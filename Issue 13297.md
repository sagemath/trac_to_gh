# Issue 13297: Bugs in C3'salgorithm implementation in sage.misc.c3

archive/issues_013297.json:
```json
{
    "body": "Assignee: @nthiery\n\nCC:  sage-combinat simonking\n\nKeywords: method resolution order\n\nThe current implementation of C3's algorithm in sage.misc.c3 (which is\nused to compute the list of all the super categories of a category) is\nincorrect.\n\nDefine indeed the following classes::\n\n```\nsage: class C(object): pass\n....: \nsage: class F(object): pass\n....: \nsage: class G(object): pass\n....: \nsage: class B(C,F): pass\n....: \nsage: class D(F,G): pass\n....: \nsage: class E(F): pass\n....: \nsage: class A(B,D,E): pass\n....: \n```\n\nWhich gives the following mro:\n\n\n```\nsage: A.mro()\n[<class '__main__.A'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.D'>, <class '__main__.E'>, <class '__main__.F'>, <class '__main__.G'>, <type 'object'>]\n```\n\n\nHere is now the same hierarchy using categories::\n\n```\nclass Cs(Category): \n    def super_categories(self): return []\n\nclass Fs(Category): \n    def super_categories(self): return []\n\nclass Gs(Category): \n    def super_categories(self): return []\n\nclass Bs(Category): \n    def super_categories(self): return [Cs(), Fs()]\n\nclass Ds(Category): \n    def super_categories(self): return [Fs(), Gs()]\n\nclass Es(Category): \n    def super_categories(self): return [Fs()]\n\nclass As(Category): \n    def super_categories(self): return [Bs(), Ds(), Es()]\n```\n\n\nThe super categories are not given in the same order (g,e,f instead of\ne f g)::\n\n```\nsage: As().all_super_categories()\n[Category of as, Category of bs, Category of cs, Category of ds, Category of gs, Category of es, Category of fs]\n```\n\n\nThis is due to popping X from the tail too early around line 186: O is\na candidate for being the next in line, but has not yet been\ndefinitely chosen.\n\n\nAnd indeed this is caught by the test suite::\n\n```\nsage: TestSuite(As()).run()\nFailure in _test_category_graph:\nTraceback (most recent call last):\n...\nAssertionError: False is not true\n```\n\n\nHere is another hierarchy with an inconsistent MRO which is not\ndetected by Sage's current C3::\n\n```\nclass B(object): pass\n\nclass C(B): pass\n\nclass A(B, C): pass\n\nTraceback (most recent call last):\n  File \"<ipython console>\", line 1, in <module>\nTypeError: Error when calling the metaclass bases\n    Cannot create a consistent method resolution\norder (MRO) for bases C, B\n```\n\n\n\n```\nclass Bs(Category): \n    def super_categories(self): return []\n\nclass Cs(Category): \n    def super_categories(self): return [Bs()]\n\nclass As(Category): \n    def super_categories(self): return [Bs(), Cs()]\n    class subcategory_class(object): # just to bypass the MRO error when building the subcategory class\n        pass\n\nsage: As()\nCategory of as\nsage: As().all_super_categories()\n[Category of as, Category of cs, Category of bs]\n```\n\n\n\nHere the issue comes from the fact that the C3 algorithm is supposed\nto work on the mro's of the bases *together with* the list of the\nbases, which the current Sage's implementation does not.\n\nIssue created by migration from https://trac.sagemath.org/ticket/13501\n\n",
    "created_at": "2012-09-17T10:59:32Z",
    "labels": [
        "component: categories",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.5",
    "title": "Bugs in C3'salgorithm implementation in sage.misc.c3",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13297",
    "user": "https://github.com/nthiery"
}
```
Assignee: @nthiery

CC:  sage-combinat simonking

Keywords: method resolution order

The current implementation of C3's algorithm in sage.misc.c3 (which is
used to compute the list of all the super categories of a category) is
incorrect.

Define indeed the following classes::

```
sage: class C(object): pass
....: 
sage: class F(object): pass
....: 
sage: class G(object): pass
....: 
sage: class B(C,F): pass
....: 
sage: class D(F,G): pass
....: 
sage: class E(F): pass
....: 
sage: class A(B,D,E): pass
....: 
```

Which gives the following mro:


```
sage: A.mro()
[<class '__main__.A'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.D'>, <class '__main__.E'>, <class '__main__.F'>, <class '__main__.G'>, <type 'object'>]
```


Here is now the same hierarchy using categories::

```
class Cs(Category): 
    def super_categories(self): return []

class Fs(Category): 
    def super_categories(self): return []

class Gs(Category): 
    def super_categories(self): return []

class Bs(Category): 
    def super_categories(self): return [Cs(), Fs()]

class Ds(Category): 
    def super_categories(self): return [Fs(), Gs()]

class Es(Category): 
    def super_categories(self): return [Fs()]

class As(Category): 
    def super_categories(self): return [Bs(), Ds(), Es()]
```


The super categories are not given in the same order (g,e,f instead of
e f g)::

```
sage: As().all_super_categories()
[Category of as, Category of bs, Category of cs, Category of ds, Category of gs, Category of es, Category of fs]
```


This is due to popping X from the tail too early around line 186: O is
a candidate for being the next in line, but has not yet been
definitely chosen.


And indeed this is caught by the test suite::

```
sage: TestSuite(As()).run()
Failure in _test_category_graph:
Traceback (most recent call last):
...
AssertionError: False is not true
```


Here is another hierarchy with an inconsistent MRO which is not
detected by Sage's current C3::

```
class B(object): pass

class C(B): pass

class A(B, C): pass

Traceback (most recent call last):
  File "<ipython console>", line 1, in <module>
TypeError: Error when calling the metaclass bases
    Cannot create a consistent method resolution
order (MRO) for bases C, B
```



```
class Bs(Category): 
    def super_categories(self): return []

class Cs(Category): 
    def super_categories(self): return [Bs()]

class As(Category): 
    def super_categories(self): return [Bs(), Cs()]
    class subcategory_class(object): # just to bypass the MRO error when building the subcategory class
        pass

sage: As()
Category of as
sage: As().all_super_categories()
[Category of as, Category of cs, Category of bs]
```



Here the issue comes from the fact that the C3 algorithm is supposed
to work on the mro's of the bases *together with* the list of the
bases, which the current Sage's implementation does not.

Issue created by migration from https://trac.sagemath.org/ticket/13501





---

archive/issue_comments_162975.json:
```json
{
    "body": "Hi Simon,\n\nI'll be working on this ticket today or so. We are currently exploring with Florent the theoretical limits of C3, and ways to fix the MRO issues once for all for categories. For that, we need a clean C3 implementation for further instrumentation. More on that topic on sage-combinat-devel shortly!",
    "created_at": "2012-09-17T11:02:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162975",
    "user": "https://github.com/nthiery"
}
```

Hi Simon,

I'll be working on this ticket today or so. We are currently exploring with Florent the theoretical limits of C3, and ways to fix the MRO issues once for all for categories. For that, we need a clean C3 implementation for further instrumentation. More on that topic on sage-combinat-devel shortly!



---

archive/issue_comments_162976.json:
```json
{
    "body": "Here is a preliminary patch. It fixes the bug and simplifies a bit the logic. I now need to benchmark it, and reintroduce a couple PyList... where timings will call for it.",
    "created_at": "2012-09-17T16:04:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162976",
    "user": "https://github.com/nthiery"
}
```

Here is a preliminary patch. It fixes the bug and simplifies a bit the logic. I now need to benchmark it, and reintroduce a couple PyList... where timings will call for it.



---

archive/issue_comments_162977.json:
```json
{
    "body": "Hi!\n\nI optimized and cleaned a bit the code; here are some timings, using the following for benchmarking (better suggestions welcome):\n\n```\nsage: l = GradedHopfAlgebrasWithBasis(GF(3)).all_super_categories() # to force preloading everything\nsage: def f(n):\n...       for i in range(5,n+5):\n...            GradedHopfAlgebras(GF(nth_prime(i))).all_super_categories()\n```\n\n\nBefore:\n\n```\nsage: %prun f(200)\n...\n2800/200    0.189    0.000    1.298    0.006 {sage.misc.c3.C3_algorithm}\n```\n\n\nWith [attachment:trac_13501-categories-c3_fix-nt.patch]:\n\n```\nsage: %prun f(200)\n...\n 2800/200    0.249    0.000    1.430    0.007 {sage.misc.c3.C3_algorithm}\n```\n\n\nWith further [attachment:trac_13501-categories-c3_fix-useless_optimization-nt.patch]:\n\n```\nsage: %prun f(200)\n...\n 2800/200    0.249    0.000    1.429    0.007 {sage.misc.c3.C3_algorithm}\n```\n\n\nSo, we have a 15% loss compared to the previous implementation. I am\nnot sure exactly where it's slower, but I guess it's just the price\nfor correctness (the previous implementation was popping out stuff too\nearly). As the second attachment shows, using PyList_GET_ITEM and\nfriends does not seem to bring anything substantial, so I'd vote for\nsticking to more readable Python notations.\n\n**Apply**:\n* [attachment:trac_13501-categories-c3_fix-nt.patch]\n\nSimon: let me know in case you are busy, I can possibly ask Florent for the review.",
    "created_at": "2012-09-18T09:58:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162977",
    "user": "https://github.com/nthiery"
}
```

Hi!

I optimized and cleaned a bit the code; here are some timings, using the following for benchmarking (better suggestions welcome):

```
sage: l = GradedHopfAlgebrasWithBasis(GF(3)).all_super_categories() # to force preloading everything
sage: def f(n):
...       for i in range(5,n+5):
...            GradedHopfAlgebras(GF(nth_prime(i))).all_super_categories()
```


Before:

```
sage: %prun f(200)
...
2800/200    0.189    0.000    1.298    0.006 {sage.misc.c3.C3_algorithm}
```


With [attachment:trac_13501-categories-c3_fix-nt.patch]:

```
sage: %prun f(200)
...
 2800/200    0.249    0.000    1.430    0.007 {sage.misc.c3.C3_algorithm}
```


With further [attachment:trac_13501-categories-c3_fix-useless_optimization-nt.patch]:

```
sage: %prun f(200)
...
 2800/200    0.249    0.000    1.429    0.007 {sage.misc.c3.C3_algorithm}
```


So, we have a 15% loss compared to the previous implementation. I am
not sure exactly where it's slower, but I guess it's just the price
for correctness (the previous implementation was popping out stuff too
early). As the second attachment shows, using PyList_GET_ITEM and
friends does not seem to bring anything substantial, so I'd vote for
sticking to more readable Python notations.

**Apply**:
* [attachment:trac_13501-categories-c3_fix-nt.patch]

Simon: let me know in case you are busy, I can possibly ask Florent for the review.



---

archive/issue_comments_162978.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2012-09-18T09:58:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162978",
    "user": "https://github.com/nthiery"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_162979.json:
```json
{
    "body": "I'll see whether using the low-level functions `PyList_GET_ITEM` and friends will help to reduce the slow-down. After all, when doing `tailsets[j]`, we already now that `j` is not out of bounds. Hence, we can drop the checks done in `O in tailsets[j]` and could as well do `O in <set>PyList_GET_ITEM(tailsets, j)`.",
    "created_at": "2012-09-18T10:07:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162979",
    "user": "https://github.com/simon-king-jena"
}
```

I'll see whether using the low-level functions `PyList_GET_ITEM` and friends will help to reduce the slow-down. After all, when doing `tailsets[j]`, we already now that `j` is not out of bounds. Hence, we can drop the checks done in `O in tailsets[j]` and could as well do `O in <set>PyList_GET_ITEM(tailsets, j)`.



---

archive/issue_comments_162980.json:
```json
{
    "body": "Replying to [comment:5 SimonKing]:\n> I'll see whether using the low-level functions `PyList_GET_ITEM` and friends will help to reduce the slow-down. After all, when doing `tailsets[j]`, we already now that `j` is not out of bounds. Hence, we can drop the checks done in `O in tailsets[j]` and could as well do `O in <set>PyList_GET_ITEM(tailsets, j)`.\n\nOr perhaps this would be even faster: `PySet_Contains(<object>PyList_GET_ITEM(tailsets, j), O) is int(1)`. Let me do some tests...",
    "created_at": "2012-09-18T10:11:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162980",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:5 SimonKing]:
> I'll see whether using the low-level functions `PyList_GET_ITEM` and friends will help to reduce the slow-down. After all, when doing `tailsets[j]`, we already now that `j` is not out of bounds. Hence, we can drop the checks done in `O in tailsets[j]` and could as well do `O in <set>PyList_GET_ITEM(tailsets, j)`.

Or perhaps this would be even faster: `PySet_Contains(<object>PyList_GET_ITEM(tailsets, j), O) is int(1)`. Let me do some tests...



---

archive/issue_comments_162981.json:
```json
{
    "body": "Replying to [comment:6 SimonKing]:\n> Replying to [comment:5 SimonKing]:\n> > I'll see whether using the low-level functions `PyList_GET_ITEM` and friends will help to reduce the slow-down. After all, when doing `tailsets[j]`, we already now that `j` is not out of bounds. Hence, we can drop the checks done in `O in tailsets[j]` and could as well do `O in <set>PyList_GET_ITEM(tailsets, j)`.\n> \n> Or perhaps this would be even faster: `PySet_Contains(<object>PyList_GET_ITEM(tailsets, j), O) is int(1)`. Let me do some tests...\n\nThat's basically what the second patch does, and it does not seem to do much of a change. But feel free to explore!",
    "created_at": "2012-09-18T10:18:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162981",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:6 SimonKing]:
> Replying to [comment:5 SimonKing]:
> > I'll see whether using the low-level functions `PyList_GET_ITEM` and friends will help to reduce the slow-down. After all, when doing `tailsets[j]`, we already now that `j` is not out of bounds. Hence, we can drop the checks done in `O in tailsets[j]` and could as well do `O in <set>PyList_GET_ITEM(tailsets, j)`.
> 
> Or perhaps this would be even faster: `PySet_Contains(<object>PyList_GET_ITEM(tailsets, j), O) is int(1)`. Let me do some tests...

That's basically what the second patch does, and it does not seem to do much of a change. But feel free to explore!



---

archive/issue_comments_162982.json:
```json
{
    "body": "Another optimization:\n\n```\nfor j from 0 <= j < nbheads: \n    if j == i: \n        continue \n    if O in tailsets[j]: \n        next_item_found = False \nif next_item_found: \n    ...\n```\n\nApparently, after the line `next_item_found = False`, one should insert a `break`, because otherwise the loop is finished to no avail.",
    "created_at": "2012-09-18T10:19:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162982",
    "user": "https://github.com/simon-king-jena"
}
```

Another optimization:

```
for j from 0 <= j < nbheads: 
    if j == i: 
        continue 
    if O in tailsets[j]: 
        next_item_found = False 
if next_item_found: 
    ...
```

Apparently, after the line `next_item_found = False`, one should insert a `break`, because otherwise the loop is finished to no avail.



---

archive/issue_comments_162983.json:
```json
{
    "body": "Replying to [comment:7 nthiery]:\n> > Or perhaps this would be even faster: `PySet_Contains(<object>PyList_GET_ITEM(tailsets, j), O) is int(1)`. Let me do some tests...\n> \n> That's basically what the second patch does, and it does not seem to do much of a change. But feel free to explore!\n\nSorry, I didn't look at the second patch. Yes, if that doesn't help, it would probably be useless. But I think breaking the loop would make sense.",
    "created_at": "2012-09-18T10:21:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162983",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:7 nthiery]:
> > Or perhaps this would be even faster: `PySet_Contains(<object>PyList_GET_ITEM(tailsets, j), O) is int(1)`. Let me do some tests...
> 
> That's basically what the second patch does, and it does not seem to do much of a change. But feel free to explore!

Sorry, I didn't look at the second patch. Yes, if that doesn't help, it would probably be useless. But I think breaking the loop would make sense.



---

archive/issue_comments_162984.json:
```json
{
    "body": "Replying to [comment:8 SimonKing]:\n> Another optimization:\n> {{{\n> for j from 0 <= j < nbheads: \n>     if j == i: \n>         continue \n>     if O in tailsets[j]: \n>         next_item_found = False \n> if next_item_found: \n>     ...\n> }}}\n> Apparently, after the line `next_item_found = False`, one should insert a `break`, because otherwise the loop is finished to no avail.\n\nGood point; I am trying it right now!",
    "created_at": "2012-09-18T10:25:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162984",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:8 SimonKing]:
> Another optimization:
> {{{
> for j from 0 <= j < nbheads: 
>     if j == i: 
>         continue 
>     if O in tailsets[j]: 
>         next_item_found = False 
> if next_item_found: 
>     ...
> }}}
> Apparently, after the line `next_item_found = False`, one should insert a `break`, because otherwise the loop is finished to no avail.

Good point; I am trying it right now!



---

archive/issue_comments_162985.json:
```json
{
    "body": "Yes, the effect of using the C Api really seems marginal. I defined\n\n```\ndef test_pythonic(O,list L):\n    cdef int j \n    cdef int l = len(L)\n    next_item_found = True\n    for j from 0 <= j < l:\n        if O in L[j]:\n            next_item_found = False\n            \ndef test_cythonic(O, list L):\n    cdef int j\n    cdef int l = len(L)\n    next_item_found = True\n    for j from 0 <= j < l:\n        if PySet_Contains(<object>PyList_GET_ITEM(L, j), O):\n            next_item_found = True\n```\n\nand obtained:\n\n```\nsage: L = [set(range(i,i+1000)) for i in range(1000)]\nsage: %timeit test_pythonic(1001,L)\n625 loops, best of 3: 116 \u00b5s per loop\nsage: %timeit test_cythonic(1001,L)\n625 loops, best of 3: 111 \u00b5s per loop\n```\n",
    "created_at": "2012-09-18T10:30:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162985",
    "user": "https://github.com/simon-king-jena"
}
```

Yes, the effect of using the C Api really seems marginal. I defined

```
def test_pythonic(O,list L):
    cdef int j 
    cdef int l = len(L)
    next_item_found = True
    for j from 0 <= j < l:
        if O in L[j]:
            next_item_found = False
            
def test_cythonic(O, list L):
    cdef int j
    cdef int l = len(L)
    next_item_found = True
    for j from 0 <= j < l:
        if PySet_Contains(<object>PyList_GET_ITEM(L, j), O):
            next_item_found = True
```

and obtained:

```
sage: L = [set(range(i,i+1000)) for i in range(1000)]
sage: %timeit test_pythonic(1001,L)
625 loops, best of 3: 116 µs per loop
sage: %timeit test_cythonic(1001,L)
625 loops, best of 3: 111 µs per loop
```




---

archive/issue_comments_162986.json:
```json
{
    "body": "PS: The difference being 5%, one could still argue that 5% is the lowest number that is called \"significant\".",
    "created_at": "2012-09-18T10:32:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162986",
    "user": "https://github.com/simon-king-jena"
}
```

PS: The difference being 5%, one could still argue that 5% is the lowest number that is called "significant".



---

archive/issue_comments_162987.json:
```json
{
    "body": "Replying to [comment:10 nthiery]:\n> > Apparently, after the line `next_item_found = False`, one should insert a `break`, because otherwise the loop is finished to no avail.\n> \n> Good point; I am trying it right now!\n\nHere it is: without the break:\n\n```\n 2800/200    0.247    0.000    1.417    0.007 {sage.misc.c3.C3_algorithm}\n```\n\n\nwith the break:\n\n```\n 2800/200    0.243    0.000    1.413    0.007 {sage.misc.c3.C3_algorithm}\n```\n\n\nTiny difference, but it's natural to put it here anyway. I am about to\nupdate the patch.\n\nNote: I switched from 5.2 to 5.3 in the mean time, so the timings from this comment can't really be compared with the timings before.\n\nCheers,\n                             Nicolas",
    "created_at": "2012-09-18T13:22:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162987",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:10 nthiery]:
> > Apparently, after the line `next_item_found = False`, one should insert a `break`, because otherwise the loop is finished to no avail.
> 
> Good point; I am trying it right now!

Here it is: without the break:

```
 2800/200    0.247    0.000    1.417    0.007 {sage.misc.c3.C3_algorithm}
```


with the break:

```
 2800/200    0.243    0.000    1.413    0.007 {sage.misc.c3.C3_algorithm}
```


Tiny difference, but it's natural to put it here anyway. I am about to
update the patch.

Note: I switched from 5.2 to 5.3 in the mean time, so the timings from this comment can't really be compared with the timings before.

Cheers,
                             Nicolas



---

archive/issue_comments_162988.json:
```json
{
    "body": "For the record: With sage-5.4.beta0 and\n\n```\ntrac_715_combined.patch\ntrac_715_local_refcache.patch\ntrac_715_safer.patch\ntrac_715_specification.patch\ntrac_11521_homset_weakcache_combined.patch\ntrac_11521_callback.patch\n13145.patch\ntrac_13447-sanitise_ring_refcount.patch\ntrac12215_weak_cached_function-sk.patch\ntrac12215_segfault_fixes.patch\ntrac_12313-mono_dict-combined-random-sk.patch\ntrac_12313_quit_sage.patch\ntrac13370_deprecate_is_field.patch\ntrac_13378-convert_map_shortcut.patch\ntrac_13412_category_for_power_series_rings.patch\n```\n\nand with `%prun f(500)` (because 200 may not be enough), I get\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 7000/500    0.212    0.000    0.773    0.002 {sage.misc.c3.C3_algorithm}\n```\n\n\nAdding your main patch, I get\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 7000/500    0.307    0.000    0.848    0.002 {sage.misc.c3.C3_algorithm}\n```\n\n\nAnd with the optimization patch, I get\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 7000/500    0.304    0.000    0.853    0.002 {sage.misc.c3.C3_algorithm}\n```\n\n\nSo, the slow-down is little and using the C Api is not noticeable.",
    "created_at": "2012-09-18T14:18:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162988",
    "user": "https://github.com/simon-king-jena"
}
```

For the record: With sage-5.4.beta0 and

```
trac_715_combined.patch
trac_715_local_refcache.patch
trac_715_safer.patch
trac_715_specification.patch
trac_11521_homset_weakcache_combined.patch
trac_11521_callback.patch
13145.patch
trac_13447-sanitise_ring_refcount.patch
trac12215_weak_cached_function-sk.patch
trac12215_segfault_fixes.patch
trac_12313-mono_dict-combined-random-sk.patch
trac_12313_quit_sage.patch
trac13370_deprecate_is_field.patch
trac_13378-convert_map_shortcut.patch
trac_13412_category_for_power_series_rings.patch
```

and with `%prun f(500)` (because 200 may not be enough), I get

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 7000/500    0.212    0.000    0.773    0.002 {sage.misc.c3.C3_algorithm}
```


Adding your main patch, I get

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 7000/500    0.307    0.000    0.848    0.002 {sage.misc.c3.C3_algorithm}
```


And with the optimization patch, I get

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 7000/500    0.304    0.000    0.853    0.002 {sage.misc.c3.C3_algorithm}
```


So, the slow-down is little and using the C Api is not noticeable.



---

archive/issue_comments_162989.json:
```json
{
    "body": "With a little cdef'ing, namely\n\n```diff\ndiff --git a/sage/misc/c3.pyx b/sage/misc/c3.pyx\n--- a/sage/misc/c3.pyx\n+++ b/sage/misc/c3.pyx\n@@ -196,6 +196,8 @@\n     nbheads = len(heads)\n     cdef object O, X\n     cdef bint next_item_found\n+    cdef set tail_set\n+    cdef list tail_list\n\n     while nbheads:\n         for i from 0 <= i < nbheads:\n@@ -205,7 +207,8 @@\n             for j from 0 <= j < nbheads:\n                 if j == i:\n                     continue\n-                if O in tailsets[j]:\n+                tail_set = tailsets[j]\n+                if O in tail_set:\n                     next_item_found = False\n                     break\n             if next_item_found:\n@@ -215,11 +218,13 @@\n                 # j goes down so that ``del heads[j]`` does not screw up the numbering\n                 for j from nbheads > j >= 0:\n                     if heads[j] is O:\n-                        try:\n-                            X = tails[j].pop()\n+                        tail_list = tails[j]\n+                        if tail_list:\n+                            X = tail_list.pop()\n                             heads[j] = X\n-                            tailsets[j].remove(X)\n-                        except IndexError:\n+                            tail_set = tailsets[j]\n+                            tail_set.remove(X)\n+                        else:\n                             del heads[j]\n                             del tails[j]\n                             del tailsets[j]\n```\n\nI get\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 7000/500    0.277    0.000    0.819    0.002 {sage.misc.c3.C3_algorithm}\n```\n\n\nThe differences really are tiny. However, here is why I removed the `try: ... except IndexError:`:\n\n```\nsage: cython(\"\"\"\n....: def test1(list L):\n....:     cdef list l\n....:     for l in L:\n....:         try:\n....:             l.pop()\n....:         except IndexError:\n....:             l.append(0)\n....: def test2(list L):\n....:     cdef list l\n....:     for l in L:\n....:         if l:\n....:             l.pop()\n....:         else:\n....:             l.append(0)\n....: \"\"\")        \nsage: L = [[] for _ in range(10000)]\nsage: %timeit test1(L)\n125 loops, best of 3: 7.07 ms per loop\nsage: L = [[] for _ in range(10000)]\nsage: %timeit test2(L)\n125 loops, best of 3: 1.94 ms per loop\n```\n",
    "created_at": "2012-09-18T14:38:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162989",
    "user": "https://github.com/simon-king-jena"
}
```

With a little cdef'ing, namely

```diff
diff --git a/sage/misc/c3.pyx b/sage/misc/c3.pyx
--- a/sage/misc/c3.pyx
+++ b/sage/misc/c3.pyx
@@ -196,6 +196,8 @@
     nbheads = len(heads)
     cdef object O, X
     cdef bint next_item_found
+    cdef set tail_set
+    cdef list tail_list

     while nbheads:
         for i from 0 <= i < nbheads:
@@ -205,7 +207,8 @@
             for j from 0 <= j < nbheads:
                 if j == i:
                     continue
-                if O in tailsets[j]:
+                tail_set = tailsets[j]
+                if O in tail_set:
                     next_item_found = False
                     break
             if next_item_found:
@@ -215,11 +218,13 @@
                 # j goes down so that ``del heads[j]`` does not screw up the numbering
                 for j from nbheads > j >= 0:
                     if heads[j] is O:
-                        try:
-                            X = tails[j].pop()
+                        tail_list = tails[j]
+                        if tail_list:
+                            X = tail_list.pop()
                             heads[j] = X
-                            tailsets[j].remove(X)
-                        except IndexError:
+                            tail_set = tailsets[j]
+                            tail_set.remove(X)
+                        else:
                             del heads[j]
                             del tails[j]
                             del tailsets[j]
```

I get

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 7000/500    0.277    0.000    0.819    0.002 {sage.misc.c3.C3_algorithm}
```


The differences really are tiny. However, here is why I removed the `try: ... except IndexError:`:

```
sage: cython("""
....: def test1(list L):
....:     cdef list l
....:     for l in L:
....:         try:
....:             l.pop()
....:         except IndexError:
....:             l.append(0)
....: def test2(list L):
....:     cdef list l
....:     for l in L:
....:         if l:
....:             l.pop()
....:         else:
....:             l.append(0)
....: """)        
sage: L = [[] for _ in range(10000)]
sage: %timeit test1(L)
125 loops, best of 3: 7.07 ms per loop
sage: L = [[] for _ in range(10000)]
sage: %timeit test2(L)
125 loops, best of 3: 1.94 ms per loop
```




---

archive/issue_comments_162990.json:
```json
{
    "body": "Another thought: We want to compare the entries on the list by identity, not by equality, isn't it? But isn't then `if O in tail_set` unnecessarily slow, because it compares by equality rather than identity?\n\nI wonder if one could instrument `MonoDict` from #12313.",
    "created_at": "2012-09-18T14:45:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162990",
    "user": "https://github.com/simon-king-jena"
}
```

Another thought: We want to compare the entries on the list by identity, not by equality, isn't it? But isn't then `if O in tail_set` unnecessarily slow, because it compares by equality rather than identity?

I wonder if one could instrument `MonoDict` from #12313.



---

archive/issue_comments_162991.json:
```json
{
    "body": "Replying to [comment:17 SimonKing]:\n> I wonder if one could instrument `MonoDict` from #12313.\n\nI tested: `MonoDict` is slower than a set. But if we want to compare by identity, then perhaps the tailsets should store the memory addresses of the objects, rather than the objects?",
    "created_at": "2012-09-18T14:53:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162991",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:17 SimonKing]:
> I wonder if one could instrument `MonoDict` from #12313.

I tested: `MonoDict` is slower than a set. But if we want to compare by identity, then perhaps the tailsets should store the memory addresses of the objects, rather than the objects?



---

archive/issue_comments_162992.json:
```json
{
    "body": "Remove assignee @nthiery.",
    "created_at": "2012-09-18T15:00:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162992",
    "user": "https://github.com/simon-king-jena"
}
```

Remove assignee @nthiery.



---

archive/issue_comments_162993.json:
```json
{
    "body": "Here is evidence that using a set of memory locations is way faster than a set of objects, if what we actually want is comparison by identity.\n\nNamely:\n\n```\nsage: cython(\"\"\"\n....: def test1(set S, object O):\n....:     return O in S\n....: def test2(set S, object O):\n....:     return <size_t><void *>O in S\n....: \"\"\")\nsage: S = set(Algebras(GF(p)) for p in prime_range(10000))\nsage: Sid = set(id(O) for O in S)\nsage: len(S)\n1229\nsage: len(Sid)\n1229\nsage: O = Algebras(GF(151))\nsage: test1(S,O)\nTrue\nsage: test2(Sid,O)\nTrue\nsage: %timeit test1(S,O)\n625 loops, best of 3: 507 ns per loop\nsage: %timeit test2(Sid,O)\n625 loops, best of 3: 186 ns per loop\n```\n",
    "created_at": "2012-09-18T15:00:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162993",
    "user": "https://github.com/simon-king-jena"
}
```

Here is evidence that using a set of memory locations is way faster than a set of objects, if what we actually want is comparison by identity.

Namely:

```
sage: cython("""
....: def test1(set S, object O):
....:     return O in S
....: def test2(set S, object O):
....:     return <size_t><void *>O in S
....: """)
sage: S = set(Algebras(GF(p)) for p in prime_range(10000))
sage: Sid = set(id(O) for O in S)
sage: len(S)
1229
sage: len(Sid)
1229
sage: O = Algebras(GF(151))
sage: test1(S,O)
True
sage: test2(Sid,O)
True
sage: %timeit test1(S,O)
625 loops, best of 3: 507 ns per loop
sage: %timeit test2(Sid,O)
625 loops, best of 3: 186 ns per loop
```




---

archive/issue_comments_162994.json:
```json
{
    "body": "Using `<size_t><void *>` rather than the objects seems to work, speed-wise! With your benchmark, I get\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 7000/500    0.197    0.000    0.671    0.001 {sage.misc.c3.C3_algorithm}\n```\n\nusing the following patch:\n\n```diff\ndiff --git a/sage/misc/c3.pyx b/sage/misc/c3.pyx\n--- a/sage/misc/c3.pyx\n+++ b/sage/misc/c3.pyx\n@@ -186,16 +186,20 @@\n     # ``tails'') . Each tail is stored reversed, so that we can use a\n     # cheap pop() in lieue of pop(0). A duplicate of the tail is\n     # stored as a set in ``tailsets`` for cheap membership testing.\n+    # Since we actually want comparison by identity, not equality,\n+    # what we store is the set of memory locations of objects\n+    cdef object O, X\n     cdef list tails = [getattr(obj, attribute) for obj in args]\n     tails.append(args)\n-    tails              = [list(reversed(tail)) for tail in tails]\n-    cdef list heads    = [tail.pop()           for tail in tails]\n-    cdef list tailsets = [set(tail)            for tail in tails]\n+    tails              = [list(reversed(tail))     for tail in tails]\n+    cdef list heads    = [tail.pop()               for tail in tails]\n+    cdef list tailsets = [set([<size_t><void *>O for O in tail]) for tail in tails]\n \n     cdef int i, j, nbheads\n     nbheads = len(heads)\n-    cdef object O, X\n     cdef bint next_item_found\n+    cdef set tail_set\n+    cdef list tail_list\n \n     while nbheads:\n         for i from 0 <= i < nbheads:\n@@ -205,7 +209,8 @@\n             for j from 0 <= j < nbheads:\n                 if j == i:\n                     continue\n-                if O in tailsets[j]:\n+                tail_set = tailsets[j]\n+                if <size_t><void *>O in tail_set:\n                     next_item_found = False\n                     break\n             if next_item_found:\n@@ -215,11 +220,13 @@\n                 # j goes down so that ``del heads[j]`` does not screw up the numbering\n                 for j from nbheads > j >= 0:\n                     if heads[j] is O:\n-                        try:\n-                            X = tails[j].pop()\n+                        tail_list = tails[j]\n+                        if tail_list:\n+                            X = tail_list.pop()\n                             heads[j] = X\n-                            tailsets[j].remove(X)\n-                        except IndexError:\n+                            tail_set = tailsets[j]\n+                            tail_set.remove(<size_t><void *>X)\n+                        else:\n                             del heads[j]\n                             del tails[j]\n                             del tailsets[j]\n```\n\n\nI am now running `make ptest` with that patch, and if it works, then I'll post it here \"officially\", and we can start cross-reviewing.",
    "created_at": "2012-09-18T15:10:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162994",
    "user": "https://github.com/simon-king-jena"
}
```

Using `<size_t><void *>` rather than the objects seems to work, speed-wise! With your benchmark, I get

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 7000/500    0.197    0.000    0.671    0.001 {sage.misc.c3.C3_algorithm}
```

using the following patch:

```diff
diff --git a/sage/misc/c3.pyx b/sage/misc/c3.pyx
--- a/sage/misc/c3.pyx
+++ b/sage/misc/c3.pyx
@@ -186,16 +186,20 @@
     # ``tails'') . Each tail is stored reversed, so that we can use a
     # cheap pop() in lieue of pop(0). A duplicate of the tail is
     # stored as a set in ``tailsets`` for cheap membership testing.
+    # Since we actually want comparison by identity, not equality,
+    # what we store is the set of memory locations of objects
+    cdef object O, X
     cdef list tails = [getattr(obj, attribute) for obj in args]
     tails.append(args)
-    tails              = [list(reversed(tail)) for tail in tails]
-    cdef list heads    = [tail.pop()           for tail in tails]
-    cdef list tailsets = [set(tail)            for tail in tails]
+    tails              = [list(reversed(tail))     for tail in tails]
+    cdef list heads    = [tail.pop()               for tail in tails]
+    cdef list tailsets = [set([<size_t><void *>O for O in tail]) for tail in tails]
 
     cdef int i, j, nbheads
     nbheads = len(heads)
-    cdef object O, X
     cdef bint next_item_found
+    cdef set tail_set
+    cdef list tail_list
 
     while nbheads:
         for i from 0 <= i < nbheads:
@@ -205,7 +209,8 @@
             for j from 0 <= j < nbheads:
                 if j == i:
                     continue
-                if O in tailsets[j]:
+                tail_set = tailsets[j]
+                if <size_t><void *>O in tail_set:
                     next_item_found = False
                     break
             if next_item_found:
@@ -215,11 +220,13 @@
                 # j goes down so that ``del heads[j]`` does not screw up the numbering
                 for j from nbheads > j >= 0:
                     if heads[j] is O:
-                        try:
-                            X = tails[j].pop()
+                        tail_list = tails[j]
+                        if tail_list:
+                            X = tail_list.pop()
                             heads[j] = X
-                            tailsets[j].remove(X)
-                        except IndexError:
+                            tail_set = tailsets[j]
+                            tail_set.remove(<size_t><void *>X)
+                        else:
                             del heads[j]
                             del tails[j]
                             del tailsets[j]
```


I am now running `make ptest` with that patch, and if it works, then I'll post it here "officially", and we can start cross-reviewing.



---

archive/issue_comments_162995.json:
```json
{
    "body": "PS: Note that according to the timing from my previous post, my patch would even yield a small speed-up, compared with vanilla sage.",
    "created_at": "2012-09-18T15:14:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162995",
    "user": "https://github.com/simon-king-jena"
}
```

PS: Note that according to the timing from my previous post, my patch would even yield a small speed-up, compared with vanilla sage.



---

archive/issue_comments_162996.json:
```json
{
    "body": "It seems to work!\n\nHence, time for a cross-review...\n\nApply trac_13501-categories-c3_fix-nt.patch trac_13501-c3-speedup-sk.patch",
    "created_at": "2012-09-18T15:42:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162996",
    "user": "https://github.com/simon-king-jena"
}
```

It seems to work!

Hence, time for a cross-review...

Apply trac_13501-categories-c3_fix-nt.patch trac_13501-c3-speedup-sk.patch



---

archive/issue_comments_162997.json:
```json
{
    "body": "Replying to [comment:22 SimonKing]:\n> It seems to work!\n> \n> Hence, time for a cross-review...\n> \n> Apply trac_13501-categories-c3_fix-nt.patch trac_13501-c3-speedup-sk.patch\n\nI am almost ready for a postive review (assuming the patchbot goes green). Two little questions: what happens if\n\n- we use id(cat) rather than the obscure <size_t><void *> cat ?\n\n- we use ``O in <set>tailsets[j]`` rather than assigning to a temporary variable?\n\nIn both cases, if the speed is roughly equivalent, then I vote for the more readable version.\n\nCheers,",
    "created_at": "2012-09-18T16:08:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162997",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:22 SimonKing]:
> It seems to work!
> 
> Hence, time for a cross-review...
> 
> Apply trac_13501-categories-c3_fix-nt.patch trac_13501-c3-speedup-sk.patch

I am almost ready for a postive review (assuming the patchbot goes green). Two little questions: what happens if

- we use id(cat) rather than the obscure <size_t><void *> cat ?

- we use ``O in <set>tailsets[j]`` rather than assigning to a temporary variable?

In both cases, if the speed is roughly equivalent, then I vote for the more readable version.

Cheers,



---

archive/issue_comments_162998.json:
```json
{
    "body": "Replying to [comment:23 nthiery]:\n> I am almost ready for a postive review (assuming the patchbot goes green).\n\nWill it ever go green? Does the patchbot work at all.\n\n> Two little questions: what happens if\n> \n> - we use id(cat) rather than the obscure <size_t><void *> cat ?\n> \n> - we use ``O in <set>tailsets[j]`` rather than assigning to a temporary variable?\n\nI guess you mean `id(O) in <set>tailsets[j]`?\n\nOne obtains\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 7000/500    0.207    0.000    0.672    0.001 {sage.misc.c3.C3_algorithm}\n```\n\ninstead of\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 7000/500    0.196    0.000    0.663    0.001 {sage.misc.c3.C3_algorithm}\n```\n\n\n> In both cases, if the speed is roughly equivalent, then I vote for the more readable version.\n\nIs the difference (again 5%) marginal? Anyway, I can only do it tomorrow.",
    "created_at": "2012-09-18T18:23:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162998",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:23 nthiery]:
> I am almost ready for a postive review (assuming the patchbot goes green).

Will it ever go green? Does the patchbot work at all.

> Two little questions: what happens if
> 
> - we use id(cat) rather than the obscure <size_t><void *> cat ?
> 
> - we use ``O in <set>tailsets[j]`` rather than assigning to a temporary variable?

I guess you mean `id(O) in <set>tailsets[j]`?

One obtains

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 7000/500    0.207    0.000    0.672    0.001 {sage.misc.c3.C3_algorithm}
```

instead of

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
 7000/500    0.196    0.000    0.663    0.001 {sage.misc.c3.C3_algorithm}
```


> In both cases, if the speed is roughly equivalent, then I vote for the more readable version.

Is the difference (again 5%) marginal? Anyway, I can only do it tomorrow.



---

archive/issue_comments_162999.json:
```json
{
    "body": "The following \"raw data\" should advise us what syntax to use.\n\nI defined\n\n```\ninclude \"sage/ext/python_list.pxi\"\n\ndef test1(list L, object O):\n    cdef set S\n    cdef size_t i\n    cdef size_t l = len(L)\n    cdef bint b\n    for i from 0<=i<l:\n        S = <set>PyList_GET_ITEM(L,i)\n        b = <size_t><void *>O in S\n\ndef test2(list L, object O):\n    cdef size_t i\n    cdef size_t l = len(L)\n    cdef bint b\n    for i from 0<=i<l:\n        b = <size_t><void *>O in <set>PyList_GET_ITEM(L,i)\n\ndef test3(list L, object O):\n    cdef size_t i\n    cdef size_t l = len(L)\n    cdef bint b\n    for i from 0<=i<l:\n        b = <size_t><void *>O in <set>L[i]\n\ndef test4(list L, object O):\n    cdef size_t i\n    cdef size_t l = len(L)\n    cdef bint b\n    for i from 0<=i<l:\n        b = id(O) in <set>L[i]\n\ndef test5(list L, object O):\n    cdef size_t i\n    cdef size_t l = len(L)\n    cdef bint b\n    for i from 0<=i<l:\n        b = id(O) in <set>PyList_GET_ITEM(L,i)\n```\n\nand obtain\n\n```\nsage: L = [set(id(GF(p)) for p in prime_range(n,n+500)) for n in range(1,1000)]\nsage: O = GF(next_prime(500))\nsage: timeit(\"test1(L,O)\", number=2000)\n2000 loops, best of 3: 48.9 \u00b5s per loop\nsage: timeit(\"test2(L,O)\", number=2000)\n2000 loops, best of 3: 45.7 \u00b5s per loop\nsage: timeit(\"test3(L,O)\", number=2000)\n2000 loops, best of 3: 70.9 \u00b5s per loop\nsage: timeit(\"test4(L,O)\", number=2000)\n2000 loops, best of 3: 107 \u00b5s per loop\nsage: timeit(\"test5(L,O)\", number=2000)\n2000 loops, best of 3: 87.1 \u00b5s per loop\n```\n\n\nSo, I would say that it really matters whether or not we should do `<set>PyList_GET_ITEM(L,i)` or `<set>L[i]` (see test2 versus test3), and it also matters whether we do `<size_t><void *>O` or `id(O)` (see test3 versus test4 and test2 versus test5). Assigning to a temporary variable is not good (unless we need the same set twice, of course).\n\nSeeing these data, I think a syntax as in test2 is best. Sure, C3 does more than an element test in a list of sets. But I do think it is a critical step.",
    "created_at": "2012-09-19T10:07:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-162999",
    "user": "https://github.com/simon-king-jena"
}
```

The following "raw data" should advise us what syntax to use.

I defined

```
include "sage/ext/python_list.pxi"

def test1(list L, object O):
    cdef set S
    cdef size_t i
    cdef size_t l = len(L)
    cdef bint b
    for i from 0<=i<l:
        S = <set>PyList_GET_ITEM(L,i)
        b = <size_t><void *>O in S

def test2(list L, object O):
    cdef size_t i
    cdef size_t l = len(L)
    cdef bint b
    for i from 0<=i<l:
        b = <size_t><void *>O in <set>PyList_GET_ITEM(L,i)

def test3(list L, object O):
    cdef size_t i
    cdef size_t l = len(L)
    cdef bint b
    for i from 0<=i<l:
        b = <size_t><void *>O in <set>L[i]

def test4(list L, object O):
    cdef size_t i
    cdef size_t l = len(L)
    cdef bint b
    for i from 0<=i<l:
        b = id(O) in <set>L[i]

def test5(list L, object O):
    cdef size_t i
    cdef size_t l = len(L)
    cdef bint b
    for i from 0<=i<l:
        b = id(O) in <set>PyList_GET_ITEM(L,i)
```

and obtain

```
sage: L = [set(id(GF(p)) for p in prime_range(n,n+500)) for n in range(1,1000)]
sage: O = GF(next_prime(500))
sage: timeit("test1(L,O)", number=2000)
2000 loops, best of 3: 48.9 µs per loop
sage: timeit("test2(L,O)", number=2000)
2000 loops, best of 3: 45.7 µs per loop
sage: timeit("test3(L,O)", number=2000)
2000 loops, best of 3: 70.9 µs per loop
sage: timeit("test4(L,O)", number=2000)
2000 loops, best of 3: 107 µs per loop
sage: timeit("test5(L,O)", number=2000)
2000 loops, best of 3: 87.1 µs per loop
```


So, I would say that it really matters whether or not we should do `<set>PyList_GET_ITEM(L,i)` or `<set>L[i]` (see test2 versus test3), and it also matters whether we do `<size_t><void *>O` or `id(O)` (see test3 versus test4 and test2 versus test5). Assigning to a temporary variable is not good (unless we need the same set twice, of course).

Seeing these data, I think a syntax as in test2 is best. Sure, C3 does more than an element test in a list of sets. But I do think it is a critical step.



---

archive/issue_comments_163000.json:
```json
{
    "body": "This time, I used `%prun f(1000)` for the timings.\n\nWhen I change the syntax, as suggested in the previous post, I get\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n14000/1000    0.385    0.000    1.330    0.001 {sage.misc.c3.C3_algorithm}\n```\n\n\nWith the current version of [attachment:trac_13501-c3-speedup-sk.patch], I get\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n14000/1000    0.380    0.000    1.297    0.001 {sage.misc.c3.C3_algorithm}\n```\n\nSo, a further \"complication\" of the syntax is not good.\n\nIf I use a more readable syntax, hence replace `<sizt_t><void *>` by id and avoid the temporary variable, I get roughly 10% slow-down:\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n14000/1000    0.427    0.000    1.364    0.001 {sage.misc.c3.C3_algorithm}\n```\n\n\nWithout the optimization patch (only your main patch), I get\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n14000/1000    0.615    0.000    1.706    0.002 {sage.misc.c3.C3_algorithm}\n```\n\n\nWithout your main patch (hence, the old buggy C3 version in Sage), I get\n\n```\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n14000/1000    0.442    0.000    1.558    0.002 {sage.misc.c3.C3_algorithm}\n```\n\n\nHence, apparently the current version of my speedup patch is just fine.",
    "created_at": "2012-09-19T10:28:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163000",
    "user": "https://github.com/simon-king-jena"
}
```

This time, I used `%prun f(1000)` for the timings.

When I change the syntax, as suggested in the previous post, I get

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
14000/1000    0.385    0.000    1.330    0.001 {sage.misc.c3.C3_algorithm}
```


With the current version of [attachment:trac_13501-c3-speedup-sk.patch], I get

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
14000/1000    0.380    0.000    1.297    0.001 {sage.misc.c3.C3_algorithm}
```

So, a further "complication" of the syntax is not good.

If I use a more readable syntax, hence replace `<sizt_t><void *>` by id and avoid the temporary variable, I get roughly 10% slow-down:

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
14000/1000    0.427    0.000    1.364    0.001 {sage.misc.c3.C3_algorithm}
```


Without the optimization patch (only your main patch), I get

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
14000/1000    0.615    0.000    1.706    0.002 {sage.misc.c3.C3_algorithm}
```


Without your main patch (hence, the old buggy C3 version in Sage), I get

```
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
14000/1000    0.442    0.000    1.558    0.002 {sage.misc.c3.C3_algorithm}
```


Hence, apparently the current version of my speedup patch is just fine.



---

archive/issue_comments_163001.json:
```json
{
    "body": "Thanks for the detailed analysis! Positive review on my behalf, assuming the tests pass (I am running them now on 5.4 beta1)\n\nCheers,\n\nPS: maybe we should use the same trick for category containment using all_super_categories_as_set (if this is still in use). This also means that we should investigate whether we could optimize further UniqueRepresentation to speedify sets and dictionaries of such objects!",
    "created_at": "2012-09-19T11:55:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163001",
    "user": "https://github.com/nthiery"
}
```

Thanks for the detailed analysis! Positive review on my behalf, assuming the tests pass (I am running them now on 5.4 beta1)

Cheers,

PS: maybe we should use the same trick for category containment using all_super_categories_as_set (if this is still in use). This also means that we should investigate whether we could optimize further UniqueRepresentation to speedify sets and dictionaries of such objects!



---

archive/issue_comments_163002.json:
```json
{
    "body": "Tests results here: http://sage.math.washington.edu/home/nthiery/trac_13501-c3-speedup-sk.patch-testlog\n\nThere is a failure in sage_object, probably trivial/unrelated, but I haven't looked at it yet; I need to take of now!",
    "created_at": "2012-09-19T11:57:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163002",
    "user": "https://github.com/nthiery"
}
```

Tests results here: http://sage.math.washington.edu/home/nthiery/trac_13501-c3-speedup-sk.patch-testlog

There is a failure in sage_object, probably trivial/unrelated, but I haven't looked at it yet; I need to take of now!



---

archive/issue_comments_163003.json:
```json
{
    "body": "Replying to [comment:28 nthiery]:\n> There is a failure in sage_object, probably trivial/unrelated, but I haven't looked at it yet; I need to take of now!\n\nThe error is when unpickling stuff. In principle, a different mro could change things. On the other hand, this should only affect parent and element classes of categories - and they are pickled by construction (hence, it is not the case that the mro is stored in the pickle).\n\nAnyway, I get:\n\n```\n./sage -t devel/sage/sage/structure/sage_object.pyx \nsage -t  \"devel/sage/sage/structure/sage_object.pyx\"        \n         [11.5 s]\n \n----------------------------------------------------------------------\nAll tests passed!\nTotal time for all tests: 11.5 seconds\n```\n\nwith\n\n```\ntrac_715_combined.patch\ntrac_715_local_refcache.patch\ntrac_715_safer.patch\ntrac_715_specification.patch\ntrac_11521_homset_weakcache_combined.patch\ntrac_11521_callback.patch\n13145.patch\ntrac_13447-sanitise_ring_refcount.patch\ntrac12215_weak_cached_function-sk.patch\ntrac12215_segfault_fixes.patch\ntrac_12313-mono_dict-combined-random-sk.patch\ntrac_12313_quit_sage.patch\ntrac13370_deprecate_is_field.patch\ntrac_13378-convert_map_shortcut.patch\ntrac_13412_category_for_power_series_rings.patch\ntrac_13501-categories-c3_fix-nt.patch\ntrac_13501-c3-speedup-sk.patch\ntrac_12876_category_abstract_classes_for_hom.patch\ntrac_12876_r_test.patch\n```\n\napplied on top of sage-5.4.beta0.",
    "created_at": "2012-09-19T12:15:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163003",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:28 nthiery]:
> There is a failure in sage_object, probably trivial/unrelated, but I haven't looked at it yet; I need to take of now!

The error is when unpickling stuff. In principle, a different mro could change things. On the other hand, this should only affect parent and element classes of categories - and they are pickled by construction (hence, it is not the case that the mro is stored in the pickle).

Anyway, I get:

```
./sage -t devel/sage/sage/structure/sage_object.pyx 
sage -t  "devel/sage/sage/structure/sage_object.pyx"        
         [11.5 s]
 
----------------------------------------------------------------------
All tests passed!
Total time for all tests: 11.5 seconds
```

with

```
trac_715_combined.patch
trac_715_local_refcache.patch
trac_715_safer.patch
trac_715_specification.patch
trac_11521_homset_weakcache_combined.patch
trac_11521_callback.patch
13145.patch
trac_13447-sanitise_ring_refcount.patch
trac12215_weak_cached_function-sk.patch
trac12215_segfault_fixes.patch
trac_12313-mono_dict-combined-random-sk.patch
trac_12313_quit_sage.patch
trac13370_deprecate_is_field.patch
trac_13378-convert_map_shortcut.patch
trac_13412_category_for_power_series_rings.patch
trac_13501-categories-c3_fix-nt.patch
trac_13501-c3-speedup-sk.patch
trac_12876_category_abstract_classes_for_hom.patch
trac_12876_r_test.patch
```

applied on top of sage-5.4.beta0.



---

archive/issue_comments_163004.json:
```json
{
    "body": "I looked at the log, and it's indeed due to another patch (I ran the test with 5.3 + the sage-combinat patches merged in 5.4, but without the correponing updated pickle jar).\n\nSo Positive Review!\n\nThanks Simon :-)",
    "created_at": "2012-09-19T13:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163004",
    "user": "https://github.com/nthiery"
}
```

I looked at the log, and it's indeed due to another patch (I ran the test with 5.3 + the sage-combinat patches merged in 5.4, but without the correponing updated pickle jar).

So Positive Review!

Thanks Simon :-)



---

archive/issue_comments_163005.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-09-19T13:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163005",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_163006.json:
```json
{
    "body": "Running the tests just made me realize that this patch commutes with #12895. I thus remove the dependency.",
    "created_at": "2012-09-19T13:38:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163006",
    "user": "https://github.com/nthiery"
}
```

Running the tests just made me realize that this patch commutes with #12895. I thus remove the dependency.



---

archive/issue_comments_163007.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2012-09-21T06:19:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163007",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_163008.json:
```json
{
    "body": "I'm getting a long doctest error:\n\n```\nsage -t  --long -force_lib devel/sage/sage/misc/c3.pyx\n**********************************************************************\nFile \"/release/merger/sage-5.4.beta2/devel/sage-main/sage/misc/c3.pyx\", line 152:\n    sage: class A(B, C): pass\nExpected:\n    Traceback (most recent call last):\n    ...\n    TypeError: Error when calling the metaclass bases\n        Cannot create a consistent method resolution\n    order (MRO) for bases B, C\nGot:\n    Traceback (most recent call last):\n      File \"/release/merger/sage-5.4.beta2/local/bin/ncadoctest.py\", line 1231, in run_one_test\n        self.run_one_example(test, example, filename, compileflags)\n      File \"/release/merger/sage-5.4.beta2/local/bin/sagedoctest.py\", line 38, in run_one_example\n        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)\n      File \"/release/merger/sage-5.4.beta2/local/bin/ncadoctest.py\", line 1172, in run_one_example\n        compileflags, 1) in test.globs\n      File \"<doctest __main__.example_1[35]>\", line 1, in <module>\n        class A(B, C): pass###line 152:\n    sage: class A(B, C): pass\n    TypeError: Error when calling the metaclass bases\n        Cannot create a consistent method resolution\n    order (MRO) for bases C, B\n**********************************************************************\n```\n",
    "created_at": "2012-09-21T06:19:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163008",
    "user": "https://github.com/jdemeyer"
}
```

I'm getting a long doctest error:

```
sage -t  --long -force_lib devel/sage/sage/misc/c3.pyx
**********************************************************************
File "/release/merger/sage-5.4.beta2/devel/sage-main/sage/misc/c3.pyx", line 152:
    sage: class A(B, C): pass
Expected:
    Traceback (most recent call last):
    ...
    TypeError: Error when calling the metaclass bases
        Cannot create a consistent method resolution
    order (MRO) for bases B, C
Got:
    Traceback (most recent call last):
      File "/release/merger/sage-5.4.beta2/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/release/merger/sage-5.4.beta2/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/release/merger/sage-5.4.beta2/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_1[35]>", line 1, in <module>
        class A(B, C): pass###line 152:
    sage: class A(B, C): pass
    TypeError: Error when calling the metaclass bases
        Cannot create a consistent method resolution
    order (MRO) for bases C, B
**********************************************************************
```




---

archive/issue_comments_163009.json:
```json
{
    "body": "Replying to [comment:32 jdemeyer]:\n> I'm getting a long doctest error:\n> {{{\n>     sage: class A(B, C): pass\n> Expected:\n>     Traceback (most recent call last):\n>     ...\n>     TypeError: Error when calling the metaclass bases\n>         Cannot create a consistent method resolution\n>     order (MRO) for bases B, C\n> Got:\n> }}}\n\nBut that's pure Python, and unrelated with our implementation of C3!\n\nCould it be that the error message randomly choses between \"Cannot create ... for bases B, C\" and \"Cannot create ... for bases C, B\"?\n\nIf that is the case, I suggest to change the expected error message into \"Cannot create a consistent method resolution order (MRO) for bases ...\"",
    "created_at": "2012-09-21T06:28:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163009",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:32 jdemeyer]:
> I'm getting a long doctest error:
> {{{
>     sage: class A(B, C): pass
> Expected:
>     Traceback (most recent call last):
>     ...
>     TypeError: Error when calling the metaclass bases
>         Cannot create a consistent method resolution
>     order (MRO) for bases B, C
> Got:
> }}}

But that's pure Python, and unrelated with our implementation of C3!

Could it be that the error message randomly choses between "Cannot create ... for bases B, C" and "Cannot create ... for bases C, B"?

If that is the case, I suggest to change the expected error message into "Cannot create a consistent method resolution order (MRO) for bases ..."



---

archive/issue_comments_163010.json:
```json
{
    "body": "Attachment [trac_13501-c3-review-nt.patch](tarball://root/attachments/some-uuid/ticket13501/trac_13501-c3-review-nt.patch) by @nthiery created at 2012-09-21 07:13:27",
    "created_at": "2012-09-21T07:13:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163010",
    "user": "https://github.com/nthiery"
}
```

Attachment [trac_13501-c3-review-nt.patch](tarball://root/attachments/some-uuid/ticket13501/trac_13501-c3-review-nt.patch) by @nthiery created at 2012-09-21 07:13:27



---

archive/issue_comments_163011.json:
```json
{
    "body": "Replying to [comment:33 SimonKing]:\n> Could it be that the error message randomly choses between \"Cannot create ... for bases B, C\" and \"Cannot create ... for bases C, B\"?\n\nThat sounds a bit strange indeed (I would have expected C3 to be\ncompletely deterministic, including in its error messages), but I\nvaguely remember having to change this order once.\n\n> If that is the case, I suggest to change the expected error message\n> into \"Cannot create a consistent method resolution order (MRO) for\n> bases ...\"\n\n+1\n\nI just did that. I used the occasion to avoid using a temporary\n``tail_set`` variable, as recommended by your benchmark. See\n[attachment:trac_13501-c3-review-nt.patch] for the changes.  The\nupdated [attachment:trac_13501-categories-c3_fix-nt.patch] contains\nall three patches folded together.\n\nApply:\n* [attachment:trac_13501-categories-c3_fix-nt.patch]\n\nCheers,\n                        Nicolas",
    "created_at": "2012-09-21T07:20:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163011",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:33 SimonKing]:
> Could it be that the error message randomly choses between "Cannot create ... for bases B, C" and "Cannot create ... for bases C, B"?

That sounds a bit strange indeed (I would have expected C3 to be
completely deterministic, including in its error messages), but I
vaguely remember having to change this order once.

> If that is the case, I suggest to change the expected error message
> into "Cannot create a consistent method resolution order (MRO) for
> bases ..."

+1

I just did that. I used the occasion to avoid using a temporary
``tail_set`` variable, as recommended by your benchmark. See
[attachment:trac_13501-c3-review-nt.patch] for the changes.  The
updated [attachment:trac_13501-categories-c3_fix-nt.patch] contains
all three patches folded together.

Apply:
* [attachment:trac_13501-categories-c3_fix-nt.patch]

Cheers,
                        Nicolas



---

archive/issue_comments_163012.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-09-21T07:20:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163012",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_163013.json:
```json
{
    "body": "Replying to [comment:34 nthiery]:\n> I used the occasion to avoid using a temporary\n> ``tail_set`` variable, as recommended by your benchmark.\n\nI just ran a benchmark, and it actually seems to make no difference ... But it's slighly more readable.",
    "created_at": "2012-09-21T07:28:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163013",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:34 nthiery]:
> I used the occasion to avoid using a temporary
> ``tail_set`` variable, as recommended by your benchmark.

I just ran a benchmark, and it actually seems to make no difference ... But it's slighly more readable.



---

archive/issue_comments_163014.json:
```json
{
    "body": "Hi Simon!\n\nCould you give it a quick look at my little change and set it back to positive review if that's ok?\n\nThanks!",
    "created_at": "2012-10-17T21:22:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163014",
    "user": "https://github.com/nthiery"
}
```

Hi Simon!

Could you give it a quick look at my little change and set it back to positive review if that's ok?

Thanks!



---

archive/issue_comments_163015.json:
```json
{
    "body": "The patch looks fine, and all doctests (except the one for cmdline.py, which has been disabled for security reasons) pass on bsd.math. So, I can set it back to a positive review.",
    "created_at": "2012-10-18T12:45:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163015",
    "user": "https://github.com/simon-king-jena"
}
```

The patch looks fine, and all doctests (except the one for cmdline.py, which has been disabled for security reasons) pass on bsd.math. So, I can set it back to a positive review.



---

archive/issue_comments_163016.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-10-18T12:45:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163016",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_163017.json:
```json
{
    "body": "This doesn't apply to sage-5.4.rc2:\n\n```\napplying /release/merger/patches/trac_13501-categories-c3_fix-nt.patch\napplying /release/merger/patches/trac_13501-c3-speedup-sk.patch\npatching file sage/misc/c3.pyx\nHunk #1 FAILED at 185\nHunk #2 FAILED at 204\nHunk #3 FAILED at 214\n3 out of 3 hunks FAILED -- saving rejects to file sage/misc/c3.pyx.rej\nabort: patch failed to apply\n```\n",
    "created_at": "2012-10-23T09:42:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163017",
    "user": "https://github.com/jdemeyer"
}
```

This doesn't apply to sage-5.4.rc2:

```
applying /release/merger/patches/trac_13501-categories-c3_fix-nt.patch
applying /release/merger/patches/trac_13501-c3-speedup-sk.patch
patching file sage/misc/c3.pyx
Hunk #1 FAILED at 185
Hunk #2 FAILED at 204
Hunk #3 FAILED at 214
3 out of 3 hunks FAILED -- saving rejects to file sage/misc/c3.pyx.rej
abort: patch failed to apply
```




---

archive/issue_comments_163018.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2012-10-23T09:42:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163018",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_163019.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2012-10-23T14:22:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163019",
    "user": "https://github.com/nthiery"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_163020.json:
```json
{
    "body": "Oops, sorry, Jeroen. I forgot to update the Apply list in the description. As noted in comment 33, Simon's c3-speedup-sk.patch is already folded in the main patch. Fixed and back to positive review.",
    "created_at": "2012-10-23T14:24:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163020",
    "user": "https://github.com/nthiery"
}
```

Oops, sorry, Jeroen. I forgot to update the Apply list in the description. As noted in comment 33, Simon's c3-speedup-sk.patch is already folded in the main patch. Fixed and back to positive review.



---

archive/issue_comments_163021.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2012-11-01T12:02:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13297#issuecomment-163021",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_013194.json:
```json
{
    "actor": "@jdemeyer",
    "created_at": "2012-11-01T12:02:58Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/13297",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13297#event-13194"
}
```
