# Issue 34536: Dual algorithm for Face iterator of Unbounded Combinatorial Polyhedron

Issue created by migration from https://trac.sagemath.org/ticket/34773

Original creator: @xuluze

Original creation time: 2022-11-22 18:07:44

CC:  mkoeppe




---

Comment by mkoeppe created at 2022-11-22 18:29:14

`@`gh-kliem Would this be easy to implement?


---

Comment by @kliem created at 2022-11-27 10:06:05

I don't think it is very hard. How urgent is it? Or is it just to have it.

It is just that I messed this up in the beginning, as I didn't know any better.

The real work might be to clean up along the way. Some stuff is just way too complicated and might be a huge pain to maintain (and is already very difficult to compensate for everyone not directly involved, maybe even everyone except me).


---

Comment by @xuluze created at 2022-11-28 04:35:32

In our case, we can try to get around it by adding a hyperplane to make the cone bounded, and be careful to identify the original faces when handling with the face iterator. But it would be nice to have the dual algorithm apply to our unbounded case directly to make the code cleaner.


---

Comment by @kliem created at 2022-11-28 19:33:40

Something like:


```
sage: P = Polyhedron(rays=[[1,0,0], [0,1,0], [0,1,1]])
sage: C = P.combinatorial_polyhedron()
sage: facets = C.facets()
sage: far_face = P.rays()
sage: new_facets = facets + (far_face,)
sage: C1 = CombinatorialPolyhedron(new_facets)
sage: it = C1.face_iter(algorithm='dual')
sage: faces = [i for i in it if any(v.is_vertex() for v in i.ambient_Vrepresentation())]
```


should work as a workaround.


---

Comment by @xuluze created at 2022-12-01 18:26:44

Thank you very much! Yes, it works.


---

Comment by mkoeppe created at 2022-12-09 19:17:42

> Suddenly we also have an algorithm to visit the bounded faces of a polyhedron:

Great - that will also be useful for computing regular subdivisions


---

Comment by @kliem created at 2022-12-09 20:48:52

Unfortunatly, I had to remove some nonsense. the bounded faces starting from the facets are a bit annoying and I don't know a shortcut to visiting all faces and filtering.

Starting from the vertices there is a shortcut I think. At least the implementation is easy. If there are few vertices and many many rays, the assymtotics are a bit annoying: # bounded faces * # generators * # vertices * # facets.

If the generators are in general position that is much nicer: # bounded faces * # vertices * max(# vertices, # facets).

(Subject to stupid mistakes I made because I'm tired.)

Edit: The generators need to be in general position.


---

Comment by @kliem created at 2022-12-10 15:30:38

New commits:


---

Comment by git created at 2022-12-10 20:06:16

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @kliem created at 2022-12-11 15:46:56

There is actually one thing one needs to pay attention to:

A far face is not always a far facet:

E.g. `Polyhedron(vertices=[[1, 0], [0, 1]], rays=[This is the Trac macro *1, 1* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1, 1-macro))` is unbounded, but does not have a far facet.

But `Polyhedron(vertices=[[1, 0], [0, 1]], rays=[[1, 0], [0, 1]])` has a far facet.
