# Issue 24610: Implement stacking onto a face of a polyhedron

Issue created by migration from https://trac.sagemath.org/ticket/24847

Original creator: jipilab

Original creation time: 2018-02-26 22:00:51

CC:  vdelecroix moritz mkoeppe chapoton

Keywords: days93, polytope

From https://www.csun.edu/~ctoth/Handbook/chap15.pdf:

Stacking onto a face of a polytope adds a vertex slightly outside of the polytope positioned over a point in the interior of the face.

This is the "polar" of the truncation operation.


---

Comment by jipilab created at 2018-02-27 11:37:13

Here's a first working version.

I hesitated between different approaches. This is not the most flexible implementation, but at least a solid enough implementation.
----
New commits:


---

Comment by jipilab created at 2018-02-27 11:37:13

Changing status from new to needs_review.


---

Comment by git created at 2018-02-27 11:51:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-03-06 16:18:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-04-10 13:03:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by moritz created at 2018-04-10 13:11:40

That's a nice addition. 

One question: Should we give the user more control over the base ring of the resulting stacked polytope? At the moment it quietly changes base ring:


```
sage: C  = polytopes.cube()
sage: C.base_ring()
Integer Ring
sage: C.stack(C.faces(2)[2], 1/2).base_ring()
Rational Field
sage: C.stack(C.faces(2)[2], 0.5).base_ring()
Real Double Field
```



Also, in the dual method of face-truncation, there is an option  `linear_coefficients=None`. Should there be an analogous option here?


---

Comment by jipilab created at 2018-04-10 18:46:28

Replying to [comment:7 moritz]:
> That's a nice addition. 

Thanks! :)

> 
> One question: Should we give the user more control over the base ring of the resulting stacked polytope? At the moment it quietly changes base ring:
> 
> {{{
> sage: C  = polytopes.cube()
> sage: C.base_ring()
> Integer Ring
> sage: C.stack(C.faces(2)[2], 1/2).base_ring()
> Rational Field
> sage: C.stack(C.faces(2)[2], 0.5).base_ring()
> Real Double Field
> }}}

I do not think it is a good idea. The above is consistent with the `Polyhedron` constructor and also the current behavior for scaling (and many other methods...):


```
sage: C = polytopes.cube()
sage: 1/2*C
A 3-dimensional polyhedron in QQ^3 defined as the convex hull of 8 vertices
sage: 0.5*C
A 3-dimensional polyhedron in RDF^3 defined as the convex hull of 8 vertices
```


The user should be aware of the type of inputs that are given, and the constructed object is somehow expected to be in the fraction field of the ring. The base_ring of `self` can not be kept in general and if the user wants to keep the base ring, it should keep the input to be in the base ring...

I agree that it would be nice to make this step for the user, but it is a nightmare to implement in a uniform stable way... :-/

> 
> 
> Also, in the dual method of face-truncation, there is an option  `linear_coefficients=None`. Should there be an analogous option here?

I thought about it, but it leads to a lot of case analysis. At least, I did not find a simple way to do this. it seems to me that the dual equivalent has more "accessible" freedom than that one. Although I may be wrong.


---

Comment by moritz created at 2018-04-11 21:07:34

ok, I agree with your reasoning above. 

One more thing:

The stacking seems to work nicely for unbounded polyhedra if you stack on bounded faces of them:

```
sage: [fac] =  [_ for _ in P.faces(1) if _.as_polyhedron().is_compact()]
sage: P = Polyhedron(ieqs = [[-1,1,0], [1,0,-1], [1,0,1]])
sage: [fac] =  [_ for _ in P.faces(1) if _.as_polyhedron().is_compact()]
sage: P = Polyhedron(ieqs = [[-1,1,0], [1,0,-1], [1,0,1]]); P
A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 2 vertices and 1 ray
sage: [fac] =  [_ for _ in P.faces(1) if _.as_polyhedron().is_compact()]
sage: SP = P.stack(fac); SP
A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 3 vertices and 1 ray
sage: P.vertices(), SP.vertices()
((A vertex at (1, 1), A vertex at (1, -1)),
 (A vertex at (0, 0), A vertex at (1, -1), A vertex at (1, 1)))
```

Could you add this as an example?

What is the desired behavior when stacking on unbounded faces of unbounded polyhedra?


---

Comment by jipilab created at 2018-04-11 22:04:18

> The stacking seems to work nicely for unbounded polyhedra if you stack on bounded faces of them:
> {{{
> sage: [fac] =  [_ for _ in P.faces(1) if _.as_polyhedron().is_compact()]
> sage: P = Polyhedron(ieqs = [[-1,1,0], [1,0,-1], [1,0,1]])
> sage: [fac] =  [_ for _ in P.faces(1) if _.as_polyhedron().is_compact()]
> sage: P = Polyhedron(ieqs = [[-1,1,0], [1,0,-1], [1,0,1]]); P
> A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 2 vertices and 1 ray
> sage: [fac] =  [_ for _ in P.faces(1) if _.as_polyhedron().is_compact()]
> sage: SP = P.stack(fac); SP
> A 2-dimensional polyhedron in QQ^2 defined as the convex hull of 3 vertices and 1 ray
> sage: P.vertices(), SP.vertices()
> ((A vertex at (1, 1), A vertex at (1, -1)),
>  (A vertex at (0, 0), A vertex at (1, -1), A vertex at (1, 1)))
> }}}

Could you retrieve the first `P` above? It seems to be missing.

> Could you add this as an example?

Sure!

> 
> What is the desired behavior when stacking on unbounded faces of unbounded polyhedra?

If one takes "stacking" as adding a vertex "just outside" a face as a definition, then it is not very difficult to extend it to unbounded faces using `.representative_point()` for `face.as_polyhedron()` and pushing it out a little.


---

Comment by jipilab created at 2018-04-11 23:10:24

New commits:


---

Comment by git created at 2018-04-11 23:14:18

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by jipilab created at 2018-04-11 23:16:48

I made the function a bit more robust: checking if the `face` is a `PolyhedronFace` object, and fixed it so that it accepts unbounded faces.

`@`moritz: I think that the new examples show the possibilities properly.

Needs review again!


---

Comment by chapoton created at 2018-07-06 18:26:49

branch does not merge


---

Comment by chapoton created at 2018-07-06 18:26:49

Changing status from needs_review to needs_work.


---

Comment by git created at 2018-07-11 09:26:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jipilab created at 2018-07-11 09:29:33

Now merges cleanly.

In the ticket, I also remove two old deprecation warnings...


---

Comment by jipilab created at 2018-07-11 09:29:50

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2018-07-11 18:49:50

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2018-07-11 18:49:50

ok, let it be


---

Comment by jipilab created at 2018-07-12 08:45:51

Thanks for the review!


---

Comment by vdelecroix created at 2018-08-03 19:20:18

update milestone 8.3 -> 8.4


---

Comment by vbraun created at 2018-08-05 08:43:00

Resolution: fixed
