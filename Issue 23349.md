# Issue 23349: fixing broken pynormaliz doctests

Issue created by migration from Trac.

Original creator: chapoton

Original creation time: 2017-08-05 20:52:30

CC:  mkoeppe dkrenn mderickx

found by the patchbot

see

https://patchbot.sagemath.org/log/14153/Gentoo%20Base%20System/2.2/x86_64/4.4.26-gentoo/sage4/2017-08-05%2017:30:09?short


---

Comment by chapoton created at 2017-08-05 20:52:56

Changing status from new to needs_review.


---

Comment by chapoton created at 2017-08-05 20:52:56

New commits:


---

Comment by chapoton created at 2017-08-07 09:57:18

bot is morally green


---

Comment by jdemeyer created at 2017-08-11 07:54:01

Changing priority from major to blocker.


---

Comment by jdemeyer created at 2017-08-11 07:55:53

Do you have any idea why the output has changed? I usually find it dangerous to just accept doctest changes like this without understanding the reason.


---

Comment by jdemeyer created at 2017-08-11 07:57:04

Replying to [comment:2 chapoton]:
> bot is morally green

Those bots do not have `pynormaliz` installed, that means nothing...

On my bots I try to install all optional packages, so `sage4` and `arando` should have it.


---

Comment by fbissey created at 2017-08-11 07:58:21

Looks to me like only the ordering of the solutions has changed. The overall set is still the same.


---

Comment by jdemeyer created at 2017-08-11 07:59:00

Replying to [comment:6 fbissey]:
> Looks to me like only the ordering of the solutions has changed.

That still doesn't answer the "why" question.


---

Comment by tscrim created at 2017-08-11 08:48:25

It's a set, so it is inherently unordered. Although my guess is either changes in the comparisons or the hash led to this change. Perhaps it will be better to make this robust and just do `sorted(PI.Vrepresentation(), key=str)` instead.


---

Comment by mkoeppe created at 2017-08-11 20:42:35

Replying to [comment:8 tscrim]:
> Perhaps it will be better to make this robust and just do `sorted(PI.Vrepresentation(), key=str)` instead.

+1


---

Comment by mkoeppe created at 2017-08-11 20:42:57

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-08-18 07:23:52

Replying to [comment:8 tscrim]:
> Perhaps it will be better to make this robust and just do `sorted(PI.Vrepresentation(), key=str)` instead.

No, if we want to do that, it should be done at the level of the displayhook. We already do that for `dict`, so it makes sense to do the same for `set`.


---

Comment by dkrenn created at 2017-08-18 08:51:54

Replying to [comment:11 jdemeyer]:
> Replying to [comment:8 tscrim]:
> No, if we want to do that, it should be done at the level of the displayhook. We already do that for `dict`, so it makes sense to do the same for `set`.

+1


---

Comment by tscrim created at 2017-08-18 09:14:50

Replying to [comment:11 jdemeyer]:
> Replying to [comment:8 tscrim]:
> > Perhaps it will be better to make this robust and just do `sorted(PI.Vrepresentation(), key=str)` instead.
> 
> No, if we want to do that, it should be done at the level of the displayhook. We already do that for `dict`, so it makes sense to do the same for `set`.

+1


---

Comment by mderickx created at 2017-08-18 21:51:38

I looked a bit into this, and from reading the sage and IPython code I currently understand how the printing of sets is handled is currently via the pretty printing of IPython. And this pretty printing of ipython already sorts items before printing (although on their actual value and not their string representation). 

I just verified this experimentally:


```
sage: str(set([13^i for i in  range(10,1,-1)]))
'set([815730721, 62748517, 137858491849, 10604499373, 28561, 2197, 169, 4826809, 371293])'
sage: set([13^i for i in  range(10,1,-1)])
{169,
 2197,
 28561,
 371293,
 4826809,
 62748517,
 815730721,
 10604499373,
 137858491849}
```


So the question is wether we want to change this sorting on `__cmp__` to a sorting on str (or on pretty). 

The current sorting behaviour is ok with respect to the doctest for sets containing objects that have a meaningful `__cmp__` method. However the default fallback for `__cmp__` is comparing objects by their id which is really random. So although the IPython pretty printing is more robust then the standard printing, it is not really robust in general.

The following current printing behaviour is convincing enough for me that we should still change. 

```
sage: set(GF(13)).union(GF(11))
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
sage: 
sage: set(GF(11)).union(GF(13))
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```


After restarting sage:


```
sage: set(GF(11)).union(GF(13))
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
```



---

Comment by mderickx created at 2017-08-18 23:09:03

I implemented the sorting by str option. Although there are some things I didn't do yet:

 - Document the newly written code
 - Adapt the doctests to accommodate the new way of printing
 - Apply this also to the printing of the builtin Set of sage

The main reason is that I am not 100% sure ye that this is the way to fix this ticket. This way of fixing this ticket namely also means that we now have


```
sage: set(GF(11))
{0, 1, 10, 2, 3, 4, 5, 6, 7, 8, 9}
```


instead of


```
sage: set(GF(11))
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```


And this looks ugly to me.

We could make the order of the printing depend on wether we are currently doctesting, so that the end user is not bothered by the ugly output.


----
New commits:


---

Comment by tscrim created at 2017-08-18 23:22:27

I am actually a little more split on the repr of `set` than initially. I feel like it is better to use the natural sorting, but this is not always sufficient to give a unique ordering (as per Jeoren's example). However, I think it is okay for things to not always work (because the data is essentially unordered), in which can for doctests, we should be more explicit. Yet, I am worried about not using `str` and Python3 of doing something like `set([int(1), 'a'])` as those become incomparable and raise an error. Those errors would be caught, but we would be back in the same situation as now in that the output is random.


---

Comment by chapoton created at 2017-08-19 16:37:37

You may want to keep the distinction between sets and frozensets:

```
Failed example:
    f.vars
Expected:
    frozenset({'x', 'y'})
Got:
    {'x', 'y'}
```



---

Comment by rws created at 2017-08-22 14:50:38

I remember fixing similar fails by not depending on printing at all, i.e. make a result set and compare both sets, testing for "True".


---

Comment by jdemeyer created at 2017-08-22 17:23:09

Replying to [comment:19 rws]:
> I remember fixing similar fails by not depending on printing at all, i.e. make a result set and compare both sets, testing for "True".

That might be good for tests, but certainly not for documentation.


---

Comment by jdemeyer created at 2017-08-24 07:52:34

Replying to [comment:17 tscrim]:
> I am actually a little more split on the repr of `set` than initially.

Why are we even discussing this? The obvious answer is: do whatever we do for dicts. A set is just a dict without values and dicts are sorted nicely:

```
sage: dict((100**i,i) for i in range(20))

{1: 0,
 100: 1,
 10000: 2,
 1000000: 3,
 100000000: 4,
 10000000000: 5,
 1000000000000: 6,
 100000000000000: 7,
 10000000000000000: 8,
 1000000000000000000: 9,
 100000000000000000000: 10,
 10000000000000000000000: 11,
 1000000000000000000000000: 12,
 100000000000000000000000000: 13,
 10000000000000000000000000000: 14,
 1000000000000000000000000000000: 15,
 100000000000000000000000000000000: 16,
 10000000000000000000000000000000000: 17,
 1000000000000000000000000000000000000: 18,
 100000000000000000000000000000000000000: 19}
```



---

Comment by tscrim created at 2017-08-24 14:21:40

Replying to [comment:21 jdemeyer]:
> Replying to [comment:17 tscrim]:
> > I am actually a little more split on the repr of `set` than initially.
> 
> Why are we even discussing this? The obvious answer is: do whatever we do for dicts. A set is just a dict without values and dicts are sorted nicely:

I agree that they should be consistent (they both are sorted by ipython, see comment:15), but I feel like the discussion is more about what we use for sorting. The question is the use their default comparisons or to use `str` as a key. After a little more thought, having the default comparison is probably best. If something needs special handling because objects are not comparable, then I think deserves to manually have a `sorted(foo, key=str)` for the doctest. Another option would be if their is an error caught by ipython, then default to `key=str`.


---

Comment by mderickx created at 2017-08-24 14:44:48

Replying to [comment:22 tscrim]:
> I agree that they should be consistent (they both are sorted by ipython, see comment:15), but I feel like the discussion is more about what we use for sorting. The question is the use their default comparisons or to use `str` as a key. 

Yes exactly that is the main question we should reach a consensus over, and why I have stopped writing more code until we know which direction we want to go! I.e. is sorting by `__cmp__` already robust enough for doctest, and should we only allow doctests with sets containing objects with a `__cmp__` method that is deterministic and not likely to change in the future. Or should we adjust the way we sort the output according to str?

If we do want to sort for str, then there is another choice to be made. Do we want to do this both for user output or just for doctesting. Doing this for user output as well, will give the user less meaningful and more ugly looking output. So the question is whether nice user output outweighs the good practice of output order in doctests and user output being the same. I personally think this is ok since sets are inherently unordered, but am open for other opinions.

> After a little more thought, having the default comparison is probably best. If something needs special handling because objects are not comparable, then I think deserves to manually have a `sorted(foo, key=str)` for the doctest. Another option would be if their is an error caught by ipython, then default to `key=str`.

In the current failing doctest IPython is not catching any errors so I don't see how the other option would help.

p.s. Slightly offtopic, thinking about the subtleties in this ticket I really start to dislike how the coercion framework, `__eq__` and hash interact. There seems to be something inherently contradictory in the assumptions of these three primitives, leading to things like

```
sage: set(srange(5)).union(GF(3)).union(GF(5))
{0, 1, 2, 3, 4}
sage: set(GF(3)).union(GF(5)).union(srange(5))
{0, 1, 2, 0, 1, 2, 3, 4}
```



---

Comment by mderickx created at 2017-08-24 15:01:38

Replying to [comment:17 tscrim]:
> Yet, I am worried about not using `str` and Python3 of doing something like `set([int(1), 'a'])` as those become incomparable and raise an error. Those errors would be caught, but we would be back in the same situation as now in that the output is random.

Good point, due to the work being done on making sage work on Python3 we also should take compatibility with Python3 in mind. I now understand your "Another option would be if their is an error caught by ipython, then default to key=str." remark. This would however only fix things for python3 and not the current situation.


---

Comment by mderickx created at 2017-08-29 15:54:31

I'm degrading this ticket from blocker status, the blocker part of this ticket (i.e. make the output of patchbot useful again) is now #23637 . 

See also the discussion in https://groups.google.com/forum/#!topic/sage-devel/_2vtRbauvrw


---

Comment by mderickx created at 2017-08-29 15:54:31

Changing priority from blocker to major.


---

Comment by jdemeyer created at 2017-08-31 13:58:49

New commits:


---

Comment by jdemeyer created at 2017-08-31 14:05:52

I'm starting to think that we don't need a general solution at all. First of all, Python 3 will help here since it will disallow sorting arbitrary objects:

```
>>> sorted([object(), object()])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unorderable types: object() < object()
```


Second, this issue doesn't seem to be so severe: this optional doctest is the only place where it comes up.


---

Comment by mderickx created at 2017-08-31 15:05:48

Hi, Jeroen.

I agree with your Second point. But I don't agree with your first point. 

You are right that comparing arbitrary objects and hence sorting of hetrogenous collections is not allowed anymore. But I think this will actually make the situation worse, since one is still allowed to make heterogenous sets like set([object(),"a",1]). IPython doesn't sort the sets where sorting raises a TypeError, so for these sets it will just print them in the order that python iterates over them, which (I admittedly didn't check) I suspect to be nondeterministic.

However as mentioned by Travis in comment 22, we can catch this error and just use sorting by string if normal sorting fails. I think this is a clean solution, so we could also just fix it for python 3 and leave the python 2 behaviour as is.


---

Comment by jdemeyer created at 2017-08-31 15:16:41

Changing component from packages: optional to packages: standard.


---

Comment by jdemeyer created at 2017-08-31 15:16:41

Changing status from needs_work to needs_review.


---

Comment by mderickx created at 2017-08-31 15:26:51

Why needs review? I agree with the new description. But we still need to see if IPython accepts our PR and update ipython after it had done so.


---

Comment by mderickx created at 2017-08-31 15:26:51

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2017-11-24 08:25:20

Pull request has been merged...


---

Comment by chapoton created at 2021-10-10 08:34:07

close as obsolete ?


---

Comment by chapoton created at 2021-10-10 08:34:07

Changing status from needs_work to needs_review.


---

Comment by fbissey created at 2021-10-10 08:40:24

Changing status from needs_review to positive_review.


---

Comment by fbissey created at 2021-10-10 08:40:24

Seems like the people involved lost interest 4 years ago so let's obsolete it.


---

Comment by chapoton created at 2021-10-11 08:43:22

Resolution: invalid
