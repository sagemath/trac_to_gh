# Issue 28380: Instantiating SkewPolynomialRing twice fails

Issue created by migration from https://trac.sagemath.org/ticket/28617

Original creator: jlavauzelle

Original creation time: 2019-10-16 13:02:40

CC:  caruso jsrn @mbombar was tscrim pbruin

I would like to report a problem concerning skew polynomial rings.

Consider the following function:

```
def foo(n):
    FF = GF(2**n)
    f = FF.frobenius_endomorphism()
    return SkewPolynomialRing(FF, f, "X")
```


Then, calling `foo` *twice*, with the same large input (ie., extension degree `n` > 15), raises an error, probably due to some cache problem:

```
sage: foo(96)
Skew Polynomial Ring in X over Finite Field in z96 of size 2^96 twisted by z96 |--> z96^2
sage: foo(96)
(...)
TypeError: None fails to convert into the map's domain Finite Field in z96 of size 2^96, but a `pushforward` method is not properly implemented
```


Quite surprisingly, the error does not appear when:
 * the extension degree is less than 15, or
 * the instantiation of the `SkewPolynomialRing` is not embedded in a function, or
 * we use classical `PolynomialRing` instead of `SkewPolynomialRing`.

Any idea?


---

Comment by caruso created at 2019-10-16 13:58:01

The problem comes from comparison between Frobenius endomorphisms:


```
sage: FF = GF(2^20)
sage: f = FF.frobenius_endomorphism()
sage: f == FF.frobenius_endomorphism()
Traceback (most recent call last):
...
TypeError: None fails to convert into the map's domain Finite Field in z20 of size 2^20, but a `pushforward` method is not properly implemented
```



---

Comment by jlavauzelle created at 2019-10-17 08:24:49

Hello Xavier,

Thanks for your quick answer. So I guess the problem lies in the fact that no specific `FrobeniusEndomorphism` class/method has been implemented for the `ntl_gf2e` finite field case.

I had a look on what has been done for "givaro" finite fields, and this seems to be a quite long work... I'm not sure I have time to write everything properly for the moment.

Thanks again,

Julien


---

Comment by embray created at 2020-01-06 14:10:03

Ticket retargeted after milestone closed


---

Comment by mkoeppe created at 2020-05-01 04:28:42

Moving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.


---

Comment by caruso created at 2020-07-03 19:04:33

Changing status from new to needs_review.


---

Comment by caruso created at 2020-07-03 19:04:33

The problem comes from the combination of two facts:
- the method `_lmul_` is not implemented for NTL finite fields, so it inherits from the abstract class `Element` and just returns `None`
- in the generic implementation of comparison of morphisms, `_lmul_` is called without further precaution

Actually, I do not see why calling `_lmul_` is needed, so I removed this call... which fixes the problem.

PS: Maybe, we should also implement `_lmul_` for NTL finite fields; I don't know if it's required.
----
New commits:


---

Comment by git created at 2020-07-03 19:08:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2020-07-05 01:24:20

Replying to [comment:7 caruso]:
> The problem comes from the combination of two facts:
> - the method `_lmul_` is not implemented for NTL finite fields, so it inherits from the abstract class `Element` and just returns `None`
> - in the generic implementation of comparison of morphisms, `_lmul_` is called without further precaution
> 
> Actually, I do not see why calling `_lmul_` is needed, so I removed this call... which fixes the problem.
> 
> PS: Maybe, we should also implement `_lmul_` for NTL finite fields; I don't know if it's required.

I think we need to hear from the initial implementer.


---

Comment by caruso created at 2020-07-05 10:05:21

With the patchbot report, I think I see now why using `_lmul_` is appropriate: it's because this code is supposed to work not only for ring homomorphisms but also for module homomorphisms.

So, I've switched back to the original version but added one test in order to avoid the call to `_lmul_` when a coercion map is defined. I believe it would make things faster.


---

Comment by git created at 2020-07-05 10:06:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2020-07-06 10:09:48

Replying to [comment:11 caruso]:
> With the patchbot report, I think I see now why using `_lmul_` is appropriate: it's because this code is supposed to work not only for ring homomorphisms but also for module homomorphisms.

I guessed so, but I still do not see it clearly. Would you give an example where `_lmul_` and `_base` things are in work?


---

Comment by caruso created at 2020-07-06 12:47:13

Let us first look at the case of ring homomorphisms. Consider the following:


```
sage: k.<a> = GF(9)
sage: Frob = k.frobenius_endomorphism()
sage: R.<x> = k[] 
sage: phi = R.hom([x^2])
sage: psi = R.hom([x^2], base_map=Frob)
```


Then `phi` is definitely different from `psi` because they act differently of `k`:


```
sage: phi(a)
a
sage: psi(a)
2*a + 1
```


However, `R.gens()` consists only of `x` and `phi(x) = psi(x) = x^3`. Therefore, in order to guarantee that two morphisms coincide, we need to check that they take the same values on the generators of the domain, but also recursively on the generators of the base of the domain, the generators of the base of the base of the domain, etc.

Now, the same occurs with modules. If `A` and `B` and two `K`-modules, it's certainly possible to imagine a mapping `A -> B` which is not `K`-linear (for instance, it could be semi-linear)... though I'm not sure it would be easy/possible to define in Sage. Hence, in order to check that two such mappings coincide, we need to check that they agree on the generators but also on the product of generators by (iterated) generators of the ring of scalars. Actually, it is not exactly what the current code does (both before and after my patch): the current code only checks products with the *last* generator of the module. It looks like a bug but I'm not sure about this (because I don't know precisely what `ModuleMorphism` means in Sage).


---

Comment by klee created at 2020-07-07 03:29:41

Replying to [comment:14 caruso]:
> Let us first look at the case of ring homomorphisms. Consider the following:
> 
> {{{
> sage: k.<a> = GF(9)
> sage: Frob = k.frobenius_endomorphism()
> sage: R.<x> = k[] 
> sage: phi = R.hom([x^2])
> sage: psi = R.hom([x^2], base_map=Frob)
> }}}
> 
> Then `phi` is definitely different from `psi` because they act differently of `k`:
> 
> {{{
> sage: phi(a)
> a
> sage: psi(a)
> 2*a + 1
> }}}
> 
> However, `R.gens()` consists only of `x` and `phi(x) = psi(x) = x^3`. Therefore, in order to guarantee that two morphisms coincide, we need to check that they take the same values on the generators of the domain, but also recursively on the generators of the base of the domain, the generators of the base of the base of the domain, etc.

Right.. But this is not a relevant example to the current issue. `_lmul_` and `_base` are not involved here.

Putting the math behind `_richcmp_` aside, the direct cause of the failure is that `g._lmul_(h)` does not work (returns `None`) for g in the finite field k and h in the prime base field of k. 

```diff
diff --git a/src/sage/categories/morphism.pyx b/src/sage/categories/morphism.pyx
index dec8b00b74..b41f5e7e2a 100644
--- a/src/sage/categories/morphism.pyx
+++ b/src/sage/categories/morphism.pyx
@@ -362,7 +362,7 @@ cdef class Morphism(Map):
             # gens by picking an element of the initial domain (e) and
             # multiplying it with the gens of the scalar ring.
             if e is not None and isinstance(e, ModuleElement):
-                gens = [(<ModuleElement>e)._lmul_(x) for x in gens]
+                gens = [e._lmul_(x) for x in gens]
             for e in gens:
                 x = self(e)
                 y = other(e)
diff --git a/src/sage/rings/finite_rings/element_base.pyx b/src/sage/rings/finite_rings/element_base.pyx
index 97d4260a18..e81155b316 100755
--- a/src/sage/rings/finite_rings/element_base.pyx
+++ b/src/sage/rings/finite_rings/element_base.pyx
@@ -30,6 +30,10 @@ def is_FiniteFieldElement(x):
 
 
 cdef class FiniteRingElement(CommutativeRingElement):
+    def _lmul_(self, other):
+        return self * other
+
```


This fixes the problem.


---

Comment by @mbombar created at 2020-08-29 20:10:59

Hi,
I'm quite new to Sage, but why exactly `e` would be different from `<ModuleElement>e` when `e` is the generator of the finite field ?

If we get into that, 


```
    if e is not None and isinstance(e, ModuleElement):
       gens = [(<ModuleElement>e)._lmul_(x) for x in gens]
```


`e` should be an instance of `ModuleElement`, isn't it ? Therefore, I don't get why there is this coercion in the first place, which is removed in [comment:15 klee]'s proposal.

Obviously, they are different : If we keep this coercion, we still have the failure, even when `_lmul_` is defined for `FiniteRingElement`. However, `e == <ModuleElement>e` evaluates to `True`. Can someone explain to me the difference please ?


My question here brings another one: By removing the coercion, aren't we breaking anything else ?



Anyway, this issue led me to trac ticket #24281. The example mentioned in the description is interesting, because `f` and `g` are both defined on `None` and evaluate to `0`, hence the result. Otherwise I guess there would have been the same exception. Is this a side effect of anything else ? Or is it normal to define a morphism on `None` ? And if so, wouldn't it solve the problem to define the Frobenius map on `None` either ? In fact, the Frobenius map is well defined on `None` for other fields :



```
sage: k = GF(9)
sage: frob = k.frobenius_endomorphism()
sage: frob(None)
0
sage: frob == k.frobenius_endomorphism()
True
sage: k = GF(2^15)  # Givaro                                                                          
sage: frob = k.frobenius_endomorphism()
sage: frob(None)
0
sage: frob == k.frobenius_endomorphism()
True
sage: k = GF(2^16)
sage: frob = k.frobenius_endomorphism()                                                                        
sage: frob(None) 
...
TypeError: None fails to convert into the map's domain Finite Field in z16 of size 2^16, but a `pushforward` method is not properly implemented
```



---

Comment by klee created at 2020-08-30 02:34:30

Replying to [comment:16 gh-mbombar]:
> Hi,
> I'm quite new to Sage, but why exactly `e` would be different from `<ModuleElement>e` when `e` is the generator of the finite field ?
> 
> If we get into that, 
> 
> {{{
>     if e is not None and isinstance(e, ModuleElement):
>        gens = [(<ModuleElement>e)._lmul_(x) for x in gens]
> }}}
> 
> `e` should be an instance of `ModuleElement`, isn't it ? Therefore, I don't get why there is this coercion in the first place, which is removed in [comment:15 klee]'s proposal.

I had the same question. My guess is what follows. With the coercion, `_lmul_` defined on `ModuleElement` class is invoked, and somehow leads to the failure. Without the coercion, `_lmul_` defined on `FiniteRingElement` is invoked, and I provided an implementation of that method.

> 
> However, `e == <ModuleElement>e` evaluates to `True`. 

Equality test is on a different level, and complicated. This being `True` is not relevant with the behavior of the above code in issue. 

> My question here brings another one: By removing the coercion, aren't we breaking anything else ?

I guess not. I hope not.

> Anyway, this issue led me to trac ticket #24281. The example mentioned in the description is interesting, because `f` and `g` are both defined on `None` and evaluate to `0`, hence the result. Otherwise I guess there would have been the same exception. Is this a side effect of anything else ? Or is it normal to define a morphism on `None` ? And if so, wouldn't it solve the problem to define the Frobenius map on `None` either ? In fact, the Frobenius map is well defined on `None` for other fields :
> 
> 
> {{{
> sage: k = GF(9)
> sage: frob = k.frobenius_endomorphism()
> sage: frob(None)
> 0
> sage: frob == k.frobenius_endomorphism()
> True
> sage: k = GF(2^15)  # Givaro                                                                          
> sage: frob = k.frobenius_endomorphism()
> sage: frob(None)
> 0
> sage: frob == k.frobenius_endomorphism()
> True
> sage: k = GF(2^16)
> sage: frob = k.frobenius_endomorphism()                                                                        
> sage: frob(None) 
> ...
> TypeError: None fails to convert into the map's domain Finite Field in z16 of size 2^16, but a `pushforward` method is not properly implemented
> }}}

Frobenius maps are not defined on `None`, mathematically. The above are just consequences of Sage coercion (different concept from the Cython coercion above) of `None` to `0` element.


---

Comment by klee created at 2020-09-08 05:13:16

I am willing to upload a patch implementing the simple fix in comment:15, if no one objects.


---

Comment by git created at 2020-09-09 06:20:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-12-16 08:17:38

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2021-03-24 02:04:25

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.


---

Comment by roed created at 2021-04-28 05:33:45

Changing status from needs_review to needs_work.


---

Comment by roed created at 2021-04-28 05:33:45

This branch no longer merges, and there's quite a bit of discussion after Xavier marked it as needs review.


---

Comment by git created at 2021-04-28 07:58:53

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by klee created at 2021-04-28 08:02:06

Changing status from needs_work to needs_review.


---

Comment by klee created at 2021-04-28 09:38:57

The patch fixes the problem. But I do not understand the logic of the code in `_richcmp_` well. In particular, the business of the base gens stuff... Hence someone who does should look at it.


---

Comment by caruso created at 2021-04-28 13:59:03

Changing status from needs_review to positive_review.


---

Comment by caruso created at 2021-04-28 13:59:03

I don't know if it's correct but I tried to explain what I've understood on comment:14.

OK for fixing the issue as you propose for this ticket (so I'm giving a positive review). However, I think that thinking again at the best way to check equalities between general morphims would be a good idea for another ticket.


---

Comment by klee created at 2021-04-29 00:34:05

Replying to [comment:29 caruso]:
> OK for fixing the issue as you propose for this ticket (so I'm giving a positive review). 

Thank you.

>However, I think that thinking again at the best way to check equalities between general morphims would be a good idea for another ticket.

and the code needs more documentation and examples.


---

Comment by tscrim created at 2021-04-29 11:25:15

For comment:28: Yes, what is in comment:15 is correct. Here is another way of explaining it. The base check just means it goes down recursively, which is necessary to check that we get the same map. For example, consider two cyclic R-modules M = <x>, N = <y> and morphisms f<sub>1</sub>, f<sub>2</sub>: M -> N such that f<sub>1</sub>(r*x) = r*y and f<sub>2</sub>(r*x) = g(r)*y, where g: R -> R is some non-trivial automorphism. On basis vectors (i.e., the generators), both f<sub>1</sub> and f<sub>2</sub> map x -> y. However, they are not the same morphism when you map the generators of R.

I am not completely sure about this fix. It seems like it could lead to an infinite loop because `*` could call the `_lmul_`, which then calls `*`. It feels like there should be a bit better of a solution, but I don't know offhand what that is.


---

Comment by klee created at 2021-04-29 12:40:16

Replying to [comment:31 tscrim]:

Is this part also correct?

    ... the current code only checks products with the *last* generator of the module. It 
    looks like a bug ...

Is it a bug?


---

Comment by tscrim created at 2021-04-29 13:58:48

I don't think so. It is enough to recurse down on the last generator because everything before and including that must have compared equal. All you are doing is comparing stuff in the base ring at that point.


---

Comment by git created at 2021-04-30 03:52:29

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2021-04-30 03:52:29

Changing status from positive_review to needs_review.


---

Comment by klee created at 2021-04-30 03:55:25

Replying to [comment:33 tscrim]:
> I don't think so. It is enough to recurse down on the last generator because everything before and including that must have compared equal. All you are doing is comparing stuff in the base ring at that point.

Okay. I now understand the code better. The last generator is just picked up to compare the images of scalar multiplications with the base ring generators. Thanks.


---

Comment by klee created at 2021-04-30 03:58:23

Replying to [comment:31 tscrim]:

> I am not completely sure about this fix. It seems like it could lead to an infinite loop because `*` could call the `_lmul_`, which then calls `*`. It feels like there should be a bit better of a solution, but I don't know offhand what that is.

In the last commit, I made `_lmul_` `cpdef`ed and use `_mul_` instead of `*`. This is simpler and seems safer.


---

Comment by git created at 2021-04-30 04:01:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-04-30 06:11:23

I think you should wrap the `_mul_` with a `try-except` block and return `None` if an error is raised from trying to do the coercion. Now it will likely fail later on in the same way, but by returning `None`, the remaining coercion framework for `*` gets invoked. This then tries to find a larger common parent (which might succeed) rather than just simply trying to force it into the same parent as `self`. This also allows us to say that there is no (left) action of `other` on `self`. I doubt I could think of a doctest for this specific case (although perhaps over two suitably chosen base rings) though...


---

Comment by git created at 2021-04-30 08:43:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-04-30 08:49:03

Now I wonder whether `FiniteRingElement` class is the right place to put `_lmul_` method. The scalar multiplication is naturally defined for all rings. So `RingElement` class might be a better place. I experimented on this idea, but I got lots of doctest failures. So I would not attempt this on this ticket.


---

Comment by klee created at 2021-04-30 08:51:43

Actually 

```
----------------------------------------------------------------------
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/complex_arb.pyx  # 1 doctest failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/qqbar.py  # 1 doctest failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/number_field/number_field_element.pyx  # 1 doctest failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/infinite_polynomial_element.py  # 6 doctests failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/skew_polynomial_ring.py  # 2 doctests failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/polynomial_element.pyx  # 1 doctest failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/ore_function_element.py  # 1 doctest failed
----------------------------------------------------------------------
```

So not so many...


---

Comment by @mwageringel created at 2021-05-03 18:56:06

Replying to [comment:32 klee]:
>     ... the current code only checks products with the *last* generator of the module. It 
>     looks like a bug ...
> 
> Is it a bug?

I think that at least the code needs to make sure that the last generator is non-zero. For example, this fails in this case:

```
sage: K.<a> = QuadraticField(-1)
sage: R.<x,y> = K['x,y'].quotient('y')
sage: id = R.Hom(R).identity()
sage: f = R.hom(R.gens(), R, base_map=K.hom([-a], K))
sage: f == id  # should be False
True
```

(Currently, this fails because `_lmul_` returns `None`, though.)

This example is from ticket [ticket:30938#comment:3], where we were also confused about this `_richcmp_` implementation.


---

Comment by git created at 2021-05-04 02:03:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-05-04 02:23:17

Replying to [comment:42 gh-mwageringel]:
> I think that at least the code needs to make sure that the last generator is non-zero. For example, this fails in this case:
> {{{
> sage: K.<a> = QuadraticField(-1)
> sage: R.<x,y> = K['x,y'].quotient('y')
> sage: id = R.Hom(R).identity()
> sage: f = R.hom(R.gens(), R, base_map=K.hom([-a], K))
> sage: f == id  # should be False
> True
> }}}
> Currently, this fails because `_lmul_` returns `None`, though.

Done. But the example still fails as you said.


---

Comment by git created at 2021-05-04 04:40:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-05-04 04:42:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-05-04 04:54:34

Looking at #30938, requiring each ring to implement `_lmul_` to avoid this morphism comparison problem seems not a good solution. It seems to me that the `_richcmp_` method of a generic morphism should try to get the necessary scalar multiplication in a general way, that is, via the coercion model. It will be a little bit slower but will work well generally.


---

Comment by roed created at 2021-05-04 13:47:57

Yeah, I agree that avoiding a direct call to `_lmul_` is best, since multiplication by the base ring is allowed to be implemented using other methods.


---

Comment by @mwageringel created at 2021-05-04 22:08:46

If I am not mistaken, there is still a problem with the theory behind this. For example:

```
sage: S.<a,b> = QQ['a,b'].quotient(['a*b'])
sage: R.<x> = S['x']
sage: f = R.hom([b], R, base_map=S.hom([-a, b], S))
sage: g = R.hom([b], R)
sage: f == g  # False is correct
False
```

The above only gives the correct answer because `f` and `g` have the same type, so a different comparison function is used. With the generic implementation, this gives the wrong answer:

```
sage: from sage.structure.richcmp import op_EQ
sage: from sage.rings.morphism import RingMap
sage: RingMap._richcmp_(f, g, op_EQ)  # should be False
True
```

Here, `f(x)==g(x)` and `f(a*x)==g(a*x)` does not imply `f(a)==g(a)`, so the implementation relies on a cancellation property that does not hold in general.

As a module, `x` does not generate `R`, but `R` is generated by all monomials in `x`. In this case, the monomial `x^0` is the only generator for which the images of `a*x^0`, `b*x^0` allow to distinguish `f` and `g`.

It may be necessary to separate the implementations for rings and modules. For rings, it is enough to check that `f` and `g` agree on the generators of the ring and, recursively, on the generators of the base ring. For modules, I am not so sure – maybe we need to restrict to the case of module _homomorphisms_ and raise a `NotImplementedError` otherwise.


---

Comment by klee created at 2021-05-04 23:39:32

Replying to [comment:49 gh-mwageringel]:
> so the implementation relies on a cancellation property that does not hold in general.

Good point. 

> It may be necessary to separate the implementations for rings and modules. 

Assuming cancellation property is reasonable for most ring and modules in Sage. So I think the implementation is okay for generic morphisms. You just showed that it is not adequate for general rings. Fortunately Sage seems to provide a different implementation for the exceptional rings as you explained. 

I would document that the implementation for generic morphisms is assuming cancellation property so that future developers be warned for the trap.


---

Comment by tscrim created at 2021-05-05 02:01:27

Why not just do

```diff
-coercion_model.bin_op(e, B.coerce(x), operator.mul)
+e * B.coerce(x)
```

I find it easier to understand and it could use some optimizations that are present in `__mul__` (such as with integers and rationals).


---

Comment by git created at 2021-05-05 05:37:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mwageringel created at 2021-05-05 07:54:51

Replying to [comment:50 klee]:
> Assuming cancellation property is reasonable for most ring and modules in Sage. So I think the implementation is okay for generic morphisms. You just showed that it is not adequate for general rings. Fortunately Sage seems to provide a different implementation for the exceptional rings as you explained. 

There are ways to construct the same maps but with different Python types, which seems to be the original motivation for #24281. Here are two examples, where the generic implementation is used:

```
sage: S.<a,b> = QQ['a,b'].quotient('a*b')
sage: R.<x> = S[]
sage: f = R.hom([b], R)
sage: g = R.hom([b], R) * R.hom(S.hom([-a, b], S), R)
sage: f == g  # should be False
True
```


```
sage: from sage.rings.polynomial.flatten import SpecializationMorphism
sage: f2 = SpecializationMorphism(R, {x:b})
sage: g2 = R.hom([b], S, base_map=S.hom([-a, b], S))
sage: f2 == g2  # should be False
True
```

So making assumptions in the generic implementation which do not hold in general opens the door to mathematically wrong answers.


---

Comment by klee created at 2021-05-05 13:02:57

Replying to [comment:53 gh-mwageringel]:
> So making assumptions in the generic implementation which do not hold in general opens the door to mathematically wrong answers.

I agree that the generic implementation is not perfect, and it needs to be replaced if someone comes up with a better one. On the other hand, the current patch solves the problem of this ticket by improving the implementation. 

If a perfect solution is not around now, I suggest to open another ticket for it later.


---

Comment by @mwageringel created at 2021-05-05 19:19:22

Replying to [comment:54 klee]:
> On the other hand, the current patch solves the problem of this ticket by improving the implementation. 

Yes, I agree the current branch is better than what we had. I am ok with these changes.

Just one small comment:

```diff
+from sage.structure.coerce cimport coercion_model
```

This import does not seem to be needed anymore.


---

Comment by caruso created at 2021-05-05 19:42:31

I'm fine with closing this ticket as it is.

However, I need to mention that while working on #21413 about two years ago, I already noticed that comparison of ring morphisms was not really reliable and I implemented my own equality checking in `sage.rings.ring_extension_morphism` (function `are_equal_morphisms`). Probably, this code should be merged in the class `RingHomomorphism` at some point.


---

Comment by git created at 2021-05-06 00:01:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-05-06 00:14:26

Replying to [comment:55 gh-mwageringel]:
> {{{#!diff
> +from sage.structure.coerce cimport coercion_model
> }}}
> This import does not seem to be needed anymore.

Fixed. Thanks.


---

Comment by git created at 2021-05-06 00:16:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-05-06 00:18:29

Replying to [comment:56 caruso]:
> I need to mention that while working on #21413 about two years ago, I already noticed that comparison of ring morphisms was not really reliable and I implemented my own equality checking in `sage.rings.ring_extension_morphism` (function `are_equal_morphisms`). Probably, this code should be merged in the class `RingHomomorphism` at some point.

Good. You may provide the code to #31783.


---

Comment by git created at 2021-05-06 09:05:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2021-05-06 09:15:29

After some thought, I became not sure of the added comment that the problem of the comparison method is only the assumption of the cancellation property. So I rewrote it only about a fact.

There is no change in the code. As it was a green light, we may still assume green light.

Further discussion on the problem should continue in #31783.


---

Comment by tscrim created at 2021-05-07 05:55:52

Shouldn't we reset:

```diff
             if e is not None and isinstance(e, ModuleElement):
                 B = (<ModuleElement>e)._parent._base
                 gens = [e * B.coerce(x) for x in gens]
+                e = None
```

Otherwise we wouldn't set `e` to be an element of `gens` on subsequent calls. This would only show up if we have to go more than twice down, which we may not have a doctest for.


---

Comment by klee created at 2021-05-07 06:02:55

Replying to [comment:63 tscrim]:
> Shouldn't we reset:
> {{{#!diff
>              if e is not None and isinstance(e, ModuleElement):
>                  B = (<ModuleElement>e)._parent._base
>                  gens = [e * B.coerce(x) for x in gens]
> +                e = None
> }}}
> Otherwise we wouldn't set `e` to be an element of `gens` on subsequent calls. This would only show up if we have to go more than twice down, which we may not have a doctest for.

e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.


---

Comment by tscrim created at 2021-05-07 06:10:55

Replying to [comment:64 klee]:
> Replying to [comment:63 tscrim]:
> > Shouldn't we reset:
> > [snip]
> > Otherwise we wouldn't set `e` to be an element of `gens` on subsequent calls. This would only show up if we have to go more than twice down, which we may not have a doctest for.
> 
> e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.

I thought we wanted a recursion going a level deeper each time. Perhaps we can add a doctest for this behavior?


---

Comment by klee created at 2021-05-09 10:00:06

Replying to [comment:65 tscrim]:
> Replying to [comment:64 klee]:
> > e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.
> 
> I thought we wanted a recursion going a level deeper each time. Perhaps we can add a doctest for this behavior?

I think the recursion should limit to the base ring of the base ring for module morphisms. For ring morphisms, the implementation seems inherently flawed as Markus showed.

Anyway, the patch fixes the problem of the ticket but do not alter the logic or algorithm of the implementation. The flaw of the algorithm should now be dealt with in #31783. I hope that someone with a proved algorithm propose a patch to completely fix the morphism comparison problem in Sage.


---

Comment by tscrim created at 2021-05-11 07:04:03

Replying to [comment:66 klee]:
> Replying to [comment:65 tscrim]:
> > Replying to [comment:64 klee]:
> > > e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.
> > 
> > I thought we wanted a recursion going a level deeper each time. Perhaps we can add a doctest for this behavior?
> 
> I think the recursion should limit to the base ring of the base ring for module morphisms. For ring morphisms, the implementation seems inherently flawed as Markus showed.

I think it needs to go down as deep as possible. This is what the code currently does.

> Anyway, the patch fixes the problem of the ticket but do not alter the logic or algorithm of the implementation. The flaw of the algorithm should now be dealt with in #31783. I hope that someone with a proved algorithm propose a patch to completely fix the morphism comparison problem in Sage. 

I am not fully convinced the logic has not changed. However, I am convinced enough that it works to let it in. I still would like a doctest doing the comparison with functions that are at least 2 deep in the recursion instead of just once to make sure it works. For example

```
Z[x] -> Z[x][y] -> Z[x][y][z]
```

where at each step we twist the generator `a -> -a`. I can write the doctest explicitly tomorrow.


---

Comment by klee created at 2021-05-11 08:07:10

Replying to [comment:67 tscrim]:
> I think the recursion should limit to the base ring of the base ring for module morphisms. For ring morphisms, the implementation seems inherently flawed as Markus showed.
> 
> I think it needs to go down as deep as possible. This is what the code currently does.

I tried to mean the recursion happens only within the base ring (not the module). My sentence was not clear. Sorry.

> I still would like a doctest doing the comparison with functions that are at least 2 deep in the recursion instead of just once to make sure it works. For example
> {{{
> Z[x] -> Z[x][y] -> Z[x][y][z]
> }}}
> where at each step we twist the generator `a -> -a`. I can write the doctest explicitly tomorrow.

Comparison of ring homomorphisms will be dealt with the code in #31783. It would be better that your doctest for the present ticket is about module homomorphisms.


---

Comment by caruso created at 2021-05-11 13:22:54

As suggested by Kwankyu, I think that we should close this ticket now (in order to fix the issue as soon as possible) and continue the discussion (which could take some time) in #31783.

That's why I'm giving again a positive review to this ticket. Feel free to revert this decision if you strongly disagree.


---

Comment by caruso created at 2021-05-11 13:22:54

Changing status from needs_review to positive_review.


---

Comment by caruso created at 2021-05-11 13:25:11

(Hope it's correct this time. Sorry for the inconvenience.)


---

Comment by tscrim created at 2021-05-12 06:58:27

I don't know of a good test for this, so okay, let it be.


---

Comment by vbraun created at 2021-05-27 20:29:21

Resolution: fixed
