# Issue 28380: Instantiating SkewPolynomialRing twice fails

archive/issues_028380.json:
```json
{
    "body": "CC:  @xcaruso @johanrosenkilde @mbombar @williamstein @tscrim @pjbruin\n\nI would like to report a problem concerning skew polynomial rings.\n\nConsider the following function:\n\n```\ndef foo(n):\n    FF = GF(2**n)\n    f = FF.frobenius_endomorphism()\n    return SkewPolynomialRing(FF, f, \"X\")\n```\n\n\nThen, calling `foo` **twice**, with the same large input (ie., extension degree `n` > 15), raises an error, probably due to some cache problem:\n\n```\nsage: foo(96)\nSkew Polynomial Ring in X over Finite Field in z96 of size 2^96 twisted by z96 |--> z96^2\nsage: foo(96)\n(...)\nTypeError: None fails to convert into the map's domain Finite Field in z96 of size 2^96, but a `pushforward` method is not properly implemented\n```\n\n\nQuite surprisingly, the error does not appear when:\n* the extension degree is less than 15, or\n* the instantiation of the `SkewPolynomialRing` is not embedded in a function, or\n* we use classical `PolynomialRing` instead of `SkewPolynomialRing`.\n\nAny idea?\n\nIssue created by migration from https://trac.sagemath.org/ticket/28617\n\n",
    "created_at": "2019-10-16T13:02:40Z",
    "labels": [
        "component: algebra",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.4",
    "title": "Instantiating SkewPolynomialRing twice fails",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/28380",
    "user": "https://github.com/jlavauzelle"
}
```
CC:  @xcaruso @johanrosenkilde @mbombar @williamstein @tscrim @pjbruin

I would like to report a problem concerning skew polynomial rings.

Consider the following function:

```
def foo(n):
    FF = GF(2**n)
    f = FF.frobenius_endomorphism()
    return SkewPolynomialRing(FF, f, "X")
```


Then, calling `foo` **twice**, with the same large input (ie., extension degree `n` > 15), raises an error, probably due to some cache problem:

```
sage: foo(96)
Skew Polynomial Ring in X over Finite Field in z96 of size 2^96 twisted by z96 |--> z96^2
sage: foo(96)
(...)
TypeError: None fails to convert into the map's domain Finite Field in z96 of size 2^96, but a `pushforward` method is not properly implemented
```


Quite surprisingly, the error does not appear when:
* the extension degree is less than 15, or
* the instantiation of the `SkewPolynomialRing` is not embedded in a function, or
* we use classical `PolynomialRing` instead of `SkewPolynomialRing`.

Any idea?

Issue created by migration from https://trac.sagemath.org/ticket/28617





---

archive/issue_comments_400292.json:
```json
{
    "body": "The problem comes from comparison between Frobenius endomorphisms:\n\n\n```\nsage: FF = GF(2^20)\nsage: f = FF.frobenius_endomorphism()\nsage: f == FF.frobenius_endomorphism()\nTraceback (most recent call last):\n...\nTypeError: None fails to convert into the map's domain Finite Field in z20 of size 2^20, but a `pushforward` method is not properly implemented\n```\n",
    "created_at": "2019-10-16T13:58:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400292",
    "user": "https://github.com/xcaruso"
}
```

The problem comes from comparison between Frobenius endomorphisms:


```
sage: FF = GF(2^20)
sage: f = FF.frobenius_endomorphism()
sage: f == FF.frobenius_endomorphism()
Traceback (most recent call last):
...
TypeError: None fails to convert into the map's domain Finite Field in z20 of size 2^20, but a `pushforward` method is not properly implemented
```




---

archive/issue_comments_400293.json:
```json
{
    "body": "Hello Xavier,\n\nThanks for your quick answer. So I guess the problem lies in the fact that no specific `FrobeniusEndomorphism` class/method has been implemented for the `ntl_gf2e` finite field case.\n\nI had a look on what has been done for \"givaro\" finite fields, and this seems to be a quite long work... I'm not sure I have time to write everything properly for the moment.\n\nThanks again,\n\nJulien",
    "created_at": "2019-10-17T08:24:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400293",
    "user": "https://github.com/jlavauzelle"
}
```

Hello Xavier,

Thanks for your quick answer. So I guess the problem lies in the fact that no specific `FrobeniusEndomorphism` class/method has been implemented for the `ntl_gf2e` finite field case.

I had a look on what has been done for "givaro" finite fields, and this seems to be a quite long work... I'm not sure I have time to write everything properly for the moment.

Thanks again,

Julien



---

archive/issue_comments_400294.json:
```json
{
    "body": "Ticket retargeted after milestone closed",
    "created_at": "2020-01-06T14:10:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400294",
    "user": "https://github.com/embray"
}
```

Ticket retargeted after milestone closed



---

archive/issue_comments_400295.json:
```json
{
    "body": "Moving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.",
    "created_at": "2020-05-01T04:28:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400295",
    "user": "https://github.com/mkoeppe"
}
```

Moving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.



---

archive/issue_comments_400296.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-07-03T19:04:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400296",
    "user": "https://github.com/xcaruso"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_400297.json:
```json
{
    "body": "The problem comes from the combination of two facts:\n- the method `_lmul_` is not implemented for NTL finite fields, so it inherits from the abstract class `Element` and just returns `None`\n- in the generic implementation of comparison of morphisms, `_lmul_` is called without further precaution\n\nActually, I do not see why calling `_lmul_` is needed, so I removed this call... which fixes the problem.\n\nPS: Maybe, we should also implement `_lmul_` for NTL finite fields; I don't know if it's required.\n----\nNew commits:",
    "created_at": "2020-07-03T19:04:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400297",
    "user": "https://github.com/xcaruso"
}
```

The problem comes from the combination of two facts:
- the method `_lmul_` is not implemented for NTL finite fields, so it inherits from the abstract class `Element` and just returns `None`
- in the generic implementation of comparison of morphisms, `_lmul_` is called without further precaution

Actually, I do not see why calling `_lmul_` is needed, so I removed this call... which fixes the problem.

PS: Maybe, we should also implement `_lmul_` for NTL finite fields; I don't know if it's required.
----
New commits:



---

archive/issue_comments_400298.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-03T19:08:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400298",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400299.json:
```json
{
    "body": "Replying to [comment:7 caruso]:\n> The problem comes from the combination of two facts:\n> - the method `_lmul_` is not implemented for NTL finite fields, so it inherits from the abstract class `Element` and just returns `None`\n> - in the generic implementation of comparison of morphisms, `_lmul_` is called without further precaution\n> \n> Actually, I do not see why calling `_lmul_` is needed, so I removed this call... which fixes the problem.\n> \n> PS: Maybe, we should also implement `_lmul_` for NTL finite fields; I don't know if it's required.\n\nI think we need to hear from the initial implementer.",
    "created_at": "2020-07-05T01:24:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400299",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:7 caruso]:
> The problem comes from the combination of two facts:
> - the method `_lmul_` is not implemented for NTL finite fields, so it inherits from the abstract class `Element` and just returns `None`
> - in the generic implementation of comparison of morphisms, `_lmul_` is called without further precaution
> 
> Actually, I do not see why calling `_lmul_` is needed, so I removed this call... which fixes the problem.
> 
> PS: Maybe, we should also implement `_lmul_` for NTL finite fields; I don't know if it's required.

I think we need to hear from the initial implementer.



---

archive/issue_comments_400300.json:
```json
{
    "body": "With the patchbot report, I think I see now why using `_lmul_` is appropriate: it's because this code is supposed to work not only for ring homomorphisms but also for module homomorphisms.\n\nSo, I've switched back to the original version but added one test in order to avoid the call to `_lmul_` when a coercion map is defined. I believe it would make things faster.",
    "created_at": "2020-07-05T10:05:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400300",
    "user": "https://github.com/xcaruso"
}
```

With the patchbot report, I think I see now why using `_lmul_` is appropriate: it's because this code is supposed to work not only for ring homomorphisms but also for module homomorphisms.

So, I've switched back to the original version but added one test in order to avoid the call to `_lmul_` when a coercion map is defined. I believe it would make things faster.



---

archive/issue_comments_400301.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-05T10:06:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400301",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400302.json:
```json
{
    "body": "Replying to [comment:11 caruso]:\n> With the patchbot report, I think I see now why using `_lmul_` is appropriate: it's because this code is supposed to work not only for ring homomorphisms but also for module homomorphisms.\n\nI guessed so, but I still do not see it clearly. Would you give an example where `_lmul_` and `_base` things are in work?",
    "created_at": "2020-07-06T10:09:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400302",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:11 caruso]:
> With the patchbot report, I think I see now why using `_lmul_` is appropriate: it's because this code is supposed to work not only for ring homomorphisms but also for module homomorphisms.

I guessed so, but I still do not see it clearly. Would you give an example where `_lmul_` and `_base` things are in work?



---

archive/issue_comments_400303.json:
```json
{
    "body": "Let us first look at the case of ring homomorphisms. Consider the following:\n\n\n```\nsage: k.<a> = GF(9)\nsage: Frob = k.frobenius_endomorphism()\nsage: R.<x> = k[] \nsage: phi = R.hom([x^2])\nsage: psi = R.hom([x^2], base_map=Frob)\n```\n\n\nThen `phi` is definitely different from `psi` because they act differently of `k`:\n\n\n```\nsage: phi(a)\na\nsage: psi(a)\n2*a + 1\n```\n\n\nHowever, `R.gens()` consists only of `x` and `phi(x) = psi(x) = x^3`. Therefore, in order to guarantee that two morphisms coincide, we need to check that they take the same values on the generators of the domain, but also recursively on the generators of the base of the domain, the generators of the base of the base of the domain, etc.\n\nNow, the same occurs with modules. If `A` and `B` and two `K`-modules, it's certainly possible to imagine a mapping `A -> B` which is not `K`-linear (for instance, it could be semi-linear)... though I'm not sure it would be easy/possible to define in Sage. Hence, in order to check that two such mappings coincide, we need to check that they agree on the generators but also on the product of generators by (iterated) generators of the ring of scalars. Actually, it is not exactly what the current code does (both before and after my patch): the current code only checks products with the *last* generator of the module. It looks like a bug but I'm not sure about this (because I don't know precisely what `ModuleMorphism` means in Sage).",
    "created_at": "2020-07-06T12:47:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400303",
    "user": "https://github.com/xcaruso"
}
```

Let us first look at the case of ring homomorphisms. Consider the following:


```
sage: k.<a> = GF(9)
sage: Frob = k.frobenius_endomorphism()
sage: R.<x> = k[] 
sage: phi = R.hom([x^2])
sage: psi = R.hom([x^2], base_map=Frob)
```


Then `phi` is definitely different from `psi` because they act differently of `k`:


```
sage: phi(a)
a
sage: psi(a)
2*a + 1
```


However, `R.gens()` consists only of `x` and `phi(x) = psi(x) = x^3`. Therefore, in order to guarantee that two morphisms coincide, we need to check that they take the same values on the generators of the domain, but also recursively on the generators of the base of the domain, the generators of the base of the base of the domain, etc.

Now, the same occurs with modules. If `A` and `B` and two `K`-modules, it's certainly possible to imagine a mapping `A -> B` which is not `K`-linear (for instance, it could be semi-linear)... though I'm not sure it would be easy/possible to define in Sage. Hence, in order to check that two such mappings coincide, we need to check that they agree on the generators but also on the product of generators by (iterated) generators of the ring of scalars. Actually, it is not exactly what the current code does (both before and after my patch): the current code only checks products with the *last* generator of the module. It looks like a bug but I'm not sure about this (because I don't know precisely what `ModuleMorphism` means in Sage).



---

archive/issue_comments_400304.json:
```json
{
    "body": "Replying to [comment:14 caruso]:\n> Let us first look at the case of ring homomorphisms. Consider the following:\n> \n> {{{\n> sage: k.<a> = GF(9)\n> sage: Frob = k.frobenius_endomorphism()\n> sage: R.<x> = k[] \n> sage: phi = R.hom([x^2])\n> sage: psi = R.hom([x^2], base_map=Frob)\n> }}}\n> \n> Then `phi` is definitely different from `psi` because they act differently of `k`:\n> \n> {{{\n> sage: phi(a)\n> a\n> sage: psi(a)\n> 2*a + 1\n> }}}\n> \n> However, `R.gens()` consists only of `x` and `phi(x) = psi(x) = x^3`. Therefore, in order to guarantee that two morphisms coincide, we need to check that they take the same values on the generators of the domain, but also recursively on the generators of the base of the domain, the generators of the base of the base of the domain, etc.\n\nRight.. But this is not a relevant example to the current issue. `_lmul_` and `_base` are not involved here.\n\nPutting the math behind `_richcmp_` aside, the direct cause of the failure is that `g._lmul_(h)` does not work (returns `None`) for g in the finite field k and h in the prime base field of k. \n\n```diff\ndiff --git a/src/sage/categories/morphism.pyx b/src/sage/categories/morphism.pyx\nindex dec8b00b74..b41f5e7e2a 100644\n--- a/src/sage/categories/morphism.pyx\n+++ b/src/sage/categories/morphism.pyx\n@@ -362,7 +362,7 @@ cdef class Morphism(Map):\n             # gens by picking an element of the initial domain (e) and\n             # multiplying it with the gens of the scalar ring.\n             if e is not None and isinstance(e, ModuleElement):\n-                gens = [(<ModuleElement>e)._lmul_(x) for x in gens]\n+                gens = [e._lmul_(x) for x in gens]\n             for e in gens:\n                 x = self(e)\n                 y = other(e)\ndiff --git a/src/sage/rings/finite_rings/element_base.pyx b/src/sage/rings/finite_rings/element_base.pyx\nindex 97d4260a18..e81155b316 100755\n--- a/src/sage/rings/finite_rings/element_base.pyx\n+++ b/src/sage/rings/finite_rings/element_base.pyx\n@@ -30,6 +30,10 @@ def is_FiniteFieldElement(x):\n \n \n cdef class FiniteRingElement(CommutativeRingElement):\n+    def _lmul_(self, other):\n+        return self * other\n+\n```\n\n\nThis fixes the problem.",
    "created_at": "2020-07-07T03:29:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400304",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:14 caruso]:
> Let us first look at the case of ring homomorphisms. Consider the following:
> 
> {{{
> sage: k.<a> = GF(9)
> sage: Frob = k.frobenius_endomorphism()
> sage: R.<x> = k[] 
> sage: phi = R.hom([x^2])
> sage: psi = R.hom([x^2], base_map=Frob)
> }}}
> 
> Then `phi` is definitely different from `psi` because they act differently of `k`:
> 
> {{{
> sage: phi(a)
> a
> sage: psi(a)
> 2*a + 1
> }}}
> 
> However, `R.gens()` consists only of `x` and `phi(x) = psi(x) = x^3`. Therefore, in order to guarantee that two morphisms coincide, we need to check that they take the same values on the generators of the domain, but also recursively on the generators of the base of the domain, the generators of the base of the base of the domain, etc.

Right.. But this is not a relevant example to the current issue. `_lmul_` and `_base` are not involved here.

Putting the math behind `_richcmp_` aside, the direct cause of the failure is that `g._lmul_(h)` does not work (returns `None`) for g in the finite field k and h in the prime base field of k. 

```diff
diff --git a/src/sage/categories/morphism.pyx b/src/sage/categories/morphism.pyx
index dec8b00b74..b41f5e7e2a 100644
--- a/src/sage/categories/morphism.pyx
+++ b/src/sage/categories/morphism.pyx
@@ -362,7 +362,7 @@ cdef class Morphism(Map):
             # gens by picking an element of the initial domain (e) and
             # multiplying it with the gens of the scalar ring.
             if e is not None and isinstance(e, ModuleElement):
-                gens = [(<ModuleElement>e)._lmul_(x) for x in gens]
+                gens = [e._lmul_(x) for x in gens]
             for e in gens:
                 x = self(e)
                 y = other(e)
diff --git a/src/sage/rings/finite_rings/element_base.pyx b/src/sage/rings/finite_rings/element_base.pyx
index 97d4260a18..e81155b316 100755
--- a/src/sage/rings/finite_rings/element_base.pyx
+++ b/src/sage/rings/finite_rings/element_base.pyx
@@ -30,6 +30,10 @@ def is_FiniteFieldElement(x):
 
 
 cdef class FiniteRingElement(CommutativeRingElement):
+    def _lmul_(self, other):
+        return self * other
+
```


This fixes the problem.



---

archive/issue_comments_400305.json:
```json
{
    "body": "Hi,\nI'm quite new to Sage, but why exactly `e` would be different from `<ModuleElement>e` when `e` is the generator of the finite field ?\n\nIf we get into that, \n\n\n```\n    if e is not None and isinstance(e, ModuleElement):\n       gens = [(<ModuleElement>e)._lmul_(x) for x in gens]\n```\n\n\n`e` should be an instance of `ModuleElement`, isn't it ? Therefore, I don't get why there is this coercion in the first place, which is removed in [comment:15 klee]'s proposal.\n\nObviously, they are different : If we keep this coercion, we still have the failure, even when `_lmul_` is defined for `FiniteRingElement`. However, `e == <ModuleElement>e` evaluates to `True`. Can someone explain to me the difference please ?\n\n\nMy question here brings another one: By removing the coercion, aren't we breaking anything else ?\n\n\n\nAnyway, this issue led me to trac ticket #24281. The example mentioned in the description is interesting, because `f` and `g` are both defined on `None` and evaluate to `0`, hence the result. Otherwise I guess there would have been the same exception. Is this a side effect of anything else ? Or is it normal to define a morphism on `None` ? And if so, wouldn't it solve the problem to define the Frobenius map on `None` either ? In fact, the Frobenius map is well defined on `None` for other fields :\n\n\n\n```\nsage: k = GF(9)\nsage: frob = k.frobenius_endomorphism()\nsage: frob(None)\n0\nsage: frob == k.frobenius_endomorphism()\nTrue\nsage: k = GF(2^15)  # Givaro                                                                          \nsage: frob = k.frobenius_endomorphism()\nsage: frob(None)\n0\nsage: frob == k.frobenius_endomorphism()\nTrue\nsage: k = GF(2^16)\nsage: frob = k.frobenius_endomorphism()                                                                        \nsage: frob(None) \n...\nTypeError: None fails to convert into the map's domain Finite Field in z16 of size 2^16, but a `pushforward` method is not properly implemented\n```\n",
    "created_at": "2020-08-29T20:10:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400305",
    "user": "https://github.com/mbombar"
}
```

Hi,
I'm quite new to Sage, but why exactly `e` would be different from `<ModuleElement>e` when `e` is the generator of the finite field ?

If we get into that, 


```
    if e is not None and isinstance(e, ModuleElement):
       gens = [(<ModuleElement>e)._lmul_(x) for x in gens]
```


`e` should be an instance of `ModuleElement`, isn't it ? Therefore, I don't get why there is this coercion in the first place, which is removed in [comment:15 klee]'s proposal.

Obviously, they are different : If we keep this coercion, we still have the failure, even when `_lmul_` is defined for `FiniteRingElement`. However, `e == <ModuleElement>e` evaluates to `True`. Can someone explain to me the difference please ?


My question here brings another one: By removing the coercion, aren't we breaking anything else ?



Anyway, this issue led me to trac ticket #24281. The example mentioned in the description is interesting, because `f` and `g` are both defined on `None` and evaluate to `0`, hence the result. Otherwise I guess there would have been the same exception. Is this a side effect of anything else ? Or is it normal to define a morphism on `None` ? And if so, wouldn't it solve the problem to define the Frobenius map on `None` either ? In fact, the Frobenius map is well defined on `None` for other fields :



```
sage: k = GF(9)
sage: frob = k.frobenius_endomorphism()
sage: frob(None)
0
sage: frob == k.frobenius_endomorphism()
True
sage: k = GF(2^15)  # Givaro                                                                          
sage: frob = k.frobenius_endomorphism()
sage: frob(None)
0
sage: frob == k.frobenius_endomorphism()
True
sage: k = GF(2^16)
sage: frob = k.frobenius_endomorphism()                                                                        
sage: frob(None) 
...
TypeError: None fails to convert into the map's domain Finite Field in z16 of size 2^16, but a `pushforward` method is not properly implemented
```




---

archive/issue_comments_400306.json:
```json
{
    "body": "Replying to [comment:16 gh-mbombar]:\n> Hi,\n> I'm quite new to Sage, but why exactly `e` would be different from `<ModuleElement>e` when `e` is the generator of the finite field ?\n> \n> If we get into that, \n> \n> {{{\n>     if e is not None and isinstance(e, ModuleElement):\n>        gens = [(<ModuleElement>e)._lmul_(x) for x in gens]\n> }}}\n> \n> `e` should be an instance of `ModuleElement`, isn't it ? Therefore, I don't get why there is this coercion in the first place, which is removed in [comment:15 klee]'s proposal.\n\nI had the same question. My guess is what follows. With the coercion, `_lmul_` defined on `ModuleElement` class is invoked, and somehow leads to the failure. Without the coercion, `_lmul_` defined on `FiniteRingElement` is invoked, and I provided an implementation of that method.\n\n> \n> However, `e == <ModuleElement>e` evaluates to `True`. \n\nEquality test is on a different level, and complicated. This being `True` is not relevant with the behavior of the above code in issue. \n\n> My question here brings another one: By removing the coercion, aren't we breaking anything else ?\n\nI guess not. I hope not.\n\n> Anyway, this issue led me to trac ticket #24281. The example mentioned in the description is interesting, because `f` and `g` are both defined on `None` and evaluate to `0`, hence the result. Otherwise I guess there would have been the same exception. Is this a side effect of anything else ? Or is it normal to define a morphism on `None` ? And if so, wouldn't it solve the problem to define the Frobenius map on `None` either ? In fact, the Frobenius map is well defined on `None` for other fields :\n> \n> \n> {{{\n> sage: k = GF(9)\n> sage: frob = k.frobenius_endomorphism()\n> sage: frob(None)\n> 0\n> sage: frob == k.frobenius_endomorphism()\n> True\n> sage: k = GF(2^15)  # Givaro                                                                          \n> sage: frob = k.frobenius_endomorphism()\n> sage: frob(None)\n> 0\n> sage: frob == k.frobenius_endomorphism()\n> True\n> sage: k = GF(2^16)\n> sage: frob = k.frobenius_endomorphism()                                                                        \n> sage: frob(None) \n> ...\n> TypeError: None fails to convert into the map's domain Finite Field in z16 of size 2^16, but a `pushforward` method is not properly implemented\n> }}}\n\nFrobenius maps are not defined on `None`, mathematically. The above are just consequences of Sage coercion (different concept from the Cython coercion above) of `None` to `0` element.",
    "created_at": "2020-08-30T02:34:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400306",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:16 gh-mbombar]:
> Hi,
> I'm quite new to Sage, but why exactly `e` would be different from `<ModuleElement>e` when `e` is the generator of the finite field ?
> 
> If we get into that, 
> 
> {{{
>     if e is not None and isinstance(e, ModuleElement):
>        gens = [(<ModuleElement>e)._lmul_(x) for x in gens]
> }}}
> 
> `e` should be an instance of `ModuleElement`, isn't it ? Therefore, I don't get why there is this coercion in the first place, which is removed in [comment:15 klee]'s proposal.

I had the same question. My guess is what follows. With the coercion, `_lmul_` defined on `ModuleElement` class is invoked, and somehow leads to the failure. Without the coercion, `_lmul_` defined on `FiniteRingElement` is invoked, and I provided an implementation of that method.

> 
> However, `e == <ModuleElement>e` evaluates to `True`. 

Equality test is on a different level, and complicated. This being `True` is not relevant with the behavior of the above code in issue. 

> My question here brings another one: By removing the coercion, aren't we breaking anything else ?

I guess not. I hope not.

> Anyway, this issue led me to trac ticket #24281. The example mentioned in the description is interesting, because `f` and `g` are both defined on `None` and evaluate to `0`, hence the result. Otherwise I guess there would have been the same exception. Is this a side effect of anything else ? Or is it normal to define a morphism on `None` ? And if so, wouldn't it solve the problem to define the Frobenius map on `None` either ? In fact, the Frobenius map is well defined on `None` for other fields :
> 
> 
> {{{
> sage: k = GF(9)
> sage: frob = k.frobenius_endomorphism()
> sage: frob(None)
> 0
> sage: frob == k.frobenius_endomorphism()
> True
> sage: k = GF(2^15)  # Givaro                                                                          
> sage: frob = k.frobenius_endomorphism()
> sage: frob(None)
> 0
> sage: frob == k.frobenius_endomorphism()
> True
> sage: k = GF(2^16)
> sage: frob = k.frobenius_endomorphism()                                                                        
> sage: frob(None) 
> ...
> TypeError: None fails to convert into the map's domain Finite Field in z16 of size 2^16, but a `pushforward` method is not properly implemented
> }}}

Frobenius maps are not defined on `None`, mathematically. The above are just consequences of Sage coercion (different concept from the Cython coercion above) of `None` to `0` element.



---

archive/issue_comments_400307.json:
```json
{
    "body": "I am willing to upload a patch implementing the simple fix in comment:15, if no one objects.",
    "created_at": "2020-09-08T05:13:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400307",
    "user": "https://github.com/kwankyu"
}
```

I am willing to upload a patch implementing the simple fix in comment:15, if no one objects.



---

archive/issue_comments_400308.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-09T06:20:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400308",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400309.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-12-16T08:17:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400309",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_400310.json:
```json
{
    "body": "Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-03-24T02:04:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400310",
    "user": "https://github.com/mkoeppe"
}
```

Sage development has entered the release candidate phase for 9.3. Setting a new milestone for this ticket based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_comments_400311.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2021-04-28T05:33:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400311",
    "user": "https://github.com/roed314"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_400312.json:
```json
{
    "body": "This branch no longer merges, and there's quite a bit of discussion after Xavier marked it as needs review.",
    "created_at": "2021-04-28T05:33:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400312",
    "user": "https://github.com/roed314"
}
```

This branch no longer merges, and there's quite a bit of discussion after Xavier marked it as needs review.



---

archive/issue_comments_400313.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2021-04-28T07:58:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400313",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_400314.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2021-04-28T08:02:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400314",
    "user": "https://github.com/kwankyu"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_400315.json:
```json
{
    "body": "The patch fixes the problem. But I do not understand the logic of the code in `_richcmp_` well. In particular, the business of the base gens stuff... Hence someone who does should look at it.",
    "created_at": "2021-04-28T09:38:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400315",
    "user": "https://github.com/kwankyu"
}
```

The patch fixes the problem. But I do not understand the logic of the code in `_richcmp_` well. In particular, the business of the base gens stuff... Hence someone who does should look at it.



---

archive/issue_comments_400316.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-04-28T13:59:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400316",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_400317.json:
```json
{
    "body": "I don't know if it's correct but I tried to explain what I've understood on comment:14.\n\nOK for fixing the issue as you propose for this ticket (so I'm giving a positive review). However, I think that thinking again at the best way to check equalities between general morphims would be a good idea for another ticket.",
    "created_at": "2021-04-28T13:59:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400317",
    "user": "https://github.com/xcaruso"
}
```

I don't know if it's correct but I tried to explain what I've understood on comment:14.

OK for fixing the issue as you propose for this ticket (so I'm giving a positive review). However, I think that thinking again at the best way to check equalities between general morphims would be a good idea for another ticket.



---

archive/issue_comments_400318.json:
```json
{
    "body": "Replying to [comment:29 caruso]:\n> OK for fixing the issue as you propose for this ticket (so I'm giving a positive review). \n\nThank you.\n\n>However, I think that thinking again at the best way to check equalities between general morphims would be a good idea for another ticket.\n\nand the code needs more documentation and examples.",
    "created_at": "2021-04-29T00:34:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400318",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:29 caruso]:
> OK for fixing the issue as you propose for this ticket (so I'm giving a positive review). 

Thank you.

>However, I think that thinking again at the best way to check equalities between general morphims would be a good idea for another ticket.

and the code needs more documentation and examples.



---

archive/issue_comments_400319.json:
```json
{
    "body": "For comment:28: Yes, what is in comment:15 is correct. Here is another way of explaining it. The base check just means it goes down recursively, which is necessary to check that we get the same map. For example, consider two cyclic R-modules M = <x>, N = <y> and morphisms f<sub>1</sub>, f<sub>2</sub>: M -> N such that f<sub>1</sub>(r*x) = r*y and f<sub>2</sub>(r*x) = g(r)*y, where g: R -> R is some non-trivial automorphism. On basis vectors (i.e., the generators), both f<sub>1</sub> and f<sub>2</sub> map x -> y. However, they are not the same morphism when you map the generators of R.\n\nI am not completely sure about this fix. It seems like it could lead to an infinite loop because `*` could call the `_lmul_`, which then calls `*`. It feels like there should be a bit better of a solution, but I don't know offhand what that is.",
    "created_at": "2021-04-29T11:25:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400319",
    "user": "https://github.com/tscrim"
}
```

For comment:28: Yes, what is in comment:15 is correct. Here is another way of explaining it. The base check just means it goes down recursively, which is necessary to check that we get the same map. For example, consider two cyclic R-modules M = <x>, N = <y> and morphisms f<sub>1</sub>, f<sub>2</sub>: M -> N such that f<sub>1</sub>(r*x) = r*y and f<sub>2</sub>(r*x) = g(r)*y, where g: R -> R is some non-trivial automorphism. On basis vectors (i.e., the generators), both f<sub>1</sub> and f<sub>2</sub> map x -> y. However, they are not the same morphism when you map the generators of R.

I am not completely sure about this fix. It seems like it could lead to an infinite loop because `*` could call the `_lmul_`, which then calls `*`. It feels like there should be a bit better of a solution, but I don't know offhand what that is.



---

archive/issue_comments_400320.json:
```json
{
    "body": "Replying to [comment:31 tscrim]:\n\nIs this part also correct?\n\n... the current code only checks products with the *last* generator of the module. It \n    looks like a bug ...\n\nIs it a bug?",
    "created_at": "2021-04-29T12:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400320",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:31 tscrim]:

Is this part also correct?

... the current code only checks products with the *last* generator of the module. It 
    looks like a bug ...

Is it a bug?



---

archive/issue_comments_400321.json:
```json
{
    "body": "I don't think so. It is enough to recurse down on the last generator because everything before and including that must have compared equal. All you are doing is comparing stuff in the base ring at that point.",
    "created_at": "2021-04-29T13:58:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400321",
    "user": "https://github.com/tscrim"
}
```

I don't think so. It is enough to recurse down on the last generator because everything before and including that must have compared equal. All you are doing is comparing stuff in the base ring at that point.



---

archive/issue_comments_400322.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2021-04-30T03:52:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400322",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_400323.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2021-04-30T03:52:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400323",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_400324.json:
```json
{
    "body": "Replying to [comment:33 tscrim]:\n> I don't think so. It is enough to recurse down on the last generator because everything before and including that must have compared equal. All you are doing is comparing stuff in the base ring at that point.\n\nOkay. I now understand the code better. The last generator is just picked up to compare the images of scalar multiplications with the base ring generators. Thanks.",
    "created_at": "2021-04-30T03:55:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400324",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:33 tscrim]:
> I don't think so. It is enough to recurse down on the last generator because everything before and including that must have compared equal. All you are doing is comparing stuff in the base ring at that point.

Okay. I now understand the code better. The last generator is just picked up to compare the images of scalar multiplications with the base ring generators. Thanks.



---

archive/issue_comments_400325.json:
```json
{
    "body": "Replying to [comment:31 tscrim]:\n\n> I am not completely sure about this fix. It seems like it could lead to an infinite loop because `*` could call the `_lmul_`, which then calls `*`. It feels like there should be a bit better of a solution, but I don't know offhand what that is.\n\nIn the last commit, I made `_lmul_` `cpdef`ed and use `_mul_` instead of `*`. This is simpler and seems safer.",
    "created_at": "2021-04-30T03:58:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400325",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:31 tscrim]:

> I am not completely sure about this fix. It seems like it could lead to an infinite loop because `*` could call the `_lmul_`, which then calls `*`. It feels like there should be a bit better of a solution, but I don't know offhand what that is.

In the last commit, I made `_lmul_` `cpdef`ed and use `_mul_` instead of `*`. This is simpler and seems safer.



---

archive/issue_comments_400326.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-30T04:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400326",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400327.json:
```json
{
    "body": "I think you should wrap the `_mul_` with a `try-except` block and return `None` if an error is raised from trying to do the coercion. Now it will likely fail later on in the same way, but by returning `None`, the remaining coercion framework for `*` gets invoked. This then tries to find a larger common parent (which might succeed) rather than just simply trying to force it into the same parent as `self`. This also allows us to say that there is no (left) action of `other` on `self`. I doubt I could think of a doctest for this specific case (although perhaps over two suitably chosen base rings) though...",
    "created_at": "2021-04-30T06:11:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400327",
    "user": "https://github.com/tscrim"
}
```

I think you should wrap the `_mul_` with a `try-except` block and return `None` if an error is raised from trying to do the coercion. Now it will likely fail later on in the same way, but by returning `None`, the remaining coercion framework for `*` gets invoked. This then tries to find a larger common parent (which might succeed) rather than just simply trying to force it into the same parent as `self`. This also allows us to say that there is no (left) action of `other` on `self`. I doubt I could think of a doctest for this specific case (although perhaps over two suitably chosen base rings) though...



---

archive/issue_comments_400328.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-04-30T08:43:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400328",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400329.json:
```json
{
    "body": "Now I wonder whether `FiniteRingElement` class is the right place to put `_lmul_` method. The scalar multiplication is naturally defined for all rings. So `RingElement` class might be a better place. I experimented on this idea, but I got lots of doctest failures. So I would not attempt this on this ticket.",
    "created_at": "2021-04-30T08:49:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400329",
    "user": "https://github.com/kwankyu"
}
```

Now I wonder whether `FiniteRingElement` class is the right place to put `_lmul_` method. The scalar multiplication is naturally defined for all rings. So `RingElement` class might be a better place. I experimented on this idea, but I got lots of doctest failures. So I would not attempt this on this ticket.



---

archive/issue_comments_400330.json:
```json
{
    "body": "Actually \n\n```\n----------------------------------------------------------------------\nsage -t --warn-long 65.6 --random-seed=0 src/sage/rings/complex_arb.pyx  # 1 doctest failed\nsage -t --warn-long 65.6 --random-seed=0 src/sage/rings/qqbar.py  # 1 doctest failed\nsage -t --warn-long 65.6 --random-seed=0 src/sage/rings/number_field/number_field_element.pyx  # 1 doctest failed\nsage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/infinite_polynomial_element.py  # 6 doctests failed\nsage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/skew_polynomial_ring.py  # 2 doctests failed\nsage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/polynomial_element.pyx  # 1 doctest failed\nsage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/ore_function_element.py  # 1 doctest failed\n----------------------------------------------------------------------\n```\n\nSo not so many...",
    "created_at": "2021-04-30T08:51:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400330",
    "user": "https://github.com/kwankyu"
}
```

Actually 

```
----------------------------------------------------------------------
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/complex_arb.pyx  # 1 doctest failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/qqbar.py  # 1 doctest failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/number_field/number_field_element.pyx  # 1 doctest failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/infinite_polynomial_element.py  # 6 doctests failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/skew_polynomial_ring.py  # 2 doctests failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/polynomial_element.pyx  # 1 doctest failed
sage -t --warn-long 65.6 --random-seed=0 src/sage/rings/polynomial/ore_function_element.py  # 1 doctest failed
----------------------------------------------------------------------
```

So not so many...



---

archive/issue_comments_400331.json:
```json
{
    "body": "Replying to [comment:32 klee]:\n>     ... the current code only checks products with the *last* generator of the module. It \n>     looks like a bug ...\n> \n> Is it a bug?\n\nI think that at least the code needs to make sure that the last generator is non-zero. For example, this fails in this case:\n\n```\nsage: K.<a> = QuadraticField(-1)\nsage: R.<x,y> = K['x,y'].quotient('y')\nsage: id = R.Hom(R).identity()\nsage: f = R.hom(R.gens(), R, base_map=K.hom([-a], K))\nsage: f == id  # should be False\nTrue\n```\n\n(Currently, this fails because `_lmul_` returns `None`, though.)\n\nThis example is from ticket [ticket:30938#comment:3], where we were also confused about this `_richcmp_` implementation.",
    "created_at": "2021-05-03T18:56:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400331",
    "user": "https://github.com/mwageringel"
}
```

Replying to [comment:32 klee]:
>     ... the current code only checks products with the *last* generator of the module. It 
>     looks like a bug ...
> 
> Is it a bug?

I think that at least the code needs to make sure that the last generator is non-zero. For example, this fails in this case:

```
sage: K.<a> = QuadraticField(-1)
sage: R.<x,y> = K['x,y'].quotient('y')
sage: id = R.Hom(R).identity()
sage: f = R.hom(R.gens(), R, base_map=K.hom([-a], K))
sage: f == id  # should be False
True
```

(Currently, this fails because `_lmul_` returns `None`, though.)

This example is from ticket [ticket:30938#comment:3], where we were also confused about this `_richcmp_` implementation.



---

archive/issue_comments_400332.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-04T02:03:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400332",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400333.json:
```json
{
    "body": "Replying to [comment:42 gh-mwageringel]:\n> I think that at least the code needs to make sure that the last generator is non-zero. For example, this fails in this case:\n> {{{\n> sage: K.<a> = QuadraticField(-1)\n> sage: R.<x,y> = K['x,y'].quotient('y')\n> sage: id = R.Hom(R).identity()\n> sage: f = R.hom(R.gens(), R, base_map=K.hom([-a], K))\n> sage: f == id  # should be False\n> True\n> }}}\n> Currently, this fails because `_lmul_` returns `None`, though.\n\nDone. But the example still fails as you said.",
    "created_at": "2021-05-04T02:23:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400333",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:42 gh-mwageringel]:
> I think that at least the code needs to make sure that the last generator is non-zero. For example, this fails in this case:
> {{{
> sage: K.<a> = QuadraticField(-1)
> sage: R.<x,y> = K['x,y'].quotient('y')
> sage: id = R.Hom(R).identity()
> sage: f = R.hom(R.gens(), R, base_map=K.hom([-a], K))
> sage: f == id  # should be False
> True
> }}}
> Currently, this fails because `_lmul_` returns `None`, though.

Done. But the example still fails as you said.



---

archive/issue_comments_400334.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-04T04:40:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400334",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400335.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-04T04:42:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400335",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400336.json:
```json
{
    "body": "Looking at #30938, requiring each ring to implement `_lmul_` to avoid this morphism comparison problem seems not a good solution. It seems to me that the `_richcmp_` method of a generic morphism should try to get the necessary scalar multiplication in a general way, that is, via the coercion model. It will be a little bit slower but will work well generally.",
    "created_at": "2021-05-04T04:54:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400336",
    "user": "https://github.com/kwankyu"
}
```

Looking at #30938, requiring each ring to implement `_lmul_` to avoid this morphism comparison problem seems not a good solution. It seems to me that the `_richcmp_` method of a generic morphism should try to get the necessary scalar multiplication in a general way, that is, via the coercion model. It will be a little bit slower but will work well generally.



---

archive/issue_comments_400337.json:
```json
{
    "body": "Yeah, I agree that avoiding a direct call to `_lmul_` is best, since multiplication by the base ring is allowed to be implemented using other methods.",
    "created_at": "2021-05-04T13:47:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400337",
    "user": "https://github.com/roed314"
}
```

Yeah, I agree that avoiding a direct call to `_lmul_` is best, since multiplication by the base ring is allowed to be implemented using other methods.



---

archive/issue_comments_400338.json:
```json
{
    "body": "If I am not mistaken, there is still a problem with the theory behind this. For example:\n\n```\nsage: S.<a,b> = QQ['a,b'].quotient(['a*b'])\nsage: R.<x> = S['x']\nsage: f = R.hom([b], R, base_map=S.hom([-a, b], S))\nsage: g = R.hom([b], R)\nsage: f == g  # False is correct\nFalse\n```\n\nThe above only gives the correct answer because `f` and `g` have the same type, so a different comparison function is used. With the generic implementation, this gives the wrong answer:\n\n```\nsage: from sage.structure.richcmp import op_EQ\nsage: from sage.rings.morphism import RingMap\nsage: RingMap._richcmp_(f, g, op_EQ)  # should be False\nTrue\n```\n\nHere, `f(x)==g(x)` and `f(a*x)==g(a*x)` does not imply `f(a)==g(a)`, so the implementation relies on a cancellation property that does not hold in general.\n\nAs a module, `x` does not generate `R`, but `R` is generated by all monomials in `x`. In this case, the monomial `x^0` is the only generator for which the images of `a*x^0`, `b*x^0` allow to distinguish `f` and `g`.\n\nIt may be necessary to separate the implementations for rings and modules. For rings, it is enough to check that `f` and `g` agree on the generators of the ring and, recursively, on the generators of the base ring. For modules, I am not so sure \u2013 maybe we need to restrict to the case of module *homomorphisms* and raise a `NotImplementedError` otherwise.",
    "created_at": "2021-05-04T22:08:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400338",
    "user": "https://github.com/mwageringel"
}
```

If I am not mistaken, there is still a problem with the theory behind this. For example:

```
sage: S.<a,b> = QQ['a,b'].quotient(['a*b'])
sage: R.<x> = S['x']
sage: f = R.hom([b], R, base_map=S.hom([-a, b], S))
sage: g = R.hom([b], R)
sage: f == g  # False is correct
False
```

The above only gives the correct answer because `f` and `g` have the same type, so a different comparison function is used. With the generic implementation, this gives the wrong answer:

```
sage: from sage.structure.richcmp import op_EQ
sage: from sage.rings.morphism import RingMap
sage: RingMap._richcmp_(f, g, op_EQ)  # should be False
True
```

Here, `f(x)==g(x)` and `f(a*x)==g(a*x)` does not imply `f(a)==g(a)`, so the implementation relies on a cancellation property that does not hold in general.

As a module, `x` does not generate `R`, but `R` is generated by all monomials in `x`. In this case, the monomial `x^0` is the only generator for which the images of `a*x^0`, `b*x^0` allow to distinguish `f` and `g`.

It may be necessary to separate the implementations for rings and modules. For rings, it is enough to check that `f` and `g` agree on the generators of the ring and, recursively, on the generators of the base ring. For modules, I am not so sure – maybe we need to restrict to the case of module *homomorphisms* and raise a `NotImplementedError` otherwise.



---

archive/issue_comments_400339.json:
```json
{
    "body": "Replying to [comment:49 gh-mwageringel]:\n> so the implementation relies on a cancellation property that does not hold in general.\n\nGood point. \n\n> It may be necessary to separate the implementations for rings and modules. \n\nAssuming cancellation property is reasonable for most ring and modules in Sage. So I think the implementation is okay for generic morphisms. You just showed that it is not adequate for general rings. Fortunately Sage seems to provide a different implementation for the exceptional rings as you explained. \n\nI would document that the implementation for generic morphisms is assuming cancellation property so that future developers be warned for the trap.",
    "created_at": "2021-05-04T23:39:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400339",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:49 gh-mwageringel]:
> so the implementation relies on a cancellation property that does not hold in general.

Good point. 

> It may be necessary to separate the implementations for rings and modules. 

Assuming cancellation property is reasonable for most ring and modules in Sage. So I think the implementation is okay for generic morphisms. You just showed that it is not adequate for general rings. Fortunately Sage seems to provide a different implementation for the exceptional rings as you explained. 

I would document that the implementation for generic morphisms is assuming cancellation property so that future developers be warned for the trap.



---

archive/issue_comments_400340.json:
```json
{
    "body": "Why not just do\n\n```diff\n-coercion_model.bin_op(e, B.coerce(x), operator.mul)\n+e * B.coerce(x)\n```\n\nI find it easier to understand and it could use some optimizations that are present in `__mul__` (such as with integers and rationals).",
    "created_at": "2021-05-05T02:01:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400340",
    "user": "https://github.com/tscrim"
}
```

Why not just do

```diff
-coercion_model.bin_op(e, B.coerce(x), operator.mul)
+e * B.coerce(x)
```

I find it easier to understand and it could use some optimizations that are present in `__mul__` (such as with integers and rationals).



---

archive/issue_comments_400341.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-05T05:37:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400341",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400342.json:
```json
{
    "body": "Replying to [comment:50 klee]:\n> Assuming cancellation property is reasonable for most ring and modules in Sage. So I think the implementation is okay for generic morphisms. You just showed that it is not adequate for general rings. Fortunately Sage seems to provide a different implementation for the exceptional rings as you explained. \n\nThere are ways to construct the same maps but with different Python types, which seems to be the original motivation for #24281. Here are two examples, where the generic implementation is used:\n\n```\nsage: S.<a,b> = QQ['a,b'].quotient('a*b')\nsage: R.<x> = S[]\nsage: f = R.hom([b], R)\nsage: g = R.hom([b], R) * R.hom(S.hom([-a, b], S), R)\nsage: f == g  # should be False\nTrue\n```\n\n\n```\nsage: from sage.rings.polynomial.flatten import SpecializationMorphism\nsage: f2 = SpecializationMorphism(R, {x:b})\nsage: g2 = R.hom([b], S, base_map=S.hom([-a, b], S))\nsage: f2 == g2  # should be False\nTrue\n```\n\nSo making assumptions in the generic implementation which do not hold in general opens the door to mathematically wrong answers.",
    "created_at": "2021-05-05T07:54:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400342",
    "user": "https://github.com/mwageringel"
}
```

Replying to [comment:50 klee]:
> Assuming cancellation property is reasonable for most ring and modules in Sage. So I think the implementation is okay for generic morphisms. You just showed that it is not adequate for general rings. Fortunately Sage seems to provide a different implementation for the exceptional rings as you explained. 

There are ways to construct the same maps but with different Python types, which seems to be the original motivation for #24281. Here are two examples, where the generic implementation is used:

```
sage: S.<a,b> = QQ['a,b'].quotient('a*b')
sage: R.<x> = S[]
sage: f = R.hom([b], R)
sage: g = R.hom([b], R) * R.hom(S.hom([-a, b], S), R)
sage: f == g  # should be False
True
```


```
sage: from sage.rings.polynomial.flatten import SpecializationMorphism
sage: f2 = SpecializationMorphism(R, {x:b})
sage: g2 = R.hom([b], S, base_map=S.hom([-a, b], S))
sage: f2 == g2  # should be False
True
```

So making assumptions in the generic implementation which do not hold in general opens the door to mathematically wrong answers.



---

archive/issue_comments_400343.json:
```json
{
    "body": "Replying to [comment:53 gh-mwageringel]:\n> So making assumptions in the generic implementation which do not hold in general opens the door to mathematically wrong answers.\n\nI agree that the generic implementation is not perfect, and it needs to be replaced if someone comes up with a better one. On the other hand, the current patch solves the problem of this ticket by improving the implementation. \n\nIf a perfect solution is not around now, I suggest to open another ticket for it later.",
    "created_at": "2021-05-05T13:02:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400343",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:53 gh-mwageringel]:
> So making assumptions in the generic implementation which do not hold in general opens the door to mathematically wrong answers.

I agree that the generic implementation is not perfect, and it needs to be replaced if someone comes up with a better one. On the other hand, the current patch solves the problem of this ticket by improving the implementation. 

If a perfect solution is not around now, I suggest to open another ticket for it later.



---

archive/issue_comments_400344.json:
```json
{
    "body": "Replying to [comment:54 klee]:\n> On the other hand, the current patch solves the problem of this ticket by improving the implementation. \n\nYes, I agree the current branch is better than what we had. I am ok with these changes.\n\nJust one small comment:\n\n```diff\n+from sage.structure.coerce cimport coercion_model\n```\n\nThis import does not seem to be needed anymore.",
    "created_at": "2021-05-05T19:19:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400344",
    "user": "https://github.com/mwageringel"
}
```

Replying to [comment:54 klee]:
> On the other hand, the current patch solves the problem of this ticket by improving the implementation. 

Yes, I agree the current branch is better than what we had. I am ok with these changes.

Just one small comment:

```diff
+from sage.structure.coerce cimport coercion_model
```

This import does not seem to be needed anymore.



---

archive/issue_comments_400345.json:
```json
{
    "body": "I'm fine with closing this ticket as it is.\n\nHowever, I need to mention that while working on #21413 about two years ago, I already noticed that comparison of ring morphisms was not really reliable and I implemented my own equality checking in `sage.rings.ring_extension_morphism` (function `are_equal_morphisms`). Probably, this code should be merged in the class `RingHomomorphism` at some point.",
    "created_at": "2021-05-05T19:42:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400345",
    "user": "https://github.com/xcaruso"
}
```

I'm fine with closing this ticket as it is.

However, I need to mention that while working on #21413 about two years ago, I already noticed that comparison of ring morphisms was not really reliable and I implemented my own equality checking in `sage.rings.ring_extension_morphism` (function `are_equal_morphisms`). Probably, this code should be merged in the class `RingHomomorphism` at some point.



---

archive/issue_comments_400346.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-06T00:01:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400346",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400347.json:
```json
{
    "body": "Replying to [comment:55 gh-mwageringel]:\n> {{{#!diff\n> +from sage.structure.coerce cimport coercion_model\n> }}}\n> This import does not seem to be needed anymore.\n\nFixed. Thanks.",
    "created_at": "2021-05-06T00:14:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400347",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:55 gh-mwageringel]:
> {{{#!diff
> +from sage.structure.coerce cimport coercion_model
> }}}
> This import does not seem to be needed anymore.

Fixed. Thanks.



---

archive/issue_comments_400348.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-06T00:16:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400348",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400349.json:
```json
{
    "body": "Replying to [comment:56 caruso]:\n> I need to mention that while working on #21413 about two years ago, I already noticed that comparison of ring morphisms was not really reliable and I implemented my own equality checking in `sage.rings.ring_extension_morphism` (function `are_equal_morphisms`). Probably, this code should be merged in the class `RingHomomorphism` at some point.\n\nGood. You may provide the code to #31783.",
    "created_at": "2021-05-06T00:18:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400349",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:56 caruso]:
> I need to mention that while working on #21413 about two years ago, I already noticed that comparison of ring morphisms was not really reliable and I implemented my own equality checking in `sage.rings.ring_extension_morphism` (function `are_equal_morphisms`). Probably, this code should be merged in the class `RingHomomorphism` at some point.

Good. You may provide the code to #31783.



---

archive/issue_comments_400350.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-06T09:05:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400350",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_400351.json:
```json
{
    "body": "After some thought, I became not sure of the added comment that the problem of the comparison method is only the assumption of the cancellation property. So I rewrote it only about a fact.\n\nThere is no change in the code. As it was a green light, we may still assume green light.\n\nFurther discussion on the problem should continue in #31783.",
    "created_at": "2021-05-06T09:15:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400351",
    "user": "https://github.com/kwankyu"
}
```

After some thought, I became not sure of the added comment that the problem of the comparison method is only the assumption of the cancellation property. So I rewrote it only about a fact.

There is no change in the code. As it was a green light, we may still assume green light.

Further discussion on the problem should continue in #31783.



---

archive/issue_comments_400352.json:
```json
{
    "body": "Shouldn't we reset:\n\n```diff\n             if e is not None and isinstance(e, ModuleElement):\n                 B = (<ModuleElement>e)._parent._base\n                 gens = [e * B.coerce(x) for x in gens]\n+                e = None\n```\n\nOtherwise we wouldn't set `e` to be an element of `gens` on subsequent calls. This would only show up if we have to go more than twice down, which we may not have a doctest for.",
    "created_at": "2021-05-07T05:55:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400352",
    "user": "https://github.com/tscrim"
}
```

Shouldn't we reset:

```diff
             if e is not None and isinstance(e, ModuleElement):
                 B = (<ModuleElement>e)._parent._base
                 gens = [e * B.coerce(x) for x in gens]
+                e = None
```

Otherwise we wouldn't set `e` to be an element of `gens` on subsequent calls. This would only show up if we have to go more than twice down, which we may not have a doctest for.



---

archive/issue_comments_400353.json:
```json
{
    "body": "Replying to [comment:63 tscrim]:\n> Shouldn't we reset:\n> {{{#!diff\n>              if e is not None and isinstance(e, ModuleElement):\n>                  B = (<ModuleElement>e)._parent._base\n>                  gens = [e * B.coerce(x) for x in gens]\n> +                e = None\n> }}}\n> Otherwise we wouldn't set `e` to be an element of `gens` on subsequent calls. This would only show up if we have to go more than twice down, which we may not have a doctest for.\n\ne should remain as an element of the module. All base elements are coerced to the scalar ring of the module.",
    "created_at": "2021-05-07T06:02:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400353",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:63 tscrim]:
> Shouldn't we reset:
> {{{#!diff
>              if e is not None and isinstance(e, ModuleElement):
>                  B = (<ModuleElement>e)._parent._base
>                  gens = [e * B.coerce(x) for x in gens]
> +                e = None
> }}}
> Otherwise we wouldn't set `e` to be an element of `gens` on subsequent calls. This would only show up if we have to go more than twice down, which we may not have a doctest for.

e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.



---

archive/issue_comments_400354.json:
```json
{
    "body": "Replying to [comment:64 klee]:\n> Replying to [comment:63 tscrim]:\n> > Shouldn't we reset:\n> > [snip]\n> > Otherwise we wouldn't set `e` to be an element of `gens` on subsequent calls. This would only show up if we have to go more than twice down, which we may not have a doctest for.\n> \n> e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.\n\nI thought we wanted a recursion going a level deeper each time. Perhaps we can add a doctest for this behavior?",
    "created_at": "2021-05-07T06:10:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400354",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:64 klee]:
> Replying to [comment:63 tscrim]:
> > Shouldn't we reset:
> > [snip]
> > Otherwise we wouldn't set `e` to be an element of `gens` on subsequent calls. This would only show up if we have to go more than twice down, which we may not have a doctest for.
> 
> e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.

I thought we wanted a recursion going a level deeper each time. Perhaps we can add a doctest for this behavior?



---

archive/issue_comments_400355.json:
```json
{
    "body": "Replying to [comment:65 tscrim]:\n> Replying to [comment:64 klee]:\n> > e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.\n> \n> I thought we wanted a recursion going a level deeper each time. Perhaps we can add a doctest for this behavior?\n\nI think the recursion should limit to the base ring of the base ring for module morphisms. For ring morphisms, the implementation seems inherently flawed as Markus showed.\n\nAnyway, the patch fixes the problem of the ticket but do not alter the logic or algorithm of the implementation. The flaw of the algorithm should now be dealt with in #31783. I hope that someone with a proved algorithm propose a patch to completely fix the morphism comparison problem in Sage.",
    "created_at": "2021-05-09T10:00:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400355",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:65 tscrim]:
> Replying to [comment:64 klee]:
> > e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.
> 
> I thought we wanted a recursion going a level deeper each time. Perhaps we can add a doctest for this behavior?

I think the recursion should limit to the base ring of the base ring for module morphisms. For ring morphisms, the implementation seems inherently flawed as Markus showed.

Anyway, the patch fixes the problem of the ticket but do not alter the logic or algorithm of the implementation. The flaw of the algorithm should now be dealt with in #31783. I hope that someone with a proved algorithm propose a patch to completely fix the morphism comparison problem in Sage.



---

archive/issue_comments_400356.json:
```json
{
    "body": "Replying to [comment:66 klee]:\n> Replying to [comment:65 tscrim]:\n> > Replying to [comment:64 klee]:\n> > > e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.\n> > \n> > I thought we wanted a recursion going a level deeper each time. Perhaps we can add a doctest for this behavior?\n> \n> I think the recursion should limit to the base ring of the base ring for module morphisms. For ring morphisms, the implementation seems inherently flawed as Markus showed.\n\nI think it needs to go down as deep as possible. This is what the code currently does.\n\n> Anyway, the patch fixes the problem of the ticket but do not alter the logic or algorithm of the implementation. The flaw of the algorithm should now be dealt with in #31783. I hope that someone with a proved algorithm propose a patch to completely fix the morphism comparison problem in Sage. \n\nI am not fully convinced the logic has not changed. However, I am convinced enough that it works to let it in. I still would like a doctest doing the comparison with functions that are at least 2 deep in the recursion instead of just once to make sure it works. For example\n\n```\nZ[x] -> Z[x][y] -> Z[x][y][z]\n```\n\nwhere at each step we twist the generator `a -> -a`. I can write the doctest explicitly tomorrow.",
    "created_at": "2021-05-11T07:04:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400356",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:66 klee]:
> Replying to [comment:65 tscrim]:
> > Replying to [comment:64 klee]:
> > > e should remain as an element of the module. All base elements are coerced to the scalar ring of the module.
> > 
> > I thought we wanted a recursion going a level deeper each time. Perhaps we can add a doctest for this behavior?
> 
> I think the recursion should limit to the base ring of the base ring for module morphisms. For ring morphisms, the implementation seems inherently flawed as Markus showed.

I think it needs to go down as deep as possible. This is what the code currently does.

> Anyway, the patch fixes the problem of the ticket but do not alter the logic or algorithm of the implementation. The flaw of the algorithm should now be dealt with in #31783. I hope that someone with a proved algorithm propose a patch to completely fix the morphism comparison problem in Sage. 

I am not fully convinced the logic has not changed. However, I am convinced enough that it works to let it in. I still would like a doctest doing the comparison with functions that are at least 2 deep in the recursion instead of just once to make sure it works. For example

```
Z[x] -> Z[x][y] -> Z[x][y][z]
```

where at each step we twist the generator `a -> -a`. I can write the doctest explicitly tomorrow.



---

archive/issue_comments_400357.json:
```json
{
    "body": "Replying to [comment:67 tscrim]:\n> I think the recursion should limit to the base ring of the base ring for module morphisms. For ring morphisms, the implementation seems inherently flawed as Markus showed.\n> \n> I think it needs to go down as deep as possible. This is what the code currently does.\n\nI tried to mean the recursion happens only within the base ring (not the module). My sentence was not clear. Sorry.\n\n> I still would like a doctest doing the comparison with functions that are at least 2 deep in the recursion instead of just once to make sure it works. For example\n> {{{\n> Z[x] -> Z[x][y] -> Z[x][y][z]\n> }}}\n> where at each step we twist the generator `a -> -a`. I can write the doctest explicitly tomorrow.\n\nComparison of ring homomorphisms will be dealt with the code in #31783. It would be better that your doctest for the present ticket is about module homomorphisms.",
    "created_at": "2021-05-11T08:07:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400357",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:67 tscrim]:
> I think the recursion should limit to the base ring of the base ring for module morphisms. For ring morphisms, the implementation seems inherently flawed as Markus showed.
> 
> I think it needs to go down as deep as possible. This is what the code currently does.

I tried to mean the recursion happens only within the base ring (not the module). My sentence was not clear. Sorry.

> I still would like a doctest doing the comparison with functions that are at least 2 deep in the recursion instead of just once to make sure it works. For example
> {{{
> Z[x] -> Z[x][y] -> Z[x][y][z]
> }}}
> where at each step we twist the generator `a -> -a`. I can write the doctest explicitly tomorrow.

Comparison of ring homomorphisms will be dealt with the code in #31783. It would be better that your doctest for the present ticket is about module homomorphisms.



---

archive/issue_comments_400358.json:
```json
{
    "body": "As suggested by Kwankyu, I think that we should close this ticket now (in order to fix the issue as soon as possible) and continue the discussion (which could take some time) in #31783.\n\nThat's why I'm giving again a positive review to this ticket. Feel free to revert this decision if you strongly disagree.",
    "created_at": "2021-05-11T13:22:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400358",
    "user": "https://github.com/xcaruso"
}
```

As suggested by Kwankyu, I think that we should close this ticket now (in order to fix the issue as soon as possible) and continue the discussion (which could take some time) in #31783.

That's why I'm giving again a positive review to this ticket. Feel free to revert this decision if you strongly disagree.



---

archive/issue_comments_400359.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-05-11T13:22:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400359",
    "user": "https://github.com/xcaruso"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_400360.json:
```json
{
    "body": "(Hope it's correct this time. Sorry for the inconvenience.)",
    "created_at": "2021-05-11T13:25:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400360",
    "user": "https://github.com/xcaruso"
}
```

(Hope it's correct this time. Sorry for the inconvenience.)



---

archive/issue_comments_400361.json:
```json
{
    "body": "I don't know of a good test for this, so okay, let it be.",
    "created_at": "2021-05-12T06:58:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400361",
    "user": "https://github.com/tscrim"
}
```

I don't know of a good test for this, so okay, let it be.



---

archive/issue_events_026271.json:
```json
{
    "actor": "@vbraun",
    "created_at": "2021-05-27T20:29:21Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28380#event-26271"
}
```



---

archive/issue_comments_400362.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2021-05-27T20:29:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28380",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28380#issuecomment-400362",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
