# Issue 29032: Add call to cliquer with custom cliques sizes

Issue created by migration from https://trac.sagemath.org/ticket/29269

Original creator: @Fightlapa

Original creation time: 2020-03-02 20:23:38

Keywords: cliquer, graphs

Currently only maximum/maximal cliques can be obtained by calling cliquer functions. With this change custom cliques can be obtained with cliquer.


---

Comment by git created at 2020-03-03 19:16:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Fightlapa created at 2020-03-03 19:18:35

Code could be reused, as this is almost copy-paste of another function. But if it will be fine, will do that and push "clean" version.


---

Comment by dcoudert created at 2020-03-03 23:45:31

Welcome to Sagemath.

You could add tests of corner cases, like small graphs (empty, 1 or 2 vertices), disconnected graphs and graphs with multiple edges.

Have you tested the code on a large graph to see what it supports ?

Also, you will have to improve the coding style (see https://www.python.org/dev/peps/pep-0008/) and ensure that comments are formatted in 80 columns mode.


---

Comment by @Fightlapa created at 2020-03-05 16:05:28

I'm still testing it. I see already one wrong result. I'm investigating it now.


---

Comment by git created at 2020-03-05 17:06:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Fightlapa created at 2020-03-05 21:34:59

Changing status from new to needs_review.


---

Comment by dcoudert created at 2020-03-06 08:18:47

a few comments
- first line of method `all_cliques`

```diff
+    Return the vertex sets of *ALL* the complete subgraphs.
+    Returns the vertex sets of *ALL* the complete subgraphs.
```

- add an `INPUT` block with the description of input parameters
- `if not graph.order():` -> `if not graph:`
- I don't understand this case `if min_size == 0 and max_size > 0:`. Not documented
- I suggest to free the graph right after the `sig_off`
- Could you improve the presentation of the code in `cl.c` and add some documentation. 

I don't know if it is possible, but it would be much better if we could turn this method into an iterator. If the number of cliques to report is large, we may have a segfault. Not clear if the design of cliquer allows that.


---

Comment by dcoudert created at 2020-03-07 10:22:25

According the documentation of cliquer (https://users.aalto.fi/~pat/cliquer.html), it seems possible to avoid storing all cliques (re-entrant methods). So it seems possible to make an iterator, but I don't know how complex it is to do so.


---

Comment by git created at 2020-03-07 11:17:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-03-07 11:19:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Fightlapa created at 2020-03-07 11:24:01

Sorry for those messy commits. Anyway, it's my first time with Cython, I'm not also that familiar with c++. I think I'm not capable of making iterator out of it.


---

Comment by dcoudert created at 2020-03-08 13:45:30

- The documentation is unclear on whether you search for cliques with number of vertices or edges between min and max, or if you consider the weight of the cliques. Please clarify
- if the default value of `min_size` is 0, it must be set if the input, that is `def all_cliques(graph, min_size=0, max_size=0):`
- alignement (and text) of input parameters

```diff
-    - ``min_size`` -- Search for cliques with weight at least N. If N=0,
-                      searches for maximum weight clique (default).
+    - ``min_size`` -- integer (default: 0); minimum size of the cliques to report.
+      When set to 0 (default), searched for a maximum weight clique.
```

- add doctests for the default case of the parameters
- don't sorted cliques at the end
- also, could change the branch name to something like `public/graphs/29269_all_cliques` (i.e., use in a new branch). When the branch is in `public/`, I can push review commit, which is usually faster for me.

- concerning the iterator, for the moment you can at least make method `all_cliques` yield cliques instead of returning a full list. Then we will have to find a way to make method `sage_find_all_clique` re-entrant, and so avoid to store all cliques.


---

Comment by git created at 2020-03-10 12:00:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-03-10 14:59:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-03-10 15:00:42

I rebased the ticket on last beta and did a few review edits. Please check them.

I remains to expose this iterator in `graph.py`.


---

Comment by @Fightlapa created at 2020-03-10 15:27:44

Okay. Does it mean this change is fine for now?


---

Comment by dcoudert created at 2020-03-10 15:37:29

You still have to expose the method in graph.py (check at the bottom of the file to see how. And you can also do further improvements if you have some in mind. You can also investigate the re-entrant capability of cliquer, at least to understand how to use it and discuss what we can do with it.


---

Comment by git created at 2020-03-10 17:59:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Fightlapa created at 2020-03-10 18:07:29

In terms of making it re-entrant my first idea is (not ideal):
Making use of global variables, which are currently reseted per call.
It would require to save last graph pointer on which was call made, other parameters and saving counter.
Then each call with same graph and other parameters would just progress to next clique and return only one, while increasing counter.

Drawbacks - only 1 instance of iteration is possible, nested call on same graph with same parameters will use same counter and won't be detected as something different. Generally, it's bad solution, but I'm not familiar with C and don't know the possibilities.

Or maybe I'm wrong about how the code is executed.


---

Comment by dcoudert created at 2020-03-11 15:01:53

I don't know either how to do it and don't have time now to investigate. It's mentioned in a todo block.

Please check the (small) error reported by the patchbot.


---

Comment by git created at 2020-03-12 16:47:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-03-25 08:36:42

For reentering something as this might be useful:

Instead of the loop

```
for (j = 0; j < sage_clique_count; j++)
```

you can pass a pointer to to `j` to the function

```
int sage_find_all_clique(graph_t *g, int **list, int min_size, int max_size, int* j)
```

On the first call `j` can be initiated to `-1` and therefore the function knows that it should initialize. Then on each further call it can just obtain partial list for `j` and return its length. If the length is `-1` this means that the iterator is exhausted.

One more thing. It would be nice if indices for counting are consistent. A few lines before you use `i` for the exact same thing. It makes it a bit easier to read if it's always `sage_clique_list[j]` or `sage_clique_list[i]`.


---

Comment by @kliem created at 2020-03-25 08:36:42

Changing type from PLEASE CHANGE to enhancement.


---

Comment by dcoudert created at 2020-03-25 09:48:43

Thank you for the explanation.

We will certainly have to build an object to encapsulate this and so make sure that we properly release memory when the iterator is no longer use.


---

Comment by @kliem created at 2020-03-25 10:59:33

I see the problem.

I believe the class `MemoryAllocator` (`from sage.ext.memory_allocator cimport MemoryAllocator`) should be used here. It should definitely be used to allocate `list_of_vertices`, because there is no guarantee that we ever reach `sig_free(list_of_vertices)`. If we revisit `sage_find_all_clique` for each clique, we can even allocate `list_of_vertices` right from the start, as it only needs to fit one clique.

Instead of calling `set_free`, we can also let `MemoryAllocator` take care of it (but thats somewhat a hack). We probably need a preparation function as well. This preparation functions sets up `sage_clique_list` and takes care that for each clique `s` the pointer `&s[-1]` is stored in `MemoryAllocator`.

Then when the iterator is destroyed then so is the `MemoryAllocator`, which takes care of all the rest.

Am I making any sense?

Here are some code snippets to explain what I mean:

In `all_cliques`:


```
cdef void** clique_memory
cdef MemoryAllocator mem = MemoryAllocator()
cdef int* list_of_vertices = <int*> mem.alloc_array(max_size, sizeof(int))
cdef int num_cliques = initialize_sage_find_all_clique(g, &clique_memory, min_size, max_size)
mem.resize(num_cliques + 1)
for i in range(num_cliques):
    mem.pointers[mem.n] = clique_memory[i]
    mem.n += 1
sig_free(clique_memory)
```


Now all the memory is stored in `mem` and will be free automatically, if the iterator is interrupted.

The function `initialize_sage_find_all_clique` could look something like this:


```diff
+int initialize_sage_find_all_clique(graph_t *g,void **list, int min_size, int max_size){
+  sage_reset_global_variables();
+  quiet++;
+  maximal = FALSE;
+  int i, j, l;
+
+  clique_options *opts = sage_init_clique_opt();
+  clique_unweighted_find_all(g, min_size, max_size, maximal, opts);
+  free(opts);
+
+  int size = 0;
+  *list = malloc(sizeof(void *) * sage_clique_count);
+  for (i = 0; i < sage_clique_count; i++) {
+    list[i] = &(sage_clique_list[i][-1]);
+  }
+  return sage_clique_count


---

Comment by dcoudert created at 2020-03-25 11:57:22

Yes, this is the idea, and all that inside a small class with a constructor, a destructor and a method `__iter__`.

My only question is whether we can have several calls to cliquer at the same time, that is if we can have to instances of the proposed iterator at the same time.


---

Comment by @kliem created at 2020-03-25 14:24:27

I don't think that is a problem to have multiple instances arround. But we would have to rewrite parts of `cliquer/cl.c`.

I like the idea of a small class better. Then the `__dealloc__` method could call the corresponding c-functions that take care of the destruction and we wouldn't need such a hack anymore.


---

Comment by dcoudert created at 2020-03-25 18:15:54

1. now we must decide if we implement this in this ticket, or if we first finalize this ticket, and then open a new ticket, based on this one, to implement the proposed changes. I have no clear opinion on that.

2. I noticed that the current branch contains some modifications of `graph.py` that are not related to this ticket. In general, we should not do that in order to avoid possible conflicts with other tickets.


---

Comment by @kliem created at 2020-03-26 09:44:34

Replying to [comment:30 dcoudert]:
> 1. now we must decide if we implement this in this ticket, or if we first finalize this ticket, and then open a new ticket, based on this one, to implement the proposed changes. I have no clear opinion on that.

I would vote for leaving this for another ticket. It looks to me like all the functions need some work. E.g. there are `sig_on`/`sig_off` statements everywhere in `cliquer.pyx` and there is no care taken that the deallocation is done in case of interrupt. I believe this should be done in a `try`/`finally` matter, such that the deallocation is done whether not the code is interrupted. Maybe I'm also misunderstanding things.

So if we put `list_of_vertices` in a `MemoryAllocator` so that `list_of_vertices` is freed automatically if the iterated is disposed of, I would be fine with it.
> 
> 2. I noticed that the current branch contains some modifications of `graph.py` that are not related to this ticket. In general, we should not do that in order to avoid possible conflicts with other tickets.
>


---

Comment by dcoudert created at 2020-03-26 10:29:37

In the current implementation, `list_of_vertices` is allocated in `cl.c`. Therefore, I don't see how to put it inside a `MemoryAllocator`.
However, we can do something like that:

```diff
-    for i in range(size):
-        if list_of_vertices[i] != -1:
-            c.append(int_to_vertex[list_of_vertices[i]])
-        else:
-            yield c
-            c = []
-
+    try:
+        for i in range(size):
+            if list_of_vertices[i] != -1:
+                c.append(int_to_vertex[list_of_vertices[i]])
+            else:
+                yield c
+                c = []
+    finally:
+        sig_free(list_of_vertices)
```



---

Comment by @kliem created at 2020-03-26 10:39:48

We do the following right after `graph_free(g)`:

```
cdef MemoryAllocator mem = MemoryAllocator()
mem.resize(mem.n + 1)
mem.pointers[mem.n] = list_of_vertices
mem.n += 1
```

This should do the job. It's not a nice solutions, but it should at least avoid a memory leak in most use cases. Still a keyboard interrupt most likely creates a memory leak, but I think that is a problem for all of those functions.


---

Comment by dcoudert created at 2020-03-26 10:44:42

Are you sure that the memory allocator destructor is effectively called in case of keyboard interrupt ? At least I tried the solution I proposed and the finally statement is always called.


---

Comment by @kliem created at 2020-03-26 10:50:58

I just tried your solutions and it works just fine and is much simpler anyway:


```
sage: cython('''
....: def foo():
....:     try:
....:         while True: yield 1
....:     finally:
....:         print('hello')
....: ''')
sage: it = foo()
sage: next(it)
1
sage: del it
hello
```


So I propose changing the code like this:


```
    try:
        try:
            sig_on()
            size = sage_find_all_clique(g, &list_of_vertices, min_size, max_size)
            sig_off()
        finally:
            graph_free(g)
        cdef list c = []
        for i in range(size):
            if list_of_vertices[i] != -1:
                c.append(int_to_vertex[list_of_vertices[i]])
            else:
                yield c
                c = []
    finally:
        if list_of_vertices:  # maybe computation was interrupted before allocating `list_of_vertices`
            sig_free(list_of_vertices)
```


With a little more effort we could even ensure that `sage_clique_list` is freed even if the calculation is interrupted.


---

Comment by dcoudert created at 2020-03-26 11:05:48

+1 for propose change. The branch is public, so we can implement it, except if gh-Fightlapa is willing to do it.

Concerning `sage_clique_list`, it's much more tricky as it is in C, not C++. Some solutions are proposed here
https://stackoverflow.com/questions/10586003/try-catch-statements-in-c. But we should wait for another ticket, and try to turn the code to c++ to enable the use of proper try-catch-finally statements.


---

Comment by @kliem created at 2020-03-26 11:17:11

Ok, I can do it. According to your suggestion, I would get rid of the last commit that fixed some pyflakes issues in graphes.py that have nothing to do with the current ticket.

I was thinking about a second function that deallocates `sage_clique_list`, but that should probably be left to a second ticket.

+1 for going to C++ in another ticket. As you already mentioned before, it would be good to have more than one `sage_clique_list` around and that sounds very much like a class.


---

Comment by git created at 2020-03-26 11:41:20

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2020-03-26 11:54:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-03-26 11:56:33

Done.


---

Comment by git created at 2020-03-26 12:09:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-03-26 12:11:05

a small review commit to avoid using variable `size` uninitialized.

If OK for you, you can set this ticket to positive review on my behalf. Don't forget to add your name as co-author.


---

Comment by @kliem created at 2020-03-26 12:13:29

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-04-16 22:35:28

Changing status from positive_review to needs_info.


---

Comment by vbraun created at 2020-04-16 22:35:28

The "Dependencies" field must be a list of trac tickets


---

Comment by @kliem created at 2020-04-17 05:59:38

Sorry, missed that. That's obsolete as cliquer is a standard package.


---

Comment by @kliem created at 2020-04-17 05:59:38

Changing status from needs_info to positive_review.


---

Comment by vbraun created at 2020-04-18 08:41:44

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2020-04-18 08:41:44

Merge conflict, please fix


---

Comment by dcoudert created at 2020-04-18 09:55:56

this might be due to #29518. So let's wait for next release to see what's the conflict.


---

Comment by @kliem created at 2020-04-25 20:44:32

Replying to [comment:47 dcoudert]:
> this might be due to #29518. So let's wait for next release to see what's the conflict.

That's exactly the problem. Doesn't make sense to add a function to a lazy import that will be removed soon. And it should be a method of a graph, this is where it belongs.


---

Comment by @kliem created at 2020-04-25 20:44:59

New commits:


---

Comment by @kliem created at 2020-04-25 20:47:53

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2020-04-26 12:56:31

Changing status from needs_review to positive_review.


---

Comment by dcoudert created at 2020-04-26 12:56:31

LGTM.


---

Comment by vbraun created at 2020-05-02 21:57:59

Resolution: fixed
