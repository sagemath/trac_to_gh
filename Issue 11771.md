# Issue 11771: The category graph should comply with Python's method resolution order

Issue created by migration from Trac.

Original creator: SimonKing

Original creation time: 2011-10-21 14:28:01

Assignee: nthiery

CC:  hivert mderickx

Keywords: category graph, method resolution order

Let C be a category. `C.all_super_categories()` starts with `C.super_categories()` and finds all super categories inductively. 

Unfortunately, the algorithm of `C.all_super_categories()` does not comply with the C3 algorithm, that is used by Python to determine the method resolution order for `C.parent_class` and `C.element_class`. 

The aim of this ticket is to be more consistent. Eventually, for any category C (perhaps with modifications for hom categories), one should have

```
sage: C.parent_class.mro() == [X.parent_class for X in C.all_super_categories()] + [object]
True
sage: C.element_class.mro() == [X.element_class for X in C.all_super_categories()] + [object]
True
```

and that test should become part of the test suite.

At #11900, the implementation of `all_super_categories()` has been changed, so, work should rely on #11900.

Unfortunately, it seems that the C3 algorithm can not simply be imported from Python, even though Python uses it internally, namely in `Objects/typeobject.c`. Looking at the implementation, it requires that one gets a list of types, while we want to use it on a list of objects.

Therefore, we need to implement C3 from scratch. Implementing C3 is easy, but if it shall be fast, one needs to be careful.

In particular, one needs to be able to `L.pop(0)` quickly, where L is a list. Unfortunately, `L.pop(0)` is slow, even in Cython. I found that, if the lists are not too long, it is best to revert L and do `L.pop()` instead, which is optimized in Cython. See the discussion at [sage-devel](http://groups.google.com/group/sage-support/browse_thread/thread/317aecee64ddab48).

My plan is:

 * Provide the C3 algorithm in a new extension module `sage.misc.c3`
 * Use it to compute `all_super_categories()`
 * Add a test `_test_category_graph`, asserting that `self.parent_class.mro()` and `self.all_super_categories()` are compatible.

First tests indicate that the change of order on `C.all_super_categories()` is fine (sage does not crash, and most tests in sage.categories pass. However, one really needs to look at the performance.


---

Comment by SimonKing created at 2011-10-21 16:22:13

With the new test, I found a bug in algebra_ideals:

```
sage: C = AlgebraIdeals(FreeAlgebra(QQ,2,'a,b'))
sage: C.parent_class
ERROR: An unexpected error occurred while tokenizing input
The following traceback may be corrupted or invalid
The error message is: ('EOF in multi-line statement', (396, 0))

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/king/Seminar/<ipython console> in <module>()

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/misc/lazy_attribute.pyc in __get__(self, a, cls)
    507         if a is None: # when doing cls.x for cls a class and x a lazy attribute
    508             return self
--> 509         result = self.f(a)
    510         if result is NotImplemented:
    511             # Workaround: we make sure that cls is the class

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/categories/category.pyc in parent_class(self)
    626         """
    627         return dynamic_class("%s.parent_class"%self.__class__.__name__,
--> 628                              tuple(cat.parent_class for cat in self.super_categories()),
    629                              self.ParentMethods,
    630                              reduction = (getattr, (self, "parent_class")))

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/misc/cachefunc.pyc in __call__(self, *args, **kwds)
    553             return self.cache[k]
    554         except KeyError:
--> 555             w = self._cachedmethod._instance_call(self._instance, *args, **kwds)
    556             self.cache[k] = w
    557             return w

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/misc/cachefunc.pyc in _instance_call(self, inst, *args, **kwds)
    776 
    777         """
--> 778         return self._cachedfunc.f(inst, *args, **kwds)
    779 
    780     def _get_instance_cache(self, inst):

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/categories/algebra_ideals.pyc in super_categories(self)
     67             [Category of algebra modules over Univariate Polynomial Ring in x over Rational Field]
     68         """
     69         from algebra_modules import AlgebraModules
     70         R = self.algebra()
---> 71         return [AlgebraModules(R)]

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/misc/classcall_metaclass.pyc in __call__(cls, *args, **options)
    256             return cls.__classcall_private__(cls, *args, **options)
    257         elif hasattr(cls, "__classcall__"):
--> 258             return cls.__classcall__(cls, *args, **options)
    259         else:
    260             return type.__call__(cls, *args, **options)

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/misc/cachefunc.pyc in __call__(self, *args, **kwds)
    176             return self.cache[k]
    177         except KeyError:
--> 178             w = self.f(*args, **kwds)
    179             self.cache[k] = w
    180             return w

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/structure/unique_representation.pyc in __classcall__(cls, *args, **options)
    447             True
    448         """
--> 449         instance = type.__call__(cls, *args, **options)
    450         assert isinstance( instance, cls )
    451         if instance.__class__.__reduce__ == UniqueRepresentation.__reduce__:

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/categories/algebra_modules.pyc in __init__(self, A)
     53         from sage.categories.commutative_algebras import CommutativeAlgebras
     54         if not hasattr(A, "base_ring") or not A in CommutativeAlgebras(A.base_ring()):
---> 55             raise TypeError, "A (=%s) must be a commutative algebra"%A
     56         Category_module.__init__(self, A)
     57 

TypeError: A (=Free Algebra on 2 generators (a, b) over Rational Field) must be a commutative algebra
```


Thus, apparently, that category has never been used.

The problem is that the super categories of the category of algebra ideals should be the category of algebra modules. However, while the former accepts non-commutative algebras, the latter wants to see commutative algebras.

The clean way to proceed would be: Make algebra modules work over non-commutative rings. If that is too much of work, C.super_categories() should be `[]` if C is the category of algebra ideals over a non-commutative rings.


---

Comment by SimonKing created at 2011-10-21 21:15:59

Changing status from new to needs_review.


---

Comment by SimonKing created at 2011-10-21 21:15:59

Patch's up!

To my surprise, the change in the order of super categories was relatively harmless. In few cases, a test involving all_super_categories had to change.

I added a test `_test_category_graph` to the Test Suite of categories. By that test, I found one bug in algebra_ideals, which I fixed. Hom categories can not use the new test yet, since it tests the mro of the parent class against the list of parent classes of all super categories - which is fairly inconsistent for hom categories. That is already a "to do", and should be part of the next category overhaule.

Apart from these small changes, all doc tests passed! In particular, I did not need to change `super_categories` (except for algebra ideals): The current category graph seems to be consistent!!

That was the good news.

The bad news is that we have a regression in the computation of `all_super_categories`. With #11900, we have

```
sage: L = [Algebras(GF(p)) for p in prime_range(10000)]
sage: %time X = [C.all_super_categories() for C in L]
CPU times: user 0.74 s, sys: 0.01 s, total: 0.75 s
Wall time: 0.75 s
```

With the patches from here added, we only have

```
sage: L = [Algebras(GF(p)) for p in prime_range(10000)]
sage: %time X = [C.all_super_categories() for C in L]
CPU times: user 1.06 s, sys: 0.02 s, total: 1.07 s
Wall time: 1.08 s
```


I tried hard to make my C3 implementation as fast as possible in the range we need: few lists (say, 4) of moderate length (not more than 60).

I think the performance should be improved. But a review can already be started.


---

Comment by nthiery created at 2011-10-21 22:10:46

Replying to [comment:1 SimonKing]:
> With the new test, I found a bug in algebra_ideals:
> The problem is that the super categories of the category of algebra ideals should be the category of algebra modules. However, while the former accepts non-commutative algebras, the latter wants to see commutative algebras.
> The clean way to proceed would be: Make algebra modules work over non-commutative rings. If that is too much of work, C.super_categories() should be `[]` if C is the category of algebra ideals over a non-commutative rings.

+1. Actually my patch on #10963 is adding a TODO about it :-)


---

Comment by nthiery created at 2011-10-21 22:13:55

Replying to [comment:2 SimonKing]:
> To my surprise, the change in the order of super categories was relatively harmless. In few cases, a test involving all_super_categories had to change.

I am not so surprised, since most categories are actually used by some
parent (which detects any incompatibility). But it's very nice to
detect such incompatibilities earlier on and to catch them
systematically in the TestSuite!

Cheers,
            Nicolas


---

Comment by SimonKing created at 2011-10-23 14:08:28

I tried to track down the regression of `all_super_categories`. Recall that my patch from #11900 did improve the implementation of `all_super_categories`, but did not change the algorithm.

With #11900, the main work is done in `_all_super_categories_raw`. With the patch from here, the work is done in `c3_algorithm` - and according to %prun, _less_ time is spent in `c3_algorithm` than it was in `_all_super_categories_raw`. However, more time is spent in the expression

```
C.all_super_categories() for C in self.super_categories()
```

I guess I have to improve the implementation of the recursion.


---

Comment by SimonKing created at 2011-10-23 14:13:11

PS: It also seems that much time is spent in `super_categories()`, which is a cached method. Probably it would be better to turn it into a lazy attribute (or have _two_ lazy attributes, namely for the case `proper=True` and `proper=False`).

Namely, even though #11115 will almost totally reduce the overhead of calling a cached function, a lazy attribute will always be faster.


---

Comment by SimonKing created at 2011-10-23 16:27:38

Replying to [comment:6 SimonKing]:
> PS: It also seems that much time is spent in `super_categories()`, which is a cached method. Probably it would be better to turn it into a lazy attribute (or have _two_ lazy attributes, namely for the case `proper=True` and `proper=False`).

Sorry, I meant: One lazy attribute C.super_categories, and two lazy attributes C.all_super_categories and C.all_super_categories_proper (super_categories() has no arguments).


---

Comment by SimonKing created at 2011-10-23 21:48:56

I have created a more invasive patch: It turns `C.super_categories()` and `C.all_super_categories(proper)` into lazy attributes, and it uses the C3 algorithm in a more efficient way.

The two patches are alternative. Personally, I prefer the second patch. If the reviewer disagrees and suggests to use the first patch, I'd like to add one improvement to the first patch. If the reviewer agrees with me, then eventually either this patch or the patch from #11935 needs to be rebased.

I just tested that all doctests pass, with sage-4.7.2.alpha3+#11900+the second patch from here.

And here are some timings:
With just #11900:

```
king`@`mpc622:/mnt/local/king/SAGE/rebase/sage-4.7.2.alpha3$ time ./sage elltest1.sage

real    0m18.089s
user    0m17.633s
sys     0m0.344s
king`@`mpc622:/mnt/local/king/SAGE/rebase/sage-4.7.2.alpha3$ time ./sage ellbsd.sage

real    0m5.578s
user    0m5.084s
sys     0m0.400s
```

and

```
sage: L = [Algebras(GF(p)) for p in prime_range(10000)]
sage: %time X = [C.all_super_categories() for C in L]
CPU times: user 0.72 s, sys: 0.01 s, total: 0.72 s
Wall time: 0.73 s
```


With #11900+the second patch from here:

```
king`@`mpc622:/mnt/local/king/SAGE/rebase/sage-4.7.2.alpha3$ time ./sage elltest1.sage

real    0m17.799s
user    0m17.333s
sys     0m0.384s
king`@`mpc622:/mnt/local/king/SAGE/rebase/sage-4.7.2.alpha3$ time ./sage ellbsd.sage

real    0m5.408s
user    0m4.956s
sys     0m0.376s
```

and

```
sage: L = [Algebras(GF(p)) for p in prime_range(10000)]
# all_super_categories is lazy now, we are not calling it
sage: %time X = [C.all_super_categories for C in L]
CPU times: user 0.54 s, sys: 0.00 s, total: 0.54 s
Wall time: 0.54 s
```


Note an additional doc test, demonstrating that the new version of all_super_categories can detect inconsistencies:

```
sage: class X(Category):
...    `@`lazy_attribute
...    def super_categories(self):
...        return [Objects()]
sage: class X(Category):
...    `@`lazy_attribute
...    def super_categories(self):
...        return [Objects()]
sage: class Y(Category):
...    `@`lazy_attribute
...    def super_categories(self):
...        return [Objects()]
sage: class A(Category):
...    `@`lazy_attribute
...    def super_categories(self):
...        return [X(),Y()]
sage: class B(Category):
...    `@`lazy_attribute
...    def super_categories(self):
...        return [Y(),X()]
sage: class Foo(Category):
...    `@`lazy_attribute
...    def super_categories(self):
...       return [A(),B()]
sage: F = Foo()
```

Python is not able to create a consistent mro for the parent class - and all_super_categories detects that inconsistency as well:

```
sage: F.parent_class
Traceback (most recent call last):
...
TypeError: Cannot create a consistent method resolution
order (MRO) for bases X.parent_class, Y.parent_class
sage: F.all_super_categories
Traceback (most recent call last):
...
ValueError: Can not merge the items Category of x, Category of y.
```


Of course, there still is the new consistency test for the category graph in the test suite.

So, it can really be reviewed now, and my suggestion is:

Apply trac11943_mro_for_all_super_categories_lazy.patch


---

Comment by SimonKing created at 2011-10-26 19:20:20

There was no reply on sage-combinat-devel and only little reply on sage-devel: The only reply was Jason Grout stating that the use of attributes is often more pythonic than the use of a method.

So, the idea to turn super_categories and all_super_categories into lazy attributes is supported.


---

Comment by SimonKing created at 2011-10-29 05:53:52

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2011-10-29 05:53:52

[Maarten](http://groups.google.com/group/sage-devel/browse_thread/thread/ab03a0d422810e73) suggested the following:

```
What I think would be the best solution in this case would be is:

make lazy attributes

_super_categories and
_all_super_categories

Make the functions super_categories and all_super_categories say in the
documentation that developers shouldn't use these but that they should use
the lazy attributes.
```


I think that this would be a very good solution indeed.


---

Comment by SimonKing created at 2011-10-29 08:53:25

I think the following model is best for preserving backwards compatibility:

 * If one wants to provide the super categories of a category, one should implement a method super_categories() - this is what one would currently do.
 * There is a new lazy attribute _super_categories defined for the base class of categories. That lazy attribute calls the method super_categories(). Of course, calling the method happens only once, so that the speed is acceptable.
 * In all _applications_, the method call super_categories() shall be replaced by getting the attribute _super_categories. That is explained in a note to the developers in the documentation of super_categories.
 * There is a lazy attribute _all_super_categories and _all_super_categories_proper, and there is still a method all_super_categories(proper=False). The method returns the appropriate lazy attribute, and the documentation of the method states that one should better use the lazy attributes.


---

Comment by SimonKing created at 2011-10-29 15:17:21

I have changed my patch according to what I learnt from the discussion on [sage-devel](http://groups.google.com/group/sage-devel/browse_thread/thread/ab03a0d422810e73). Namely:

 * I preserved the old methods `super_categories` and `all_super_categories`, so that the users can still work with them and can read their documentation. 
 * In particular, if one wants to define a new category, one would still define a _method_ (no need for a cached method) called `super_categories` that returns the immediate super categories. However, the documentation now also states that internally (i.e., for development), the new lazy attributes explained below should be used.
 * The patch introduces three lazy attributes `_super_categories`, `_all_super_categories` and `_all_super_categories_proper` that carry the lists of (immediate or all) super categories. If one asks for the super categories in code, the fastest way is to request these lazy attributes, not calling the old methods.

Anyway, why do I see a need to make things faster? Recall that the purpose of this ticket is to order the list of all super categories according to Python's method resolution order, i.e., the C3 algorithm. I did my very best to implement the C3 algorithm as fast as possible. However:

 * When I keep super_categories() what they are, then even my best attempt to implement all_super_categories based on C3 resulted in a mild regression.
 * When I keep super_categories() what they are (namely cached methods) and use #11115, then there is neither a regression nor a speed-up.
 * When I replace super_categories() by _super_categories (a lazy attribute), then I am getting a speed-up, even without #11115.

Here are the data. I've run `sage -t devel/sage/sage/schemes/` and found these total running times:

 * 620.7 seconds with sage-4.7.3.alpha3
 * 600.1 seconds with sage-4.7.3.alpha3 and #11943 (plus dependencies)

That's not much (3.3% speedup), but certainly better than a regression.


---

Comment by SimonKing created at 2011-10-29 15:17:21

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2011-10-29 15:21:33

I forgot the patch bot:

Apply trac11943_mro_for_all_super_categories_lazy.patch


---

Comment by SimonKing created at 2011-11-03 09:03:25

There is a new suggestion, also based on the [sage-devel thread](http://groups.google.com/group/sage-devel/browse_thread/thread/ab03a0d422810e73):

If we want to test whether a category C is a super category of a category D, then we currently try to find C in the _list_ of all super categories. But it is much faster to search it in a _frozen set_ of super categories.

So, I suggest to use a lazy attribute `_set_of_super_categories`, providing the frozen set. It will be used in `is_subcategory`. Of course, the _list_ of super categories should still be available, and its order should comply with Python's mro, according to the subject of this ticket.

Since #11115 is merged into sage-4.7.3.alpha1, I wonder whether it is still necessary to have the list of all super categories as a lazy attribute, or whether a cached method is fast enough. I'll need some tests.

However, I think it is a good idea to have a lazy attribute `_super_categories`. In that way, we have the speed even if the user does not use `@`cached_method when (s)he implements the method `super_categories()`.
 
"Needs work", until I have sorted it out.


---

Comment by SimonKing created at 2011-11-03 09:03:25

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2011-11-03 14:19:08

I found another detail that may fit here: `Category.is_subcategory` contains the lines

```
        assert(isinstance(c, Category))
        if isinstance(self, JoinCategory):
            for cat in self._super_categories:
                if cat.is_subcategory(c):
                    return True
            return False
```

First, I don't see why it should be needed to assert that c is a Category. It seems like a waste of time to me.

Secondly, the loop does nothing more than to test the cat is in the set of super categories of self. So, it can be safely erased. And it is a lot faster. For example:

With my current patch, we have

```
sage: P.<x,y> = QQ[]
sage: C = CommutativeRings()
sage: P.category()
Join of Category of unique factorization domains and Category of commutative algebras over Rational Field
sage: P in C
True
sage: %timeit P in C
625 loops, best of 3: 12.1 µs per loop
```


With my patch after deletion of the lines criticised above, we have

```
sage: P.<x,y> = QQ[]
sage: C = CommutativeRings()
sage: P.category()
Join of Category of unique factorization domains and Category of commutative algebras over Rational Field
sage: P in C
True
sage: %timeit P in C
625 loops, best of 3: 6.39 µs per loop
```


So, my next patch version will remove these lines, provided that doc tests pass.


---

Comment by jdemeyer created at 2011-11-03 16:14:43

Milestone sage-4.7.3 deleted


---

Comment by nthiery created at 2011-11-03 23:40:31

Replying to [comment:14 SimonKing]:
> So, I suggest to use a lazy attribute `_set_of_super_categories`, providing the frozen set. It will be used in `is_subcategory`. Of course, the _list_ of super categories should still be available, and its order should comply with Python's mro, according to the subject of this ticket.

+1 (obviously :-)), though I kind of like better _all_super_categories_as_set to insist on the fact that it is very close to all_super_categories.

> Since #11115 is merged into sage-4.7.3.alpha1, I wonder whether it is still necessary to have the list of all super categories as a lazy attribute, or whether a cached method is fast enough. I'll need some tests.

+1 on getting rid of this lazy attribute, unless there is a very clearly defined use case where speed is essential.

> However, I think it is a good idea to have a lazy attribute `_super_categories`. In that way, we have the speed even if the user does not use `@`cached_method when (s)he implements the method `super_categories()`.

+1

Cheers,
				Nicolas


---

Comment by nthiery created at 2011-11-03 23:55:33

Replying to [comment:15 SimonKing]:
> I found another detail that may fit here: `Category.is_subcategory` contains the lines
> {{{
>         assert(isinstance(c, Category))
>         if isinstance(self, JoinCategory):
>             for cat in self._super_categories:
>                 if cat.is_subcategory(c):
>                     return True
>             return False
> }}}
> First, I don't see why it should be needed to assert that c is a Category. It seems like a waste of time to me.

As for any reasonable programming language, Python allows to
completely disable assertion tests, to encourage the programmer to put
more safety guards and write programmatically his
preconditions/assertions/..., knowing that in production there won't
be any penalty.  Alas, this can't be done on the fly like in MuPAD for
switching between debugging and full speed computation modes inside a
given session (a feature I loved). Still this can be achieved in
principle on a new session by passing -O to the Python
interpreter. Maybe we should add this option to the Sage script
itself.

In that particular case, I guess I once met a bug where something was
passed to is_subcategory which was not a category, so I felt safer
with the assertion test.

> Secondly, the loop does nothing more than to test the cat is in the
> set of super categories of self. So, it can be safely erased. And it
> is a lot faster. ...
> So, my next patch version will remove these lines, provided that doc tests pass.

I don't remember anymore why I did a special case for join categories,
so +1.

Cheers,
			Nicolas


---

Comment by SimonKing created at 2011-11-04 11:02:59

Dear Nicolas,

Replying to [comment:18 nthiery]:
> In that particular case, I guess I once met a bug where something was
> passed to is_subcategory which was not a category, so I felt safer
> with the assertion test.

But I think, in this particular case, nothing nasty can happen.

Ultimately, it is tested whether the argument c belongs to the list of all super categories of `self`. Hence, unexpected things can only happen if c is not a category but is equal to a category, or if `self.super_categories()` contains something that is not a category.
 
> > So, my next patch version will remove these lines, provided that doc tests pass.
> 
> I don't remember anymore why I did a special case for join categories,
> so +1.

I have just attached a new version of my patch. I used several techniques to speed up `is_subcategory`.

In particular, I rely on the hypothesis that if a category C1 has a base (ring) and is super-category of C2, then C2 must have the same base (ring). Hence, if the base rings differ or C2 has no base ring then we can very quickly conclude that C1 is not a super-categoriy of C2.

This turns out to be very helpful in elliptic curve computations. Namely, it often suffices to study the base rings, so that it is not needed to construct the list of all super categories.

By consequence, I needed to introduce a `base()` method for various settings. For example, tensor products preserve the base. And for join categories, I argue: If `C = JoinCategory((C1,C2,...))` then `C.base()` should be the first answer that one obtains by walking through the list `C1.base(), C2.base(),...`.

I think this makes sense in the intended application: By #9138, polynomial rings over F belong to a join category of a base-free category (unique factorization domains) and a category with base F (F-algebras). 


The code of is_subcategory is now (with some comments added):

```python
# No cached method, currently
    def is_subcategory(self, c):
        if c is self:  # short path for a common case
            return True
        if isinstance(c, JoinCategory):
            return all(self.is_subcategory(x) for x in c._super_categories)
        try:
            # If the lazy attribute has already been computed, then we do not
            # need to bother about the categories having bases.
            # Here, the trick is that we look in self.__dict__, so that we do
            # not trigger computation of self._set_of_super_categories, if it has
            # not been done before.
            return c in self.__dict__['_set_of_super_categories']
        except KeyError:
            pass
        # In elliptic curves, one often has categories over different base rings.
        # Thus, as a short-path, we compare the base rings first, before we try
        # to compute the set of all super-categories.
        try:
            cbase = c.base()
        except (AttributeError, TypeError, NotImplementedError):
            cbase = None
        if cbase is not None:
            try:
                selfbase = self.base()
            except (AttributeError, TypeError, NotImplementedError):
                selfbase = None
            if selfbase is not cbase:
                return False
        # Now, the only remaining thing to do is to look at the super categories.
        # Looking it up in a (frozen) set is quickest:
        return c in self._set_of_super_categories
```


With the new patch, all long doctests pass - needs review!

I am now attending a lecture and will try to provide some timings afterwards.

Apply trac11943_mro_for_all_super_categories_lazy.patch


---

Comment by SimonKing created at 2011-11-04 11:02:59

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2011-11-04 13:21:59

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2011-11-04 13:21:59

Replying to [comment:19 SimonKing]:
> Replying to [comment:18 nthiery]:
> By consequence, I needed to introduce a `base()` method for various settings. For example, tensor products preserve the base. And for join categories, I argue: If `C = JoinCategory((C1,C2,...))` then `C.base()` should be the first answer that one obtains by walking through the list `C1.base(), C2.base(),...`.

I think that's a bad idea, after all. For example, one would have

```
sage: C = Category.join([Algebras(GF(5)),Modules(ZZ)])
sage: C.is_subcategory(Modules(ZZ))
False
```


But I have a suggestion:

`base()` provides a speed-up in an important application: Polynomial rings over F. In that situation, one has a join category that clearly should have a base, namely F. So, perhaps one should add an optional parameter `base=None` to the construction of a join category.

So, one could have something like

```
sage: P.<x,y> = QQ[]
sage: P.category()
Join over Rational Field of Category of unique factorization domains and Category of commutative algebras over Rational Field
sage: P.category().base()
Rational Field
```

and at the same time

```
sage: C = Category.join([Algebras(GF(5)),Modules(ZZ)])
sage: print C.base()
None
```


What do you think?


---

Comment by mderickx created at 2011-11-04 16:25:00

Where can I find the specific elliptic curve code you mention?


---

Comment by SimonKing created at 2011-11-04 16:50:28

Replying to [comment:21 mderickx]:
> Where can I find the specific elliptic curve code you mention?

I was referring to the things that were discussed on #11900. That ticket is about a serious speed regression in elliptic curves caused by #9138. And analysing it, using prun and so on, it turned out that really a lot of time has been spent on computing the list of all super categories. The problem is that caching the list of super categories does not really help, since one has many different categories (of algebras, for example) over different base fields.

But now that you mention it: It could be that the remark in the code above

```
        # In elliptic curves, one often has categories over different base rings.
        # Thus, as a short-path, we compare the base rings first, before we try
        # to compute the set of all super-categories.
```

is misleading. 

The code is supposed to recognise very quickly that a category with base is not contained in a category with a different base. I am afraid I can not show you the original example that made me suggest this bit of code. However, here are some examples showing that it helps.

With the base test (each example being in a new session):

```
sage: L = [GF(p)['x','y'] for p in prime_range(5000)]
sage: C = CommutativeRings()
# here the test is not used - this is to show that there is almost no regression
sage: %time [X in C for X in L] 
CPU times: user 0.29 s, sys: 0.00 s, total: 0.29 s
Wall time: 0.29 s
```


```
sage: L = [GF(p)['x','y'] for p in prime_range(5000)]
sage: D = Modules(ZZ)
sage: %time [X in D for X in L]
CPU times: user 0.06 s, sys: 0.00 s, total: 0.06 s
Wall time: 0.06 s
```


With the base test commented out:

```
sage: L = [GF(p)['x','y'] for p in prime_range(5000)]
sage: C = CommutativeRings()
sage: %time [X in C for X in L]
CPU times: user 0.26 s, sys: 0.00 s, total: 0.26 s
Wall time: 0.27 s
```


```
sage: L = [GF(p)['x','y'] for p in prime_range(5000)]
sage: D = Modules(ZZ)
sage: %time [X in D for X in L]
CPU times: user 0.28 s, sys: 0.00 s, total: 0.28 s
Wall time: 0.28 s
```


So, if base rings are involved then the test is much faster, and if no base rings are involved, the test is not much slower.


---

Comment by SimonKing created at 2011-11-04 18:14:30

Replying to [comment:22 SimonKing]:
> I am afraid I can not show you the original example that made me suggest this bit of code.

Now I remember the story.

By #9138, we have that the category of a polynomial ring is the join of a category of algebras with a base-free algebra, for example:

```
sage: P.<x,y> = ZZ[]
sage: P.category()
Join of Category of unique factorization domains and Category of commutative algebras over Integer Ring
```


Originally, that category has been computed via

```
sage: Category.join([UniqueFactorizationDomains(), CommutativeAlgebras(ZZ)])
Join of Category of unique factorization domains and Category of commutative algebras over Integer Ring
```


But that turned out to be a problem for elliptic curve computations:

 * In the benchmarks discussed on #11900, polynomial rings over many different finite fields are constructed.
 * For each of them, `Category.join(...)` was called.
 * Internally, `Category.join(...)` tests whether the categories to be joined are sub-categories of each other.
 * Hence, for each prime p, one had to compute `CommutativeAlgebras(GF(p)).all_super_categories()`, in order to test whether it is a sub-category of `UniqueFactorizationDomains()`.

In fact, that was the main reason for the speed regression from #9138.

For fixing it, I had (at least) the following two ideas:

 1. Do not call `Category.join(...)`, but construct `JoinCategory(...)` directly. Advantage: `JoinCategory.__init__` does not test for sub-categories. So, no time is wasted.
 1. When testing `UniqueFactorizationDomains().is_subcategory(CommutativeAlgebras(F))`, one does not need to waste time by computing `CommutativeAlgebras(F).all_super_categories()`. The fact that `UniqueFactorizationDomains()` has no base ring suffices  to recognise that it is not a sub-category.

In #11900, I went for the first approach. Here, I'd like to also add the second approach. It is not needed for fixing an existing regression, but I still think it is a good idea.

Here is an example for what I have explained:

We start with a list of categories of algebras over different finite fields. The aim is to compute the join with the category of unique factorization domains.

```
sage: L = [CommutativeAlgebras(GF(p)) for p in prime_range(5000)]
sage: C = UniqueFactorizationDomains()
```


With sage-4.6.2 (as an old reference):

```
sage: %time X = [Category.join([C,A]) for A in L]
CPU times: user 0.65 s, sys: 0.00 s, total: 0.65 s
Wall time: 0.65 s
```


With sage-4.7.2.alpha3 (hence, with #9138, but without #11900):

```
sage: L = [CommutativeAlgebras(GF(p)) for p in prime_range(5000)]
sage: C = UniqueFactorizationDomains()
sage: %time X = [Category.join([C,A]) for A in L]
CPU times: user 0.76 s, sys: 0.00 s, total: 0.77 s
Wall time: 0.77 s
```


With unpatched sage-4.7.3.alpha1 (which contains #11900):

```
sage: %time X = [Category.join([C,A]) for A in L]
CPU times: user 0.59 s, sys: 0.01 s, total: 0.60 s
Wall time: 0.61 s
```


With sage-4.7.3.alpha1 plus the patch from here (thus, using base rings):

```
sage: %time X = [Category.join([C,A]) for A in L]
CPU times: user 0.39 s, sys: 0.00 s, total: 0.39 s
Wall time: 0.39 s
```


Believe it or not, but that kind of differences had a noticeable effect, as I found out while working on #11900.

*__Conclusion__*

I still believe that one should exploit the base of a category for short-cuts in subcategory tests.


---

Comment by SimonKing created at 2011-11-04 18:51:51

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2011-11-04 18:51:51

I have updated my patch. As I have announced, I add the possibility to define a join category with a base. It is used for polynomial rings, who clearly should belong to a category with a base, but also to a join category.


---

Comment by mderickx created at 2011-11-04 19:56:39

I think base has nothing to do with join logically so I think it is a bad idea to only add it to joins of categories for this shortcut purpose. Also I don't like your 'base' concept since it is just a speedup thing right now and doesn't relate to something wich has a real mathematical meaning. 
The second thing is that I don't like the way how the code is organized right now in is_subclass. The reason for this is that this way of making shortcuts scales very bad and that other people thinking of other specific shortcuts to speed stuff up might make this a very cluttered method very soon. I'd say its cluttered already since this generic method already has special code for categories witch are a join of something and special code for the case that self and other have a base method. I think it is better to provide a truly generic implementation in combination with something like a __subclasshook__ as python has for Abstract Base Classes http://docs.python.org/library/abc.html#abc.ABCMeta.__subclasshook__ . In this way you we can have the JoinCategory specific code where it belongs and you can have your "base" optimisation in the place where it belongs, and other people can add their own shortcuts as they please.


---

Comment by mderickx created at 2011-11-04 20:02:04

Changing status from needs_review to needs_work.


---

Comment by mderickx created at 2011-11-04 20:02:04

something went wrong with the previous link cause of the wiki formatting it should be [this link](http://docs.python.org/library/abc.html#abc.ABCMeta.__subclasshook__)


---

Comment by SimonKing created at 2011-11-04 20:43:01

Replying to [comment:25 mderickx]:
> I think base has nothing to do with join logically 

I think it does, to some extent. If C is a category with a base B, then all its objects are supposed to have this base B as well. If you form a join J of C with another category, then all objects of J are also objects of C and thus have the base B.

It only starts to lack logic if you join categories with distinct bases.

But if you join a list of categories such that at least one of them has base B and all other categories on the list either have no base at all or have the base B as well, then I think it is alright to say that the join has base B.

> The second thing is that I don't like the way how the code is organized right now in is_subclass. ... I think it is better to provide a truly generic implementation in combination with something like a `__subclasshook__`

One could argue that `super_categories()` alreay plays the role of `__subclasshook__`: It determines how different categories are contained in one another, and is used in a generic method `Category.is_subcategory`.

But I agree that it is conceivable that `JoinCategory` or `Category_over_base` could benefit from using a specialised method for detecting subcategories.


---

Comment by mderickx created at 2011-11-04 21:03:11

No, super_categories() plays the exact opposite role of !__subclashook!__ . The subclass hook allows you to define what you consider as subclass of self and not what you consider a super class.  What you claim is sort of saying that class inheritance plays the same role as __subclasshook__!


---

Comment by mderickx created at 2011-11-04 21:49:38

Maybe my real problem is with the way how you implement the base logic. I think that asuming that if two categories have a different base then they cannot be sub categories of each other is way to strict, this is not an interface wich I like to program to. And that by your current implementation you add way to much specific code to the general parts of the category framework that will not nicely generalize to more situations and don't fit nicely with the mathematical concept of base.


---

Comment by SimonKing created at 2011-11-05 08:45:00

Replying to [comment:28 mderickx]:
> No, super_categories() plays the exact opposite role of !__subclashook!__ . The subclass hook allows you to define what you consider as subclass of self and not what you consider a super class.

Yes, you are right! Even though a while ago I did some experiments with the ABC module, I forgot that one is registering sub-classes, not super-classes. Sorry.

Let me see. When we do `A.is_subcategory(B)` then _with or without my patch_ we make a special case when B is a join category. With my patch, we also make a special case when B has a base - and actually what we _really_ want is a special case for `Category_over_base` (recall the original use case, where A is the category of unique factorization domains and B is a category of algebras). 

So, it seems like a good idea that both `JoinCategory` and `Category_over_base` and perhaps also `TensorProductsCategory` get a method `subcategory_hook`, and that `Category.is_subcategory` then looks as follows:

```python
def is_subcategory(self, C):
    try:
        return C.subcategory_hook(self)
    except AttributeError:
        return C in self._set_of_super_categories
```


Of course, one should add a comment about the new "magical" method into the docs.

Is that what you suggested?


---

Comment by mderickx created at 2011-11-05 09:47:47

That is indeed my suggestion. But my specific implementation would be:


```
 #!python
 def is_subcategory(self, C): 
    hook_result = C.subcategory_hook(self)
    if hook_result is not NotImplemented:
        return hook_result
    return C in self._set_of_super_categories
```


So that it is more similar to the !__subclasshook!__ that python provides and your shortcut can just return NotImplemented to signify that the shortcut didn't work (just like you can do with the subclasshook). And make a default implementation in Category that just returns NotImplemented. The new magical method should indeed be documented.


---

Comment by mderickx created at 2011-11-05 09:49:28

and maybe it should be  _subcategory_hook_ since I consider it more of a developer thing then an enduser.


---

Comment by SimonKing created at 2011-11-05 12:55:54

Now I wonder how we should proceed. Namely, I introduced the special case for categories with base not here, but in #11900.

I would argue as follows: #11900 is explicitly about speed. It provides speed. Hence, let it stay as it is.

The ticket here is more about structure. Hence, part of it should be to fix _here_ my messy code from #11900.


---

Comment by SimonKing created at 2011-11-05 13:51:59

I am now rewriting it, and first tests seem to indicate that a cleaner implementation of is_subcategory is _faster_ than the current mess. So, thank you for your suggestion, Maarten!


---

Comment by mderickx created at 2011-11-05 14:56:32

No problem :). I think you deserve way more credit, considering the huge amount of work you have done to make the category framework better lately.


---

Comment by SimonKing created at 2011-11-06 12:16:33

I will add documentation to `sage.categories.primer`. The section in the primer on "how to implement a new category" is rather short anyway. It even does not explain that one should provide a method `super_categories` (it only tells that the order of super-categories should follow certain rules), and it does not mention `ParentMethods` and `ElementMethods` at all. I'll add that, plus some words on the new `_subcategory_hook_`.


---

Comment by SimonKing created at 2011-11-07 09:09:33

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2011-11-07 09:09:33

I have added Maarten's idea of a _subcategory_hook_ and documented it. The subcategory hook is used for `Category_over_base` (hence, it is not needed to check for the existence of a base() attribute).

Moreover, in order to keep the generic implementation of `is_subcategory` clean, I provided `JoinCategory` with a specialised `is_subcategory`.

The documentation looks fine to me, and all tests pass. Needs review!


---

Comment by SimonKing created at 2011-11-07 09:10:58

I forgot to inform the patch bot:

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by SimonKing created at 2011-11-07 13:33:55

I updated the patch. Only change: I added some doc tests that I had previously forgotten to include.

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by SimonKing created at 2011-11-07 21:43:02

I updated the patch again. Reason: The previous one was relative to sage-4.7.3.alpha1, which includes #11068. But sage-4.8.alpha0 does not include #11068. I modified one hunk of the patch such that the order in which this patch and the patches from #11068 are applied will hopefully not matter.

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by SimonKing created at 2011-11-08 09:58:31

I noticed that once again I was commenting out old code, rather than properly removing it. Sorry. I will remove the commented-out code from `is_subcategory` and update my patch soon.


---

Comment by SimonKing created at 2011-11-08 09:58:31

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2011-11-08 10:05:08

Dead code is removed, ticket description updated.

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by SimonKing created at 2011-11-08 10:05:08

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2011-11-08 14:59:58

I found that there is a trivial conflict with #11068. Therefore, I updated the patches from here and from there, so that it wouldn't matter in which order both tickets are merged.

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by nthiery created at 2011-11-16 08:45:17

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2011-11-16 12:40:41

I have replaced the `base()` method of Cartesian products by a `base_ring()` method. I think it holds true that if some category has a base ring then all cartesian products of its objects have the same base ring. This may be not so sure when doing the same with a general bases.

I did not run full doctests yet, but the original example that made me introduce the `base()` method in #11900 is still working:

```
sage: P.<x,y,z> = QQ[]
sage: P in Algebras(QQ)
True
sage: P.category()
Join of Category of unique factorization domains and Category of commutative algebras over Rational Field
```


Benchmark, for avoiding to return to the old regression:

```
sage: %time L = EllipticCurve('960d1').prove_BSD()
CPU times: user 3.78 s, sys: 0.08 s, total: 3.86 s
Wall time: 4.10 s
```

#11935 will make this even faster.


---

Comment by SimonKing created at 2011-11-16 12:40:41

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2011-11-16 12:41:56

I forgot the patch bot:

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by SimonKing created at 2011-11-16 14:14:21

I find one very strange doctest error in sage/interfaces/r.py, and I have so far no clue what goes wrong.


---

Comment by SimonKing created at 2011-11-16 14:14:21

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2011-11-16 14:20:30

Replying to [comment:47 SimonKing]:
> I find one very strange doctest error in sage/interfaces/r.py, and I have so far no clue what goes wrong.

And now I cannot reproduce the error. So, even more mysterious. I put it back to "needs review", as repeting the failing test did not reproduce the error.


---

Comment by SimonKing created at 2011-11-16 14:20:30

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2011-11-23 10:23:48

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2011-11-23 10:40:40

For the record: With the current version of the patch, we have numerous mismatches, namely in

```
sage/categories/bimodules.py
sage/categories/category.py
sage/categories/category_types.py
sage/categories/euclidean_domains.py
sage/categories/fields.py
sage/categories/homset.py
sage/categories/modules.py
sage/categories/ring_ideals.py
sage/categories/semirings.py
sage/categories/vector_spaces.py
```



---

Comment by SimonKing created at 2011-11-23 11:00:42

I have updated the patch, so that (1) it applies, and (2) Sage starts. But I'd certainly like to improve the _subcategory_hook_ by using subclass check of parent classes. This would work generally, not only for Category_singleton. In #11935, it would then be needed to refine the _subcategory_hook_ for subclasses of `CategoryWithParameter`, because of sharing parent classes.


---

Comment by SimonKing created at 2011-11-23 12:35:27

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2011-11-23 12:35:27

The patch is updated, and with it all tests should pass.

The patch uses the `_subcategory_hook_` mechanism, which will make it easier in #11935 to cope with the case of shared parent classes. However, for now, the default `_subcategory_hook_`, which tests whether one parent class is subclass of the other, is actually sufficient to determine subcategories, with the only exception of join categories.

Needs review, I'd say!


---

Comment by SimonKing created at 2011-11-23 15:06:40

The patchbot got it wrong:

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by SimonKing created at 2011-12-05 17:45:29

Mental note: The `base()` method for `CartesianProductCategory` that has been introduced in #11900 should be removed here, if possible. Could be that it is already done in the patch (no time to check it now, though).


---

Comment by jdemeyer created at 2011-12-09 14:55:20

How close is this ticket to being finished?  Since #9138, #11900 and #11943 are related, I am thinking about merging them all together.  Do you think this is a good idea?


---

Comment by SimonKing created at 2011-12-09 15:33:49

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2011-12-09 15:33:49

Replying to [comment:55 jdemeyer]:
> How close is this ticket to being finished?  Since #9138, #11900 and #11943 are related, I am thinking about merging them all together.  Do you think this is a good idea?

_If_ this ticket is close to being finished, then merging the three together would be a good idea. I am not sure how much work needs to be done, in particular since Nicolas seems to have problems building sage-4.8.alpha3.

Anyway, it does need work since a couple of hunks do not apply when starting with sage-4.8.alpha3 and applying the latest patch version from #11900 (namely the one that does not use Category_singleton for Finite*, which Nicolas seems to prefer).


---

Comment by SimonKing created at 2011-12-09 15:43:54

Replying to [comment:55 jdemeyer]:
> How close is this ticket to being finished?  Since #9138, #11900 and #11943 are related, I am thinking about merging them all together.  Do you think this is a good idea?

Yes, I think it is a good idea. But perhaps one should also ask the opposite: Do you think it is a good idea to _not_ merge #9138 and #11900, if #11943 is not ready? Here, my answer would be "no".

Personally, I want to have #9138 and thus #11900. I could live without #11943, even though it cleans up some stuff.


---

Comment by SimonKing created at 2011-12-09 16:32:08

I have updated the patch.

Concerning the `base()` method for Cartesian products: If I remember correctly, Nicolas and I agreed that it is ok to have a `base_ring()` method for Cartesian products (meaning: If a category is defined over a base ring then the category of Cartesian products of objects in that category is defined over the same base ring). Thus, the patch renames the method.

The patch should work on top of the positively reviewed patch from #11900.

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by SimonKing created at 2011-12-09 16:32:08

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2011-12-09 16:33:50

PS: `./sage -tp 5 devel/sage/sage` and `./sage -tp 5 devel/sage/doc` pass for me.


---

Comment by SimonKing created at 2011-12-13 09:17:45

I'm awfully sorry: I just noticed that I forgot to include the name change "`base() -> base_ring()` in my patch. It has now been updated.

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by mderickx created at 2011-12-17 15:25:30

I'm now starting to review it. At least it passes al tests when applied to sage 4.8.alpha4 + dependencies. I'm reading through your code now.


---

Comment by nthiery created at 2012-03-09 15:23:52

Hi Simon,

I am including your patch in the queue to handle conflicts with various other patches in finalization (and reviewing it by the way). The systematic removal of 

Do you insist on systematically removing "cached_method" to all super_categories methods? I am not so sure about it. And practically speaking it does create quite a few conflicts; I am fine resolving them, but only if it's for the good cause. What do you think?

Cheers,
                         Nicolas


---

Comment by SimonKing created at 2012-03-09 16:00:25

> Do you insist on systematically removing "cached_method" to all super_categories methods?

Not necessarily.

The main reason for having super_categories cached was speed: One wouldn't like to create the list of super categories repeatedly. However, with my patch, it is cached in a different way, namely as an attribute, and that's even faster than a cached method.

In fact, i is kind of courtesy: Before, if the user forgot to use `@`cached_method then it became slower. Now, it doesn't matter whether or not the user knows of `@`cached_method.

From that point of view, it doesn't matter whether the cached_method decorator is systematically removed or not. With perhaps one exception: Calling a cached method hundred times takes shorter than calling a non-cached method hundred times. But calling the cached method just once takes longer than calling a non-cached method just once.

Hence, I could imagine that in the following setting, using my patch without cached_method would be noticeable faster than using my patch with cached_method (but I hope that using cached_method with my patch will still be slower than using cached_method without my patch...):

 - Create many different categories
 - For each pair C1,C2, determine whether one is subcategory of the other

I intend to try and provide an example. But I am having trouble with my mercurial queue.


---

Comment by SimonKing created at 2012-03-09 16:17:14

To my great surprise, using cached method seems to be _faster_, even with my patch:


```
sage: class MyCat1(Category):
....:     def __init__(self, R):
....:         self.R = R
....:         Category.__init__(self)
....:     def super_categories(self):
....:         return [Algebras(self.R)]
....:     
sage: class MyCat2(Category):
....:     def __init__(self, R):
....:         self.R = R
....:     `@`cached_method
....:     def super_categories(self):
....:         return [Algebras(self.R)]
....:     
sage: L1 = [MyCat1(GF(p)) for p in prime_range(10000)]
sage: L2 = [MyCat2(GF(p)) for p in prime_range(10000)]
sage: def test_cats(L):
....:     for A in L:
....:         for B in L:
....:             A.is_subcategory(B)
....:             
sage: %time test_cats(L1)
CPU times: user 3.53 s, sys: 0.04 s, total: 3.56 s
Wall time: 3.58 s
sage: %time test_cats(L2)
CPU times: user 2.35 s, sys: 0.01 s, total: 2.36 s
Wall time: 2.36 s
```


Of course, as soon as the super categories are obtained and put in the cache, there is no difference anymore:

```
sage: %time test_cats(L1)
CPU times: user 2.17 s, sys: 0.00 s, total: 2.17 s
Wall time: 2.18 s
sage: %time test_cats(L2)
CPU times: user 2.15 s, sys: 0.01 s, total: 2.16 s
Wall time: 2.16 s
```


So, after all: Yes, I do not insist on removing all cached_method decorators on the super_categories methods, but I still think removing them would be better aesthetically.


---

Comment by SimonKing created at 2012-03-09 16:23:50

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2012-03-09 16:23:50

But there is something else: #12357 has a positive review, but it brings a conflict. So, I need to rebase my patch.


---

Comment by SimonKing created at 2012-03-09 16:24:44

Or perhaps better I shouldn't: #12357 is pending. So, let's do it the other way around...


---

Comment by SimonKing created at 2012-03-09 16:24:44

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2012-03-09 16:25:27

Oops, the "dependencies" field should only contain #11900...


---

Comment by nthiery created at 2012-03-09 16:43:59

Replying to [comment:67 SimonKing]:
> Oops, the "dependencies" field should only contain #11900...

For the record: I have already slightly rebased your patch on top of #7980 (multiple realizations) which conflicted and is almost positive review.

Thanks for your comments. I'll see if I keep the cached_methods in there or not depending on how the conflict resolution goes.

Ah one thing: for all the attributes like _all_super_categories, shouldn't we use tuples rather than lists for safety?

Cheers,
                               Nicolas


---

Comment by SimonKing created at 2012-03-09 17:08:31

Replying to [comment:68 nthiery]:
> Ah one thing: for all the attributes like _all_super_categories, shouldn't we use tuples rather than lists for safety?

Well, they used to be lists (and were cached).

If I remember correctly, I tried at some point whether a tuple would be better, but it was too slow. I think the reason was that during the creation of the list of all super categories, one would naturally operate with lists, and the transformation of the final list into a tuple was too time consuming in some elliptic curve computations.

If you like, I could try again, but probably only in a couple of days.


---

Comment by nthiery created at 2012-03-09 17:58:30

Replying to [comment:69 SimonKing]:
> If I remember correctly, I tried at some point whether a tuple would be better, but it was too slow. I think the reason was that during the creation of the list of all super categories, one would naturally operate with lists, and the transformation of the final list into a tuple was too time consuming in some elliptic curve computations.
> 
> If you like, I could try again, but probably only in a couple of days.

Ok; let's postpone this to a later patch. I'll just mention that the
lazy attributes will probably become tuples at some point.

On another note: why not systematically build _set_of_super_categories
as frozenset(_all_super_categories_proper) and
_all_super_categories_proper as _all_super_categories[1:]? Otherwise
it seems likely that C3 could often be called three times for a single
given category.

Besides C3_algorithm_set and the proper option would not be needed in
that case, and the overall logic be simplified a bit.

Cheers,
                Nicolas


---

Comment by SimonKing created at 2012-03-10 06:26:22

Replying to [comment:68 nthiery]:
> For the record: I have already slightly rebased your patch on top of #7980 

Where are the patches from #7980? Where is my rebased patch from here?


---

Comment by SimonKing created at 2012-03-10 06:38:01

O dear. Last night, I installed sage-5.0.beta7. The patch from here won't apply anymore, because the file age/categories/partially_ordered_sets.py has not been found.

Can you tell me the ticket which has removed that file?


---

Comment by SimonKing created at 2012-03-10 06:47:15

Apparently it is #10998. Needs to be rebased, then.

Nicolas, you said that you have rebased my patch. Is it relative to #10998? Can you post it here? And please, do post #7980 as well.


---

Comment by SimonKing created at 2012-03-10 06:47:15

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2012-03-10 06:56:07

OK, I have updated my patch, simply by removing one of the hooks that removes a cached method.

My patch should now apply, regardless whether #10998 is applied or not. So, needs review again.

But please, do post the stuff from #7980, so that I can rebase my patch relative to it.

Apply trac11943_mro_for_all_super_categories_lazy_hook.patch


---

Comment by SimonKing created at 2012-03-10 06:56:07

Changing status from needs_work to needs_review.


---

Comment by nthiery created at 2012-03-10 08:15:11

Replying to [comment:74 SimonKing]:
> OK, I have updated my patch, simply by removing one of the hooks that removes a cached method.
> 
> My patch should now apply, regardless whether #10998 is applied or not. So, needs review again.
> 
> But please, do post the stuff from #7980, so that I can rebase my patch relative to it.
> 
> Apply trac11943_mro_for_all_super_categories_lazy_hook.patch

Don't waste your time: I told you I am handling it (on the Sage-Combinat queue), as well as #11935. I haven't pushed yet, because there are quite a few conflicts to resolve with the other category patches there. I'll post it here when I am done (probably monday).


---

Comment by nthiery created at 2012-03-10 08:45:55

Changing status from needs_review to needs_work.


---

Comment by nthiery created at 2012-03-10 08:45:55

Ok, I pushed on the Sage-Combinat queue; I haven't finished the merging so the patches are still disabled; I still need to decide on keeping or not a couple cashed methods to best resolve the conflicts.

Please let me know about my question above about building _set_of_super_categories.


---

Comment by SimonKing created at 2012-03-10 08:52:51

Replying to [comment:76 nthiery]:
> Please let me know about my question above about building _set_of_super_categories.

That will probably take a while. I am still in the process of getting sage-5.0.beta7 to work with all my patches applied (so that I can work on my ext algebra project), have to finish writing some paper, and have some other urgent things to do, that will essentially occupy this weekend.


---

Comment by nthiery created at 2012-03-10 09:55:40

> That will probably take a while. I am still in the process of getting sage-5.0.beta7 to work with all my patches applied (so that I can work on my ext algebra project), have to finish writing some paper, and have some other urgent things to do, that will essentially occupy this weekend.

I just meant: do you agree if I do this change in my reviewer patch?


---

Comment by nthiery created at 2012-04-02 20:05:52

For the record: the Sage-Combinat queue has been rebased on top of this patch. To this end,
I stripped away from this patch the "cached_method" changes concerning categories that won't have a super_categories method after #10963 anyway. I am writing a small review patch with some improvements (including the "_set_of_super_categories" thingie discussed above). At this point, all tests pass on 5.0.beta10.

I hope to finish the review shortly.

Cheers,
                     Nicolas


---

Comment by nthiery created at 2012-04-06 16:06:49

Hi Simon,

I have finished my review. I'll push shortly my reviewer's patch on the Sage-Combinat queue

http://combinat.sagemath.org/patches/file/tip/trac11943_mro_for_all_super_categories_lazy_hook-review-nt.patch

Overall, I am happy with it, and it's almost good to go if you are happy with my changes. Thanks for your hard work!

Just two little details:

* in covariant_functorial_construction.py, the method is_subcategory is not documented, and I am not sure why it is required. Please remove, or add documentation and tests with a comment on the rationale for this method

* in the C3 algorithm: Cython knows that ``tails`` is a list, so one would assume that tails[i] is optimized. Is it really faster to use PyList_GET_ITEM(tails,i) rather than just tails[i]? Otherwise, please use the later which is more readable. Same thing for the other PyList_*.

Once those are done, and it is confirmed that all tests pass (I am running them), you can set a positive review on my behalf (I'll be away for the week-end).

Happy easter!
                                    Nicolas


---

Comment by nthiery created at 2012-04-06 16:09:13

Hold on a minute; I need to rebase a bit of stuff before pushing, and before that pickup the girls at school ...


---

Comment by nthiery created at 2012-04-06 16:54:33

Pushed. I am running the tests now. Note: I also had to make some modifications to the original patch; so please start from http://combinat.sagemath.org/patches/file/tip/trac11943_mro_for_all_super_categories_lazy_hook.patch.

As far as I remember, all I did to this patch was, as discussed, to remove the hunks that were removing "cached_method"'s on those super_categories methods that are going to disapear with #10963 anyway. That to make the rebase of #10963 easier.

I'll upload both patches here once the tests are positive.


---

Attachment

Order the super categories of a category according to Python's mro. Internally replace (all_)super_categories by lazy attributes, to prevent a regression. Use _subcategory_hook_


---

Comment by nthiery created at 2012-04-06 17:12:57

Changing status from needs_work to needs_review.


---

Comment by nthiery created at 2012-04-06 17:13:52

All tests pass; latest versions of the patches uploaded. Please fold the two patches once you have reviewed my changes.


---

Comment by SimonKing created at 2012-04-09 23:34:52

Sorry, I can not do (reviewing or other) work, being in the middle of holidays. I'll return next week.


---

Comment by nthiery created at 2012-04-10 08:51:20

Replying to [comment:85 SimonKing]:
> Sorry, I can not do (reviewing or other) work, being in the middle of holidays. I'll return next week.

Sure: enjoy your vacations!

Just in case: are you ok with, e.g., Florent finishing the review, or do you prefer double checking things yourself? (just to give a chance to the patch to go into 5.0).

Cheers,
                                Nicolas


---

Comment by nthiery created at 2012-04-10 10:08:05

On 5.0.beta13, I was getting a random doctest failure due to the order
of the classes changing in Python's error message about MRO's:


```
File "/home/nthiery/sage-5.0.beta13/devel/sage-combinat/sage/misc/c3.pyx", line 81:
    sage: F.parent_class
Expected:
    Traceback (most recent call last):
    ...
    TypeError: Cannot create a consistent method resolution
    order (MRO) for bases X.parent_class, Y.parent_class
Got:
    Traceback (most recent call last):
    ...      File "/home/nthiery/sage-5.0.beta13/local/bin/ncadoctest.py", line 1231, in run_one_test
    TypeError: Cannot create a consistent method resolution
    order (MRO) for bases Y.parent_class, X.parent_class
```


The updated patch uses "..." instead of X and Y.


---

Comment by SimonKing created at 2012-04-10 17:19:31

Replying to [comment:86 nthiery]:
> Replying to [comment:85 SimonKing]:
> Sure: enjoy your vacations!

Thank you! By the way, it is in France.
 
> Just in case: are you ok with, e.g., Florent finishing the review

Of course! Just go ahead.


---

Comment by SimonKing created at 2012-04-14 19:30:09

The reviewer patch mostly looks fine to me (running tests now). But I think one should use the occasion and apply the trac directive in the Sphynx markup. Hence,

```
... in :trac:`11943`
```

rather than

```
... in trac ticket #11943
```


When I wrote the original patch, I have not been aware of the directive.


---

Comment by nthiery created at 2012-04-16 14:16:09

Replying to [comment:89 SimonKing]:
> The reviewer patch mostly looks fine to me (running tests now). But I think one should use the occasion and apply the trac directive in the Sphynx markup. Hence,
> {{{
> ... in :trac:`11943`
> }}}
> rather than
> {{{
> ... in trac ticket #11943
> }}}
> 
> When I wrote the original patch, I have not been aware of the directive.

Perfect; I was about to upload an updated patch doing just that after a suggestion by Florent on Friday :-) Give me two minutes.


---

Attachment

There it is. Here is the diff between the two patches (oops, sorry, I did the diff the wrong way):

```
 diff --git a/sage/categories/algebras.py b/sage/categories/algebras.py
 --- a/sage/categories/algebras.py
`@``@` -155,7 +155,7 `@``@`
 +        All the super categories of this category, including this category.
  
 -        TEST::
-+        Since :trac:`11943`, the order of super categories is
++        Since trac ticket #11943, the order of super categories is
 +        determined by Python's method resolution order C3 algorithm.
  
 -            sage: Rngs()._all_super_categories_raw()
`@``@` -193,7 +193,7 `@``@`
 +        r"""
 +        All the proper super categories of this category.
 +
-+        Since :trac:`11943`, the order of super categories is
++        Since trac ticket #11943, the order of super categories is
 +        determined by Python's method resolution order C3 algorithm.
 +
 +        .. seealso:: :meth:`all_super_categories`
`@``@` -266,7 +266,7 `@``@`
 +         - ``proper`` -- a boolean (default: ``False``); whether to exclude this category.
  
 -        FIXME:
-+        Since :trac:`11943`, the order of super categories is
++        Since trac ticket #11943, the order of super categories is
 +        determined by Python's method resolution order C3 algorithm.
  
 -        - make sure that this is compatible with the python algorithm
`@``@` -422,7 +422,7 `@``@`
 -        By trac ticket #11943, the list of categories returned by :meth:`all_super_categories`
 -        is supposed to correspond to the method resolution order of the parent or element
 -        classes. This method verifies it.
-+            By :trac:`11943`, the list of categories returned by
++            By trac ticket #11943, the list of categories returned by
 +            :meth:`all_super_categories` is supposed to match with the
 +            method resolution order of the parent and element
 +            classes. This method checks this.

```


If you are happy with the changes, please fold the two patches, and double check the patch header.

Cheers,
                      Nicolas


---

Comment by SimonKing created at 2012-04-16 14:27:09

Replaces the two other patches: Order the super categories of a category according to Python's mro. Internally replace (all_)super_categories by lazy attributes, to prevent a regression. Use _subcategory_hook_


---

Attachment

Replying to [comment:91 nthiery]:
> If you are happy with the changes, please fold the two patches, and double check the patch header.

Done! I am happy with your reviewer patch (which is folded into the combined patch), and if you think it is appropriate, please give it a positive review.

Apply trac11943_mro_for_all_super_categories_combined.patch


---

Comment by nthiery created at 2012-04-16 17:29:38

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2012-05-06 12:15:10

Resolution: fixed
