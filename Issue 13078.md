# Issue 13078: Additional poset examples

Issue created by migration from Trac.

Original creator: csar

Original creation time: 2012-07-13 19:32:45

Assignee: sage-combinat

CC:  kdilks jmantysalo

Keywords: sd40

Various combinatorial objects already have order relations available, but the posets themselves are not available. (An example of such a poset that is available is SymmetricGroupWeakOrderPoset.)

Posets to add:
 * set partitions ordered by refinement
 * Young's lattice up to rank n
 * Principal order ideal in Young's lattice
 * dominance order on partitions
 * poset of cells in a Young diagram
 * absolute order on the symmetric group


---

Comment by csar created at 2013-07-06 01:39:23

Changing status from new to needs_review.


---

Comment by csar created at 2013-07-06 15:41:18

#14816 implements absolute order for Weyl groups. Maybe it would make more sense for the example to use that implementation, rather than using one specifically for the symmetric group. (I also generated the transpositions in what seems like a bizarre way.)


---

Comment by ncohen created at 2013-07-07 14:12:06

Hellooooooooooooo !!

Two comments : 
* You can use in the code of `PartitionsDominanceOrder` the same trick that you used in `SetPartitions` : instead of defining `dominance_leq` you can directly return

```
Poset([Partitions(n),Partition.dominates])
```


* Could you add an INPUT section to the docstrings of all functions ? It is in particular impossible right now to guess what the `"labels"` argument of `SymmetricGroupAbsoluteOrderPoset` can accept as an input, and what the result would be. I do not understand what this `n<10` constraint does either.

And a question too... Do you have any idea what "mro" does inside of posets ? `O_o`


```
sage: posets.mro??
Error getting source: <built-in method mro of sage.misc.classcall_metaclass.ClasscallMetaclass object at 0x4533aa0> is not a module, class, method, function, traceback, frame, or code object
Type:       builtin_function_or_method
String Form:<built-in method mro of sage.misc.classcall_metaclass.ClasscallMetaclass object at 0x4533aa0>
Docstring:  mro() -> list return a type's method resolution order
sage: 
```


I do not see where it is imported there, but I don't get why it should `O_o`

Nathann


---

Comment by csar created at 2013-07-24 03:07:45

Replying to [comment:4 ncohen]:
> Hellooooooooooooo !!
> 
> Two comments : 
> * You can use in the code of `PartitionsDominanceOrder` the same trick that you used in `SetPartitions` : instead of defining `dominance_leq` you can directly return
> {{{
> Poset([Partitions(n),Partition.dominates])
> }}}
> 

Oops. I've changed that.

> * Could you add an INPUT section to the docstrings of all functions ? It is in particular impossible right now to guess what the `"labels"` argument of `SymmetricGroupAbsoluteOrderPoset` can accept as an input, and what the result would be. I do not understand what this `n<10` constraint does either.
> 
I've added INPUT sections to the docstrings (for the functions I added--did you mean all the example posets functions?). It occurs to me that maybe I should change the arguments called `lam` to `mu` or something. I'm assuming Python would be unhappy with an argument called `lambda`, but perhaps `lam` doesn't convey much meaning to people who aren't me. Thoughts?

I put the `n<10` constraint in `SymmetricGroupAbsoluteOrderPoset` because `SymmetricGroupWeakOrderPoset` has one. I don't know of a, uh, structural reason for this constraint, in the sense that some code somewhere needs it. I suspect actually computing these posets for `n=10` might be overly taxing time or memory-wise.

> And a question too... Do you have any idea what "mro" does inside of posets ? `O_o`
> 
> {{{
> sage: posets.mro??
> Error getting source: <built-in method mro of sage.misc.classcall_metaclass.ClasscallMetaclass object at 0x4533aa0> is not a module, class, method, function, traceback, frame, or code object
> Type:       builtin_function_or_method
> String Form:<built-in method mro of sage.misc.classcall_metaclass.ClasscallMetaclass object at 0x4533aa0>
> Docstring:  mro() -> list return a type's method resolution order
> sage: 
> }}}
> 
> I do not see where it is imported there, but I don't get why it should `O_o`
> 
I'm not totally sure what you mean, so I might be about to say things you know. My rough understanding is that `mro` is a method that all classes have (so it wouldn't get imported) that returns a list telling you what precedence the classes it inherited form have when looking for functions (i.e. if it inherited `foo` from two different classes, which `foo` wins?). But `Posets` doesn't actually inherit from any other classes (well, besides `object`), so `Posets.mro()` is returning `[sage.combinat.posets.poset_examples.Posets, object]`, which maybe isn't that interesting.


---

Comment by tscrim created at 2013-07-24 06:45:27

Hey,

So `cls.mro()` returns the method resolution order (MRO for short), which is the sequences of superclasses of the type (class) `cls` in some linear order that used to in order to determine which method to call. The MRO is used to solve what is known as the diamond problem with multiple inheritance. All things in python will have one since all objects have one and everything is an object. Also `cls.mro()` is equivalent (up to tuple -> list) to calling `cls.__mro__`. In short, it does exactly as it says it does because `posets` is a class.

More importantly, for the patch could you do the following:

- Implement Young's lattice using
  {{{
  Poset((partitions, Partition.contains))
  }}}
  as with the other similar prebuilt functions.
- It's not good practice to call the variable you iterate over the same as the defining variable for the iteration:
  {{{
  partitions = flatten([list(Partitions(n)) for n in range(n+1)])
  }}}
  because `n` gets overwritten (of course that's not a problem here, but in general this can be a subtle bug).
- The `cell_leq` method is not needed since the default comparison between lists/tuples in python is lex which matches your definition (and your current implementation does not match your def'n in that the def'n has "or" whereas the test has "and").
- Could you split line 570 a few times? It's quite long.
- You'll need to put your real name as the author.

Once these are done, I'd be happy setting this to positive review.

Thanks,

Travis


---

Comment by ncohen created at 2013-07-24 07:50:25

Hellooooooo !!!

> So `cls.mro()` returns the method resolution order (MRO for short), which is the sequences of superclasses of the type (class) `cls` in some linear order that used to in order to determine which method to call. The MRO is used to solve what is known as the diamond problem with multiple inheritance. All things in python will have one since all objects have one and everything is an object. Also `cls.mro()` is equivalent (up to tuple -> list) to calling `cls.__mro__`. In short, it does exactly as it says it does because `posets` is a class.

Hmmmmm... Well, what I wondered about is what was such a method (with a shortened name, while we would usually write "method_resolution_order") was doing in Poset. I mean, not in Poset, but as it really is related to Sage's implementation of whatever it implements more than to what the Poset means as a mathematical object, I thought that we would have stuck with `_mro_` instead. Hidden function, as user don't care much `O_o`

Nathann


---

Comment by tscrim created at 2013-07-24 08:04:35

Replying to [comment:7 ncohen]:
> Hmmmmm... Well, what I wondered about is what was such a method (with a shortened name, while we would usually write "method_resolution_order") was doing in Poset. I mean, not in Poset, but as it really is related to Sage's implementation of whatever it implements more than to what the Poset means as a mathematical object, I thought that we would have stuck with `_mro_` instead. Hidden function, as user don't care much `O_o`

But you're neglecting the fact that this is a class, which 98% of the time in python you are not manipulating other than `isinstance(obj, cls)`. So having this class `posets` is not the truly pythonic way, instead it should be at the module level (because this is not Java where everything has to be [in] a class). And if you are going to insist on changing that, it should be done on a separate ticket.


---

Comment by ncohen created at 2013-07-24 08:08:02

Yooooooooooo !

> But you're neglecting the fact that this is a class, which 98% of the time in python you are not manipulating other than `isinstance(obj, cls)`. So having this class `posets` is not the truly pythonic way, instead it should be at the module level (because this is not Java where everything has to be [in] a class). And if you are going to insist on changing that, it should be done on a separate ticket.

I'm sorry but I don't get a word of what you say `O_o`

My question is pretty simple : this mro thing is not really a function that will be used by the typical user of the poset class, so why don't we just hide it ? It's internal stuff, so why don't we keep it internal ?

And I don't insist on anything. I just wondered about it, as it did not seem right. What do you think ?

Nathann


---

Comment by tscrim created at 2013-07-24 08:21:44

Simplest version, it's correct and expected. Something with the structure has to change in order to remove `mro()`.


---

Comment by ncohen created at 2013-07-24 08:23:42

? Why do you say that it's correct ? Surely you agree that this mro thing is not something that the user should see ? And how could renaming a method from `mro` to `_mro_` or `_the_method_that_used_to_be_called_mro_` be a structural problem ? `O_o`

Nathann


---

Comment by tscrim created at 2013-07-24 08:37:34

No I do not agree. The reason is all that stuff 2 comments ago that you didn't understand. `posets` is a class, so it has an MRO. To change this behavior, one would have to change `posets` into a module and import that module (as opposed the class that it currently is).

Some links for reading on the MRO:

- http://stackoverflow.com/questions/2010692/what-does-mro-do-in-python
- http://docs.python.org/2/library/stdtypes.html?highlight=mro#class.__mro__
- http://www.python.org/download/releases/2.3/mro/

Classes vs. modules in python:

- http://docs.python.org/2/tutorial/modules.html
- http://docs.python.org/2/tutorial/classes.html

Best,

Travis


---

Comment by ncohen created at 2013-07-24 08:46:53

> No I do not agree. The reason is all that stuff 2 comments ago that you didn't understand. `posets` is a class, so it has an MRO. 

`O_o`

And this thing *HAS* to be called .mro() and cannot be called `_whatever_` ?

Nathann


---

Comment by tscrim created at 2013-07-24 08:47:34

Replying to [comment:13 ncohen]:
> And this thing *HAS* to be called .mro() and cannot be called `_whatever_` ?

Correct, it's a python thing.


---

Comment by ncohen created at 2013-07-24 08:53:34

> Correct, it's a python thing.

Python is stuffed with methods like `__add__` `__rmul__` `__eq__`, and yet they require that `.mro` cannot be a private function ?... `>_<`

Crazy...

Nathann


---

Comment by ncohen created at 2013-07-28 20:42:14

Changing status from needs_review to needs_work.


---

Comment by ncohen created at 2013-07-28 20:42:14

(because of Travis' comment)


---

Attachment

Replying to [comment:6 tscrim]:
> - The `cell_leq` method is not needed since the default comparison between lists/tuples in python is lex which matches your definition (and your current implementation does not match your def'n in that the def'n has "or" whereas the test has "and").

I think what I had written was just wrong. This is supposed to be the order that the entries of standard Young tableaux satisfy, so it isn't lex. I've rewritten it to check for covering relations (and it now occurs to me the function should be renamed--I'll do that after I write this).

> - You'll need to put your real name as the author.

Name where? On the ticket?

The patch isn't ready to be reviewed, despite me having uploaded a new version. I noticed there's a way to simplify `YoungsLatticePrincipalOrderIdeal`.


---

Comment by chapoton created at 2014-03-21 19:37:08

Changing keywords from "sd40" to "sd40, posets".


---

Comment by chapoton created at 2014-10-05 20:05:08

Made a git branch. This needs refactoring. Note in particular. that some functions about absolute order already exist.
----
New commits:


---

Comment by git created at 2014-10-08 13:03:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-01-18 19:58:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-03-16 16:02:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-04-17 12:04:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-10-08 19:27:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2015-10-09 06:14:58

I suggest adding standard example. That is, the poset of `2n` (`n >= 2`) elements with dimension `n`. Code is for example


```
return Poset( (range(2*n), [[i, j+n] for i in range(n) for j in range(n) if i != j]) )
```



---

Comment by kdilks created at 2015-10-09 16:41:40

Implementing fences ( https://en.wikipedia.org/wiki/Fence_(mathematics) ), which is a generalization of the zig-zag poset, would also be good.


---

Comment by jmantysalo created at 2015-10-09 18:35:28

Replying to [comment:35 kdilks]:
> Implementing fences ( https://en.wikipedia.org/wiki/Fence_(mathematics) ), which is a generalization of the zig-zag poset, would also be good.

Wikipedia says that up-down -posets are a generalization of fences. Should we implement it directly, as a fence would be then available as `updown_poset(1, n)`?

Young's lattice is a semilattice. Should the function then return a semilattice instead of "only" poset? Or should we have an option for return type? I.e. `type='poset'` or something like it?

These are of course only suggestions.


---

Comment by kdilks created at 2015-10-09 18:53:06

Yes, I meant to say up-down posets are a generalization of the zig-zag poset.

Maybe implement up-down posets generally, and then have `zigzag_poset(n)` as an alias for `updown_poset(1,n)` ? Zig-zag poset is something that people might be interested in without necessarily knowing the generalized notion of up-down posets.


---

Comment by kdilks created at 2015-10-09 19:08:54

Created ticket #19383 for up-down posets and the dimension n on 2n elements example, so this ticket can be reviewed and closed without being delayed every time we think of a new kind of poset to add.


---

Comment by jmantysalo created at 2016-01-12 12:58:53

This is in needs_work, but every point in the decription says "done". So what this actually waits for?


---

Comment by ncohen created at 2016-01-12 17:00:24

Changing status from needs_work to positive_review.


---

Comment by ncohen created at 2016-01-12 17:00:24

It is what some people call a "meta ticket". I don't know what exactly people create them for, but I believe that they are meant to be closed once their are fulfilled?

I set it to 'close', feel free to change the status if you believe that something should be added to this ticket's description.

Nathann


---

Comment by vbraun created at 2016-01-12 17:16:53

names...


---

Comment by vbraun created at 2016-01-12 17:16:53

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2016-01-12 17:17:53

is this fixed? set milestone to wontfix


---

Comment by ncohen created at 2016-01-12 17:30:14

Sorry.

Do we need an 'Author' for wontfix closed tickets?


---

Comment by chapoton created at 2016-01-12 18:06:58

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2016-01-12 18:06:58

NO ! THIS is NOT a metaticket ! this contains CODE !


---

Comment by git created at 2016-01-12 19:28:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-01-12 20:42:39

I still don't understand why `SetPartitions` returns a poset and not a lattice.


---

Comment by git created at 2016-01-13 08:00:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-01-13 09:12:35

This is a good addition. However, some comments:

- Index of `poset_examples.py` is missing functions. Maybe this could be a place for Nathann's automatic indexing feature.

- `print "TEST FAILED"` -part should be on `TESTS`, not on `EXAMPLES`.

- `SetPartitions` works. However, actually you can say `Posets.SetPartitions('junk')`, but the documentation mentions only integers. Safe option is to check input type and raise exception if it is not an integer; it is always easier to extend than to deprecate.

- `YoungsLattice` is returned as a poset. Not so important, but why not as a meet-semilattice?

- Similarly, `YoungsLatticePrincipalOrderIdeal` is lattice. And I think that `PartitionsDominanceOrder` is also.

- Should an input section crosslink to type when the input is of type `Partition`? See output block in `antichains`. OTOH maybe just a noise.

- `PartitionsDominanceOrder('junk')` gives error but `PartitionsDominanceOrder(-1)` does not.

- Maybe a stupid question, but is "integer partitions" by definition sorted partitioning, i.e. not for example `[4,2,3]`? I was just wondering about doc of `PartitionsDominanceOrder`.

As I don't know Coxeter groups, this needs another reviewer. But I can check `poset_examples.py`.


---

Comment by git created at 2016-01-13 10:27:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-01-13 11:00:57

I have no other comments. But actually the one reviewing Coxeter group code should also take a quck look to `SymmetricGroupAbsoluteOrderPoset`. Otherwise `poset_examples.py` is in positive_review from my side.


---

Comment by git created at 2016-02-01 07:49:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-02-06 16:27:23

A few comments:

- I don't like the special case of `absolute_length` for the symmetric group. This should be a method for the elements of `SymmetricGroup`. Actually, there probably is a quick way to implement `absolute_length()` on those elements directly.

- For `absolute_covers`, it is faster to iterate over `reflections` (typically about 2x faster). Also you should store `self.absolute_length()` so it doesn't get recomputed each time.


---

Comment by git created at 2016-02-06 21:05:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2016-02-06 21:09:25

I have tried to use "reflections()". This forced me to change the behaviour of the existing reflections method for finite Weyl groups.

Where should I put a "method for elements of the symmetric group" ? I have not found the place to do so.

The usual length is not cached. Why should I cache absolute length ?

Maybe it would be better to split this ticket into the part that Jori can review and the part about absolute order ?


---

Comment by tscrim created at 2016-02-07 16:10:35

Replying to [comment:58 chapoton]:
> I have tried to use "reflections()". This forced me to change the behaviour of the existing reflections method for finite Weyl groups.

It does not look like need to change the behavior of `reflections()`, but just need to get the keys with `reflections().keys()`. However, I do agree that there is some ambiguity with `reflections` in the sense of Coxeter groups. This latter issue warrants a separate discussion/ticket.

> Where should I put a "method for elements of the symmetric group" ? I have not found the place to do so.

We probably need to add such a class. I can do that.

> The usual length is not cached. Why should I cache absolute length ?

I didn't say cache it, but what I said was somewhat vague. I meant store it as a variable before you run the list comprehension in `absolute_covers`.

> Maybe it would be better to split this ticket into the part that Jori can review and the part about absolute order ?

We can do one of 3 things:

1 - include it all here,
2 - make it a dependency, or
3 - make it a completely separate issue.

Although the absolute order/length things I can finish with things tomorrow (Monday) too. So personally I'm in favor of 1.


---

Comment by chapoton created at 2016-02-07 17:55:16

The change in reflections is needed because it currently returns different things for Coxeter groups and for Weyl groups. I can not ask for the keys in Coxeter groups, where
the method reflections return a list of all reflections. In my opinion, it should do the same by default for Weyl groups. Doing so breaks only a few doctests in the tutorials, as one can see in the patchbot reports.

I will not be available for sage development next week.


---

Comment by tscrim created at 2016-02-09 15:05:57

I created #20027 for making the behaviors consistent.


---

Comment by chapoton created at 2016-03-06 20:20:42

needs to be adapted after #20027


---

Comment by chapoton created at 2016-03-06 20:20:42

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-03-08 17:12:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-08 23:29:30

Let me know when this is ready to be looked at again.


---

Comment by git created at 2016-03-12 18:47:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2016-03-12 18:47:52

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2016-03-12 18:47:52

should be good now


---

Comment by tscrim created at 2016-03-12 22:38:14

I made a few changes:

- Added `coxeter_matrix()` to symmetric group so its some geneic methods of its elements are not broken.
- Added a new class for elements of the symmetric group (the permutation group element code could use a cleanup to bring it up to our current standards; e.g., the first input for the element should be the parent and we should use the category framework).
- Changed `dict` into dict comprehension.
- Added an absolute order example poset for Coxeter groups.
- Removed the size of `n` restriction for the symmetric group. It's artificial and someone might want the `n = 11` case to test a conjecture on a good machine.

If you agree with my changes, then you can set a positive review.
----
New commits:


---

Comment by git created at 2016-03-13 07:30:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-13 07:33:00

Whoops. Thought I got them all. Although you lost a space.


---

Comment by git created at 2016-03-13 07:39:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2016-03-13 08:10:07

I'm happy with your changes. Does this count as a positive review?


---

Comment by chapoton created at 2016-03-13 08:34:06

ok, I think this can go. There remains one "dict", but that is not important. You
can set to positive review.


---

Comment by tscrim created at 2016-03-13 08:53:41

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2016-03-13 08:53:41

Meh, not so important. I mostly changed the others because I was looking very closely at that poset anyways since that had not been "reviewed". Thanks to you all.


---

Comment by vbraun created at 2016-03-20 23:41:53

Resolution: fixed
