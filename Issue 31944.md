# Issue 31944: RealSet: Faster operations by scan-line (merging) techniques

Issue created by migration from https://trac.sagemath.org/ticket/32181

Original creator: mkoeppe

Original creation time: 2021-07-11 18:10:41

CC:  yzh

Adapt from:
- https://github.com/mkoeppe/cutgeneratingfunctionology/blob/master/cutgeneratingfunctionology/igp/intervals.py
- https://github.com/mkoeppe/cutgeneratingfunctionology/blob/master/cutgeneratingfunctionology/igp/fast_piecewise.py


---

Comment by git created at 2022-07-18 21:42:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-26 19:56:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-07-27 07:46:40

If you merge the most current beta (9.7.beta6), you can use https://trac.sagemath.org/wiki/ReleaseTours/sage-9.7#Validatingdocstringwith.sage-tox-erst


---

Comment by git created at 2022-07-28 19:54:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-07-28 20:17:56

`tox -e relint` will tell you that `EXAMPLE::` should be `EXAMPLES::` according to our style guide (whether there is a single or there are multiple examples)


---

Comment by yzh created at 2022-07-29 18:39:24

The current code does not pass the doc-tests.
Also, please follow https://doc.sagemath.org/html/en/developer/coding_basics.html. For example, in the text part, `convex_hull` should be fully-referenced so that it is clickable after build, i.e. :meth:`~sage.sets.real_set.RealSet.convex_hull`


---

Comment by yzh created at 2022-07-30 03:50:05

I took a look through the code, but didn't run the code. 
I have some first comments.
- The patchbot currently shows 31 doctests failures and 4 lint errors. To be fixed!
- In the docstrings of `_scan_left_endpoint` and `_scan_right_endpoint`: What does an event mean. Reformat the text after output. Describe the value of delta. Include example(s) where tag is given.
- `RealSet` constructor with option normalized=True. What does this assume? Describe it in the docstring of `__classcall__`  or that of `RealSet`. Mention that is does not apply to the manifold case. Include doctests/tests where normalized=True is given, and examples where arguments are of type `InternalRealInterval`. 
- I have doubts about where `if not normalized` is treated. (But of course, this depends on how you define normalized=True). I thought if normalized=True and it's not of the manifold case (lines 1267-1283), one can just return `UniqueRepresentation.__classcall__(cls, *intervals)` before line 1199 `intervals = []`, which skips all treatments on args. 
- When normalized is not True, may simplify and insert the code in def normalize here, then remove the normalize function as it is only used once here. Alternatively, keep def normalize and move all treatment of args from `__classcall__` to normalize.
- `RealSet.__classcall__`: Line 1188-1190 change to just: normalized = kwds.pop('normalized', False). L1194: "... take no keyword arguments other than 'normalized'."" 
- `RealSet._prep`: L1710 elif. L1717 elif
- `RealSet` doesn't need methods `_scan_left_endpoint` and `_scan_right_endpoint`. These are methods of the class `InternalRealInterval`. 
- `RealSet._scan_interval` Rename the function, to something like `_scan`, or `_scan_intervals`, or `_generate_events`. Rewrite the function: for i in self._intervals: yield i._scan_left_endpoint(tag); yield i._scan_right_endpoint(tag). No more merge/sorting needed.
- Ideally, all scan methods are generators. Currently, some are generators, some return lists.
- In `_scan_line_union`, lines 2104-2122, the two while loops look very suspicious to me. I think they do not belong here. Moreover, the lines 2118-2119 in the second while loop might be wrong. You claimed that these two while loops take care of the special cases RealSet(x=-infinity) and RealSet(x<=-infinity), but the input scan to this function should never be in such form. Such empty (nonsense) special cases should already been eliminated in around line 1209 in `__classcall__`
- In `union_of_realsets` and other similar functions: Lines 2175 to 2178 can be simplified to `scan = merge(RealSet(s)._scan() for s in real_set_collection)`
- `_scan_line_intersection`. Add more special examples to doctest to cover the cases where intersection is just one point, or just empty. For example:  `[1,2] ∩ [2,3]`, `[2,3] ∩ (3,4)`, `(3,4) ∩ [4,5)`, `[4,5) ∩ (5,6)`. Lines 2252-2261 (and other similar places) can be simplified to

```
if now_on:
  (on_x, on_epsilon) = (x, epsilon) 
else: 
  if was_on and (on_x, on_epsilon) < (x, epsilon): 
    yield InternalRealInterval(...)
  (on_x, on_epsilon) = (None, None)
```

- Questions about 'tag'. It is said to be a real number in the docstrings of many function, but is used as True or False for the difference function only. I think tag can be eliminated throughout the code (and do some special treatment for the difference.) Also, why is it called index at some places? That's not used either, so can be removed as well. On a related note, given a collection of real sets, after generating and merging the their scan, you can no longer match the list of events back to the original real sets, because index was not passed to tag in the events. I do not like the current design. 
- `_scan_line_union`, `_scan_line_intersection`, `_scan_line_symmetric_difference` (and part of `are_pairwise_disjoint`) all look redundant. They all can be replaced by a new method `RealSet._scan_to_intervals(scan, indicator)` that takes scan as a generator of sorted events and indicator as a number 1 or n (or perhaps as a lambda function for `are_pairwise_disjoint`), and outputs a tuple intervals of type InternalRealInterval.
- According to your ticket description, the old union method is slower than the new one. Is this true for the union of two real sets? If so, why is the old one kept in the code? If not, please update the description of the ticket, and include comments in the code. In general, are there examples where the original method is faster? Please specify the examples, and change the code to choose strategically between the two versions according to the input.
- `def convex_hull`: correct but wasteful. One does not to sort all intervals, only the left most and right most intervals of each real set matter.
- `def is_connected` docstring: Return whether ``self`` is a connected set. OUTPUT: Boolean. ``True`` if ``self`` is a single interval.
- `def are_pairwise_disjoint`: Revise.
- Throughout the code, (for example in `_scan_line_union` and `_scan_line_intersection` and many other functions,) the docstrings need significant improvements! The current ones make little sense. They are often copy-pasted from other places which do not correspond to the function. Input and output descriptions are not exact, variable undefined, variable mistaken (eg. realsets v.s `real_set_collection`) type not specified, code-style incorrect. Often bad and incomplete examples. `EXAMPLES::` plural. At the beginning of the file, "Yueqi Li (2022-06-27): ..." Rephrase to one or two lines. Some places in the docstrings ":meth:`~sage.sets.real_set.RealSet.convex_hull`"
- Please make sure that your docstrings follow https://doc.sagemath.org/html/en/developer/coding_basics.html.  
- Throughout the code: clean up the commented-out code.
- Throughout the code: :class:`RealInterval` should be :class:`InternalRealInterval`
- New method: relative closure in a superset?


---

Comment by yzh created at 2022-07-30 04:42:00

Merge-in [SageMath](SageMath) version to 9.7.beta6.
----
New commits:


---

Comment by git created at 2022-07-31 06:52:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-31 07:07:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-31 13:26:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by yzh created at 2022-07-31 13:46:10

Replying to [comment:6 gh-NicoleYueqiLi]:
I rewrote your code according to the remarks in comment:12. Yet to update the docstrings.


---

Comment by git created at 2022-08-01 09:58:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by yzh created at 2022-08-01 10:01:22

Changing status from new to needs_info.


---

Comment by git created at 2022-08-01 10:17:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by yzh created at 2022-08-01 10:20:37

Try merging #34252 to fix the docbuild errors.


---

Comment by yzh created at 2022-08-01 10:23:35

Changing status from needs_info to needs_review.


---

Comment by git created at 2022-08-01 10:33:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-01 13:47:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-01 17:58:07

As you merged #34252 here, add it to Dependencies in the ticket box


---

Comment by mkoeppe created at 2022-08-01 18:06:34

I think you can unify `RealSet.intersection` and `RealSet.intersection_of_realsets` to just one (non-static) method `RealSet.intersection`.


---

Comment by git created at 2022-08-01 21:31:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-04 17:20:24


```
-    @staticmethod
-    def normalize(intervals):
-        r"""
```

This function is part of the public API, can't just remove


---

Comment by mkoeppe created at 2022-08-04 17:21:19


```
+            # Fastpass: The input is already normalized: Args is a list of
```

That should be "Fast path"


---

Comment by mkoeppe created at 2022-08-04 17:25:35


```
+    def is_connected(self):
+        """
+        Return whether ``self`` is a connected set.
+
+        OUTPUT:
+
+        Boolean. Whether the normalized form of ``self``
+        has a single connected component.
+
```


In this description, you are mixing talking about ``self`` as a set and its representation as a list of intervals


---

Comment by mkoeppe created at 2022-08-04 17:27:05


```
             sage: s1.symmetric_difference(s2)
             (0, 1] ∪ [2, +oo)
         """
-        other = RealSet(*other)
-        return self.difference(other).union(other.difference(self))
+        scan = merge(self._scan(), RealSet(*other)._scan())
+        intervals = tuple(RealSet._scan_to_intervals(scan, lambda i: bool(i == 1)))
+        return RealSet(*intervals, normalized=True)
 
     def contains(self, x):
```

Is the explicit conversion to `bool` necessary here?


---

Comment by mkoeppe created at 2022-08-04 17:34:33

Would it make sense to add the benchmarks mentioned in the ticket description as doctests (can be marked `# not tested` so it does not run automatically)?

The benchmarks are for complicated real sets with many intervals.

Does the new implementation have an overhead over the previous implementation that becomes noticeable for simple real sets with 0, 1, 2, or 5 intervals? That's probably the most common case how this class is used. It would be good to include a benchmark for this.


---

Comment by yzh created at 2022-08-04 17:44:05

Thanks for reviewing the ticket! I don't think that the benchmark in the current ticket description makes much sense. I was hoping that Yueqi would be able to provide an updated version and more details soon. 
Replying to [comment:35 mkoeppe]:
> Would it make sense to add the benchmarks mentioned in the ticket description as doctests (can be marked `# not tested` so it does not run automatically)?
> 
> The benchmarks are for complicated real sets with many intervals.
> 
> Does the new implementation have an overhead over the previous implementation that becomes noticeable for simple real sets with 0, 1, 2, or 5 intervals? That's probably the most common case how this class is used. It would be good to include a benchmark for this.
>


---

Comment by yzh created at 2022-08-04 17:46:09

I don't quite get it. I thought that a real set is connected iff its normalized form has only one connected component (interval or singleton).

Replying to [comment:33 mkoeppe]:
> {{{
> +    def is_connected(self):
> +        """
> +        Return whether ``self`` is a connected set.
> +
> +        OUTPUT:
> +
> +        Boolean. Whether the normalized form of ``self``
> +        has a single connected component.
> +
> }}}
> 
> In this description, you are mixing talking about ``self`` as a set and its representation as a list of intervals
>


---

Comment by yzh created at 2022-08-04 17:47:23

Do you mean bool(i==1)? I don't know if it's always needed, but I thought there is nothing wrong to add it.
Replying to [comment:34 mkoeppe]:
> {{{
>              sage: s1.symmetric_difference(s2)
>              (0, 1] ∪ [2, +oo)
>          """
> -        other = RealSet(*other)
> -        return self.difference(other).union(other.difference(self))
> +        scan = merge(self._scan(), RealSet(*other)._scan())
> +        intervals = tuple(RealSet._scan_to_intervals(scan, lambda i: bool(i == 1)))
> +        return RealSet(*intervals, normalized=True)
>  
>      def contains(self, x):
> }}}
> Is the explicit conversion to `bool` necessary here?


---

Comment by mkoeppe created at 2022-08-04 17:58:31

Replying to [comment:37 yzh]:
> I don't quite get it. I thought that a real set is connected iff its normalized form has only one connected component (interval or singleton).

"Connected component" is a property of the set (topological space).

"Normalized form" is a list of intervals. There's no such thing as a connected component of a list.


---

Comment by git created at 2022-08-04 17:59:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-04 18:00:49

Replying to [comment:38 yzh]:
> Do you mean bool(i==1)? I don't know if it's always needed, but I thought there is nothing wrong to add it.

`i` is just an integer, right? Converting to `bool` is only needed in comparison when you are comparing `SR` elements, which have overloaded comparison operators for forming relational expressions.


---

Comment by mkoeppe created at 2022-08-04 18:01:42

If you want, you can add a deprecation for the `normalize` method


---

Comment by git created at 2022-08-04 18:03:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-04 18:08:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-08-04 19:04:41

Here's a microbenchmark:

Before:

```
sage: from itertools import count
sage: c = count()
sage: %timeit RealSet((0, next(c)))
82.9 µs ± 3.75 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
sage: %timeit RealSet((0, next(c))).union([next(c), next(c)])
210 µs ± 7.86 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
```


With this ticket:

```
sage: from itertools import count
sage: c = count()
sage: %timeit RealSet((0, next(c)))
86.2 µs ± 3.43 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
sage: %timeit RealSet((0, next(c))).union([next(c), next(c)])
257 µs ± 18.9 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
```



---

Comment by yzh created at 2022-08-04 19:39:31

Does the overhead look acceptable on the above examples?


---

Comment by mkoeppe created at 2022-08-04 19:40:01


```
     def __init__(self, lower, lower_closed, upper, upper_closed, check=True):
         """
         Initialize ``self``.
[...]
             if (upper_closed and upper == infinity):
                 raise ValueError('interval cannot be closed at +oo')
+            # TODO: take care of the empty set case.
```


What do you have in mind there?


---

Comment by yzh created at 2022-08-04 19:44:31

Somewhere in the original code (__mul__ ?), the empty interval is set to (0, 0)
Replying to [comment:47 mkoeppe]:
> {{{
>      def __init__(self, lower, lower_closed, upper, upper_closed, check=True):
>          """
>          Initialize ``self``.
> [...]
>              if (upper_closed and upper == infinity):
>                  raise ValueError('interval cannot be closed at +oo')
> +            # TODO: take care of the empty set case.
> }}}
> 
> What do you have in mind there?


---

Comment by mkoeppe created at 2022-08-04 21:23:49

Is this syntax `self.intersection(0,1)` new? Is it really needed?

```
+        elif len(real_set_collection) == 2:
+            a, b = real_set_collection
+            # allow self.intersection(0,1) syntax
+            try:
+                a.n()
+                b.n()
+                sets.append(RealSet(a, b))
+            except (AttributeError, ValueError, TypeError):
+                sets.append(RealSet(a))
+                sets.append(RealSet(b))
+        else:
```



---

Comment by yzh created at 2022-08-04 21:26:19

I didn't like it either, since the new code spends a lot of effect to take care of that. I wanted to eliminate that. However, the original code allowed for it (contained doctests of that kind).
Replying to [comment:51 mkoeppe]:
> Is this syntax `self.intersection(0,1)` new? Is it really needed?
> {{{
> +        elif len(real_set_collection) == 2:
> +            a, b = real_set_collection
> +            # allow self.intersection(0,1) syntax
> +            try:
> +                a.n()
> +                b.n()
> +                sets.append(RealSet(a, b))
> +            except (AttributeError, ValueError, TypeError):
> +                sets.append(RealSet(a))
> +                sets.append(RealSet(b))
> +        else:
> }}}


---

Comment by mkoeppe created at 2022-08-04 21:30:22

OK, you are right, the old code did allow it. So we have to keep it.


---

Comment by mkoeppe created at 2022-08-04 21:34:57


``` 
-    def intersection(self, *other):
+    def intersection(self, *real_set_collection):
         """
```


I think you can simplify it further by making it 

```
     def intersection(*real_set_collection)
```


When used as a bound method, `RealSet(1, 3).intersection(RealSet(2, 4))`, the ``self`` would just be the first element of ``real_set_collection``.

But it could also be used as an unbound method `RealSet.intersection(RealSet(1, 3), RealSet(2,4))`, and you could also handle the case `RealSet.intersection()`, which should give the real line as the intersection over an empty family


---

Comment by mkoeppe created at 2022-08-04 21:44:08

(Just a suggestion, it's fine as it)


---

Comment by mkoeppe created at 2022-08-04 21:51:41

Replying to [comment:46 yzh]:
> Does the overhead look acceptable on the above examples?

Yes, I think it's fine.

My guess is that it could be improved by a custom version of heapq with a fast path for near-trivial cases, or even cythonized.

Let's keep this for a possible follow-up ticket.


---

Comment by mkoeppe created at 2022-08-04 21:53:22

Changing status from needs_review to positive_review.


---

Comment by yzh created at 2022-08-04 21:58:05

That's a good suggestion, but I incline to leave it as is on this ticket. The reason is the treatments for special cases such as `RealSet.union(RealSet(0,1)), RealSet.union((0,1)), RealSet.union(0, 1), and RealSet(0,1).union(1, 3)==RealSet.union(RealSet(0,1), 1, 3)` could be too complicated at the moment. Will discuss the deprecation of the use of `RealSet(0,1).union(1, 3)` on another ticket later.
Replying to [comment:54 mkoeppe]:
> {{{ 
> -    def intersection(self, *other):
> +    def intersection(self, *real_set_collection):
>          """
> }}}
> 
> I think you can simplify it further by making it 
> {{{
>      def intersection(*real_set_collection)
> }}}
> 
> When used as a bound method, `RealSet(1, 3).intersection(RealSet(2, 4))`, the ``self`` would just be the first element of ``real_set_collection``.
> 
> But it could also be used as an unbound method `RealSet.intersection(RealSet(1, 3), RealSet(2,4))`, and you could also handle the case `RealSet.intersection()`, which should give the real line as the intersection over an empty family 
> 
>


---

Comment by yzh created at 2022-08-04 21:59:43

Thank you! Replying to [comment:57 mkoeppe]:


---

Comment by yzh created at 2022-08-05 16:27:22

Should `def normalize(intervals)` be `@`staticmethod


---

Comment by yzh created at 2022-08-05 16:51:51

Never mind. Without `@`staticmethod, the following can apply.

```
sage: r = RealSet(RealSet(2, 6)[0], RealSet(4, 10)[0], normalized=True)
sage: r
(2, 6) ∪ (4, 10)
sage: r.normalize()
((2, 10),)
```


Replying to [comment:60 yzh]:
> Should `def normalize(intervals)` be `@`staticmethod


---

Comment by vbraun created at 2022-08-06 07:44:13

Resolution: fixed
