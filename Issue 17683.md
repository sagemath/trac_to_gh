# Issue 17683: Reimplement IntegerLists using Polyhedron.integral_points()

archive/issues_017683.json:
```json
{
    "body": "CC:  @nathanncohen @anneschilling @tscrim @nthiery\n\nThis fixes #17548.\n\nIt also adds new features to `IntegerLists`:\n\n1. Negative integers are allowed (but the default still is `min_part=0`).\n\n2. There does not need to be a fixed sum, one can do for example `IntegerLists(max_part=2)` for all lists of integers <= 2. One can also give a lower/upper bound for the sum.\n\nNote that the current implementation requires, for a given length, that there are only finitely many lists of that length. This limitation could be lifted in the future.\n\nIssue created by migration from https://trac.sagemath.org/ticket/17920\n\n",
    "closed_at": "2015-03-09T20:56:34Z",
    "created_at": "2015-03-09T17:52:44Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.6",
    "title": "Reimplement IntegerLists using Polyhedron.integral_points()",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17683",
    "user": "https://github.com/jdemeyer"
}
```
CC:  @nathanncohen @anneschilling @tscrim @nthiery

This fixes #17548.

It also adds new features to `IntegerLists`:

1. Negative integers are allowed (but the default still is `min_part=0`).

2. There does not need to be a fixed sum, one can do for example `IntegerLists(max_part=2)` for all lists of integers <= 2. One can also give a lower/upper bound for the sum.

Note that the current implementation requires, for a given length, that there are only finitely many lists of that length. This limitation could be lifted in the future.

Issue created by migration from https://trac.sagemath.org/ticket/17920





---

archive/issue_comments_236019.json:
```json
{
    "body": "The Sage MILP solvers cannot enumerate all solutions => closing as invalid.",
    "created_at": "2015-03-09T20:56:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236019",
    "user": "https://github.com/jdemeyer"
}
```

The Sage MILP solvers cannot enumerate all solutions => closing as invalid.



---

archive/issue_comments_236020.json:
```json
{
    "body": "Resolution: invalid",
    "created_at": "2015-03-09T20:56:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236020",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: invalid



---

archive/issue_events_051027.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-03-09T20:56:34Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17683#event-51027"
}
```



---

archive/issue_events_051028.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-03-09T20:56:34Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17683#event-51028"
}
```



---

archive/issue_comments_236021.json:
```json
{
    "body": "Changing status from closed to new.",
    "created_at": "2015-03-10T15:41:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236021",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from closed to new.



---

archive/issue_events_051029.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-03-10T15:41:56Z",
    "event": "reopened",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17683#event-51029"
}
```



---

archive/issue_comments_236022.json:
```json
{
    "body": "Resolution changed from invalid to ",
    "created_at": "2015-03-10T15:41:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236022",
    "user": "https://github.com/jdemeyer"
}
```

Resolution changed from invalid to 



---

archive/issue_events_051030.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-03-10T15:41:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17683#event-51030"
}
```



---

archive/issue_events_051031.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2015-03-10T15:41:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "milestone": "sage-6.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17683#event-51031"
}
```



---

archive/issue_comments_236023.json:
```json
{
    "body": "I do not understand what this is... Did you copy/paste the original file? It seems that you copy/pasted the original files and made some modifications to it `O_o`\n\nNathann\n\n---\nNew commits:",
    "created_at": "2015-03-12T07:16:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236023",
    "user": "https://github.com/nathanncohen"
}
```

I do not understand what this is... Did you copy/paste the original file? It seems that you copy/pasted the original files and made some modifications to it `O_o`

Nathann

---
New commits:



---

archive/issue_comments_236024.json:
```json
{
    "body": "Yes, that's what I did. Anyway, this is still very much work in progress...",
    "created_at": "2015-03-12T10:02:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236024",
    "user": "https://github.com/jdemeyer"
}
```

Yes, that's what I did. Anyway, this is still very much work in progress...



---

archive/issue_comments_236025.json:
```json
{
    "body": "> Yes, that's what I did. Anyway, this is still very much work in progress...\n\n\nOh, okay!\n\nNathann",
    "created_at": "2015-03-12T10:03:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236025",
    "user": "https://github.com/nathanncohen"
}
```

> Yes, that's what I did. Anyway, this is still very much work in progress...


Oh, okay!

Nathann



---

archive/issue_comments_236026.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-12T16:41:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236026",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236027.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-13T10:38:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236027",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236028.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-14T14:11:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236028",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236029.json:
```json
{
    "body": "This now seems to work reasonably well. Not yet ready, but good enough for example to compare with the existing implementation. That's how I found all the bugs at #17548.\n\nDue to the polyhedra overhead, it is generally (a lot) slower than the existing code.",
    "created_at": "2015-03-14T14:17:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236029",
    "user": "https://github.com/jdemeyer"
}
```

This now seems to work reasonably well. Not yet ready, but good enough for example to compare with the existing implementation. That's how I found all the bugs at #17548.

Due to the polyhedra overhead, it is generally (a lot) slower than the existing code.



---

archive/issue_comments_236030.json:
```json
{
    "body": "Replying to [comment:12 jdemeyer]:\n> This now seems to work reasonably well. Not yet ready, but good enough for example to compare with the existing implementation. That's how I found all the bugs at #17548.\n> \n> Due to the polyhedra overhead, it is generally (a lot) slower than the existing code.\n\n\nIs it worth changing this branch so that it changes the existing code instead of adding a new file ? As you said: let's be correct first, *then* fast.\n\nNathann",
    "created_at": "2015-03-14T16:40:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236030",
    "user": "https://github.com/nathanncohen"
}
```

Replying to [comment:12 jdemeyer]:
> This now seems to work reasonably well. Not yet ready, but good enough for example to compare with the existing implementation. That's how I found all the bugs at #17548.
> 
> Due to the polyhedra overhead, it is generally (a lot) slower than the existing code.


Is it worth changing this branch so that it changes the existing code instead of adding a new file ? As you said: let's be correct first, *then* fast.

Nathann



---

archive/issue_comments_236031.json:
```json
{
    "body": "My code does not yet support all (undocumented!) features of the old `IntegerListsLex`, so we cannot yet replace `IntegerListsLex`.",
    "created_at": "2015-03-14T16:43:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236031",
    "user": "https://github.com/jdemeyer"
}
```

My code does not yet support all (undocumented!) features of the old `IntegerListsLex`, so we cannot yet replace `IntegerListsLex`.



---

archive/issue_comments_236032.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-14T18:24:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236032",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236033.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-14T22:03:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236033",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236034.json:
```json
{
    "body": "This now implements `Compositions` using my new `IntegerListsLex` (is the lex ordering really important? I guess not, it's for sure nowhere documented). However, doing the same for `Partitions` leads to all kinds of breakage and I don't understand why.",
    "created_at": "2015-03-14T22:05:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236034",
    "user": "https://github.com/jdemeyer"
}
```

This now implements `Compositions` using my new `IntegerListsLex` (is the lex ordering really important? I guess not, it's for sure nowhere documented). However, doing the same for `Partitions` leads to all kinds of breakage and I don't understand why.



---

archive/issue_comments_236035.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-14T22:11:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236035",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236036.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-14T22:23:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236036",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236037.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-15T11:06:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236037",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236038.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-15T11:19:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236038",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236039.json:
```json
{
    "body": "Note that this changes 3 tests (just reordering the output) in `src/sage/tests/book_schilling_zabrocki_kschur_primer.py`",
    "created_at": "2015-03-15T11:22:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236039",
    "user": "https://github.com/jdemeyer"
}
```

Note that this changes 3 tests (just reordering the output) in `src/sage/tests/book_schilling_zabrocki_kschur_primer.py`



---

archive/issue_comments_236040.json:
```json
{
    "body": "The code on this ticket is essentially complete, I just need to add more doctests to comply with the \"coverage\" policy.",
    "created_at": "2015-03-15T11:23:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236040",
    "user": "https://github.com/jdemeyer"
}
```

The code on this ticket is essentially complete, I just need to add more doctests to comply with the "coverage" policy.



---

archive/issue_comments_236041.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-15T12:38:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236041",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236042.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-03-15T15:03:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236042",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_236043.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-03-15T15:08:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236043",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_236044.json:
```json
{
    "body": "Do you have some timings?\n\nAlso, both of these are wrong:\n\n```\nsage: Compositions(3, max_length=2, inner=[1,1,1]).list()\n[]\nsage: Compositions(10, outer=[4], inner=[1,1]).list()\n[]\n```\nThe first should be `[[2, 1], [1, 2]]` since the `inner` (or `outer`) are not related to the min or max lengths. For the second, the inner composition is extendedby the minimum part, so there are many such compositions, such as `[4,6]`, `[2,8]`, etc.",
    "created_at": "2015-03-15T15:25:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236044",
    "user": "https://github.com/tscrim"
}
```

Do you have some timings?

Also, both of these are wrong:

```
sage: Compositions(3, max_length=2, inner=[1,1,1]).list()
[]
sage: Compositions(10, outer=[4], inner=[1,1]).list()
[]
```
The first should be `[[2, 1], [1, 2]]` since the `inner` (or `outer`) are not related to the min or max lengths. For the second, the inner composition is extendedby the minimum part, so there are many such compositions, such as `[4,6]`, `[2,8]`, etc.



---

archive/issue_comments_236045.json:
```json
{
    "body": "Replying to [comment:27 tscrim]:\n> Do you have some timings?\n\n\nSlow is better than wrong, isn't it? ;-)",
    "created_at": "2015-03-15T15:28:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236045",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:27 tscrim]:
> Do you have some timings?


Slow is better than wrong, isn't it? ;-)



---

archive/issue_comments_236046.json:
```json
{
    "body": "Replying to [comment:27 tscrim]:\n> Do you have some timings?\n\nMy code is much slower.\n\n> Also, both of these are wrong:\n> \n> ```\n> sage: Compositions(3, max_length=2, inner=[1,1,1]).list()\n> []\n> sage: Compositions(10, outer=[4], inner=[1,1]).list()\n> []\n> ```\n> The first should be `[[2, 1], [1, 2]]`\n\nI don't think so. The `Compositions` code explicitly adds the length of the `inner` argument as minimal length. I didn't change this.",
    "created_at": "2015-03-15T15:29:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236046",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:27 tscrim]:
> Do you have some timings?

My code is much slower.

> Also, both of these are wrong:
> 
> ```
> sage: Compositions(3, max_length=2, inner=[1,1,1]).list()
> []
> sage: Compositions(10, outer=[4], inner=[1,1]).list()
> []
> ```
> The first should be `[[2, 1], [1, 2]]`

I don't think so. The `Compositions` code explicitly adds the length of the `inner` argument as minimal length. I didn't change this.



---

archive/issue_comments_236047.json:
```json
{
    "body": "Changing priority from major to blocker.",
    "created_at": "2015-03-15T15:31:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236047",
    "user": "https://github.com/jdemeyer"
}
```

Changing priority from major to blocker.



---

archive/issue_comments_236048.json:
```json
{
    "body": "Setting to blocker status since either #17920 or #17956 should be fixed.",
    "created_at": "2015-03-15T15:31:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236048",
    "user": "https://github.com/jdemeyer"
}
```

Setting to blocker status since either #17920 or #17956 should be fixed.



---

archive/issue_comments_236049.json:
```json
{
    "body": "Replying to [comment:27 tscrim]:\n> The first should be `[[2, 1], [1, 2]]` since the `inner` (or `outer`) are not related to the min or max lengths.\n\n\nTo clarify: you might be confusing with the `floor` and `ceiling` arguments of `IntegerListsLex`. Those do not have any effect on the length, but `inner`/`outer` *do* add lower/upper bounds to the length. With both the existing code as well as with my code, we have for example\n\n```\nsage: Compositions(3, inner=[1,1,1]).list()\n[[1, 1, 1]]\n```",
    "created_at": "2015-03-15T15:35:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236049",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:27 tscrim]:
> The first should be `[[2, 1], [1, 2]]` since the `inner` (or `outer`) are not related to the min or max lengths.


To clarify: you might be confusing with the `floor` and `ceiling` arguments of `IntegerListsLex`. Those do not have any effect on the length, but `inner`/`outer` *do* add lower/upper bounds to the length. With both the existing code as well as with my code, we have for example

```
sage: Compositions(3, inner=[1,1,1]).list()
[[1, 1, 1]]
```



---

archive/issue_comments_236050.json:
```json
{
    "body": "On the ordering, from the title of the class, the output should be in lexicographical order. Moreover, since these are `EnumeratedSets`, the change in the ordering could lead to subtle changes that breaks people's code.\n\n`Compositions` also does a similar thing with the max length and `outer`, so I agree that those should be empty. However IMO these tests should be in `Compositions`.\n\n`@`vdelecroix It's mostly correct and there is a lot of code which depends on this being fast. Minimal slowdowns are okay (IMO), but significant slowdowns are unacceptable.",
    "created_at": "2015-03-15T15:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236050",
    "user": "https://github.com/tscrim"
}
```

On the ordering, from the title of the class, the output should be in lexicographical order. Moreover, since these are `EnumeratedSets`, the change in the ordering could lead to subtle changes that breaks people's code.

`Compositions` also does a similar thing with the max length and `outer`, so I agree that those should be empty. However IMO these tests should be in `Compositions`.

`@`vdelecroix It's mostly correct and there is a lot of code which depends on this being fast. Minimal slowdowns are okay (IMO), but significant slowdowns are unacceptable.



---

archive/issue_comments_236051.json:
```json
{
    "body": "> On the ordering, from the title of the class, the output should be in lexicographical order. Moreover, since these are `EnumeratedSets`, the change in the ordering could lead to subtle changes that breaks people's code.\n\n\nWe can sort it before returning it I guess.\n\n> `@`vdelecroix It's mostly correct\n\n\nJeroen compiled many related bugs in the description of #17548.\n\n> Minimal slowdowns are okay (IMO), but significant slowdowns are unacceptable.\n\n\nSignificant slowdown can be a problem, that's for sure. If they turn out to be our only way to have a code which does not return wrong results, however, we will learn to live with them.\n\nNathann",
    "created_at": "2015-03-15T15:42:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236051",
    "user": "https://github.com/nathanncohen"
}
```

> On the ordering, from the title of the class, the output should be in lexicographical order. Moreover, since these are `EnumeratedSets`, the change in the ordering could lead to subtle changes that breaks people's code.


We can sort it before returning it I guess.

> `@`vdelecroix It's mostly correct


Jeroen compiled many related bugs in the description of #17548.

> Minimal slowdowns are okay (IMO), but significant slowdowns are unacceptable.


Significant slowdown can be a problem, that's for sure. If they turn out to be our only way to have a code which does not return wrong results, however, we will learn to live with them.

Nathann



---

archive/issue_comments_236052.json:
```json
{
    "body": "I think it is great that Jeroen implemented this to get the correct results! Of course we do want fast code at the end.\n\nAs I mentioned on sage-devel, the order of lists of tableaux does not matter very much.\n\nAs Travis mentioned, there might be some subtle places where the order matters. One example that comes to mind is that the representations of S_n and characters are returned as matrices with rows and columns indexed by integers instead of partitions. So if the order of partitions changes, the interpretation of the results might change!",
    "created_at": "2015-03-15T15:45:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236052",
    "user": "https://github.com/anneschilling"
}
```

I think it is great that Jeroen implemented this to get the correct results! Of course we do want fast code at the end.

As I mentioned on sage-devel, the order of lists of tableaux does not matter very much.

As Travis mentioned, there might be some subtle places where the order matters. One example that comes to mind is that the representations of S_n and characters are returned as matrices with rows and columns indexed by integers instead of partitions. So if the order of partitions changes, the interpretation of the results might change!



---

archive/issue_comments_236053.json:
```json
{
    "body": "Replying to [comment:33 tscrim]:\n> On the ordering, from the title of the class, the output should be in lexicographical order.\n\nThe name is now `IntegerLists` and I do provide `IntegerListsLex` for \"backwards compatibility\" which does sort.\n\nSince the documentation of neither `Partitions` nor `Compositions` says anything about the order, I think it's allowed to change the order.",
    "created_at": "2015-03-15T15:47:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236053",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:33 tscrim]:
> On the ordering, from the title of the class, the output should be in lexicographical order.

The name is now `IntegerLists` and I do provide `IntegerListsLex` for "backwards compatibility" which does sort.

Since the documentation of neither `Partitions` nor `Compositions` says anything about the order, I think it's allowed to change the order.



---

archive/issue_comments_236054.json:
```json
{
    "body": "About the speed: if you manage to fix all existing bugs in the `IntegerListsLex` code, you can again use that implementation for `Compositions` and `Partitions`. It's probably good to have two indepdendent implementations anyway.\n\nEven better would of course be that somebody speeds up `Polyhedron().integral_points()` which would benefit everybody using polyhedra.",
    "created_at": "2015-03-15T15:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236054",
    "user": "https://github.com/jdemeyer"
}
```

About the speed: if you manage to fix all existing bugs in the `IntegerListsLex` code, you can again use that implementation for `Compositions` and `Partitions`. It's probably good to have two indepdendent implementations anyway.

Even better would of course be that somebody speeds up `Polyhedron().integral_points()` which would benefit everybody using polyhedra.



---

archive/issue_comments_236055.json:
```json
{
    "body": "Dear Jeroen,\n\nThanks a lot for taking action! It's definitely a good thing to have a\ngood connection between ``IntegerListLex`` and ``Polyhedron``, as\nthere is some non trivial overlap. The main differences is that\n``IntegerListLex`` was specifically designed for allowing for\n(essentially) Constant Amortized Time lexicographic Iteration in\nalmost constant memory, which is an important feature.\n\nSo I can see a work path along the following lines:\n\n- Get this ticket in to have a robust implementation of list\n\n- Completely rewrite the current ``IntegerListLex`` iterator to be\n  robust (it's definitely possible); keep the Polyhedron\n  implementation for testing purposes as well as for counting, ...\n\n- Optimize the iterator (Cythonization, using ClonableIntArray, ...).\n\nPlease do not change the enumeration order, at least as default: quite\nsome code depends on it (I agree, this should be made explicit in the\ndocumentation). The proposed generalizations (n in a range, negative\nentries) are fine since the iterator could be made to handle them.\n\nCheers,\n                       Nicolas",
    "created_at": "2015-03-16T05:10:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236055",
    "user": "https://github.com/nthiery"
}
```

Dear Jeroen,

Thanks a lot for taking action! It's definitely a good thing to have a
good connection between ``IntegerListLex`` and ``Polyhedron``, as
there is some non trivial overlap. The main differences is that
``IntegerListLex`` was specifically designed for allowing for
(essentially) Constant Amortized Time lexicographic Iteration in
almost constant memory, which is an important feature.

So I can see a work path along the following lines:

- Get this ticket in to have a robust implementation of list

- Completely rewrite the current ``IntegerListLex`` iterator to be
  robust (it's definitely possible); keep the Polyhedron
  implementation for testing purposes as well as for counting, ...

- Optimize the iterator (Cythonization, using ClonableIntArray, ...).

Please do not change the enumeration order, at least as default: quite
some code depends on it (I agree, this should be made explicit in the
documentation). The proposed generalizations (n in a range, negative
entries) are fine since the iterator could be made to handle them.

Cheers,
                       Nicolas



---

archive/issue_comments_236056.json:
```json
{
    "body": "Replying to [comment:39 nthiery]:\n> Please do not change the enumeration order, at least as default\n\nI disagree with this: the default should be \"do not sort, return stuff in the fastest possible way\". Sorting an iterator is very expensive and should only be done if really needed.\n\n> quite some code depends on it\n\nIs that really true? The only doctest failures that I saw where \"obvious\" failures where some list order changed, I didn't see anything subtle.",
    "created_at": "2015-03-16T07:30:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236056",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:39 nthiery]:
> Please do not change the enumeration order, at least as default

I disagree with this: the default should be "do not sort, return stuff in the fastest possible way". Sorting an iterator is very expensive and should only be done if really needed.

> quite some code depends on it

Is that really true? The only doctest failures that I saw where "obvious" failures where some list order changed, I didn't see anything subtle.



---

archive/issue_comments_236057.json:
```json
{
    "body": "Replying to [comment:39 nthiery]:\n> keep the Polyhedron implementation for testing purposes as well as for counting, ...\n\n\nI'm not sure about the counting... I guess a well-written Cython implementation of `IntegerListsLex` will usually be faster than the current polyhedra code. Profiling shows that a lot of time is spent in just *constructing* the polyhedra (if there are not so many points, enumerating them takes a lot less time than constructing the polyhedron in the first place).",
    "created_at": "2015-03-16T08:55:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236057",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:39 nthiery]:
> keep the Polyhedron implementation for testing purposes as well as for counting, ...


I'm not sure about the counting... I guess a well-written Cython implementation of `IntegerListsLex` will usually be faster than the current polyhedra code. Profiling shows that a lot of time is spent in just *constructing* the polyhedra (if there are not so many points, enumerating them takes a lot less time than constructing the polyhedron in the first place).



---

archive/issue_comments_236058.json:
```json
{
    "body": "Hello,\n\n> I'm not sure about the counting... I guess a well-written Cython implementation of `IntegerListsLex` will usually be faster than the current polyhedra code.\n\n\nTrue. This being said, your polyhedron code may very well be 'all we can do' to implement this feature while handling all possible combinations of parameters.\n\n> Profiling shows that a lot of time is spent in just *constructing* the polyhedra\n\n\nTrue. Do you have any idea where that comes from ? I had similar troubles with the Poset constructor (related to memory usage).\n\nNathann",
    "created_at": "2015-03-16T09:15:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236058",
    "user": "https://github.com/nathanncohen"
}
```

Hello,

> I'm not sure about the counting... I guess a well-written Cython implementation of `IntegerListsLex` will usually be faster than the current polyhedra code.


True. This being said, your polyhedron code may very well be 'all we can do' to implement this feature while handling all possible combinations of parameters.

> Profiling shows that a lot of time is spent in just *constructing* the polyhedra


True. Do you have any idea where that comes from ? I had similar troubles with the Poset constructor (related to memory usage).

Nathann



---

archive/issue_comments_236059.json:
```json
{
    "body": "Replying to [comment:42 ncohen]:\n> > Profiling shows that a lot of time is spent in just *constructing* the polyhedra\n\n> \n> True. Do you have any idea where that comes from ?\n  \nIt's just PPL.\n\nInterestingly, arithmetic with infinity also shows up quite high in the profiling reports (up to 10% of the time), so optimizing `src/sage/rings/infinity.py` will also give some speedup.",
    "created_at": "2015-03-16T09:22:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236059",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:42 ncohen]:
> > Profiling shows that a lot of time is spent in just *constructing* the polyhedra

> 
> True. Do you have any idea where that comes from ?
  
It's just PPL.

Interestingly, arithmetic with infinity also shows up quite high in the profiling reports (up to 10% of the time), so optimizing `src/sage/rings/infinity.py` will also give some speedup.



---

archive/issue_comments_236060.json:
```json
{
    "body": "> Interestingly, arithmetic with infinity also shows up quite high in the profiling reports (up to 10% of the time), so optimizing `src/sage/rings/infinity.py` will also give some speedup.\n\n\nAahahah. Yaeh, Vincent has been fighting a lot with some abstractions we have, which makes code run *much* slower. For `+oo` he advises to solve the problem by using float(\"inf\") instead of Infinity. It is *MUCH* faster.\n\nAt some point he got some crazy somewhere by adding 'from math import sqrt' in a module to overwrite Sage's sqrt function.\n\nNathann",
    "created_at": "2015-03-16T09:25:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236060",
    "user": "https://github.com/nathanncohen"
}
```

> Interestingly, arithmetic with infinity also shows up quite high in the profiling reports (up to 10% of the time), so optimizing `src/sage/rings/infinity.py` will also give some speedup.


Aahahah. Yaeh, Vincent has been fighting a lot with some abstractions we have, which makes code run *much* slower. For `+oo` he advises to solve the problem by using float("inf") instead of Infinity. It is *MUCH* faster.

At some point he got some crazy somewhere by adding 'from math import sqrt' in a module to overwrite Sage's sqrt function.

Nathann



---

archive/issue_comments_236061.json:
```json
{
    "body": "Replying to [comment:44 ncohen]:\n> > Interestingly, arithmetic with infinity also shows up quite high in the profiling reports (up to 10% of the time), so optimizing `src/sage/rings/infinity.py` will also give some speedup.\n\n> \n> Aahahah. Yaeh, Vincent has been fighting a lot with some abstractions we have, which makes code run *much* slower. For `+oo` he advises to solve the problem by using float(\"inf\") instead of Infinity.\n\n\nIn general, I don't like the \"X is slow, therefore let's not use X\" mentality. My idea is: \"let's use X and then optimize X\".",
    "created_at": "2015-03-16T09:29:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236061",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:44 ncohen]:
> > Interestingly, arithmetic with infinity also shows up quite high in the profiling reports (up to 10% of the time), so optimizing `src/sage/rings/infinity.py` will also give some speedup.

> 
> Aahahah. Yaeh, Vincent has been fighting a lot with some abstractions we have, which makes code run *much* slower. For `+oo` he advises to solve the problem by using float("inf") instead of Infinity.


In general, I don't like the "X is slow, therefore let's not use X" mentality. My idea is: "let's use X and then optimize X".



---

archive/issue_comments_236062.json:
```json
{
    "body": "Replying to [comment:45 jdemeyer]:\n> > > Interestingly, arithmetic with infinity also shows up quite high in the profiling reports (up to 10% of the time), so optimizing `src/sage/rings/infinity.py` will also give some speedup.\n\n> > \n> > Aahahah. Yaeh, Vincent has been fighting a lot with some abstractions we have, which makes code run *much* slower. For `+oo` he advises to solve the problem by using float(\"inf\") instead of Infinity.\n  \n> \n> In general, I don't like the \"X is slow, therefore let's not use X\" mentality. My idea is: \"let's use X and then optimize X\".\n\n\nOn a tangential note: if someone makes major changes to the infinity rings, please consider adding a `NaN` element to them.",
    "created_at": "2015-03-16T10:08:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236062",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:45 jdemeyer]:
> > > Interestingly, arithmetic with infinity also shows up quite high in the profiling reports (up to 10% of the time), so optimizing `src/sage/rings/infinity.py` will also give some speedup.

> > 
> > Aahahah. Yaeh, Vincent has been fighting a lot with some abstractions we have, which makes code run *much* slower. For `+oo` he advises to solve the problem by using float("inf") instead of Infinity.
  
> 
> In general, I don't like the "X is slow, therefore let's not use X" mentality. My idea is: "let's use X and then optimize X".


On a tangential note: if someone makes major changes to the infinity rings, please consider adding a `NaN` element to them.



---

archive/issue_comments_236063.json:
```json
{
    "body": "> In general, I don't like the \"X is slow, therefore let's not use X\" mentality. My idea is: \"let's use X and then optimize X\".\n\n\nWell, for the sqrt problem we were only computing on floats, and sqrt(5) in Sage is not a float. Having this symbolic value in the code we compared it with floats and this had a cost we had no reason to pay, so `from math import sqrt` made total sense, and there was nothing in Sage's sqrt that we could have wanted to change.\n\nAs per Sage's Infinity... Well, it also seems to have been designed with a different aim in mind. I usually want speed, and I do not want to pay for pointless abstraction. In infinity.py you will find parents, elements, rings and generators, while the feature I need is already provided by the constant LONG_MAX.\n\nThis Sage object is called 'infinity', but it turns out that one definition of \"infinity\" cannot cover all uses that we have for infinity on a computer. And I don't think that we could beat a single CPU instruction while dealing with parents and elements in a .py file.\n\nNathann",
    "created_at": "2015-03-16T10:40:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236063",
    "user": "https://github.com/nathanncohen"
}
```

> In general, I don't like the "X is slow, therefore let's not use X" mentality. My idea is: "let's use X and then optimize X".


Well, for the sqrt problem we were only computing on floats, and sqrt(5) in Sage is not a float. Having this symbolic value in the code we compared it with floats and this had a cost we had no reason to pay, so `from math import sqrt` made total sense, and there was nothing in Sage's sqrt that we could have wanted to change.

As per Sage's Infinity... Well, it also seems to have been designed with a different aim in mind. I usually want speed, and I do not want to pay for pointless abstraction. In infinity.py you will find parents, elements, rings and generators, while the feature I need is already provided by the constant LONG_MAX.

This Sage object is called 'infinity', but it turns out that one definition of "infinity" cannot cover all uses that we have for infinity on a computer. And I don't think that we could beat a single CPU instruction while dealing with parents and elements in a .py file.

Nathann



---

archive/issue_comments_236064.json:
```json
{
    "body": "Replying to [comment:47 ncohen]:\n> while the feature I need is already provided by the constant LONG_MAX.\n\nIn this case, we shouldn't aritificially restrict to `long`s:\n\n```\nsage: IntegerLists(10^100, max_length=1).list()\n[[10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]]\n```\n\n> This Sage object is called 'infinity', but it turns out that one definition of \"infinity\" cannot cover all uses that we have for infinity on a computer.\n\nI think we can have one definition which covers all uses *within Sage*. There is nothing fundamentally wrong with `Infinity`, it's just slow.",
    "created_at": "2015-03-16T11:50:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236064",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:47 ncohen]:
> while the feature I need is already provided by the constant LONG_MAX.

In this case, we shouldn't aritificially restrict to `long`s:

```
sage: IntegerLists(10^100, max_length=1).list()
[[10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]]
```

> This Sage object is called 'infinity', but it turns out that one definition of "infinity" cannot cover all uses that we have for infinity on a computer.

I think we can have one definition which covers all uses *within Sage*. There is nothing fundamentally wrong with `Infinity`, it's just slow.



---

archive/issue_comments_236065.json:
```json
{
    "body": "Note the difference of a factor 20 between the following:\n\n```\nsage: b = ZZ(1); a = Infinity; timeit('a < b', repeat=20, number=10^4)\n10000 loops, best of 20: 11.7 \u00b5s per loop\nsage: b = ZZ(1); a = QQ(2); timeit('a < b', repeat=20, number=10^4)\n10000 loops, best of 20: 681 ns per loop\n```\nA proper Cython implementation of `Infinity` should match the speed for `QQ`.",
    "created_at": "2015-03-16T11:54:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236065",
    "user": "https://github.com/jdemeyer"
}
```

Note the difference of a factor 20 between the following:

```
sage: b = ZZ(1); a = Infinity; timeit('a < b', repeat=20, number=10^4)
10000 loops, best of 20: 11.7 µs per loop
sage: b = ZZ(1); a = QQ(2); timeit('a < b', repeat=20, number=10^4)
10000 loops, best of 20: 681 ns per loop
```
A proper Cython implementation of `Infinity` should match the speed for `QQ`.



---

archive/issue_comments_236066.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-16T13:53:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236066",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_236067.json:
```json
{
    "body": "Replying to [comment:33 tscrim]:\n> However IMO these tests should be in `Compositions`.\n\nDone",
    "created_at": "2015-03-16T13:54:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236067",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:33 tscrim]:
> However IMO these tests should be in `Compositions`.

Done



---

archive/issue_comments_236068.json:
```json
{
    "body": "Replying to [comment:40 jdemeyer]:\n> Replying to [comment:39 nthiery]:\n> > Please do not change the enumeration order, at least as default\n\n> I disagree with this: the default should be \"do not sort, return stuff in the fastest possible way\". Sorting an iterator is very expensive and should only be done if really needed.\n\nFor IntegerList itself, any default is fine, and sorting is certainly\nvery bad. But for Partitions, Compositions, ... users are really\nexpecting lexicographic order. Besides, this is only a temporary\nsolution, and we will switch back to lexicographic once we have a\nproper implementation of IntegerListLex.\n\n> Is that really true? The only doctest failures that I saw where\n> \"obvious\" failures where some list order changed, I didn't see\n> anything subtle.\n\n\nThat's a point indeed; my feeling is that we have been lucky, although\nit could be that some changes w.r.t. MuPAD-Combinat makes the code\nless dependent on that feature.  I am worried by user's personal code\nout there. Well, if you are willing to help those guys ...\n\nCheers,\n                                    Nicolas",
    "created_at": "2015-03-16T14:30:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236068",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:40 jdemeyer]:
> Replying to [comment:39 nthiery]:
> > Please do not change the enumeration order, at least as default

> I disagree with this: the default should be "do not sort, return stuff in the fastest possible way". Sorting an iterator is very expensive and should only be done if really needed.

For IntegerList itself, any default is fine, and sorting is certainly
very bad. But for Partitions, Compositions, ... users are really
expecting lexicographic order. Besides, this is only a temporary
solution, and we will switch back to lexicographic once we have a
proper implementation of IntegerListLex.

> Is that really true? The only doctest failures that I saw where
> "obvious" failures where some list order changed, I didn't see
> anything subtle.


That's a point indeed; my feeling is that we have been lucky, although
it could be that some changes w.r.t. MuPAD-Combinat makes the code
less dependent on that feature.  I am worried by user's personal code
out there. Well, if you are willing to help those guys ...

Cheers,
                                    Nicolas



---

archive/issue_comments_236069.json:
```json
{
    "body": "Replying to [comment:41 jdemeyer]:\n> I'm not sure about the counting... I guess a well-written Cython\n> implementation of `IntegerListsLex` will usually be faster than the\n> current polyhedra code. Profiling shows that a lot of time is spent in\n> just *constructing* the polyhedra (if there are not so many points,\n> enumerating them takes a lot less time than constructing the\n> polyhedron in the first place).\n\n\nAgreed, especially if we further go parallel: counting through\npolyhedral methods only becomes relevant for relatively large\npolyhedron. But this would be a very useful feature. So count\nwould eventually have some threshold to choose between the\ntwo methods. \n\nBy the way: we don't yet use Barvinok-like algorithms for counting\n(e.g. through LattE), or do we? This could make a difference too.\n\nCheers,\n                               Nicolas",
    "created_at": "2015-03-16T14:36:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236069",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:41 jdemeyer]:
> I'm not sure about the counting... I guess a well-written Cython
> implementation of `IntegerListsLex` will usually be faster than the
> current polyhedra code. Profiling shows that a lot of time is spent in
> just *constructing* the polyhedra (if there are not so many points,
> enumerating them takes a lot less time than constructing the
> polyhedron in the first place).


Agreed, especially if we further go parallel: counting through
polyhedral methods only becomes relevant for relatively large
polyhedron. But this would be a very useful feature. So count
would eventually have some threshold to choose between the
two methods. 

By the way: we don't yet use Barvinok-like algorithms for counting
(e.g. through LattE), or do we? This could make a difference too.

Cheers,
                               Nicolas



---

archive/issue_comments_236070.json:
```json
{
    "body": "Replying to [comment:54 nthiery]:\n> By the way: we don't yet use Barvinok-like algorithms for counting\n> (e.g. through LattE), or do we? This could make a difference too.\n\n\nI just read the first paragraph of the LattE manual and it does **exactly** what we need for counting:\n\n```\n1.1    What is LattE?\n\nThe name \u201cLattE\u201d is an abbreviation for \u201cLattice point Enumeration.\u201d LattE\nwas developed in 2001 to count lattice points contained in convex polyhedra\ndefined by linear equations and inequalities with integer coefficients. The poly-\nhedra can be of any (reasonably small) dimension.\n```",
    "created_at": "2015-03-16T14:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236070",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:54 nthiery]:
> By the way: we don't yet use Barvinok-like algorithms for counting
> (e.g. through LattE), or do we? This could make a difference too.


I just read the first paragraph of the LattE manual and it does **exactly** what we need for counting:

```
1.1    What is LattE?

The name “LattE” is an abbreviation for “Lattice point Enumeration.” LattE
was developed in 2001 to count lattice points contained in convex polyhedra
defined by linear equations and inequalities with integer coefficients. The poly-
hedra can be of any (reasonably small) dimension.
```



---

archive/issue_comments_236071.json:
```json
{
    "body": "Replying to [comment:53 nthiery]:\n> But for Partitions, Compositions, ... users are really expecting lexicographic order.\n\nWell, certainly for `Compositions`, the current order is not defined:\n\n```\nsage: Compositions(2).list()\n[[1, 1], [2]]\nsage: Compositions(2, max_slope=0).list()\n[[2], [1, 1]]\n```",
    "created_at": "2015-03-16T14:55:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236071",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:53 nthiery]:
> But for Partitions, Compositions, ... users are really expecting lexicographic order.

Well, certainly for `Compositions`, the current order is not defined:

```
sage: Compositions(2).list()
[[1, 1], [2]]
sage: Compositions(2, max_slope=0).list()
[[2], [1, 1]]
```



---

archive/issue_comments_236072.json:
```json
{
    "body": "http://trac.sagemath.org/ticket/17529#comment:11 (we already have a LattE package)",
    "created_at": "2015-03-16T14:56:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236072",
    "user": "https://github.com/nathanncohen"
}
```

http://trac.sagemath.org/ticket/17529#comment:11 (we already have a LattE package)



---

archive/issue_comments_236073.json:
```json
{
    "body": "Replying to [comment:55 jdemeyer]:\n> I just read the first paragraph of the LattE manual and it does **exactly** what we need for counting:\n\n\nYes indeed! See also #15180.\n\nBtw: in case this could be useful, the developers are in Davis where I\ncurrently am for the upcoming Sage Days 64.\n\nCheers,\n                             Nicolas",
    "created_at": "2015-03-16T14:58:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236073",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:55 jdemeyer]:
> I just read the first paragraph of the LattE manual and it does **exactly** what we need for counting:


Yes indeed! See also #15180.

Btw: in case this could be useful, the developers are in Davis where I
currently am for the upcoming Sage Days 64.

Cheers,
                             Nicolas



---

archive/issue_comments_236074.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-16T14:58:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236074",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_236075.json:
```json
{
    "body": "FYI - `float('inf')` works quite well as a good and fast substitute for `Infinity` (which is why it is used in the current `IntegerListsLex`).",
    "created_at": "2015-03-16T15:09:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236075",
    "user": "https://github.com/tscrim"
}
```

FYI - `float('inf')` works quite well as a good and fast substitute for `Infinity` (which is why it is used in the current `IntegerListsLex`).



---

archive/issue_comments_236076.json:
```json
{
    "body": "Replying to [comment:53 nthiery]:\n> But for Partitions users are really expecting lexicographic order.\n\nFor which applications does this really matter?\n\nI know that's how partitions are traditionally written down and how things are done in Sage historically. But I don't think that's enough reason to not change it, especially given the fact that the documentation doesn't say anything about the order. Any order of the list of partitions is a good answer mathematically.",
    "created_at": "2015-03-16T15:13:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236076",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:53 nthiery]:
> But for Partitions users are really expecting lexicographic order.

For which applications does this really matter?

I know that's how partitions are traditionally written down and how things are done in Sage historically. But I don't think that's enough reason to not change it, especially given the fact that the documentation doesn't say anything about the order. Any order of the list of partitions is a good answer mathematically.



---

archive/issue_comments_236077.json:
```json
{
    "body": "I'm worried this could lead to errors being raised when trying to convert between different bases of the symmetric functions (which are indexed by partitions). IIRC the code relies on some of the (graded) transition matrices being upper triangular, which requires the order be compatible with dominance ordering.",
    "created_at": "2015-03-16T15:17:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236077",
    "user": "https://github.com/tscrim"
}
```

I'm worried this could lead to errors being raised when trying to convert between different bases of the symmetric functions (which are indexed by partitions). IIRC the code relies on some of the (graded) transition matrices being upper triangular, which requires the order be compatible with dominance ordering.



---

archive/issue_comments_236078.json:
```json
{
    "body": "Replying to [comment:62 tscrim]:\n> I'm worried this could lead to errors being raised when trying to convert between different bases of the symmetric functions (which are indexed by partitions). IIRC the code relies on some of the (graded) transition matrices being upper triangular, which requires the order be compatible with dominance ordering.\n\n\nTo be honest, I don't know what you mean mathematically. But, like I said, the fact that there are no strange doctest failures shows that the issue cannot be so serious.\n\nAnd in the cases where the order really matters, I think those places should simply explicitly sort or use `IntegerListsLex`. Slowing down all of `Paritions()` just because one or two applications require it seems stupid.",
    "created_at": "2015-03-16T15:26:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236078",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:62 tscrim]:
> I'm worried this could lead to errors being raised when trying to convert between different bases of the symmetric functions (which are indexed by partitions). IIRC the code relies on some of the (graded) transition matrices being upper triangular, which requires the order be compatible with dominance ordering.


To be honest, I don't know what you mean mathematically. But, like I said, the fact that there are no strange doctest failures shows that the issue cannot be so serious.

And in the cases where the order really matters, I think those places should simply explicitly sort or use `IntegerListsLex`. Slowing down all of `Paritions()` just because one or two applications require it seems stupid.



---

archive/issue_comments_236079.json:
```json
{
    "body": "> But, like I said, the fact that there are no strange doctest failures shows that the issue cannot be so serious.\n\n\nThis might be an issue though\n\n```\nsage: S=SymmetricGroup(3)\nsage: S.character_table()\n[ 1 -1  1]\n[ 2  0 -1]\n[ 1  1  1]\nsage: type(S.character_table())\n<type 'sage.matrix.matrix_cyclo_dense.Matrix_cyclo_dense'>\n```\nThe character table should really be indexed by partitions (or conjugacy classes of S_n).\nSo the meaning of the matrix changes if the order of the list of partitions changes.",
    "created_at": "2015-03-16T19:01:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236079",
    "user": "https://github.com/anneschilling"
}
```

> But, like I said, the fact that there are no strange doctest failures shows that the issue cannot be so serious.


This might be an issue though

```
sage: S=SymmetricGroup(3)
sage: S.character_table()
[ 1 -1  1]
[ 2  0 -1]
[ 1  1  1]
sage: type(S.character_table())
<type 'sage.matrix.matrix_cyclo_dense.Matrix_cyclo_dense'>
```
The character table should really be indexed by partitions (or conjugacy classes of S_n).
So the meaning of the matrix changes if the order of the list of partitions changes.



---

archive/issue_comments_236080.json:
```json
{
    "body": "Replying to [comment:64 aschilling]:\n> This might be an issue though\n> \n> ```\n> sage: S=SymmetricGroup(3)\n> sage: S.character_table()\n> [ 1 -1  1]\n> [ 2  0 -1]\n> [ 1  1  1]\n> sage: type(S.character_table())\n> <type 'sage.matrix.matrix_cyclo_dense.Matrix_cyclo_dense'>\n> ```\n> The character table should really be indexed by partitions (or conjugacy classes of S_n).\n> So the meaning of the matrix changes if the order of the list of partitions changes.\n\n\nOkay, so the meaning of the matrix changes. There is nothing wrong with output *changing* as long as things stay mathematically correct and internally consistent.",
    "created_at": "2015-03-16T19:31:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236080",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:64 aschilling]:
> This might be an issue though
> 
> ```
> sage: S=SymmetricGroup(3)
> sage: S.character_table()
> [ 1 -1  1]
> [ 2  0 -1]
> [ 1  1  1]
> sage: type(S.character_table())
> <type 'sage.matrix.matrix_cyclo_dense.Matrix_cyclo_dense'>
> ```
> The character table should really be indexed by partitions (or conjugacy classes of S_n).
> So the meaning of the matrix changes if the order of the list of partitions changes.


Okay, so the meaning of the matrix changes. There is nothing wrong with output *changing* as long as things stay mathematically correct and internally consistent.



---

archive/issue_comments_236081.json:
```json
{
    "body": "Replying to [comment:55 jdemeyer]:\n> Replying to [comment:54 nthiery]:\n> > By the way: we don't yet use Barvinok-like algorithms for counting\n> > (e.g. through LattE), or do we? This could make a difference too.\n  \n> \n> I just read the first paragraph of the LattE manual and it does **exactly** what we need for counting:\n\n\nMoreover, counting the points is faster than enumerating the points; there could be exponentially many points to count, but still the number of them is only polynomial in the input size, for fixed dimension, and LattE provides a truly polynomial-time procedure for this counting.",
    "created_at": "2015-03-18T10:13:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236081",
    "user": "https://github.com/dimpase"
}
```

Replying to [comment:55 jdemeyer]:
> Replying to [comment:54 nthiery]:
> > By the way: we don't yet use Barvinok-like algorithms for counting
> > (e.g. through LattE), or do we? This could make a difference too.
  
> 
> I just read the first paragraph of the LattE manual and it does **exactly** what we need for counting:


Moreover, counting the points is faster than enumerating the points; there could be exponentially many points to count, but still the number of them is only polynomial in the input size, for fixed dimension, and LattE provides a truly polynomial-time procedure for this counting.



---

archive/issue_comments_236082.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-03-25T20:01:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236082",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_236083.json:
```json
{
    "body": "a badly formated doc in composition.py\n\n```\n     TESTS::\n \n+    Check that :trac:`17548` is fixed::\n```",
    "created_at": "2015-03-25T20:01:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236083",
    "user": "https://github.com/fchapoton"
}
```

a badly formated doc in composition.py

```
     TESTS::
 
+    Check that :trac:`17548` is fixed::
```



---

archive/issue_comments_236084.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-25T22:34:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236084",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_236085.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-25T22:36:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236085",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_236086.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-03-25T22:37:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236086",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_236087.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-05T07:01:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236087",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_236088.json:
```json
{
    "body": "Whats your plan with the code here? It might be useful to check. Thoughts?",
    "created_at": "2015-04-12T11:24:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236088",
    "user": "https://github.com/vbraun"
}
```

Whats your plan with the code here? It might be useful to check. Thoughts?



---

archive/issue_comments_236089.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-04-12T11:24:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236089",
    "user": "https://github.com/vbraun"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_236090.json:
```json
{
    "body": "This code is useful as it works in more general context than the new `IntegerListsLex` as it allows entries in `ZZ` (instead of just `NN`) and when lex ordering doesn't hit every element in finite time. Plus I like alternative algorithms for testing, and this is faster in certain cases currently as well. I just need to find some time to review this.",
    "created_at": "2015-04-12T11:47:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236090",
    "user": "https://github.com/tscrim"
}
```

This code is useful as it works in more general context than the new `IntegerListsLex` as it allows entries in `ZZ` (instead of just `NN`) and when lex ordering doesn't hit every element in finite time. Plus I like alternative algorithms for testing, and this is faster in certain cases currently as well. I just need to find some time to review this.



---

archive/issue_comments_236091.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2015-04-12T11:47:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236091",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_236092.json:
```json
{
    "body": "Indeed, we want this code in Sage! I promised Jeroen I would rebase his code, and work on the review. This could be a good sprint for Sage Days 67. But yes this certainly is not a blocker anymore for 6.6.",
    "created_at": "2015-04-12T14:54:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236092",
    "user": "https://github.com/nthiery"
}
```

Indeed, we want this code in Sage! I promised Jeroen I would rebase his code, and work on the review. This could be a good sprint for Sage Days 67. But yes this certainly is not a blocker anymore for 6.6.



---

archive/issue_comments_236093.json:
```json
{
    "body": "Needs to be rebased in any case. I might also try to make it work in *all* cases of infinite iterator (currently, I still require that there are only finitely many lists of every given length).",
    "created_at": "2015-04-13T07:09:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236093",
    "user": "https://github.com/jdemeyer"
}
```

Needs to be rebased in any case. I might also try to make it work in *all* cases of infinite iterator (currently, I still require that there are only finitely many lists of every given length).



---

archive/issue_comments_236094.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-04-13T07:09:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236094",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_236095.json:
```json
{
    "body": "I would actually like to redesign `IntegerListsLex` and `IntegerLists_polyhedron` such that they share code: they could be the same class but with a different implementation for `__iter__` and `__contains__`.",
    "created_at": "2015-04-13T07:47:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236095",
    "user": "https://github.com/jdemeyer"
}
```

I would actually like to redesign `IntegerListsLex` and `IntegerLists_polyhedron` such that they share code: they could be the same class but with a different implementation for `__iter__` and `__contains__`.



---

archive/issue_comments_236096.json:
```json
{
    "body": "Replying to [comment:77 jdemeyer]:\n> I would actually like to redesign `IntegerListsLex` and `IntegerLists_polyhedron` such that they share code: they could be the same class but with a different implementation for `__iter__` and `__contains__`.\n\n\n+1\n\nwhy not several iterators on the same class? (with a reasonable one by default in `__iter__`).",
    "created_at": "2015-04-13T08:00:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236096",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:77 jdemeyer]:
> I would actually like to redesign `IntegerListsLex` and `IntegerLists_polyhedron` such that they share code: they could be the same class but with a different implementation for `__iter__` and `__contains__`.


+1

why not several iterators on the same class? (with a reasonable one by default in `__iter__`).



---

archive/issue_comments_236097.json:
```json
{
    "body": "Replying to [comment:78 vdelecroix]:\n> Replying to [comment:77 jdemeyer]:\n> > I would actually like to redesign `IntegerListsLex` and `IntegerLists_polyhedron` such that they share code: they could be the same class but with a different implementation for `__iter__` and `__contains__`.\n\n> \n> +1\n> \n> why not several iterators on the same class? (with a reasonable one by default in `__iter__`).\n\nWell, it will be something along those lines. But I haven't thought too much about the actual design.",
    "created_at": "2015-04-13T08:22:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236097",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:78 vdelecroix]:
> Replying to [comment:77 jdemeyer]:
> > I would actually like to redesign `IntegerListsLex` and `IntegerLists_polyhedron` such that they share code: they could be the same class but with a different implementation for `__iter__` and `__contains__`.

> 
> +1
> 
> why not several iterators on the same class? (with a reasonable one by default in `__iter__`).

Well, it will be something along those lines. But I haven't thought too much about the actual design.



---

archive/issue_comments_236098.json:
```json
{
    "body": "Replying to [comment:75 nthiery]:\n> I promised Jeroen I would rebase his code\n\nThanks for the offer, but that will not be needed (in any case, it's just merging with `-X theirs` essentially)",
    "created_at": "2015-04-13T08:46:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236098",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:75 nthiery]:
> I promised Jeroen I would rebase his code

Thanks for the offer, but that will not be needed (in any case, it's just merging with `-X theirs` essentially)



---

archive/issue_comments_236099.json:
```json
{
    "body": "Replying to [comment:79 jdemeyer]:\n> Replying to [comment:78 vdelecroix]:\n> > Replying to [comment:77 jdemeyer]:\n> > > I would actually like to redesign `IntegerListsLex` and `IntegerLists_polyhedron` such that they share code: they could be the same class but with a different implementation for `__iter__` and `__contains__`.\n\n> > \n> > +1\n> > \n> > why not several iterators on the same class? (with a reasonable one by default in `__iter__`).\n\n> Well, it will be something along those lines. But I haven't thought too much about the actual design.\n\n+1 to sharing code between the classes; in fact I had put a mental\nnote on doing this when I offered to do the merge :-)\n\nHaving a class that can handle any set of constraints, even if it does\nonly containment check, would be useful. We would need this in\nparticular to properly refactor integer vectors.\n\nI am not sure whether we want a single class, or two classes:\n\n```\nclass IntegerLists:\n    __iter__ -> __iter__ on the polyhedron\n\nclass IntegerListsLex(IntegerLists):\n```\n\nWith the second one having the additional specification that the\nenumeration shall be lexicographic.\n\nThoughts?\n\nCheers,\n                              Nicolas",
    "created_at": "2015-04-13T11:38:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17683",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17683#issuecomment-236099",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:79 jdemeyer]:
> Replying to [comment:78 vdelecroix]:
> > Replying to [comment:77 jdemeyer]:
> > > I would actually like to redesign `IntegerListsLex` and `IntegerLists_polyhedron` such that they share code: they could be the same class but with a different implementation for `__iter__` and `__contains__`.

> > 
> > +1
> > 
> > why not several iterators on the same class? (with a reasonable one by default in `__iter__`).

> Well, it will be something along those lines. But I haven't thought too much about the actual design.

+1 to sharing code between the classes; in fact I had put a mental
note on doing this when I offered to do the merge :-)

Having a class that can handle any set of constraints, even if it does
only containment check, would be useful. We would need this in
particular to properly refactor integer vectors.

I am not sure whether we want a single class, or two classes:

```
class IntegerLists:
    __iter__ -> __iter__ on the polyhedron

class IntegerListsLex(IntegerLists):
```

With the second one having the additional specification that the
enumeration shall be lexicographic.

Thoughts?

Cheers,
                              Nicolas
