# Issue 18248: Make function to generate *all* independent sets.

Issue created by migration from https://trac.sagemath.org/ticket/18485

Original creator: Rudi

Original creation time: 2015-05-24 10:11:21

Assignee: Rudi

CC:  chapoton vdelecroix

Currently the user can only enumerate all independent sets by calling Matroid.independent_r_sets repeatedly.  
An algorithm to compute all independent sets could be more efficient by taking into account that the independent sets are closed under taking subsets. 

I will write two versions of the algorithm, for Matroid and for BasisExchangeMatroid.




---

Comment by Rudi created at 2015-05-24 10:11:47

Changing component from PLEASE CHANGE to matroid theory.


---

Comment by Rudi created at 2015-05-24 10:11:47

Changing type from PLEASE CHANGE to enhancement.


---

Comment by ncohen created at 2015-05-24 14:32:12

I do not know what exactly you have in mind, but I remember from a conversation (on another ticket that I forgot) that we already needed it. You may also find in `sage.combinat.subsets_hereditary.subsets_with_hereditary_property` a function that "may" be a part of what you intend, though I do not know what exactly you want to optimize your function for.

Nathann


---

Comment by Rudi created at 2015-05-24 22:18:05

Hi Nathann,

I think you remember ticket #18183, on matroid polytopes. I saw that discussion the other day and I had to agree that it is an omission that we have no `.independent_sets()` method. 

I want to optimize the running time. Maybe using  `subsets_with_hereditary_property` is a good choice for the top class Matroids, I'll check it out. To improve upon `BasisExchangeMatroid.independent_r_sets()` I will have to work harder. Not sure even how much I can still squeeze out, we thoroughly optimized that one. But even if I cannot improve the running time, it will be good to have `.independent_sets()` in the interface.

Rudi


---

Comment by ncohen created at 2015-05-25 08:36:21

Hello !

> I think you remember ticket #18183, on matroid polytopes. I saw that discussion the other day and I had to agree that it is an omission that we have no `.independent_sets()` method. 

Yepyep. Such a function will surely be useful.

> I want to optimize the running time. Maybe using  `subsets_with_hereditary_property` is a good choice for the top class Matroids, I'll check it out.

I wrote it for situations when the function that checks if a set is a base is very slow. It may not be very efficient in other cases, though it definitely uses the information that the property is hereditary.

Good luck `;-)`

Nathann


---

Comment by Rudi created at 2015-05-25 21:43:25

Right now this ticket #18485 fails to build (sage -b) when I check it out on my fresh sage 6.7. The master can be rebuilt afterwards, but it takes quite a while.  This suggests that this ticket carries major changes, but clearly that is not the case. I have not added any code since creating it yesterday afternoon, it's empty! I'm baffled. What could possibly be wrong here?


---

Comment by ncohen created at 2015-05-26 06:00:06

> Right now this ticket #18485 fails to build (sage -b) when I check it out on my fresh sage 6.7.

There is no branch attached to this ticket.

Nathann


---

Comment by Rudi created at 2015-05-26 06:57:33

Replying to [comment:7 ncohen]:
> 
> There is no branch attached to this ticket.
Exactly. It does not get much stranger than this. I `git trac checkout 18485`, this empty branch, do `sage -b`, and boom. Have you tried it out?


---

Comment by Rudi created at 2015-05-30 17:30:20

The new function seems to work just fine. 

```
sage: M=matroids.named_matroids.Q10()
sage: len(M.independent_sets())==sum([len(M.independent_r_sets(r)) for r in range(M.full_rank()+1)])
True
sage: timeit("M.independent_sets()")
625 loops, best of 3: 467 µs per loop
sage: timeit("[M.independent_r_sets(r) for r in range(M.full_rank()+1)]")
625 loops, best of 3: 674 µs per loop
```

Other matroids give the same picture. There is some speedup (30-40%), but nothing exceptional. 

Q10 is a BasisExchangeMatroid, so independent_sets() and independent_r_sets() above use bitsets, and that is where some of the speed comes from. 

I tried out Nathann's idea to use the hereditary-set code:

```
sage:def independent_sets_iterator(M):
    from sage.combinat.subsets_hereditary import subsets_with_hereditary_property
    for x in subsets_with_hereditary_property(M.is_independent,M.groundset()):
        yield x
sage: timeit("list(independent_sets_iterator(M))")
125 loops, best of 3: 5.17 ms per loop
```

For a fair comparison, I should force the use Matroid.independent_sets() instead of BasisExchangeMatroid.independent_sets(), so that you're not just looking at the advantage of using bitsets.

```
sage: from sage.matroids.matroid import Matroid
sage: timeit("Matroid.independent_sets(M)")
625 loops, best of 3: 1.17 ms per loop
```


I will go and modify the code for M.independence_matroid_polytope().The code will perhaps be more straightforward, but it will not matter much for the efficiency. With the same matroid Q10, you get:

```
sage: timeit("M.independence_matroid_polytope()")
5 loops, best of 3: 109 ms per loop
```

So the amount of time spent on generating independent sets is already less than 1%.

A somewhat bigger matroid is the binary Golay code on 24 elements. The timings for that matroid are as follows:

```
sage: M=matroids.named_matroids.ExtendedBinaryGolayCode()
sage: len(M.independent_sets())
7898547
sage: timeit("M.independent_sets()")
5 loops, best of 3: 2.29 s per loop
sage: timeit("[M.independent_r_sets(r) for r in range(M.full_rank()+1)]")
5 loops, best of 3: 3.95 s per loop
sage: timeit("list(independent_sets_iterator(M))")
5 loops, best of 3: 92.1 s per loop
timeit("Matroid.independent_sets(M)")
5 loops, best of 3: 40 s per loop
}}} 
----
New commits:


---

Comment by git created at 2015-05-30 17:35:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by Rudi created at 2015-05-30 17:36:26

Changing status from new to needs_review.


---

Comment by git created at 2015-06-07 14:29:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by Rudi created at 2015-06-07 14:33:42

The patchbot could not merge, and so I rebased to develop. Let's see if the patchbot is happy now.


---

Comment by Rudi created at 2015-06-07 18:03:56

Hmm, mixed signals from the patchbot. Two out of four pass. One fails tests, but this seems unrelated to my patch:

```
sage -t --long src/sage/rings/integer.pyx  # Timed out (and interrupt failed)
```

Plugins fail on one time:

```
plugins.startup_time Failed
```

This also seems unrelated to my patch.


---

Comment by vdelecroix created at 2015-06-07 18:51:44

Replying to [comment:16 Rudi]:
> Hmm, mixed signals from the patchbot. Two out of four pass. One fails tests, but this seems unrelated to my patch:
> {{{
> sage -t --long src/sage/rings/integer.pyx  # Timed out (and interrupt failed)
> }}}

This is a problem with some update of PARI/GP (the failing doctest is the interrupt in `Integer.binomial`). Independent of that ticket.

> Plugins fail on one time:
> {{{
> plugins.startup_time Failed
> }}}
> This also seems unrelated to my patch.

You can also ignore that.


---

Comment by vdelecroix created at 2015-06-09 16:36:52

Hello,

Your commit `6347279` is full of

```
- <empty line>
+ <four or more spaces>
```

Remove that.

You might have a serious problem with your text editor ;-) Or you like too much trailing whitespaces. Anyway: remove all trailing whitespaces you introduced.

Vincent


---

Comment by vdelecroix created at 2015-06-09 16:36:52

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-06-09 16:41:44

When you use `set` there is no need that for the argument of `.union()` to be a set also. You can replace

```
I[r+1] = I[r].union(set([e]))
```

with

```
I[r+1] = I[r].union([e])
```



---

Comment by vdelecroix created at 2015-06-09 16:43:47

Instead of `sage_malloc` you should use `check_malloc` or `check_calloc` from #10257.


---

Comment by Rudi created at 2015-06-09 17:32:06

Replying to [comment:18 vdelecroix]:
> Hello,
> 
> Your commit `6347279` is full of
> {{{
> - <empty line>
> + <four or more spaces>
> }}}
> Remove that.
> 
> You might have a serious problem with your text editor ;-) Or you like too much trailing whitespaces. Anyway: remove all trailing whitespaces you introduced.

I recall touching a button `cleanup whitespace` in my text editor. Guess that did not work out as advertised :). I will get rid of those whitespaces.


---

Comment by git created at 2015-06-09 18:43:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-09 18:50:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-09 18:59:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by Rudi created at 2015-06-09 19:05:18

My, my, that was a lot of white space. 

Looking at the final branch I appear to have repaired them all. I even repaired a few new ones that were in the recently added method `components()'. 

I also got rid of the superfluous set([e]). You're right, in that position [e] will do.

Up for review again.


---

Comment by Rudi created at 2015-06-09 19:05:18

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2015-06-12 21:19:39

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-06-12 21:19:39

Replying to [comment:25 Rudi]:
> My, my, that was a lot of white space. 
> 
> Looking at the final branch I appear to have repaired them all. I even repaired a few new ones that were in the recently added method `components()'. 

Just look at the diff. Many of them are still there. I will provide a commit for gettint rid of them later on if you do not succeed.

> I also got rid of the superfluous set([e]). You're right, in that position [e] will do.
> 
> Up for review again.

Might be cool to do more declaration in `src/sage/matroids/matroid.pyx`

``` 
cdef list T = [...]
cdef list L = [...]
cdef int r = 0
```

As a consequence, calls like `T[i]` gets much faster.

Vincent


---

Comment by vdelecroix created at 2015-06-12 21:21:17

And also declare `cdef long e` in `basis_exchange_matroid.pyx`.


---

Comment by vdelecroix created at 2015-06-12 21:23:07

Use `range` instead of `xrange`. First of all it does not make any difference in Cython and secondly, `xrange` is gone in Python 3.


---

Comment by vdelecroix created at 2015-06-12 21:24:54

`cdef long r = self.full_rank()`

BTW, is this full rank intended to be huge? Doing `r+1` malloc/free of size `X` is much slower than one malloc/free of size `(r+1)*X`. Why not using `sage.data_structures.binary_matrix` here?


---

Comment by Rudi created at 2015-06-12 22:26:10

Replying to [comment:26 vdelecroix]:
> Might be cool to do more declaration in `src/sage/matroids/matroid.pyx`
> {{{ 
> cdef list T = [...]
> cdef list L = [...]
> cdef int r = 0
> }}}
> As a consequence, calls like `T[i]` gets much faster.
Yes, that does improve the efficiency a bit.


---

Comment by Rudi created at 2015-06-12 22:28:22

Replying to [comment:28 vdelecroix]:
> Use `range` instead of `xrange`. First of all it does not make any difference in Cython and secondly, `xrange` is gone in Python 3.
Old habit. Perhaps I should go through all the code, I used it all over.


---

Comment by Rudi created at 2015-06-12 22:31:03

Replying to [comment:29 vdelecroix]:
> `cdef long r = self.full_rank()`
> 
> BTW, is this full rank intended to be huge? Doing `r+1` malloc/free of size `X` is much slower than one malloc/free of size `(r+1)*X`. Why not using `sage.data_structures.binary_matrix` here?
I'll check out `binary_matrix` on the train tomorrow morning. I do need to apply bitset operations between rows of that matrix...


---

Comment by Rudi created at 2015-06-13 08:19:34

Replying to [comment:29 vdelecroix]:
> `cdef long r = self.full_rank()`
> 
> BTW, is this full rank intended to be huge? Doing `r+1` malloc/free of size `X` is much slower than one malloc/free of size `(r+1)*X`.

Full_rank is not huge, never more than the sizes of bitsets themselves.

Creating an array of bitset_t is what I do in most places, even if the lenght of that array is huge. Typically the work in computing the contents of the individual bitsets outweighs the time to allocate them in my application. The advantage is that each entry is an individual bitset to which I can apply bitset methods. And in theory (I don't seem to do it anywhere in practice) you can swap pointers in such an array stead of copying their contents. So once you've paid for all the memory allocation, you will only benefit while using it.

But perhaps if we design a new dense hypergraph, we can have our cake and eat it, by doing mass allocation of the bitset contents and have an array of pointers on the side. It's just that calling bitset_free has to be avoided then.


---

Comment by Rudi created at 2015-06-13 08:26:53

Replying to [comment:28 vdelecroix]:
> Use `range` instead of `xrange`. First of all it does not make any difference in Cython and secondly, `xrange` is gone in Python 3.

Perhaps I should really go through all of the matroid code to make it ready for python 3. Is there any particular place where I can read up on the kind of stuff I need to check (e.g. get rid of xrange).


---

Comment by git created at 2015-06-13 08:41:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by Rudi created at 2015-06-13 08:45:20

Changing status from needs_work to needs_review.


---

Comment by Rudi created at 2015-06-13 08:45:20

Replying to [comment:26 vdelecroix]:
> Replying to [comment:25 Rudi]:
> > Looking at the final branch I appear to have repaired them all. I even repaired a few new ones that were in the recently added method `components()'. 
> 
> Just look at the diff. Many of them are still there. I will provide a commit for gettint rid of them later on if you do not succeed.
> 
Hi Vincent, 

I think I got everything you mentioned in the above, so up for review again.

About the whitespaces: I think the few things you still see in the diff are changes in the right direction, from whitespace to no whitespace.


---

Comment by vdelecroix created at 2015-06-13 11:57:09

Still some non-technical comments:

- Why are you declaring your new functions as `cpdef` and not `def`? Will they be called from Cython code?

- Now, there are two very similar functions in `basis_exchange_matroid.pyx`: `independent_r_sets` and `independent_sets`. Could you at least make a reference to each other (ideally in a `.. SEEALSO` section). Similarly in `matroid.pyx` you have `bases`, `independent_r_sets`, ...

- (not necessarily for this ticket) The code in `independent_r_sets` and `bases_count` is almost identical. Why not making `bases_count` more general by allowing to count the cardinality of independent set and share the code with `independent_r_sets`?

Vincent


---

Comment by git created at 2015-06-13 16:01:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by Rudi created at 2015-06-13 16:03:31

Replying to [comment:37 vdelecroix]: 
> - Why are you declaring your new functions as `cpdef` and not `def`? Will they be called from Cython code?
> 
The BasisExchangeMatroid method could be called from cython at some point, and that function overrides the Matroid method. Is there a disadvantage to declaring then cpdef? 

> - Now, there are two very similar functions in `basis_exchange_matroid.pyx`: `independent_r_sets` and `independent_sets`. Could you at least make a reference to each other (ideally in a `.. SEEALSO` section). Similarly in `matroid.pyx` you have `bases`, `independent_r_sets`, ...
> 
OK.
> - (not necessarily for this ticket) The code in `independent_r_sets` and `bases_count` is almost identical. Why not making `bases_count` more general by allowing to count the cardinality of independent set and share the code with `independent_r_sets`?
> 
In BasisExchangeMatroid this is already the case. Andl I could also modify Matroid, but right now that is not my top priority. We are talking about 6 lines of code here. 
----
New commits:


---

Comment by git created at 2015-07-20 08:43:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by Rudi created at 2015-07-20 08:45:22

The patch was out of date, so I merged with the most recent develop. Doctests still run.

Anything in particular that still needs to be done for the review?


---

Comment by ncohen created at 2015-07-22 15:13:21

Your branch creates three files in the build/ folder. That does not seem to be your intent.


---

Comment by Rudi created at 2015-07-22 15:48:48

Replying to [comment:42 ncohen]:
> Your branch creates three files in the build/ folder. That does not seem to be your intent.

Clearly not. I suspect this happened after my the last merge, but I honestly don't see what I might have done wrong. It was a fairly clean operation, although I had to help the merge a little bit.. So have two questions:
- where did I mess up?
- how do I make this right?
Hope you can be my coach one more time, Nathan :).


---

Comment by ncohen created at 2015-07-22 15:55:00

Helloooooo,

It must have happened during this merge: those files were *moved* to a different directory in a recent release, and perhaps some "git commit -a" during the merge added them back. Either way it is not complicated: just type "git rm <filename>" on those three guys, then add the commit to your branch.

That means that your branch will in theory add them back then remove them, but that's not really a problem. If you want to make it cleaner later, you can squash all the commits of your branch together (after the previous operation) with "git rebase -i develop".

Nathann


---

Comment by git created at 2015-07-22 17:06:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by Rudi created at 2015-07-22 17:10:08

Replying to [comment:44 ncohen]:

> It must have happened during this merge: those files were *moved* to a different directory in a recent release, and perhaps some "git commit -a" during the merge added them back. Either way it is not complicated: just type "git rm <filename>" on those three guys, then add the commit to your branch.

Thanks Nathann, did that.


---

Comment by tscrim created at 2015-11-20 18:32:28

Hey Vincent,

Do you plan on finishing the review for this ticket? Otherwise I can finish it.


---

Comment by vdelecroix created at 2015-11-23 14:34:05

Hello Travis,

Replying to [comment:47 tscrim]:
> Do you plan on finishing the review for this ticket? Otherwise I can finish it.

Please do. The ticket is waiting since too long.


---

Comment by tscrim created at 2015-11-23 15:25:45

In the `independent_sets` of `BasisExchangeMatroid`, is there a reason why you have to do all of that extra processing before the empty ground set check? Also it is faster to do `if not self._E:`.

You also have a little bit of whitespace left here:

```
        # <-- Whitespace
        .. SEEALSO::

            :meth:`M.independent_sets() <sage.matroids.matroid.Matroid.independent_sets>`
            :meth:`M.bases() <sage.matroids.matroid.Matroid.bases>`
```


Otherwise I think it looks good.


---

Comment by tscrim created at 2016-01-03 04:13:54

I made the changes in my comment. If there is no response to my question in comment:49 in a few days, then Vincent, if you could double-check my code and then set a positive review.
----
New commits:


---

Comment by vdelecroix created at 2016-01-03 15:10:31

Hello,

1. This is very bad

```
+        I = <bitset_t*>sage_malloc((r + 1) * sizeof(bitset_t))
+        T = <bitset_t*>sage_malloc((r + 1) * sizeof(bitset_t))
+        for i in range(r + 1):
+            bitset_init(I[i], self._bitset_size)
+            bitset_init(T[i], self._bitset_size)
```

  It calls `2(r+2)` times memory allocation for arrays of fixed size! There should be only *one* memory allocation call for everything.

2. Something should be done for `KeyboardInterruption`. i.e. proper `sig_on/sig_off` and appropriate testing.

3. In the other method `independent_sets`:
 - the variable `int i` is useless.
 - replace

```
cdef list I = [frozenset() for i in range(self.full_rank()+1)]
```

  with

```
cdef list I = [frozenset()] * (self.full_rank()+1)
```

 - why using `frozenset` in `I`? Using `set` would allow to replace `I[r+1] = I[r].union([e])` with

```
I[r+1] = I[r].copy()
I[r+1].update(e)
```

  It avoids a one element list to be created and `update` is much faster than `union`.


---

Comment by vdelecroix created at 2016-01-03 15:10:31

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2016-01-03 16:04:36

Replying to [comment:51 vdelecroix]:
> 1. This is very bad
> {{{
> +        I = <bitset_t*>sage_malloc((r + 1) * sizeof(bitset_t))
> +        T = <bitset_t*>sage_malloc((r + 1) * sizeof(bitset_t))
> +        for i in range(r + 1):
> +            bitset_init(I[i], self._bitset_size)
> +            bitset_init(T[i], self._bitset_size)
> }}}
>   It calls `2(r+2)` times memory allocation for arrays of fixed size! There should be only *one* memory allocation call for everything.

These are just my 2 cents and do not constitute an expert opinion on this issue.

I believe it has to be the two arrays of bitsets because of the code (at least without adding additional bitset manipulations and reimplementing the `__closure`).

Although I don't know if it is faster to use a python list of bitsets or the allocated block of memory. My intuition says the latter because it avoids the Python overhead.

> 2. Something should be done for `KeyboardInterruption`. i.e. proper `sig_on/sig_off` and appropriate testing.

Do you need a `sig_on` / `sig_off` for `cpdef` functions?

> 3. In the other method `independent_sets`:
>  - the variable `int i` is useless.

Yes, it is redundant; `r` could be used in its stead.

>  - replace
> {{{
> cdef list I = [frozenset() for i in range(self.full_rank()+1)]
> }}}
>   with
> {{{
> cdef list I = [frozenset()] * (self.full_rank()+1)
> }}}
>  - why using `frozenset` in `I`? Using `set` would allow to replace `I[r+1] = I[r].union([e])` with
> {{{
> I[r+1] = I[r].copy()
> I[r+1].update(e)
> }}}
>   It avoids a one element list to be created and `update` is much faster than `union`.

If this switches to using `set`, then we can't do the first replacement (which I believe you are aware, but I'm stating for the record). I'm +1 for changing to `set` and the above; it is much better in terms of memory manipulations and should gain some speed improvements. Additionally (mostly a note for myself), we will also need to cast the result into a frozenset:

```diff
-self.__closure(T[i+1], self._input)
+self.__closure(frozenset(T[i+1]), self._input)
```



---

Comment by Rudi created at 2016-01-03 18:43:15

Hi Travis,

sorry for the late reply. My setup for writing sage code involves working remotely on a linux machine. This is so uncomfortable that I was putting of this work until my macbook installation is on it's feet again. But I will at least reply to your last comments.

Replying to [comment:49 tscrim]:
> In the `independent_sets` of `BasisExchangeMatroid`, is there a reason why you have to do all of that extra processing before the empty ground set check? Also it is faster to do `if not self._E:`.
> 
The empty set is always an independent set of a matroid, so even if the ground set (self._E) is empty the output of .independent_sets() should be a SetSystem containing an empty set. So yes, that setup before the test if self._E is empty is necessary.


---

Comment by Rudi created at 2016-01-03 19:13:18

Hi Vincent,

thanks for the feedback.

Replying to [comment:51 vdelecroix]:
> 1. This is very bad
> {{{
> +        I = <bitset_t*>sage_malloc((r + 1) * sizeof(bitset_t))
> +        T = <bitset_t*>sage_malloc((r + 1) * sizeof(bitset_t))
> +        for i in range(r + 1):
> +            bitset_init(I[i], self._bitset_size)
> +            bitset_init(T[i], self._bitset_size)
> }}}
>   It calls `2(r+2)` times memory allocation for arrays of fixed size! There should be only *one* memory allocation call for everything.
> 

The overhead of these 2(r+2) memory allocations is negligible compared to the other work that independent_sets() does. Most subsets of the ground set of cardinality at most r will be independent, so for a matroid on n elements, writing the output takes time proportional to ` \sum_{i=0}^r (n choose i)`. So when this memory allocation takes more than a microsecond, were looking at an r in the hundreds. Then the function as a whole will probably take many years.


---

Comment by git created at 2016-01-04 00:42:46

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2016-01-04 00:46:05

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2016-01-04 00:51:04

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2016-01-04 00:51:04

Whoops, sorry about that. Fixed and you shouldn't have to do anything special because I just reverted my bad merge.

I did some testing and found that the extra copying of the sets plus the conversion to a frozenset was just as slow if not slower than doing the union with the frozenset.

However I was able to optimize the method by special casing when `r` is at the full rank. The `BetsyRoss().independent_sets()` time when from 4.8s to 1.6s and `R98().independent_sets()` went from 4.8s to 2.8s on my machine.

Thanks for the explanations Rudi.


---

Comment by tscrim created at 2016-01-08 16:01:54

Ping. Vincent, Rudi, are my changes good and are we ready to set this to a positive review?


---

Comment by Rudi created at 2016-02-11 19:19:22

Replying to [comment:58 tscrim]:
> Ping. Vincent, Rudi, are my changes good and are we ready to set this to a positive review?

Sorry Travis, missed that ping. Thank you for making those changes, I'm happy with them.

Cheers,
Rudi


---

Comment by tscrim created at 2016-02-11 20:20:24

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-02-11 23:26:35

Resolution: fixed
