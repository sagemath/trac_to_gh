# Issue 14050: OverflowErrors in TripleDictEraser

archive/issues_014050.json:
```json
{
    "body": "Assignee: robertwb\n\nCC:  simonking nbruin\n\nWith the new doctesting framework (#12415), I sometimes see errors like\n\n```\nsage -t --long devel/sage/sage/combinat/sf/sfa.py\n**********************************************************************\nFile \"devel/sage/sage/combinat/sf/sfa.py\", line 388, in sage.combinat.sf.sfa.is_SymmetricFunctionAlgebra\nFailed example:\n    is_SymmetricFunctionAlgebra(SymmetricFunctions(FractionField(QQ['q','t'])).macdonald().P())\nExpected:\n    True\nGot:\n    Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9531b3c> ignored\n    True\n**********************************************************************\n```\n\non 32-bit systems.\n\nThese appear randomly non-reproducibly in doctests.\n\nIssue created by migration from https://trac.sagemath.org/ticket/14254\n\n",
    "created_at": "2013-03-11T09:01:43Z",
    "labels": [
        "coercion",
        "blocker",
        "bug"
    ],
    "title": "OverflowErrors in TripleDictEraser",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14050",
    "user": "jdemeyer"
}
```
Assignee: robertwb

CC:  simonking nbruin

With the new doctesting framework (#12415), I sometimes see errors like

```
sage -t --long devel/sage/sage/combinat/sf/sfa.py
**********************************************************************
File "devel/sage/sage/combinat/sf/sfa.py", line 388, in sage.combinat.sf.sfa.is_SymmetricFunctionAlgebra
Failed example:
    is_SymmetricFunctionAlgebra(SymmetricFunctions(FractionField(QQ['q','t'])).macdonald().P())
Expected:
    True
Got:
    Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x9531b3c> ignored
    True
**********************************************************************
```

on 32-bit systems.

These appear randomly non-reproducibly in doctests.

Issue created by migration from https://trac.sagemath.org/ticket/14254





---

archive/issue_comments_175705.json:
```json
{
    "body": "There is a comment\n\n```\n# A note about how to store \"id\" keys in python structures:\n#\n# In python a \"pointer length integer\" (size_t) normally, is encoded\n# as a *signed* integer, of type Py_ssize_t. This has an advantage in that\n# if the value gets encoded as a *python integer* it can do so in a sign-preserving\n# way and still make use of all the bits that python offers to store (small) integers.\n#\n# There is one place where we have to be careful about signs:\n# Our hash values most naturally live in Py_ssize_t. We convert those into\n# an index into our bucket list by taking the hash modulo the number of buckets.\n# However, the modulo operator in C preserves the sign of the number we take the\n# modulus of, which is not what we want.\n# The solution is to always do\n# (<size_t) h)% modulus\n# to ensure we're doing an unsigned modulus.\n```\n\n\nCould it be that this is relevant here?\n\nIs it really safe to do\n\n```\n        cdef Py_ssize_t k1,k2,k3\n        cdef int offset\n        k1,k2,k3,offset = r.key\n        cdef Py_ssize_t h = (k1 + 13*k2 ^ 503*k3)\n        PyList_GET_ITEM(buckets, (<size_t>h) % PyList_GET_SIZE(buckets))\n```\n\n?\n\nYes, we need to care about the sign. But we also have\n\n```\n Py_ssize_t PyList_GET_SIZE(object list)\n PyObject* PyList_GET_ITEM(object list, Py_ssize_t i)\n```\n\n(hence, the modulus is Py_ssize_t, and the result will be translated into Py_ssize_t, too)\n\nI am afraid I have no 32 bit machine to test.",
    "created_at": "2013-03-11T10:37:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175705",
    "user": "SimonKing"
}
```

There is a comment

```
# A note about how to store "id" keys in python structures:
#
# In python a "pointer length integer" (size_t) normally, is encoded
# as a *signed* integer, of type Py_ssize_t. This has an advantage in that
# if the value gets encoded as a *python integer* it can do so in a sign-preserving
# way and still make use of all the bits that python offers to store (small) integers.
#
# There is one place where we have to be careful about signs:
# Our hash values most naturally live in Py_ssize_t. We convert those into
# an index into our bucket list by taking the hash modulo the number of buckets.
# However, the modulo operator in C preserves the sign of the number we take the
# modulus of, which is not what we want.
# The solution is to always do
# (<size_t) h)% modulus
# to ensure we're doing an unsigned modulus.
```


Could it be that this is relevant here?

Is it really safe to do

```
        cdef Py_ssize_t k1,k2,k3
        cdef int offset
        k1,k2,k3,offset = r.key
        cdef Py_ssize_t h = (k1 + 13*k2 ^ 503*k3)
        PyList_GET_ITEM(buckets, (<size_t>h) % PyList_GET_SIZE(buckets))
```

?

Yes, we need to care about the sign. But we also have

```
 Py_ssize_t PyList_GET_SIZE(object list)
 PyObject* PyList_GET_ITEM(object list, Py_ssize_t i)
```

(hence, the modulus is Py_ssize_t, and the result will be translated into Py_ssize_t, too)

I am afraid I have no 32 bit machine to test.



---

archive/issue_comments_175706.json:
```json
{
    "body": "PS: Note the discussion that we had on #715 on that matter.\n\nIs there a reason why we use ssize_t and not size_t?",
    "created_at": "2013-03-11T10:41:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175706",
    "user": "SimonKing"
}
```

PS: Note the discussion that we had on #715 on that matter.

Is there a reason why we use ssize_t and not size_t?



---

archive/issue_comments_175707.json:
```json
{
    "body": "Any idea on how to debug this? The problem is that currently we have no idea where this exception is generated.",
    "created_at": "2013-03-11T10:45:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175707",
    "user": "jdemeyer"
}
```

Any idea on how to debug this? The problem is that currently we have no idea where this exception is generated.



---

archive/issue_comments_175708.json:
```json
{
    "body": "Google seems to tell me that one should use size_t and not ssize_t here anyway. Not sure though.\n\nNils, do you think it could help to consistently replace ssize_t and Py_ssize_t by size_t?",
    "created_at": "2013-03-11T10:46:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175708",
    "user": "SimonKing"
}
```

Google seems to tell me that one should use size_t and not ssize_t here anyway. Not sure though.

Nils, do you think it could help to consistently replace ssize_t and Py_ssize_t by size_t?



---

archive/issue_comments_175709.json:
```json
{
    "body": "Replying to [comment:4 jdemeyer]:\n> Any idea on how to debug this? The problem is that currently we have no idea where this exception is generated.\n\nSage's debug version?",
    "created_at": "2013-03-11T10:47:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175709",
    "user": "SimonKing"
}
```

Replying to [comment:4 jdemeyer]:
> Any idea on how to debug this? The problem is that currently we have no idea where this exception is generated.

Sage's debug version?



---

archive/issue_comments_175710.json:
```json
{
    "body": "Replying to [comment:2 SimonKing]:\n> {{{\n>         k1,k2,k3,offset = r.key\n> }}}\nThis line might be problematic if there is no guarantee that the components of `r.key` fit in the respective types (`Py_ssize_t`, `Py_ssize_t`, `Py_ssize_t`, `int`).",
    "created_at": "2013-03-11T10:48:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175710",
    "user": "jdemeyer"
}
```

Replying to [comment:2 SimonKing]:
> {{{
>         k1,k2,k3,offset = r.key
> }}}
This line might be problematic if there is no guarantee that the components of `r.key` fit in the respective types (`Py_ssize_t`, `Py_ssize_t`, `Py_ssize_t`, `int`).



---

archive/issue_comments_175711.json:
```json
{
    "body": "Replying to [comment:6 SimonKing]:\n> Sage's debug version?\nWould it really give more information about where the exception is generated?",
    "created_at": "2013-03-11T10:49:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175711",
    "user": "jdemeyer"
}
```

Replying to [comment:6 SimonKing]:
> Sage's debug version?
Would it really give more information about where the exception is generated?



---

archive/issue_comments_175712.json:
```json
{
    "body": "Replying to [comment:8 jdemeyer]:\n> Replying to [comment:6 SimonKing]:\n> > Sage's debug version?\n> Would it really give more information about where the exception is generated?\n\nI thought that this is the point of a debug version? Is there an environment variable similar to MALLOC_CHECK_ that makes the program segfault on an overflow error, so that one could then analyse the problem using gdb?",
    "created_at": "2013-03-11T10:54:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175712",
    "user": "SimonKing"
}
```

Replying to [comment:8 jdemeyer]:
> Replying to [comment:6 SimonKing]:
> > Sage's debug version?
> Would it really give more information about where the exception is generated?

I thought that this is the point of a debug version? Is there an environment variable similar to MALLOC_CHECK_ that makes the program segfault on an overflow error, so that one could then analyse the problem using gdb?



---

archive/issue_comments_175713.json:
```json
{
    "body": "How many bytes is Py_ssize_t using? On 32-bit machines, is Py_ssize_t perhaps using more bytes than size_t? Then, the problem could be here:\n\n```\n        cdef Py_ssize_t h1 = <Py_ssize_t><void *>k1\n        cdef Py_ssize_t h2 = <Py_ssize_t><void *>k2\n        cdef Py_ssize_t h3 = <Py_ssize_t><void *>k3\n        cdef Py_ssize_t h = (h1 + 13*h2 ^ 503*h3)\n```\n\nWhile h1, h2, and h3 should be fine (they are obtained from a pointer and are thus using 32 bit), I could imagine that Python tries to be clever and uses more byte (long versus int) for h, if 13*h2 or 503*h3 happen to be larger than the greatest number representable by 32 bit.\n\nIf this is the case, then the line\n\n```\ncdef list bucket = <object>PyList_GET_ITEM(all_buckets, (<size_t>h) % PyList_GET_SIZE(all_buckets))\n```\n\n(when the \"long\" Py_ssize_t h is converted down to 32 bit of size_t) could overflow, isn't it?\n\nCaveat: I am not an expert for the subtleties of Py_ssize_t on 32 versus 64 bit...",
    "created_at": "2013-03-11T11:34:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175713",
    "user": "SimonKing"
}
```

How many bytes is Py_ssize_t using? On 32-bit machines, is Py_ssize_t perhaps using more bytes than size_t? Then, the problem could be here:

```
        cdef Py_ssize_t h1 = <Py_ssize_t><void *>k1
        cdef Py_ssize_t h2 = <Py_ssize_t><void *>k2
        cdef Py_ssize_t h3 = <Py_ssize_t><void *>k3
        cdef Py_ssize_t h = (h1 + 13*h2 ^ 503*h3)
```

While h1, h2, and h3 should be fine (they are obtained from a pointer and are thus using 32 bit), I could imagine that Python tries to be clever and uses more byte (long versus int) for h, if 13*h2 or 503*h3 happen to be larger than the greatest number representable by 32 bit.

If this is the case, then the line

```
cdef list bucket = <object>PyList_GET_ITEM(all_buckets, (<size_t>h) % PyList_GET_SIZE(all_buckets))
```

(when the "long" Py_ssize_t h is converted down to 32 bit of size_t) could overflow, isn't it?

Caveat: I am not an expert for the subtleties of Py_ssize_t on 32 versus 64 bit...



---

archive/issue_comments_175714.json:
```json
{
    "body": "Replying to [comment:10 SimonKing]:\n> How many bytes is Py_ssize_t using? On 32-bit machines, is Py_ssize_t perhaps using more bytes than size_t? Then, the problem could be here:\n> {{{\n>         cdef Py_ssize_t h1 = <Py_ssize_t><void *>k1\n>         cdef Py_ssize_t h2 = <Py_ssize_t><void *>k2\n>         cdef Py_ssize_t h3 = <Py_ssize_t><void *>k3\n>         cdef Py_ssize_t h = (h1 + 13*h2 ^ 503*h3)\n> }}}\n> While h1, h2, and h3 should be fine (they are obtained from a pointer and are thus using 32 bit), I could imagine that Python tries to be clever and uses more byte (long versus int) for h\nNo, that cannot be the problem, arithmetic on pure C types (like here) doesn't use Python at all.",
    "created_at": "2013-03-11T11:41:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175714",
    "user": "jdemeyer"
}
```

Replying to [comment:10 SimonKing]:
> How many bytes is Py_ssize_t using? On 32-bit machines, is Py_ssize_t perhaps using more bytes than size_t? Then, the problem could be here:
> {{{
>         cdef Py_ssize_t h1 = <Py_ssize_t><void *>k1
>         cdef Py_ssize_t h2 = <Py_ssize_t><void *>k2
>         cdef Py_ssize_t h3 = <Py_ssize_t><void *>k3
>         cdef Py_ssize_t h = (h1 + 13*h2 ^ 503*h3)
> }}}
> While h1, h2, and h3 should be fine (they are obtained from a pointer and are thus using 32 bit), I could imagine that Python tries to be clever and uses more byte (long versus int) for h
No, that cannot be the problem, arithmetic on pure C types (like here) doesn't use Python at all.



---

archive/issue_comments_175715.json:
```json
{
    "body": "I found the following on [PEP 353](http://www.python.org/dev/peps/pep-0353/):\n\n```\nConceptually, Py_intptr_t and Py_ssize_t are different things: Py_intptr_t needs\nto be the same size as void*, and Py_ssize_t the same size as size_t. These could\ndiffer, e.g. on machines where pointers have segment and offset. On current\nflat-address space machines, there is no difference, so for all practical purposes,\nPy_intptr_t would have worked as well.\n```\n\nNote that we actually *do* want a conversion from and to <void*>. So, shouldn't we actually use Py_intptr_t, not Py_ssize_t?",
    "created_at": "2013-03-11T11:56:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175715",
    "user": "SimonKing"
}
```

I found the following on [PEP 353](http://www.python.org/dev/peps/pep-0353/):

```
Conceptually, Py_intptr_t and Py_ssize_t are different things: Py_intptr_t needs
to be the same size as void*, and Py_ssize_t the same size as size_t. These could
differ, e.g. on machines where pointers have segment and offset. On current
flat-address space machines, there is no difference, so for all practical purposes,
Py_intptr_t would have worked as well.
```

Note that we actually *do* want a conversion from and to <void*>. So, shouldn't we actually use Py_intptr_t, not Py_ssize_t?



---

archive/issue_comments_175716.json:
```json
{
    "body": "Does Py_intptr_t even exist in Sage? I did a grep for it, to no avail.",
    "created_at": "2013-03-11T12:20:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175716",
    "user": "SimonKing"
}
```

Does Py_intptr_t even exist in Sage? I did a grep for it, to no avail.



---

archive/issue_comments_175717.json:
```json
{
    "body": "Replying to [comment:12 SimonKing]:\n> I found the following on [PEP 353](http://www.python.org/dev/peps/pep-0353/):\n> {{{\n> Conceptually, Py_intptr_t and Py_ssize_t are different things: Py_intptr_t needs\n> to be the same size as void*, and Py_ssize_t the same size as size_t. These could\n> differ, e.g. on machines where pointers have segment and offset. On current\n> flat-address space machines, there is no difference, so for all practical purposes,\n> Py_intptr_t would have worked as well.\n> }}}\n> Note that we actually *do* want a conversion from and to <void*>. So, shouldn't we actually use Py_intptr_t, not Py_ssize_t?\n\nThat's all true but it wouldn't solve this error.",
    "created_at": "2013-03-11T12:29:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175717",
    "user": "jdemeyer"
}
```

Replying to [comment:12 SimonKing]:
> I found the following on [PEP 353](http://www.python.org/dev/peps/pep-0353/):
> {{{
> Conceptually, Py_intptr_t and Py_ssize_t are different things: Py_intptr_t needs
> to be the same size as void*, and Py_ssize_t the same size as size_t. These could
> differ, e.g. on machines where pointers have segment and offset. On current
> flat-address space machines, there is no difference, so for all practical purposes,
> Py_intptr_t would have worked as well.
> }}}
> Note that we actually *do* want a conversion from and to <void*>. So, shouldn't we actually use Py_intptr_t, not Py_ssize_t?

That's all true but it wouldn't solve this error.



---

archive/issue_comments_175718.json:
```json
{
    "body": "Replying to [comment:14 jdemeyer]:\n> > Note that we actually *do* want a conversion from and to <void*>. So, shouldn't we actually use Py_intptr_t, not Py_ssize_t?\n> \n> That's all true but it wouldn't solve this error.\n\nWell, you didn't tell yet were exactly the error is located.\n\nLacking more information, my guess was that an overflow could occur on systems where `sizeof(Py_ssize_t)==sizeof(size_t)` differs from `sizeof(Py_intptr_t)==sizeof(void*)`. So, why are you sure that the problem is *not* related with conversion between size_t and pointers?",
    "created_at": "2013-03-11T12:36:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175718",
    "user": "SimonKing"
}
```

Replying to [comment:14 jdemeyer]:
> > Note that we actually *do* want a conversion from and to <void*>. So, shouldn't we actually use Py_intptr_t, not Py_ssize_t?
> 
> That's all true but it wouldn't solve this error.

Well, you didn't tell yet were exactly the error is located.

Lacking more information, my guess was that an overflow could occur on systems where `sizeof(Py_ssize_t)==sizeof(size_t)` differs from `sizeof(Py_intptr_t)==sizeof(void*)`. So, why are you sure that the problem is *not* related with conversion between size_t and pointers?



---

archive/issue_comments_175719.json:
```json
{
    "body": "Replying to [comment:15 SimonKing]:\n> Well, you didn't tell yet were exactly the error is located.\nIf I would know that, fixing the error would probably be trivial.",
    "created_at": "2013-03-11T13:29:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175719",
    "user": "jdemeyer"
}
```

Replying to [comment:15 SimonKing]:
> Well, you didn't tell yet were exactly the error is located.
If I would know that, fixing the error would probably be trivial.



---

archive/issue_comments_175720.json:
```json
{
    "body": "I see it also *all over the place* when building the docs:\n\n```\n[...]\n[rings    ] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings    ] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings    ] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings    ] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings    ] no targets are out of date.\n[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored\n[rings_num] no targets are out of date.\n[...]\n```\n",
    "created_at": "2013-03-11T13:30:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175720",
    "user": "jdemeyer"
}
```

I see it also *all over the place* when building the docs:

```
[...]
[rings    ] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings    ] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings    ] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings    ] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings    ] no targets are out of date.
[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings_num] Exception OverflowError: 'long int too large to convert to int' in <sage.structure.coerce_dict.TripleDictEraser object at 0x949611c> ignored
[rings_num] no targets are out of date.
[...]
```




---

archive/issue_comments_175721.json:
```json
{
    "body": "Can you test `sizeof(Py_ssize_t)==sizeof(void*)` on those machines that exposed the error? Namely, this equality would falsify my guess.",
    "created_at": "2013-03-11T13:32:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175721",
    "user": "SimonKing"
}
```

Can you test `sizeof(Py_ssize_t)==sizeof(void*)` on those machines that exposed the error? Namely, this equality would falsify my guess.



---

archive/issue_comments_175722.json:
```json
{
    "body": "Replying to [comment:15 SimonKing]:\n> Lacking more information, my guess was that an overflow could occur on systems where `sizeof(Py_ssize_t)==sizeof(size_t)` differs from `sizeof(Py_intptr_t)==sizeof(void*)`. So, why are you sure that the problem is *not* related with conversion between size_t and pointers?\n\nThis is a typical 32-bit system where the types `int`, `long`, `size_t`, `Py_ssize_t`, `void*`, `intptr_t` are all 4 bytes.",
    "created_at": "2013-03-11T13:34:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175722",
    "user": "jdemeyer"
}
```

Replying to [comment:15 SimonKing]:
> Lacking more information, my guess was that an overflow could occur on systems where `sizeof(Py_ssize_t)==sizeof(size_t)` differs from `sizeof(Py_intptr_t)==sizeof(void*)`. So, why are you sure that the problem is *not* related with conversion between size_t and pointers?

This is a typical 32-bit system where the types `int`, `long`, `size_t`, `Py_ssize_t`, `void*`, `intptr_t` are all 4 bytes.



---

archive/issue_comments_175723.json:
```json
{
    "body": "Besides, even if `void*` would be larger than `Py_ssize_t`, I still don't see how it could cause the error that we're seeing. The cast `void*` -> `Py_ssize_t` is pure C, so it couldn't overflow.",
    "created_at": "2013-03-11T13:36:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175723",
    "user": "jdemeyer"
}
```

Besides, even if `void*` would be larger than `Py_ssize_t`, I still don't see how it could cause the error that we're seeing. The cast `void*` -> `Py_ssize_t` is pure C, so it couldn't overflow.



---

archive/issue_comments_175724.json:
```json
{
    "body": "I am debugging building the docs, as I can reliably get the failure this way.",
    "created_at": "2013-03-11T13:37:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175724",
    "user": "jdemeyer"
}
```

I am debugging building the docs, as I can reliably get the failure this way.



---

archive/issue_comments_175725.json:
```json
{
    "body": "The error happens in the last line here:\n\n```\n        cdef TripleDict D = <object>PyWeakref_GetObject(self.D)\n        if D is None:\n            return\n        cdef list buckets = D.buckets\n        if buckets is None:\n            return\n        # r is a (weak) reference (typically to a parent), and it knows the\n        # stored key of the unique triple r() had been part of.\n        # We remove that unique triple from self.D\n        cdef Py_ssize_t k1,k2,k3\n        k1,k2,k3 = r.key\n```\n",
    "created_at": "2013-03-11T13:45:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175725",
    "user": "jdemeyer"
}
```

The error happens in the last line here:

```
        cdef TripleDict D = <object>PyWeakref_GetObject(self.D)
        if D is None:
            return
        cdef list buckets = D.buckets
        if buckets is None:
            return
        # r is a (weak) reference (typically to a parent), and it knows the
        # stored key of the unique triple r() had been part of.
        # We remove that unique triple from self.D
        cdef Py_ssize_t k1,k2,k3
        k1,k2,k3 = r.key
```




---

archive/issue_comments_175726.json:
```json
{
    "body": "Replying to [comment:22 jdemeyer]:\n> The error happens in the last line here: \n> {{{\n>         cdef Py_ssize_t k1,k2,k3\n>         k1,k2,k3 = r.key\n> }}}\n\nInteresting. So, this would probably mean that the actual error occurs when *storing* the key. Let's see what is done there...\n\nJust out of curiosity: Does the same problem also occur with #14159 and dependencies?",
    "created_at": "2013-03-11T13:50:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175726",
    "user": "SimonKing"
}
```

Replying to [comment:22 jdemeyer]:
> The error happens in the last line here: 
> {{{
>         cdef Py_ssize_t k1,k2,k3
>         k1,k2,k3 = r.key
> }}}

Interesting. So, this would probably mean that the actual error occurs when *storing* the key. Let's see what is done there...

Just out of curiosity: Does the same problem also occur with #14159 and dependencies?



---

archive/issue_comments_175727.json:
```json
{
    "body": "Aha!\n\nWe have\n\n```\n        cdef size_t h1 = <size_t><void *>k1\n        cdef size_t h2 = <size_t><void *>k2\n        cdef size_t h3 = <size_t><void *>k3\n        try:\n            ref1 = KeyedRef(k1,self.eraser,(h1, h2, h3))\n        except TypeError:\n            ref1 = k1\n```\n\n\nHence, the three items of the key originally were size_t. But they are assigned to Py_ssize_t.",
    "created_at": "2013-03-11T13:53:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175727",
    "user": "SimonKing"
}
```

Aha!

We have

```
        cdef size_t h1 = <size_t><void *>k1
        cdef size_t h2 = <size_t><void *>k2
        cdef size_t h3 = <size_t><void *>k3
        try:
            ref1 = KeyedRef(k1,self.eraser,(h1, h2, h3))
        except TypeError:
            ref1 = k1
```


Hence, the three items of the key originally were size_t. But they are assigned to Py_ssize_t.



---

archive/issue_comments_175728.json:
```json
{
    "body": "I can't find this code, where is it?",
    "created_at": "2013-03-11T13:55:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175728",
    "user": "jdemeyer"
}
```

I can't find this code, where is it?



---

archive/issue_comments_175729.json:
```json
{
    "body": "Replying to [comment:23 SimonKing]:\n> Interesting. So, this would probably mean that the actual error occurs when *storing* the key.\nIndeed.\n\nAnd `r.key` does indeed take values like `k1,k2,k3 = (3043219468L, 154417500, 150140108)`, the first of which would not fit in a `Py_ssize_t`.\n\nSo the question is: where does this tuple come from?",
    "created_at": "2013-03-11T13:55:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175729",
    "user": "jdemeyer"
}
```

Replying to [comment:23 SimonKing]:
> Interesting. So, this would probably mean that the actual error occurs when *storing* the key.
Indeed.

And `r.key` does indeed take values like `k1,k2,k3 = (3043219468L, 154417500, 150140108)`, the first of which would not fit in a `Py_ssize_t`.

So the question is: where does this tuple come from?



---

archive/issue_comments_175730.json:
```json
{
    "body": "In sage/categories/homset.py:\n\n```\n    _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))\n```\n\n\n`id()` returns `<type 'int'>`. I don't know if assigning `int` to `Py_ssize_t` can be a problem.",
    "created_at": "2013-03-11T14:00:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175730",
    "user": "SimonKing"
}
```

In sage/categories/homset.py:

```
    _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))
```


`id()` returns `<type 'int'>`. I don't know if assigning `int` to `Py_ssize_t` can be a problem.



---

archive/issue_comments_175731.json:
```json
{
    "body": "Replying to [comment:26 jdemeyer]:\n> And `r.key` does indeed take values like `k1,k2,k3 = (3043219468L, 154417500, 150140108)`, the first of which would not fit in a `Py_ssize_t`.\n> \n> So the question is: where does this tuple come from?\n\nThere are (as much as I know) only the two places that I mentioned (by the way, #14159 would change it).\n\nIs `size_t-->Py_ssize_t` a potential problem? Or is `id(...)-->Py_ssize_t` a potential problem?",
    "created_at": "2013-03-11T14:05:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175731",
    "user": "SimonKing"
}
```

Replying to [comment:26 jdemeyer]:
> And `r.key` does indeed take values like `k1,k2,k3 = (3043219468L, 154417500, 150140108)`, the first of which would not fit in a `Py_ssize_t`.
> 
> So the question is: where does this tuple come from?

There are (as much as I know) only the two places that I mentioned (by the way, #14159 would change it).

Is `size_t-->Py_ssize_t` a potential problem? Or is `id(...)-->Py_ssize_t` a potential problem?



---

archive/issue_comments_175732.json:
```json
{
    "body": "Replying to [comment:27 SimonKing]:\n> In sage/categories/homset.py:\n> {{{\n>     _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))\n> }}}\n> \n> `id()` returns `<type 'int'>`. I don't know if assigning `int` to `Py_ssize_t` can be a problem.\nBingo!  That's the problem indeed.",
    "created_at": "2013-03-11T14:14:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175732",
    "user": "jdemeyer"
}
```

Replying to [comment:27 SimonKing]:
> In sage/categories/homset.py:
> {{{
>     _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))
> }}}
> 
> `id()` returns `<type 'int'>`. I don't know if assigning `int` to `Py_ssize_t` can be a problem.
Bingo!  That's the problem indeed.



---

archive/issue_comments_175733.json:
```json
{
    "body": "Replying to [comment:29 jdemeyer]:\n> Replying to [comment:27 SimonKing]:\n> > In sage/categories/homset.py:\n> > {{{\n> >     _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))\n> > }}}\n> > \n> > `id()` returns `<type 'int'>`. I don't know if assigning `int` to `Py_ssize_t` can be a problem.\n> Bingo!  That's the problem indeed.\n\nOK. Then it is solved in #14159, I suppose.",
    "created_at": "2013-03-11T14:17:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175733",
    "user": "SimonKing"
}
```

Replying to [comment:29 jdemeyer]:
> Replying to [comment:27 SimonKing]:
> > In sage/categories/homset.py:
> > {{{
> >     _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))
> > }}}
> > 
> > `id()` returns `<type 'int'>`. I don't know if assigning `int` to `Py_ssize_t` can be a problem.
> Bingo!  That's the problem indeed.

OK. Then it is solved in #14159, I suppose.



---

archive/issue_comments_175734.json:
```json
{
    "body": "But I would really like a quick fix independently of #14159. Then this quick fix here could be merged in sage-5.8.rc0 while #14159 wouldn't. Would you mind if I create a patch?",
    "created_at": "2013-03-11T14:21:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175734",
    "user": "jdemeyer"
}
```

But I would really like a quick fix independently of #14159. Then this quick fix here could be merged in sage-5.8.rc0 while #14159 wouldn't. Would you mind if I create a patch?



---

archive/issue_comments_175735.json:
```json
{
    "body": "Replying to [comment:31 jdemeyer]:\n> But I would really like a quick fix independently of #14159. Then this quick fix here could be merged in sage-5.8.rc0 while #14159 wouldn't. Would you mind if I create a patch?\n\nNo, I wouldn't mind (rebasing #14159 should be easy enough).\n\nBut how can one change the id() thingy in sage/categories/homset.py? After all, it is a Python file, hence, one can not just do `<size_t><void*>X`.",
    "created_at": "2013-03-11T14:23:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175735",
    "user": "SimonKing"
}
```

Replying to [comment:31 jdemeyer]:
> But I would really like a quick fix independently of #14159. Then this quick fix here could be merged in sage-5.8.rc0 while #14159 wouldn't. Would you mind if I create a patch?

No, I wouldn't mind (rebasing #14159 should be easy enough).

But how can one change the id() thingy in sage/categories/homset.py? After all, it is a Python file, hence, one can not just do `<size_t><void*>X`.



---

archive/issue_comments_175736.json:
```json
{
    "body": "Replying to [comment:32 SimonKing]:\n> But how can one change the id() thingy in sage/categories/homset.py? After all, it is a Python file, hence, one can not just do `<size_t><void*>X`.\nYou can't, but you could write a small function to do just this in `coerce_dict.pyx` for example.",
    "created_at": "2013-03-11T14:24:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175736",
    "user": "jdemeyer"
}
```

Replying to [comment:32 SimonKing]:
> But how can one change the id() thingy in sage/categories/homset.py? After all, it is a Python file, hence, one can not just do `<size_t><void*>X`.
You can't, but you could write a small function to do just this in `coerce_dict.pyx` for example.



---

archive/issue_comments_175737.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-03-11T14:57:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175737",
    "user": "jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_175738.json:
```json
{
    "body": "Attachment [14254_signed_id.patch](tarball://root/attachments/some-uuid/ticket14254/14254_signed_id.patch) by jdemeyer created at 2013-03-11 14:57:20",
    "created_at": "2013-03-11T14:57:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175738",
    "user": "jdemeyer"
}
```

Attachment [14254_signed_id.patch](tarball://root/attachments/some-uuid/ticket14254/14254_signed_id.patch) by jdemeyer created at 2013-03-11 14:57:20



---

archive/issue_comments_175739.json:
```json
{
    "body": "The patch looks fine to me, and it applies cleanly after #13387. Now I wonder what the patchbots have to tell.\n\nProblem: I have no 32-bit machine available. Will the machines on which you first noticed the problem report here, in the hopefully green) blob?",
    "created_at": "2013-03-11T15:17:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175739",
    "user": "SimonKing"
}
```

The patch looks fine to me, and it applies cleanly after #13387. Now I wonder what the patchbots have to tell.

Problem: I have no 32-bit machine available. Will the machines on which you first noticed the problem report here, in the hopefully green) blob?



---

archive/issue_comments_175740.json:
```json
{
    "body": "Replying to [comment:36 SimonKing]:\n> Will the machines on which you first noticed the problem report here, in the (hopefully green) blob?\nI don't think so.\n\nIn any case, the machine in question managed to build the documentation without errors, so that's a good sign. I'm running tests now, but it's a slow machine so I'll report back tomorrow.\n\nRegardless, I think you can review the patch without access to a 32-bit system and assume that I have done my duty in testing the patch.",
    "created_at": "2013-03-11T15:41:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175740",
    "user": "jdemeyer"
}
```

Replying to [comment:36 SimonKing]:
> Will the machines on which you first noticed the problem report here, in the (hopefully green) blob?
I don't think so.

In any case, the machine in question managed to build the documentation without errors, so that's a good sign. I'm running tests now, but it's a slow machine so I'll report back tomorrow.

Regardless, I think you can review the patch without access to a 32-bit system and assume that I have done my duty in testing the patch.



---

archive/issue_comments_175741.json:
```json
{
    "body": "Replying to [comment:30 SimonKing]:\n> > {{{\n> > _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))\n> > }}}\n> > Bingo!  That's the problem indeed.\n> OK. Then it is solved in #14159, I suppose.\n\nGood work guys! That line made me feel uncomfortable when I was reviewing it, because it was reaching into implementation details of `_cache.eraser` and indeed, it *wasn't* properly doing that, in a way I did not spot. This is even more confirmation that #14159 is the right solution and not just over-engineering.",
    "created_at": "2013-03-11T16:19:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175741",
    "user": "nbruin"
}
```

Replying to [comment:30 SimonKing]:
> > {{{
> > _cache[key] = KeyedRef(H, _cache.eraser, (id(X),id(Y),id(category)))
> > }}}
> > Bingo!  That's the problem indeed.
> OK. Then it is solved in #14159, I suppose.

Good work guys! That line made me feel uncomfortable when I was reviewing it, because it was reaching into implementation details of `_cache.eraser` and indeed, it *wasn't* properly doing that, in a way I did not spot. This is even more confirmation that #14159 is the right solution and not just over-engineering.



---

archive/issue_comments_175742.json:
```json
{
    "body": "OK, I believe Jeroen when he says that building the documentation on his 32-bit systems works with the patch, while it reproducibly failed without the patch.\n\nI think the solution makes sense: id(X) returns a positive number, and this may very well be beyond what a signed number type of the same size (such as Py_ssize_t) can take.\n\nThe patchbot gives a green blob, too. Hence, I hope it is safe to give this a positive review (but I think #14159 will be better, on the long run).",
    "created_at": "2013-03-11T16:31:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175742",
    "user": "SimonKing"
}
```

OK, I believe Jeroen when he says that building the documentation on his 32-bit systems works with the patch, while it reproducibly failed without the patch.

I think the solution makes sense: id(X) returns a positive number, and this may very well be beyond what a signed number type of the same size (such as Py_ssize_t) can take.

The patchbot gives a green blob, too. Hence, I hope it is safe to give this a positive review (but I think #14159 will be better, on the long run).



---

archive/issue_comments_175743.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-03-11T16:31:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175743",
    "user": "SimonKing"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_175744.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-03-13T10:51:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14050",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14050#issuecomment-175744",
    "user": "jdemeyer"
}
```

Resolution: fixed
