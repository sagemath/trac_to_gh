# Issue 30224: Fully-commutative stable Grothendieck crystal

Issue created by migration from https://trac.sagemath.org/ticket/30461

Original creator: wpoh

Original creation time: 2020-08-28 23:11:35

CC:  aschilling jppan tscrim

Keywords: crystal

Implementation of the crystal on fully-commutative decreasing factorizations in the 0-Hecke monoid. See https://arxiv.org/abs/1911.08732.


---

Comment by wpoh created at 2020-08-31 20:03:37

New commits:


---

Comment by git created at 2020-09-08 03:17:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-08 23:30:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-09 03:56:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-10 01:45:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-10 08:40:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-11 19:39:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-11 21:08:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-13 00:20:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-13 00:37:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-13 02:48:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by wpoh created at 2020-09-13 04:35:20

Changing status from new to needs_review.


---

Comment by chapoton created at 2020-09-13 07:03:00

Samll remarks.

Avoid having only TESTS:: in any non-underscored method, because the doc will be empty.

This

```
w.reduced_word()==[]
```

could be

```
not w.reduced_word()
```

which is faster.


```
+    Lists all words
```

should be

```
+    List all words
```



```
+    while len(queue) > 0:
```

could be

```
while queue:
```



---

Comment by git created at 2020-09-13 17:43:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-09-13 18:08:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2020-09-14 18:49:31

failing doctests in src/sage/misc/dev_tools.py

This seems to be due to a side effect of importing HeckeMonoid here.


---

Comment by git created at 2020-09-15 01:20:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-09-15 01:21:54

Looks good. Thank you for this addition.

Some additional comments to Frédéric's:

`fully_commutative_stable_grothendieck.py` is missing the file header information (module-level docstring, copyright, etc.).

You could have `DecreasingHeckeFactorization` inherit from `SageObject` (maybe `tuple`). Also, the inequality probably won't work (perhaps even some of the other inequalities). Using the `_richcmp_` (there is a decorator to add this) would simplify this.

In the `__repr__`, why do you do the `list` cast here: `repr(list(factor))[1:-1]`?

Do you really expect this:

```
            if not isinstance(parent, FullyCommutativeStableGrothendieckCrystal):
                raise ValueError("parent should be an instance of FullyCommutativeStableGrothendieckCrystal")
```

It seems like it would be mostly useless.

It would be good to avoid going through the coercion framework and element constructor and just directly create the element:

```diff
-self.parent()(s)
+P = self.parent()
+P.element_class(P, s)
```

This is good for speed.

Error messages should start with a lowercase:

```diff
-raise ValueError("Each nonempty factor should be a strictly decreasing sequence")
+raise ValueError("each nonempty factor should be a strictly decreasing sequence")
```

This is a Python convention that we try to follow.

You don't need the list here (I think it is actually slightly slower):

```diff
-m = max([cell[0] for cell in cells])+1
+m = max(cell[0] for cell in cells) + 1
```

(and in similar other places).


```diff
-for i in range(m)[::-1]:
+for i in range(m-1,-1,-1):
```


I believe you can do this:

```
-if p not in Permutations(avoiding=[3,2,1]):
+if p.has_pattern([3,2,1]):
```

to avoid the transient parent (and some extra unnecessary containment checks).


```diff
-if m == None or (len(_jumps(w))<=m-1):
+if m is None or len(_jumps(w)) <= m-1:
```


I think it would be good to avoid creating the tableau and then its conjugate in `_is_valid_column_word`:

```python
            T = Tableau(L)
            return T.conjugate().is_semistandard()
```

I would just go through and check everything directly in `L`.


---

Comment by git created at 2020-09-15 02:01:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-09-15 03:03:43

This can be simplified:

```diff
-            for i in range(len(L)-1):
-                for j in range(len(L[i+1])):
-                    if L[i+1][j]<L[i][j]:
-                        return False
-            return True
+            return not any(L[i+1][j] < L[i][j] for i in range(len(L)-1)
+                           for j in range(len(L[i+1])))
```

or

```diff
+            return all(L[i+1][j] >= L[i][j] for i in range(len(L)-1)
+                       for j in range(len(L[i+1])))
```

(Interestingly enough the latter is actually faster.)


---

Comment by git created at 2020-09-15 03:33:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by wpoh created at 2020-09-15 03:52:02

Thanks a lot for looking through the code, Travis. Appreciate the suggestions on syntax, speedups, SageMath-specific infrastructure, etc.

Replying to [comment:18 tscrim]:
> You could have `DecreasingHeckeFactorization` inherit from `SageObject` (maybe `tuple`). Also, the inequality probably won't work (perhaps even some of the other inequalities). Using the `_richcmp_` (there is a decorator to add this) would simplify this.
Thank you for the suggestions. I used the following guide for `__richcmp__`, do correct me if the syntax does not look right:
https://doc.sagemath.org/html/en/reference/structure/sage/structure/richcmp.html

> In the `__repr__`, why do you do the `list` cast here: `repr(list(factor))[1:-1]`?
It was to have the `__repr__` print
`()(2, 1)(2)()(2)`
rather than 
`()(2, 1)(2,)()(2,)`
for factors with single values. That behavior has been changed now. I'm maintaining the list casting for the _latex_ method though as it looks prettier. =)

> Do you really expect this:
> {{{
>             if not isinstance(parent, FullyCommutativeStableGrothendieckCrystal):
>                 raise ValueError("parent should be an instance of FullyCommutativeStableGrothendieckCrystal")
> }}}
> It seems like it would be mostly useless.
No, so this has been removed.


---

Comment by tscrim created at 2020-09-15 23:21:26

Replying to [comment:22 wpoh]:
> Thanks a lot for looking through the code, Travis. Appreciate the suggestions on syntax, speedups, SageMath-specific infrastructure, etc.

Thank you for your changes.

> Replying to [comment:18 tscrim]:
> > You could have `DecreasingHeckeFactorization` inherit from `SageObject` (maybe `tuple`). Also, the inequality probably won't work (perhaps even some of the other inequalities). Using the `_richcmp_` (there is a decorator to add this) would simplify this.
> Thank you for the suggestions. I used the following guide for `__richcmp__`, do correct me if the syntax does not look right:
> https://doc.sagemath.org/html/en/reference/structure/sage/structure/richcmp.html

Looks good. Thanks. Can you add a test showing that the `!=` works as expected?

> > In the `__repr__`, why do you do the `list` cast here: `repr(list(factor))[1:-1]`?
> It was to have the `__repr__` print
> `()(2, 1)(2)()(2)`
> rather than 
> `()(2, 1)(2,)()(2,)`
> for factors with single values. That behavior has been changed now. I'm maintaining the list casting for the _latex_ method though as it looks prettier. =)

That is a good point; I forgot about the singletons. For the `__repr__` it would make sense to do it like how you had before. Also, since `DecreasingHeckeFactorization` now inherits from `SageObject`, you should rename `__repr__` -> `_repr_`.

I have a few more additional comments:


```diff
-return tuple(len(l) for l in self.value)[::-1]
+return tuple([len(l) for l in reversed(self.value)])
```


Yes, having the list here is strangely faster.


```diff
-if len(factor)>0:
+if factor:
```


Instead of using both `Partition, Partitions`, you can just use the global parent of all partitions `_Partitions`. Also, I thought `SkewPartition` would parse its inputs into a pair of partitions?

This is strange to me:

```
class Element(DecreasingHeckeFactorization, ElementWrapper):
```

Why inherit from both? Why not just wrap the `DecreasingHeckeFactorization` or inherit from `Element` instead of `ElementWrapper` since I believe the wrapping is basically done by `DecreasingHeckeFactorization`.


---

Comment by git created at 2020-09-16 01:38:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by wpoh created at 2020-09-16 04:35:48

Thank you for the further comments. I've pushed all the changes according to the previous suggestions, except for the one on the `Element` class (see below).

Replying to [comment:23 tscrim]:
> > Replying to [comment:18 tscrim]:
> > > You could have `DecreasingHeckeFactorization` inherit from `SageObject` (maybe `tuple`). Also, the inequality probably won't work (perhaps even some of the other inequalities). Using the `_richcmp_` (there is a decorator to add this) would simplify this.
> > Thank you for the suggestions. I used the following guide for `__richcmp__`, do correct me if the syntax does not look right:
> > https://doc.sagemath.org/html/en/reference/structure/sage/structure/richcmp.html
> 
> Looks good. Thanks. Can you add a test showing that the `!=` works as expected?
I've added a test in the `__init__` for `DecreasingHeckeFactorization`.

> Instead of using both `Partition, Partitions`, you can just use the global parent of all partitions `_Partitions`. Also, I thought `SkewPartition` would parse its inputs into a pair of partitions?
Both remarks make sense. The code looks better now.

> This is strange to me:
> {{{
> class Element(DecreasingHeckeFactorization, ElementWrapper):
> }}}
> Why inherit from both? Why not just wrap the `DecreasingHeckeFactorization` or inherit from `Element` instead of `ElementWrapper` since I believe the wrapping is basically done by `DecreasingHeckeFactorization`.
The code was more or less adopted from `affine_factorization.py` in the `combinat/crystal` folder. The original intention is to inherit the methods (eg. `weight`) that come with `DecreasingHeckeFactorization` while having access to `parent` from `ElementWrapper`.

I am not so familiar with the difference between `ElementWrapper` and `Element`, but trying
for example


```
class Element(ElementWrapper):
    def __init__()
        # Do something to validate and process t into 
        # an instance of DecreasingHeckeFactorization u
        ElementWrapper.__init__(self, parent, u)
```


and making minor changes in `e`, `f`, `bracketing` in the same class somehow gives the following unexpected behavior for `weight`:


```
sage: S = SymmetricGroup(3+1)
sage: w = S.from_reduced_word([1, 3, 2])
sage: B = crystals.FullyCommutativeStableGrothendieck(w, 3, 2)
sage: h = B([[3, 1], [3], [3, 2]]); h
(3, 1)(3)(3, 2)
sage: h.weight()
(0, -1, 0) # expected (2, 1, 2)
```



---

Comment by tscrim created at 2020-09-16 23:56:52

Replying to [comment:25 wpoh]:
> Thank you for the further comments. I've pushed all the changes according to the previous suggestions, except for the one on the `Element` class (see below).

Thank you.

> > This is strange to me:
> > {{{
> > class Element(DecreasingHeckeFactorization, ElementWrapper):
> > }}}
> > Why inherit from both? Why not just wrap the `DecreasingHeckeFactorization` or inherit from `Element` instead of `ElementWrapper` since I believe the wrapping is basically done by `DecreasingHeckeFactorization`.
> The code was more or less adopted from `affine_factorization.py` in the `combinat/crystal` folder. The original intention is to inherit the methods (eg. `weight`) that come with `DecreasingHeckeFactorization` while having access to `parent` from `ElementWrapper`.
> 
> I am not so familiar with the difference between `ElementWrapper` and `Element`, but trying
> for example
> 
> {{{
> class Element(ElementWrapper):
>     def __init__()
>         # Do something to validate and process t into 
>         # an instance of DecreasingHeckeFactorization u
>         ElementWrapper.__init__(self, parent, u)
> }}}
> 
> and making minor changes in `e`, `f`, `bracketing` in the same class somehow gives the following unexpected behavior for `weight`:
> 
> {{{
> sage: S = SymmetricGroup(3+1)
> sage: w = S.from_reduced_word([1, 3, 2])
> sage: B = crystals.FullyCommutativeStableGrothendieck(w, 3, 2)
> sage: h = B([[3, 1], [3], [3, 2]]); h
> (3, 1)(3)(3, 2)
> sage: h.weight()
> (0, -1, 0) # expected (2, 1, 2)
> }}}

Without seeing what your code is, I cannot comment. You can look at the `ElementWrapper` class and see what extra features it builds upon. However, from what you (and the code) are telling me, you do not want to wrap `DecreasingHeckeFactorization` but extend its functionality, which means it should subclass it. You wrap an object if you want it to behave differently than the corresponding class, but you need the data structure and/or some functionality. Right now your code is somehow in between and you might need to disentangle it a bit.

Actually, I am starting to wonder a bit why you need the separate class. If it inherits from `Element`(`Wrapper`), then it doesn't need the ``@`richcmp_method` decorator. Why do you need the `DecreasingHeckeFactorization` to not be a subclass of `Element`?

----

Some little nitpicks with style (it wouldn't stop a positive review, but it is good to follow):

```diff
-    k, D = max(w), {}
+    k = max(w)
+    D = {}
```


```diff
-if all(len(L[i])>=len(L[i+1]) for i in range(len(L)-1)):
+if all(len(L[i]) >= len(L[i+1]) for i in range(len(L)-1)):
```


```diff
-if p==r and q!=p and abs(p-q)==1:
+if p == r and q != p and abs(p-q) == 1:
```


```diff
-t = _apply_relations(v,position,move)
+t = _apply_relations(v, position, move)
```

and similar.

More micro-optimizations: For `_applicable_relations`, I would do:

```python
    def _applicable_relations(word):
        """
        Return all positions where a relation can be applied on ``word``
        along with the type of relation.
        """
        L = []
        for i in range(len(word)-2):
            p, q, r = word[i:(i+2)+1]
            if abs(p-q) > 1:
                L += [[i,"pq=qp"]]
            elif abs(p-q) == 1:
                if p == r:  # p != q by the abs test
                    L += [[i,"pqp=qpq"]]
            elif r != p:  # We must have p == q
                L += [[i,"ppq=pqq"]]
            if q == r and r != p:
                L += [[i,"pqq=ppq"]]
        if abs(word[-2]-word[-1]) > 1:
           L += [[len(word)-2,"pq=qp"]]
        return L
```

The first is removing the unless if statements and pulling the last case outside of the loop. The second is removing redundant checks for the different relations.

I think this can be simplified:

```diff
-w[J[i]:J[i+1]][::-1]
+w[J[i+1]-1:J[i]-1:-1]
```


In `_apply_relations()`, do you need those checks? They are good for when debugging, but the first index errors will be thrown naturally by Python. The other errors checking the relations apply also feel more for debugging than a practical-use.

Your doc is not building because you need to make this change:

```diff
-Remove all bracketed letters between `i`th and `(i+1)`th entry.
+Remove all bracketed letters between `i`-th and `(i+1)`-th entry.
```



---

Comment by git created at 2020-09-21 05:48:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by wpoh created at 2020-09-21 06:05:07

Thanks again for the further comments. I have pushed all the changes according to the suggestions.

Replying to [comment:26 tscrim]:
> Actually, I am starting to wonder a bit why you need the separate class. If it inherits from `Element`(`Wrapper`), then it doesn't need the ``@`richcmp_method` decorator. Why do you need the `DecreasingHeckeFactorization` to not be a subclass of `Element`?
There are decreasing factorizations associated to non-fully commutative permutations, so I was hesitant to put it directly in the `Element` class of the parent class `FullyCommutativeStableGrothendieck`. However, writing `DecreasingHeckeFactorization` as a separate class and letting it inherit from `Element` does seem to work for our purposes, and I've added a parent class `DecreasingHeckeFactorizations` (with related methods) for the benefit of future explorations on non-fully commutative decreasing factorizations.

Also, I need `__classcall_private__` for `DecreasingHeckeFactorization` to be called before the `__init__` method so that the proper parent class is initialized, do let me know if using `metaclass=InheritComparisonClasscallMetaclass` is not appropriate.

> In `_apply_relations()`, do you need those checks? They are good for when debugging, but the first index errors will be thrown naturally by Python. The other errors checking the relations apply also feel more for debugging than a practical-use.
You're right that they were there mainly for debugging. I've removed the error handling.


---

Comment by git created at 2020-09-22 21:50:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2020-09-23 04:40:47

Replying to [comment:28 wpoh]:
> Thanks again for the further comments. I have pushed all the changes according to the suggestions.
> 
> Replying to [comment:26 tscrim]:
> > Actually, I am starting to wonder a bit why you need the separate class. If it inherits from `Element`(`Wrapper`), then it doesn't need the ``@`richcmp_method` decorator. Why do you need the `DecreasingHeckeFactorization` to not be a subclass of `Element`?
> There are decreasing factorizations associated to non-fully commutative permutations, so I was hesitant to put it directly in the `Element` class of the parent class `FullyCommutativeStableGrothendieck`. However, writing `DecreasingHeckeFactorization` as a separate class and letting it inherit from `Element` does seem to work for our purposes, and I've added a parent class `DecreasingHeckeFactorizations` (with related methods) for the benefit of future explorations on non-fully commutative decreasing factorizations.

Making this into a separate `Parent`/`Element` is overkill IMO. You don't need it now and it makes the code much more complicated. What I was suggesting was simply having `DecreasingHeckeFactorization` be the element class for the crystal. Perhaps I was unclear about this. The crystal seems sufficient for the current purposes, and anything else you can add to the Hecke monoid elements.

> Also, I need `__classcall_private__` for `DecreasingHeckeFactorization` to be called before the `__init__` method so that the proper parent class is initialized, do let me know if using `metaclass=InheritComparisonClasscallMetaclass` is not appropriate.

I don't see any reason why you should need this. It seems like you are fighting code that is trying to tell you to make it more simple. Have I missed something?


---

Comment by aschilling created at 2020-09-25 06:13:37

Replying to [comment:30 tscrim]:
> Replying to [comment:28 wpoh]:
> > Thanks again for the further comments. I have pushed all the changes according to the suggestions.
> > 
> > Replying to [comment:26 tscrim]:
> > > Actually, I am starting to wonder a bit why you need the separate class. If it inherits from `Element`(`Wrapper`), then it doesn't need the ``@`richcmp_method` decorator. Why do you need the `DecreasingHeckeFactorization` to not be a subclass of `Element`?
> > There are decreasing factorizations associated to non-fully commutative permutations, so I was hesitant to put it directly in the `Element` class of the parent class `FullyCommutativeStableGrothendieck`. However, writing `DecreasingHeckeFactorization` as a separate class and letting it inherit from `Element` does seem to work for our purposes, and I've added a parent class `DecreasingHeckeFactorizations` (with related methods) for the benefit of future explorations on non-fully commutative decreasing factorizations.
> 
> Making this into a separate `Parent`/`Element` is overkill IMO. You don't need it now and it makes the code much more complicated. What I was suggesting was simply having `DecreasingHeckeFactorization` be the element class for the crystal. Perhaps I was unclear about this. The crystal seems sufficient for the current purposes, and anything else you can add to the Hecke monoid elements.

Sorry for the slow response. I could not compile Sage for a while due to Xcode12. 

We need this for the insertion algorithm implemented in #30460 unless the insertion takes as input crystal elements rather than decreasing factorizations.


---

Comment by tscrim created at 2020-09-28 04:20:10

Replying to [comment:31 aschilling]:
> Replying to [comment:30 tscrim]:
> > Making this into a separate `Parent`/`Element` is overkill IMO. You don't need it now and it makes the code much more complicated. What I was suggesting was simply having `DecreasingHeckeFactorization` be the element class for the crystal. Perhaps I was unclear about this. The crystal seems sufficient for the current purposes, and anything else you can add to the Hecke monoid elements.
> 
> Sorry for the slow response. I could not compile Sage for a while due to Xcode12. 
> 
> We need this for the insertion algorithm implemented in #30460 unless the insertion takes as input crystal elements rather than decreasing factorizations.

I don't see why the insertion could not take the crystal elements. So it still feels a little over-engineered, but it is good enough for now as the element class hierarchy doesn't have any duplication.


---

Comment by tscrim created at 2020-09-28 04:20:10

Changing status from needs_review to positive_review.


---

Comment by aschilling created at 2020-09-28 04:29:24

Thank you for the review, Travis!


---

Comment by tscrim created at 2020-09-28 04:36:49

Replying to [comment:33 aschilling]:
> Thank you for the review, Travis!

No problem. Sorry it took a little longer for me to get to it. I will be on the lookout for when #30460 is ready.


---

Comment by vbraun created at 2020-10-05 20:13:22

Resolution: fixed
