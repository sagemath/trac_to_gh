# Issue 13700: Proper deletion of items of TripleDict

archive/issues_013700.json:
```json
{
    "body": "Assignee: @rlmill\n\nCC:  @nbruin @vbraun jpflori\n\nIn #715, `TripleDict` has been modified, so that the key items are compared by identity rather than equality, and so that weak keys are used when possible.\n\nHowever, as it turns out, the deletion of the items tracked in a `TripleDict` was done improperly. The aim of this ticket is to fix that.\n\nIssue created by migration from https://trac.sagemath.org/ticket/13904\n\n",
    "created_at": "2013-01-03T18:16:33Z",
    "labels": [
        "component: memleak",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "Proper deletion of items of TripleDict",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13700",
    "user": "https://github.com/simon-king-jena"
}
```
Assignee: @rlmill

CC:  @nbruin @vbraun jpflori

In #715, `TripleDict` has been modified, so that the key items are compared by identity rather than equality, and so that weak keys are used when possible.

However, as it turns out, the deletion of the items tracked in a `TripleDict` was done improperly. The aim of this ticket is to fix that.

Issue created by migration from https://trac.sagemath.org/ticket/13904





---

archive/issue_comments_169659.json:
```json
{
    "body": "Attachment [trac_13904_fix_del.patch](tarball://root/attachments/some-uuid/ticket13904/trac_13904_fix_del.patch) by @simon-king-jena created at 2013-01-03 18:25:51\n\nAttempt to fix `TripleDict.__delitem__`",
    "created_at": "2013-01-03T18:25:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169659",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_13904_fix_del.patch](tarball://root/attachments/some-uuid/ticket13904/trac_13904_fix_del.patch) by @simon-king-jena created at 2013-01-03 18:25:51

Attempt to fix `TripleDict.__delitem__`



---

archive/issue_comments_169660.json:
```json
{
    "body": "There's the more severe problem that during GC cleanup, a weakref callback could lead to the deletion of a non-weakreffable key, which could retrigger the dealloc of the object that has just generated the weakref. That would lead to a double dealloc.\n\nThe following might be a solution:\n- equip TripleDict with an attribute `self.deathrow=[]`.\n- when TripleDictEraser finds itself removing a non-weakreffed key (other than None, int, float, etc), it appends the key to `self.deathrow` instead.\nThis way, we don't trigger the deletion (and the whole cascade that may follow) in the callback.\n\nDeathrow will be cleaned up eventually, as part of the regular cleanup code for deallocation of TripleDict.\n\nThe problem is that weakref callback operates in a strange environment: There is a dealloc call higher up the stack somewhere. Normally python code doesn't run under those circumstances. It shouldn't make much difference, but you should *absolutely not* delete that object again. Hence, I think the default should be: Don't delete objects in callback. You can modify this rule, but only on a case-by-case basis, by carefully reasoning that the deletions that you do allow won't lead to nasty unpredictable deletion cascades.",
    "created_at": "2013-01-03T18:39:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169660",
    "user": "https://github.com/nbruin"
}
```

There's the more severe problem that during GC cleanup, a weakref callback could lead to the deletion of a non-weakreffable key, which could retrigger the dealloc of the object that has just generated the weakref. That would lead to a double dealloc.

The following might be a solution:
- equip TripleDict with an attribute `self.deathrow=[]`.
- when TripleDictEraser finds itself removing a non-weakreffed key (other than None, int, float, etc), it appends the key to `self.deathrow` instead.
This way, we don't trigger the deletion (and the whole cascade that may follow) in the callback.

Deathrow will be cleaned up eventually, as part of the regular cleanup code for deallocation of TripleDict.

The problem is that weakref callback operates in a strange environment: There is a dealloc call higher up the stack somewhere. Normally python code doesn't run under those circumstances. It shouldn't make much difference, but you should *absolutely not* delete that object again. Hence, I think the default should be: Don't delete objects in callback. You can modify this rule, but only on a case-by-case basis, by carefully reasoning that the deletions that you do allow won't lead to nasty unpredictable deletion cascades.



---

archive/issue_comments_169661.json:
```json
{
    "body": "I don't think we need this ticket for the `__delitem__` optimization. That can be wrapped into #13387.",
    "created_at": "2013-01-03T18:41:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169661",
    "user": "https://github.com/nbruin"
}
```

I don't think we need this ticket for the `__delitem__` optimization. That can be wrapped into #13387.



---

archive/issue_comments_169662.json:
```json
{
    "body": "Nils, indeed it might be an idea to use the ideas from #13387. However, the ticket here is not about optimization.\n\nAnyway.\n\nI am starting with Sage's debug version as in #13864. With the first patch applied, one gets a crash in modules/module.pyx\n\nWith both patches applied, one gets\n\n```\nsage -t  \"devel/sage-main/sage/modules/module.pyx\"          \n         [3.5 s]\n```\nSo, that looks like a progress.\n\nHowever, at least with a slightly different version of the first patch, make ptest still results in\n\n```\n        sage -t  -force_lib devel/sage/sage/schemes/elliptic_curves/ell_point.py # Killed/crashed\n        sage -t  -force_lib devel/sage/sage/algebras/free_algebra_quotient.py # Killed/crashed\n        sage -t  -force_lib devel/sage/sage/algebras/free_algebra_quotient_element.py # Killed/crashed\n        sage -t  -force_lib devel/sage/sage/categories/modules_with_basis.py # Killed/crashed\n        sage -t  -force_lib devel/sage/sage/categories/homset.py # 1 doctests failed\n```\nwhen both patches are applied. Note, however, that I can *not* reproduce these crashes when I run them independently.\n\nHence, one needs to dig deeper. See comment:1.",
    "created_at": "2013-01-03T18:46:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169662",
    "user": "https://github.com/simon-king-jena"
}
```

Nils, indeed it might be an idea to use the ideas from #13387. However, the ticket here is not about optimization.

Anyway.

I am starting with Sage's debug version as in #13864. With the first patch applied, one gets a crash in modules/module.pyx

With both patches applied, one gets

```
sage -t  "devel/sage-main/sage/modules/module.pyx"          
         [3.5 s]
```
So, that looks like a progress.

However, at least with a slightly different version of the first patch, make ptest still results in

```
        sage -t  -force_lib devel/sage/sage/schemes/elliptic_curves/ell_point.py # Killed/crashed
        sage -t  -force_lib devel/sage/sage/algebras/free_algebra_quotient.py # Killed/crashed
        sage -t  -force_lib devel/sage/sage/algebras/free_algebra_quotient_element.py # Killed/crashed
        sage -t  -force_lib devel/sage/sage/categories/modules_with_basis.py # Killed/crashed
        sage -t  -force_lib devel/sage/sage/categories/homset.py # 1 doctests failed
```
when both patches are applied. Note, however, that I can *not* reproduce these crashes when I run them independently.

Hence, one needs to dig deeper. See comment:1.



---

archive/issue_comments_169663.json:
```json
{
    "body": "Replying to [comment:1 nbruin]:\n> There's the more severe problem that during GC cleanup, a weakref callback could lead to the deletion of a non-weakreffable key, which could retrigger the dealloc of the object that has just generated the weakref. That would lead to a double dealloc.\n\n\nAh, you say that the problem actually isn't so much the `__delitem__` but the callback? OK, I'll have a look into that. And of course we should try to rebase #13387.",
    "created_at": "2013-01-03T18:49:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169663",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:1 nbruin]:
> There's the more severe problem that during GC cleanup, a weakref callback could lead to the deletion of a non-weakreffable key, which could retrigger the dealloc of the object that has just generated the weakref. That would lead to a double dealloc.


Ah, you say that the problem actually isn't so much the `__delitem__` but the callback? OK, I'll have a look into that. And of course we should try to rebase #13387.



---

archive/issue_comments_169664.json:
```json
{
    "body": "Oops, I just notice that the patch attempts to fix `TripleDictEraser.__call__`, hence, the callback, but not `TripleDict.__delitem__`. So, I *did* have a look into the callback function...",
    "created_at": "2013-01-03T18:57:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169664",
    "user": "https://github.com/simon-king-jena"
}
```

Oops, I just notice that the patch attempts to fix `TripleDictEraser.__call__`, hence, the callback, but not `TripleDict.__delitem__`. So, I *did* have a look into the callback function...



---

archive/issue_comments_169665.json:
```json
{
    "body": "Replying to [comment:4 SimonKing]:\n> Ah, you say that the problem actually isn't so much the `__delitem__` but the callback? OK, I'll have a look into that. And of course we should try to rebase #13387.\n\n\nThe `__delitem__` isn't *wrong*. It just happens to be slightly more memory intensive that the straight `del`, so it happened to trigger a GC. The crash was due to Cython not handling GC during deallocation properly. That's getting fixed with #13896. The potential issue I described above hasn't been observed. I suspect that one could engineer an example. Perhaps one should (Robert's cython test case for #13896 can serve as a template). It's just that memory management is such a sensitive business that one should really (informally) prove bad scenarios can't happen rather than wait until they do. I think the scenario I describe can happen and I don't see what measures in the python code would prevent it.\n\nOne way to solve this would be to forbid non-weakreffable container types to be used as keys. The problem is that I can't think of a reliable test for that. Since the consequences of violating might lead to incredibly insidious memory corruptions, I think we should guard against it. A consequence is that any non-weakreffable (non-whitelisted such as None or int) key automatically has its life span bounded below by the lifetime of the `TripleDict`, even if the entry in which it served got removed due to a weakref dying (explicit key deletions would be fine). I don't see how we could get hold of a hook where clearing `deathrow` would be safe.",
    "created_at": "2013-01-03T19:42:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169665",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:4 SimonKing]:
> Ah, you say that the problem actually isn't so much the `__delitem__` but the callback? OK, I'll have a look into that. And of course we should try to rebase #13387.


The `__delitem__` isn't *wrong*. It just happens to be slightly more memory intensive that the straight `del`, so it happened to trigger a GC. The crash was due to Cython not handling GC during deallocation properly. That's getting fixed with #13896. The potential issue I described above hasn't been observed. I suspect that one could engineer an example. Perhaps one should (Robert's cython test case for #13896 can serve as a template). It's just that memory management is such a sensitive business that one should really (informally) prove bad scenarios can't happen rather than wait until they do. I think the scenario I describe can happen and I don't see what measures in the python code would prevent it.

One way to solve this would be to forbid non-weakreffable container types to be used as keys. The problem is that I can't think of a reliable test for that. Since the consequences of violating might lead to incredibly insidious memory corruptions, I think we should guard against it. A consequence is that any non-weakreffable (non-whitelisted such as None or int) key automatically has its life span bounded below by the lifetime of the `TripleDict`, even if the entry in which it served got removed due to a weakref dying (explicit key deletions would be fine). I don't see how we could get hold of a hook where clearing `deathrow` would be safe.



---

archive/issue_comments_169666.json:
```json
{
    "body": "Replying to [comment:1 nbruin]:\n> There's the more severe problem that during GC cleanup, a weakref callback could lead to the deletion of a non-weakreffable key, which could retrigger the dealloc of the object that has just generated the weakref. That would lead to a double dealloc.\n\n\nIs what you describe as follows?\n\nLet's say we have a key `(A,B,C)`, where `A` is weakrefed and got deleted, so that the key `(A,B,C)` gets removed by means of `A`'s callback function. Now let `B` be non-weakrefable. Assume further that the key triple is the last reference to B, and assume that `B` has an attribute that constitutes a (strong? weak?) reference to `A`. Then, deletion of `B` would trigger a second deletion of `A`.\n\nOr did I misunderstand? Can you elaborate a bit more, please?",
    "created_at": "2013-01-03T19:53:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169666",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:1 nbruin]:
> There's the more severe problem that during GC cleanup, a weakref callback could lead to the deletion of a non-weakreffable key, which could retrigger the dealloc of the object that has just generated the weakref. That would lead to a double dealloc.


Is what you describe as follows?

Let's say we have a key `(A,B,C)`, where `A` is weakrefed and got deleted, so that the key `(A,B,C)` gets removed by means of `A`'s callback function. Now let `B` be non-weakrefable. Assume further that the key triple is the last reference to B, and assume that `B` has an attribute that constitutes a (strong? weak?) reference to `A`. Then, deletion of `B` would trigger a second deletion of `A`.

Or did I misunderstand? Can you elaborate a bit more, please?



---

archive/issue_comments_169667.json:
```json
{
    "body": "Replying to [comment:7 SimonKing]:\n> Let's say we have a key `(A,B,C)`, where `A` is weakrefed and got deleted, so that the key `(A,B,C)` gets removed by means of `A`'s callback function. Now let `B` be non-weakrefable. Assume further that the key triple is the last reference to B, and assume that `B` has an attribute that constitutes a (strong? weak?) reference to `A`. Then, deletion of `B` would trigger a second deletion of `A`.\n\n\nYes, that's correct. It would have to be a strong reference from B to A, because deletion of weakrefs should not trigger deletion cascades. Of course, that means the reference count to A isn't 0, so normally A would not be eligible for deletion ... but if A and B are found to be cyclic garbage, deallocation could still occur. We'd be at the mercy of GC for how the chain gets broken up and deleted.\n\nIn fact, moving B to `deathrow` could be tricky, because that would resurrect `B` (generally frowned upon), albeit only within the cyclic garbage. OK, I'll try and see if I can make a testcase that triggers this behaviour. At this point I don't even know how to fix this. Perhaps we should just forbid non-weakreffable keys that refer to another key component. Mind you, that forbids\n\n```\n(None, ZZ, ZZ(1) )\n```\nas a key, which doesn't immediately look completely unlikely. We don't generate keys like that, but someone else might ...",
    "created_at": "2013-01-03T20:06:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169667",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:7 SimonKing]:
> Let's say we have a key `(A,B,C)`, where `A` is weakrefed and got deleted, so that the key `(A,B,C)` gets removed by means of `A`'s callback function. Now let `B` be non-weakrefable. Assume further that the key triple is the last reference to B, and assume that `B` has an attribute that constitutes a (strong? weak?) reference to `A`. Then, deletion of `B` would trigger a second deletion of `A`.


Yes, that's correct. It would have to be a strong reference from B to A, because deletion of weakrefs should not trigger deletion cascades. Of course, that means the reference count to A isn't 0, so normally A would not be eligible for deletion ... but if A and B are found to be cyclic garbage, deallocation could still occur. We'd be at the mercy of GC for how the chain gets broken up and deleted.

In fact, moving B to `deathrow` could be tricky, because that would resurrect `B` (generally frowned upon), albeit only within the cyclic garbage. OK, I'll try and see if I can make a testcase that triggers this behaviour. At this point I don't even know how to fix this. Perhaps we should just forbid non-weakreffable keys that refer to another key component. Mind you, that forbids

```
(None, ZZ, ZZ(1) )
```
as a key, which doesn't immediately look completely unlikely. We don't generate keys like that, but someone else might ...



---

archive/issue_comments_169668.json:
```json
{
    "body": "Replying to [comment:1 nbruin]:\n> There's the more severe problem that during GC cleanup, a weakref callback could lead to the deletion of a non-weakreffable key, which could retrigger the dealloc of the object that has just generated the weakref. That would lead to a double dealloc.\n\n\nPS: Why can this only happen with a non-weakreffable key? In particular, what are the keys in our crashing example? Namely, in its current use, I don't think that there are any non-weakreffable keys other than None and ints.\n\n> The following might be a solution:\n> - equip TripleDict with an attribute `self.deathrow=[]`.\n> - when TripleDictEraser finds itself removing a non-weakreffed key (other than None, int, float, etc), it appends the key to `self.deathrow` instead.\n> This way, we don't trigger the deletion (and the whole cascade that may follow) in the callback.\n> \n> Deathrow will be cleaned up eventually, as part of the regular cleanup code for deallocation of TripleDict.\n> \n> The problem is that weakref callback operates in a strange environment: There is a dealloc call higher up the stack somewhere. Normally python code doesn't run under those circumstances. It shouldn't make much difference, but you should *absolutely not* delete that object again. Hence, I think the default should be: Don't delete objects in callback.\n\n\nOne could provide a new method `TripleDict.kill_deathrow`, that will be called in any other method of `TripleDict`. Hence, the deletions would occur when the `TripleDict` will be used another time, and in particular this will only happen *after* the \"dealloc call higher up the stack\" has been completed.\n\nPerhaps `kill_deathrow` could also be called at the beginning of the callback function - so that it performs the deletions that were scheduled by the preceding callback function.\n\nProblem could be a severe slow-down.",
    "created_at": "2013-01-03T20:13:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169668",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:1 nbruin]:
> There's the more severe problem that during GC cleanup, a weakref callback could lead to the deletion of a non-weakreffable key, which could retrigger the dealloc of the object that has just generated the weakref. That would lead to a double dealloc.


PS: Why can this only happen with a non-weakreffable key? In particular, what are the keys in our crashing example? Namely, in its current use, I don't think that there are any non-weakreffable keys other than None and ints.

> The following might be a solution:
> - equip TripleDict with an attribute `self.deathrow=[]`.
> - when TripleDictEraser finds itself removing a non-weakreffed key (other than None, int, float, etc), it appends the key to `self.deathrow` instead.
> This way, we don't trigger the deletion (and the whole cascade that may follow) in the callback.
> 
> Deathrow will be cleaned up eventually, as part of the regular cleanup code for deallocation of TripleDict.
> 
> The problem is that weakref callback operates in a strange environment: There is a dealloc call higher up the stack somewhere. Normally python code doesn't run under those circumstances. It shouldn't make much difference, but you should *absolutely not* delete that object again. Hence, I think the default should be: Don't delete objects in callback.


One could provide a new method `TripleDict.kill_deathrow`, that will be called in any other method of `TripleDict`. Hence, the deletions would occur when the `TripleDict` will be used another time, and in particular this will only happen *after* the "dealloc call higher up the stack" has been completed.

Perhaps `kill_deathrow` could also be called at the beginning of the callback function - so that it performs the deletions that were scheduled by the preceding callback function.

Problem could be a severe slow-down.



---

archive/issue_comments_169669.json:
```json
{
    "body": "Replying to [comment:9 SimonKing]:\n> PS: Why can this only happen with a non-weakreffable key? In particular, what are the keys in our crashing example? Namely, in its current use, I don't think that there are any non-weakreffable keys other than None and ints.\n\n\nThe cython-induced crash has only weakreffable keys. The hypothetical behaviour *has not been observed*.\n\n> One could provide a new method `TripleDict.kill_deathrow`, that will be called in any other method of `TripleDict`. Hence, the deletions would occur when the `TripleDict` will be used another time, and in particular this will only happen *after* the \"dealloc call higher up the stack\" has been completed.\n\n\nBut arbitrary code can be executed during weakref callbacks, including arbitrary `TripleDict` operations. So you'd never be sure if it's safe to kill `deathrow`. \n\nReally, this is starting to look more like a design deficiency in CPython: it should really mark objects on which dealloc is running to prevent GC, decref, whatever, from reentering dealloc. Preventing this by code protocol just seems to unduly restrict allowed data structures.\n\n> Perhaps `kill_deathrow` could also be called at the beginning of the callback function - so that it performs the deletions that were scheduled by the preceding callback function.\n\n\nYou wouldn't be sure that deathrow entries are now safe to delete ...\n\n**EXECUTIVE DECISION:** we mandate that key components to `TripleDict` be either weakreffable or do not hold references to other objects (i.e., are non container-types). Perhaps we can relax this rule once we come up with a smart mechanism.",
    "created_at": "2013-01-03T20:42:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169669",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:9 SimonKing]:
> PS: Why can this only happen with a non-weakreffable key? In particular, what are the keys in our crashing example? Namely, in its current use, I don't think that there are any non-weakreffable keys other than None and ints.


The cython-induced crash has only weakreffable keys. The hypothetical behaviour *has not been observed*.

> One could provide a new method `TripleDict.kill_deathrow`, that will be called in any other method of `TripleDict`. Hence, the deletions would occur when the `TripleDict` will be used another time, and in particular this will only happen *after* the "dealloc call higher up the stack" has been completed.


But arbitrary code can be executed during weakref callbacks, including arbitrary `TripleDict` operations. So you'd never be sure if it's safe to kill `deathrow`. 

Really, this is starting to look more like a design deficiency in CPython: it should really mark objects on which dealloc is running to prevent GC, decref, whatever, from reentering dealloc. Preventing this by code protocol just seems to unduly restrict allowed data structures.

> Perhaps `kill_deathrow` could also be called at the beginning of the callback function - so that it performs the deletions that were scheduled by the preceding callback function.


You wouldn't be sure that deathrow entries are now safe to delete ...

**EXECUTIVE DECISION:** we mandate that key components to `TripleDict` be either weakreffable or do not hold references to other objects (i.e., are non container-types). Perhaps we can relax this rule once we come up with a smart mechanism.



---

archive/issue_comments_169670.json:
```json
{
    "body": "Replying to [comment:10 nbruin]:\n> Replying to [comment:9 SimonKing]:\n> > PS: Why can this only happen with a non-weakreffable key? In particular, what are the keys in our crashing example? Namely, in its current use, I don't think that there are any non-weakreffable keys other than None and ints.\n\n> \n> The cython-induced crash has only weakreffable keys...\n\n\n... and is an upstream bug in Cython?\n\n\n> > One could provide a new method `TripleDict.kill_deathrow`, that will be called in any other method of `TripleDict`. Hence, the deletions would occur when the `TripleDict` will be used another time, and in particular this will only happen *after* the \"dealloc call higher up the stack\" has been completed.\n\n> \n> But arbitrary code can be executed during weakref callbacks, including arbitrary `TripleDict` operations. So you'd never be sure if it's safe to kill `deathrow`.\n\n\nNot quite, because we Know exactly what is happening in our weakref callbacks (namely: In the `__call__` method of `TripleDictEraser`). The callback function will not call any method of `TripleDict`.\n\n> > Perhaps `kill_deathrow` could also be called at the beginning of the callback function - so that it performs the deletions that were scheduled by the preceding callback function.\n\n> \n> You wouldn't be sure that deathrow entries are now safe to delete ...\n\n\nAgreed.\n\n> **EXECUTIVE DECISION:** we mandate that key components to `TripleDict` be either weakreffable or do not hold references to other objects (i.e., are non container-types). Perhaps we can relax this rule once we come up with a smart mechanism.\n\n\nI guess this would be the easiest solution on the short run. Do you think of a whitelist, i.e., explicitly allowing `NoneType`, `int`, `long` and so on?",
    "created_at": "2013-01-03T20:51:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169670",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:10 nbruin]:
> Replying to [comment:9 SimonKing]:
> > PS: Why can this only happen with a non-weakreffable key? In particular, what are the keys in our crashing example? Namely, in its current use, I don't think that there are any non-weakreffable keys other than None and ints.

> 
> The cython-induced crash has only weakreffable keys...


... and is an upstream bug in Cython?


> > One could provide a new method `TripleDict.kill_deathrow`, that will be called in any other method of `TripleDict`. Hence, the deletions would occur when the `TripleDict` will be used another time, and in particular this will only happen *after* the "dealloc call higher up the stack" has been completed.

> 
> But arbitrary code can be executed during weakref callbacks, including arbitrary `TripleDict` operations. So you'd never be sure if it's safe to kill `deathrow`.


Not quite, because we Know exactly what is happening in our weakref callbacks (namely: In the `__call__` method of `TripleDictEraser`). The callback function will not call any method of `TripleDict`.

> > Perhaps `kill_deathrow` could also be called at the beginning of the callback function - so that it performs the deletions that were scheduled by the preceding callback function.

> 
> You wouldn't be sure that deathrow entries are now safe to delete ...


Agreed.

> **EXECUTIVE DECISION:** we mandate that key components to `TripleDict` be either weakreffable or do not hold references to other objects (i.e., are non container-types). Perhaps we can relax this rule once we come up with a smart mechanism.


I guess this would be the easiest solution on the short run. Do you think of a whitelist, i.e., explicitly allowing `NoneType`, `int`, `long` and so on?



---

archive/issue_comments_169671.json:
```json
{
    "body": "By the way, my first attachment is wrong anyway, because I mispelled `gc.isenabled()`.",
    "created_at": "2013-01-03T21:06:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169671",
    "user": "https://github.com/simon-king-jena"
}
```

By the way, my first attachment is wrong anyway, because I mispelled `gc.isenabled()`.



---

archive/issue_comments_169672.json:
```json
{
    "body": "For debugging only. Increase the likelyhood that a gc occurs during a weakref callback",
    "created_at": "2013-01-03T21:07:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169672",
    "user": "https://github.com/simon-king-jena"
}
```

For debugging only. Increase the likelyhood that a gc occurs during a weakref callback



---

archive/issue_comments_169673.json:
```json
{
    "body": "Attachment [trac_13904_debug_only.patch](tarball://root/attachments/some-uuid/ticket13904/trac_13904_debug_only.patch) by @simon-king-jena created at 2013-01-03 21:26:56\n\nThe \"debug_only\" patch is updated. With it, I tried the following:\n\n```\nsage: cython(\"\"\"\n....: cdef class A:\n....:     cdef object x\n....:     def __init__(self, x):\n....:         self.x = x\n....: \"\"\")\nsage: import gc\nsage: from sage.structure.coerce_dict import TripleDict\nsage: T = TripleDict(31)\nsage: while(1):\n....:     b = B()\n....:     a = A(b)\n....:     T[b,a,None] = a\n....:     del a,b\n....:     foo = gc.collect()\n....:     \n```\n\nThat should be exactly the theoretical situation you were describing, isn't it?\n\nBut there is no crash. When I interrupt it after a while, with Ctrl-C, I get\n\n```\nsage: len(T)\n1681\n```\nThis I don't understand. Is `TripleDict` broken, in the sense of it doesn't allow its weak keys be cleared??",
    "created_at": "2013-01-03T21:26:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169673",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_13904_debug_only.patch](tarball://root/attachments/some-uuid/ticket13904/trac_13904_debug_only.patch) by @simon-king-jena created at 2013-01-03 21:26:56

The "debug_only" patch is updated. With it, I tried the following:

```
sage: cython("""
....: cdef class A:
....:     cdef object x
....:     def __init__(self, x):
....:         self.x = x
....: """)
sage: import gc
sage: from sage.structure.coerce_dict import TripleDict
sage: T = TripleDict(31)
sage: while(1):
....:     b = B()
....:     a = A(b)
....:     T[b,a,None] = a
....:     del a,b
....:     foo = gc.collect()
....:     
```

That should be exactly the theoretical situation you were describing, isn't it?

But there is no crash. When I interrupt it after a while, with Ctrl-C, I get

```
sage: len(T)
1681
```
This I don't understand. Is `TripleDict` broken, in the sense of it doesn't allow its weak keys be cleared??



---

archive/issue_comments_169674.json:
```json
{
    "body": "Replying to [comment:13 SimonKing]:\n> This I don't understand. Is `TripleDict` broken, in the sense of it doesn't allow its weak keys be cleared??\n\n\nWell, certainly the weak keys can be cleared. But apparently they can not be cleared, if there is a non-weakreffable item in the key that holds a reference to a weakreffable item in the key.\n\nHence, on the one hand, it seems that the situation you constructed is a non-issue, because the callback function for the weak reference will not be called.\n\nOn the other hand, it is yet another reason to not allow non-weakreffable containers as key.",
    "created_at": "2013-01-03T21:36:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169674",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:13 SimonKing]:
> This I don't understand. Is `TripleDict` broken, in the sense of it doesn't allow its weak keys be cleared??


Well, certainly the weak keys can be cleared. But apparently they can not be cleared, if there is a non-weakreffable item in the key that holds a reference to a weakreffable item in the key.

Hence, on the one hand, it seems that the situation you constructed is a non-issue, because the callback function for the weak reference will not be called.

On the other hand, it is yet another reason to not allow non-weakreffable containers as key.



---

archive/issue_comments_169675.json:
```json
{
    "body": "Script that tries to cause a double dealloc but fails because python is mature",
    "created_at": "2013-01-03T21:41:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169675",
    "user": "https://github.com/nbruin"
}
```

Script that tries to cause a double dealloc but fails because python is mature



---

archive/issue_comments_169676.json:
```json
{
    "body": "Attachment [test.sage](tarball://root/attachments/some-uuid/ticket13904/test.sage) by @nbruin created at 2013-01-03 21:47:44\n\nHOORAY!\nAs [Modules/gc_weakref.txt](http://hg.python.org/cpython/file/4b42d7f288c5/Modules/gc_weakref.txt) shows, Zope has already put very good stresstests on python's clearing of weakrefs in cyclic garbage. I think we're safe with `TripleDict` as it is, because python takes special precautions when running weakref callbacks in cleaning up cyclic garbage. In our case the weakref itself is part of the cyclic garbage. That means Python always stacks the deck such that the weakref appears to be cleared prior to the deletion of what it references. Hence, the callback doesn't happen! I think we're safe with TripleDict as it is.",
    "created_at": "2013-01-03T21:47:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169676",
    "user": "https://github.com/nbruin"
}
```

Attachment [test.sage](tarball://root/attachments/some-uuid/ticket13904/test.sage) by @nbruin created at 2013-01-03 21:47:44

HOORAY!
As [Modules/gc_weakref.txt](http://hg.python.org/cpython/file/4b42d7f288c5/Modules/gc_weakref.txt) shows, Zope has already put very good stresstests on python's clearing of weakrefs in cyclic garbage. I think we're safe with `TripleDict` as it is, because python takes special precautions when running weakref callbacks in cleaning up cyclic garbage. In our case the weakref itself is part of the cyclic garbage. That means Python always stacks the deck such that the weakref appears to be cleared prior to the deletion of what it references. Hence, the callback doesn't happen! I think we're safe with TripleDict as it is.



---

archive/issue_comments_169677.json:
```json
{
    "body": "Replying to [comment:13 SimonKing]:\n\n> But there is no crash. When I interrupt it after a while, with Ctrl-C, I get\n> \n> ```\n> sage: len(T)\n> 1681\n> ```\n> This I don't understand. Is `TripleDict` broken, in the sense of it doesn't allow its weak keys be cleared??\n\n\nNo, nothing is broken. You haven't included the definition of `B`, but I assume it's a weakreffable type.\n\nAlthough you delete `a,b`, your dictionary `T` is still holding a strong reference to `a` (because it can't weakref it) and `a` is holding a strong reference to `b`, so `b` is reachable. Nothing gets collected.\n\nThings are collectible once you throw away `T` but thanks to the special handling of callbacks in cyclic garbage this is always handled properly.",
    "created_at": "2013-01-03T21:52:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169677",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:13 SimonKing]:

> But there is no crash. When I interrupt it after a while, with Ctrl-C, I get
> 
> ```
> sage: len(T)
> 1681
> ```
> This I don't understand. Is `TripleDict` broken, in the sense of it doesn't allow its weak keys be cleared??


No, nothing is broken. You haven't included the definition of `B`, but I assume it's a weakreffable type.

Although you delete `a,b`, your dictionary `T` is still holding a strong reference to `a` (because it can't weakref it) and `a` is holding a strong reference to `b`, so `b` is reachable. Nothing gets collected.

Things are collectible once you throw away `T` but thanks to the special handling of callbacks in cyclic garbage this is always handled properly.



---

archive/issue_comments_169678.json:
```json
{
    "body": "Replying to [comment:15 nbruin]:\n> I think we're safe with `TripleDict` as it is.\n\n\nOK. But I wouldn't like to resolve this ticket as \"wontfix\" or \"duplicate\".\n\nStill, we should use \"del\", not \"`__delitem__`\", because it gives shorter C-code. And in addition to that, we should see whether the new Cython from #13896 fixes the problem.",
    "created_at": "2013-01-03T21:56:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169678",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:15 nbruin]:
> I think we're safe with `TripleDict` as it is.


OK. But I wouldn't like to resolve this ticket as "wontfix" or "duplicate".

Still, we should use "del", not "`__delitem__`", because it gives shorter C-code. And in addition to that, we should see whether the new Cython from #13896 fixes the problem.



---

archive/issue_comments_169679.json:
```json
{
    "body": "Replying to [comment:17 SimonKing]:\n\n> Still, we should use \"del\", not \"`__delitem__`\", because it gives shorter C-code. And in addition to that, we should see whether the new Cython from #13896 fixes the problem.\n\n\nYes, go ahead. Since there is no urgent issue anymore, use this ticket for whatever you want (and yes, that cython does solve the problem, if you compile the whole library with it. I'm now pretty confident I know exactly what went wrong, after seeing it happen on bit-level ...). The `gc_weakref.txt` is a fascinating read and should be required for anybody intending to meddle with sage's memory management.",
    "created_at": "2013-01-03T22:02:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169679",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:17 SimonKing]:

> Still, we should use "del", not "`__delitem__`", because it gives shorter C-code. And in addition to that, we should see whether the new Cython from #13896 fixes the problem.


Yes, go ahead. Since there is no urgent issue anymore, use this ticket for whatever you want (and yes, that cython does solve the problem, if you compile the whole library with it. I'm now pretty confident I know exactly what went wrong, after seeing it happen on bit-level ...). The `gc_weakref.txt` is a fascinating read and should be required for anybody intending to meddle with sage's memory management.



---

archive/issue_comments_169680.json:
```json
{
    "body": "It seems that indeed #13896 fixes the problem. Hooray `\\<sup>.</sup>/`\n\nHence, the priority regarding #715 is to upgrade Cython. The change from calling `__delitem__` to `del` should be done (here) as well, but not so urgent.",
    "created_at": "2013-01-03T22:39:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169680",
    "user": "https://github.com/simon-king-jena"
}
```

It seems that indeed #13896 fixes the problem. Hooray `\<sup>.</sup>/`

Hence, the priority regarding #715 is to upgrade Cython. The change from calling `__delitem__` to `del` should be done (here) as well, but not so urgent.



---

archive/issue_comments_169681.json:
```json
{
    "body": "Can we get the change from __delitem__ to del quickly in?\nIt is trivial, produce better C code, and potentially avoid horribly complicated gc problems?\n\nFrom what I've really quickly read, Nils pointed out another problem with weakrefs and callbacks, but let's go one step at a time and deal with that elsewhere (or move the trivial fix on a separate ticket).",
    "created_at": "2013-01-04T10:18:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169681",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Can we get the change from __delitem__ to del quickly in?
It is trivial, produce better C code, and potentially avoid horribly complicated gc problems?

From what I've really quickly read, Nils pointed out another problem with weakrefs and callbacks, but let's go one step at a time and deal with that elsewhere (or move the trivial fix on a separate ticket).



---

archive/issue_comments_169682.json:
```json
{
    "body": "Oh in fact, I've read a little less quickly and the problem Nils thought about does not occur?\nSo let's just get the trivial improvement here.\nI agree it is not a fix, but an imporvement, so I've changed the ticket title to reflect that as well.\n\nAnd in case one really wants to let garbage collection occurs during weakref callback or whenever, there are always ways to do that.",
    "created_at": "2013-01-04T10:21:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169682",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Oh in fact, I've read a little less quickly and the problem Nils thought about does not occur?
So let's just get the trivial improvement here.
I agree it is not a fix, but an imporvement, so I've changed the ticket title to reflect that as well.

And in case one really wants to let garbage collection occurs during weakref callback or whenever, there are always ways to do that.



---

archive/issue_comments_169683.json:
```json
{
    "body": "Replying to [comment:23 jpflori]:\n> Oh in fact, I've read a little less quickly and the problem Nils thought about does not occur?\n\n\nYes, because \"Python is more mature than we thought\"...\n\n> So let's just get the trivial improvement here.\n> I agree it is not a fix, but an imporvement\n\n\nBut, for the record, it is fixed with the new Cython spkg from #13896.",
    "created_at": "2013-01-04T10:34:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169683",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:23 jpflori]:
> Oh in fact, I've read a little less quickly and the problem Nils thought about does not occur?


Yes, because "Python is more mature than we thought"...

> So let's just get the trivial improvement here.
> I agree it is not a fix, but an imporvement


But, for the record, it is fixed with the new Cython spkg from #13896.



---

archive/issue_comments_169684.json:
```json
{
    "body": "Note that #12313 comprises a patch that makes the callback of a `TripleDictEraser` (hence, the deletion of dead items of a `TripleDict`) more secure. But I forgot to include the little improvement from here. Hence, I still think this ticket here is valid.",
    "created_at": "2013-01-19T18:23:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169684",
    "user": "https://github.com/simon-king-jena"
}
```

Note that #12313 comprises a patch that makes the callback of a `TripleDictEraser` (hence, the deletion of dead items of a `TripleDict`) more secure. But I forgot to include the little improvement from here. Hence, I still think this ticket here is valid.



---

archive/issue_comments_169685.json:
```json
{
    "body": "Use del rather then calling `__delitem__` directly, in `TripleDict` and `MonoDict`",
    "created_at": "2013-01-21T10:08:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169685",
    "user": "https://github.com/simon-king-jena"
}
```

Use del rather then calling `__delitem__` directly, in `TripleDict` and `MonoDict`



---

archive/issue_comments_169686.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-01-21T10:10:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169686",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_169687.json:
```json
{
    "body": "Attachment [trac13904_use_del.patch](tarball://root/attachments/some-uuid/ticket13904/trac13904_use_del.patch) by @simon-king-jena created at 2013-01-21 10:10:44\n\nI think using `del` rather than calling `__delitem__` makes sense even though the segfaults from #715 seem to be fixed by the Cython upgrade: Apparently `del` results in shorter C code.\n\nThe new patch uses `del` both on `TripleDict` and the new `MonoDict`, hence, it depends on #12313, where the latter was introduced.\n\nApply trac13904_use_del.patch",
    "created_at": "2013-01-21T10:10:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169687",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac13904_use_del.patch](tarball://root/attachments/some-uuid/ticket13904/trac13904_use_del.patch) by @simon-king-jena created at 2013-01-21 10:10:44

I think using `del` rather than calling `__delitem__` makes sense even though the segfaults from #715 seem to be fixed by the Cython upgrade: Apparently `del` results in shorter C code.

The new patch uses `del` both on `TripleDict` and the new `MonoDict`, hence, it depends on #12313, where the latter was introduced.

Apply trac13904_use_del.patch



---

archive/issue_comments_169688.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-01-21T10:13:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169688",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_039028.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-01-21T10:34:19Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "milestone": "sage-5.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13700#event-39028"
}
```



---

archive/issue_events_039029.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-02-01T07:14:27Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "milestone": "sage-5.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13700#event-39029"
}
```



---

archive/issue_events_039030.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-02-01T07:14:27Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "milestone": "sage-5.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13700#event-39030"
}
```



---

archive/issue_events_039031.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-02-17T22:43:34Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13700#event-39031"
}
```



---

archive/issue_comments_169689.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-02-17T22:43:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169689",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_comments_169690.json:
```json
{
    "body": "Changing status from closed to new.",
    "created_at": "2013-02-20T16:04:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169690",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from closed to new.



---

archive/issue_events_039032.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-02-20T16:04:25Z",
    "event": "reopened",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13700#event-39032"
}
```



---

archive/issue_comments_169691.json:
```json
{
    "body": "Resolution changed from fixed to ",
    "created_at": "2013-02-20T16:04:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169691",
    "user": "https://github.com/jdemeyer"
}
```

Resolution changed from fixed to 



---

archive/issue_comments_169692.json:
```json
{
    "body": "Unmerging because of trouble with #12313.",
    "created_at": "2013-02-20T16:04:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169692",
    "user": "https://github.com/jdemeyer"
}
```

Unmerging because of trouble with #12313.



---

archive/issue_comments_169693.json:
```json
{
    "body": "Perhaps try #13387 instead? With the solution there, this ticket is superseded there. It improves the performance of these dictionaries in some other ways as well.",
    "created_at": "2013-02-20T17:19:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169693",
    "user": "https://github.com/nbruin"
}
```

Perhaps try #13387 instead? With the solution there, this ticket is superseded there. It improves the performance of these dictionaries in some other ways as well.



---

archive/issue_comments_169694.json:
```json
{
    "body": "So this one should get closed as #12313 and #13387 will get merged together?",
    "created_at": "2013-02-28T10:49:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169694",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

So this one should get closed as #12313 and #13387 will get merged together?



---

archive/issue_comments_169695.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-02-28T10:49:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169695",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_169696.json:
```json
{
    "body": "Resolution: duplicate",
    "created_at": "2013-02-28T10:59:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13700#issuecomment-169696",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: duplicate



---

archive/issue_events_039033.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-02-28T10:59:30Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "milestone": "sage-5.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13700#event-39033"
}
```



---

archive/issue_events_039034.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-02-28T10:59:30Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13700#event-39034"
}
```



---

archive/issue_events_039035.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-02-28T10:59:30Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/13700",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13700#event-39035"
}
```
