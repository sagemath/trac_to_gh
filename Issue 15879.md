# Issue 15879: Multiplication of dense cyclotomic matrices should be faster

Issue created by migration from Trac.

Original creator: jipilab

Original creation time: 2014-04-09 23:02:51

CC:  sage-combinat nthiery stumpc5 vdelecroix was

Keywords: cyclotomic field, matrix, multiplication, benchmark, days57

The multiplication of matrices with a (universal) cyclotomic fields as base ring could be optimized as the following profiling shows:


```
    sage: x,y=var('x,y')
    sage: PR=PolynomialRing(QQ,[x,y])
    sage: I=Ideal(x^2 - 1/2*x - 1/4, y^3 - 1/2*y^2 - 1/2*y + 1/8)
    sage: Q=PR.quotient(I)
    sage: a,b=Q.gens()
    sage: elmt=matrix(Q,[[-1, 1, 2*x],[-4*x*y - 1, 4*x*y + 4*y^2, 4*x*y + 2*x],[-2*x, 2*x + 2*y, 2*x]])
    sage: %timeit elmt^2
    1000 loops, best of 3: 1.17 ms per loop

    sage: UCF.<E>=UniversalCyclotomicField()
    sage: ae=(E(10)+~E(10))/2  #same value as a
    sage: be=(E(14)+~E(14))/2  #same value as b
    sage: m=matrix(UCF,[[-1, 1, 2*ae],[-4*ae*be - 1, 4*ae*be + 4*be^2, 4*ae*be + 2*ae],[-2*ae, 2*ae + 2*be, 2*ae]])
    sage: %timeit m^2
    100 loops, best of 3: 8.13 ms per loop

    sage: CFC.<F>=CyclotomicField(2*5*7)
    sage: af=(F^7+~F^7)/2 #same value as a
    sage: bf=(F^5+~F^5)/2 #same value as b
    sage: m2=matrix(CFC,[[-1, 1, 2*af],[-4*af*bf - 1, 4*af*bf + 4*bf^2, 4*af*bf + 2*af],[-2*af, 2*af + 2*bf, 2*af]])
    sage: %timeit m2^2
    100 loops, best of 3: 4.99 ms per loop
```


The three matrices elmt, m and m2 are the same encoded into 3 different base rings. It would be natural to think that the cyclotomic field be the optimal field to do computations, but it does not seem to be the case in practice.


---

Comment by vdelecroix created at 2015-04-11 08:42:21

Hello,

With #18152, I got a 10x speedup

old version:

```
sage: %timeit m^2
100 loops, best of 3: 3.65 ms per loop
```


new version:

```
sage: %timeit m^2
The slowest run took 69.65 times longer than the fastest. This could mean that an intermediate result is being cached 
1000 loops, best of 3: 336 µs per loop
```


Vincent


---

Comment by vdelecroix created at 2015-04-11 08:44:49

And using libgap directly is even faster

```
sage: M = m._libgap_()
sage: %timeit M^2
The slowest run took 9.57 times longer than the fastest. This could mean that an intermediate result is being cached 
1000 loops, best of 3: 183 µs per loop
```

So, as written in the bottom of the description in #18152, we should wrap GAP matrices to deal with dense cyclotomics matrices in Sage.

Vincent


---

Comment by vdelecroix created at 2015-04-11 13:15:35

Hello,

I reformatted your example such that they fit in less lines (it can easily switched back to your original version if you do not like it).

I had a quick look at the code for dense cyclotomic matrices. The implementation is quite old and uses a lot of reduction mod p (even for multiplication). The code calls a lot of Python code like creating a finite field, creating a matrix space, etc which are relatively slow compared to a small matrix multiplication. Did you try multiplying larger matrices (i.e. 10x10 or 15x15)? On the other hand, I am pretty sure that some cleaning could be of great speed up. By cleaning I mean:
 - declare `cdef` variables wherever possible
 - let as minimum as possible `import` inside the methods
 - ...
You can also do some profiling on the code (using "%prun" and "%crun"), see #17689 which is not yet in the current development release.

Vincent


---

Comment by was created at 2015-04-11 14:19:11

Replying to [comment:7 vdelecroix]:
> Hello,
> 
> I reformatted your example such that they fit in less lines (it can easily switched back to your original version if you do not like it).
> 
> I had a quick look at the code for dense cyclotomic matrices. The implementation is quite old and uses a lot of reduction mod p (even for multiplication). The code calls a lot of Python code like creating a finite field, creating a matrix space, etc which are relatively slow compared to a small matrix multiplication. Did you try multiplying larger matrices (i.e. 10x10 or 15x15)?

I designed and implemented the algorithm for dense cyclotomic matrices.  We were optimizing for larger matrices... which in the context of modular forms means at least 100 rows (and often much, much more).   GAP/pari on the other hand optimize for relatively tiny matrices.   The asymptotically fast algorithms for large matrices are totally different than for small...


---

Comment by vdelecroix created at 2015-04-11 14:26:24

Replying to [comment:8 was]:
> Replying to [comment:7 vdelecroix]:
> > Hello,
> > 
> > I reformatted your example such that they fit in less lines (it can easily switched back to your original version if you do not like it).
> > 
> > I had a quick look at the code for dense cyclotomic matrices. The implementation is quite old and uses a lot of reduction mod p (even for multiplication). The code calls a lot of Python code like creating a finite field, creating a matrix space, etc which are relatively slow compared to a small matrix multiplication. Did you try multiplying larger matrices (i.e. 10x10 or 15x15)?
> 
> I designed and implemented the algorithm for dense cyclotomic matrices.  We were optimizing for larger matrices... which in the context of modular forms means at least 100 rows (and often much, much more).   GAP/pari on the other hand optimize for relatively tiny matrices.   The asymptotically fast algorithms for large matrices are totally different than for small...

All right. I now understand better what I read! I see two possibilities.

1) [easy one] We add a test in the matrix space constructor:
 - if the size is small -> use the generic implementation of dense matrices
 - if the size is large -> use your optimized version
This requires a bit of benchmark.

2) [better one] Wrap pari matrices for small sizes or add a another multiplication on the current datatype that is fast on small matrices.

Vincent


---

Comment by jipilab created at 2015-04-13 13:19:29

Hi,

In the case I'm interested in, it is definitely for small sizes. Say up to 20-25 at the very very biggest. Most commonly it is going to be between 3 and 10. This is related to the tickets #15703, #16087.

How to proceed to add another multiplication to the matrices that could be used for small matrices?

Are there examples around with such a thing? I could look at it...


---

Comment by was created at 2015-04-13 13:21:51

Replying to [comment:10 jipilab]:
> Hi,
> 
> In the case I'm interested in, it is definitely for small sizes. Say up to 20-25 at the very very biggest. Most commonly it is going to be between 3 and 10. This is related to the tickets #15703, #16087.
> 
> How to proceed to add another multiplication to the matrices that could be used for small matrices?
> 
> Are there examples around with such a thing? I could look at it...

Matrices over ZZ used to have special code for small versus large.   I think now that variation in algorithms is mainly hidden by calling FLINT.      Look into it.


---

Comment by vdelecroix created at 2015-04-13 13:37:18

Replying to [comment:11 was]:
> Replying to [comment:10 jipilab]:
> > Hi,
> > 
> > In the case I'm interested in, it is definitely for small sizes. Say up to 20-25 at the very very biggest. Most commonly it is going to be between 3 and 10. This is related to the tickets #15703, #16087.
> > 
> > How to proceed to add another multiplication to the matrices that could be used for small matrices?
> > 
> > Are there examples around with such a thing? I could look at it...
> 
> Matrices over ZZ used to have special code for small versus large.   I think now that variation in algorithms is mainly hidden by calling FLINT.      Look into it.

William, are you sure that the representation you used in `MatrixDense_cyclotomic` is the thing we want for small sizes? If that so, I would rather implement something for any number fields. I do not see why it might be different. Did you have something in mind?

In the present case, I would rather modify `MatrixSpace._get_matrix_class` to choose the generic dense matrices for small sizes and see if something break.


---

Comment by was created at 2015-04-13 16:37:37

> William, are you sure that the representation you used in MatrixDense_cyclotomic is the thing we want for small sizes? 

No.  In fact, I'm pretty sure they are *not* what you would want for small sizes.


---

Comment by tscrim created at 2015-09-16 23:09:26

We also have a related issue:

```
sage: R = CyclotomicField(12)
sage: M = matrix.random(R, 40,40)
sage: N = matrix.random(R, 3, 3)
sage: %time K = M.tensor_product(N)
CPU times: user 5.75 s, sys: 28.4 ms, total: 5.78 s
Wall time: 5.73 s
sage: R.defining_polynomial()
x^4 - x^2 + 1
sage: type(M)
<type 'sage.matrix.matrix_cyclo_dense.Matrix_cyclo_dense'>

sage: R = NumberField(x^4 - x^2 + 1, 'a')
sage: M = matrix.random(R, 40,40)
sage: N = matrix.random(R, 3, 3)
sage: %time K = M.tensor_product(N)
CPU times: user 225 ms, sys: 16.4 ms, total: 241 ms
Wall time: 232 ms
sage: type(M)
<type 'sage.matrix.matrix_generic_dense.Matrix_generic_dense'>
```

Where the issue is coming from having a scalar times a matrix. Here's some profiling info of doing it over the cyclotomic field:

```
   594202    1.806    0.000    3.620    0.000 number_field.py:9200(_element_constructor_)
   594202    0.816    0.000    1.171    0.000 number_field.py:6628(_coerce_non_number_field_element_in)
  4184691    0.569    0.000    0.569    0.000 {isinstance}
```

This is nowhere to be found when doing it over the number field. (For very small matrices this isn't a problem per se, but it still is visible when profiling.)

So my conclusion is that we are doing something wrong with how we handle multiplication with cyclotomics in the matrix versus our generic dense cases.


---

Comment by tscrim created at 2015-09-16 23:18:48

I should note that I get very different profiling when I reverse the orders of the tensor product, which from the naive implementation of the tensor product and thoughts about scalar multiplication surprises me:

```
sage: R = CyclotomicField(2)
sage: M = matrix.random(R, 40,40)
sage: N = matrix.random(R, 3, 3)
sage: %time K = N.tensor_product(M)
CPU times: user 337 ms, sys: 20.6 ms, total: 358 ms
Wall time: 335 ms
sage: %time K = M.tensor_product(N)
CPU times: user 3.99 s, sys: 32.5 ms, total: 4.02 s
Wall time: 3.97 s
```

There are quite a lot more function calls (~10x) to the `_element_constructor_` in one ordering:

```
48023 for _element_constructor_
577312 function calls (577311 primitive calls) in 0.421 seconds
```

versus

```
594198  for _element_constructor_
7240514 function calls (7240513 primitive calls) in 4.992 seconds
```



---

Comment by tscrim created at 2015-09-20 16:46:05

The part which handles speeding up the tensor product is now #19258.


---

Comment by tscrim created at 2016-01-03 01:15:31

It seems that matrix multiplication over the universal cyclotomic field is on the same order as the polynomial ring (probably because it uses the generic matrix class):

```
sage: %timeit m * m
1000 loops, best of 3: 224 µs per loop
sage: %timeit elmt * elmt
1000 loops, best of 3: 207 µs per loop
```

However for UCF matrices, I'm thinking we might benefit from either using (lib)GAP's matrix multiplication or internally storing the GAP element and only converting it to a Sage UCF element as necessary. See #19821 for a use-case.


---

Comment by vdelecroix created at 2016-01-03 03:32:32

At least on sage-7.0.beta2, wrapping GAP matrices for the examples mentioned in the ticket description will not bring any magic

```
sage: M = m._libgap_()
sage: %timeit A = M^2
1000 loops, best of 3: 181 µs per loop
sage: %timeit A = M^3
1000 loops, best of 3: 456 µs per loop
```

versus

```
sage: %timeit a = m^2
1000 loops, best of 3: 298 µs per loop
sage: %timeit a = m^3
1000 loops, best of 3: 690 µs per loop
```

We are below x2 speedup. But in this example the matrix is small and coefficients relatively dense (~25 nonzero coefficients). Though, the gain is significant with 10x10 dense matrices with small coefficients

```
sage: m1 = matrix(10, [E(randint(2,3)) for _ in range(100)]) 
sage: m2 = matrix(10, [E(randint(2,3)) for _ in range(100)])
sage: %timeit m1*m2
100 loops, best of 3: 4.51 ms per loop
sage: %timeit M1*M2
1000 loops, best of 3: 329 µs per loop
```

We might update the ticket description accordingly. Two concrete propositions are:
- below a certain threshold (to be determined) use generic matrices for cyclotomic fields
- wrap GAP matrices for UCF
What do you think?


---

Comment by tscrim created at 2016-01-03 03:57:51

A 30-40% speed reduction is nothing to scoff at either. So from that data, I think for dense matrices over the UCF we should always just wrap GAP.


---

Comment by vdelecroix created at 2017-08-24 21:09:46

Changing keywords from "cyclotomic field, matrix, multiplication, benchmark, days57" to "cyclotomic field, matrix, multiplication, benchmark, days57, days88".


---

Comment by vdelecroix created at 2017-08-24 22:40:17

Changing component from number fields to linear algebra.


---

Comment by vdelecroix created at 2017-08-24 22:40:17

Changing type from enhancement to task.
