# Issue 13503: Enhancement of `is_triangle_free' addition of `triangles_count' and a minor change in `spanning_trees_count'

archive/issues_013299.json:
```json
{
    "body": "The main change of this patch is to improve the `is_triangle_free' method. The introduced algorithm uses the fact that given that A is the adjacency matrix of a simple graph G, then the number of triangles in G is tr(A^3)/6. \n\nThe change has been tested resulting in the following benchmarks:\n\n1. Testing all graphs of order up to 10 for triangles: (old: 201m44.339s, new: **87m38.146s**)\n2. Testing all triangle-free graphs of order 12 for triangles: (old: 15m56.679s, new **9m41.116s**)\n3. Testing all graphs of order up to 10 that do contain triangles: (old:  0m10.305s, new : **0m5.798s**)\n\nI can provide the test programs if needed.\n\nSince there are many applications in which one needs to count the number of triangles in a graph the named routine was also added.\n\nFinally a minor change has been made to the generic_graph function spanning_trees_count() which calls abs on a determinant that is always positive.\n\n\nApply:\n\n* [attachment:trac_13503_triangles-v2.patch]\n\n\nAssignee: jason, ncohen, rlm\n\nCC:  @rbeezer @nathanncohen\n\nKeywords: triangles, graphs, number of triangles\n\nReviewer: Jernej Azarija\n\nAuthor: Jernej Azarija, David Coudert\n\nMerged: sage-5.6.beta1\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/13503\n\n",
    "closed_at": "2012-12-21T09:31:42Z",
    "created_at": "2012-09-17T16:27:09Z",
    "labels": [
        "component: graph theory",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.6",
    "title": "Enhancement of `is_triangle_free' addition of `triangles_count' and a minor change in `spanning_trees_count'",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13503",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```
The main change of this patch is to improve the `is_triangle_free' method. The introduced algorithm uses the fact that given that A is the adjacency matrix of a simple graph G, then the number of triangles in G is tr(A^3)/6. 

The change has been tested resulting in the following benchmarks:

1. Testing all graphs of order up to 10 for triangles: (old: 201m44.339s, new: **87m38.146s**)
2. Testing all triangle-free graphs of order 12 for triangles: (old: 15m56.679s, new **9m41.116s**)
3. Testing all graphs of order up to 10 that do contain triangles: (old:  0m10.305s, new : **0m5.798s**)

I can provide the test programs if needed.

Since there are many applications in which one needs to count the number of triangles in a graph the named routine was also added.

Finally a minor change has been made to the generic_graph function spanning_trees_count() which calls abs on a determinant that is always positive.


Apply:

* [attachment:trac_13503_triangles-v2.patch]


Assignee: jason, ncohen, rlm

CC:  @rbeezer @nathanncohen

Keywords: triangles, graphs, number of triangles

Reviewer: Jernej Azarija

Author: Jernej Azarija, David Coudert

Merged: sage-5.6.beta1

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/13503





---

archive/issue_comments_163031.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2012-09-25T18:50:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163031",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_163032.json:
```json
{
    "body": "<a id='comment:4'></a>The patch needs a fix of the documentation before its ready for review.",
    "created_at": "2012-09-26T19:54:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163032",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:4'></a>The patch needs a fix of the documentation before its ready for review.



---

archive/issue_comments_163033.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-09-26T19:54:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163033",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_163034.json:
```json
{
    "body": "<a id='comment:5'></a>Hello,\n\nI added Nathann in Cc because we had a discussion about counting triangles last week ;)\n\nThe proposed method for testing if the graph is triangle free is not a good one. Indeed, the time complexity for testing if the graph is triangle free is at most N^w, where 2 <= w < 3 is the best possible exponent for  computing the square of a matrix of side N. You compute the square of the adjacency matrix to get all paths of length 2, and then you test for every edge (u,v) if there is a path of length 2 from u to v. Furthermore, the basic algorithm of testing if some neighbors of a vertex are incident is fast.\n\nLet us compare the following method with your proposition for testing if the graph is triangle free.\n\n```\ndef my_is_triangle_free(G):\n    for u in G.vertex_iterator():\n        if any(G.has_edge(v,w) for v,w in combinations_iterator(G.neighbors(u),2)):\n            return False\n    #\n    return True\n```\n\nWe get the following running times:\n\n```\nsage: G = graphs.GridGraph([5,2]); M = G.adjacency_matrix() # 10 nodes\nsage: %timeit G.is_triangle_free()\n625 loops, best of 3: 603 \u00b5s per loop\nsage: %timeit (M^3).trace() > 0\n625 loops, best of 3: 101 \u00b5s per loop\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 376 \u00b5s per loop\nsage:\nsage: G = graphs.GridGraph([10,5]); M = G.adjacency_matrix() # 50 nodes\nsage: %timeit G.is_triangle_free()\n25 loops, best of 3: 9.49 ms per loop\nsage: %timeit (M^3).trace() > 0\n125 loops, best of 3: 3.92 ms per loop\nsage: %timeit my_is_triangle_free(G)\n125 loops, best of 3: 2.67 ms per loop\nsage:\nsage: G = graphs.GridGraph([10,10]); M = G.adjacency_matrix() # 100 nodes\nsage: %timeit G.is_triangle_free()\n25 loops, best of 3: 31.5 ms per loop\nsage: %timeit (M^3).trace() > 0\n25 loops, best of 3: 12.3 ms per loop\nsage: %timeit my_is_triangle_free(G)\n125 loops, best of 3: 5.71 ms per loop\nsage: \nsage: G = graphs.GridGraph([50,20]); M = G.adjacency_matrix() # 1000 nodes\nsage: %timeit G.is_triangle_free()\n5 loops, best of 3: 1.1 s per loop\nsage: %timeit (M^3).trace() > 0\n5 loops, best of 3: 1.04 s per loop\nsage: %timeit my_is_triangle_free(G)\n5 loops, best of 3: 63.8 ms per loop\nsage:\nsage: G = graphs.RandomGNP(10,.1); M = G.adjacency_matrix()  # 10 nodes\nsage: %timeit G.is_triangle_free()\n625 loops, best of 3: 492 \u00b5s per loop\nsage: %timeit (M^3).trace() > 0\n625 loops, best of 3: 90.5 \u00b5s per loop\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 160 \u00b5s per loop\nsage: \nsage: G = graphs.RandomGNP(50,.1); M = G.adjacency_matrix()  # 50 nodes\nsage: %timeit G.is_triangle_free()\n25 loops, best of 3: 9.92 ms per loop\nsage: %timeit (M^3).trace() > 0\n125 loops, best of 3: 3.93 ms per loop\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 110 \u00b5s per loop\nsage:\nsage: G = graphs.RandomGNP(100,.2); M = G.adjacency_matrix() # 100 nodes, dense\nsage: %timeit G.is_triangle_free()\n5 loops, best of 3: 40 ms per loop\nsage: %timeit (M^3).trace() > 0\n25 loops, best of 3: 12.9 ms per loop\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 125 \u00b5s per loop\nsage:\nsage: G = graphs.RandomGNP(100,.01); M = G.adjacency_matrix()  # 100 nodes, sparse\nsage: %timeit G.is_triangle_free()\n25 loops, best of 3: 29.7 ms per loop\nsage: %timeit (M^3).trace() > 0\n25 loops, best of 3: 12.2 ms per loop\nsage: %timeit my_is_triangle_free(G)\n125 loops, best of 3: 2.05 ms per loop\nsage: \nsage: G = graphs.RandomGNP(1000,.01); M = G.adjacency_matrix() # 1000 nodes\nsage: %timeit G.is_triangle_free()\n5 loops, best of 3: 33.9 s per loop\nsage: %timeit (M^3).trace() > 0\n5 loops, best of 3: 33.8 s per loop\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 1.24 ms per loop\n```\n\nFor very small graphs it is apparently faster to do `(M^3).trace() > 0`, but for large graphs, basic iterations are way faster because we stop computations as soon as a triangle is found (if any). Therefore, a better solution could be an hybrid method using matrix multiplication if the graph is very small, and basic iterations otherwise.\n\n---\n\nFor counting triangles, the situation is rather different and the density of the graph matters. Furthermore, it is interesting to use networkx graphs:\n\n```\ndef my_triangles_count(G):\n    tr = 0\n    for u in G.vertex_iterator():\n        tr += sum(G.has_edge(v,w) for v,w in combinations_iterator(G.neighbors(u),2))\n    return tr/3\n\ndef my_triangles_countnx(G):\n    tr = 0\n    ggnx = G.networkx_graph()\n    for u in ggnx.nodes_iter():\n        tr += sum(ggnx.has_edge(v,w) for v,w in combinations_iterator(ggnx.neighbors(u),2))\n    return tr/3\n```\n\nWe get the following running time:\n\n```\nsage: G = graphs.GridGraph([5,2])\nsage: %timeit G.triangles_count()\n625 loops, best of 3: 608 \u00b5s per loop\nsage: %timeit my_triangles_count(G)\n625 loops, best of 3: 444 \u00b5s per loop\nsage: %timeit my_triangles_countnx(G)\n625 loops, best of 3: 353 \u00b5s per loop\nsage:\nsage: G = graphs.GridGraph([10,5])\nsage: %timeit G.triangles_count()\n25 loops, best of 3: 9.44 ms per loop\nsage: %timeit my_triangles_count(G)\n125 loops, best of 3: 2.98 ms per loop\nsage: %timeit my_triangles_countnx(G)\n125 loops, best of 3: 1.99 ms per loop\nsage:\nsage: G = graphs.RandomGNP(10,.1)\nsage: %timeit G.triangles_count()\n625 loops, best of 3: 493 \u00b5s per loop\nsage: %timeit my_triangles_count(G)\n625 loops, best of 3: 217 \u00b5s per loop\nsage: %timeit my_triangles_countnx(G)\n625 loops, best of 3: 218 \u00b5s per loop\nsage:\nsage: G = graphs.RandomGNP(50,.1)\nsage: %timeit G.triangles_count()\n25 loops, best of 3: 9.79 ms per loop\nsage: %timeit my_triangles_count(G)\n125 loops, best of 3: 5.49 ms per loop\nsage: %timeit my_triangles_countnx(G)\n125 loops, best of 3: 2.78 ms per loop\nsage:\nsage: G = graphs.RandomGNP(50,.5)\nsage: %timeit G.triangles_count()\n25 loops, best of 3: 15 ms per loop\nsage: %timeit my_triangles_count(G)\n5 loops, best of 3: 82.4 ms per loop\nsage: %timeit my_triangles_countnx(G)\n25 loops, best of 3: 23.4 ms per loop\nsage:\nsage: G = graphs.RandomGNP(100,.5)\nsage: %timeit G.triangles_count()\n5 loops, best of 3: 58.4 ms per loop\nsage: %timeit my_triangles_count(G)\n5 loops, best of 3: 716 ms per loop\nsage: %timeit my_triangles_countnx(G)\n5 loops, best of 3: 181 ms per loop\nsage:\nsage: G = graphs.RandomGNP(100,.1)\nsage: %timeit G.triangles_count()\n25 loops, best of 3: 35.4 ms per loop\nsage: %timeit my_triangles_count(G)\n25 loops, best of 3: 33.6 ms per loop\nsage: %timeit my_triangles_countnx(G)\n25 loops, best of 3: 12.8 ms per loop\nsage:\nsage: G = graphs.RandomGNP(100,.05)\nsage: %timeit G.triangles_count()\n25 loops, best of 3: 32.3 ms per loop\nsage: %timeit my_triangles_count(G)\n25 loops, best of 3: 10.8 ms per loop\nsage: %timeit my_triangles_countnx(G)\n125 loops, best of 3: 5.53 ms per loop\n```\n\nAs you can see, when the graph is dense, the matrix multiplication method is the fastest, but for spare graphs it is better to use iterations and to convert the graph into a networkx graph. However, I don't know how to choose the threshold and I don't have better proposals in mind yet.",
    "created_at": "2012-09-29T11:12:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163034",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:5'></a>Hello,

I added Nathann in Cc because we had a discussion about counting triangles last week ;)

The proposed method for testing if the graph is triangle free is not a good one. Indeed, the time complexity for testing if the graph is triangle free is at most N^w, where 2 <= w < 3 is the best possible exponent for  computing the square of a matrix of side N. You compute the square of the adjacency matrix to get all paths of length 2, and then you test for every edge (u,v) if there is a path of length 2 from u to v. Furthermore, the basic algorithm of testing if some neighbors of a vertex are incident is fast.

Let us compare the following method with your proposition for testing if the graph is triangle free.

```
def my_is_triangle_free(G):
    for u in G.vertex_iterator():
        if any(G.has_edge(v,w) for v,w in combinations_iterator(G.neighbors(u),2)):
            return False
    #
    return True
```

We get the following running times:

```
sage: G = graphs.GridGraph([5,2]); M = G.adjacency_matrix() # 10 nodes
sage: %timeit G.is_triangle_free()
625 loops, best of 3: 603 µs per loop
sage: %timeit (M^3).trace() > 0
625 loops, best of 3: 101 µs per loop
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 376 µs per loop
sage:
sage: G = graphs.GridGraph([10,5]); M = G.adjacency_matrix() # 50 nodes
sage: %timeit G.is_triangle_free()
25 loops, best of 3: 9.49 ms per loop
sage: %timeit (M^3).trace() > 0
125 loops, best of 3: 3.92 ms per loop
sage: %timeit my_is_triangle_free(G)
125 loops, best of 3: 2.67 ms per loop
sage:
sage: G = graphs.GridGraph([10,10]); M = G.adjacency_matrix() # 100 nodes
sage: %timeit G.is_triangle_free()
25 loops, best of 3: 31.5 ms per loop
sage: %timeit (M^3).trace() > 0
25 loops, best of 3: 12.3 ms per loop
sage: %timeit my_is_triangle_free(G)
125 loops, best of 3: 5.71 ms per loop
sage: 
sage: G = graphs.GridGraph([50,20]); M = G.adjacency_matrix() # 1000 nodes
sage: %timeit G.is_triangle_free()
5 loops, best of 3: 1.1 s per loop
sage: %timeit (M^3).trace() > 0
5 loops, best of 3: 1.04 s per loop
sage: %timeit my_is_triangle_free(G)
5 loops, best of 3: 63.8 ms per loop
sage:
sage: G = graphs.RandomGNP(10,.1); M = G.adjacency_matrix()  # 10 nodes
sage: %timeit G.is_triangle_free()
625 loops, best of 3: 492 µs per loop
sage: %timeit (M^3).trace() > 0
625 loops, best of 3: 90.5 µs per loop
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 160 µs per loop
sage: 
sage: G = graphs.RandomGNP(50,.1); M = G.adjacency_matrix()  # 50 nodes
sage: %timeit G.is_triangle_free()
25 loops, best of 3: 9.92 ms per loop
sage: %timeit (M^3).trace() > 0
125 loops, best of 3: 3.93 ms per loop
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 110 µs per loop
sage:
sage: G = graphs.RandomGNP(100,.2); M = G.adjacency_matrix() # 100 nodes, dense
sage: %timeit G.is_triangle_free()
5 loops, best of 3: 40 ms per loop
sage: %timeit (M^3).trace() > 0
25 loops, best of 3: 12.9 ms per loop
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 125 µs per loop
sage:
sage: G = graphs.RandomGNP(100,.01); M = G.adjacency_matrix()  # 100 nodes, sparse
sage: %timeit G.is_triangle_free()
25 loops, best of 3: 29.7 ms per loop
sage: %timeit (M^3).trace() > 0
25 loops, best of 3: 12.2 ms per loop
sage: %timeit my_is_triangle_free(G)
125 loops, best of 3: 2.05 ms per loop
sage: 
sage: G = graphs.RandomGNP(1000,.01); M = G.adjacency_matrix() # 1000 nodes
sage: %timeit G.is_triangle_free()
5 loops, best of 3: 33.9 s per loop
sage: %timeit (M^3).trace() > 0
5 loops, best of 3: 33.8 s per loop
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 1.24 ms per loop
```

For very small graphs it is apparently faster to do `(M^3).trace() > 0`, but for large graphs, basic iterations are way faster because we stop computations as soon as a triangle is found (if any). Therefore, a better solution could be an hybrid method using matrix multiplication if the graph is very small, and basic iterations otherwise.

---

For counting triangles, the situation is rather different and the density of the graph matters. Furthermore, it is interesting to use networkx graphs:

```
def my_triangles_count(G):
    tr = 0
    for u in G.vertex_iterator():
        tr += sum(G.has_edge(v,w) for v,w in combinations_iterator(G.neighbors(u),2))
    return tr/3

def my_triangles_countnx(G):
    tr = 0
    ggnx = G.networkx_graph()
    for u in ggnx.nodes_iter():
        tr += sum(ggnx.has_edge(v,w) for v,w in combinations_iterator(ggnx.neighbors(u),2))
    return tr/3
```

We get the following running time:

```
sage: G = graphs.GridGraph([5,2])
sage: %timeit G.triangles_count()
625 loops, best of 3: 608 µs per loop
sage: %timeit my_triangles_count(G)
625 loops, best of 3: 444 µs per loop
sage: %timeit my_triangles_countnx(G)
625 loops, best of 3: 353 µs per loop
sage:
sage: G = graphs.GridGraph([10,5])
sage: %timeit G.triangles_count()
25 loops, best of 3: 9.44 ms per loop
sage: %timeit my_triangles_count(G)
125 loops, best of 3: 2.98 ms per loop
sage: %timeit my_triangles_countnx(G)
125 loops, best of 3: 1.99 ms per loop
sage:
sage: G = graphs.RandomGNP(10,.1)
sage: %timeit G.triangles_count()
625 loops, best of 3: 493 µs per loop
sage: %timeit my_triangles_count(G)
625 loops, best of 3: 217 µs per loop
sage: %timeit my_triangles_countnx(G)
625 loops, best of 3: 218 µs per loop
sage:
sage: G = graphs.RandomGNP(50,.1)
sage: %timeit G.triangles_count()
25 loops, best of 3: 9.79 ms per loop
sage: %timeit my_triangles_count(G)
125 loops, best of 3: 5.49 ms per loop
sage: %timeit my_triangles_countnx(G)
125 loops, best of 3: 2.78 ms per loop
sage:
sage: G = graphs.RandomGNP(50,.5)
sage: %timeit G.triangles_count()
25 loops, best of 3: 15 ms per loop
sage: %timeit my_triangles_count(G)
5 loops, best of 3: 82.4 ms per loop
sage: %timeit my_triangles_countnx(G)
25 loops, best of 3: 23.4 ms per loop
sage:
sage: G = graphs.RandomGNP(100,.5)
sage: %timeit G.triangles_count()
5 loops, best of 3: 58.4 ms per loop
sage: %timeit my_triangles_count(G)
5 loops, best of 3: 716 ms per loop
sage: %timeit my_triangles_countnx(G)
5 loops, best of 3: 181 ms per loop
sage:
sage: G = graphs.RandomGNP(100,.1)
sage: %timeit G.triangles_count()
25 loops, best of 3: 35.4 ms per loop
sage: %timeit my_triangles_count(G)
25 loops, best of 3: 33.6 ms per loop
sage: %timeit my_triangles_countnx(G)
25 loops, best of 3: 12.8 ms per loop
sage:
sage: G = graphs.RandomGNP(100,.05)
sage: %timeit G.triangles_count()
25 loops, best of 3: 32.3 ms per loop
sage: %timeit my_triangles_count(G)
25 loops, best of 3: 10.8 ms per loop
sage: %timeit my_triangles_countnx(G)
125 loops, best of 3: 5.53 ms per loop
```

As you can see, when the graph is dense, the matrix multiplication method is the fastest, but for spare graphs it is better to use iterations and to convert the graph into a networkx graph. However, I don't know how to choose the threshold and I don't have better proposals in mind yet.



---

archive/issue_comments_163035.json:
```json
{
    "body": "<a id='comment:6'></a>Hello,\n\nI agree with what you said. \n\nAs you mentioned it is hard to deduce a threshold that is going to be good for all platforms (and times) so I suppose we could simply add an optional argument for the user to specify which algorithm to use. We could then also add the even faster triangle detection algorithms based on probability.",
    "created_at": "2012-09-29T12:29:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163035",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:6'></a>Hello,

I agree with what you said. 

As you mentioned it is hard to deduce a threshold that is going to be good for all platforms (and times) so I suppose we could simply add an optional argument for the user to specify which algorithm to use. We could then also add the even faster triangle detection algorithms based on probability.



---

archive/issue_comments_163036.json:
```json
{
    "body": "<a id='comment:7'></a>Yes, adding an argument to specify the algorithm is the best solution.",
    "created_at": "2012-09-29T13:08:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163036",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:7'></a>Yes, adding an argument to specify the algorithm is the best solution.



---

archive/issue_comments_163037.json:
```json
{
    "body": "<a id='comment:8'></a>Also not to forget that the code for triangle detection would be much much faster if we compute A*A*A in the real field. Could you also check that? To compare with your other results?",
    "created_at": "2012-09-29T21:29:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163037",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:8'></a>Also not to forget that the code for triangle detection would be much much faster if we compute A*A*A in the real field. Could you also check that? To compare with your other results?



---

archive/issue_comments_163038.json:
```json
{
    "body": "<a id='comment:9'></a>It is true that A*A*A is a bit faster, but not in the real field where it seems very slow.",
    "created_at": "2012-09-29T22:09:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163038",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:9'></a>It is true that A*A*A is a bit faster, but not in the real field where it seems very slow.



---

archive/issue_comments_163039.json:
```json
{
    "body": "<a id='comment:10'></a>Replying to [comment:9 dcoudert]:\n> It is true that A*A*A is a bit faster, but not in the real field where it seems very slow.\n\n\n`RR = RealField(53)` is arbitrary precision reals, so perhaps predictably slow, given the generality.\n\n`RDF` (real double field) is floating point doubles.  Whatever the 53-bit precision IEEE format is.  Try adjacency matrices over that ring.  They might be an improvement.",
    "created_at": "2012-09-29T22:27:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163039",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:10'></a>Replying to [comment:9 dcoudert]:
> It is true that A*A*A is a bit faster, but not in the real field where it seems very slow.


`RR = RealField(53)` is arbitrary precision reals, so perhaps predictably slow, given the generality.

`RDF` (real double field) is floating point doubles.  Whatever the 53-bit precision IEEE format is.  Try adjacency matrices over that ring.  They might be an improvement.



---

archive/issue_comments_163040.json:
```json
{
    "body": "<a id='comment:11'></a>Since the adjacency matrix is a matrix of integers (in fact booleans or bits), I expect matrix multiplication  to be significantly faster than in any other rings.",
    "created_at": "2012-09-30T08:22:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163040",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:11'></a>Since the adjacency matrix is a matrix of integers (in fact booleans or bits), I expect matrix multiplication  to be significantly faster than in any other rings.



---

archive/issue_comments_163041.json:
```json
{
    "body": "<a id='comment:12'></a>HMmmm... I just read your tests, and did not get this one :\n\n```\nsage: %timeit G.is_triangle_free()\n5 loops, best of 3: 1.1 s per loop\nsage: %timeit (M^3).trace() > 0\n5 loops, best of 3: 1.04 s per loop\nsage: %timeit my_is_triangle_free(G)\n5 loops, best of 3: 63.8 ms per loop\n```\n\nCould it be that there would be another difference in runtimes if one requires the adjacency matrix to be *dense* ? `:-)`\n\nNathann",
    "created_at": "2012-09-30T16:23:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163041",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:12'></a>HMmmm... I just read your tests, and did not get this one :

```
sage: %timeit G.is_triangle_free()
5 loops, best of 3: 1.1 s per loop
sage: %timeit (M^3).trace() > 0
5 loops, best of 3: 1.04 s per loop
sage: %timeit my_is_triangle_free(G)
5 loops, best of 3: 63.8 ms per loop
```

Could it be that there would be another difference in runtimes if one requires the adjacency matrix to be *dense* ? `:-)`

Nathann



---

archive/issue_comments_163042.json:
```json
{
    "body": "<a id='comment:13'></a>If the graph is dense, the first visited vertex will have a triangle with high probability. So after a very small number of iterations and so operations, the algorithm returns False. But with matrix multiplications, you have to pay the full cost whatever the result.\n\nOf course, if the graph is dense and triangle free (not so many such graphs), my algorithm will take long time, and possibly more than matrix multiplications, but in average it is faster. Do your own experiments to convince yourself.\n\nSo for testing if G is triangle free, it is good to have a parameter to choose the algorithm, and a default behavior like: if G has less than 15 nodes, then do matrix multiplications, else use other algo.\n\nFor counting triangles, the situation is different and we clearly have to take into account the density to choose the best algorithm.",
    "created_at": "2012-09-30T16:44:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163042",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:13'></a>If the graph is dense, the first visited vertex will have a triangle with high probability. So after a very small number of iterations and so operations, the algorithm returns False. But with matrix multiplications, you have to pay the full cost whatever the result.

Of course, if the graph is dense and triangle free (not so many such graphs), my algorithm will take long time, and possibly more than matrix multiplications, but in average it is faster. Do your own experiments to convince yourself.

So for testing if G is triangle free, it is good to have a parameter to choose the algorithm, and a default behavior like: if G has less than 15 nodes, then do matrix multiplications, else use other algo.

For counting triangles, the situation is different and we clearly have to take into account the density to choose the best algorithm.



---

archive/issue_comments_163043.json:
```json
{
    "body": "<a id='comment:14'></a>Two interesting (worst case) examples: \n\n```\nsage: G = graphs.CompleteBipartiteGraph(100,100); M = G.adjacency_matrix()\nsage: G.density()\n100/199\nsage: %timeit not (M*M*M).trace()\n5 loops, best of 3: 59.8 ms per loop\nsage: %timeit my_is_triangle_free(G)\n5 loops, best of 3: 5.66 s per loop\nsage:\nsage: G = graphs.RandomGNP(200,100/199); M = G.adjacency_matrix()\nsage: G.density()\n10009/19900\nsage: %timeit not (M*M*M).trace()\n5 loops, best of 3: 63.8 ms per loop\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 300 \u00b5s per loop\n```",
    "created_at": "2012-09-30T17:33:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163043",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:14'></a>Two interesting (worst case) examples: 

```
sage: G = graphs.CompleteBipartiteGraph(100,100); M = G.adjacency_matrix()
sage: G.density()
100/199
sage: %timeit not (M*M*M).trace()
5 loops, best of 3: 59.8 ms per loop
sage: %timeit my_is_triangle_free(G)
5 loops, best of 3: 5.66 s per loop
sage:
sage: G = graphs.RandomGNP(200,100/199); M = G.adjacency_matrix()
sage: G.density()
10009/19900
sage: %timeit not (M*M*M).trace()
5 loops, best of 3: 63.8 ms per loop
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 300 µs per loop
```



---

archive/issue_comments_163044.json:
```json
{
    "body": "<a id='comment:15'></a>Replying to [comment:11 dcoudert]:\n> Since the adjacency matrix is a matrix of integers (in fact booleans or bits), I expect matrix multiplication  to be significantly faster than in any other rings.\n\n\nI'd guess that managing (potentially) large integers has more overhead than managing doubles:\n\n```\nsage: G = graphs.CompleteBipartiteGraph(100, 100)\nsage: M = G.am()\nsage: timeit(\"M*M*M\")\n25 loops, best of 3: 31 ms per loop\nsage: MR = M.change_ring(RDF)\nsage: timeit(\"MR*MR*MR\")     \n125 loops, best of 3: 2.4 ms per loop\nsage: (MR*MR*MR).trace()\n0.0\n```\n\nI can't recall seeing a Sage class for integers of a bounded size.",
    "created_at": "2012-09-30T17:58:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163044",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:15'></a>Replying to [comment:11 dcoudert]:
> Since the adjacency matrix is a matrix of integers (in fact booleans or bits), I expect matrix multiplication  to be significantly faster than in any other rings.


I'd guess that managing (potentially) large integers has more overhead than managing doubles:

```
sage: G = graphs.CompleteBipartiteGraph(100, 100)
sage: M = G.am()
sage: timeit("M*M*M")
25 loops, best of 3: 31 ms per loop
sage: MR = M.change_ring(RDF)
sage: timeit("MR*MR*MR")     
125 loops, best of 3: 2.4 ms per loop
sage: (MR*MR*MR).trace()
0.0
```

I can't recall seeing a Sage class for integers of a bounded size.



---

archive/issue_comments_163045.json:
```json
{
    "body": "<a id='comment:16'></a>I'm certainly not used to matrix multiplications and rings in sage, and I'm surprised that computing with doubles is faster than with integer. For instance, if G has `10^6` vertices, then since M is a matrix of 0 and 1's, the largest value in `M^3` is in `10^18 < 2^63` and so all computations are doable using 64bits integers.\n\nFollowing your example, and after some search, I found a much faster solution: use GF(2)\n\n```\nsage: G = graphs.CompleteBipartiteGraph(100,100); M = G.am(); M\n200 x 200 dense matrix over Integer Ring (type 'print M.str()' to see all of the entries)\nsage: %timeit not (M*M*M).trace()\n5 loops, best of 3: 39.5 ms per loop\nsage: MR = M.change_ring(RDF); MR\n200 x 200 dense matrix over Real Double Field (type 'print MR.str()' to see all of the entries)\nsage: %timeit (MR*MR*MR).trace() == 0.0\n125 loops, best of 3: 1.47 ms per loop\nsage: M2 = M.change_ring(GF(2)); M2\n200 x 200 dense matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)\nsage: %timeit not (M2*M2*M2).trace()\n625 loops, best of 3: 201 \u00b5s per loop\n```\n\n\nHowever, this is not always the best solution and it is extremely slow for sparse matrix O_o\n\n```\nsage: G = graphs.RandomGNP(1000,.1); M = G.am(); M2 = M.change_ring(GF(2)); M2\n1000 x 1000 dense matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 424 \u00b5s per loop\nsage: %timeit not (M2*M2*M2).trace()\n125 loops, best of 3: 4.09 ms per loop\nsage: MR = M.change_ring(RDF)\nsage: %timeit (MR*MR*MR).trace() == 0.0\n5 loops, best of 3: 96.9 ms per loop\nsage:\nsage: G = graphs.RandomGNP(1000,.01); M = G.am(); M2 = M.change_ring(GF(2)); M2\n1000 x 1000 sparse matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 594 \u00b5s per loop\nsage: %timeit not (M2*M2*M2).trace()\n5 loops, best of 3: 3.41 s per loop\nsage: MR = M.change_ring(RDF)\n5 loops, best of 3: 8.08 s per loop\nsage:\nsage: G = graphs.RandomGNP(100,.01); M = G.am(); M2 = M.change_ring(GF(2)); M2\n100 x 100 dense matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 1.22 ms per loop\nsage: %timeit not (M2*M2*M2).trace()\n625 loops, best of 3: 95.7 \u00b5s per loop\nsage:\nsage: G = graphs.RandomGNP(100,.1); M = G.am(); M2 = M.change_ring(GF(2)); M2\n100 x 100 dense matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)\nsage: %timeit my_is_triangle_free(G)\n625 loops, best of 3: 71.4 \u00b5s per loop\nsage: %timeit not (M2*M2*M2).trace()\n625 loops, best of 3: 95.5 \u00b5s per loop\n```\n\nI don't know how to force a matrix to be dense. for \"small\" graphs, it is apparently always dense. \n\nClearly, the algorithm should use tradeoffs between size and density.",
    "created_at": "2012-09-30T22:20:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163045",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:16'></a>I'm certainly not used to matrix multiplications and rings in sage, and I'm surprised that computing with doubles is faster than with integer. For instance, if G has `10^6` vertices, then since M is a matrix of 0 and 1's, the largest value in `M^3` is in `10^18 < 2^63` and so all computations are doable using 64bits integers.

Following your example, and after some search, I found a much faster solution: use GF(2)

```
sage: G = graphs.CompleteBipartiteGraph(100,100); M = G.am(); M
200 x 200 dense matrix over Integer Ring (type 'print M.str()' to see all of the entries)
sage: %timeit not (M*M*M).trace()
5 loops, best of 3: 39.5 ms per loop
sage: MR = M.change_ring(RDF); MR
200 x 200 dense matrix over Real Double Field (type 'print MR.str()' to see all of the entries)
sage: %timeit (MR*MR*MR).trace() == 0.0
125 loops, best of 3: 1.47 ms per loop
sage: M2 = M.change_ring(GF(2)); M2
200 x 200 dense matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)
sage: %timeit not (M2*M2*M2).trace()
625 loops, best of 3: 201 µs per loop
```


However, this is not always the best solution and it is extremely slow for sparse matrix O_o

```
sage: G = graphs.RandomGNP(1000,.1); M = G.am(); M2 = M.change_ring(GF(2)); M2
1000 x 1000 dense matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 424 µs per loop
sage: %timeit not (M2*M2*M2).trace()
125 loops, best of 3: 4.09 ms per loop
sage: MR = M.change_ring(RDF)
sage: %timeit (MR*MR*MR).trace() == 0.0
5 loops, best of 3: 96.9 ms per loop
sage:
sage: G = graphs.RandomGNP(1000,.01); M = G.am(); M2 = M.change_ring(GF(2)); M2
1000 x 1000 sparse matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 594 µs per loop
sage: %timeit not (M2*M2*M2).trace()
5 loops, best of 3: 3.41 s per loop
sage: MR = M.change_ring(RDF)
5 loops, best of 3: 8.08 s per loop
sage:
sage: G = graphs.RandomGNP(100,.01); M = G.am(); M2 = M.change_ring(GF(2)); M2
100 x 100 dense matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 1.22 ms per loop
sage: %timeit not (M2*M2*M2).trace()
625 loops, best of 3: 95.7 µs per loop
sage:
sage: G = graphs.RandomGNP(100,.1); M = G.am(); M2 = M.change_ring(GF(2)); M2
100 x 100 dense matrix over Finite Field of size 2 (type 'print M2.str()' to see all of the entries)
sage: %timeit my_is_triangle_free(G)
625 loops, best of 3: 71.4 µs per loop
sage: %timeit not (M2*M2*M2).trace()
625 loops, best of 3: 95.5 µs per loop
```

I don't know how to force a matrix to be dense. for "small" graphs, it is apparently always dense. 

Clearly, the algorithm should use tradeoffs between size and density.



---

archive/issue_comments_163046.json:
```json
{
    "body": "<a id='comment:17'></a>> I don't know how to force a matrix to be dense.\n\n\n`mat.dense_matrix()` should do it.",
    "created_at": "2012-09-30T22:48:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163046",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:17'></a>> I don't know how to force a matrix to be dense.


`mat.dense_matrix()` should do it.



---

archive/issue_comments_163047.json:
```json
{
    "body": "<a id='comment:18'></a>`@`dcoudert \n\nWhile matrix multiplication over GF(2) is quite fast, it is wrong for the adjacency matrix. The trace of the cube of an adjacency matrix is always zero over GF(2).",
    "created_at": "2012-09-30T22:57:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163047",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:18'></a>`@`dcoudert 

While matrix multiplication over GF(2) is quite fast, it is wrong for the adjacency matrix. The trace of the cube of an adjacency matrix is always zero over GF(2).



---

archive/issue_comments_163048.json:
```json
{
    "body": "<a id='comment:19'></a>> While matrix multiplication over GF(2) is quite fast, it is wrong for the adjacency matrix. The trace of the cube of an adjacency matrix is always zero over GF(2).\n\n\nThat's a pity :(\n\nAny interesting alternatives?\nAt least you can force matrices to be dense, but for small graphs (10 nodes), the extra cost might be non-negligeable.",
    "created_at": "2012-09-30T23:15:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163048",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:19'></a>> While matrix multiplication over GF(2) is quite fast, it is wrong for the adjacency matrix. The trace of the cube of an adjacency matrix is always zero over GF(2).


That's a pity :(

Any interesting alternatives?
At least you can force matrices to be dense, but for small graphs (10 nodes), the extra cost might be non-negligeable.



---

archive/issue_comments_163049.json:
```json
{
    "body": "<a id='comment:20'></a>\"dense\" in Sage is an implementation detail.  Any matrix can be made dense or sparse, even if it is not a good idea for the algorithm at hand.\n\nIn the discussion here, the actual \"density\" of the adjacency matrix is relevant for which approach (matrix algebra, vertex neighborhoods) might be faster.",
    "created_at": "2012-09-30T23:35:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163049",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:20'></a>"dense" in Sage is an implementation detail.  Any matrix can be made dense or sparse, even if it is not a good idea for the algorithm at hand.

In the discussion here, the actual "density" of the adjacency matrix is relevant for which approach (matrix algebra, vertex neighborhoods) might be faster.



---

archive/issue_comments_163050.json:
```json
{
    "body": "<a id='comment:21'></a>Right.\n\nA reasonably fast alternative to matrix multiplication (could be improved):\n\n```\ndef my_is_triangle_free_bitset(G):\n    map = {}\n    i = 0\n    for u in G.vertex_iterator():\n        map[u] = i\n        i += 1\n    B = {}\n    for u in G.vertex_iterator():\n        B[u] = Bitset([map[i] for i in G.neighbor_iterator(u)])\n    BB = {}\n    for u in G.vertex_iterator():\n        BB[u] = Bitset()\n        for v in G.vertex_iterator():\n            if B[u]&B[v]:\n                BB[u].add(map[v])\n    return not any(B[u]&BB[u] for u in G.vertex_iterator())\n\ndef toto(G):\n    M = G.am()\n    return not (M*M*M).trace()\n```\n\n```\nsage: G = graphs.CompleteBipartiteGraph(3,3)\nsage: %timeit toto(G)                \n625 loops, best of 3: 256 \u00b5s per loop\nsage: %timeit my_is_triangle_free_bitset(G)\n625 loops, best of 3: 132 \u00b5s per loop\nsage:\nsage: G = graphs.CompleteBipartiteGraph(30,30)\nsage: %timeit toto(G)\n25 loops, best of 3: 15 ms per loop\nsage: %timeit my_is_triangle_free_bitset(G)\n125 loops, best of 3: 6.99 ms per loop\n\n```",
    "created_at": "2012-09-30T23:57:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163050",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:21'></a>Right.

A reasonably fast alternative to matrix multiplication (could be improved):

```
def my_is_triangle_free_bitset(G):
    map = {}
    i = 0
    for u in G.vertex_iterator():
        map[u] = i
        i += 1
    B = {}
    for u in G.vertex_iterator():
        B[u] = Bitset([map[i] for i in G.neighbor_iterator(u)])
    BB = {}
    for u in G.vertex_iterator():
        BB[u] = Bitset()
        for v in G.vertex_iterator():
            if B[u]&B[v]:
                BB[u].add(map[v])
    return not any(B[u]&BB[u] for u in G.vertex_iterator())

def toto(G):
    M = G.am()
    return not (M*M*M).trace()
```

```
sage: G = graphs.CompleteBipartiteGraph(3,3)
sage: %timeit toto(G)                
625 loops, best of 3: 256 µs per loop
sage: %timeit my_is_triangle_free_bitset(G)
625 loops, best of 3: 132 µs per loop
sage:
sage: G = graphs.CompleteBipartiteGraph(30,30)
sage: %timeit toto(G)
25 loops, best of 3: 15 ms per loop
sage: %timeit my_is_triangle_free_bitset(G)
125 loops, best of 3: 6.99 ms per loop

```



---

archive/issue_comments_163051.json:
```json
{
    "body": "<a id='comment:22'></a>Replying to [comment:21 dcoudert]:\n> A reasonably fast alternative to matrix multiplication (could be improved):\n\n\nI like the looks of `my_is_triangle_free_bitset`.  \n\nIt is too bad more of these bit-by-bit type operations are not more easily available for graphs.  I know the folks working on the matroid classes are implementing a lot of duplicate functionality to be faster in tese sorts of situations (like matrix operations).\n\nRob",
    "created_at": "2012-10-02T04:32:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163051",
    "user": "https://github.com/rbeezer"
}
```

<a id='comment:22'></a>Replying to [comment:21 dcoudert]:
> A reasonably fast alternative to matrix multiplication (could be improved):


I like the looks of `my_is_triangle_free_bitset`.  

It is too bad more of these bit-by-bit type operations are not more easily available for graphs.  I know the folks working on the matroid classes are implementing a lot of duplicate functionality to be faster in tese sorts of situations (like matrix operations).

Rob



---

archive/issue_comments_163052.json:
```json
{
    "body": "<a id='comment:23'></a>Well, the difficulty with graph algorithms is that the efficiency depends on the data structure, and we have as many possibilities as algorithms. bit-by-bit operations are suitable for some kind of operations, but other representations are also helpful. Sometimes it is faster to turn the graph into a networkx graph (e.g. when adding/removing edges to test some property), but sometimes the extra cost of changing the graph structure is non negligible. I don't have magic solution but it's true that we could gather some sets of operations into dedicated graph structures as for instance the FastGraph class Nathann has used for pathwidth.\n\nThis version is a bit faster\n\n```\ndef my_is_triangle_free_bitset(G):\n    N = G.num_verts()\n    map = {}\n    i = 0\n    B = {}\n    for u in G.vertex_iterator():\n        map[u] = i\n        i += 1\n        B[u] = Bitset(capacity=N)\n    # map adjacency to bitsets\n    for u,v in G.edge_iterator(labels=None):\n        B[u].add(map[v])\n        B[v].add(map[u])\n    # map lengths 2 paths to bitsets\n    BB = {}\n    for u in G.vertex_iterator():\n        BB[u] = Bitset(capacity=N)\n        for v in G.vertex_iterator():\n            if B[u]&B[v]:\n                BB[u].add(map[v])\n    # search for triangles\n    return not any(B[u]&BB[u] for u in G.vertex_iterator())\n```",
    "created_at": "2012-10-02T07:18:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163052",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:23'></a>Well, the difficulty with graph algorithms is that the efficiency depends on the data structure, and we have as many possibilities as algorithms. bit-by-bit operations are suitable for some kind of operations, but other representations are also helpful. Sometimes it is faster to turn the graph into a networkx graph (e.g. when adding/removing edges to test some property), but sometimes the extra cost of changing the graph structure is non negligible. I don't have magic solution but it's true that we could gather some sets of operations into dedicated graph structures as for instance the FastGraph class Nathann has used for pathwidth.

This version is a bit faster

```
def my_is_triangle_free_bitset(G):
    N = G.num_verts()
    map = {}
    i = 0
    B = {}
    for u in G.vertex_iterator():
        map[u] = i
        i += 1
        B[u] = Bitset(capacity=N)
    # map adjacency to bitsets
    for u,v in G.edge_iterator(labels=None):
        B[u].add(map[v])
        B[v].add(map[u])
    # map lengths 2 paths to bitsets
    BB = {}
    for u in G.vertex_iterator():
        BB[u] = Bitset(capacity=N)
        for v in G.vertex_iterator():
            if B[u]&B[v]:
                BB[u].add(map[v])
    # search for triangles
    return not any(B[u]&BB[u] for u in G.vertex_iterator())
```



---

archive/issue_comments_163053.json:
```json
{
    "body": "<a id='comment:24'></a>I have included discussed improvements into the `is_triangle_free` and the `triangles_count` methods, and added optional argument for algorithm selection. \nOne could also add probabilistic test for triangle detection. \n\nCould you benchmark the new functions to update the ticket description?",
    "created_at": "2012-10-20T11:33:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163053",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:24'></a>I have included discussed improvements into the `is_triangle_free` and the `triangles_count` methods, and added optional argument for algorithm selection. 
One could also add probabilistic test for triangle detection. 

Could you benchmark the new functions to update the ticket description?



---

archive/issue_comments_163054.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-10-20T11:33:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163054",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_163055.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-10-22T08:45:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163055",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_163056.json:
```json
{
    "body": "<a id='comment:25'></a>Hellooooooooo David !!\n\nFirst, you do not know how glad I am to hear things like \"the difficulty with graph algorithms is that the efficiency depends on the data structure\" from the mouth of researchers. \"Adjacency test ? O(1) !\" is their usual answer. `:-D`\n\nI have been thinking of reimplementing another version using FastGraph, but that would be more trouble than necessary for the moment. And I could actually use the same technique to reimplement SubgraphSearch a bit better anyway, so I guess I will go there directly.\n\nAbout the patch :\n\n* Where did you find that this \"abs\" was not needed ? I thought it was `O_o`\n* I'm not a big fan of having triangle_count in generic_graph, as I don't really see it used with DiGraphs... And the code reflects that indeed, but if you think they can, then why not ? Could you at least say that not all algorithms are available for Digraphs, and that the method looks for \"directed C3\" in this case, or something similar ? And in particular not C3 in the underlying graph.\n* \"tests if the trace of the adjacency matrix is positive\" would be counting the number of loops `:-D` Btw I guess it would be better to have \"``return (A * * 3 ).trace() == 0``\" instead of \"``return (A*A*A).trace() == 0``\", just in case they might implement some smart thing for powers of binary matrices eventually... The logarithmic power method changes nothing for `k=3` `:-)`\n\nThanks for that patch !!\n\nnathann",
    "created_at": "2012-10-22T08:45:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163056",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:25'></a>Hellooooooooo David !!

First, you do not know how glad I am to hear things like "the difficulty with graph algorithms is that the efficiency depends on the data structure" from the mouth of researchers. "Adjacency test ? O(1) !" is their usual answer. `:-D`

I have been thinking of reimplementing another version using FastGraph, but that would be more trouble than necessary for the moment. And I could actually use the same technique to reimplement SubgraphSearch a bit better anyway, so I guess I will go there directly.

About the patch :

* Where did you find that this "abs" was not needed ? I thought it was `O_o`
* I'm not a big fan of having triangle_count in generic_graph, as I don't really see it used with DiGraphs... And the code reflects that indeed, but if you think they can, then why not ? Could you at least say that not all algorithms are available for Digraphs, and that the method looks for "directed C3" in this case, or something similar ? And in particular not C3 in the underlying graph.
* "tests if the trace of the adjacency matrix is positive" would be counting the number of loops `:-D` Btw I guess it would be better to have "``return (A * * 3 ).trace() == 0``" instead of "``return (A*A*A).trace() == 0``", just in case they might implement some smart thing for powers of binary matrices eventually... The logarithmic power method changes nothing for `k=3` `:-)`

Thanks for that patch !!

nathann



---

archive/issue_comments_163057.json:
```json
{
    "body": "<a id='comment:26'></a>>     * Where did you find that this \"abs\" was not needed ? I thought it was `O_o`\n\n\nIt was in the original patch  from Jernej Azarija ([trac_17334_triangle_free_speedup.patch]). I don't know if its true or not, and since the gain is very limited, we could put it back to be on the safe side.\n\n>     * I'm not a big fan of having triangle_count in generic_graph, as I don't really see it used with DiGraphs... And the code reflects that indeed, but if you think they can, then why not ? Could you at least say that not all algorithms are available for Digraphs, and that the method looks for \"directed C3\" in this case, or something similar ? And in particular not C3 in the underlying graph.\n\n\nJernej should answer that remark.\n\n\n>     * \"tests if the trace of the adjacency matrix is positive\" would be counting the number of loops `:-D` Btw I guess it would be better to have \"``return (A * * 3 ).trace() == 0``\" instead of \"``return (A*A*A).trace() == 0``\", just in case they might implement some smart thing for powers of binary matrices eventually... The logarithmic power method changes nothing for `k=3` `:-)`\n\n\nOK.\n\nI have implemented some of the modifications.\n\n> Thanks for that patch !!\n\n\nI was also thinking of some nice and fast methods from Alon et al., or from Latapy (see the code in c and the survey at [http://www-rp.lip6.fr/~latapy/Triangles/](http://www-rp.lip6.fr/~latapy/Triangles/)). We could add them (in particular the compact-forward method) at the cost of adding an interface and a method for converting the graph into the tricky data structure used by Latapy.",
    "created_at": "2012-10-22T09:47:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163057",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:26'></a>>     * Where did you find that this "abs" was not needed ? I thought it was `O_o`


It was in the original patch  from Jernej Azarija ([trac_17334_triangle_free_speedup.patch]). I don't know if its true or not, and since the gain is very limited, we could put it back to be on the safe side.

>     * I'm not a big fan of having triangle_count in generic_graph, as I don't really see it used with DiGraphs... And the code reflects that indeed, but if you think they can, then why not ? Could you at least say that not all algorithms are available for Digraphs, and that the method looks for "directed C3" in this case, or something similar ? And in particular not C3 in the underlying graph.


Jernej should answer that remark.


>     * "tests if the trace of the adjacency matrix is positive" would be counting the number of loops `:-D` Btw I guess it would be better to have "``return (A * * 3 ).trace() == 0``" instead of "``return (A*A*A).trace() == 0``", just in case they might implement some smart thing for powers of binary matrices eventually... The logarithmic power method changes nothing for `k=3` `:-)`


OK.

I have implemented some of the modifications.

> Thanks for that patch !!


I was also thinking of some nice and fast methods from Alon et al., or from Latapy (see the code in c and the survey at [http://www-rp.lip6.fr/~latapy/Triangles/](http://www-rp.lip6.fr/~latapy/Triangles/)). We could add them (in particular the compact-forward method) at the cost of adding an interface and a method for converting the graph into the tricky data structure used by Latapy.



---

archive/issue_comments_163058.json:
```json
{
    "body": "<a id='comment:27'></a>Replying to [comment:26 dcoudert]:\n> \n> >     * Where did you find that this \"abs\" was not needed ? I thought it was `O_o`\n \n> \n> It was in the original patch  from Jernej Azarija ([trac_17334_triangle_free_speedup.patch]). I don't know if its true or not, and since the gain is very limited, we could put it back to be on the safe side.\n\nabs is not needed. Perhaps we can still remove it from this patch and I add it later in a generic patch fixing various small details in graph.py. The reason it is not needed is that Kirchhoff matrix tree theorem states that the number of spanning trees equals \n\ndet(L')*(-1)^(i+j}+) \n\nwhere L' is the matrix that is obtained from the Laplacian after removing row i and column j.\n\n> \n> >     * I'm not a big fan of having triangle_count in generic_graph, as I don't really see it used with DiGraphs... And the code reflects that indeed, but if you think they can, then why not ? Could you at least say that not all algorithms are available for Digraphs, and that the method looks for \"directed C3\" in this case, or something similar ? And in particular not C3 in the underlying graph.\n\n\n> \n> Jernej should answer that remark.\n\nI am not really sure what to do here. \n> \n> \n> >     * \"tests if the trace of the adjacency matrix is positive\" would be counting the number of loops `:-D` Btw I guess it would be better to have \"``return (A * * 3 ).trace() == 0``\" instead of \"``return (A*A*A).trace() == 0``\", just in case they might implement some smart thing for powers of binary matrices eventually... The logarithmic power method changes nothing for `k=3` `:-)`\n \n> \n> OK.\n> \n> I have implemented some of the modifications.\n> \n> > Thanks for that patch !!\n\n> \n> I was also thinking of some nice and fast methods from Alon et al., or from Latapy (see the code in c and the survey at [http://www-rp.lip6.fr/~latapy/Triangles/](http://www-rp.lip6.fr/~latapy/Triangles/)). We could add them (in particular the compact-forward method) at the cost of adding an interface and a method for converting the graph into the tricky data structure used by Latapy.\n\n\nHaven't looked at the site yet, but is it hard to implement the algorithm directly into sage?",
    "created_at": "2012-10-28T08:37:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163058",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:27'></a>Replying to [comment:26 dcoudert]:
> 
> >     * Where did you find that this "abs" was not needed ? I thought it was `O_o`
 
> 
> It was in the original patch  from Jernej Azarija ([trac_17334_triangle_free_speedup.patch]). I don't know if its true or not, and since the gain is very limited, we could put it back to be on the safe side.

abs is not needed. Perhaps we can still remove it from this patch and I add it later in a generic patch fixing various small details in graph.py. The reason it is not needed is that Kirchhoff matrix tree theorem states that the number of spanning trees equals 

det(L')*(-1)^(i+j}+) 

where L' is the matrix that is obtained from the Laplacian after removing row i and column j.

> 
> >     * I'm not a big fan of having triangle_count in generic_graph, as I don't really see it used with DiGraphs... And the code reflects that indeed, but if you think they can, then why not ? Could you at least say that not all algorithms are available for Digraphs, and that the method looks for "directed C3" in this case, or something similar ? And in particular not C3 in the underlying graph.


> 
> Jernej should answer that remark.

I am not really sure what to do here. 
> 
> 
> >     * "tests if the trace of the adjacency matrix is positive" would be counting the number of loops `:-D` Btw I guess it would be better to have "``return (A * * 3 ).trace() == 0``" instead of "``return (A*A*A).trace() == 0``", just in case they might implement some smart thing for powers of binary matrices eventually... The logarithmic power method changes nothing for `k=3` `:-)`
 
> 
> OK.
> 
> I have implemented some of the modifications.
> 
> > Thanks for that patch !!

> 
> I was also thinking of some nice and fast methods from Alon et al., or from Latapy (see the code in c and the survey at [http://www-rp.lip6.fr/~latapy/Triangles/](http://www-rp.lip6.fr/~latapy/Triangles/)). We could add them (in particular the compact-forward method) at the cost of adding an interface and a method for converting the graph into the tricky data structure used by Latapy.


Haven't looked at the site yet, but is it hard to implement the algorithm directly into sage?



---

archive/issue_comments_163059.json:
```json
{
    "body": "<a id='comment:28'></a>Replying to [comment:27 azi]:\n> Replying to [comment:26 dcoudert]:\n> > \n> > >     * Where did you find that this \"abs\" was not needed ? I thought it was `O_o`\n \n> > \n> > It was in the original patch  from Jernej Azarija ([trac_17334_triangle_free_speedup.patch]). I don't know if its true or not, and since the gain is very limited, we could put it back to be on the safe side.\n\n> abs is not needed. Perhaps we can still remove it from this patch and I add it later in a generic patch fixing various small details in graph.py. The reason it is not needed is that Kirchhoff matrix tree theorem states that the number of spanning trees equals \n> \n> det(L')*(-1)^(i+j}+) \n> \n> where L' is the matrix that is obtained from the Laplacian after removing row i and column j.\n\n\nyes, it is better to remove the abs in a patch dedicated to small details ;-)\n\n\n> > I was also thinking of some nice and fast methods from Alon et al., or from Latapy (see the code in c and the survey at [http://www-rp.lip6.fr/~latapy/Triangles/](http://www-rp.lip6.fr/~latapy/Triangles/)). We could add them (in particular the compact-forward method) at the cost of adding an interface and a method for converting the graph into the tricky data structure used by Latapy.\n\n> \n> Haven't looked at the site yet, but is it hard to implement the algorithm directly into sage?\n\n\nIt's difficult in python. The method is fast because it uses optimized data structure. It can be done in cython, but then it is certainly better to only implement the interfaces with the original c code of Latapy. We can easily obtained agreement from him for integrating is code in sage.\nThis should be done in a dedicated patch to ease reviewing process.",
    "created_at": "2012-10-28T11:23:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163059",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:28'></a>Replying to [comment:27 azi]:
> Replying to [comment:26 dcoudert]:
> > 
> > >     * Where did you find that this "abs" was not needed ? I thought it was `O_o`
 
> > 
> > It was in the original patch  from Jernej Azarija ([trac_17334_triangle_free_speedup.patch]). I don't know if its true or not, and since the gain is very limited, we could put it back to be on the safe side.

> abs is not needed. Perhaps we can still remove it from this patch and I add it later in a generic patch fixing various small details in graph.py. The reason it is not needed is that Kirchhoff matrix tree theorem states that the number of spanning trees equals 
> 
> det(L')*(-1)^(i+j}+) 
> 
> where L' is the matrix that is obtained from the Laplacian after removing row i and column j.


yes, it is better to remove the abs in a patch dedicated to small details ;-)


> > I was also thinking of some nice and fast methods from Alon et al., or from Latapy (see the code in c and the survey at [http://www-rp.lip6.fr/~latapy/Triangles/](http://www-rp.lip6.fr/~latapy/Triangles/)). We could add them (in particular the compact-forward method) at the cost of adding an interface and a method for converting the graph into the tricky data structure used by Latapy.

> 
> Haven't looked at the site yet, but is it hard to implement the algorithm directly into sage?


It's difficult in python. The method is fast because it uses optimized data structure. It can be done in cython, but then it is certainly better to only implement the interfaces with the original c code of Latapy. We can easily obtained agreement from him for integrating is code in sage.
This should be done in a dedicated patch to ease reviewing process.



---

archive/issue_comments_163060.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-10-28T12:21:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163060",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_163061.json:
```json
{
    "body": "<a id='comment:30'></a>Can someone review this patch?",
    "created_at": "2012-11-19T06:07:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163061",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:30'></a>Can someone review this patch?



---

archive/issue_comments_163062.json:
```json
{
    "body": "<a id='comment:31'></a>> Can someone review this patch?\n\n\nWell. Why wouldn't you ? `^^;`\n\nIt looks like David updated the patch last, so you can review his changes.. I mean, for as long as two persons look at the file together and agree that it is all good, we usually accept this as a review and put both names as Authors and Reviewers `:-)`\n\nNathann",
    "created_at": "2012-11-20T10:20:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163062",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:31'></a>> Can someone review this patch?


Well. Why wouldn't you ? `^^;`

It looks like David updated the patch last, so you can review his changes.. I mean, for as long as two persons look at the file together and agree that it is all good, we usually accept this as a review and put both names as Authors and Reviewers `:-)`

Nathann



---

archive/issue_comments_163063.json:
```json
{
    "body": "<a id='comment:32'></a>Oh, didn't know I can do that too. Here we go...\n\nI have tested the code briefly and it looks good to me as far as correction goes. I have two additional remarks though.\n\n1. Can we avoid using graphx? Why exactly are we using it? I know its because of performance but what exactly is making the algorithm tick that faster? It doesn\u2019t seem the right thing (to me) to call a graphx object for this purpose but rather see where the problem in Sage is. Its weird that its that faster even when you take the wrapping overhead into account.\n\n2. The code in is_triangle_free currently looks as follows\n\n```\n            BB = {} \n            for u in self.vertex_iterator():\n                BB[u] = Bitset(capacity=N)\n                for v in self.vertex_iterator():\n                    if B[u]&B[v]:\n                        BB[u].add(map[v])\n\n            # search for triangles\n            return not any(B[u]&BB[u] for u in self.vertex_iterator())\n```\n\nAm I missing something or this should be equivalent (to the slightly more optimal):\n\n```\n            BB = {} \n            for u in self.vertex_iterator():\n                BB[u] = Bitset(capacity=N)\n                for v in self.vertex_iterator():\n                    if B[u]&B[v]:\n                        BB[u].add(map[v])\n                if B[u] & BB[u] == 1:\n                   return False\n\n            return True\n```",
    "created_at": "2012-11-20T13:26:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163063",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:32'></a>Oh, didn't know I can do that too. Here we go...

I have tested the code briefly and it looks good to me as far as correction goes. I have two additional remarks though.

1. Can we avoid using graphx? Why exactly are we using it? I know its because of performance but what exactly is making the algorithm tick that faster? It doesn’t seem the right thing (to me) to call a graphx object for this purpose but rather see where the problem in Sage is. Its weird that its that faster even when you take the wrapping overhead into account.

2. The code in is_triangle_free currently looks as follows

```
            BB = {} 
            for u in self.vertex_iterator():
                BB[u] = Bitset(capacity=N)
                for v in self.vertex_iterator():
                    if B[u]&B[v]:
                        BB[u].add(map[v])

            # search for triangles
            return not any(B[u]&BB[u] for u in self.vertex_iterator())
```

Am I missing something or this should be equivalent (to the slightly more optimal):

```
            BB = {} 
            for u in self.vertex_iterator():
                BB[u] = Bitset(capacity=N)
                for v in self.vertex_iterator():
                    if B[u]&B[v]:
                        BB[u].add(map[v])
                if B[u] & BB[u] == 1:
                   return False

            return True
```



---

archive/issue_comments_163064.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2012-11-20T13:49:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163064",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_163065.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2012-11-20T14:05:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163065",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_163066.json:
```json
{
    "body": "<a id='comment:34'></a>Attachment [trac_13503_triangles-v2.patch](tarball://root/attachments/some-uuid/ticket13503/trac_13503_triangles-v2.patch) by @dcoudert created at 2012-11-20 14:05:14\n\n1. networkx uses dictionaries to store edges. If G is a networkx graph, it is also a dictionary indexed by the vertices, and G[u] is a dictionary indexed by neighbors and containing edge data. This way, iterations are fast. I don't know exactly how are implemented sage graphs in the backends, and so I don't know how to speedup the basic iterations over the edges, the neighbors, etc. This is certainly needed.\n\n2. I have implemented the proposed modification in `is_triangle_free`.",
    "created_at": "2012-11-20T14:05:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163066",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:34'></a>Attachment [trac_13503_triangles-v2.patch](tarball://root/attachments/some-uuid/ticket13503/trac_13503_triangles-v2.patch) by @dcoudert created at 2012-11-20 14:05:14

1. networkx uses dictionaries to store edges. If G is a networkx graph, it is also a dictionary indexed by the vertices, and G[u] is a dictionary indexed by neighbors and containing edge data. This way, iterations are fast. I don't know exactly how are implemented sage graphs in the backends, and so I don't know how to speedup the basic iterations over the edges, the neighbors, etc. This is certainly needed.

2. I have implemented the proposed modification in `is_triangle_free`.



---

archive/issue_comments_163067.json:
```json
{
    "body": "<a id='comment:35'></a>Hello!\n\n1. I would suggest we make this into a new ticket or something - how to make graph structures more efficient , and leave the code as is for now?\n\nWhat do you guys think?",
    "created_at": "2012-11-20T14:34:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163067",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:35'></a>Hello!

1. I would suggest we make this into a new ticket or something - how to make graph structures more efficient , and leave the code as is for now?

What do you guys think?



---

archive/issue_comments_163068.json:
```json
{
    "body": "<a id='comment:36'></a>I agree.",
    "created_at": "2012-11-20T14:55:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163068",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:36'></a>I agree.



---

archive/issue_comments_163069.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-11-20T18:30:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163069",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_163070.json:
```json
{
    "body": "<a id='comment:37'></a>Okay. Could you (dcoudert) pleaase make another ticket that basically explains what you said under 1? We can then discuss this there.\n\nI'll mark this ticket with a positive review now.",
    "created_at": "2012-11-20T18:30:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163070",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:37'></a>Okay. Could you (dcoudert) pleaase make another ticket that basically explains what you said under 1? We can then discuss this there.

I'll mark this ticket with a positive review now.



---

archive/issue_comments_163071.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2012-12-21T09:31:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13503#issuecomment-163071",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_037452.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2012-12-21T09:31:42Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/13503",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13503#event-37452"
}
```
