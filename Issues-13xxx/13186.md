# Issue 13186: Equality, hashability of Factorizations

archive/issues_013014.json:
```json
{
    "body": "Assignee: tbd\n\nCC:  @xcaruso @tscrim\n\nKeywords: equality factorization\n\nCurrently, two Factorization object are considered to be equal if they have the same value, but a Factorization object is not equal to its value:\n\n```\nsage: P.<x> = QQ[]\nsage: a = x+1; b = x+2; c = x+3\nsage: F = Factorization([(a,1),(b,1),(c,1)]); F\n(x + 1) * (x + 2) * (x + 3)\nsage: F1 = Factorization([(a*b,1),(c,1)]); F1\n(x + 3) * (x^2 + 3*x + 2)\nsage: F2 = Factorization([(a,1),(b*c,1)]); F2\n(x + 1) * (x^2 + 5*x + 6)\nsage: F == F1\nTrue\nsage: F == F2\nTrue\nsage: F1 == F2\nTrue\nsage: F == a*b*c\nFalse\n```\n\nIs this normal? (It seems to me really weird.)\n\nPS: Am I supposed to ask this kind of questions here or is there a better place?\n\nIssue created by migration from https://trac.sagemath.org/ticket/13186\n\n",
    "created_at": "2012-06-30T12:09:20Z",
    "labels": [
        "component: factorization",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Equality, hashability of Factorizations",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13186",
    "user": "https://github.com/xcaruso"
}
```
Assignee: tbd

CC:  @xcaruso @tscrim

Keywords: equality factorization

Currently, two Factorization object are considered to be equal if they have the same value, but a Factorization object is not equal to its value:

```
sage: P.<x> = QQ[]
sage: a = x+1; b = x+2; c = x+3
sage: F = Factorization([(a,1),(b,1),(c,1)]); F
(x + 1) * (x + 2) * (x + 3)
sage: F1 = Factorization([(a*b,1),(c,1)]); F1
(x + 3) * (x^2 + 3*x + 2)
sage: F2 = Factorization([(a,1),(b*c,1)]); F2
(x + 1) * (x^2 + 5*x + 6)
sage: F == F1
True
sage: F == F2
True
sage: F1 == F2
True
sage: F == a*b*c
False
```

Is this normal? (It seems to me really weird.)

PS: Am I supposed to ask this kind of questions here or is there a better place?

Issue created by migration from https://trac.sagemath.org/ticket/13186





---

archive/issue_events_036345.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13186#event-36345"
}
```



---

archive/issue_comments_157105.json:
```json
{
    "body": "The methods `__eq__` and `__ne__` seems not to be implemented in the class.",
    "created_at": "2013-08-26T12:45:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157105",
    "user": "https://github.com/fchapoton"
}
```

The methods `__eq__` and `__ne__` seems not to be implemented in the class.



---

archive/issue_comments_157106.json:
```json
{
    "body": "I would happily implement them but I'm wondering what should be the correct behaviour of these methods. Do you have an opinion? (Don't forget that a ` Factorization` object can be \"non commutative\" as well.)",
    "created_at": "2013-08-26T13:08:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157106",
    "user": "https://github.com/xcaruso"
}
```

I would happily implement them but I'm wondering what should be the correct behaviour of these methods. Do you have an opinion? (Don't forget that a ` Factorization` object can be "non commutative" as well.)



---

archive/issue_comments_157107.json:
```json
{
    "body": "well, one could try the following in the comparison of self and other\n\n1) look if other is in self.parent (or maybe do that for the first factors)\n\n2) if not compare (the value of self) and other\n\n3) if yes, ask if self.parent is_commutative\n\n4) if yes, sort and compare ; if not compare without sorting ?",
    "created_at": "2013-08-26T15:27:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157107",
    "user": "https://github.com/fchapoton"
}
```

well, one could try the following in the comparison of self and other

1) look if other is in self.parent (or maybe do that for the first factors)

2) if not compare (the value of self) and other

3) if yes, ask if self.parent is_commutative

4) if yes, sort and compare ; if not compare without sorting ?



---

archive/issue_comments_157108.json:
```json
{
    "body": "Attachment [trac_13186_v1.patch](tarball://root/attachments/some-uuid/ticket13186/trac_13186_v1.patch) by @fchapoton created at 2013-08-27 09:42:44",
    "created_at": "2013-08-27T09:42:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157108",
    "user": "https://github.com/fchapoton"
}
```

Attachment [trac_13186_v1.patch](tarball://root/attachments/some-uuid/ticket13186/trac_13186_v1.patch) by @fchapoton created at 2013-08-27 09:42:44



---

archive/issue_comments_157109.json:
```json
{
    "body": "here is a patch with a proposal for `__eq__`",
    "created_at": "2013-08-27T09:43:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157109",
    "user": "https://github.com/fchapoton"
}
```

here is a patch with a proposal for `__eq__`



---

archive/issue_comments_157110.json:
```json
{
    "body": "The patch looks ok to me (but I also think that I'm not a good reviewer).\n\nI'm just wondering whether we really want this:\n\n```\nsage: factor(691*(x-4)*(x+6)) == factor(691*(y-4)*(y+6)) \nFalse \n```\n\nIndeed, even if 691 is a unit in one case and is not in the other case, the factorizations are the same, aren't they?",
    "created_at": "2013-08-28T19:18:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157110",
    "user": "https://github.com/xcaruso"
}
```

The patch looks ok to me (but I also think that I'm not a good reviewer).

I'm just wondering whether we really want this:

```
sage: factor(691*(x-4)*(x+6)) == factor(691*(y-4)*(y+6)) 
False 
```

Indeed, even if 691 is a unit in one case and is not in the other case, the factorizations are the same, aren't they?



---

archive/issue_comments_157111.json:
```json
{
    "body": "Well, one must choose the meaning of equality.\n\nOne precise meaning would be \n- a factorisation is made of a unit and a set/list of factors\n- two factorisations are equal if they have the same unit and the same factors (up to order maybe)\n\nAnother possible solution would be to consider the unit as just any other factor. I do no like this solution, and I prefer the previous (current) behavior \n\nIf you want, you can maybe ask for opinions on sage-devel.\n\nSomething else: I have just thought that it would sometimes be good to separate factors in the center of the ring (commuting) and other factors, and to implement \"partially commutative factorisations\". But this is something for the wishlist.",
    "created_at": "2013-08-29T08:07:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157111",
    "user": "https://github.com/fchapoton"
}
```

Well, one must choose the meaning of equality.

One precise meaning would be 
- a factorisation is made of a unit and a set/list of factors
- two factorisations are equal if they have the same unit and the same factors (up to order maybe)

Another possible solution would be to consider the unit as just any other factor. I do no like this solution, and I prefer the previous (current) behavior 

If you want, you can maybe ask for opinions on sage-devel.

Something else: I have just thought that it would sometimes be good to separate factors in the center of the ring (commuting) and other factors, and to implement "partially commutative factorisations". But this is something for the wishlist.



---

archive/issue_events_036346.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13186#event-36346"
}
```



---

archive/issue_events_036347.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13186#event-36347"
}
```



---

archive/issue_events_036348.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13186#event-36348"
}
```



---

archive/issue_events_036349.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13186#event-36349"
}
```



---

archive/issue_events_036350.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13186#event-36350"
}
```



---

archive/issue_events_036351.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13186#event-36351"
}
```



---

archive/issue_comments_157112.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-08-31T19:41:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157112",
    "user": "https://github.com/fchapoton"
}
```

New commits:



---

archive/issue_comments_157113.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-08-31T19:41:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157113",
    "user": "https://github.com/fchapoton"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_157114.json:
```json
{
    "body": "Hello,\n\nPlease add specifications to the doc! It is not clear to me (and to you as well looking at comment:8) what should be an equality between element.\n\nI really found weird the begining\n\n```\nif not isinstance(other, Factorization):\n    return self.value() == other\n```\nhow can you compare a factorization with something else. Would you like that\n\n```\nsage: [1,2,3] == (1,2,3)\nTrue\n```\n\nInstead of using `Sequence`, what about\n\n```\nsage: from sage.structure.element import get_coercion_model\nsage: cm = get_coercion_model()\nsage: cm.common_parent(1,1/2)\nRational field\n```\n(not so important, as at the end of the day the same code is called)\n\nIf the ring is commutative your test is wrong as the elements of the underlying universe are not necessarily sortable... you can not assume that the order is the same based on the fact that you call `sorted`. It might also depend on the specification you will add...\n\nYou need to define a `__ne__` if you want that `!=` works as well. Basically it would be\n\n```\ndef __ne__(self, other):\n    return not (self == other)\n```\n\nVincent",
    "created_at": "2014-08-31T21:40:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157114",
    "user": "https://github.com/videlec"
}
```

Hello,

Please add specifications to the doc! It is not clear to me (and to you as well looking at comment:8) what should be an equality between element.

I really found weird the begining

```
if not isinstance(other, Factorization):
    return self.value() == other
```
how can you compare a factorization with something else. Would you like that

```
sage: [1,2,3] == (1,2,3)
True
```

Instead of using `Sequence`, what about

```
sage: from sage.structure.element import get_coercion_model
sage: cm = get_coercion_model()
sage: cm.common_parent(1,1/2)
Rational field
```
(not so important, as at the end of the day the same code is called)

If the ring is commutative your test is wrong as the elements of the underlying universe are not necessarily sortable... you can not assume that the order is the same based on the fact that you call `sorted`. It might also depend on the specification you will add...

You need to define a `__ne__` if you want that `!=` works as well. Basically it would be

```
def __ne__(self, other):
    return not (self == other)
```

Vincent



---

archive/issue_comments_157115.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-08-31T21:40:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157115",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_157116.json:
```json
{
    "body": "There are other problems too:\n\n```\nsage: R.<x>=QQ[]\nsage: hash(x^2)\n15360174650385708\nsage: hash(factor(x^2))\n-5999452984666080493\nsage: factor(x^2).value()==x^2\nTrue\n```\nIf you want to equate factorizations with their values (a reasonable thing to do) then their hashes should be equal too. I'd think a reasonable thing to do is to set\n\n```\nfactor(A) == B iff factor(A).value() == B\nhash(factor(A)) == hash(factor(A).value())\n```\nand in fact to implement them by punting to the tests on values.\n\nNote that if \"factorizations\" are ever returned in domains that do not have unique factorizations, this might be confusing: after all, there are supposed to be factorizations of the same value into irreducibles there that are not mutually equal.",
    "created_at": "2014-08-31T22:39:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157116",
    "user": "https://github.com/nbruin"
}
```

There are other problems too:

```
sage: R.<x>=QQ[]
sage: hash(x^2)
15360174650385708
sage: hash(factor(x^2))
-5999452984666080493
sage: factor(x^2).value()==x^2
True
```
If you want to equate factorizations with their values (a reasonable thing to do) then their hashes should be equal too. I'd think a reasonable thing to do is to set

```
factor(A) == B iff factor(A).value() == B
hash(factor(A)) == hash(factor(A).value())
```
and in fact to implement them by punting to the tests on values.

Note that if "factorizations" are ever returned in domains that do not have unique factorizations, this might be confusing: after all, there are supposed to be factorizations of the same value into irreducibles there that are not mutually equal.



---

archive/issue_comments_157117.json:
```json
{
    "body": "There is now a `__richcmp__` method in this class. One needs to check if the issue still stands.",
    "created_at": "2017-09-14T12:39:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157117",
    "user": "https://github.com/fchapoton"
}
```

There is now a `__richcmp__` method in this class. One needs to check if the issue still stands.



---

archive/issue_comments_157118.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2017-09-14T12:39:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157118",
    "user": "https://github.com/fchapoton"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_157119.json:
```json
{
    "body": "The example from the ticket description gives the following in 9.7.rc0:\n\n```\nsage: F == F1\nFalse\nsage: F == F2\nFalse\nsage: F1 == F2\nFalse\nsage: F == a*b*c\nFalse\n```\nAlso:\n\n```\nsage: hash(F)\nTypeError: <class 'sage.structure.factorization.Factorization'> is not hashable\n```\n(see also #33932, example 1)",
    "created_at": "2022-08-31T21:27:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157119",
    "user": "https://github.com/mkoeppe"
}
```

The example from the ticket description gives the following in 9.7.rc0:

```
sage: F == F1
False
sage: F == F2
False
sage: F1 == F2
False
sage: F == a*b*c
False
```
Also:

```
sage: hash(F)
TypeError: <class 'sage.structure.factorization.Factorization'> is not hashable
```
(see also #33932, example 1)



---

archive/issue_events_036352.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T21:27:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13186#event-36352"
}
```



---

archive/issue_events_036353.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T21:27:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13186#event-36353"
}
```



---

archive/issue_comments_157120.json:
```json
{
    "body": "`Factorization` has implementations of `__copy__` and `__deepcopy__` that include examples with mutable prime factors.\n\nDo we have a use case for this, or should we just make `Factorization`s immutable and give it an implementation of `_hash_`?",
    "created_at": "2022-08-31T21:46:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157120",
    "user": "https://github.com/mkoeppe"
}
```

`Factorization` has implementations of `__copy__` and `__deepcopy__` that include examples with mutable prime factors.

Do we have a use case for this, or should we just make `Factorization`s immutable and give it an implementation of `_hash_`?



---

archive/issue_comments_157121.json:
```json
{
    "body": "Given that its `__setitem__` explicitly states a factorization is immutable, I think we should have the (deep)copy be idempotent and implement a `__hash__`.",
    "created_at": "2022-10-05T07:47:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13186",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13186#issuecomment-157121",
    "user": "https://github.com/tscrim"
}
```

Given that its `__setitem__` explicitly states a factorization is immutable, I think we should have the (deep)copy be idempotent and implement a `__hash__`.
