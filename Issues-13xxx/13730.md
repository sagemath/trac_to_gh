# Issue 13730: Speed up some graph iterations

archive/issues_013526.json:
```json
{
    "body": "Several graph methods can be significantly speed up improving the data structure, or at least the way some basic operations are performed. \nFor instance, many functions are faster using networkx graphs (conversion time included) instead of sage graphs. \n\nIn fact, NetworkX uses dictionaries to store edges. If G is a networkx graph, it is also a dictionary indexed by the vertices, and G[u] is a dictionary indexed by neighbors and containing edge data. This way, iterations are fast.\n\n```\nsage: G = graphs.RandomBarabasiAlbert(100,2)\nsage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n125 loops, best of 3: 1.63 ms per loop\nsage: ggnx = G.networkx_graph()\nsage: %timeit EE = [(u,v) for u in ggnx for v in ggnx.neighbors_iter(u)] \n625 loops, best of 3: 141 \u00b5s per loop\nsage: %timeit EE = [(u,v) for u in ggnx for v in ggnx[u]] \n625 loops, best of 3: 127 \u00b5s per loop\n```\nWe should at least improve iteration over the neighbors.\n\n**Assignee:** jason, ncohen, rlm\n\n**CC:**  azi @nathanncohen @lobiCode brunellus @videlec\n\n**Status:** needs_work\n\nIssue created by migration from https://trac.sagemath.org/ticket/13730\n\n",
    "created_at": "2012-11-20T19:37:13Z",
    "labels": [
        "component: graph theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Speed up some graph iterations",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13730",
    "user": "https://github.com/dcoudert"
}
```
Several graph methods can be significantly speed up improving the data structure, or at least the way some basic operations are performed. 
For instance, many functions are faster using networkx graphs (conversion time included) instead of sage graphs. 

In fact, NetworkX uses dictionaries to store edges. If G is a networkx graph, it is also a dictionary indexed by the vertices, and G[u] is a dictionary indexed by neighbors and containing edge data. This way, iterations are fast.

```
sage: G = graphs.RandomBarabasiAlbert(100,2)
sage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
125 loops, best of 3: 1.63 ms per loop
sage: ggnx = G.networkx_graph()
sage: %timeit EE = [(u,v) for u in ggnx for v in ggnx.neighbors_iter(u)] 
625 loops, best of 3: 141 µs per loop
sage: %timeit EE = [(u,v) for u in ggnx for v in ggnx[u]] 
625 loops, best of 3: 127 µs per loop
```
We should at least improve iteration over the neighbors.

**Assignee:** jason, ncohen, rlm

**CC:**  azi @nathanncohen @lobiCode brunellus @videlec

**Status:** needs_work

Issue created by migration from https://trac.sagemath.org/ticket/13730





---

archive/issue_comments_213245.json:
```json
{
    "body": "<a id='comment:1'></a>\nHello, dcoudert!!\n\nFirst thing that I am wondering is why is sage constructing a set from the iterator and then returns the iterator of the set. Does anyone happen to know that? It does not seem to affect computational speed but I do not see why it is necessary. Anyone happens to know why is set() required in this case?\n\n```\n    def neighbor_iterator(self, vertex):\n      \n        if self._directed:\n            return iter(set(self.neighbor_out_iterator(vertex)) \\\n                    | set(self.neighbor_in_iterator(vertex)))\n        else: \n            return iter(set(self._backend.iterator_nbrs(vertex))))\n```",
    "created_at": "2012-11-21T15:20:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213245",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:1'></a>
Hello, dcoudert!!

First thing that I am wondering is why is sage constructing a set from the iterator and then returns the iterator of the set. Does anyone happen to know that? It does not seem to affect computational speed but I do not see why it is necessary. Anyone happens to know why is set() required in this case?

```
    def neighbor_iterator(self, vertex):
      
        if self._directed:
            return iter(set(self.neighbor_out_iterator(vertex)) \
                    | set(self.neighbor_in_iterator(vertex)))
        else: 
            return iter(set(self._backend.iterator_nbrs(vertex))))
```



---

archive/issue_comments_213246.json:
```json
{
    "body": "<a id='comment:2'></a>\nI'm not expert enough in iterators to answer. Furthermore, the backend for graphs also constructs sets:\n\n```\ndef iterator_nbrs(self, v):\n\n    return iter(set(self.iterator_in_nbrs(v)) |\n                set(self.iterator_out_nbrs(v)))\n```\nI don't know the reasons behind but this can certainly be improved/simplified.\n\nDavid.",
    "created_at": "2012-11-22T12:24:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213246",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:2'></a>
I'm not expert enough in iterators to answer. Furthermore, the backend for graphs also constructs sets:

```
def iterator_nbrs(self, v):

    return iter(set(self.iterator_in_nbrs(v)) |
                set(self.iterator_out_nbrs(v)))
```
I don't know the reasons behind but this can certainly be improved/simplified.

David.



---

archive/issue_comments_213247.json:
```json
{
    "body": "<a id='comment:3'></a>\nAgree!\n\nIt seems like something suspiciously complex is being done in these iterators (lists, to iterators, to sets, to iterators to sets..)\n\nI've played around and removed the (intuitively) unneeded parts and observed that there is a minor performance gain.\n\nBut if we want to be as fast as networkx then we'd need to keep a hash table of neighbors for each vertex. \n\nBefore trying to implement this - does sage allow graphs with unhashable vertices?",
    "created_at": "2012-11-24T12:27:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213247",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:3'></a>
Agree!

It seems like something suspiciously complex is being done in these iterators (lists, to iterators, to sets, to iterators to sets..)

I've played around and removed the (intuitively) unneeded parts and observed that there is a minor performance gain.

But if we want to be as fast as networkx then we'd need to keep a hash table of neighbors for each vertex. 

Before trying to implement this - does sage allow graphs with unhashable vertices?



---

archive/issue_comments_213248.json:
```json
{
    "body": "<a id='comment:4'></a>\nNOnonono, vertices are hashable or everything would break. I mean, or instance the code you just printed would not work at all !\n\n```\nsage: set([set([1])])\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n\n/home/ncohen/<ipython console> in <module>()\n\nTypeError: unhashable type: 'set'\n```\n\nNathann",
    "created_at": "2012-11-24T23:34:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213248",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:4'></a>
NOnonono, vertices are hashable or everything would break. I mean, or instance the code you just printed would not work at all !

```
sage: set([set([1])])
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/ncohen/<ipython console> in <module>()

TypeError: unhashable type: 'set'
```

Nathann



---

archive/issue_comments_213249.json:
```json
{
    "body": "<a id='comment:5'></a>\nHello guys!\n\nI have implemented a stupid \"fix\" by adding a hash table to the graph object storing neighbours for every vertex of the graph. I then modified the add_edge/delete_edge methods to update the hash  table accordingly.\n\nThe speedup was drastic (as with networkX graphs) and it also speed up other graph theory functions (since many things rely on obtaining the neighbours of some vertices)\n\nHOWEVER. Many of the graph theory tests made sage crash which makes uncomfortable in posting the patch here. I am not aware enough of the graph internals to be able to write a sane patch that is not just some naive fix.\n\nHence I call someone that is more experienced with the c_graph implementation to add this feature. It is really really worth doing it!",
    "created_at": "2012-12-21T09:50:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213249",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:5'></a>
Hello guys!

I have implemented a stupid "fix" by adding a hash table to the graph object storing neighbours for every vertex of the graph. I then modified the add_edge/delete_edge methods to update the hash  table accordingly.

The speedup was drastic (as with networkX graphs) and it also speed up other graph theory functions (since many things rely on obtaining the neighbours of some vertices)

HOWEVER. Many of the graph theory tests made sage crash which makes uncomfortable in posting the patch here. I am not aware enough of the graph internals to be able to write a sane patch that is not just some naive fix.

Hence I call someone that is more experienced with the c_graph implementation to add this feature. It is really really worth doing it!



---

archive/issue_comments_213250.json:
```json
{
    "body": "<a id='comment:6'></a>\nHello,\n\nyou should post your patch so that others can try it and help identifying and fixing the problem. The status of this patch could be \"needs work\" or \"needs info\".\n\nBest,\nDavid.",
    "created_at": "2012-12-21T13:24:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213250",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:6'></a>
Hello,

you should post your patch so that others can try it and help identifying and fixing the problem. The status of this patch could be "needs work" or "needs info".

Best,
David.



---

archive/issue_comments_213251.json:
```json
{
    "body": "**Changing status** from new to needs_info.",
    "created_at": "2012-12-29T16:15:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213251",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

**Changing status** from new to needs_info.



---

archive/issue_comments_213252.json:
```json
{
    "body": "Attachment [trac_17710_needs_info.patch](tarball://root/attachments/some-uuid/ticket13730/trac_17710_needs_info.patch) by @lobiCode created at 2013-02-21 16:53:07",
    "created_at": "2013-02-21T16:53:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213252",
    "user": "https://github.com/lobiCode"
}
```

Attachment [trac_17710_needs_info.patch](tarball://root/attachments/some-uuid/ticket13730/trac_17710_needs_info.patch) by @lobiCode created at 2013-02-21 16:53:07



---

archive/issue_comments_213253.json:
```json
{
    "body": "<a id='comment:8'></a>\nHello.\n\nI tried to implement what azi did. I added the hash tabel and update some methods. I didn't make other tests.\nI'm new to SAGE and I would like to work on this problem. Please help me and tell me if this patch is going in the right direction. \n\nBest regards,\n\nslani\n\n\n```\nnew\n==========================================================\nsage:  G = graphs.RandomBarabasiAlbert(100,2)\nsage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n625 loops, best of 3: 479 \u00c2\u00b5s per loop\nsage: ggnx = G.networkx_graph()\nsage: %timeit EE = [(u,v) for u in ggnx for v in ggnx.neighbors_iter(u)] \n625 loops, best of 3: 171 \u00c2\u00b5s per loopsage: %timeit EE = [(u,v) for u in ggnx for v in ggnx[u]] \n625 loops, best of 3: 159 \u00c2\u00b5s per loop\n\nsage: %timeit G.neighbors(3)                \n625 loops, best of 3: 5.35 \u00c2\u00b5s per loop\n===========================================================\n\nold\n===========================================================\nsage: G = graphs.RandomBarabasiAlbert(100,2)\nsage:  %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n125 loops, best of 3: 2.03 ms per loop\nsage: ggnx = G.networkx_graph()\nsage: %timeit EE = [(u,v) for u in ggnx for v in ggnx.neighbors_iter(u)] \n625 loops, best of 3: 177 \u00c2\u00b5s per loop\nsage: %timeit EE = [(u,v) for u in ggnx for v in ggnx[u]] \n625 loops, best of 3: 159 \u00c2\u00b5s per loop\n\n%timeit G.neighbors(3)\n625 loops, best of 3: 91.1 \u00c2\u00b5s per loop\n============================================================\n```",
    "created_at": "2013-02-21T16:59:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213253",
    "user": "https://github.com/lobiCode"
}
```

<a id='comment:8'></a>
Hello.

I tried to implement what azi did. I added the hash tabel and update some methods. I didn't make other tests.
I'm new to SAGE and I would like to work on this problem. Please help me and tell me if this patch is going in the right direction. 

Best regards,

slani


```
new
==========================================================
sage:  G = graphs.RandomBarabasiAlbert(100,2)
sage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
625 loops, best of 3: 479 Âµs per loop
sage: ggnx = G.networkx_graph()
sage: %timeit EE = [(u,v) for u in ggnx for v in ggnx.neighbors_iter(u)] 
625 loops, best of 3: 171 Âµs per loopsage: %timeit EE = [(u,v) for u in ggnx for v in ggnx[u]] 
625 loops, best of 3: 159 Âµs per loop

sage: %timeit G.neighbors(3)                
625 loops, best of 3: 5.35 Âµs per loop
===========================================================

old
===========================================================
sage: G = graphs.RandomBarabasiAlbert(100,2)
sage:  %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
125 loops, best of 3: 2.03 ms per loop
sage: ggnx = G.networkx_graph()
sage: %timeit EE = [(u,v) for u in ggnx for v in ggnx.neighbors_iter(u)] 
625 loops, best of 3: 177 Âµs per loop
sage: %timeit EE = [(u,v) for u in ggnx for v in ggnx[u]] 
625 loops, best of 3: 159 Âµs per loop

%timeit G.neighbors(3)
625 loops, best of 3: 91.1 Âµs per loop
============================================================
```



---

archive/issue_comments_213254.json:
```json
{
    "body": "**Changing status** from needs_info to needs_review.",
    "created_at": "2013-02-21T18:31:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213254",
    "user": "https://github.com/lobiCode"
}
```

**Changing status** from needs_info to needs_review.



---

archive/issue_comments_213255.json:
```json
{
    "body": "**Changing status** from needs_review to needs_info.",
    "created_at": "2013-02-22T08:59:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213255",
    "user": "https://github.com/nathanncohen"
}
```

**Changing status** from needs_review to needs_info.



---

archive/issue_comments_213256.json:
```json
{
    "body": "<a id='comment:11'></a>\n....\n\nThis patch does not even contain an instruction to remove an element from your cached list when an edge is deleted....\n\nThis problem has to be fixed, but it has to be fixed properly... If the backend is slow it has to be fixed there or the backend should be changed.\n\nNathann",
    "created_at": "2013-02-22T08:59:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213256",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:11'></a>
....

This patch does not even contain an instruction to remove an element from your cached list when an edge is deleted....

This problem has to be fixed, but it has to be fixed properly... If the backend is slow it has to be fixed there or the backend should be changed.

Nathann



---

archive/issue_comments_213257.json:
```json
{
    "body": "**Changing status** from needs_info to needs_review.",
    "created_at": "2013-02-25T14:54:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213257",
    "user": "https://github.com/lobiCode"
}
```

**Changing status** from needs_info to needs_review.



---

archive/issue_comments_213258.json:
```json
{
    "body": "<a id='comment:12'></a>\nHello\n\nI've added the function to handle vertex removals as well. I am aware that this solution is not good but I just wanted to write something to get us going. To make it work properly I would have to change the respective backends but I am clueless about the internal structure of the backends. Is there anyone here that can shed some light on it or point to the relevant documentation - I was not able to find any.\n\nWhere should this improvement be implemented?",
    "created_at": "2013-02-25T14:54:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213258",
    "user": "https://github.com/lobiCode"
}
```

<a id='comment:12'></a>
Hello

I've added the function to handle vertex removals as well. I am aware that this solution is not good but I just wanted to write something to get us going. To make it work properly I would have to change the respective backends but I am clueless about the internal structure of the backends. Is there anyone here that can shed some light on it or point to the relevant documentation - I was not able to find any.

Where should this improvement be implemented?



---

archive/issue_comments_213259.json:
```json
{
    "body": "Attachment [trac_17711_needs_info.patch](tarball://root/attachments/some-uuid/ticket13730/trac_17711_needs_info.patch) by @lobiCode created at 2013-02-25 14:55:06",
    "created_at": "2013-02-25T14:55:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213259",
    "user": "https://github.com/lobiCode"
}
```

Attachment [trac_17711_needs_info.patch](tarball://root/attachments/some-uuid/ticket13730/trac_17711_needs_info.patch) by @lobiCode created at 2013-02-25 14:55:06



---

archive/issue_comments_213260.json:
```json
{
    "body": "<a id='comment:13'></a>\nYour updated patch would fail if there are two edges between two vertices, and the user removes one of the two edges.\n\nYou unnecessarily check whether the dictionaries contain a list associated to a vertex of the graph, and it would probably be better to associate an empty list to each vertex from the beginning. Anyway you have to make TESTS to decide what to do.\n\nThe functions you add are not doctested.\n\nYou do not document the features you add either.\n\nI think that it would be better to add what you need in the code directly, without creating 2\n\nPlease, do not write this patch.\n\n> Is there anyone here that can shed some light on it or point to the relevant documentation - I was not able to find any.\n\n\nThere isn't, that's one of the problems. I write some comments in the code about some parts of it when I have to understand how it works to fix a bug.\n\n> Where should this improvement be implemented?\n\n\nI do not know. What I would do if I were to write this patch, or what I will do if you force  me to write it, is try to understand why the current implementation is so slow compared to dictionaries. I would try to locate the place which makes a difference in the timings. This has to come from the way edges are stored, and from what I remember this part of the code is not that clear.\n\nNathann",
    "created_at": "2013-02-25T16:34:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213260",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:13'></a>
Your updated patch would fail if there are two edges between two vertices, and the user removes one of the two edges.

You unnecessarily check whether the dictionaries contain a list associated to a vertex of the graph, and it would probably be better to associate an empty list to each vertex from the beginning. Anyway you have to make TESTS to decide what to do.

The functions you add are not doctested.

You do not document the features you add either.

I think that it would be better to add what you need in the code directly, without creating 2

Please, do not write this patch.

> Is there anyone here that can shed some light on it or point to the relevant documentation - I was not able to find any.


There isn't, that's one of the problems. I write some comments in the code about some parts of it when I have to understand how it works to fix a bug.

> Where should this improvement be implemented?


I do not know. What I would do if I were to write this patch, or what I will do if you force  me to write it, is try to understand why the current implementation is so slow compared to dictionaries. I would try to locate the place which makes a difference in the timings. This has to come from the way edges are stored, and from what I remember this part of the code is not that clear.

Nathann



---

archive/issue_comments_213261.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2013-02-26T11:17:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213261",
    "user": "https://github.com/nathanncohen"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_213262.json:
```json
{
    "body": "<a id='comment:16'></a>\nAttachment [trac_17710_iter_set.patch](tarball://root/attachments/some-uuid/ticket13730/trac_17710_iter_set.patch) by @lobiCode created at 2013-06-04 23:28:01\n\n![](http://lobi.dev.si/s.png)\n\nHello,\n\non picture you can see a diagram what happens when we call neighbors() on graph. You can see there is a lot conversion from set/iter and then back again. \n\nWhere this conversion is not necessary I remove it.  \n\nBut most time reduction was made (for ours specific test), when function neighbor_iterator (F2) start calling iterator_out_nbrs (F4.2) for undirected graph instead iterator_nbrs (F3.1). If graph is undirected we only need out nbrs. or  in nbrs.??????????\n\n\n```\nBefore:\nsage: G = graphs.RandomBarabasiAlbert(100,2)\nsage:  %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n125 loops, best of 3: 2.03 ms per loop\nNow:\nsage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n625 loops, best of 3: 900 \u00b5s per loop\n```\n\n\n\nI also remove \n\n```\n#Sparse\nif self._cg_rev is not None:\nreturn iter([vertex_label(u_int,\nself.vertex_ints,\nself.vertex_labels,\nself._cg)\nfor u_int in self._cg_rev.out_neighbors(v_int)])\n```\n\nin iterator_in_nbrs (F 4.1). I don't know what relation this has with sparse/dense.\n\nBut most time consuming problem is conversion from vertex int to vertex label  in iterator_out_nbrs  (F4.2) and  iterator_in_nbrs (F4.1)\n\nThis conversion for our specific test takes almost 500 \u00b5s. \n \nI tried to implement array of python object in cython, where we can save vertex labels, but I was unsuccessful, because I don't know cython well (yet). Maybe someone can help me?\n\nIf this is a good solution then we can return iter of vertex labels instead of list of vertex int from cpdef list out_neighbors (F5).\n\nSo what do you think?\n\nBest,\nUros",
    "created_at": "2013-06-04T23:28:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213262",
    "user": "https://github.com/lobiCode"
}
```

<a id='comment:16'></a>
Attachment [trac_17710_iter_set.patch](tarball://root/attachments/some-uuid/ticket13730/trac_17710_iter_set.patch) by @lobiCode created at 2013-06-04 23:28:01

![](http://lobi.dev.si/s.png)

Hello,

on picture you can see a diagram what happens when we call neighbors() on graph. You can see there is a lot conversion from set/iter and then back again. 

Where this conversion is not necessary I remove it.  

But most time reduction was made (for ours specific test), when function neighbor_iterator (F2) start calling iterator_out_nbrs (F4.2) for undirected graph instead iterator_nbrs (F3.1). If graph is undirected we only need out nbrs. or  in nbrs.??????????


```
Before:
sage: G = graphs.RandomBarabasiAlbert(100,2)
sage:  %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
125 loops, best of 3: 2.03 ms per loop
Now:
sage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
625 loops, best of 3: 900 µs per loop
```



I also remove 

```
#Sparse
if self._cg_rev is not None:
return iter([vertex_label(u_int,
self.vertex_ints,
self.vertex_labels,
self._cg)
for u_int in self._cg_rev.out_neighbors(v_int)])
```

in iterator_in_nbrs (F 4.1). I don't know what relation this has with sparse/dense.

But most time consuming problem is conversion from vertex int to vertex label  in iterator_out_nbrs  (F4.2) and  iterator_in_nbrs (F4.1)

This conversion for our specific test takes almost 500 µs. 
 
I tried to implement array of python object in cython, where we can save vertex labels, but I was unsuccessful, because I don't know cython well (yet). Maybe someone can help me?

If this is a good solution then we can return iter of vertex labels instead of list of vertex int from cpdef list out_neighbors (F5).

So what do you think?

Best,
Uros



---

archive/issue_comments_213263.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2013-06-04T23:28:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213263",
    "user": "https://github.com/lobiCode"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_213264.json:
```json
{
    "body": "Attachment [trac_13730-vd.patch](tarball://root/attachments/some-uuid/ticket13730/trac_13730-vd.patch) by @videlec created at 2013-06-05 07:41:04",
    "created_at": "2013-06-05T07:41:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213264",
    "user": "https://github.com/videlec"
}
```

Attachment [trac_13730-vd.patch](tarball://root/attachments/some-uuid/ticket13730/trac_13730-vd.patch) by @videlec created at 2013-06-05 07:41:04



---

archive/issue_comments_213265.json:
```json
{
    "body": "<a id='comment:19'></a>\nHi,\n\nI just upload [attachment:trac_13730-vd.patch] to show how you could do this. There is no reason to add extra attributes to graphs (it will only slow down everything). Right now, all graph data structures in Sage are implemented to be fast at Cython level (ie compiled code). In order to have reasonable timings at Python level you need to work a bit.\n\nIn [attachment:trac_13730-vd.patch], there is a working iterator for the out neighbors in a dense graph (in `sage.graphs.base.dense_graph`). You might implement similar classes `InIteratorXXX`, `OutIteratorXXX` and `InAndOutIteratorXXX` for each graph backend `XXX` and then make some small wrapper in order to make it works for Sage graphs (ie translating ints to vertex labels).\n\nI may help further if you need.\n\nBest,\nVincent",
    "created_at": "2013-06-05T07:47:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213265",
    "user": "https://github.com/videlec"
}
```

<a id='comment:19'></a>
Hi,

I just upload [attachment:trac_13730-vd.patch] to show how you could do this. There is no reason to add extra attributes to graphs (it will only slow down everything). Right now, all graph data structures in Sage are implemented to be fast at Cython level (ie compiled code). In order to have reasonable timings at Python level you need to work a bit.

In [attachment:trac_13730-vd.patch], there is a working iterator for the out neighbors in a dense graph (in `sage.graphs.base.dense_graph`). You might implement similar classes `InIteratorXXX`, `OutIteratorXXX` and `InAndOutIteratorXXX` for each graph backend `XXX` and then make some small wrapper in order to make it works for Sage graphs (ie translating ints to vertex labels).

I may help further if you need.

Best,
Vincent



---

archive/issue_comments_213266.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2013-06-05T07:47:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213266",
    "user": "https://github.com/videlec"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_213267.json:
```json
{
    "body": "Attachment [trac_13730-v2-vd.patch](tarball://root/attachments/some-uuid/ticket13730/trac_13730-v2-vd.patch) by @videlec created at 2013-06-07 08:14:37",
    "created_at": "2013-06-07T08:14:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213267",
    "user": "https://github.com/videlec"
}
```

Attachment [trac_13730-v2-vd.patch](tarball://root/attachments/some-uuid/ticket13730/trac_13730-v2-vd.patch) by @videlec created at 2013-06-07 08:14:37



---

archive/issue_comments_213268.json:
```json
{
    "body": "<a id='comment:21'></a>\nHi,\n\nI appologize, I was a bit old school in my precedent message.\n\nA long time ago, Cython did not support the yield statement and it was necessary either to write a class dedicated to iteration or to build the set on which we would like to iterate and return `iter(my_set)`. This is the reason why it is implemented like that in `sage.graphs.base.c_graph` and `sage.graphs.base.sparse_graph`.\n\nI upload a patch where all iterators does not build the underlying set. The gain is not extraordinary (only a x2) and the output order is completely messed up (this need to be fixed).",
    "created_at": "2013-06-07T08:15:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213268",
    "user": "https://github.com/videlec"
}
```

<a id='comment:21'></a>
Hi,

I appologize, I was a bit old school in my precedent message.

A long time ago, Cython did not support the yield statement and it was necessary either to write a class dedicated to iteration or to build the set on which we would like to iterate and return `iter(my_set)`. This is the reason why it is implemented like that in `sage.graphs.base.c_graph` and `sage.graphs.base.sparse_graph`.

I upload a patch where all iterators does not build the underlying set. The gain is not extraordinary (only a x2) and the output order is completely messed up (this need to be fixed).



---

archive/issue_comments_213269.json:
```json
{
    "body": "<a id='comment:22'></a>\nHello,\n\nI tried with yield in iterator_out_nbrs (l:1745, c_graph.pyx) but it does not improve anything. \n\n```\nsage: G = graphs.RandomBarabasiAlbert(100,2)\nsage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n625 loops, best of 3: 940 \u00b5s per loop\n```\n\nI did a lot of modification and testing (also tried with new function in cython which use yield for returning nbrs), but didn't improve anything. \n\nI also made a function (in generic_graph.py) which directly call  cpdef list out_neighbors (base/sparse_graph.pyx; l:798):\n\n```\nsage: %timeit E = [(u,v) for u in G for v in G.neighbors_three(u)]\n\n625 loops, best of 3: 362 \u00b5s per loop \n```\n\nIt is still slower than NetworkX!\n\nI don't know, but I came to the conclusion that we have tow problems:\n1. conversion from vertex ints to vertex lables\n2. how to faster return vertex ints from data structure we have for nbrs\n\nVincent, what do you think?\n\nThis is also interesting for me:\n\n```\nsage: G\nGraph on 100 vertices\nsage: ggnx\n<networkx.classes.graph.Graph object at 0x65c8ed0>\n\nsage: %timeit E = [(u,v) for u in G for v in G.neighbors_three(u)]\n625 loops, best of 3: 358 \u00b5s per loop\n\nsage: %timeit E = [(u,v) for u in ggnx for v in G.neighbors_three(u)]\n625 loops, best of 3: 273 \u00b5s per loop\n\n\nsage: %timeit EE = [(u,v) for u in ggnx for v in ggnx.neighbors(u)] \n625 loops, best of 3: 213 \u00b5s per loop\n\n```\n\nBest, \nUros",
    "created_at": "2013-06-08T06:11:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213269",
    "user": "https://github.com/lobiCode"
}
```

<a id='comment:22'></a>
Hello,

I tried with yield in iterator_out_nbrs (l:1745, c_graph.pyx) but it does not improve anything. 

```
sage: G = graphs.RandomBarabasiAlbert(100,2)
sage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
625 loops, best of 3: 940 µs per loop
```

I did a lot of modification and testing (also tried with new function in cython which use yield for returning nbrs), but didn't improve anything. 

I also made a function (in generic_graph.py) which directly call  cpdef list out_neighbors (base/sparse_graph.pyx; l:798):

```
sage: %timeit E = [(u,v) for u in G for v in G.neighbors_three(u)]

625 loops, best of 3: 362 µs per loop 
```

It is still slower than NetworkX!

I don't know, but I came to the conclusion that we have tow problems:
1. conversion from vertex ints to vertex lables
2. how to faster return vertex ints from data structure we have for nbrs

Vincent, what do you think?

This is also interesting for me:

```
sage: G
Graph on 100 vertices
sage: ggnx
<networkx.classes.graph.Graph object at 0x65c8ed0>

sage: %timeit E = [(u,v) for u in G for v in G.neighbors_three(u)]
625 loops, best of 3: 358 µs per loop

sage: %timeit E = [(u,v) for u in ggnx for v in G.neighbors_three(u)]
625 loops, best of 3: 273 µs per loop


sage: %timeit EE = [(u,v) for u in ggnx for v in ggnx.neighbors(u)] 
625 loops, best of 3: 213 µs per loop

```

Best, 
Uros



---

archive/issue_comments_213270.json:
```json
{
    "body": "<a id='comment:23'></a>\nReplying to [slani](#comment%3A22):\nHello,\n \n> I don't know, but I came to the conclusion that we have tow problems:\n> 1. conversion from vertex ints to vertex lables\n\n\nThis should not slow down too much (not x4). It is a lookup in an array. Did you make some timings to see whether this is slow ? Perhaps we have to dig the way it is implemented.\n\n> 2. how to faster return vertex ints from data structure we have for nbrs\n\n\nIt might be a good idea to see whether iterator over int vertices are faster compared to the labeled one.\n\nOther possibilities\n\n3. There are 3 levels in a graph: the `GenericGraph` class, the `backend` (stored at `my_graph._backend`) and then the datastructure (stored at `my_graph._backend._cg` for c graphs or `my_graph._backend._nxg` for networkx).\n\n4. Possibly #14690 might be a good speedup (if it works one day ;-)",
    "created_at": "2013-06-08T06:54:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213270",
    "user": "https://github.com/videlec"
}
```

<a id='comment:23'></a>
Replying to [slani](#comment%3A22):
Hello,
 
> I don't know, but I came to the conclusion that we have tow problems:
> 1. conversion from vertex ints to vertex lables


This should not slow down too much (not x4). It is a lookup in an array. Did you make some timings to see whether this is slow ? Perhaps we have to dig the way it is implemented.

> 2. how to faster return vertex ints from data structure we have for nbrs


It might be a good idea to see whether iterator over int vertices are faster compared to the labeled one.

Other possibilities

3. There are 3 levels in a graph: the `GenericGraph` class, the `backend` (stored at `my_graph._backend`) and then the datastructure (stored at `my_graph._backend._cg` for c graphs or `my_graph._backend._nxg` for networkx).

4. Possibly #14690 might be a good speedup (if it works one day ;-)



---

archive/issue_comments_213271.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [vdelecroix](#comment%3A23):\n> Replying to [slani](#comment%3A22):\n> Hello,\n>  \n> > I don't know, but I came to the conclusion that we have tow problems:\n> > 1. conversion from vertex ints to vertex lables\n  \n> \n> This should not slow down too much (not x4). It is a lookup in an array. Did you make some timings to see whether this is slow ? Perhaps we have to dig the way it is implemented.\n> >\n> >\n> >Yes.\n> >This is a timing when I'm calling iterator_out_nbrs (base/c_graph.pyx; l: 1754)\n\n\n```\nsage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n625 loops, best of 3: 872 \u00b5s per loop\n```\nThis is a timing when I'm calling  cpdef list out_neighbors (base/sparse_graph.pyx; l:798) directly (no conversions  vertex int to vertex labels)\n\n```\nsage: %timeit E = [(u,v) for u in G for v in G.neighbors_three(u)]\n625 loops, best of 3: 362 \u00b5s per loop \n```\n\n\n> \n> > 2. how to faster return vertex ints from data structure we have for nbrs\n  \n> \n> It might be a good idea to see whether iterator over int vertices are faster compared to the labeled one.\n> \n> >\n> >I also trying with yield in sparse_graph.pyx\n\n\n```\n+    def iter_out_nbrs_one(self, u):\n+        \n+        cdef int i, num_nbrs = 0, current_nbr = 0\n+        cdef int size = self.out_degrees[u]\n+        if self.out_degrees[u] == 0:\n+            return 0\n+        cdef SparseGraphBTNode **pointers = <SparseGraphBTNode **> \\\n+          sage_malloc(size * sizeof(SparseGraphBTNode *))\n+        if not pointers:\n+            raise RuntimeError(\"Failure allocating memory.\")\n+        for i from u * self.hash_length <= i < (u+1) * self.hash_length:\n+            if self.vertices[i] == NULL:\n+                continue\n+            if num_nbrs == size:\n+                sage_free(pointers)\n+                return -1\n+            pointers[num_nbrs] = self.vertices[i]\n+            yield self.vertices[i].vertex\n+            num_nbrs += 1\n+\n+            # While all the neighbors have not been added to the list, explore\n+            # element pointers[current_nbr] and append its children to the end\n+            # of pointers if necessary, the increment current_nbr.\n+            while current_nbr < num_nbrs:\n+                if pointers[current_nbr].left != NULL:\n+                    if num_nbrs == size:\n+                        sage_free(pointers)\n+                        return -1\n+                    pointers[num_nbrs] = pointers[current_nbr].left\n+                    yield pointers[current_nbr].left.vertex\n+                    num_nbrs += 1\n+                if pointers[current_nbr].right != NULL:\n+                    if num_nbrs == size:\n+                        sage_free(pointers)\n+                        return -1\n+                    pointers[num_nbrs] = pointers[current_nbr].right\n+                    yield  pointers[current_nbr].right.vertex\n+                    num_nbrs += 1\n+                current_nbr += 1\n+        sage_free(pointers)\n+     \n```\n> >\n> >This doesn\u2019t improve anything. I suppose this is not a good implementation but it was just a test.\n\n> Other possibilities\n> \n> 3. There are 3 levels in a graph: the `GenericGraph` class, the `backend` (stored at `my_graph._backend`) and then the datastructure (stored at `my_graph._backend._cg` for c graphs or `my_graph._backend._nxg` for networkx).\n> \n> 4. Possibly #14690 might be a good speedup (if it works one day ;-)",
    "created_at": "2013-06-08T07:18:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213271",
    "user": "https://github.com/lobiCode"
}
```

<a id='comment:24'></a>
Replying to [vdelecroix](#comment%3A23):
> Replying to [slani](#comment%3A22):
> Hello,
>  
> > I don't know, but I came to the conclusion that we have tow problems:
> > 1. conversion from vertex ints to vertex lables
  
> 
> This should not slow down too much (not x4). It is a lookup in an array. Did you make some timings to see whether this is slow ? Perhaps we have to dig the way it is implemented.
> >
> >
> >Yes.
> >This is a timing when I'm calling iterator_out_nbrs (base/c_graph.pyx; l: 1754)


```
sage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
625 loops, best of 3: 872 µs per loop
```
This is a timing when I'm calling  cpdef list out_neighbors (base/sparse_graph.pyx; l:798) directly (no conversions  vertex int to vertex labels)

```
sage: %timeit E = [(u,v) for u in G for v in G.neighbors_three(u)]
625 loops, best of 3: 362 µs per loop 
```


> 
> > 2. how to faster return vertex ints from data structure we have for nbrs
  
> 
> It might be a good idea to see whether iterator over int vertices are faster compared to the labeled one.
> 
> >
> >I also trying with yield in sparse_graph.pyx


```
+    def iter_out_nbrs_one(self, u):
+        
+        cdef int i, num_nbrs = 0, current_nbr = 0
+        cdef int size = self.out_degrees[u]
+        if self.out_degrees[u] == 0:
+            return 0
+        cdef SparseGraphBTNode **pointers = <SparseGraphBTNode **> \
+          sage_malloc(size * sizeof(SparseGraphBTNode *))
+        if not pointers:
+            raise RuntimeError("Failure allocating memory.")
+        for i from u * self.hash_length <= i < (u+1) * self.hash_length:
+            if self.vertices[i] == NULL:
+                continue
+            if num_nbrs == size:
+                sage_free(pointers)
+                return -1
+            pointers[num_nbrs] = self.vertices[i]
+            yield self.vertices[i].vertex
+            num_nbrs += 1
+
+            # While all the neighbors have not been added to the list, explore
+            # element pointers[current_nbr] and append its children to the end
+            # of pointers if necessary, the increment current_nbr.
+            while current_nbr < num_nbrs:
+                if pointers[current_nbr].left != NULL:
+                    if num_nbrs == size:
+                        sage_free(pointers)
+                        return -1
+                    pointers[num_nbrs] = pointers[current_nbr].left
+                    yield pointers[current_nbr].left.vertex
+                    num_nbrs += 1
+                if pointers[current_nbr].right != NULL:
+                    if num_nbrs == size:
+                        sage_free(pointers)
+                        return -1
+                    pointers[num_nbrs] = pointers[current_nbr].right
+                    yield  pointers[current_nbr].right.vertex
+                    num_nbrs += 1
+                current_nbr += 1
+        sage_free(pointers)
+     
```
> >
> >This doesn’t improve anything. I suppose this is not a good implementation but it was just a test.

> Other possibilities
> 
> 3. There are 3 levels in a graph: the `GenericGraph` class, the `backend` (stored at `my_graph._backend`) and then the datastructure (stored at `my_graph._backend._cg` for c graphs or `my_graph._backend._nxg` for networkx).
> 
> 4. Possibly #14690 might be a good speedup (if it works one day ;-)



---

archive/issue_comments_213272.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [vdelecroix](#comment%3A23):\n\n> >\n> >4. Possibly #14690 might be a good speedup (if it works one day ;-)\n\n>\n>\n> \n\n\n>I modified  data structure for saving nbrs. I implemented linked list and save all nbrs for vertex in one place in vertices (not on 16 different places). Obvious this is not good for adds  and removes nbrs.\n>\n>\n\n\n```\nsage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n625 loops, best of 3: 871 \u00b5s per loop\n```\n> Very small improvements.\n\n\n>\n> How can networkX data structure (python dict) return data so fast?\n\n\n>\n> Best, \n\n\n> Uros",
    "created_at": "2013-06-10T23:03:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213272",
    "user": "https://github.com/lobiCode"
}
```

<a id='comment:25'></a>
Replying to [vdelecroix](#comment%3A23):

> >
> >4. Possibly #14690 might be a good speedup (if it works one day ;-)

>
>
> 


>I modified  data structure for saving nbrs. I implemented linked list and save all nbrs for vertex in one place in vertices (not on 16 different places). Obvious this is not good for adds  and removes nbrs.
>
>


```
sage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
625 loops, best of 3: 871 µs per loop
```
> Very small improvements.


>
> How can networkX data structure (python dict) return data so fast?


>
> Best, 


> Uros



---

archive/issue_comments_213273.json:
```json
{
    "body": "<a id='comment:26'></a>\nThat may be interesting\n\n```\nsage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n1000 loops, best of 3: 1.65 ms per loop\nsage: H = Graph(G.graph6_string(), implementation='networkx')\nsage: %timeit E = [(u,v) for u in H for v in H.neighbor_iterator(u)]\n100 loops, best of 3: 1.35 ms per loop\n```",
    "created_at": "2013-08-13T12:46:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213273",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:26'></a>
That may be interesting

```
sage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
1000 loops, best of 3: 1.65 ms per loop
sage: H = Graph(G.graph6_string(), implementation='networkx')
sage: %timeit E = [(u,v) for u in H for v in H.neighbor_iterator(u)]
100 loops, best of 3: 1.35 ms per loop
```



---

archive/issue_comments_213274.json:
```json
{
    "body": "<a id='comment:27'></a>\nWhat about #14806 ? `:-P`\n\nNathann",
    "created_at": "2013-08-13T12:51:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213274",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:27'></a>
What about #14806 ? `:-P`

Nathann



---

archive/issue_comments_213275.json:
```json
{
    "body": "<a id='comment:28'></a>\nOkay this is even more interesting and it indicates the problem is not really in the backend per se.\n\n```\n\nsage: G = graphs.RandomBarabasiAlbert(1000,2)\nsage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n1000 loops, best of 3: 1.68 ms per loop\n```\n\nBUT:\n\n```\nsage: S = SparseGraph(1000)\nsage: for i,j in G.edges(labels=False): S.add_arc(i,j)\nsage: %timeit E = [(u,v) for u in S.verts() for v in S.out_neighbors(u)]\n1000 loops, best of 3: 374 us per loop\n```\n\n\n**What do you guys thin is going on here?**\n\nAs for your static graphs thing If nobody wakes up then I promise to review it by the weekend! :-)",
    "created_at": "2013-08-13T12:56:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213275",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:28'></a>
Okay this is even more interesting and it indicates the problem is not really in the backend per se.

```

sage: G = graphs.RandomBarabasiAlbert(1000,2)
sage: %timeit E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
1000 loops, best of 3: 1.68 ms per loop
```

BUT:

```
sage: S = SparseGraph(1000)
sage: for i,j in G.edges(labels=False): S.add_arc(i,j)
sage: %timeit E = [(u,v) for u in S.verts() for v in S.out_neighbors(u)]
1000 loops, best of 3: 374 us per loop
```


**What do you guys thin is going on here?**

As for your static graphs thing If nobody wakes up then I promise to review it by the weekend! :-)



---

archive/issue_comments_213276.json:
```json
{
    "body": "<a id='comment:29'></a>\nAnd also the relevant profilings.. If they are of any help..\n\n```\nsage: G = graphs.RandomBarabasiAlbert(1000,2)\nsage: %prun E = [(u,v) for u in G for v in G.neighbor_iterator(u)]\n         1003 function calls in 0.005 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n     1000    0.003    0.000    0.003    0.000 generic_graph.py:7848(neighbor_iterator)\n        1    0.002    0.002    0.005    0.005 <string>:1(<module>)\n        1    0.000    0.000    0.000    0.000 generic_graph.py:7794(vertex_iterator)\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\nsage: %prun E = [(u,v) for u in S.verts() for v in S.out_neighbors(u)]\n         1003 function calls in 0.001 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n        1    0.001    0.001    0.001    0.001 <string>:1(<module>)\n     1000    0.000    0.000    0.000    0.000 {method 'out_neighbors' of 'sage.graphs.base.sparse_graph.SparseGraph' objects}\n        1    0.000    0.000    0.000    0.000 {method 'verts' of 'sage.graphs.base.c_graph.CGraph' objects}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\n```",
    "created_at": "2013-08-13T13:14:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213276",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:29'></a>
And also the relevant profilings.. If they are of any help..

```
sage: G = graphs.RandomBarabasiAlbert(1000,2)
sage: %prun E = [(u,v) for u in G for v in G.neighbor_iterator(u)]
         1003 function calls in 0.005 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     1000    0.003    0.000    0.003    0.000 generic_graph.py:7848(neighbor_iterator)
        1    0.002    0.002    0.005    0.005 <string>:1(<module>)
        1    0.000    0.000    0.000    0.000 generic_graph.py:7794(vertex_iterator)
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

sage: %prun E = [(u,v) for u in S.verts() for v in S.out_neighbors(u)]
         1003 function calls in 0.001 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.001    0.001    0.001    0.001 <string>:1(<module>)
     1000    0.000    0.000    0.000    0.000 {method 'out_neighbors' of 'sage.graphs.base.sparse_graph.SparseGraph' objects}
        1    0.000    0.000    0.000    0.000 {method 'verts' of 'sage.graphs.base.c_graph.CGraph' objects}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}

```



---

archive/issue_comments_213277.json:
```json
{
    "body": "<a id='comment:30'></a>\n> Okay this is even more interesting and it indicates the problem is not really in the backend per se.\n\n\nWelll... Is it just forwarding the values returned by out_neighbors through neighbor_iterator ?\n\n> As for your static graphs thing If nobody wakes up then I promise to review it by the weekend! :-)\n\n\nThat'd be cool `:-PPPPPPPP`\n\nNathann",
    "created_at": "2013-08-13T13:15:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213277",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:30'></a>
> Okay this is even more interesting and it indicates the problem is not really in the backend per se.


Welll... Is it just forwarding the values returned by out_neighbors through neighbor_iterator ?

> As for your static graphs thing If nobody wakes up then I promise to review it by the weekend! :-)


That'd be cool `:-PPPPPPPP`

Nathann



---

archive/issue_comments_213278.json:
```json
{
    "body": "<a id='comment:31'></a>\nReplying to [ncohen](#comment%3A30):\n> > Okay this is even more interesting and it indicates the problem is not really in the backend per se.\n\n> \n> Welll... Is it just forwarding the values returned by out_neighbors through neighbor_iterator ?\n  \nYES. But why does it take so long? This changes the runtime by a huge order of magnitude.\n\n\n> > As for your static graphs thing If nobody wakes up then I promise to review it by the weekend! :-)\n\n> \n> That'd be cool `:-PPPPPPPP`\n> \n> Nathann",
    "created_at": "2013-08-13T13:24:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213278",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:31'></a>
Replying to [ncohen](#comment%3A30):
> > Okay this is even more interesting and it indicates the problem is not really in the backend per se.

> 
> Welll... Is it just forwarding the values returned by out_neighbors through neighbor_iterator ?
  
YES. But why does it take so long? This changes the runtime by a huge order of magnitude.


> > As for your static graphs thing If nobody wakes up then I promise to review it by the weekend! :-)

> 
> That'd be cool `:-PPPPPPPP`
> 
> Nathann



---

archive/issue_comments_213279.json:
```json
{
    "body": "<a id='comment:32'></a>\n> YES. But why does it take so long? This changes the runtime by a huge order of magnitude.\n\n\nHMmmmm... I'd say \"just Python being Python\" `O_o`\n\nNathann",
    "created_at": "2013-08-13T13:31:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213279",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:32'></a>
> YES. But why does it take so long? This changes the runtime by a huge order of magnitude.


HMmmmm... I'd say "just Python being Python" `O_o`

Nathann



---

archive/issue_comments_213280.json:
```json
{
    "body": "<a id='comment:33'></a>\nYes! The only confusing thing to me is why then is NetworkX (called without going through the frontend) efficient? (confusing because NetworkX is in Python)\n\n```\nsage: N = G.networkx_graph()\nsage: %timeit E = [(u,v) for u in N for v in N.neighbors_iter(u)]\n1000 loops, best of 3: 599 us per loop\n```\n\nSo there is some Python being Python thing going on in the Graph frontend  class.",
    "created_at": "2013-08-13T13:37:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213280",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:33'></a>
Yes! The only confusing thing to me is why then is NetworkX (called without going through the frontend) efficient? (confusing because NetworkX is in Python)

```
sage: N = G.networkx_graph()
sage: %timeit E = [(u,v) for u in N for v in N.neighbors_iter(u)]
1000 loops, best of 3: 599 us per loop
```

So there is some Python being Python thing going on in the Graph frontend  class.



---

archive/issue_events_044596.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13730#event-44596"
}
```



---

archive/issue_comments_213281.json:
```json
{
    "body": "<a id='comment:35'></a>\nHere is a wrap up of what's going on with this problem https://groups.google.com/forum/#!topic/sage-devel/CwKSNWXVJtU",
    "created_at": "2013-08-30T09:50:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213281",
    "user": "https://trac.sagemath.org/admin/accounts/users/azi"
}
```

<a id='comment:35'></a>
Here is a wrap up of what's going on with this problem https://groups.google.com/forum/#!topic/sage-devel/CwKSNWXVJtU



---

archive/issue_events_044597.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13730#event-44597"
}
```



---

archive/issue_events_044598.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13730#event-44598"
}
```



---

archive/issue_events_044599.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13730#event-44599"
}
```



---

archive/issue_events_044600.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13730#event-44600"
}
```



---

archive/issue_events_044601.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13730#event-44601"
}
```



---

archive/issue_events_044602.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13730#event-44602"
}
```



---

archive/issue_comments_213282.json:
```json
{
    "body": "<a id='comment:39'></a>\nin view of recent progresses (see #28895), may be we can move this ticket to wont fix and close it.",
    "created_at": "2020-10-17T13:31:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13730",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13730#issuecomment-213282",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:39'></a>
in view of recent progresses (see #28895), may be we can move this ticket to wont fix and close it.
