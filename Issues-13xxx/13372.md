# Issue 13372: Meta-ticket: Duals of modules, algebras, coalgebras, hopf algebras, etc.

archive/issues_013200.json:
```json
{
    "body": "In this [discussion](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion), we came up with a rough draft of an interface for the method returning the dual of an object. Here is a summary by way of docstrings for the methods:\n\n```\ndef dual(self, category=None):\n    r\"\"\"\n    The dual of ``self``.\n\n    By default, the dual is computed in the category\n    ``self.category()``. If the user specifies a category, the dual will\n    be computed in that category.\n\n    INPUT:\n\n    - ``category`` -- category (default: the category of ``self``).\n\n    OUTPUT:\n\n    - The dual of ``self``.\n\n    EXAMPLES:\n\n    The Hopf algebra of symmetric functions is a self-dual Hopf\n    algebra::\n\n        sage: Sym = SymmetricFunctions(QQ); Sym\n        Symmetric Functions over Rational Field\n        sage: Sym.dual()\n        Symmetric Functions over Rational Field\n        sage: Sym.dual() is Sym\n        True\n\n    If we view ``Sym`` as an algebra, then its dual is a co-algebra::\n\n        sage: C = Sym.dual(category=Algebras(QQ)).category()\n        Category of duals of algebras over Rational Field\n        sage: C.super_categories()\n        [Category of coalgebras over Rational Field,\n         Category of duals of vector spaces over Rational Field]\n\n    The Schur basis for symmetric functions is self-dual and the\n    homogeneous symmetric functions are dual to the monomial\n    symmetric functions::\n\n        sage: s = Sym.schur()\n        sage: s.dual() is s\n        True\n        sage: h = Sym.homogeneous()\n        sage: m = Sym.monomial()\n        sage: h.dual() is m\n        True\n\n    Note that in the above, ``s`` (as well as ``h`` and ``m``) are Hopf\n    algebras with basis. Hence, their duals are also Hopf algebras with\n    basis.\n\n    The Hopf algebra of quasi-symmetric functions is dual, as a Hopf\n    algebra, to the Hopf algebra of non-commutative symmetric\n    functions::\n\n        sage: NCSF = NonCommutativeSymmetricFunctions(QQ)\n        sage: NCSF.dual()\n        Quasisymmetric functions over the Rational Field\n\n    ::\n        sage: QSym = QuasiSymmetricFunctions(QQ)\n        sage: QSym.dual()\n        Non-Commutative Symmetric Functions over the Rational Field\n\n    \"\"\"\n    return NotImplemented\n```\n\n```\ndef duality_pairing(self, x, y):\n    r\"\"\"\n    The duality pairing between elements of NSym and elements of QSym.\n\n    INPUT:\n\n    - ``x`` -- an element of ``self``\n    - ``y`` -- an element in the dual basis of ``self``\n\n    OUTPUT:\n\n    - The result of pairing the element ``x`` of ``self`` with the\n      element ``y`` of the dual of ``self``.\n\n    EXAMPLES:\n\n    The Schur basis of symmetric functions is self-dual::\n\n        sage: Sym = SymmetricFunctions(QQ)\n        sage: s = Sym(QQ).schur()\n        sage: s.dual() is s\n        True\n        sage: s.duality_pairing(s[2,1,1], s[2,1,1])\n        1\n        sage: s.duality_pairing(s[2,1], s[3])\n        0\n\n    The fundamental basis of quasi-symmetric functions is dual to the\n    ribbon basis of non-commutative symmetric functions::\n\n        sage: R = NonCommutativeSymmetricFunctions(QQ).Ribbon()\n        sage: F = QuasiSymmetricFunctions(QQ).Fundamental()\n        sage: R.duality_pairing(R[1,1,2], F[1,1,2])\n        1\n        sage: R.duality_pairing(R[1,2,1], F[1,1,2])\n        0\n        sage: F.duality_pairing(F[1,2,1], R[1,1,2])\n        0\n\n    \"\"\"\n    return NotImplemented\n```\nA rudimentary implementation for `duality_pairing` can be found at #8899, but see also the scalar product code for symmetric functions.\n\nI think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html).\n\nTickets:\n- #34621 Method `dual_pairing` for modules in `sage.tensor`\n\n\n\n**Assignee:** @aghitza\n\n**CC:**  combinat @tscrim\n\n**Keywords:** duality, categories, algebras\n\n**Status:** new\n\nIssue created by migration from https://trac.sagemath.org/ticket/13372\n\n",
    "created_at": "2012-08-15T14:57:10Z",
    "labels": [
        "component: algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Meta-ticket: Duals of modules, algebras, coalgebras, hopf algebras, etc.",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13372",
    "user": "https://github.com/saliola"
}
```
In this [discussion](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion), we came up with a rough draft of an interface for the method returning the dual of an object. Here is a summary by way of docstrings for the methods:

```
def dual(self, category=None):
    r"""
    The dual of ``self``.

    By default, the dual is computed in the category
    ``self.category()``. If the user specifies a category, the dual will
    be computed in that category.

    INPUT:

    - ``category`` -- category (default: the category of ``self``).

    OUTPUT:

    - The dual of ``self``.

    EXAMPLES:

    The Hopf algebra of symmetric functions is a self-dual Hopf
    algebra::

        sage: Sym = SymmetricFunctions(QQ); Sym
        Symmetric Functions over Rational Field
        sage: Sym.dual()
        Symmetric Functions over Rational Field
        sage: Sym.dual() is Sym
        True

    If we view ``Sym`` as an algebra, then its dual is a co-algebra::

        sage: C = Sym.dual(category=Algebras(QQ)).category()
        Category of duals of algebras over Rational Field
        sage: C.super_categories()
        [Category of coalgebras over Rational Field,
         Category of duals of vector spaces over Rational Field]

    The Schur basis for symmetric functions is self-dual and the
    homogeneous symmetric functions are dual to the monomial
    symmetric functions::

        sage: s = Sym.schur()
        sage: s.dual() is s
        True
        sage: h = Sym.homogeneous()
        sage: m = Sym.monomial()
        sage: h.dual() is m
        True

    Note that in the above, ``s`` (as well as ``h`` and ``m``) are Hopf
    algebras with basis. Hence, their duals are also Hopf algebras with
    basis.

    The Hopf algebra of quasi-symmetric functions is dual, as a Hopf
    algebra, to the Hopf algebra of non-commutative symmetric
    functions::

        sage: NCSF = NonCommutativeSymmetricFunctions(QQ)
        sage: NCSF.dual()
        Quasisymmetric functions over the Rational Field

    ::
        sage: QSym = QuasiSymmetricFunctions(QQ)
        sage: QSym.dual()
        Non-Commutative Symmetric Functions over the Rational Field

    """
    return NotImplemented
```

```
def duality_pairing(self, x, y):
    r"""
    The duality pairing between elements of NSym and elements of QSym.

    INPUT:

    - ``x`` -- an element of ``self``
    - ``y`` -- an element in the dual basis of ``self``

    OUTPUT:

    - The result of pairing the element ``x`` of ``self`` with the
      element ``y`` of the dual of ``self``.

    EXAMPLES:

    The Schur basis of symmetric functions is self-dual::

        sage: Sym = SymmetricFunctions(QQ)
        sage: s = Sym(QQ).schur()
        sage: s.dual() is s
        True
        sage: s.duality_pairing(s[2,1,1], s[2,1,1])
        1
        sage: s.duality_pairing(s[2,1], s[3])
        0

    The fundamental basis of quasi-symmetric functions is dual to the
    ribbon basis of non-commutative symmetric functions::

        sage: R = NonCommutativeSymmetricFunctions(QQ).Ribbon()
        sage: F = QuasiSymmetricFunctions(QQ).Fundamental()
        sage: R.duality_pairing(R[1,1,2], F[1,1,2])
        1
        sage: R.duality_pairing(R[1,2,1], F[1,1,2])
        0
        sage: F.duality_pairing(F[1,2,1], R[1,1,2])
        0

    """
    return NotImplemented
```
A rudimentary implementation for `duality_pairing` can be found at #8899, but see also the scalar product code for symmetric functions.

I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html).

Tickets:
- #34621 Method `dual_pairing` for modules in `sage.tensor`



**Assignee:** @aghitza

**CC:**  combinat @tscrim

**Keywords:** duality, categories, algebras

**Status:** new

Issue created by migration from https://trac.sagemath.org/ticket/13372





---

archive/issue_comments_205822.json:
```json
{
    "body": "<a id='comment:1'></a>\nSimon raised the following question in the [thread](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion):\n\n> Start with an object O in some category C1, take its dual D in C1, and\n> apply the forgetful functor to map it to a sub-category C2; one would\n> not always get the same result as if one first applies the forgetful\n> functor to O and then dualise the result in C2, right?\n\n>\n> And hence VectorSpaces(QQ)(H.dual()) might (perhaps not here, but in\n> other situations) be different from (VectorSpaces(QQ)(H)).dual().\n> Would that be a problem?",
    "created_at": "2012-08-15T15:00:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13372#issuecomment-205822",
    "user": "https://github.com/saliola"
}
```

<a id='comment:1'></a>
Simon raised the following question in the [thread](https://groups.google.com/d/topic/sage-combinat-devel/LdKONcGfGhU/discussion):

> Start with an object O in some category C1, take its dual D in C1, and
> apply the forgetful functor to map it to a sub-category C2; one would
> not always get the same result as if one first applies the forgetful
> functor to O and then dualise the result in C2, right?

>
> And hence VectorSpaces(QQ)(H.dual()) might (perhaps not here, but in
> other situations) be different from (VectorSpaces(QQ)(H)).dual().
> Would that be a problem?



---

archive/issue_comments_205823.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -68,20 +68,22 @@\n \n     \"\"\"\n     return NotImplemented\n+```\n \n+}}}\n def duality_pairing(self, x, y):\n     r\"\"\"\n     The duality pairing between elements of NSym and elements of QSym.\n \n     INPUT:\n \n-    - ``x`` -- an element of ``self``\n-    - ``y`` -- an element in the dual basis of ``self``\n+- ``x`` -- an element of ``self``\n+- ``y`` -- an element in the dual basis of ``self``\n \n     OUTPUT:\n \n-    - The result of pairing the element ``x`` of ``self`` with the\n-      element ``y`` of the dual of ``self``.\n+- The result of pairing the element ``x`` of ``self`` with the\n+  element ``y`` of the dual of ``self``.\n \n     EXAMPLES:\n \n@@ -110,8 +112,7 @@\n \n     \"\"\"\n     return NotImplemented\n-```\n-A rudimentary implementation for `duality_matrix` can be found at #8899, but see also the scalar product code for symmetric functions.\n+}}}\n+A rudimentary implementation for `duality_pairing` can be found at #8899, but see also the scalar product code for symmetric functions.\n \n-I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html)\n-\n+I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html).\n``````\n",
    "created_at": "2012-08-15T15:03:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13372#issuecomment-205823",
    "user": "https://github.com/saliola"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -68,20 +68,22 @@
 
     """
     return NotImplemented
+```
 
+}}}
 def duality_pairing(self, x, y):
     r"""
     The duality pairing between elements of NSym and elements of QSym.
 
     INPUT:
 
-    - ``x`` -- an element of ``self``
-    - ``y`` -- an element in the dual basis of ``self``
+- ``x`` -- an element of ``self``
+- ``y`` -- an element in the dual basis of ``self``
 
     OUTPUT:
 
-    - The result of pairing the element ``x`` of ``self`` with the
-      element ``y`` of the dual of ``self``.
+- The result of pairing the element ``x`` of ``self`` with the
+  element ``y`` of the dual of ``self``.
 
     EXAMPLES:
 
@@ -110,8 +112,7 @@
 
     """
     return NotImplemented
-```
-A rudimentary implementation for `duality_matrix` can be found at #8899, but see also the scalar product code for symmetric functions.
+}}}
+A rudimentary implementation for `duality_pairing` can be found at #8899, but see also the scalar product code for symmetric functions.
 
-I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html)
-
+I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html).
``````




---

archive/issue_comments_205824.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -70,20 +70,20 @@\n     return NotImplemented\n ```\n \n-}}}\n+```\n def duality_pairing(self, x, y):\n     r\"\"\"\n     The duality pairing between elements of NSym and elements of QSym.\n \n     INPUT:\n \n-- ``x`` -- an element of ``self``\n-- ``y`` -- an element in the dual basis of ``self``\n+    - ``x`` -- an element of ``self``\n+    - ``y`` -- an element in the dual basis of ``self``\n \n     OUTPUT:\n \n-- The result of pairing the element ``x`` of ``self`` with the\n-  element ``y`` of the dual of ``self``.\n+    - The result of pairing the element ``x`` of ``self`` with the\n+      element ``y`` of the dual of ``self``.\n \n     EXAMPLES:\n \n@@ -112,7 +112,7 @@\n \n     \"\"\"\n     return NotImplemented\n-}}}\n+```\n A rudimentary implementation for `duality_pairing` can be found at #8899, but see also the scalar product code for symmetric functions.\n \n I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html).\n``````\n",
    "created_at": "2012-08-15T15:03:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13372#issuecomment-205824",
    "user": "https://github.com/saliola"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -70,20 +70,20 @@
     return NotImplemented
 ```
 
-}}}
+```
 def duality_pairing(self, x, y):
     r"""
     The duality pairing between elements of NSym and elements of QSym.
 
     INPUT:
 
-- ``x`` -- an element of ``self``
-- ``y`` -- an element in the dual basis of ``self``
+    - ``x`` -- an element of ``self``
+    - ``y`` -- an element in the dual basis of ``self``
 
     OUTPUT:
 
-- The result of pairing the element ``x`` of ``self`` with the
-  element ``y`` of the dual of ``self``.
+    - The result of pairing the element ``x`` of ``self`` with the
+      element ``y`` of the dual of ``self``.
 
     EXAMPLES:
 
@@ -112,7 +112,7 @@
 
     """
     return NotImplemented
-}}}
+```
 A rudimentary implementation for `duality_pairing` can be found at #8899, but see also the scalar product code for symmetric functions.
 
 I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html).
``````




---

archive/issue_events_043153.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43153"
}
```



---

archive/issue_events_043154.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43154"
}
```



---

archive/issue_events_043155.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43155"
}
```



---

archive/issue_events_043156.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43156"
}
```



---

archive/issue_events_043157.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43157"
}
```



---

archive/issue_events_043158.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43158"
}
```



---

archive/issue_events_043159.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43159"
}
```



---

archive/issue_events_043160.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-07-08T19:55:41Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43160"
}
```



---

archive/issue_events_043161.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-07-08T19:55:41Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43161"
}
```



---

archive/issue_events_043162.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-13T17:11:30Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43162"
}
```



---

archive/issue_events_043163.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-13T17:11:30Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43163"
}
```



---

archive/issue_events_043164.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43164"
}
```



---

archive/issue_events_043165.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43165"
}
```



---

archive/issue_comments_205825.json:
```json
{
    "body": "<a id='comment:11'></a>\nSetting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13372#issuecomment-205825",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:11'></a>
Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_043166.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:43:17Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43166"
}
```



---

archive/issue_events_043167.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:43:17Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43167"
}
```



---

archive/issue_events_043168.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43168"
}
```



---

archive/issue_events_043169.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43169"
}
```



---

archive/issue_events_043170.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-01T21:16:35Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43170"
}
```



---

archive/issue_events_043171.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-01T21:16:35Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43171"
}
```



---

archive/issue_events_043172.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T05:25:02Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43172"
}
```



---

archive/issue_events_043173.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T05:25:02Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43173"
}
```



---

archive/issue_comments_205826.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -116,3 +116,8 @@\n A rudimentary implementation for `duality_pairing` can be found at #8899, but see also the scalar product code for symmetric functions.\n \n I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html).\n+\n+Tickets:\n+- #34621 Method `dual_pairing` for modules in `sage.tensor`\n+\n+\n``````\n",
    "created_at": "2022-09-30T22:20:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13372#issuecomment-205826",
    "user": "https://github.com/mkoeppe"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -116,3 +116,8 @@
 A rudimentary implementation for `duality_pairing` can be found at #8899, but see also the scalar product code for symmetric functions.
 
 I think a bunch of the code for duality for symmetric functions can be refactored. See [sage.combinat.sf.dual](http://www.sagemath.org/doc/reference/sage/combinat/sf/dual.html).
+
+Tickets:
+- #34621 Method `dual_pairing` for modules in `sage.tensor`
+
+
``````




---

archive/issue_events_043174.json:
```json
{
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/13372",
    "rename": {
        "from": "add functionality for duals of algebras, coalgebras, hopf algebras, etc.",
        "to": "Meta-ticket: Duals of modules, algebras, coalgebras, hopf algebras, etc."
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13372#event-43174"
}
```
