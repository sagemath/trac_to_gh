# Issue 13814: LazyFamily.__eq__ gives false positives.

archive/issues_013610.json:
```json
{
    "assignees": [
        "https://github.com/sagetrac-sage-combinat"
    ],
    "body": "`LazyFamily.__eq__` occasionally returns false positives, because it only compares function names, not values. This can lead to subtle bugs later, like this one:\n\n```python\nfun = lambda i:i\nfam1 = LazyFamily((0,1),fun)\nfun = lambda i:i+6\nfam2 = LazyFamily((0,1),fun)\nfam3 = LazyFamily((2,3),fun)\nd1 = DisjointUnionEnumeratedSets((fam1,fam3))\nd2 = DisjointUnionEnumeratedSets((fam2,fam3))\nfor u in (fam1,fam2,fam3,d1,d2):\n    print list(u)\n```\n\nThis gives\n\n```python\n[0, 1]\n[6, 7]\n[8, 9]\n[0, 1, 8, 9]\n[0, 1, 8, 9]\n```\n\nbecause Sage thinks `fam1 == fam2`. The behaviour can be fixed by setting\n\n```python\ndef noteq(self,other):\n    return False\nLazyFamily.__eq__ = noteq\n```\n\nI think `__eq__` should `_never_` give false positives for classes that might be hashed. In this case `LazyFamily.__eq__` should \n\n* test function equality if the index sets are finite of the same size\n* return `False` if one of the indexing sets is infinite\n   \n\nAuthor: **Christian Nassau**\n\nComponent: **combinatorics**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/13814_\n\n",
    "created_at": "2012-12-09T13:59:20Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20combinatorics",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "LazyFamily.__eq__ gives false positives.",
    "type": "issue",
    "updated_at": "2022-12-29T01:28:25Z",
    "url": "https://github.com/sagemath/sage/issues/13814",
    "user": "https://github.com/cnassau"
}
```
`LazyFamily.__eq__` occasionally returns false positives, because it only compares function names, not values. This can lead to subtle bugs later, like this one:

```python
fun = lambda i:i
fam1 = LazyFamily((0,1),fun)
fun = lambda i:i+6
fam2 = LazyFamily((0,1),fun)
fam3 = LazyFamily((2,3),fun)
d1 = DisjointUnionEnumeratedSets((fam1,fam3))
d2 = DisjointUnionEnumeratedSets((fam2,fam3))
for u in (fam1,fam2,fam3,d1,d2):
    print list(u)
```

This gives

```python
[0, 1]
[6, 7]
[8, 9]
[0, 1, 8, 9]
[0, 1, 8, 9]
```

because Sage thinks `fam1 == fam2`. The behaviour can be fixed by setting

```python
def noteq(self,other):
    return False
LazyFamily.__eq__ = noteq
```

I think `__eq__` should `_never_` give false positives for classes that might be hashed. In this case `LazyFamily.__eq__` should 

* test function equality if the index sets are finite of the same size
* return `False` if one of the indexing sets is infinite
   

Author: **Christian Nassau**

Component: **combinatorics**

_Issue created by migration from https://trac.sagemath.org/ticket/13814_





---

archive/issue_events_191954.json:
```json
{
    "actor": "https://github.com/cnassau",
    "created_at": "2012-12-09T13:59:20Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-5.11",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191954"
}
```



---

archive/issue_events_191955.json:
```json
{
    "actor": "https://github.com/cnassau",
    "created_at": "2012-12-09T13:59:20Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20combinatorics",
    "label_color": "0000ff",
    "label_name": "c: combinatorics",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191955"
}
```



---

archive/issue_events_191956.json:
```json
{
    "actor": "https://github.com/cnassau",
    "created_at": "2012-12-09T13:59:20Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191956"
}
```



---

archive/issue_events_191957.json:
```json
{
    "actor": "https://github.com/cnassau",
    "created_at": "2012-12-09T13:59:20Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191957"
}
```



---

archive/issue_events_191958.json:
```json
{
    "actor": "https://github.com/sagetrac-sage-combinat",
    "created_at": "2012-12-09T13:59:20Z",
    "event": "assigned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "subject": "https://github.com/cnassau",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191958"
}
```



---

archive/issue_comments_162803.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -14,7 +14,7 @@\n \n This gives\n \n-```\n+```python\n [0, 1]\n [6, 7]\n [8, 9]\n@@ -24,14 +24,14 @@\n \n because Sage thinks `fam1 == fam2`. The behaviour can be fixed by setting\n \n-```\n+```python\n def noteq(self,other):\n     return False\n LazyFamily.__eq__ = noteq\n ```\n \n-I think `__eq__` should *never* give false positives for classes that might be hashed. In this case `LazyFamily.__eq__` should \n+I think `__eq__` should `_never_` give false positives for classes that might be hashed. In this case `LazyFamily.__eq__` should \n \n * test function equality if the index sets are finite of the same size\n-* return `False` if the both index sets are infinite\n+* return `False` if one of the indexing sets is infinite\n    \n``````\n",
    "created_at": "2012-12-09T15:37:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162803",
    "user": "https://github.com/cnassau"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -14,7 +14,7 @@
 
 This gives
 
-```
+```python
 [0, 1]
 [6, 7]
 [8, 9]
@@ -24,14 +24,14 @@
 
 because Sage thinks `fam1 == fam2`. The behaviour can be fixed by setting
 
-```
+```python
 def noteq(self,other):
     return False
 LazyFamily.__eq__ = noteq
 ```
 
-I think `__eq__` should *never* give false positives for classes that might be hashed. In this case `LazyFamily.__eq__` should 
+I think `__eq__` should `_never_` give false positives for classes that might be hashed. In this case `LazyFamily.__eq__` should 
 
 * test function equality if the index sets are finite of the same size
-* return `False` if the both index sets are infinite
+* return `False` if one of the indexing sets is infinite
    
``````




---

archive/issue_comments_162804.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nI've attached a patch that fixes the equality test for lazy families. \n\nIt leads to testsuite failures in `disjoint_union_enumerated_sets.py`: these failures are due to pickling problems that were hidden by the deficiency of the old `__eq__` implementation.\n\nThe TestSuite failures would probably be fixed if `_test_pickling` would check for\n\n   ```\n   not (f != loads(dumps(f)))\n   ```\nrather than\n\n   ```\n   f == loads(dumps(f))\n   ```\nI'll suggest this in a different ticket.",
    "created_at": "2012-12-10T18:12:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162804",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:2" align="right">comment:2</div>

I've attached a patch that fixes the equality test for lazy families. 

It leads to testsuite failures in `disjoint_union_enumerated_sets.py`: these failures are due to pickling problems that were hidden by the deficiency of the old `__eq__` implementation.

The TestSuite failures would probably be fixed if `_test_pickling` would check for

   ```
   not (f != loads(dumps(f)))
   ```
rather than

   ```
   f == loads(dumps(f))
   ```
I'll suggest this in a different ticket.



---

archive/issue_events_191959.json:
```json
{
    "actor": "https://github.com/cnassau",
    "created_at": "2012-12-10T18:12:13Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191959"
}
```



---

archive/issue_events_191960.json:
```json
{
    "actor": "https://github.com/cnassau",
    "created_at": "2012-12-10T18:13:09Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191960"
}
```



---

archive/issue_events_191961.json:
```json
{
    "actor": "https://github.com/cnassau",
    "created_at": "2012-12-10T18:13:09Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191961"
}
```



---

archive/issue_comments_162805.json:
```json
{
    "body": "Hi!\n\nReplying to [ticket:13814 cnassau]:\n> `LazyFamily.__eq__` occasionally returns false positives, because it only compares function names, not values. \n\nYikes. This is indeed definitely a bug!\n\nThanks for catching it, and sorry for commenting on it after you have\nimplemented a first proposal of solution.\n\n> I think `__eq__` should `_never_` give false positives for classes that might be hashed.\n\n+1!\n\n> In this case `LazyFamily.__eq__` should\n\n>\n>* test function equality if the index sets are finite of the same size\n>* return `False` if one of the indexing sets is infinite\n\nI would much prefer to stick as much as possible to the default\nequality rule for composite objects: namely to compare their\ncomponents for equality. A Family is composed of an indexing set `I`\nand a mapping `f`. Thus, ideally, two families should be equal if\ntheir indexing sets are equal and their mappings are equal.  How two\nsets (infinite or not) compare for equality is not Family's decision\nto take.\n\nNow, we have the problem that comparing mappings is delicate; first\nbecause two functions with the same code are not considered as equal,\nand anyway because two functions with different code might implement\nthe same mapping, but that's undecidable.\n\nSo at this point it seems to me that the best approximation would be\nas follow:\n\n- For comparing two FiniteFamily's, compare the underlying indexing\n  set and dictionary for equality (the mapping has already been\n  computed on all the indexing set, so we might as well use it, even\n  though this comparison will have a cost).\n\n- For comparing other families: test whether the two indexing sets and\n  the two mappings compare to equal.\n\nPotential issue: that upon pickling unpickling we get back an equal\nobject.\n\nThanks again for investigating this,\n\nBest,\n                              Nicolas",
    "created_at": "2012-12-11T09:45:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162805",
    "user": "https://github.com/nthiery"
}
```

Hi!

Replying to [ticket:13814 cnassau]:
> `LazyFamily.__eq__` occasionally returns false positives, because it only compares function names, not values. 

Yikes. This is indeed definitely a bug!

Thanks for catching it, and sorry for commenting on it after you have
implemented a first proposal of solution.

> I think `__eq__` should `_never_` give false positives for classes that might be hashed.

+1!

> In this case `LazyFamily.__eq__` should

>
>* test function equality if the index sets are finite of the same size
>* return `False` if one of the indexing sets is infinite

I would much prefer to stick as much as possible to the default
equality rule for composite objects: namely to compare their
components for equality. A Family is composed of an indexing set `I`
and a mapping `f`. Thus, ideally, two families should be equal if
their indexing sets are equal and their mappings are equal.  How two
sets (infinite or not) compare for equality is not Family's decision
to take.

Now, we have the problem that comparing mappings is delicate; first
because two functions with the same code are not considered as equal,
and anyway because two functions with different code might implement
the same mapping, but that's undecidable.

So at this point it seems to me that the best approximation would be
as follow:

- For comparing two FiniteFamily's, compare the underlying indexing
  set and dictionary for equality (the mapping has already been
  computed on all the indexing set, so we might as well use it, even
  though this comparison will have a cost).

- For comparing other families: test whether the two indexing sets and
  the two mappings compare to equal.

Potential issue: that upon pickling unpickling we get back an equal
object.

Thanks again for investigating this,

Best,
                              Nicolas



---

archive/issue_comments_162806.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nReplying to [@cnassau](#comment:2):\n> The TestSuite failures would probably be fixed if `_test_pickling` would check for\n> \n>    ```\n>    not (f != loads(dumps(f)))\n>    ```\n> rather than\n> \n>    ```\n>    f == loads(dumps(f))\n>    ```\n> I'll suggest this in a different ticket.\n\n``__eq__`` and ``__ne__`` are supposed to be implemented consistently; so\n_test_pickling is allowed to rely on this assumption. If the\nassumption fails, that's an equality bug which should be fixed in\n``__eq__/__ne__`` and be tested in ``_test_equal`` (whenever possible).\n\nCheers,\n                   Nicolas",
    "created_at": "2012-12-11T09:52:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162806",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:6" align="right">comment:6</div>

Replying to [@cnassau](#comment:2):
> The TestSuite failures would probably be fixed if `_test_pickling` would check for
> 
>    ```
>    not (f != loads(dumps(f)))
>    ```
> rather than
> 
>    ```
>    f == loads(dumps(f))
>    ```
> I'll suggest this in a different ticket.

``__eq__`` and ``__ne__`` are supposed to be implemented consistently; so
_test_pickling is allowed to rely on this assumption. If the
assumption fails, that's an equality bug which should be fixed in
``__eq__/__ne__`` and be tested in ``_test_equal`` (whenever possible).

Cheers,
                   Nicolas



---

archive/issue_comments_162807.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nReplying to [@nthiery](#comment:5):\n> So at this point it seems to me that the best approximation would be\n> as follow:\n> \n> - For comparing two FiniteFamily's, compare the underlying indexing\n>   set and dictionary for equality (the mapping has already been\n>   computed on all the indexing set, so we might as well use it, even\n>   though this comparison will have a cost).\n> \n> - For comparing other families: test whether the two indexing sets and\n>   the two mappings compare to equal.\n\nI think this is also how my patch implements this (which does not quite follow the description in my original submission). \n\nIn my patch function equality is tested like this:\n \n* finite family: brute force check of all values\n* infinite family: check if function objects are identical\n\nIt occured to me that we should also try this:\n\n* comparison of the pickle-string of the function objects\n* testing an initial finite slice of the values \n\nI believe functions with the same pickle-representation are guaranteed to be equal, even if their pickled-function might not be usable (see failure of U3 doctests in my patch).\n\n> Potential issue: that upon pickling unpickling we get back an equal\n> object.",
    "created_at": "2012-12-11T10:02:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162807",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:7" align="right">comment:7</div>

Replying to [@nthiery](#comment:5):
> So at this point it seems to me that the best approximation would be
> as follow:
> 
> - For comparing two FiniteFamily's, compare the underlying indexing
>   set and dictionary for equality (the mapping has already been
>   computed on all the indexing set, so we might as well use it, even
>   though this comparison will have a cost).
> 
> - For comparing other families: test whether the two indexing sets and
>   the two mappings compare to equal.

I think this is also how my patch implements this (which does not quite follow the description in my original submission). 

In my patch function equality is tested like this:
 
* finite family: brute force check of all values
* infinite family: check if function objects are identical

It occured to me that we should also try this:

* comparison of the pickle-string of the function objects
* testing an initial finite slice of the values 

I believe functions with the same pickle-representation are guaranteed to be equal, even if their pickled-function might not be usable (see failure of U3 doctests in my patch).

> Potential issue: that upon pickling unpickling we get back an equal
> object.



---

archive/issue_comments_162808.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nReplying to [@nthiery](#comment:6):\n> Replying to [@cnassau](#comment:2):\n> > The TestSuite failures would probably be fixed if `_test_pickling` would check for\n> > \n> >    ```\n> >    not (f != loads(dumps(f)))\n> >    ```\n> > rather than\n> > \n> >    ```\n> >    f == loads(dumps(f))\n> >    ```\n> > I'll suggest this in a different ticket.\n\n> \n> ``__eq__`` and ``__ne__`` are supposed to be implemented consistently; so\n> _test_pickling is allowed to rely on this assumption. If the\n> assumption fails, that's an equality bug which should be fixed in\n> ``__eq__/__ne__`` and be tested in ``_test_equal`` (whenever possible).\n\nWell, I think it `__is__` consistent to have\n\n   ```\n      sage: LazyFamily(Integers(),lambda i:i) == LazyFamily(Integers(),lambda i:1*i)\n      False\n      sage: LazyFamily(Integers(),lambda i:i) != LazyFamily(Integers(),lambda i:1*i)\n      False\n   ```\n\nIn my reading this conforms to the standard python requirements: \n\n   hashing only requires `__hash__` and `__eq__` in \n   `http://docs.python.org/2/reference/datamodel.html#object.__hash__`\n\nThe document also says\n\n   There are no implied relationships among the comparison operators. The truth of x==y does not imply that x!=y is false.\n\nCheers,\nChristian",
    "created_at": "2012-12-11T10:06:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162808",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:8" align="right">comment:8</div>

Replying to [@nthiery](#comment:6):
> Replying to [@cnassau](#comment:2):
> > The TestSuite failures would probably be fixed if `_test_pickling` would check for
> > 
> >    ```
> >    not (f != loads(dumps(f)))
> >    ```
> > rather than
> > 
> >    ```
> >    f == loads(dumps(f))
> >    ```
> > I'll suggest this in a different ticket.

> 
> ``__eq__`` and ``__ne__`` are supposed to be implemented consistently; so
> _test_pickling is allowed to rely on this assumption. If the
> assumption fails, that's an equality bug which should be fixed in
> ``__eq__/__ne__`` and be tested in ``_test_equal`` (whenever possible).

Well, I think it `__is__` consistent to have

   ```
      sage: LazyFamily(Integers(),lambda i:i) == LazyFamily(Integers(),lambda i:1*i)
      False
      sage: LazyFamily(Integers(),lambda i:i) != LazyFamily(Integers(),lambda i:1*i)
      False
   ```

In my reading this conforms to the standard python requirements: 

   hashing only requires `__hash__` and `__eq__` in 
   `http://docs.python.org/2/reference/datamodel.html#object.__hash__`

The document also says

   There are no implied relationships among the comparison operators. The truth of x==y does not imply that x!=y is false.

Cheers,
Christian



---

archive/issue_comments_162809.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nReplying to [@cnassau](#comment:7):\n> I think this is also how my patch implements this (which does not quite follow the description in my original submission). \n> \n> In my patch function equality is tested like this:\n>  \n> * finite family: brute force check of all values\n> * infinite family: check if function objects are identical\n\nThere is a slight difference: I prefer the distinction to be based on\nthe class, namely whether we are manipulating two FiniteFamily's or\nnot.\n\nBy the way, please use:\n\n```\n    for i in self.set:\n```\n\nrather than:\n\n```\n    lst = list(self.set)\n    for i in lst\n```\n\n\n> It occured to me that we should also try this:\n> \n> * comparison of the pickle-string of the function objects\n\nThis sounds reasonable, but needs to be heavily tested for all sorts\nof function objects.\n\n> * testing an initial finite slice of the values\n\nI can see the point! Still, I'd rather stick to a behavior that\ndepends only on the class, rather than on some magic constant.\nOtherwise, this is likely to cause bugs that won't be caught by\ntesting since they will only show up for large objects.\n\nCheers,\n               Nicolas",
    "created_at": "2012-12-11T14:44:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162809",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:9" align="right">comment:9</div>

Replying to [@cnassau](#comment:7):
> I think this is also how my patch implements this (which does not quite follow the description in my original submission). 
> 
> In my patch function equality is tested like this:
>  
> * finite family: brute force check of all values
> * infinite family: check if function objects are identical

There is a slight difference: I prefer the distinction to be based on
the class, namely whether we are manipulating two FiniteFamily's or
not.

By the way, please use:

```
    for i in self.set:
```

rather than:

```
    lst = list(self.set)
    for i in lst
```


> It occured to me that we should also try this:
> 
> * comparison of the pickle-string of the function objects

This sounds reasonable, but needs to be heavily tested for all sorts
of function objects.

> * testing an initial finite slice of the values

I can see the point! Still, I'd rather stick to a behavior that
depends only on the class, rather than on some magic constant.
Otherwise, this is likely to cause bugs that won't be caught by
testing since they will only show up for large objects.

Cheers,
               Nicolas



---

archive/issue_comments_162810.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nReplying to [@nthiery](#comment:9):\n> Replying to [@cnassau](#comment:7):\n> > I think this is also how my patch implements this (which does not quite follow the description in my original submission). \n> > \n> > In my patch function equality is tested like this:\n> >  \n> > * finite family: brute force check of all values\n> > * infinite family: check if function objects are identical\n\n> \n> There is a slight difference: I prefer the distinction to be based on\n> the class, namely whether we are manipulating two FiniteFamily's or\n> not.\n\nThis has some really bad consequences if (as I believe) we're `__not__` able to reliably test functions for equality. We would then have to live with\n\n   ```\n   sage: LazyFamily([1,2,3], lambda i:i) == LazyFamily([1,2,3], lambda i:i)\n   False\n   ```\n\nI would find it better to use a brute force check for those finite index sets that implement a `list()` method:\n\n   ```\n   try:\n       for i in self.set.list():\n           if self.function(i) != other.function(i):\n               return False\n       return True\n   except NotImplementedError:\n       pass\n   ```\n\nAs noted in `src/categories/enumerated_sets.py` a set can choose to not implement `list` if it is probably too large to be useful. \n\n> By the way, please use:\n> \n> ```\n>     for i in self.set:\n> ```\n> \n> rather than:\n> \n> ```\n>     lst = list(self.set)\n>     for i in lst\n> ```\n\nThe idea was to use `self.set.list()` as explained above, because then the exhaustive check would be skipped for sets that are too big and know about it.\n\n> > It occured to me that we should also try this:\n> > \n> > * comparison of the pickle-string of the function objects\n\n> \n> This sounds reasonable, but needs to be heavily tested for all sorts\n> of function objects.\n\nI've changed my mind: this is not at all a good idea: in my tests an `unpickle_function(lambda i:i)` includes a reference to the doctest where it was defined. That's not good at all if we want to test for function equality... for similar reasons it seems bad to use the bytecode disassembly from the dis module...\n\nCould you live with the `self.set.list()` suggestion?",
    "created_at": "2012-12-11T17:25:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162810",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:10" align="right">comment:10</div>

Replying to [@nthiery](#comment:9):
> Replying to [@cnassau](#comment:7):
> > I think this is also how my patch implements this (which does not quite follow the description in my original submission). 
> > 
> > In my patch function equality is tested like this:
> >  
> > * finite family: brute force check of all values
> > * infinite family: check if function objects are identical

> 
> There is a slight difference: I prefer the distinction to be based on
> the class, namely whether we are manipulating two FiniteFamily's or
> not.

This has some really bad consequences if (as I believe) we're `__not__` able to reliably test functions for equality. We would then have to live with

   ```
   sage: LazyFamily([1,2,3], lambda i:i) == LazyFamily([1,2,3], lambda i:i)
   False
   ```

I would find it better to use a brute force check for those finite index sets that implement a `list()` method:

   ```
   try:
       for i in self.set.list():
           if self.function(i) != other.function(i):
               return False
       return True
   except NotImplementedError:
       pass
   ```

As noted in `src/categories/enumerated_sets.py` a set can choose to not implement `list` if it is probably too large to be useful. 

> By the way, please use:
> 
> ```
>     for i in self.set:
> ```
> 
> rather than:
> 
> ```
>     lst = list(self.set)
>     for i in lst
> ```

The idea was to use `self.set.list()` as explained above, because then the exhaustive check would be skipped for sets that are too big and know about it.

> > It occured to me that we should also try this:
> > 
> > * comparison of the pickle-string of the function objects

> 
> This sounds reasonable, but needs to be heavily tested for all sorts
> of function objects.

I've changed my mind: this is not at all a good idea: in my tests an `unpickle_function(lambda i:i)` includes a reference to the doctest where it was defined. That's not good at all if we want to test for function equality... for similar reasons it seems bad to use the bytecode disassembly from the dis module...

Could you live with the `self.set.list()` suggestion?



---

archive/issue_comments_162811.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nReplying to [@cnassau](#comment:10):\n> This has some really bad consequences if (as I believe) we're `__not__` able to reliably test functions for equality. We would then have to live with\n> \n>    ```\n>    sage: LazyFamily([1,2,3], lambda i:i) == LazyFamily([1,2,3], lambda i:i)\n>    False\n>    ```\n\nThat is perfectly fine for me: if the caller asked explicitly for a\nlazy family, then (s)he should expect the comparison to be lazy, and\nthus cheap but incomplete. If she is willing to pay the price of\ncomputing the function on all indices, then a FiniteFamily is what she\nwants.\n\n> As noted in `src/categories/enumerated_sets.py` a set can choose to not implement `list` if it is probably too large to be useful.\n\nYup. But there are a lot of sets, like Permutations(n) that can be\nvery small or very large, and such sets cannot make a good decision.\nAt the end of the day, it's better to take the decision upon building\nthe family (by asking explicitly for a lazy family or not).\n\n> I've changed my mind: this is not at all a good idea: in my tests an `unpickle_function(lambda i:i)` includes a reference to the doctest where it was defined. That's not good at all if we want to test for function equality... for similar reasons it seems bad to use the bytecode disassembly from the dis module...\n\nOk!\n\nKind regards,\n\t                    Nicolas",
    "created_at": "2012-12-11T23:02:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162811",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:11" align="right">comment:11</div>

Replying to [@cnassau](#comment:10):
> This has some really bad consequences if (as I believe) we're `__not__` able to reliably test functions for equality. We would then have to live with
> 
>    ```
>    sage: LazyFamily([1,2,3], lambda i:i) == LazyFamily([1,2,3], lambda i:i)
>    False
>    ```

That is perfectly fine for me: if the caller asked explicitly for a
lazy family, then (s)he should expect the comparison to be lazy, and
thus cheap but incomplete. If she is willing to pay the price of
computing the function on all indices, then a FiniteFamily is what she
wants.

> As noted in `src/categories/enumerated_sets.py` a set can choose to not implement `list` if it is probably too large to be useful.

Yup. But there are a lot of sets, like Permutations(n) that can be
very small or very large, and such sets cannot make a good decision.
At the end of the day, it's better to take the decision upon building
the family (by asking explicitly for a lazy family or not).

> I've changed my mind: this is not at all a good idea: in my tests an `unpickle_function(lambda i:i)` includes a reference to the doctest where it was defined. That's not good at all if we want to test for function equality... for similar reasons it seems bad to use the bytecode disassembly from the dis module...

Ok!

Kind regards,
	                    Nicolas



---

archive/issue_comments_162812.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nOk, so I'll prepare a new patch which \n\n* does not compare function values if the indexing set is finite\n* recognizes identical function objects\n* uses `self.function.__eq__` if this is available\n* otherwise treats functions as distinct\n\nWe will then have, for example,\n   \n\n   ```\n   sage: LazyFamily([1,2,3], lambda i:i) == LazyFamily([1,2,3], lambda i:i)\n   False\n   sage: LazyFamily([1,2,3], lambda i:i) != LazyFamily([1,2,3], lambda i:i)\n   False\n   ```\n\nI predict that quite a number of doctests will have to be modified. There will be new pickling failures, because Sage will often not be able to verify `f == load(dumps(f))`. If we switched to `not(f!=load(dumps(f)))` the doctests could probably remain as they are. I'll post more on this when I have the patch and some numbers.\n\nCheers,\nChristian",
    "created_at": "2012-12-12T07:22:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162812",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:12" align="right">comment:12</div>

Ok, so I'll prepare a new patch which 

* does not compare function values if the indexing set is finite
* recognizes identical function objects
* uses `self.function.__eq__` if this is available
* otherwise treats functions as distinct

We will then have, for example,
   

   ```
   sage: LazyFamily([1,2,3], lambda i:i) == LazyFamily([1,2,3], lambda i:i)
   False
   sage: LazyFamily([1,2,3], lambda i:i) != LazyFamily([1,2,3], lambda i:i)
   False
   ```

I predict that quite a number of doctests will have to be modified. There will be new pickling failures, because Sage will often not be able to verify `f == load(dumps(f))`. If we switched to `not(f!=load(dumps(f)))` the doctests could probably remain as they are. I'll post more on this when I have the patch and some numbers.

Cheers,
Christian



---

archive/issue_comments_162813.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nBy the way, would you mind if I also included the change proposed in ticket #13811 in this patch?",
    "created_at": "2012-12-12T08:48:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162813",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:13" align="right">comment:13</div>

By the way, would you mind if I also included the change proposed in ticket #13811 in this patch?



---

archive/issue_comments_162814.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nHi Christian,\n\nReplying to [@cnassau](#comment:8):\n> > ``__eq__`` and ``__ne__`` are supposed to be implemented consistently; so\n> > _test_pickling is allowed to rely on this assumption. If the\n> > assumption fails, that's an equality bug which should be fixed in\n> > ``__eq__/__ne__`` and be tested in ``_test_equal`` (whenever possible).\n\n> \n> Well, I think it `__is__` consistent to have\n> \n>    ```\n>       sage: LazyFamily(Integers(),lambda i:i) == LazyFamily(Integers(),lambda i:1*i)\n>       False\n>       sage: LazyFamily(Integers(),lambda i:i) != LazyFamily(Integers(),lambda i:1*i)\n>       False\n>    ```\n> \n> In my reading this conforms to the standard python requirements: \n> \n>    hashing only requires `__hash__` and `__eq__` in \n>    `http://docs.python.org/2/reference/datamodel.html#object.__hash__`\n> \n> The document also says\n> \n>    There are no implied relationships among the comparison operators. The truth of x==y does not imply that x!=y is false.\n\nThat's right for Python. However Sage is more stringent about this and\nrequires == and != to be consistent. Hmm, I am not sure this is\ndocumented anywhere though. Basically the idea is that we already have\ntrouble maintaining a consistent specification and implementation for\n==, so we can't really afford to also maintain a possibly different\nspecification for != ...\n\nCheers,\n                     Nicolas",
    "created_at": "2012-12-13T09:14:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162814",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:14" align="right">comment:14</div>

Hi Christian,

Replying to [@cnassau](#comment:8):
> > ``__eq__`` and ``__ne__`` are supposed to be implemented consistently; so
> > _test_pickling is allowed to rely on this assumption. If the
> > assumption fails, that's an equality bug which should be fixed in
> > ``__eq__/__ne__`` and be tested in ``_test_equal`` (whenever possible).

> 
> Well, I think it `__is__` consistent to have
> 
>    ```
>       sage: LazyFamily(Integers(),lambda i:i) == LazyFamily(Integers(),lambda i:1*i)
>       False
>       sage: LazyFamily(Integers(),lambda i:i) != LazyFamily(Integers(),lambda i:1*i)
>       False
>    ```
> 
> In my reading this conforms to the standard python requirements: 
> 
>    hashing only requires `__hash__` and `__eq__` in 
>    `http://docs.python.org/2/reference/datamodel.html#object.__hash__`
> 
> The document also says
> 
>    There are no implied relationships among the comparison operators. The truth of x==y does not imply that x!=y is false.

That's right for Python. However Sage is more stringent about this and
requires == and != to be consistent. Hmm, I am not sure this is
documented anywhere though. Basically the idea is that we already have
trouble maintaining a consistent specification and implementation for
==, so we can't really afford to also maintain a possibly different
specification for != ...

Cheers,
                     Nicolas



---

archive/issue_comments_162815.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nReplying to [@cnassau](#comment:12):\n> Ok, so I'll prepare a new patch which \n> \n> * does not compare function values if the indexing set is finite\n> * recognizes identical function objects\n> * uses `self.function.__eq__` if this is available\n> * otherwise treats functions as distinct\n\nExcellent. Thanks!\n\n> We will then have, for example,\n\n>\n>    ```\n>    sage: LazyFamily([1,2,3], lambda i:i) == LazyFamily([1,2,3], lambda i:i)\n>    False\n>    sage: LazyFamily([1,2,3], lambda i:i) != LazyFamily([1,2,3], lambda i:i)\n>    False\n>    ```\n\nI really vote for == and != being consistent. Comments anyone else?\n\n> I predict that quite a number of doctests will have to be\n> modified. There will be new pickling failures, because Sage will\n> often not be able to verify `f == load(dumps(f))`.\n\nDo you mind post here a quick selection of typical\ndoctests / pickling failures? That will be a good source for me and\nothers to think about what the right approach shall be.\n\nThanks for your ongoing work!\n                                  Nicolas\n\nPS: for the other ticket, since the changes are fairly independent,\nplease keep them separate!",
    "created_at": "2012-12-13T09:22:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162815",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:15" align="right">comment:15</div>

Replying to [@cnassau](#comment:12):
> Ok, so I'll prepare a new patch which 
> 
> * does not compare function values if the indexing set is finite
> * recognizes identical function objects
> * uses `self.function.__eq__` if this is available
> * otherwise treats functions as distinct

Excellent. Thanks!

> We will then have, for example,

>
>    ```
>    sage: LazyFamily([1,2,3], lambda i:i) == LazyFamily([1,2,3], lambda i:i)
>    False
>    sage: LazyFamily([1,2,3], lambda i:i) != LazyFamily([1,2,3], lambda i:i)
>    False
>    ```

I really vote for == and != being consistent. Comments anyone else?

> I predict that quite a number of doctests will have to be
> modified. There will be new pickling failures, because Sage will
> often not be able to verify `f == load(dumps(f))`.

Do you mind post here a quick selection of typical
doctests / pickling failures? That will be a good source for me and
others to think about what the right approach shall be.

Thanks for your ongoing work!
                                  Nicolas

PS: for the other ticket, since the changes are fairly independent,
please keep them separate!



---

archive/issue_comments_162816.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nI have implemented a new patch, based on Sage 5.5.rc0. Here are the key features:\n\nThe new `LazyFamily.__eq__`\n\n*  does not compare function values (even if the indexing set is finite)\n*  recognizes identical function objects\n*  uses `self.function.__eq__` if this is available\n*  otherwise treats functions as distinct \n\nFurthermore\n\n*  \"`f != g`\" is exactly equivalent to \"`not(f==g)`\"\n\nContrary to my expectations there were not that many doctest failures. The only affectes files were ``family.py`` and ``disjoint_union_enumerated_sets.py``.\n\nOriginally I was hoping to present two patches, plus numbers/statistics about doctest failures and the like....  but I'm a little bit too exhausted right now. And I think the new patch is probably good enough as it stands ;-)\n\nCheers, \\\\\nChristian",
    "created_at": "2012-12-14T17:52:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162816",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:16" align="right">comment:16</div>

I have implemented a new patch, based on Sage 5.5.rc0. Here are the key features:

The new `LazyFamily.__eq__`

*  does not compare function values (even if the indexing set is finite)
*  recognizes identical function objects
*  uses `self.function.__eq__` if this is available
*  otherwise treats functions as distinct 

Furthermore

*  "`f != g`" is exactly equivalent to "`not(f==g)`"

Contrary to my expectations there were not that many doctest failures. The only affectes files were ``family.py`` and ``disjoint_union_enumerated_sets.py``.

Originally I was hoping to present two patches, plus numbers/statistics about doctest failures and the like....  but I'm a little bit too exhausted right now. And I think the new patch is probably good enough as it stands ;-)

Cheers, \\
Christian



---

archive/issue_comments_162817.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nReplying to [@cnassau](#comment:16):\n> I have implemented a new patch, based on Sage 5.5.rc0. Here are the key features:\n> \n> The new `LazyFamily.__eq__`\n> \n> *  does not compare function values (even if the indexing set is finite)\n> *  recognizes identical function objects\n> *  uses `self.function.__eq__` if this is available\n> *  otherwise treats functions as distinct \n> \n> Furthermore\n> \n> *  \"`f != g`\" is exactly equivalent to \"`not(f==g)`\"\n\nGreat, thanks!\n\n> Contrary to my expectations there were not that many doctest failures. The only affectes files were ``family.py`` and ``disjoint_union_enumerated_sets.py``.\n\nThat's definitely good news.\n\nShould I remove the previous patch? Then we won't have to specify\nwhich patch to apply.\n\nA couple questions:\n\nWould there be a problem to just compare the functions with:\n\n```\n   self.function == other.function\n```\nRather than doing the check for is and then for eq?\n\nI am surprised about your comment about Permutations not being\npicklable. This works for me:\n\n```\n  sage: P = Permutations(3) \n  sage: P == Permutations(3)\n  True\n  sage: P == loads(dumps(P))\n  True\n```\n\nCould the hash be calculated using both the hash of the indexing set\nand the function?\n\nPlease take the occasion to rewrite `WARNING` into\n`.. WARNING::` (see the developers manual for the exact syntax).\n\nWhere is ``!=`` implemented?\n\n\nCheers,\n                          Nicolas",
    "created_at": "2012-12-14T21:09:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162817",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:17" align="right">comment:17</div>

Replying to [@cnassau](#comment:16):
> I have implemented a new patch, based on Sage 5.5.rc0. Here are the key features:
> 
> The new `LazyFamily.__eq__`
> 
> *  does not compare function values (even if the indexing set is finite)
> *  recognizes identical function objects
> *  uses `self.function.__eq__` if this is available
> *  otherwise treats functions as distinct 
> 
> Furthermore
> 
> *  "`f != g`" is exactly equivalent to "`not(f==g)`"

Great, thanks!

> Contrary to my expectations there were not that many doctest failures. The only affectes files were ``family.py`` and ``disjoint_union_enumerated_sets.py``.

That's definitely good news.

Should I remove the previous patch? Then we won't have to specify
which patch to apply.

A couple questions:

Would there be a problem to just compare the functions with:

```
   self.function == other.function
```
Rather than doing the check for is and then for eq?

I am surprised about your comment about Permutations not being
picklable. This works for me:

```
  sage: P = Permutations(3) 
  sage: P == Permutations(3)
  True
  sage: P == loads(dumps(P))
  True
```

Could the hash be calculated using both the hash of the indexing set
and the function?

Please take the occasion to rewrite `WARNING` into
`.. WARNING::` (see the developers manual for the exact syntax).

Where is ``!=`` implemented?


Cheers,
                          Nicolas



---

archive/issue_comments_162818.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\n> Should I remove the previous patch? Then we won't have to specify\n> which patch to apply.\n\nYes, please! I would do it myself if I knew how to do it ;-)\n\n> A couple questions:\n> \n> Would there be a problem to just compare the functions with:\n> \n> ```\n>    self.function == other.function\n> ```\n> Rather than doing the check for is and then for eq?\n\nNo problem, that's definitly better.\n\n> I am surprised about your comment about Permutations not being\n> picklable. This works for me:\n> \n> ```\n>   sage: P = Permutations(3) \n>   sage: P == Permutations(3)\n>   True\n>   sage: P == loads(dumps(P))\n>   True\n> ```\n\nThis is really an issue with `sage.misc.fpickle`: the function \"``n -> Permutations(n)``\" can be pickled, but the unpickled version has forgotten the default value of the second argument of `Permutations(n,k)`:\n\n```python\n   sage: f = Permutations \n   sage: from sage.misc.fpickle import pickle_function, unpickle_function \n   sage: g = unpickle_function(pickle_function(f)) \n   sage: print f(5) \n   Standard permutations of 5\n   sage: print g(5) \n   Traceback (most recent call last):\n   ...\n   TypeError: Permutations() takes exactly 2 arguments (1 given)\n```\n\n> Could the hash be calculated using both the hash of the indexing set\n> and the function?\n\nI'm now using the sum of both hashes.\n\n> Please take the occasion to rewrite `WARNING` into\n> `.. WARNING::` (see the developers manual for the exact syntax).\n\nFixed.\n\n> Where is ``!=`` implemented?\n\nThat's a good question: ``grep`` could find a handful of `__ne__` in the Sage code base, but none that would be a candidate for `LazyFamily.__ne__`. The python manual clearly says that one should define `__ne__` if `__eq__` is defined; that appears not to be the case in class `SageObject`, so my guess is that Python is using a default implementation.\n\nBy the way, both `Parent` and `SageObject` seem to test the consistency of `__eq__` and `__ne__` in the test suite.\n\nCheers,\\\\\nChristian",
    "created_at": "2012-12-15T09:23:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162818",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:18" align="right">comment:18</div>

> Should I remove the previous patch? Then we won't have to specify
> which patch to apply.

Yes, please! I would do it myself if I knew how to do it ;-)

> A couple questions:
> 
> Would there be a problem to just compare the functions with:
> 
> ```
>    self.function == other.function
> ```
> Rather than doing the check for is and then for eq?

No problem, that's definitly better.

> I am surprised about your comment about Permutations not being
> picklable. This works for me:
> 
> ```
>   sage: P = Permutations(3) 
>   sage: P == Permutations(3)
>   True
>   sage: P == loads(dumps(P))
>   True
> ```

This is really an issue with `sage.misc.fpickle`: the function "``n -> Permutations(n)``" can be pickled, but the unpickled version has forgotten the default value of the second argument of `Permutations(n,k)`:

```python
   sage: f = Permutations 
   sage: from sage.misc.fpickle import pickle_function, unpickle_function 
   sage: g = unpickle_function(pickle_function(f)) 
   sage: print f(5) 
   Standard permutations of 5
   sage: print g(5) 
   Traceback (most recent call last):
   ...
   TypeError: Permutations() takes exactly 2 arguments (1 given)
```

> Could the hash be calculated using both the hash of the indexing set
> and the function?

I'm now using the sum of both hashes.

> Please take the occasion to rewrite `WARNING` into
> `.. WARNING::` (see the developers manual for the exact syntax).

Fixed.

> Where is ``!=`` implemented?

That's a good question: ``grep`` could find a handful of `__ne__` in the Sage code base, but none that would be a candidate for `LazyFamily.__ne__`. The python manual clearly says that one should define `__ne__` if `__eq__` is defined; that appears not to be the case in class `SageObject`, so my guess is that Python is using a default implementation.

By the way, both `Parent` and `SageObject` seem to test the consistency of `__eq__` and `__ne__` in the test suite.

Cheers,\\
Christian



---

archive/issue_comments_162819.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nHi Christian,\n\nThanks for your changes!\n\nReplying to [@cnassau](#comment:18):\n> > Should I remove the previous patch? Then we won't have to specify\n> > which patch to apply.\n\nDone.\n\n> This is really an issue with `sage.misc.fpickle`: the function \"``n -> Permutations(n)``\" can be pickled, but the unpickled version has forgotten the default value of the second argument of `Permutations(n,k)`:\n> ...\n\nI see!\n\nYes, this is definitely a misfeature with sage.misc.fpickle. It should\nbe fixed to use standard pickling when it can (e.g. for a function\ndefined in a library). And it should return something that can be\nunpickled with a plain loads. And, as mentioned in the code of family\nit should be registered to copy_reg so that it would be called\nautomatically by dumps without needing to pollute one's code (like\nfamily) with it. Would you be so kind as to open a ticket about this\nif there is not already one?\n\nIn order to separate the two issues, what about changing the failing\nexamples to use Partitions (which pickles smoothly), rather than\nmaking it more complicated with some workaround that won't be needed\nhopefully sometime soon, and is not vital for most users?\n\n> > Where is ``!=`` implemented?\n\n> \n> That's a good question: ``grep`` could find a handful of `__ne__` in the Sage code base, but none that would be a candidate for `LazyFamily.__ne__`. The python manual clearly says that one should define `__ne__` if `__eq__` is defined; that appears not to be the case in class `SageObject`, so my guess is that Python is using a default implementation.\n\nOk. Then you may want to explicitly implement `__ne__` as not `__eq__`,\njust to be sure.\n\n> By the way, both `Parent` and `SageObject` seem to test the consistency of `__eq__` and `__ne__` in the test suite.\n\nThat's good :-)\n\nCheers,\n                                Nicolas",
    "created_at": "2012-12-16T11:05:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162819",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:19" align="right">comment:19</div>

Hi Christian,

Thanks for your changes!

Replying to [@cnassau](#comment:18):
> > Should I remove the previous patch? Then we won't have to specify
> > which patch to apply.

Done.

> This is really an issue with `sage.misc.fpickle`: the function "``n -> Permutations(n)``" can be pickled, but the unpickled version has forgotten the default value of the second argument of `Permutations(n,k)`:
> ...

I see!

Yes, this is definitely a misfeature with sage.misc.fpickle. It should
be fixed to use standard pickling when it can (e.g. for a function
defined in a library). And it should return something that can be
unpickled with a plain loads. And, as mentioned in the code of family
it should be registered to copy_reg so that it would be called
automatically by dumps without needing to pollute one's code (like
family) with it. Would you be so kind as to open a ticket about this
if there is not already one?

In order to separate the two issues, what about changing the failing
examples to use Partitions (which pickles smoothly), rather than
making it more complicated with some workaround that won't be needed
hopefully sometime soon, and is not vital for most users?

> > Where is ``!=`` implemented?

> 
> That's a good question: ``grep`` could find a handful of `__ne__` in the Sage code base, but none that would be a candidate for `LazyFamily.__ne__`. The python manual clearly says that one should define `__ne__` if `__eq__` is defined; that appears not to be the case in class `SageObject`, so my guess is that Python is using a default implementation.

Ok. Then you may want to explicitly implement `__ne__` as not `__eq__`,
just to be sure.

> By the way, both `Parent` and `SageObject` seem to test the consistency of `__eq__` and `__ne__` in the test suite.

That's good :-)

Cheers,
                                Nicolas



---

archive/issue_comments_162820.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\n> In order to separate the two issues, what about changing the failing\n> examples to use Partitions (which pickles smoothly), rather than\n> making it more complicated with some workaround that won't be needed\n> hopefully sometime soon, and is not vital for most users?\n\nActually, `Partitions` doesn't really pickle very well either:\n\n   ```python\n   sage: # first attempt\n   sage: f=Family(NonNegativeIntegers(),Partitions) ; f\n   Lazy family (Partitions(i))_{i in Non negative integers}\n   sage: loads(dumps(f))\n   Traceback (most recent call last)\n   ...\n   ValueError: Cannot pickle code objects from closures\n\n   sage: # second attempt\n   sage: f=Family(NonNegativeIntegers(),lambda n:Partitions(n))\n   sage: g=loads(dumps(f))\n   sage: f[5]\n   Partitions of the integer 5\n   sage: g[5]\n   Traceback (most recent call last)\n   ...\n   NameError: global name 'Partitions' is not defined\n   ``` \n\nI can use `Simplex` for a smooth example:\n\n   ```python\n   sage: f=Family(NonNegativeIntegers(),Simplex)\n   sage: g=loads(dumps(f))\n   sage: f[5]\n   (0, 1, 2, 3, 4, 5)\n   sage: g[5]\n   (0, 1, 2, 3, 4, 5)\n   ```\n\nI'll try to prepare a new patch tomorrow.\n\nCheers, \\\\\nChristian",
    "created_at": "2012-12-16T20:39:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162820",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:20" align="right">comment:20</div>

> In order to separate the two issues, what about changing the failing
> examples to use Partitions (which pickles smoothly), rather than
> making it more complicated with some workaround that won't be needed
> hopefully sometime soon, and is not vital for most users?

Actually, `Partitions` doesn't really pickle very well either:

   ```python
   sage: # first attempt
   sage: f=Family(NonNegativeIntegers(),Partitions) ; f
   Lazy family (Partitions(i))_{i in Non negative integers}
   sage: loads(dumps(f))
   Traceback (most recent call last)
   ...
   ValueError: Cannot pickle code objects from closures

   sage: # second attempt
   sage: f=Family(NonNegativeIntegers(),lambda n:Partitions(n))
   sage: g=loads(dumps(f))
   sage: f[5]
   Partitions of the integer 5
   sage: g[5]
   Traceback (most recent call last)
   ...
   NameError: global name 'Partitions' is not defined
   ``` 

I can use `Simplex` for a smooth example:

   ```python
   sage: f=Family(NonNegativeIntegers(),Simplex)
   sage: g=loads(dumps(f))
   sage: f[5]
   (0, 1, 2, 3, 4, 5)
   sage: g[5]
   (0, 1, 2, 3, 4, 5)
   ```

I'll try to prepare a new patch tomorrow.

Cheers, \\
Christian



---

archive/issue_comments_162821.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nReplying to [@nthiery](#comment:19):\n> Would you be so kind as to open a ticket about this\n> if there is not already one?\n\nDone: this is now #13835\n\nCheers,\\\\\nChristian",
    "created_at": "2012-12-16T20:42:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162821",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:21" align="right">comment:21</div>

Replying to [@nthiery](#comment:19):
> Would you be so kind as to open a ticket about this
> if there is not already one?

Done: this is now #13835

Cheers,\\
Christian



---

archive/issue_comments_162822.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nReplying to [@cnassau](#comment:20):\n> \n> > In order to separate the two issues, what about changing the failing\n> > examples to use Partitions (which pickles smoothly), rather than\n> > making it more complicated with some workaround that won't be needed\n> > hopefully sometime soon, and is not vital for most users?\n\n> \n> Actually, `Partitions` doesn't really pickle very well either:\n\nOops, sorry; I had forgotten that Partitions was fixed, but only in\nthe Sage-Combinat queue for the moment. Simplex will do.\n\nCheers,",
    "created_at": "2012-12-16T21:37:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162822",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:22" align="right">comment:22</div>

Replying to [@cnassau](#comment:20):
> 
> > In order to separate the two issues, what about changing the failing
> > examples to use Partitions (which pickles smoothly), rather than
> > making it more complicated with some workaround that won't be needed
> > hopefully sometime soon, and is not vital for most users?

> 
> Actually, `Partitions` doesn't really pickle very well either:

Oops, sorry; I had forgotten that Partitions was fixed, but only in
the Sage-Combinat queue for the moment. Simplex will do.

Cheers,



---

archive/issue_comments_162823.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nHere's a new patch. This implements a `__ne__` on the `AbstractFamily` base class and uses `SymmetricGroups` in place of `Permutations` in the disjoint union doctests.\n\nActually, it wasn' easy to find an example of a Family where the pickling tests worked smoothly: `Simplex` failed (`Simplex(n)` is not a set), `GF` failed (elements not disjoint because of a common `0`), `Subsets` failed (same defect as the original `Partitions` example)... \n\nCheers,\\\\\nChristian",
    "created_at": "2012-12-17T18:04:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162823",
    "user": "https://github.com/cnassau"
}
```

<div id="comment:23" align="right">comment:23</div>

Here's a new patch. This implements a `__ne__` on the `AbstractFamily` base class and uses `SymmetricGroups` in place of `Permutations` in the disjoint union doctests.

Actually, it wasn' easy to find an example of a Family where the pickling tests worked smoothly: `Simplex` failed (`Simplex(n)` is not a set), `GF` failed (elements not disjoint because of a common `0`), `Subsets` failed (same defect as the original `Partitions` example)... 

Cheers,\\
Christian



---

archive/issue_comments_162824.json:
```json
{
    "body": "Attachment: **[trac13814_cna.patch.gz](https://github.com/sagemath/sage/files/ticket13814/trac13814_cna.patch.gz)**",
    "created_at": "2013-01-26T12:06:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162824",
    "user": "https://github.com/cnassau"
}
```

Attachment: **[trac13814_cna.patch.gz](https://github.com/sagemath/sage/files/ticket13814/trac13814_cna.patch.gz)**



---

archive/issue_events_191962.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-5.11",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191962"
}
```



---

archive/issue_events_191963.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191963"
}
```



---

archive/issue_comments_162825.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nneeds rebase",
    "created_at": "2013-09-15T16:35:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13814#issuecomment-162825",
    "user": "https://github.com/fchapoton"
}
```

<div id="comment:25" align="right">comment:25</div>

needs rebase



---

archive/issue_events_191964.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2013-09-15T16:35:08Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191964"
}
```



---

archive/issue_events_191965.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2013-09-15T16:35:08Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191965"
}
```



---

archive/issue_events_191966.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-6.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191966"
}
```



---

archive/issue_events_191967.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191967"
}
```



---

archive/issue_events_191968.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191968"
}
```



---

archive/issue_events_191969.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191969"
}
```



---

archive/issue_events_191970.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191970"
}
```



---

archive/issue_events_191971.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191971"
}
```



---

archive/issue_events_191972.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-12-29T01:28:25Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/13814",
    "milestone_number": null,
    "milestone_title": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13814#event-191972"
}
```
