# Issue 13811: Meta-ticket: Support Python's __copy__ / __deepcopy__ protocol

archive/issues_013607.json:
```json
{
    "body": "Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n\n```\nsage: a = 0\nsage: copy(a) is a\nFalse\n```\n\n\nAnother symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n\n  {{{\n     sage: def unpicklableFamily():\n...       x = 10\n...       return LazyFamily([1,2,3], lambda n: x*n)\n     sage: f = unpicklableFamily() \n     sage: copy(f)\n     Traceback (most recent call last):\n     ...\n     ValueError: Cannot pickle code objects from closures\n  }}}\n\nThe case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.\n\nTickets: \n- #32454 trivial `__copy__` and `__deepcopy__` methods for number types\n- #32478 trivial `__copy__` and `__deepcopy__` methods for number field elements\n- #32480 trivial `__copy__` and `__deepcopy__` methods for symbolic expressions and functions\n- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`\n- #32453 `__copy__` methods for all classes that define `copy` methods\n- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods\n- #23075 `copy(CombinatorialFreeModule.Element)` broken by #22632\n- #5417 Fix some more deepcopy/caching issues in the quadratic forms code\nRelated:\n- #30387\n\n\nAssignee: @williamstein\n\nCC:  @tscrim @mjungmath @nbruin @kwankyu @williamstein @mwageringel @kcrisman\n\nKeywords: LazyFamily, copy, pickle\n\nAuthor: Matthias Koeppe\n\nBranch: u/mkoeppe/__copy___and___deepcopy___methods_for_all_immutable_sage_objects\n\nStatus: needs_info\n\nDependencies: #32454\n\nCommit: 2bd01ae26f1447cfc35d2fc1901413baab43819d\n\nIssue created by migration from https://trac.sagemath.org/ticket/13811\n\n",
    "created_at": "2012-12-08T12:49:43Z",
    "labels": [
        "component: pickling",
        "critical",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Meta-ticket: Support Python's __copy__ / __deepcopy__ protocol",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13811",
    "user": "https://github.com/cnassau"
}
```
Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).

```
sage: a = 0
sage: copy(a) is a
False
```


Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:

  {{{
     sage: def unpicklableFamily():
...       x = 10
...       return LazyFamily([1,2,3], lambda n: x*n)
     sage: f = unpicklableFamily() 
     sage: copy(f)
     Traceback (most recent call last):
     ...
     ValueError: Cannot pickle code objects from closures
  }}}

The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.

Tickets: 
- #32454 trivial `__copy__` and `__deepcopy__` methods for number types
- #32478 trivial `__copy__` and `__deepcopy__` methods for number field elements
- #32480 trivial `__copy__` and `__deepcopy__` methods for symbolic expressions and functions
- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`
- #32453 `__copy__` methods for all classes that define `copy` methods
- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods
- #23075 `copy(CombinatorialFreeModule.Element)` broken by #22632
- #5417 Fix some more deepcopy/caching issues in the quadratic forms code
Related:
- #30387


Assignee: @williamstein

CC:  @tscrim @mjungmath @nbruin @kwankyu @williamstein @mwageringel @kcrisman

Keywords: LazyFamily, copy, pickle

Author: Matthias Koeppe

Branch: u/mkoeppe/__copy___and___deepcopy___methods_for_all_immutable_sage_objects

Status: needs_info

Dependencies: #32454

Commit: 2bd01ae26f1447cfc35d2fc1901413baab43819d

Issue created by migration from https://trac.sagemath.org/ticket/13811





---

archive/issue_comments_179287.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2012-12-08T14:11:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179287",
    "user": "https://github.com/cnassau"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_179288.json:
```json
{
    "body": "<a id='comment:4'></a>Hi Christian!\n\nFamilies are (semantically) immutable objects. Why would we want to copy them?\n\nCheers,\n                                   Nicolas",
    "created_at": "2012-12-13T09:16:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179288",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:4'></a>Hi Christian!

Families are (semantically) immutable objects. Why would we want to copy them?

Cheers,
                                   Nicolas



---

archive/issue_comments_179289.json:
```json
{
    "body": "<a id='comment:5'></a>Replying to [comment:4 nthiery]:\n>     Hi Christian!\n\n> \n> Families are (semantically) immutable objects. Why would we want to copy them?\n\n\nGood point... I stumbled across this issue while I was struggling to create a disjoint union of a dynamically generated family of `LazyFamily` objects, while the *real* problem was that I was using closures with reference to a loop variable. I eventually resolved this issue, and my solution does not requiry any copies now. So I agree that there's no need to create shallow copies.\n\nI **do** think that user code can expect that `copy(any_sage_object)` does not throw an error. Maybe `LazyFamily.__copy__(self)` should just return `self`? This would be in accordance with\n\n   {{{\n   sage: copy(Integers()) is Integers()\n   True\n   }}}\n      \nCheers,\nChristian",
    "created_at": "2012-12-13T10:17:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179289",
    "user": "https://github.com/cnassau"
}
```

<a id='comment:5'></a>Replying to [comment:4 nthiery]:
>     Hi Christian!

> 
> Families are (semantically) immutable objects. Why would we want to copy them?


Good point... I stumbled across this issue while I was struggling to create a disjoint union of a dynamically generated family of `LazyFamily` objects, while the *real* problem was that I was using closures with reference to a loop variable. I eventually resolved this issue, and my solution does not requiry any copies now. So I agree that there's no need to create shallow copies.

I **do** think that user code can expect that `copy(any_sage_object)` does not throw an error. Maybe `LazyFamily.__copy__(self)` should just return `self`? This would be in accordance with

   {{{
   sage: copy(Integers()) is Integers()
   True
   }}}
      
Cheers,
Christian



---

archive/issue_comments_179290.json:
```json
{
    "body": "<a id='comment:6'></a>Replying to [comment:5 cnassau]:\n> I **do** think that user code can expect that `copy(any_sage_object)` does not throw an error. Maybe `LazyFamily.__copy__(self)` should just return `self`? This would be in accordance with\n> \n>    {{{\n>    sage: copy(Integers()) is Integers()\n>    True\n>    }}}\n\n\nYes, it would make sense to have copy(x) return x for all immutable objects in Sage. I am not sure how to achieve this though: we do not (yet?) have a class for providing code for all immutable objects in Sage, and I would not want to force every relevant class to reimplement a trivial __copy__ method.\n\nFor the case at hand (families), maybe one could add a method Parent.__copy__ returning `self`? As far as I can tell, parents are required to be immutable anyway. But one should double check this.\n\nCheers,\n                              Nicolas",
    "created_at": "2012-12-13T10:29:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179290",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>Replying to [comment:5 cnassau]:
> I **do** think that user code can expect that `copy(any_sage_object)` does not throw an error. Maybe `LazyFamily.__copy__(self)` should just return `self`? This would be in accordance with
> 
>    {{{
>    sage: copy(Integers()) is Integers()
>    True
>    }}}


Yes, it would make sense to have copy(x) return x for all immutable objects in Sage. I am not sure how to achieve this though: we do not (yet?) have a class for providing code for all immutable objects in Sage, and I would not want to force every relevant class to reimplement a trivial __copy__ method.

For the case at hand (families), maybe one could add a method Parent.__copy__ returning `self`? As far as I can tell, parents are required to be immutable anyway. But one should double check this.

Cheers,
                              Nicolas



---

archive/issue_comments_179291.json:
```json
{
    "body": "A patch for this problem",
    "created_at": "2013-01-26T12:13:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179291",
    "user": "https://github.com/cnassau"
}
```

A patch for this problem



---

archive/issue_events_038708.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38708"
}
```



---

archive/issue_comments_179292.json:
```json
{
    "body": "<a id='comment:7'></a>Attachment [lazyfamcopy.patch](tarball://root/attachments/some-uuid/ticket13811/lazyfamcopy.patch) by @jdemeyer created at 2013-08-13 15:35:53",
    "created_at": "2013-08-13T15:35:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179292",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>Attachment [lazyfamcopy.patch](tarball://root/attachments/some-uuid/ticket13811/lazyfamcopy.patch) by @jdemeyer created at 2013-08-13 15:35:53



---

archive/issue_events_038709.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38709"
}
```



---

archive/issue_events_038710.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38710"
}
```



---

archive/issue_events_038711.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38711"
}
```



---

archive/issue_events_038712.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38712"
}
```



---

archive/issue_events_038713.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38713"
}
```



---

archive/issue_events_038714.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38714"
}
```



---

archive/issue_comments_179293.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-02-01T11:29:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179293",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_179294.json:
```json
{
    "body": "<a id='comment:11'></a>Hi,\n\nAs Nicolas suggested in [comment:6 his comnent 6], `__copy__` should be implemented as\n\n```\ndef __copy__(self):\n    return self\n```\nIt is standard Python for immutable objects\n\n```\nsage: t = (1,2,3)\nsage: copy(t) is t\nTrue\nsage: i = 1231491283r\nsage: copy(i) is i\nTrue \n```\n\nVincent",
    "created_at": "2015-02-01T11:29:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179294",
    "user": "https://github.com/videlec"
}
```

<a id='comment:11'></a>Hi,

As Nicolas suggested in [comment:6 his comnent 6], `__copy__` should be implemented as

```
def __copy__(self):
    return self
```
It is standard Python for immutable objects

```
sage: t = (1,2,3)
sage: copy(t) is t
True
sage: i = 1231491283r
sage: copy(i) is i
True 
```

Vincent



---

archive/issue_comments_179295.json:
```json
{
    "body": "Changing priority from minor to critical.",
    "created_at": "2021-09-01T01:18:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179295",
    "user": "https://github.com/mkoeppe"
}
```

Changing priority from minor to critical.



---

archive/issue_comments_179296.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,13 @@\n-Currently, copying of `LazyFamily` objects only works for families that can be pickled:\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__`, `__deepcopy__` methods (which should just return the object).\n+\n+```\n+sage: copy(0) is 0\n+False\n+```\n+\n+\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n \n   {{{\n      sage: def unpicklableFamily():\n@@ -11,7 +20,7 @@\n      ValueError: Cannot pickle code objects from closures\n   }}}\n \n-I suggest adding a `LazyFamily.__copy__` method that fixes this.\n+\n \n Comment: 1\n \n``````\n",
    "created_at": "2021-09-01T01:18:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179296",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,13 @@
-Currently, copying of `LazyFamily` objects only works for families that can be pickled:
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__`, `__deepcopy__` methods (which should just return the object).
+
+```
+sage: copy(0) is 0
+False
+```
+
+
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
 
   {{{
      sage: def unpicklableFamily():
@@ -11,7 +20,7 @@
      ValueError: Cannot pickle code objects from closures
   }}}
 
-I suggest adding a `LazyFamily.__copy__` method that fixes this.
+
 
 Comment: 1
 
``````




---

archive/issue_events_038715.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-09-01T01:18:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38715"
}
```



---

archive/issue_events_038716.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-09-01T01:18:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38716"
}
```



---

archive/issue_comments_179297.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,25 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__`, `__deepcopy__` methods (which should just return the object).\n+\n+```\n+sage: copy(0) is 0\n+False\n+```\n+\n+Related: #30387\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-01T01:23:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179297",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,25 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__`, `__deepcopy__` methods (which should just return the object).
+
+```
+sage: copy(0) is 0
+False
+```
+
+Related: #30387
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
 
 
 Comment: 1
``````




---

archive/issue_comments_179298.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,27 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n+\n+```\n+sage: copy(0) is 0\n+False\n+```\n+\n+Related: #30387\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? \n+\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-01T20:20:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179298",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,27 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).
+
+```
+sage: copy(0) is 0
+False
+```
+
+Related: #30387
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? 
+
 
 
 Comment: 1
``````




---

archive/issue_comments_179299.json:
```json
{
    "body": "<a id='comment:16'></a>Immutability of a container object implies all elements of it are also immutable. This is important for hashability. Although there is not a strict adherence to this, it can be an assumption of good input.",
    "created_at": "2021-09-01T21:07:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179299",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:16'></a>Immutability of a container object implies all elements of it are also immutable. This is important for hashability. Although there is not a strict adherence to this, it can be an assumption of good input.



---

archive/issue_comments_179300.json:
```json
{
    "body": "<a id='comment:17'></a>Well, that's certainly not true for `tuple`.",
    "created_at": "2021-09-01T21:25:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179300",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:17'></a>Well, that's certainly not true for `tuple`.



---

archive/issue_comments_179301.json:
```json
{
    "body": "<a id='comment:18'></a>Replying to [comment:16 tscrim]:\n> Immutability of a container object implies all elements of it are also immutable. This is important for hashability. Although there is not a strict adherence to this, it can be an assumption of good input. \n\n\nThat's not quite the case in python, though: tuples are \"immutable\", but you're free to put mutable objects in them. Because tuples compute their hash by incorporating the hashes of all the constituents, such tuples then fail to be hashable. From that perspective, I think it can be fairly expensive in general to determine if an object is hashable/really immutable in a generic way (concrete implementations can answer these questions much better), so it might not be such a good idea to let copy/deepcopy really depend on it. I don't see why it's important to optimize the operations anyway: if you're interested in optimizing your code, then you should probably be avoiding unnecessary copying yourself.",
    "created_at": "2021-09-01T21:25:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179301",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:18'></a>Replying to [comment:16 tscrim]:
> Immutability of a container object implies all elements of it are also immutable. This is important for hashability. Although there is not a strict adherence to this, it can be an assumption of good input. 


That's not quite the case in python, though: tuples are "immutable", but you're free to put mutable objects in them. Because tuples compute their hash by incorporating the hashes of all the constituents, such tuples then fail to be hashable. From that perspective, I think it can be fairly expensive in general to determine if an object is hashable/really immutable in a generic way (concrete implementations can answer these questions much better), so it might not be such a good idea to let copy/deepcopy really depend on it. I don't see why it's important to optimize the operations anyway: if you're interested in optimizing your code, then you should probably be avoiding unnecessary copying yourself.



---

archive/issue_comments_179302.json:
```json
{
    "body": "<a id='comment:19'></a>I think in `__deepcopy__` of an immutable container-like object, we should first call `deepcopy` for all elements; and if the copies are all identical to the source elements, then we can just return `self` instead of making a new object.  (The positive result of this test can be cached.)",
    "created_at": "2021-09-01T21:30:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179302",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:19'></a>I think in `__deepcopy__` of an immutable container-like object, we should first call `deepcopy` for all elements; and if the copies are all identical to the source elements, then we can just return `self` instead of making a new object.  (The positive result of this test can be cached.)



---

archive/issue_comments_179303.json:
```json
{
    "body": "<a id='comment:20'></a>Replying to [comment:19 mkoeppe]:\n> I think in `__deepcopy__` of an immutable container-like object, we should first call `deepcopy` for all elements; and if the copies are all identical to the source elements, then we can just return `self` instead of making a new object.  (The positive result of this test can be cached.)\n\n\nBut by then: why would you bother? You've already done the hard work. I don't think there's much benefit and you'd make the code more complex. Just make a deep copy. That's what was requested.",
    "created_at": "2021-09-01T22:45:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179303",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:20'></a>Replying to [comment:19 mkoeppe]:
> I think in `__deepcopy__` of an immutable container-like object, we should first call `deepcopy` for all elements; and if the copies are all identical to the source elements, then we can just return `self` instead of making a new object.  (The positive result of this test can be cached.)


But by then: why would you bother? You've already done the hard work. I don't think there's much benefit and you'd make the code more complex. Just make a deep copy. That's what was requested.



---

archive/issue_comments_179304.json:
```json
{
    "body": "<a id='comment:22'></a>Replying to [comment:20 nbruin]:\n> Replying to [comment:19 mkoeppe]:\n> > I think in `__deepcopy__` of an immutable container-like object, we should first call `deepcopy` for all elements; and if the copies are all identical to the source elements, then we can just return `self` instead of making a new object.  (The positive result of this test can be cached.)\n\n> \n> But by then: why would you bother? \n\n\nThe time for copying is sunk, but the memory isn't\n\n---\nNew commits:",
    "created_at": "2021-09-01T22:51:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179304",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:22'></a>Replying to [comment:20 nbruin]:
> Replying to [comment:19 mkoeppe]:
> > I think in `__deepcopy__` of an immutable container-like object, we should first call `deepcopy` for all elements; and if the copies are all identical to the source elements, then we can just return `self` instead of making a new object.  (The positive result of this test can be cached.)

> 
> But by then: why would you bother? 


The time for copying is sunk, but the memory isn't

---
New commits:



---

archive/issue_comments_179305.json:
```json
{
    "body": "<a id='comment:23'></a>Here's an implementation for two example classes. Obviously we would have to do the same for many more classes.",
    "created_at": "2021-09-01T22:52:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179305",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:23'></a>Here's an implementation for two example classes. Obviously we would have to do the same for many more classes.



---

archive/issue_comments_179306.json:
```json
{
    "body": "<a id='comment:24'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-01T22:59:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179306",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:24'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179307.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2021-09-01T23:41:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179307",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_179308.json:
```json
{
    "body": "<a id='comment:25'></a>Setting to needs review so the patchbot will run",
    "created_at": "2021-09-01T23:41:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179308",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:25'></a>Setting to needs review so the patchbot will run



---

archive/issue_comments_179309.json:
```json
{
    "body": "<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-01T23:42:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179309",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179310.json:
```json
{
    "body": "<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-02T01:30:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179310",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179311.json:
```json
{
    "body": "<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-02T01:42:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179311",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179312.json:
```json
{
    "body": "<a id='comment:29'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-02T02:05:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179312",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:29'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179313.json:
```json
{
    "body": "<a id='comment:30'></a>Missing in `sage.modules` is now only a `__deepcopy__` method for generic dense and sparse vectors.  Not sure if we may assume that ring elements are immutable (see #32450)...",
    "created_at": "2021-09-02T02:08:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179313",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:30'></a>Missing in `sage.modules` is now only a `__deepcopy__` method for generic dense and sparse vectors.  Not sure if we may assume that ring elements are immutable (see #32450)...



---

archive/issue_comments_179314.json:
```json
{
    "body": "<a id='comment:31'></a>Replying to [comment:18 nbruin]:\n> Replying to [comment:16 tscrim]:\n> > Immutability of a container object implies all elements of it are also immutable. This is important for hashability. Although there is not a strict adherence to this, it can be an assumption of good input. \n\n> \n> That's not quite the case in python, though: tuples are \"immutable\", but you're free to put mutable objects in them. Because tuples compute their hash by incorporating the hashes of all the constituents, such tuples then fail to be hashable.\n\n\nRight, that is what I was saying that there is an assumption on good input (which is something we can check when necessary).\n\n> From that perspective, I think it can be fairly expensive in general to determine if an object is hashable/really immutable in a generic way (concrete implementations can answer these questions much better), so it might not be such a good idea to let copy/deepcopy really depend on it. I don't see why it's important to optimize the operations anyway: if you're interested in optimizing your code, then you should probably be avoiding unnecessary copying yourself.\n\n\nSometimes you are using an algorithm that is designed to handle something that is designed to work with something that does mutate (say, uses `+=`) as it makes a copy to be sure to be safe. Granted, I don't think this occurs so frequently, but it is good to support this case as I don't think it adds that much more to the complexity.",
    "created_at": "2021-09-02T03:52:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179314",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:31'></a>Replying to [comment:18 nbruin]:
> Replying to [comment:16 tscrim]:
> > Immutability of a container object implies all elements of it are also immutable. This is important for hashability. Although there is not a strict adherence to this, it can be an assumption of good input. 

> 
> That's not quite the case in python, though: tuples are "immutable", but you're free to put mutable objects in them. Because tuples compute their hash by incorporating the hashes of all the constituents, such tuples then fail to be hashable.


Right, that is what I was saying that there is an assumption on good input (which is something we can check when necessary).

> From that perspective, I think it can be fairly expensive in general to determine if an object is hashable/really immutable in a generic way (concrete implementations can answer these questions much better), so it might not be such a good idea to let copy/deepcopy really depend on it. I don't see why it's important to optimize the operations anyway: if you're interested in optimizing your code, then you should probably be avoiding unnecessary copying yourself.


Sometimes you are using an algorithm that is designed to handle something that is designed to work with something that does mutate (say, uses `+=`) as it makes a copy to be sure to be safe. Granted, I don't think this occurs so frequently, but it is good to support this case as I don't think it adds that much more to the complexity.



---

archive/issue_comments_179315.json:
```json
{
    "body": "<a id='comment:32'></a>In any case, adding the `__deepcopy__` methods gives some speedup also for mutable vectors:\n\nBefore:\n\n```\nsage: %timeit deepcopy(vector(ZZ, 100000))                                                                                                                     \n396 ms \u00b1 1.67 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n```\nAfter:\n\n```\nsage: %timeit deepcopy(vector(ZZ, 100000))\n1.39 ms \u00b1 15 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n```",
    "created_at": "2021-09-02T04:46:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179315",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:32'></a>In any case, adding the `__deepcopy__` methods gives some speedup also for mutable vectors:

Before:

```
sage: %timeit deepcopy(vector(ZZ, 100000))                                                                                                                     
396 ms ± 1.67 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```
After:

```
sage: %timeit deepcopy(vector(ZZ, 100000))
1.39 ms ± 15 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
```



---

archive/issue_comments_179316.json:
```json
{
    "body": "<a id='comment:33'></a>Sage even has actual method `Integer.__copy__` that makes an actual copy! The implementation is from 15 years ago; perhaps mutable integers similar to mpz were considered at the time.",
    "created_at": "2021-09-02T05:22:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179316",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:33'></a>Sage even has actual method `Integer.__copy__` that makes an actual copy! The implementation is from 15 years ago; perhaps mutable integers similar to mpz were considered at the time.



---

archive/issue_comments_179317.json:
```json
{
    "body": "<a id='comment:34'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-02T05:31:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179317",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:34'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179318.json:
```json
{
    "body": "<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-02T05:43:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179318",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179319.json:
```json
{
    "body": "<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-02T05:54:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179319",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:36'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179320.json:
```json
{
    "body": "<a id='comment:37'></a>Making the same change to `src/sage/rings/number_field/number_field_element.pyx` gives weird errors:\n\n```\nsage -t --random-seed=0 src/sage/rings/number_field/number_field_element.pyx\n**********************************************************************\nFile \"src/sage/rings/number_field/number_field_element.pyx\", line 4193, in sage.rings.number_field.number_field_element.NumberFieldElement._matrix_over_base_morphism\nFailed example:\n    alpha._matrix_over_base_morphism(h) == alpha.matrix(QQ)\nException raised:\n    Traceback (most recent call last):\n      File \"/Users/mkoeppe/s/sage/sage-rebasing/local/lib/python3.9/site-packages/sage/doctest/forker.py\", line 718, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/Users/mkoeppe/s/sage/sage-rebasing/local/lib/python3.9/site-packages/sage/doctest/forker.py\", line 1137, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.rings.number_field.number_field_element.NumberFieldElement._matrix_over_base_morphism[3]>\", line 1, in <module>\n        alpha._matrix_over_base_morphism(h) == alpha.matrix(QQ)\n      File \"sage/rings/number_field/number_field_element.pyx\", line 4204, in sage.rings.number_field.number_field_element.NumberFieldElement._matrix_over_base_morphism (build/cythonized/sage/rings/number_field/number_field_element.cpp:34434)\n        raise ValueError(\"codomain of phi must be parent of self\")\n    ValueError: codomain of phi must be parent of self\n**********************************************************************\nFile \"src/sage/rings/number_field/number_field_element.pyx\", line 4470, in sage.rings.number_field.number_field_element.NumberFieldElement.different\nFailed example:\n    b.different(K=phi)\nExpected:\n    4*b^3\nGot:\n    4*alpha^3\n**********************************************************************\n```\nAre number field elements mutable??",
    "created_at": "2021-09-02T06:00:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179320",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:37'></a>Making the same change to `src/sage/rings/number_field/number_field_element.pyx` gives weird errors:

```
sage -t --random-seed=0 src/sage/rings/number_field/number_field_element.pyx
**********************************************************************
File "src/sage/rings/number_field/number_field_element.pyx", line 4193, in sage.rings.number_field.number_field_element.NumberFieldElement._matrix_over_base_morphism
Failed example:
    alpha._matrix_over_base_morphism(h) == alpha.matrix(QQ)
Exception raised:
    Traceback (most recent call last):
      File "/Users/mkoeppe/s/sage/sage-rebasing/local/lib/python3.9/site-packages/sage/doctest/forker.py", line 718, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Users/mkoeppe/s/sage/sage-rebasing/local/lib/python3.9/site-packages/sage/doctest/forker.py", line 1137, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.rings.number_field.number_field_element.NumberFieldElement._matrix_over_base_morphism[3]>", line 1, in <module>
        alpha._matrix_over_base_morphism(h) == alpha.matrix(QQ)
      File "sage/rings/number_field/number_field_element.pyx", line 4204, in sage.rings.number_field.number_field_element.NumberFieldElement._matrix_over_base_morphism (build/cythonized/sage/rings/number_field/number_field_element.cpp:34434)
        raise ValueError("codomain of phi must be parent of self")
    ValueError: codomain of phi must be parent of self
**********************************************************************
File "src/sage/rings/number_field/number_field_element.pyx", line 4470, in sage.rings.number_field.number_field_element.NumberFieldElement.different
Failed example:
    b.different(K=phi)
Expected:
    4*b^3
Got:
    4*alpha^3
**********************************************************************
```
Are number field elements mutable??



---

archive/issue_comments_179321.json:
```json
{
    "body": "<a id='comment:38'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-02T06:28:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179321",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:38'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179322.json:
```json
{
    "body": "<a id='comment:39'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-02T06:29:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179322",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:39'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179323.json:
```json
{
    "body": "<a id='comment:40'></a>Replying to [comment:30 mkoeppe]:\n> Missing in `sage.modules` is now only a `__deepcopy__` method for generic dense and sparse vectors.  Not sure if we may assume that ring elements are immutable (see #32450)...\n\n\nDone now in the same way as for `Sequence_generic`. In this ticket I'll not use new assumptions.",
    "created_at": "2021-09-02T06:31:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179323",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:40'></a>Replying to [comment:30 mkoeppe]:
> Missing in `sage.modules` is now only a `__deepcopy__` method for generic dense and sparse vectors.  Not sure if we may assume that ring elements are immutable (see #32450)...


Done now in the same way as for `Sequence_generic`. In this ticket I'll not use new assumptions.



---

archive/issue_comments_179324.json:
```json
{
    "body": "<a id='comment:41'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-02T06:40:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179324",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:41'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_179325.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,27 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n+\n+```\n+sage: copy(0) is 0\n+False\n+```\n+\n+Related: #30387\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.\n+\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-02T06:42:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179325",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,27 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).
+
+```
+sage: copy(0) is 0
+False
+```
+
+Related: #30387
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.
+
 
 
 Comment: 1
``````




---

archive/issue_comments_179326.json:
```json
{
    "body": "<a id='comment:43'></a>Obviously a lot of the added trivial `__copy__` and `__deepcopy__` methods could be replaced by using a mixin class; but I am not sure what it would be called or if it would be better in terms of the clarity of the code.",
    "created_at": "2021-09-02T06:44:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179326",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:43'></a>Obviously a lot of the added trivial `__copy__` and `__deepcopy__` methods could be replaced by using a mixin class; but I am not sure what it would be called or if it would be better in terms of the clarity of the code.



---

archive/issue_comments_179327.json:
```json
{
    "body": "<a id='comment:44'></a>Replying to [comment:43 mkoeppe]:\n> Obviously a lot of the added trivial `__copy__` and `__deepcopy__` methods could be replaced by using a mixin class; but I am not sure what it would be called or if it would be better in terms of the clarity of the code.\n\n\nA number of them we probably wouldn't want for the very low level classes as `cdef` classes don't allow for multiple inheritance. This might mitigate some of the utility of a mixin class.",
    "created_at": "2021-09-02T12:26:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179327",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:44'></a>Replying to [comment:43 mkoeppe]:
> Obviously a lot of the added trivial `__copy__` and `__deepcopy__` methods could be replaced by using a mixin class; but I am not sure what it would be called or if it would be better in terms of the clarity of the code.


A number of them we probably wouldn't want for the very low level classes as `cdef` classes don't allow for multiple inheritance. This might mitigate some of the utility of a mixin class.



---

archive/issue_comments_179328.json:
```json
{
    "body": "<a id='comment:45'></a>There are some doctest failures now from bad code like this in `src/sage/geometry/cone.py`:\n\n```\n                    # rays has immutable elements\n                    rays = [copy(ray) for ray in rays]\n\n                    for i, ray in enumerate(rays):\n                        rays[i][0] = pm * (ray[0].abs() + 1)\n```",
    "created_at": "2021-09-02T16:10:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179328",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:45'></a>There are some doctest failures now from bad code like this in `src/sage/geometry/cone.py`:

```
                    # rays has immutable elements
                    rays = [copy(ray) for ray in rays]

                    for i, ray in enumerate(rays):
                        rays[i][0] = pm * (ray[0].abs() + 1)
```



---

archive/issue_comments_179329.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,29 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n+\n+```\n+sage: copy(0) is 0\n+False\n+```\n+\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.\n+\n+Related: \n+- #30387\n+- #32453 `__copy__` methods for all classes the define `copy` methods\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-02T16:27:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179329",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,29 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).
+
+```
+sage: copy(0) is 0
+False
+```
+
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.
+
+Related: 
+- #30387
+- #32453 `__copy__` methods for all classes the define `copy` methods
 
 
 Comment: 1
``````




---

archive/issue_comments_179330.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2021-09-02T16:27:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179330",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_179331.json:
```json
{
    "body": "<a id='comment:48'></a>For the pattern in comment:45, with #29101 (\"Refined protocol for `_element_constructor_  `\") we would generally be able to replace `copy(ray)` by `ray.parent()(ray, mutable=True, copy=True)`; but perhaps we should define a shorthand for that.\n- #32353 proposes new methods `mutable`, `immutable` for this\n- `src/sage/combinat/constellation.py` defines `.mutable_copy`\n- `src/sage/graphs/generic_graph.py` defines `GenericGraph.copy`, which has a parameter `immutable=None`:\n- some classes have `copy` methods with optional arguments that could be extended (see also #32453) to allow `ray.copy(mutable=True)` (proposed in https://groups.google.com/g/sage-devel/c/DNrbtItMVmQ/m/BbMwM-qeAQAJ)\n\nDecision time...",
    "created_at": "2021-09-02T16:43:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179331",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:48'></a>For the pattern in comment:45, with #29101 ("Refined protocol for `_element_constructor_  `") we would generally be able to replace `copy(ray)` by `ray.parent()(ray, mutable=True, copy=True)`; but perhaps we should define a shorthand for that.
- #32353 proposes new methods `mutable`, `immutable` for this
- `src/sage/combinat/constellation.py` defines `.mutable_copy`
- `src/sage/graphs/generic_graph.py` defines `GenericGraph.copy`, which has a parameter `immutable=None`:
- some classes have `copy` methods with optional arguments that could be extended (see also #32453) to allow `ray.copy(mutable=True)` (proposed in https://groups.google.com/g/sage-devel/c/DNrbtItMVmQ/m/BbMwM-qeAQAJ)

Decision time...



---

archive/issue_comments_179332.json:
```json
{
    "body": "<a id='comment:49'></a>Replying to [comment:45 mkoeppe]:\n> There are some doctest failures now from bad code like this in `src/sage/geometry/cone.py`:\n> \n> ```\n>                     # rays has immutable elements\n>                     rays = [copy(ray) for ray in rays]\n> \n>                     for i, ray in enumerate(rays):\n>                         rays[i][0] = pm * (ray[0].abs() + 1)\n> ```\n\nThis pattern -- expecting that `ray.__copy__` (and thus `copy(ray)`) make a mutable copy of an immutable object -- appears to come from a decision made many many years ago in Sage (#111, #6522, #15132, ...). This was probably a good idea at the time, but I think it is not compatible with current Python practices.",
    "created_at": "2021-09-02T17:13:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179332",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:49'></a>Replying to [comment:45 mkoeppe]:
> There are some doctest failures now from bad code like this in `src/sage/geometry/cone.py`:
> 
> ```
>                     # rays has immutable elements
>                     rays = [copy(ray) for ray in rays]
> 
>                     for i, ray in enumerate(rays):
>                         rays[i][0] = pm * (ray[0].abs() + 1)
> ```

This pattern -- expecting that `ray.__copy__` (and thus `copy(ray)`) make a mutable copy of an immutable object -- appears to come from a decision made many many years ago in Sage (#111, #6522, #15132, ...). This was probably a good idea at the time, but I think it is not compatible with current Python practices.



---

archive/issue_comments_179333.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2021-09-02T17:29:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179333",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_179334.json:
```json
{
    "body": "<a id='comment:52'></a>> This pattern -- expecting that `ray.__copy__` (and thus `copy(ray)`) make a mutable copy of an immutable object -- appears to come from a decision made many many years ago in Sage (#111, #6522, #15132, ...). This was probably a good idea at the time, but I think it is not compatible with current Python practices.\n\n\nThat may indeed be the case.  As you say, at the time the goal was standardized *Sage* command structure, but if there is a more (modern) Pythonic way to handle this, #6522 alone shows how much gnashing of teeth surrounded some of these changes at the time, so more power to you as long as any syntax changes would be documented.  \n\nOne should also be sure that things which would \"naturally\" be seen as copyable are, but other than `Sequence` which I am not as familiar with, it seems like e.g. vectors can still be copied unless asked not to be, so seems fine to me.",
    "created_at": "2021-09-02T17:37:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179334",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:52'></a>> This pattern -- expecting that `ray.__copy__` (and thus `copy(ray)`) make a mutable copy of an immutable object -- appears to come from a decision made many many years ago in Sage (#111, #6522, #15132, ...). This was probably a good idea at the time, but I think it is not compatible with current Python practices.


That may indeed be the case.  As you say, at the time the goal was standardized *Sage* command structure, but if there is a more (modern) Pythonic way to handle this, #6522 alone shows how much gnashing of teeth surrounded some of these changes at the time, so more power to you as long as any syntax changes would be documented.  

One should also be sure that things which would "naturally" be seen as copyable are, but other than `Sequence` which I am not as familiar with, it seems like e.g. vectors can still be copied unless asked not to be, so seems fine to me.



---

archive/issue_comments_179335.json:
```json
{
    "body": "<a id='comment:53'></a>Regarding the pair of methods `v.mutable()`, `v.immutable()` proposed in #32353: `v.immutable()` is clear, of course, and shorter than `v.copy(mutable=False)`.  But I think it is unclear what `v.mutable()` is supposed to be if `v` is already mutable. Does it return a copy? Then the method's name should say so that it is obvious to users / readers of the code that mutating the result is not only allowed but also safe.\nSo a pair `v.mutable_copy()`, `v.immutable_copy()` would be fine, although I'm not sure if it's much better than `v.copy(mutable=True)`, `v.copy(mutable=False)`",
    "created_at": "2021-09-03T07:52:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179335",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:53'></a>Regarding the pair of methods `v.mutable()`, `v.immutable()` proposed in #32353: `v.immutable()` is clear, of course, and shorter than `v.copy(mutable=False)`.  But I think it is unclear what `v.mutable()` is supposed to be if `v` is already mutable. Does it return a copy? Then the method's name should say so that it is obvious to users / readers of the code that mutating the result is not only allowed but also safe.
So a pair `v.mutable_copy()`, `v.immutable_copy()` would be fine, although I'm not sure if it's much better than `v.copy(mutable=True)`, `v.copy(mutable=False)`



---

archive/issue_comments_179336.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,34 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n+\n+```\n+sage: a = 0\n+sage: copy(a) is a\n+False\n+```\n+\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.\n+\n+Tickets: \n+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types\n+- #32462 trivial __copy__ and __deepcopy__ methods for Family and Set\n+- #32453 `__copy__` methods for all classes that define `copy` methods\n+\n+Related:\n+- #30387\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-03T19:50:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179336",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,34 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).
+
+```
+sage: a = 0
+sage: copy(a) is a
+False
+```
+
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.
+
+Tickets: 
+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types
+- #32462 trivial __copy__ and __deepcopy__ methods for Family and Set
+- #32453 `__copy__` methods for all classes that define `copy` methods
+
+Related:
+- #30387
 
 
 Comment: 1
``````




---

archive/issue_comments_179337.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,34 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n+\n+```\n+sage: a = 0\n+sage: copy(a) is a\n+False\n+```\n+\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.\n+\n+Tickets: \n+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types\n+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`\n+- #32453 `__copy__` methods for all classes that define `copy` methods\n+\n+Related:\n+- #30387\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-03T19:51:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179337",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,34 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).
+
+```
+sage: a = 0
+sage: copy(a) is a
+False
+```
+
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.
+
+Tickets: 
+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types
+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`
+- #32453 `__copy__` methods for all classes that define `copy` methods
+
+Related:
+- #30387
 
 
 Comment: 1
``````




---

archive/issue_comments_179338.json:
```json
{
    "body": "<a id='comment:57'></a>Some more data points on other libraries:\n- numpy's `ndarray`s (and subclasses) have a `copy` method with an optional parameter that controls the memory layout of the copy; the `__copy__` method is equivalent to one of these choices.\n- sympy defines `copy` methods but no `deepcopy`, `__copy__`, or `__deepcopy__` methods",
    "created_at": "2021-09-04T02:09:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179338",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:57'></a>Some more data points on other libraries:
- numpy's `ndarray`s (and subclasses) have a `copy` method with an optional parameter that controls the memory layout of the copy; the `__copy__` method is equivalent to one of these choices.
- sympy defines `copy` methods but no `deepcopy`, `__copy__`, or `__deepcopy__` methods



---

archive/issue_comments_179339.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,35 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n+\n+```\n+sage: a = 0\n+sage: copy(a) is a\n+False\n+```\n+\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.\n+\n+Tickets: \n+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types\n+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`\n+- #32453 `__copy__` methods for all classes that define `copy` methods\n+- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods\n+\n+Related:\n+- #30387\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-05T18:29:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179339",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,35 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).
+
+```
+sage: a = 0
+sage: copy(a) is a
+False
+```
+
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.
+
+Tickets: 
+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types
+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`
+- #32453 `__copy__` methods for all classes that define `copy` methods
+- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods
+
+Related:
+- #30387
 
 
 Comment: 1
``````




---

archive/issue_comments_179340.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,36 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n+\n+```\n+sage: a = 0\n+sage: copy(a) is a\n+False\n+```\n+\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.\n+\n+Tickets: \n+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types\n+- #32478 trivial `__copy__` and `__deepcopy__` methods for number field elements\n+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`\n+- #32453 `__copy__` methods for all classes that define `copy` methods\n+- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods\n+\n+Related:\n+- #30387\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-05T23:07:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179340",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,36 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).
+
+```
+sage: a = 0
+sage: copy(a) is a
+False
+```
+
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.
+
+Tickets: 
+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types
+- #32478 trivial `__copy__` and `__deepcopy__` methods for number field elements
+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`
+- #32453 `__copy__` methods for all classes that define `copy` methods
+- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods
+
+Related:
+- #30387
 
 
 Comment: 1
``````




---

archive/issue_comments_179341.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,37 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n+\n+```\n+sage: a = 0\n+sage: copy(a) is a\n+False\n+```\n+\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.\n+\n+Tickets: \n+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types\n+- #32478 trivial `__copy__` and `__deepcopy__` methods for number field elements\n+- #32480 trivial `__copy__` and `__deepcopy__` methods for symbolic expressions and functions\n+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`\n+- #32453 `__copy__` methods for all classes that define `copy` methods\n+- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods\n+\n+Related:\n+- #30387\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-06T03:37:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179341",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,37 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).
+
+```
+sage: a = 0
+sage: copy(a) is a
+False
+```
+
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.
+
+Tickets: 
+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types
+- #32478 trivial `__copy__` and `__deepcopy__` methods for number field elements
+- #32480 trivial `__copy__` and `__deepcopy__` methods for symbolic expressions and functions
+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`
+- #32453 `__copy__` methods for all classes that define `copy` methods
+- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods
+
+Related:
+- #30387
 
 
 Comment: 1
``````




---

archive/issue_comments_179342.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,38 @@\n+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).\n+\n+```\n+sage: a = 0\n+sage: copy(a) is a\n+False\n+```\n+\n+\n+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:\n+\n+  {{{\n+     sage: def unpicklableFamily():\n+...       x = 10\n+...       return LazyFamily([1,2,3], lambda n: x*n)\n+     sage: f = unpicklableFamily() \n+     sage: copy(f)\n+     Traceback (most recent call last):\n+     ...\n+     ValueError: Cannot pickle code objects from closures\n+  }}}\n+\n+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.\n+\n+Tickets: \n+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types\n+- #32478 trivial `__copy__` and `__deepcopy__` methods for number field elements\n+- #32480 trivial `__copy__` and `__deepcopy__` methods for symbolic expressions and functions\n+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`\n+- #32453 `__copy__` methods for all classes that define `copy` methods\n+- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods\n+- #23075 `copy(CombinatorialFreeModule.Element)` broken by #22632\n+- #5417 Fix some more deepcopy/caching issues in the quadratic forms code\n+Related:\n+- #30387\n \n \n Comment: 1\n``````\n",
    "created_at": "2021-09-06T05:58:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13811#issuecomment-179342",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,38 @@
+Most Sage objects are immutable. Nevertheless, `copy` and `deepcopy` make copies (through pickling/unpickling) for them because we have not provided the classes with `__copy__` methods (which should just return the object) and `__deepcopy__` methods (which in many cases should just return the object).
+
+```
+sage: a = 0
+sage: copy(a) is a
+False
+```
+
+
+Another symptom (from the original ticket description): Copying of (immutable!) `LazyFamily` objects only works for families that can be pickled:
+
+  {{{
+     sage: def unpicklableFamily():
+...       x = 10
+...       return LazyFamily([1,2,3], lambda n: x*n)
+     sage: f = unpicklableFamily() 
+     sage: copy(f)
+     Traceback (most recent call last):
+     ...
+     ValueError: Cannot pickle code objects from closures
+  }}}
+
+The case of `__deepcopy__` of immutable container-like objects (like `Family` or `Sequence`) is a bit trickier: Is immutability intended to imply that the elements are immutable too? In this ticket, we make no such assumption.
+
+Tickets: 
+- #32454 trivial `__copy__` and `__deepcopy__` methods for number types
+- #32478 trivial `__copy__` and `__deepcopy__` methods for number field elements
+- #32480 trivial `__copy__` and `__deepcopy__` methods for symbolic expressions and functions
+- #32462 trivial `__copy__` and `__deepcopy__` methods for `Family` and `Set`
+- #32453 `__copy__` methods for all classes that define `copy` methods
+- #32476 `sage.tensor`, `sage.manifolds`: `__copy__`, `__deepcopy__` methods for all classes that define `copy` methods
+- #23075 `copy(CombinatorialFreeModule.Element)` broken by #22632
+- #5417 Fix some more deepcopy/caching issues in the quadratic forms code
+Related:
+- #30387
 
 
 Comment: 1
``````




---

archive/issue_events_038717.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38717"
}
```



---

archive/issue_events_038718.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38718"
}
```



---

archive/issue_events_038719.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T00:06:20Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38719"
}
```



---

archive/issue_events_038720.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T00:06:20Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38720"
}
```



---

archive/issue_events_038721.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T05:25:02Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38721"
}
```



---

archive/issue_events_038722.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T05:25:02Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/13811",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/13811#event-38722"
}
```
