# Issue 13896: Fix cython's gc_track and gc_untrack

archive/issues_013692.json:
```json
{
    "assignees": [
        "https://github.com/rlmill"
    ],
    "body": "<div id=\"comment:0\"></div>\n\nIn a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.\n\nInstall only the new spkg at [http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg](http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg)\n\nUpstream: **Completely fixed; Fix reported upstream**\n\nCC:  @simon-king-jena @jpflori\n\nComponent: **memleak**\n\nAuthor: **Robert Bradshaw**\n\nReviewer: **Jeroen Demeyer**\n\nMerged: **sage-5.6.beta3**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/13896_\n\n",
    "closed_at": "2013-01-07T20:58:26Z",
    "created_at": "2013-01-01T18:52:39Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/memleak",
        "https://github.com/sagemath/sage/labels/p%3A%20blocker%20/%201",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-5.6",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Fix cython's gc_track and gc_untrack",
    "type": "issue",
    "updated_at": "2013-01-10T09:55:38Z",
    "url": "https://github.com/sagemath/sage/issues/13896",
    "user": "https://github.com/nbruin"
}
```
<div id="comment:0"></div>

In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.

Install only the new spkg at [http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg](http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg)

Upstream: **Completely fixed; Fix reported upstream**

CC:  @simon-king-jena @jpflori

Component: **memleak**

Author: **Robert Bradshaw**

Reviewer: **Jeroen Demeyer**

Merged: **sage-5.6.beta3**

_Issue created by migration from https://trac.sagemath.org/ticket/13896_





---

archive/issue_events_193258.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2013-01-01T18:52:39Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "milestone_number": null,
    "milestone_title": "sage-5.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193258"
}
```



---

archive/issue_events_193259.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2013-01-01T18:52:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/memleak",
    "label_color": "d73a4a",
    "label_name": "memleak",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193259"
}
```



---

archive/issue_events_193260.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2013-01-01T18:52:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193260"
}
```



---

archive/issue_events_193261.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2013-01-01T18:52:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193261"
}
```



---

archive/issue_events_193262.json:
```json
{
    "actor": "https://github.com/rlmill",
    "created_at": "2013-01-01T18:52:39Z",
    "event": "assigned",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "subject": "https://github.com/nbruin",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193262"
}
```



---

archive/issue_comments_164243.json:
```json
{
    "body": "Patch to more reliably produce crash",
    "created_at": "2013-01-01T18:53:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164243",
    "user": "https://github.com/nbruin"
}
```

Patch to more reliably produce crash



---

archive/issue_comments_164244.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nAttachment: **[double-free-crash.patch.gz](https://github.com/sagemath/sage/files/ticket13896/double-free-crash.patch.gz)**\n\nWith attached patch applied to 5.6.beta2 (and probably also other versions close to it),\n\n```\nsage -t devel/sage/sage/modules/module.pyx\n```\nwill crash relatively reliably on several machines (including `sage.math`)",
    "created_at": "2013-01-01T18:55:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164244",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:1" align="right">comment:1</div>

Attachment: **[double-free-crash.patch.gz](https://github.com/sagemath/sage/files/ticket13896/double-free-crash.patch.gz)**

With attached patch applied to 5.6.beta2 (and probably also other versions close to it),

```
sage -t devel/sage/sage/modules/module.pyx
```
will crash relatively reliably on several machines (including `sage.math`)



---

archive/issue_comments_164245.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI'd like to see this ticket as a blocker, anyone against this idea?",
    "created_at": "2013-01-02T16:48:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164245",
    "user": "https://github.com/jpflori"
}
```

<div id="comment:3" align="right">comment:3</div>

I'd like to see this ticket as a blocker, anyone against this idea?



---

archive/issue_comments_164246.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nReplying to [@jpflori](#comment%3A3):\n> I'd like to see this ticket as a blocker, anyone against this idea?\n\nSince this is the ultimate \"can generate segfaults anywhere\", it's a prime candidate for blocker status. However, we're fully at the mercy of cython developers as to when this gets fixed. Also, if we release with this bug unfixed, we might as well leave #715 in too, since this one has a much wider possible impact :-).",
    "created_at": "2013-01-02T17:34:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164246",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:4" align="right">comment:4</div>

Replying to [@jpflori](#comment%3A3):
> I'd like to see this ticket as a blocker, anyone against this idea?

Since this is the ultimate "can generate segfaults anywhere", it's a prime candidate for blocker status. However, we're fully at the mercy of cython developers as to when this gets fixed. Also, if we release with this bug unfixed, we might as well leave #715 in too, since this one has a much wider possible impact :-).



---

archive/issue_comments_164247.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nOk, Ive put it as blocker.\n\nFor those who want to play while waiting for upstream, I've posted a p0 Cython spkg which does \"something\" with PyObject_GC_[Un]Track.\nNot sure it makes any sense, but it seems to make our bug disappear.\nIt's at\nhttp://boxen.math.washington.edu/home/jpflori/cython-0.17.3.p0.spkg",
    "created_at": "2013-01-02T19:22:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164247",
    "user": "https://github.com/jpflori"
}
```

<div id="comment:5" align="right">comment:5</div>

Ok, Ive put it as blocker.

For those who want to play while waiting for upstream, I've posted a p0 Cython spkg which does "something" with PyObject_GC_[Un]Track.
Not sure it makes any sense, but it seems to make our bug disappear.
It's at
http://boxen.math.washington.edu/home/jpflori/cython-0.17.3.p0.spkg



---

archive/issue_events_193263.json:
```json
{
    "actor": "https://github.com/jpflori",
    "created_at": "2013-01-02T19:22:43Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193263"
}
```



---

archive/issue_events_193264.json:
```json
{
    "actor": "https://github.com/jpflori",
    "created_at": "2013-01-02T19:22:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20blocker%20/%201",
    "label_color": "ff0000",
    "label_name": "p: blocker / 1",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193264"
}
```



---

archive/issue_comments_164248.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1 +1 @@\n-In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.h](http://svn.python.org/projects/python/trunk/Include/object.h),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.\n+In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.\n``````\n",
    "created_at": "2013-01-02T19:42:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164248",
    "user": "https://github.com/nbruin"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1 +1 @@
-In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.h](http://svn.python.org/projects/python/trunk/Include/object.h),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.
+In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.
``````




---

archive/issue_comments_164249.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nApologies. I saw I linked to the wrong file. [Include/object.h](http://svn.python.org/projects/python/trunk/Include/object.h) also has some interesting information, but it looks like it is a bit out-of-date on some bits. In particular, if you look at the actual use of the TRASHCAN macros:\n\n```\n    PyObject_GC_UnTrack(self);\n    ++_PyTrash_delete_nesting;\n    Py_TRASHCAN_SAFE_BEGIN(self);\n    --_PyTrash_delete_nesting;\n...\n  endlabel:\n    ++_PyTrash_delete_nesting;\n    Py_TRASHCAN_SAFE_END(self);\n    --_PyTrash_delete_nesting;\n```\nwith the explanation a little lower:\n\n```\n       Q. Why the bizarre (net-zero) manipulation of\n          _PyTrash_delete_nesting around the trashcan macros?\n\n       A. Some base classes (e.g. list) also use the trashcan mechanism.\n          The following scenario used to be possible:\n\n          - suppose the trashcan level is one below the trashcan limit\n\n          - subtype_dealloc() is called\n\n          - the trashcan limit is not yet reached, so the trashcan level\n        is incremented and the code between trashcan begin and end is\n        executed\n\n          - this destroys much of the object's contents, including its\n        slots and __dict__\n\n          - basedealloc() is called; this is really list_dealloc(), or\n        some other type which also uses the trashcan macros\n\n          - the trashcan limit is now reached, so the object is put on the\n        trashcan's to-be-deleted-later list\n\n          - basedealloc() returns\n\n          - subtype_dealloc() decrefs the object's type\n\n          - subtype_dealloc() returns\n\n          - later, the trashcan code starts deleting the objects from its\n        to-be-deleted-later list\n\n          - subtype_dealloc() is called *AGAIN* for the same object\n\n          - at the very least (if the destroyed slots and __dict__ don't\n        cause problems) the object's type gets decref'ed a second\n        time, which is *BAD*!!!\n\n          The remedy is to make sure that if the code between trashcan\n          begin and end in subtype_dealloc() is called, the code between\n          trashcan begin and end in basedealloc() will also be called.\n          This is done by decrementing the level after passing into the\n          trashcan block, and incrementing it just before leaving the\n          block.\n\n          But now it's possible that a chain of objects consisting solely\n          of objects whose deallocator is subtype_dealloc() will defeat\n          the trashcan mechanism completely: the decremented level means\n          that the effective level never reaches the limit.      Therefore, we\n          *increment* the level *before* entering the trashcan block, and\n          matchingly decrement it after leaving.  This means the trashcan\n          code will trigger a little early, but that's no big deal.\n```\nIt's probably better to leave out the trashcan for now. It seems like rather tricky code and I'm not sure it's part of the official Python C-API (it might be something internal, just like they use some macros themselves they find unsafe for use in extension modules)",
    "created_at": "2013-01-02T19:42:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164249",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:6" align="right">comment:6</div>

Apologies. I saw I linked to the wrong file. [Include/object.h](http://svn.python.org/projects/python/trunk/Include/object.h) also has some interesting information, but it looks like it is a bit out-of-date on some bits. In particular, if you look at the actual use of the TRASHCAN macros:

```
    PyObject_GC_UnTrack(self);
    ++_PyTrash_delete_nesting;
    Py_TRASHCAN_SAFE_BEGIN(self);
    --_PyTrash_delete_nesting;
...
  endlabel:
    ++_PyTrash_delete_nesting;
    Py_TRASHCAN_SAFE_END(self);
    --_PyTrash_delete_nesting;
```
with the explanation a little lower:

```
       Q. Why the bizarre (net-zero) manipulation of
          _PyTrash_delete_nesting around the trashcan macros?

       A. Some base classes (e.g. list) also use the trashcan mechanism.
          The following scenario used to be possible:

          - suppose the trashcan level is one below the trashcan limit

          - subtype_dealloc() is called

          - the trashcan limit is not yet reached, so the trashcan level
        is incremented and the code between trashcan begin and end is
        executed

          - this destroys much of the object's contents, including its
        slots and __dict__

          - basedealloc() is called; this is really list_dealloc(), or
        some other type which also uses the trashcan macros

          - the trashcan limit is now reached, so the object is put on the
        trashcan's to-be-deleted-later list

          - basedealloc() returns

          - subtype_dealloc() decrefs the object's type

          - subtype_dealloc() returns

          - later, the trashcan code starts deleting the objects from its
        to-be-deleted-later list

          - subtype_dealloc() is called *AGAIN* for the same object

          - at the very least (if the destroyed slots and __dict__ don't
        cause problems) the object's type gets decref'ed a second
        time, which is *BAD*!!!

          The remedy is to make sure that if the code between trashcan
          begin and end in subtype_dealloc() is called, the code between
          trashcan begin and end in basedealloc() will also be called.
          This is done by decrementing the level after passing into the
          trashcan block, and incrementing it just before leaving the
          block.

          But now it's possible that a chain of objects consisting solely
          of objects whose deallocator is subtype_dealloc() will defeat
          the trashcan mechanism completely: the decremented level means
          that the effective level never reaches the limit.      Therefore, we
          *increment* the level *before* entering the trashcan block, and
          matchingly decrement it after leaving.  This means the trashcan
          code will trigger a little early, but that's no big deal.
```
It's probably better to leave out the trashcan for now. It seems like rather tricky code and I'm not sure it's part of the official Python C-API (it might be something internal, just like they use some macros themselves they find unsafe for use in extension modules)



---

archive/issue_comments_164250.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nI saw and read about this additional steps in addition to the macro, but I was not sure it was also needed here.\n\nAnyway I agree it is a better take to leave that out for now, and anyway, upstream will decide what is the best.\n\nSo I've updated the spkg to not include the trashcan parts.",
    "created_at": "2013-01-02T19:54:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164250",
    "user": "https://github.com/jpflori"
}
```

<div id="comment:7" align="right">comment:7</div>

I saw and read about this additional steps in addition to the macro, but I was not sure it was also needed here.

Anyway I agree it is a better take to leave that out for now, and anyway, upstream will decide what is the best.

So I've updated the spkg to not include the trashcan parts.



---

archive/issue_comments_164251.json:
```json
{
    "body": "Attachment: **[cython-0.17.3.p0.diff.gz](https://github.com/sagemath/sage/files/ticket13896/cython-0.17.3.p0.diff.gz)**",
    "created_at": "2013-01-02T19:54:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164251",
    "user": "https://github.com/jpflori"
}
```

Attachment: **[cython-0.17.3.p0.diff.gz](https://github.com/sagemath/sage/files/ticket13896/cython-0.17.3.p0.diff.gz)**



---

archive/issue_comments_164252.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nReplying to [@jpflori](#comment%3A7):\n> I saw and read about this additional steps in addition to the macro, but I was not sure it was also needed here.\n\nIn fact, I think the precautions taken are *not enough* for general cython classes. With the little\n\n```\n    ++_PyTrash_delete_nesting;\n    Py_TRASHCAN_SAFE_BEGIN(self);\n    --_PyTrash_delete_nesting;\n    ...\n    ++_PyTrash_delete_nesting;\n    Py_TRASHCAN_SAFE_END(self);\n    --_PyTrash_delete_nesting;\n```\ndance they are making sure there is room for *one* extra trashcan nesting *provided that that call doesn't use the same trick*. However, a cython class could have a whole inheritance hierarchy going here (that would all use this trick too!), so I'm pretty sure that the exact scenario they describe could still happen. You'd need to know the depth of the inheritance line (for deallocs, multiple inheritance can't happen, right?) and ensure there's enough room for all those.",
    "created_at": "2013-01-02T21:39:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164252",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:8" align="right">comment:8</div>

Replying to [@jpflori](#comment%3A7):
> I saw and read about this additional steps in addition to the macro, but I was not sure it was also needed here.

In fact, I think the precautions taken are *not enough* for general cython classes. With the little

```
    ++_PyTrash_delete_nesting;
    Py_TRASHCAN_SAFE_BEGIN(self);
    --_PyTrash_delete_nesting;
    ...
    ++_PyTrash_delete_nesting;
    Py_TRASHCAN_SAFE_END(self);
    --_PyTrash_delete_nesting;
```
dance they are making sure there is room for *one* extra trashcan nesting *provided that that call doesn't use the same trick*. However, a cython class could have a whole inheritance hierarchy going here (that would all use this trick too!), so I'm pretty sure that the exact scenario they describe could still happen. You'd need to know the depth of the inheritance line (for deallocs, multiple inheritance can't happen, right?) and ensure there's enough room for all those.



---

archive/issue_comments_164253.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nhttps://github.com/cython/cython/commit/9a08ff23544ac9afd8392715c660898e1f3a762f\n\nComing up with a nice clean test was...interesting.",
    "created_at": "2013-01-02T22:24:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164253",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:9" align="right">comment:9</div>

https://github.com/cython/cython/commit/9a08ff23544ac9afd8392715c660898e1f3a762f

Coming up with a nice clean test was...interesting.



---

archive/issue_comments_164254.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nJust one potentially naive question:\nshouldn't the object get retracked iff you're going to call another dealloc method?\nor conversely, if the type does not extend a previous type, shouldn't the object stay untracked when you call tp_free?\nI'm not sure it would really matter if the object is still tracked in this latter case, but I got this feeling when staring at CPython's code today.\n\nAnyway, it just made me think of what will happen if your extension class is GC tracked, but the base class is not? In this case you're lost because if you track your object before calling the base dealloc, then you will not untrack it there. Is that even possible? And anyway if a class is not gc tracked, or is not a container I guess it cannot be weakrefed...",
    "created_at": "2013-01-02T22:31:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164254",
    "user": "https://github.com/jpflori"
}
```

<div id="comment:10" align="right">comment:10</div>

Just one potentially naive question:
shouldn't the object get retracked iff you're going to call another dealloc method?
or conversely, if the type does not extend a previous type, shouldn't the object stay untracked when you call tp_free?
I'm not sure it would really matter if the object is still tracked in this latter case, but I got this feeling when staring at CPython's code today.

Anyway, it just made me think of what will happen if your extension class is GC tracked, but the base class is not? In this case you're lost because if you track your object before calling the base dealloc, then you will not untrack it there. Is that even possible? And anyway if a class is not gc tracked, or is not a container I guess it cannot be weakrefed...



---

archive/issue_comments_164255.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nThe final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.",
    "created_at": "2013-01-02T22:47:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164255",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:11" align="right">comment:11</div>

The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.



---

archive/issue_comments_164256.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nThanks for pointing that out.",
    "created_at": "2013-01-02T23:03:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164256",
    "user": "https://github.com/jpflori"
}
```

<div id="comment:12" align="right">comment:12</div>

Thanks for pointing that out.



---

archive/issue_comments_164257.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nSpkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4pre.spkg , if this looks good I'll cut a release and make an actual spkg based on that.",
    "created_at": "2013-01-03T05:06:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164257",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:13" align="right">comment:13</div>

Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4pre.spkg , if this looks good I'll cut a release and make an actual spkg based on that.



---

archive/issue_comments_164258.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\ntrashcan issues now tracked on #13901 (yes, you can easily crash cython because it's not using the trashcan)",
    "created_at": "2013-01-03T07:32:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164258",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:14" align="right">comment:14</div>

trashcan issues now tracked on #13901 (yes, you can easily crash cython because it's not using the trashcan)



---

archive/issue_comments_164259.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nReplying to [@robertwb](#comment%3A13):\n> Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4pre.spkg , if this looks good I'll cut a release and make an actual spkg based on that.\n\nThis does look good to me. JP has already confirmed that this fixed the issue (as does your elegant test in the cython suite). Your pre.spkg has some different files in it, but I guess that's why you don't consider it an actual spkg.",
    "created_at": "2013-01-03T07:48:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164259",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:15" align="right">comment:15</div>

Replying to [@robertwb](#comment%3A13):
> Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4pre.spkg , if this looks good I'll cut a release and make an actual spkg based on that.

This does look good to me. JP has already confirmed that this fixed the issue (as does your elegant test in the cython suite). Your pre.spkg has some different files in it, but I guess that's why you don't consider it an actual spkg.



---

archive/issue_comments_164260.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nReplying to [@robertwb](#comment%3A11):\n> The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.\n\nSorry to insist a little bit, but while looking at the trashcan stuff, I thought again about it and in fact what I was worried about was rather the converse.\n\nIf the base type does not have the GC_FLAG, and youve retracked it in the subclass, then final tp_free will indeed not touch anything related to gc, but won't that leave an invalid object in the gc tracked object list?\nIn particular won't a call to gc_list_remove(o) be missing?",
    "created_at": "2013-01-03T12:39:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164260",
    "user": "https://github.com/jpflori"
}
```

<div id="comment:16" align="right">comment:16</div>

Replying to [@robertwb](#comment%3A11):
> The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.

Sorry to insist a little bit, but while looking at the trashcan stuff, I thought again about it and in fact what I was worried about was rather the converse.

If the base type does not have the GC_FLAG, and youve retracked it in the subclass, then final tp_free will indeed not touch anything related to gc, but won't that leave an invalid object in the gc tracked object list?
In particular won't a call to gc_list_remove(o) be missing?



---

archive/issue_comments_164261.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nReplying to [@jpflori](#comment%3A16):\n> Replying to [@robertwb](#comment%3A11):\n> > The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.\n> \n> Sorry to insist a little bit, but while looking at the trashcan stuff, I thought again about it and in fact what I was worried about was rather the converse.\n> \n> If the base type does not have the GC_FLAG, and youve retracked it in the subclass, then final tp_free will indeed not touch anything related to gc, but won't that leave an invalid object in the gc tracked object list?\n> In particular won't a call to gc_list_remove(o) be missing?\n\nThe base tp_free looks at the actual type's flags (which will have GC_FLAG set) to determine what gc (un)tracking to do. Any intermediate superclasses will either leave this alone or do the untrack/track dance.",
    "created_at": "2013-01-03T17:19:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164261",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:17" align="right">comment:17</div>

Replying to [@jpflori](#comment%3A16):
> Replying to [@robertwb](#comment%3A11):
> > The final call to the (generic) tp_free calls PyObject_GC_Untrack iff the GC flags are set in the type flags.  If the base class is not GC tracked then its dealloc method won't touch these bits.
> 
> Sorry to insist a little bit, but while looking at the trashcan stuff, I thought again about it and in fact what I was worried about was rather the converse.
> 
> If the base type does not have the GC_FLAG, and youve retracked it in the subclass, then final tp_free will indeed not touch anything related to gc, but won't that leave an invalid object in the gc tracked object list?
> In particular won't a call to gc_list_remove(o) be missing?

The base tp_free looks at the actual type's flags (which will have GC_FLAG set) to determine what gc (un)tracking to do. Any intermediate superclasses will either leave this alone or do the untrack/track dance.



---

archive/issue_comments_164262.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nReplying to [@nbruin](#comment%3A14):\n> trashcan issues now tracked on #13901 (yes, you can easily crash cython because it's not using the trashcan)\n\nYeah, this is a separate (and more complicated to resolve) issue.",
    "created_at": "2013-01-03T17:22:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164262",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:18" align="right">comment:18</div>

Replying to [@nbruin](#comment%3A14):
> trashcan issues now tracked on #13901 (yes, you can easily crash cython because it's not using the trashcan)

Yeah, this is a separate (and more complicated to resolve) issue.



---

archive/issue_comments_164263.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nReplying to [@robertwb](#comment%3A17):\n> The base tp_free looks at the actual type's flags (which will have GC_FLAG set) to determine what gc (un)tracking to do. Any intermediate superclasses will either leave this alone or do the untrack/track dance. \n\n... so suppose we have a superclass that doesn't do the untrack/track dance (so this must be a non-container superclass of a container class. We're entering rather hypothetical territory here). We'll be entering its dealloc with tracking SET. I guess the actual memory free happens by our class, so I guess the list of GC-tracked objects will be properly amended eventually. Can we prove that no GC or trashcan-shelving of this intermediate object will happen in between? I guess it's unlikely because non-container types should be easy to deallocate ... unless some callous person writes an extension class that does hold references to other objects but is convinced that those will never lead to cycles and hence makes it non-GC-tracked. Some weakref callbacks and a GC could then find a partially torn down object tracked by the GC. Multithreaded stuff could make this even worse, but I guess we're protected by the GIL here.\n\nIt should probably be mandated that *any* container type *has to* participate in GC. For a non-container type it's hard to see how a dealloc could ever be interrupted or interleaved by a GC. So this note is probably more a request for clarification (addition to documentation somewhere?) why this is not a problem than a diagnosis of a bug.",
    "created_at": "2013-01-03T17:52:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164263",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:19" align="right">comment:19</div>

Replying to [@robertwb](#comment%3A17):
> The base tp_free looks at the actual type's flags (which will have GC_FLAG set) to determine what gc (un)tracking to do. Any intermediate superclasses will either leave this alone or do the untrack/track dance. 

... so suppose we have a superclass that doesn't do the untrack/track dance (so this must be a non-container superclass of a container class. We're entering rather hypothetical territory here). We'll be entering its dealloc with tracking SET. I guess the actual memory free happens by our class, so I guess the list of GC-tracked objects will be properly amended eventually. Can we prove that no GC or trashcan-shelving of this intermediate object will happen in between? I guess it's unlikely because non-container types should be easy to deallocate ... unless some callous person writes an extension class that does hold references to other objects but is convinced that those will never lead to cycles and hence makes it non-GC-tracked. Some weakref callbacks and a GC could then find a partially torn down object tracked by the GC. Multithreaded stuff could make this even worse, but I guess we're protected by the GIL here.

It should probably be mandated that *any* container type *has to* participate in GC. For a non-container type it's hard to see how a dealloc could ever be interrupted or interleaved by a GC. So this note is probably more a request for clarification (addition to documentation somewhere?) why this is not a problem than a diagnosis of a bug.



---

archive/issue_comments_164264.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nI think it helps to look at the generated code. Suppose one has\n\n```\ncdef class A: ...\ncdef class B(A): ...\ncdef class C(B): ...\n...\n```\n\nIn this case one has, roughly, \n\n```\ntp_dealloc_A(self) {\n   [optional untrack]\n   bodyA\n   [optional track]\n   PY_TYPE(self)->tp_free(self)\n}\n\ntp_dealloc_B(self) {\n   [optional untrack]\n   bodyB\n   [optional track]\n   tp_dealloc_A(self)\n}\n\ntp_dealloc_C(self) {\n   [optional untrack]\n   bodyC\n   [optional track]\n   tp_dealloc_B(self)\n}\n\n...\n\n```\n\nbodyX consists of decrefing Python members, traversing weakrefs, and (if present)\n\n```\nPyRef(self)++;\nX.__dealloc__(self);\nPyRef(self)--;\n```\n\nThe track/untrack markers are added exactly when Python/weakref members are present, which is where a garbage collection might happen.  (When executing `__dealloc__` the refcount is incremented, also preventing garbage collection.)\n\nWhat could be an issue is a non-gc-tracked container class that is subclassed by a gc-tracked class, but we don't have those in Cython.",
    "created_at": "2013-01-03T19:05:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164264",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:20" align="right">comment:20</div>

I think it helps to look at the generated code. Suppose one has

```
cdef class A: ...
cdef class B(A): ...
cdef class C(B): ...
...
```

In this case one has, roughly, 

```
tp_dealloc_A(self) {
   [optional untrack]
   bodyA
   [optional track]
   PY_TYPE(self)->tp_free(self)
}

tp_dealloc_B(self) {
   [optional untrack]
   bodyB
   [optional track]
   tp_dealloc_A(self)
}

tp_dealloc_C(self) {
   [optional untrack]
   bodyC
   [optional track]
   tp_dealloc_B(self)
}

...

```

bodyX consists of decrefing Python members, traversing weakrefs, and (if present)

```
PyRef(self)++;
X.__dealloc__(self);
PyRef(self)--;
```

The track/untrack markers are added exactly when Python/weakref members are present, which is where a garbage collection might happen.  (When executing `__dealloc__` the refcount is incremented, also preventing garbage collection.)

What could be an issue is a non-gc-tracked container class that is subclassed by a gc-tracked class, but we don't have those in Cython.



---

archive/issue_comments_164265.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\n> \n> What could be an issue is a non-gc-tracked container class that is subclassed by a gc-tracked class, but we don't have those in Cython. \n\nThat is exactly what I was thinking about, and IIRC what is looked for in the CPython subtype_dealloc when looking for the base type.\n\nIf you say it cannot happy in Cython, I'm very happy with that!",
    "created_at": "2013-01-03T19:13:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164265",
    "user": "https://github.com/jpflori"
}
```

<div id="comment:21" align="right">comment:21</div>

> 
> What could be an issue is a non-gc-tracked container class that is subclassed by a gc-tracked class, but we don't have those in Cython. 

That is exactly what I was thinking about, and IIRC what is looked for in the CPython subtype_dealloc when looking for the base type.

If you say it cannot happy in Cython, I'm very happy with that!



---

archive/issue_comments_164266.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nAre you sure this is the case, e.g., for category_object and sage_object?\nI see a TPFLAGS_HAVE_GC on the former but not on the latter.",
    "created_at": "2013-01-03T20:35:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164266",
    "user": "https://github.com/jpflori"
}
```

<div id="comment:22" align="right">comment:22</div>

Are you sure this is the case, e.g., for category_object and sage_object?
I see a TPFLAGS_HAVE_GC on the former but not on the latter.



---

archive/issue_comments_164267.json:
```json
{
    "body": "Robert's cython test case (I spent quite some time twice to find it, so I'm storing it here for future reference)",
    "created_at": "2013-01-03T21:09:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164267",
    "user": "https://github.com/nbruin"
}
```

Robert's cython test case (I spent quite some time twice to find it, so I'm storing it here for future reference)



---

archive/issue_comments_164268.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nAttachment: **[double_dealloc_T796.pyx.gz](https://github.com/sagemath/sage/files/ticket13896/double_dealloc_T796.pyx.gz)**\n\nAnd Robert just released Cython 0.17.4, see https://groups.google.com/d/topic/cython-users/s3ycj83Yctw/discussion",
    "created_at": "2013-01-03T21:21:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164268",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:23" align="right">comment:23</div>

Attachment: **[double_dealloc_T796.pyx.gz](https://github.com/sagemath/sage/files/ticket13896/double_dealloc_T796.pyx.gz)**

And Robert just released Cython 0.17.4, see https://groups.google.com/d/topic/cython-users/s3ycj83Yctw/discussion



---

archive/issue_events_193265.json:
```json
{
    "actor": "https://github.com/robertwb",
    "created_at": "2013-01-03T21:47:45Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193265"
}
```



---

archive/issue_comments_164269.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1 +1,3 @@\n In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.\n+\n+Install only the new spkg at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4.spkg\n``````\n",
    "created_at": "2013-01-03T21:47:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164269",
    "user": "https://github.com/robertwb"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1 +1,3 @@
 In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.
+
+Install only the new spkg at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4.spkg
``````




---

archive/issue_comments_164270.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nSpkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4.spkg",
    "created_at": "2013-01-03T21:47:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164270",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:24" align="right">comment:24</div>

Spkg up at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4.spkg



---

archive/issue_events_193266.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-01-04T09:38:34Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193266"
}
```



---

archive/issue_events_193267.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-01-04T09:38:34Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193267"
}
```



---

archive/issue_comments_164271.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nTypo in the version number:\n\n```\n=== cython-0.17.3 (Robert Bradshaw, 3 January 2013) ===\n```\nshould be\n\n```\n=== cython-0.17.4 (Robert Bradshaw, 3 January 2013) ===\n```",
    "created_at": "2013-01-04T09:38:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164271",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:25" align="right">comment:25</div>

Typo in the version number:

```
=== cython-0.17.3 (Robert Bradshaw, 3 January 2013) ===
```
should be

```
=== cython-0.17.4 (Robert Bradshaw, 3 January 2013) ===
```



---

archive/issue_comments_164272.json:
```json
{
    "body": "Author: **Robert Bradshaw**",
    "created_at": "2013-01-04T09:38:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164272",
    "user": "https://github.com/jdemeyer"
}
```

Author: **Robert Bradshaw**



---

archive/issue_events_193268.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-01-04T12:57:52Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193268"
}
```



---

archive/issue_events_193269.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-01-04T12:57:52Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193269"
}
```



---

archive/issue_comments_164273.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,3 @@\n In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.\n \n-Install only the new spkg at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4.spkg\n+Install only the new spkg at [http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg](http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg)\n``````\n",
    "created_at": "2013-01-04T12:57:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164273",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,3 @@
 In a long sage-devel thread we eventually found [in this message](https://groups.google.com/group/sage-devel/msg/1d05a46b9b5fa8e2?hl=en) that a GC during a weakref callback on a Cython class can lead to double deallocation of that class. In Python's [Objects/typeobject.c](http://svn.python.org/projects/python/trunk/Objects/typeobject.c),  line 1024 and onwards, there are some comments that indicate that earlier version of Python were bitten by this problem too. The solution is to insert the appropriate `PyObject_GC_Untrack` and `PyObject_GC_Track` in cython's deallocation code. This is best fixed in cython itself.
 
-Install only the new spkg at http://sage.math.washington.edu/home/robertwb/patches/cython-0.17.4.spkg
+Install only the new spkg at [http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg](http://boxen.math.washington.edu/home/jdemeyer/spkg/cython-0.17.4.spkg)
``````




---

archive/issue_comments_164274.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nFixed `SPKG.txt`.",
    "created_at": "2013-01-04T12:57:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164274",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:26" align="right">comment:26</div>

Fixed `SPKG.txt`.



---

archive/issue_comments_164275.json:
```json
{
    "body": "Reviewer: **Jeroen Demeyer**",
    "created_at": "2013-01-04T12:57:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164275",
    "user": "https://github.com/jdemeyer"
}
```

Reviewer: **Jeroen Demeyer**



---

archive/issue_comments_164276.json:
```json
{
    "body": "Changed upstream from **Reported upstream. Developers acknowledge bug.** to **Completely fixed; Fix reported upstream**",
    "created_at": "2013-01-04T13:00:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164276",
    "user": "https://github.com/jdemeyer"
}
```

Changed upstream from **Reported upstream. Developers acknowledge bug.** to **Completely fixed; Fix reported upstream**



---

archive/issue_comments_164277.json:
```json
{
    "body": "<div id=\"comment:28\" align=\"right\">comment:28</div>\n\nD'oh. Thanks.",
    "created_at": "2013-01-04T18:26:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164277",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:28" align="right">comment:28</div>

D'oh. Thanks.



---

archive/issue_comments_164278.json:
```json
{
    "body": "Merged: **sage-5.6.beta3**",
    "created_at": "2013-01-07T20:58:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164278",
    "user": "https://github.com/jdemeyer"
}
```

Merged: **sage-5.6.beta3**



---

archive/issue_events_193270.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-01-07T20:58:26Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193270"
}
```



---

archive/issue_events_193271.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-01-07T20:58:26Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/13896#event-193271"
}
```



---

archive/issue_comments_164279.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nI have not seen anymore segmentation faults regarding #715, so this might have fixed it.",
    "created_at": "2013-01-10T09:42:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164279",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:30" align="right">comment:30</div>

I have not seen anymore segmentation faults regarding #715, so this might have fixed it.



---

archive/issue_comments_164280.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">comment:31</div>\n\nYay! Congratulations to everybody and a special thanks to Simon for pushing the weak caches!",
    "created_at": "2013-01-10T09:55:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/13896",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/13896#issuecomment-164280",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:31" align="right">comment:31</div>

Yay! Congratulations to everybody and a special thanks to Simon for pushing the weak caches!
