# Issue 13854: Weakly reference binary operation codomains

Issue created by migration from https://trac.sagemath.org/ticket/14058

Original creator: robertwb

Original creation time: 2013-02-05 09:51:57

Assignee: rlm

CC:  nbruin simonking jpflori

R(1) + S(1) caches a strong reference to both R and S, which we'd like to avoid. 

See discussion at https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/ozhIHIwQ4WA


---

Attachment


---

Comment by robertwb created at 2013-02-05 10:00:37

Changing status from new to needs_review.


---

Comment by SimonKing created at 2013-02-05 10:49:07

Is it possible to add an example that shows that parents become collectable that previously weren't?


---

Comment by nbruin created at 2013-02-05 17:38:12

Doctest proposal


---

Attachment

I like the idea. Can we get some data on speed regressions due to this? In principle the double lookup might be noticeable. I don't mean speed regressions due to parents getting deleted -- those are good to know but need other fixes. I mean when the parents are still around.

Attached doctests may need #12313 to work, in which case this ticket should depend on that (because then that's necessary to get benefit from this ticket).


---

Comment by nbruin created at 2013-02-05 19:54:56

Sadly, the performance hit is quite noticeable.

```
a=ZZ(1)
b=QQ(1)
c=ZZ['x'](1)
d=b+c

def test(x,y):
  for i in xrange(10^6):
    _=x+y
```

Within a run, timing `test` seems fairly consistent. However, between different compiles of the same code I'm observing fluctuations of up to `0.10s` in timings. Lucky/unlucky memory layout?
Anyway, with patch:

```
sage: %time test(a,b)
CPU times: user 2.15 s, sys: 0.00 s, total: 2.15 s
Wall time: 2.16 s
sage: %time test(a,c)
CPU times: user 2.25 s, sys: 0.00 s, total: 2.25 s
Wall time: 2.26 s
sage: %time test(b,c)
CPU times: user 16.83 s, sys: 0.00 s, total: 16.83 s
```

without patch

```
sage: %time test(a,b)
CPU times: user 1.54 s, sys: 0.00 s, total: 1.54 s
Wall time: 1.55 s
sage: %time test(a,c)
CPU times: user 1.64 s, sys: 0.00 s, total: 1.64 s
Wall time: 1.64 s
CPU times: user 15.68 s, sys: 0.00 s, total: 15.68 s
Wall time: 15.76 s
```

For `test(a,a)`, `test(b,b)`, `test(c,c)` there doesn't seem to be a difference (luckily!)

The penalties seem to be about `0.6s`, `0.6s`, `1.2s`, which is rather consistent with 1,1,2 extra lookups.

This indicates to me it may be worth trying storing a weakref to the morphism instead, since that can probably be dereferenced faster than a coercion lookup on the codomain. Logically this should be equivalent. We're just storing a weakref to the object we're interested in rather than instructions where to go and lookup the object we want.

Caveat:

For stored coercions of the type
`(R,S, ...): (None,<map S->R>)`
or
`(R,S, ...): (<map R->S>,None)`
the codomain is part of the key, so deletion of the codomain (which is a prerequisite for the morphism being deleted and hence the weakref dying) implies removal of the weak key entry in `TripleDict`.

However, for stored coercions of the type
`(R,S,...): (<map R->C>,<map S->C>)`
we could have that `C` and the weakrefs to the morphisms die, but that would not trigger the removal from the `TripleDict`. So we could still encounter dead weakrefs (but much less than one would perhaps initially think!) It's not really much different from how [attachment:14058-weak-binop.patch] handles dead weakrefs.

Major problem for immediately applying this idea:

```
sage: M=QQ.coerce_map_from(ZZ)
sage: import weakref
sage: weakref.ref(M)
TypeError: cannot create weak reference to 'sage.rings.rational.Z_to_Q' object
```



---

Comment by robertwb created at 2013-02-05 20:02:44

Yeah, I had exactly this same idea. I'll post an updated patch.


---

Attachment

Apply 14058-weak-binop-morphisms.patch and trac_14058-doctest.patch


---

Comment by nbruin created at 2013-02-05 21:16:57

Great! With this new patch I cannot distinguish the timing differences from the noise one normally gets already, so I'd think this is quite acceptable.


---

Comment by nbruin created at 2013-02-05 22:12:05

patchbot seems unhappy about the doctest.Probably #12313 is indeed necessary to make parents reclaimable.


---

Comment by SimonKing created at 2013-02-06 07:26:13

Stating in the ticket description what patches are to apply. Admittedly I didn't test yet whether the doctest patch applies after Robert's new patch. But the test patch is needed, I think.

Apply 14058-weak-binop-morphisms.patch and trac_14058-doctest.patch trac_14058-doctest.patch


---

Comment by SimonKing created at 2013-02-06 13:45:57

The patches apply, and at least the new test passes. So, this together with #12313, does fix another leak.


---

Comment by SimonKing created at 2013-02-06 14:47:15

In vanilla Sage, the coercion model stores (coercion) morphisms in its cache (which was a `TripleDict`, hence, with weak keys), and the only change introduced by your patch is to store weak references to the (coercion) morphism instead. Did I understand this correctly?

In vanilla Sage, the coercion model kept a strong reference to the morphism, which kept a strong reference to domain and codomain, which were thus not reclaimable, and so the item of the `TripleDict` has eternal life, in spite of the weak keys. Correct?

With the patch, the coercion model keeps a weak reference to the coercion morphism, hence, the strong reference from the morphism to domain and codomain doesn't matter, and thus the item of the `TripleDict` may disappear.

But how is the morphism kept alive? The coercion model only has a weak reference to it. Do I understand correctly that the morphism involved in the binary operation is, at the same time, stored in the coerce dict of its codomain? That's why it does not immediately die?

In other words, do I understand that the layout is as follows? We have parents A and B, and want to apply some binary operator, with a result in the parent C (C may coincide with either A or B). And we have maps r_A and r_B from A or B to C.

Both r_A and r_B are stored with a strong reference in a cache located in C, with weak keys A and B. At the same time, they are stored with a weak reference in the coercion model, again with weak keys A and B. r_A has strong references to C and to A, r_B has strong references to C and to B.

What do we want? Do we want that keeping C alive makes A and B survive? Or do we want that keeping both A and B alive makes C survive?

If the user has a strong reference to C, then C has a strong reference to r_A and r_B (in its coerce cache), and r_A/r_B strongly refers to A/B. Hence, the existence of C keeps A and B alive. Since C is a complicated object, it is more likely to be mortal, hence, probably it is not much of a problem.

If the user has a strong reference to both A and B, then C keeps a strong reference to both r_A and r_B, and the coercion model keeps a weak reference to r_A and r_B. Moreover, r_A and r_B strongly refer to C.

However, isn't it just a reference cycle between C and r_A/r_B? It would not prevent C from becoming collectable, right?

I doubt that we want that. It is not desirable that, when adding elements of `ZZ['x']` and QQ, the ring `QQ['x']` is created repeatedly (OK, polynomial rings have a strong cache anyway. But you see what I mean).

Or did I misunderstand something?


---

Comment by SimonKing created at 2013-02-06 15:59:01

An example that shows that the current patch needs work


---

Attachment

> I doubt that we want that. It is not desirable that, when adding elements of `ZZ['x']` and QQ, the ring `QQ['x']` is created repeatedly (OK, polynomial rings have a strong cache anyway. But you see what I mean).

In my opinion, that is exactly what we want, or at least what we have to settle for. If a person wants to work efficiently with `QQ['x']` he should ensure his elements already live there. Adding elements with the same parents is orders of magnitude faster than relying on coercion. A step closer is ensure that your parent remains in memory. I suspect that usually that will be the case, because if a user creates elements somewhere regularly he probably

In this scenario:

```
P=[ZZ['x%d'%i] for i in [1..1000]]
F=[GF(p) for p in prime_range(1000)]
for Zxi in P:
    for k in F:
        a=P.0
        b=F(1)
        c=a+b
```

If we keep the `GF(p)[xi]` alive because at some point we constructed an element in it from parents that are still around, we've just created quadratic memory requirements where linear should be enough.

I don't think that we can afford to assume that just because a user has combined two parents he/she will do so again in the future. We may be able to afford doing so if it happened _recently_, but that really is an optimisation, and currently I don't see a hook where we can do this efficiently.

A limited length buffer that gets updated whenever a certain component sees a parent go by might work. In Coercion _discovery_ perhaps? That's already slow and it would exactly protect these automatically generated parents. Logically it's hard to defend but it may be OK in practice.

Another possibility is just `UniqueRepresentation_c.__cinit__`. Only when we're making a lot of parents do we care about losing them again ...

The problem with artificially keeping transient elements alive for longer is that you'll defeat the heuristics for generational garbage collection (which Python does), and we depend rather heavily on that to get rid of cyclic garbage. Testing would be required to see if this is indeed a problem, and it will be very application-dependent.


---

Comment by SimonKing created at 2013-02-06 16:02:35

Before posting a reply to Nils' post, here is an example that the existence of A and B does not ensure the survival of the pushout of A and B. First, attach [attachment:testcoercion.py] into a Sage session. Then:

```
sage: %attach /home/simon/SAGE/work/memleak/testcoercion.py
sage: OA = A()
sage: OB = B()
sage: cm = sage.structure.element.get_coercion_model()
sage: OC = cm.explain(OA,OB)
Coercion on left operand via
    Conversion map:
      From: A
      To:   C
Coercion on right operand via
    Conversion map:
      From: B
      To:   C
Arithmetic performed after coercions.
Result lives in C
sage: OC.is_coercion_cached(OA)
True
sage: OC.is_coercion_cached(OB)
True
sage: del OC
sage: import gc
sage: _ = gc.collect()
sage: len([X for X in gc.get_objects() if isinstance(X,C)])
0
sage: xc = OA(1)*OB(1)
sage: isinstance(xc.parent(),C)
True
sage: del xc
sage: _ = gc.collect()
sage: len([X for X in gc.get_objects() if isinstance(X,C)])
0
```


I do believe that this is _not_ desired behaviour.


---

Comment by SimonKing created at 2013-02-06 16:13:18

Replying to [comment:14 nbruin]:
> > I doubt that we want that. It is not desirable that, when adding elements of `ZZ['x']` and QQ, the ring `QQ['x']` is created repeatedly (OK, polynomial rings have a strong cache anyway. But you see what I mean).
> 
> In my opinion, that is exactly what we want, or at least what we have to settle for. If a person wants to work efficiently with `QQ['x']` he should ensure his elements already live there.

Granted. But it is a very typical usage to _not_ explicitly convert everything into a common parent, but let the coercion model do the work. That is what the coercion model is for!

>  I suspect that usually that will be the case, because if a user creates elements somewhere regularly he probably

However, in the example that I posted above, note that multiplying `OA(1)*OB(1)` repeatedly will also create `C()` _repeatedly_, even though it is a `UniqueRepresentation` and hence (weakly, nowadays) cached!

I think it is not acceptable that a multiple creation is triggered.

>
> In this scenario:
> {{{
> P=[ZZ['x%d'%i] for i in [1..1000]]
> F=[GF(p) for p in prime_range(1000)]
> for Zxi in P:
>     for k in F:
>         a=P.0
>         b=F(1)
>         c=a+b
> }}}
> If we keep the `GF(p)[xi]` alive because at some point we constructed an element in it from parents that are still around, we've just created quadratic memory requirements where linear should be enough.

In your example, `GF(p)[xi]` is created exactly once, for each value of p and i. Clearly, in this situation it would not make sense to keep it alive, because it is never reused. However, I doubt that this is a typical use case.

> A limited length buffer that gets updated whenever a certain component sees a parent go by might work. In Coercion _discovery_ perhaps? That's already slow and it would exactly protect these automatically generated parents. Logically it's hard to defend but it may be OK in practice.
> 
> Another possibility is just `UniqueRepresentation_c.__cinit__`. Only when we're making a lot of parents do we care about losing them again ...

OK, but not all unique parent structures rely on it.


---

Comment by nbruin created at 2013-02-06 16:33:03

Replying to [comment:16 SimonKing]:
> I think it is not acceptable that a multiple creation is triggered.
...
Why not? Should the user expect that doing something a second time is faster than the first, without taking special precautions?

> In your example, `GF(p)[xi]` is created exactly once, for each value of p and i. Clearly, in this situation it would not make sense to keep it alive, because it is never reused. However, I doubt that this is a typical use case.

But how do you tell the difference? Against too little caching there is a simple defense: keep a reference yourself. Against too much caching there is nothing you can do. You just run out of memory because data structures outside your control blow up.

We clearly have too much caching presently, in some cases by design. I think we first need a design that's fairly clean and for which we can reliably reason there's not "too much" caching (changing the order of memory requirement is definitely "too much" for me). Next step is tweaking it, possibly with MRU queues (which in that case should really be investigated for interfering with efficient GC, which is based on "objects either live very short or very long", so artificially creating objects with a medium lifespan is bad)


---

Comment by SimonKing created at 2013-02-06 17:10:57

By the way, it seems that the "insufficient" caching (not enough to keep C() alive) has no influence on performance, at least not if computations are done in a close cycle:

```
sage: %attach /home/simon/SAGE/work/memleak/testcoercion.py
sage: OA = A()
sage: OB = B()
sage: a = OA(1)
sage: b = OB(1)
sage: def test(x,y):
....:     for _ in xrange(2*10^5):
....:         z = x*y
....:         
sage: %time test(a,a)
CPU times: user 4.49 s, sys: 0.00 s, total: 4.49 s
Wall time: 4.49 s
sage: %time test(a,b)
CPU times: user 8.99 s, sys: 0.11 s, total: 9.11 s
Wall time: 9.13 s
sage: c = a*b
sage: print c.parent()
C
sage: %time test(a,b)
CPU times: user 8.85 s, sys: 0.03 s, total: 8.88 s
Wall time: 8.89 s
```


In the first run of test(a,b), there is the possibility that `parent(a*b)` becomes created repeatedly, as I have demonstrated above. In the second run, `parent(a*b)` is kept alive, by keeping a pointer to the result of `a*b`. There is no significant difference in performance. Of course, we also see that multiplication within one parent is faster.

Is there a way to get the patchbots report significant regressions in some examples? Because I am sure that some parts of Sage (schemes and combinat are typical candidates) rely on a strong coercion cache.


---

Comment by nbruin created at 2013-02-06 17:45:31

Replying to [comment:18 SimonKing]:
> By the way, it seems that the "insufficient" caching (not enough to keep C() alive) has no influence on performance, at least not if computations are done in a close cycle:
Ah right, because `C._coerce_from_hash[A]._codomain is C`, there's a cycle involving C so instead of getting deleted eagerly by Python's refcounting, it's only done with (relatively infrequent) GCs. So it even comes with a trick to improve this free "caching": Increase the interval for garbage collection. See `gc.get_threshold` and `gc.set_threshold`. By tweaking those numbers you can probably manipulate the running times in these examples.

*NOTE:* Doesn't `timeit` turn garbage collection off? So that may be a misleading tool for investigating performance for these things.


---

Comment by SimonKing created at 2013-02-06 19:01:10

I think it makes sense to ask [sage-devel](https://groups.google.com/forum/?fromgroups=#!topic/sage-devel/7FCHou9nkIg) whether it is better to fix this leak or not.

I believe that keeping A and B alive should prevent C from garbage collection. In contrast, keeping C alive should _not_ prevent A and B from garbage collection. Currently, it is the other way around. Perhaps we should try to think through whether having a weak reference to the domain of coercion or conversion maps would work.


---

Comment by robertwb created at 2013-02-06 19:57:55

+1 to taking this discussion to sage-devel.

Patchbot: apply 14058-weak-binop-morphisms.patch trac_14058-doctest.patch


---

Comment by SimonKing created at 2013-02-07 12:21:03

The patchbot only reports one error, namely

```
File "/home/patchbot/sage-5.7.beta3/devel/sage-14058/sage/rings/number_field/number_field_ideal.py", line 118:
    sage: convert_to_idealprimedec_form(K, P)
Exception raised:
    Traceback (most recent call last):
      File "/home/patchbot/sage-5.7.beta3/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/home/patchbot/sage-5.7.beta3/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/patchbot/sage-5.7.beta3/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_2[5]>", line 1, in <module>
        convert_to_idealprimedec_form(K, P)###line 118:
    sage: convert_to_idealprimedec_form(K, P)
      File "/home/patchbot/sage-5.7.beta3/local/lib/python/site-packages/sage/rings/number_field/number_field_ideal.py", line 124, in convert_to_idealprimedec_form
        K_bnf = gp(field.pari_bnf())
      File "/home/patchbot/sage-5.7.beta3/local/lib/python/site-packages/sage/interfaces/interface.py", line 201, in __call__
        return self._coerce_from_special_method(x)
      File "/home/patchbot/sage-5.7.beta3/local/lib/python/site-packages/sage/interfaces/interface.py", line 227, in _coerce_from_special_method
        return (x.__getattribute__(s))(self)
      File "sage_object.pyx", line 485, in sage.structure.sage_object.SageObject._gp_ (sage/structure/sage_object.c:4804)
      File "sage_object.pyx", line 450, in sage.structure.sage_object.SageObject._interface_ (sage/structure/sage_object.c:4144)
      File "/home/patchbot/sage-5.7.beta3/local/lib/python/site-packages/sage/interfaces/interface.py", line 199, in __call__
        return cls(self, x, name=name)
      File "/home/patchbot/sage-5.7.beta3/local/lib/python/site-packages/sage/interfaces/expect.py", line 1280, in __init__
        self._name = parent._create(value, name=name)
      File "/home/patchbot/sage-5.7.beta3/local/lib/python/site-packages/sage/interfaces/interface.py", line 389, in _create
        self.set(name, value)
      File "/home/patchbot/sage-5.7.beta3/local/lib/python/site-packages/sage/interfaces/gp.py", line 511, in set
        raise TypeError, "Error executing code in GP:\nCODE:\n\t%s\nPARI/GP ERROR:\n%s"%(cmd, out)
    TypeError: Error executing code in GP:
    CODE:
    	sage[14]=[[;], matrix(0,7), [;], Mat([0.E-38 + 3.52184386028273*I, 0.E-37 + 3.70366245659542*I, 0.E-37 + 2.91167081258838*I, 0.E-38 + 3.14159265358979*I, 0.E-38 + 9.04452675407645*I, 0.E-37 + 8.86270815776375*I, 0.E-37 + 9.65469980177079*I]), [[7, [-1, 2]~, 1, 1, [3, -2; 2, 1]], [13, [-5, 2]~, 1, 1, [-6, -2; 2, -8]], [19, [-3, 2]~, 1, 1, [5, -2; 2, 3]], [3, [1, 2]~, 2, 1, [1, 1; -1, 2]], [7, [3, 2]~, 1, 1, [-1, -2; 2, -3]], [13, [7, 2]~, 1, 1, [-5, -2; 2, -7]], [19, [5, 2]~, 1, 1, [-3, -2; 2, -5]]], 0, [y^2 + 3, [0, 1], -3, 2, [Mat([1, -0.500000000000000 - 0.866025403784439*I]), [1, -1.36602540378444; 1, 0.366025403784439], [1, -1; 1, 0], [2, -1; -1, -1], [3, 2; 0, 1], [1, -1; -1, -2], [3, [2, -1; 1, 1]]], [0.E-38 - 1.73205080756888*I], [1, 1/2*y - 1/2], [1, 1; 0, 2], [1, 0, 0, -1; 0, 1, 1, -1]], [[1, [], []], 1, 1, [6, -1/2*y + 1/2], []], [[;], [], []], [0, []]];
    PARI/GP ERROR:
      ***   at top-level: sage[14]=[[;],matrix(0,7
      ***                     ^--------------------
      ***   _[_]: not a vector.
  ***   Warning: precision too low for generators, not given.
```

That's obscure to me. What does it mean?


---

Comment by SimonKing created at 2013-02-07 12:26:19

Unfortunately, I get

```
sage -t  "devel/sage-main/sage/rings/number_field/number_field_ideal.py"
         [21.9 s]
 
----------------------------------------------------------------------
All tests passed!
Total time for all tests: 22.0 seconds
```


So, what happened here?

In any case, I think the example of collectable pushout should be included in the documentation, combined with a warning to keep a pointer to the pushout (or avoid cross-parent arithmetic altogether), if speed matters.

I could write that. But to what location? Logically, it belongs to sage.structure.coerce, but nobody would read that. It might better be in a more general tutorial. What do you suggest?


---

Comment by SimonKing created at 2013-02-07 19:14:55

I did make ptest with a highly patched debug version of sage-5.7.beta2. Hence, I have the dependencies of #13864 and additionally #9107, #12951, #13916. #12313, #14058 and #13370 applied.

In the parallel test, I got two timeouts, namely in devel/sage/doc/en/bordeaux_2008/birds_other.rst and devel/sage/sage/interfaces/maxima.py. Running the former individually is long, but fine:

```
sage -t -force_lib "devel/sage/doc/en/bordeaux_2008/birds_other.rst"
         [339.8 s]
 
----------------------------------------------------------------------
All tests passed!
Total time for all tests: 339.9 seconds
```


However, the maxima test is suspicious. I ran it twice individually. The first time I got an evil error:

```
sage -t -force_lib "devel/sage/sage/interfaces/maxima.py"   
**********************************************************************
File "/home/simon/SAGE/debug/sage-5.7.beta2/devel/sage/sage/interfaces/maxima.py", line 355:
    sage: T.tlimit('n','inf')
Exception raised:
    Traceback (most recent call last):
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/bin/ncadoctest.py", line 1231, in run_one_test
        self.run_one_example(test, example, filename, compileflags)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/bin/sagedoctest.py", line 38, in run_one_example
        OrigDocTestRunner.run_one_example(self, test, example, filename, compileflags)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/bin/ncadoctest.py", line 1172, in run_one_example
        compileflags, 1) in test.globs
      File "<doctest __main__.example_0[77]>", line 1, in <module>
        T.tlimit('n','inf')###line 355:
    sage: T.tlimit('n','inf')
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/lib/python/site-packages/sage/interfaces/interface.py", line 588, in __call__
        return self._obj.parent().function_call(self._name, [self._obj] + list(args), kwds)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/lib/python/site-packages/sage/interfaces/interface.py", line 489, in function_call
        return self.new(s)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/lib/python/site-packages/sage/interfaces/interface.py", line 264, in new
        return self(code)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/lib/python/site-packages/sage/interfaces/interface.py", line 199, in __call__
        return cls(self, x, name=name)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/lib/python/site-packages/sage/interfaces/maxima.py", line 1153, in __init__
        ExpectElement.__init__(self, parent, value, is_name=False, name=None)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/lib/python/site-packages/sage/interfaces/expect.py", line 1280, in __init__
        self._name = parent._create(value, name=name)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/lib/python/site-packages/sage/interfaces/interface.py", line 389, in _create
        self.set(name, value)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/lib/python/site-packages/sage/interfaces/maxima.py", line 998, in set
        self._eval_line(cmd)
      File "/home/simon/SAGE/debug/sage-5.7.beta2/local/lib/python/site-packages/sage/interfaces/maxima.py", line 754, in _eval_line
        assert line_echo.strip() == line.strip()
    AssertionError
**********************************************************************
1 items had failures:
   1 of  97 in __main__.example_0
***Test Failed*** 1 failures.
For whitespace errors, see the file /home/simon/.sage//tmp/maxima_30383.py
         [13.7 s]
 
----------------------------------------------------------------------
The following tests failed:


        sage -t -force_lib "devel/sage/sage/interfaces/maxima.py"
Total time for all tests: 13.8 seconds
```

and the second time I got

```
sage -t -force_lib "devel/sage/sage/interfaces/maxima.py"   
         [12.6 s]
 
----------------------------------------------------------------------
All tests passed!
Total time for all tests: 12.6 seconds
```


Is the error something we should worry about? Or is that likely to be the effect of a neutrino hitting my laptop?


---

Comment by SimonKing created at 2013-02-26 19:45:04

At #14159, I am providing a version of `MonoDict` and `TripleDict` that optionally allows to store the values by weak references. Provided that the performance is OK, Nils Bruin suggests to consider to use this here, hence, make #14159 a dependency. What do you think?


---

Comment by SimonKing created at 2013-08-15 07:23:46

Note to myself: Work on this ticket...


---

Comment by SimonKing created at 2013-11-16 23:44:01

Lost track again.

I tried to import the patches and turn them into git branches. It mostly worked, but I had to resolve some conflicts with the second patch.

Would it be OK to change this hg-ticket into a git-ticket?


---

Comment by SimonKing created at 2013-11-17 14:45:39

Changing status from needs_review to needs_work.


---

Comment by SimonKing created at 2013-11-17 14:45:39

While I had to resolve conflicts when importing the two patches into the git master branch, the patches do apply to sage-5.12.beta5, and the patchbot reports the same on sage-5.13.beta2. So, perhaps it is OK to keep this a mercurial ticket.

However, with the gitification of the patches, I find (similar to the patchbot)

```
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.13.beta2/devel/sage/sage/rings/polynomial/plural.pyx  # 17 doctests failed
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.13.beta2/devel/sage/sage/libs/singular/function.pyx  # 1 doctest failed
```

The patchbot additionally finds

```
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.13.beta2/devel/sage/sage/algebras/free_algebra.py  # 1 doctest failed
sage -t --long /mnt/storage2TB/patchbot/Sage/sage-5.13.beta2/devel/sage/sage/structure/coerce.pyx  # 1 doctest failed
```

So, this requires some work.


---

Comment by SimonKing created at 2015-07-16 19:55:56

I plan to create a branch for it. Probably it will fix #18905.


---

Comment by SimonKing created at 2015-07-16 22:46:19

Here is a branch. The merge was not trivial, so, hopefully I did it well.

Next, we have to see if the "old problem" (i.e., attachment:testcoercion.py) is still problematic, and of course there may be doctest failures.

At least, the issue from comment:20 is solved: We do have weak references to the domain of coercion maps now.
----
New commits:


---

Comment by SimonKing created at 2015-07-17 07:43:00


```
sage -t src/sage/algebras/commutative_dga.py  # 3 doctests failed
sage -t src/sage/algebras/free_algebra.py  # 1 doctest failed
sage -t src/sage/rings/polynomial/plural.pyx  # 17 doctests failed
sage -t src/sage/dev/sagedev.py  # 2 doctests failed
sage -t src/sage/structure/coerce.pyx  # 2 doctests failed
sage -t src/sage/libs/singular/function.pyx  # 2 doctests failed
```

Not bad (and the sagedev error very likely is because I have rerere enabled, hence, it is unrelated anyway).


---

Comment by SimonKing created at 2015-07-17 08:06:34

Details:

```
sage -t src/sage/libs/singular/function.pyx
**********************************************************************
File "src/sage/libs/singular/function.pyx", line 413, in sage.libs.singular.function.is_singular_poly_wrapper
Failed example:
    H.<x,y,z> = A.g_algebra({z*x:x*z+2*x, z*y:y*z-2*y})
Expected nothing
Got:
    Exception KeyError: (The ring pointer 0x7f7c7470c8d0,) in 'sage.libs.singular.ring.singular_ring_delete' ignored
**********************************************************************
File "src/sage/libs/singular/function.pyx", line 1250, in sage.libs.singular.function.SingularFunction.__call__
Failed example:
    I = Ideal(I.groebner_basis())
Expected nothing
Got:
    Exception KeyError: (The ring pointer 0x7f7c7470ca40,) in 'sage.libs.singular.ring.singular_ring_delete' ignored
**********************************************************************
```

--> It seems that the cache became too weak. All errors in `sage -t src/sage/rings/polynomial/plural.pyx` and `sage -t src/sage/algebras/commutative_dga.py` are of that form.


```
sage -t src/sage/structure/coerce.pyx
**********************************************************************
File "src/sage/structure/coerce.pyx", line 418, in sage.structure.coerce.CoercionModel_cache_maps.get_cache
Failed example:
    print copy(left_morphism_ref())
Exception raised:
    Traceback (most recent call last):
      File "/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 496, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 858, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.structure.coerce.CoercionModel_cache_maps.get_cache[4]>", line 1, in <module>
        print copy(left_morphism_ref())
    NameError: name 'left_morphism_ref' is not defined
**********************************************************************
File "src/sage/structure/coerce.pyx", line 422, in sage.structure.coerce.CoercionModel_cache_maps.get_cache
Failed example:
    print right_morphism_ref
Exception raised:
    Traceback (most recent call last):
      File "/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 496, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 858, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.structure.coerce.CoercionModel_cache_maps.get_cache[5]>", line 1, in <module>
        print right_morphism_ref
    NameError: name 'right_morphism_ref' is not defined
**********************************************************************
```

--> I got something wrong in my merge.

So, we actually just have two errors.


---

Comment by git created at 2015-07-17 15:29:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-17 21:46:53

#13447 is probably related. Perhaps (if we can finish the work here) #13447 can eventually be closed as a duplicate.


---

Comment by SimonKing created at 2015-07-17 21:52:57

In the following example

```
            sage: import gc
            sage: from sage.rings.polynomial.plural import NCPolynomialRing_plural
            sage: from sage.algebras.free_algebra import FreeAlgebra
            sage: A1.<x,y,z> = FreeAlgebra(QQ, 3)
            sage: R1 = A1.g_algebra({y*x:x*y-z, z*x:x*z+2*x, z*y:y*z-2*y}, order=TermOrder('degrevlex', 2))
            sage: A2.<x,y,z> = FreeAlgebra(GF(5), 3)
            sage: R2 = A2.g_algebra({y*x:x*y-z, z*x:x*z+2*x, z*y:y*z-2*y}, order=TermOrder('degrevlex', 2))
            sage: A3.<x,y,z> = FreeAlgebra(GF(11), 3)
            sage: R3 = A3.g_algebra({y*x:x*y-z, z*x:x*z+2*x, z*y:y*z-2*y}, order=TermOrder('degrevlex', 2))
            sage: A4.<x,y,z> = FreeAlgebra(GF(13), 3)
            sage: R4 = A4.g_algebra({y*x:x*y-z, z*x:x*z+2*x, z*y:y*z-2*y}, order=TermOrder('degrevlex', 2))
            sage: _ = gc.collect()
            sage: foo = R1.gen(0)
            sage: del foo
            sage: del R1
            sage: _ = gc.collect()
            sage: del R2
            sage: _ = gc.collect()
            sage: del R3
            sage: _ = gc.collect()
```

the reference counting goes wrong after each `gc.collect()`.


---

Comment by git created at 2015-07-17 22:38:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-17 22:40:10

Got it! When a non-commutative ring is created, it was forgotten to put the underlying libsingular ring into Sage's refcounting system. Should be fixed now. I'll see if #13447 is fixed now, too.


---

Comment by SimonKing created at 2015-07-17 22:50:36

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2015-07-17 22:50:36

Sigh. #13447 is not fixed, as the following example shows.

```
sage: import gc
sage: _ = gc.collect()
sage: from sage.rings.polynomial.multi_polynomial_libsingular import MPolynomialRing_libsingular
sage: from sage.libs.singular.groebner_strategy import GroebnerStrategy
sage: n = len([x for x in gc.get_objects() if isinstance(x,MPolynomialRing_libsingular)])
sage: P = MPolynomialRing_libsingular(GF(541), 2, ('x', 'y'), TermOrder('degrevlex', 2))
sage: strat = GroebnerStrategy(Ideal([P.gen(0) + P.gen(1)]))
sage: del strat
sage: del P
sage: _ = gc.collect()
sage: n == len([x for x in gc.get_objects() if isinstance(x,MPolynomialRing_libsingular)])
False
```


I'd suggest to proceed as follows. Provided that all tests pass, I can review Robert's and Nils' patches, someone else reviews my additions (which are the merging and the latest commit), and then we make this a dependency for #13447.


---

Comment by git created at 2015-07-18 06:18:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-18 06:26:18

Sometimes, the following test in sage/categories/fields.py has failed:

```
            sage: import gc
            sage: _ = gc.collect()
            sage: n = len([X for X in gc.get_objects() if isinstance(X, sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic)])
            sage: for i in prime_range(100):
            ....:     R = ZZ.quotient(i)
            ....:     t = R in Fields()
            sage: _ = gc.collect()
            sage: len([X for X in gc.get_objects() if isinstance(X, sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic)]) - n
            1
```

The reason for the failure: Sometimes the last line gave 0, not 1. It is not totally clear to me why the different results occurred. But in fact 0 is better than 1 here (one additional ring got collected). So, I hope my change is OK.


---

Comment by SimonKing created at 2015-07-18 06:45:34

I am giving a positive review to Robert's code and Nils' doctest. I consider my contribution too small to make me author, but I think my changes need a review.


---

Comment by pbruin created at 2015-07-20 14:40:49

Replying to [comment:45 SimonKing]:
> Sometimes, the following test in sage/categories/fields.py has failed:
> {{{
>             sage: import gc
>             sage: _ = gc.collect()
>             sage: n = len([X for X in gc.get_objects() if isinstance(X, sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic)])
>             sage: for i in prime_range(100):
>             ....:     R = ZZ.quotient(i)
>             ....:     t = R in Fields()
>             sage: _ = gc.collect()
>             sage: len([X for X in gc.get_objects() if isinstance(X, sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic)]) - n
>             1
> }}}
> The reason for the failure: Sometimes the last line gave 0, not 1. It is not totally clear to me why the different results occurred. But in fact 0 is better than 1 here (one additional ring got collected).
Shouldn't the result always be 1 given that `R` refers to `Zmod(97)` after the loop (unless there is a surviving reference from a `Zmod(97)` created in some earlier test)?  What happens if you do `del R` before the last `gc.collect()`?


---

Comment by SimonKing created at 2015-07-20 14:56:52

Replying to [comment:47 pbruin]:
> Shouldn't the result always be 1 given that `R` refers to `Zmod(97)` after the loop (unless there is a surviving reference from a `Zmod(97)` created in some earlier test)?

Exactly. And what's strange: It isn't reproducible. Sometimes I get 1, sometimes I get 0. And I always get 1 when I run it on the command line.

>  What happens if you do `del R` before the last `gc.collect()`?

No idea.


---

Comment by SimonKing created at 2015-07-20 15:02:30

To be precise: I saw this problem precisely once. When I run the previous test about 20 times, it always passes.


---

Comment by git created at 2015-07-21 13:18:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2015-07-21 13:19:18

Hopefully the new version of the test is reliable.


---

Comment by chapoton created at 2015-08-04 07:37:21

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2015-08-04 07:37:21

excerpt from patchbot report:

```
+inside file:  b/src/sage/structure/coerce.pyx
+@@ -1265,33 +1287,74 @@ cdef class CoercionModel_cache_maps(CoercionModel):
++                    raise RuntimeError, "BUG in coercion model: coerce_map_from must return a Map"
++                    raise RuntimeError, "BUG in coercion model: coerce_map_from must return a Map"
+Old-style raise statement inserted on 2 non-empty lines
```



---

Comment by SimonKing created at 2015-08-04 07:59:42

Replying to [comment:52 chapoton]:
> excerpt from patchbot report:
> {{{
> +inside file:  b/src/sage/structure/coerce.pyx
> +`@``@` -1265,33 +1287,74 `@``@` cdef class CoercionModel_cache_maps(CoercionModel):
> ++                    raise RuntimeError, "BUG in coercion model: coerce_map_from must return a Map"
> ++                    raise RuntimeError, "BUG in coercion model: coerce_map_from must return a Map"
> +Old-style raise statement inserted on 2 non-empty lines
> }}}

Actually this was not inserted, but moved. Would it be possible for you to change this to new-style raise statement by a reviewer commit?


---

Comment by chapoton created at 2015-08-04 08:57:55

done. I also did it for some of the other raise in the same file.
----
New commits:


---

Comment by chapoton created at 2015-08-04 08:58:07

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2015-08-06 14:06:37

Replying to [comment:46 SimonKing]:
> I am giving a positive review to Robert's code and Nils' doctest. I consider my contribution too small to make me author, but I think my changes need a review.

Could someone please finish the review? The patchbot thinks the branch is fine.


---

Comment by jpflori created at 2015-08-06 14:11:50

Changing status from needs_review to positive_review.


---

Comment by jpflori created at 2015-08-06 14:11:50

Your change is small and makes sense.


---

Comment by vdelecroix created at 2015-08-10 09:56:54

Changing status from positive_review to needs_work.


---

Comment by vdelecroix created at 2015-08-10 09:56:54

From the patchbot

```
sage -t --long src/sage/structure/coerce.pyx
**********************************************************************
File "src/sage/structure/coerce.pyx", line 1307, in sage.structure.coerce.CoercionModel_cache_maps.coercion_maps
Failed example:
    print N2-N0
Expected:
    0
Got:
    -1
```

Is it what we should get?


---

Comment by vdelecroix created at 2015-08-10 09:58:06

Replying to [comment:58 vdelecroix]:
> From the patchbot
> ...

wrong ticket... should be #18905. Sorry for the noise.


---

Comment by vdelecroix created at 2015-08-10 09:58:06

Changing status from needs_work to needs_review.


---

Comment by SimonKing created at 2015-08-10 11:53:55

Replying to [comment:59 vdelecroix]:
> Replying to [comment:58 vdelecroix]:
> > From the patchbot
> > ...
> 
> wrong ticket... should be #18905. Sorry for the noise.

The patchbot HERE does report this problem. So, what do you mean that it "should be #18905"?


---

Comment by vdelecroix created at 2015-08-10 11:55:17

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2015-08-10 11:55:17

Right! I confused myself.


---

Comment by vdelecroix created at 2015-08-10 12:08:30

The failing doctest is reproducible after applying this branch onto `6.9.beta1`.


---

Comment by slabbe created at 2015-08-11 18:43:21

On sage-6.9.beta1, I get:


```
$ sage nbruin.sage
Time: CPU 7.95 s, Wall: 7.95 s
Time: CPU 7.68 s, Wall: 7.68 s
Time: CPU 76.76 s, Wall: 76.94 s
```


On sage-6.9.beta1 + #14058, I get a very good improvement:


```
$ sage nbruin.sage
Time: CPU 2.48 s, Wall: 2.48 s
Time: CPU 2.07 s, Wall: 2.07 s
Time: CPU 32.38 s, Wall: 32.42 s
```


Note: I originally thought it [was a regression in sage](https://groups.google.com/d/msg/sage-devel/n7_21tCO4zI/cuCAlO01DwAJ) since I was getting this earlier this morning with sage-6.8 + #14058. But thanksfully, it seems to be a improvement obtained from this ticket.

The file `nbruin.sage` is from [comment 4](http://trac.sagemath.org/ticket/14058#comment:4):


```
 $ cat nbruin.sage
a=ZZ(1)
b=QQ(1)
c=ZZ['x'](1)
d=b+c

def test(x,y):
  for i in xrange(10^6):
    _=x+y

time test(a,b)
time test(a,c)
time test(b,c)
```



---

Comment by slabbe created at 2015-08-11 19:01:02

I also get improvements on tests above of Simon King at [comments 18](http://trac.sagemath.org/ticket/14058#comment:18).

With sage-6.9.beta1:


```
$ sage testcoercion.sage
Time: CPU 1.69 s, Wall: 1.69 s
Time: CPU 4.05 s, Wall: 4.05 s
C
Time: CPU 4.03 s, Wall: 4.03 s
```


With sage-6.9.beta1 + this ticket:


```
$ sage testcoercion.sage
Time: CPU 0.34 s, Wall: 0.34 s
Time: CPU 0.85 s, Wall: 0.85 s
C
Time: CPU 0.86 s, Wall: 0.86 s
```


(My file testcoercion.sage contains testcoercion.py + the lines at comment 18.)


---

Comment by slabbe created at 2015-08-12 09:30:06

With sage-6.9.beta1 + this ticket, I get `All tests passed` when I do


```
./sage -t --long src/sage/structure/coerce.pyx
```


but I get the problem when I test after the build


```
./sage -bt --long src/sage/structure/coerce.pyx
```


which gives the error:


```
**********************************************************************
File "src/sage/structure/coerce.pyx", line 1307, in sage.structure.coerce.CoercionModel_cache_maps.coercion_maps
Failed example:
    print N2-N0
Expected:
    0
Got:
    -1
**********************************************************************
```


I have never seen such a behavior.


---

Comment by git created at 2015-08-12 11:08:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-08-12 11:41:01

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by slabbe created at 2015-08-12 11:46:22

In other doctests in the same file, `GF(3)`, `GF(7)` and `GF(41)` are also created. While there are references to `GF(7)` and `GF(41)`, no variable references to `GF(3)` which is available for gargage collection. If `GF(3)` gets garbage collected before the offending doctest, then everything is fine, the doctest pass. But it can also be garbage collected in the call to `gc.collect()` in the doctest. If this is the case, then `N0` was also counting `GF(3)` which explains why `N2-N0` can be negative.

One way to fix this is to call `gc.collect()` before creating `N0`.

(my first fix was using sets of ids... sorry for the noise).


---

Comment by SimonKing created at 2015-08-12 12:08:19

Replying to [comment:68 slabbe]:
> One way to fix this is to call `gc.collect()` before creating `N0`.

I agree, that's the way to fix it.


---

Comment by slabbe created at 2015-08-12 12:16:19

Changing status from needs_work to needs_review.


---

Comment by jpflori created at 2015-08-13 09:31:47

I assume Simon's comment gives positive review here as this was the only thing to fix.


---

Comment by jpflori created at 2015-08-13 09:31:47

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-09-13 22:12:27

Resolution: fixed


---

Comment by jdemeyer created at 2015-09-17 19:59:56

On arando:

```

sage -t --long src/sage/categories/fields.py
**********************************************************************
File "src/sage/categories/fields.py", line 104, in sage.categories.fields.Fields.__contains__
Failed example:
    len([X for X in gc.get_objects() if isinstance(X, sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic)]) - n
Expected:
    0
Got:
    -1
**********************************************************************
```



---

Comment by jdemeyer created at 2015-09-19 10:53:54

See #19244
