# Issue 30423: Slow SR matrix inversion

archive/issues_030423.json:
```json
{
    "body": "The inversion of SR matrices appears to be quite a bit slower than e.g. in Maxima.\n\nTest case in Sage:\n\n```\nvar('a b c')\nm = matrix([[a + 1, b, c, a, b, c, a, b, c, a],\n[b, c + 1, a, b, c, a, b, c, a, b],\n[c, a, b + 1, c, a, b, c, a, b, c],\n[a, b, c, a + 1, b, c, a, b, c, a],\n[b, c, a, b, c + 1, a, b, c, a, b],\n[c, a, b, c, a, b + 1, c, a, b, c],\n[a, b, c, a, b, c, a + 1, b, c, a],\n[b, c, a, b, c, a, b, c + 1, a, b],\n[c, a, b, c, a, b, c, a, b + 1, c],\n[a, b, c, a, b, c, a, b, c, a + 1]])\nm2 = m.inverse()\n```\n\ntakes ~2 minutes, whereas\n\n```\nm2 = m._maxima_().invert()._sage_()\n```\n\ncompletes in less than a second.\n\nThe hot spot in Sage seems to be checking SR expression equality to zero, not only when selecting pivots, but also as an optimization to avoid subtracting zeros from the rows (in sage/matrix/matrix2.pyx:_echelon_in_place). Why the checks become so slow probably has to do with expressions growing long, given that e.g. .factor() is not called after row operations. There's probably several things one could do to improve the speed (or, Sage could use Maxima for matrix inversion when that's safe to do).\n\nIssue created by migration from https://trac.sagemath.org/ticket/30660\n\n",
    "created_at": "2020-09-25T10:34:26Z",
    "labels": [
        "linear algebra",
        "major",
        "enhancement"
    ],
    "title": "Slow SR matrix inversion",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/30423",
    "user": "@pv"
}
```
The inversion of SR matrices appears to be quite a bit slower than e.g. in Maxima.

Test case in Sage:

```
var('a b c')
m = matrix([[a + 1, b, c, a, b, c, a, b, c, a],
[b, c + 1, a, b, c, a, b, c, a, b],
[c, a, b + 1, c, a, b, c, a, b, c],
[a, b, c, a + 1, b, c, a, b, c, a],
[b, c, a, b, c + 1, a, b, c, a, b],
[c, a, b, c, a, b + 1, c, a, b, c],
[a, b, c, a, b, c, a + 1, b, c, a],
[b, c, a, b, c, a, b, c + 1, a, b],
[c, a, b, c, a, b, c, a, b + 1, c],
[a, b, c, a, b, c, a, b, c, a + 1]])
m2 = m.inverse()
```

takes ~2 minutes, whereas

```
m2 = m._maxima_().invert()._sage_()
```

completes in less than a second.

The hot spot in Sage seems to be checking SR expression equality to zero, not only when selecting pivots, but also as an optimization to avoid subtracting zeros from the rows (in sage/matrix/matrix2.pyx:_echelon_in_place). Why the checks become so slow probably has to do with expressions growing long, given that e.g. .factor() is not called after row operations. There's probably several things one could do to improve the speed (or, Sage could use Maxima for matrix inversion when that's safe to do).

Issue created by migration from https://trac.sagemath.org/ticket/30660





---

archive/issue_comments_433977.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30423",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30423#issuecomment-433977",
    "user": "mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
