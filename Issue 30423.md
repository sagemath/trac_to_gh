# Issue 30423: Slow SR matrix inversion

Issue created by migration from https://trac.sagemath.org/ticket/30660

Original creator: @pv

Original creation time: 2020-09-25 10:34:26

The inversion of SR matrices appears to be quite a bit slower than e.g. in Maxima.

Test case in Sage:

```
var('a b c')
m = matrix([[a + 1, b, c, a, b, c, a, b, c, a],
[b, c + 1, a, b, c, a, b, c, a, b],
[c, a, b + 1, c, a, b, c, a, b, c],
[a, b, c, a + 1, b, c, a, b, c, a],
[b, c, a, b, c + 1, a, b, c, a, b],
[c, a, b, c, a, b + 1, c, a, b, c],
[a, b, c, a, b, c, a + 1, b, c, a],
[b, c, a, b, c, a, b, c + 1, a, b],
[c, a, b, c, a, b, c, a, b + 1, c],
[a, b, c, a, b, c, a, b, c, a + 1]])
m2 = m.inverse()
```

takes ~2 minutes, whereas

```
m2 = m._maxima_().invert()._sage_()
```

completes in less than a second.

The hot spot in Sage seems to be checking SR expression equality to zero, not only when selecting pivots, but also as an optimization to avoid subtracting zeros from the rows (in sage/matrix/matrix2.pyx:_echelon_in_place). Why the checks become so slow probably has to do with expressions growing long, given that e.g. .factor() is not called after row operations. There's probably several things one could do to improve the speed (or, Sage could use Maxima for matrix inversion when that's safe to do).


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
