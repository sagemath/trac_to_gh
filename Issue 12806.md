# Issue 12806: conditionally_defined decorator for methods and nested classes

Issue created by migration from Trac.

Original creator: nthiery

Original creation time: 2012-05-19 16:54:30

Assignee: jason

CC:  sage-combinat simonking saliola

Keywords: categories, conditionally_defined

Goal: implement conditionally defined methods and nested classes:

Typical use cases:

```
class A(...):

    ...

    `@`conditionaly_defined(has="product_with_basis")
    def product(self):
        ... build the product by bilinearity


    `@`conditionaly_defined(lambda self: self.q() == 2):
    class MyBasis:
        ... 
```


Then, for ``a`` an instance of ``A``, the above condition would be
evaluated at runtime, when a.product is first accessed, like for lazy
attributes.

That's a feature we used a lot in the category code in MuPAD.


---

Comment by SimonKing created at 2013-08-15 08:31:04

Nicolas, I have questions to this feature request.

What do you want to happen, if the condition in "conditionally_defined" is not met? Raise an attribute error (probably yes)?

It seems to me that in your proposal we would either have a certain method defined, or have it not defined at all. Wouldn't it be nice to have _several_ implementations of a method, and choose one of them according to certain parameters?

I guess the extended proposal could not be done by a simple decorator, because a decorator only expects a single function as input.

Anyway. I think it would be possible to create a wrapper that is bound to the class and has a `__get__` method that will then choose one of the wrapped methods and bind it to a specific instance.

Note that in an awkward manual way, it is probably already possible to mimic this behaviour. Something like:

```
class C:
    def __init__(self, n):
        self.n = n
    `@`lazy_attribute
    def fancy_method(self):
        if self.n>0:
            return self.method1
        return self.method2
    def method1(self, m):
        print "method 1"
        return self.n*m
    def method2(self, m):
        print "method 2"
        return self.n+m
```

Indeed, you would then have

```
sage: c1 = C(3)
sage: c2 = C(-3)
sage: c1.fancy_method(2)
method 1
6
sage: c2.fancy_method(2)
method 2
-1
```


So, you suggest to have a decorator that makes this behaviour automatic?

Perhaps the choice could be made exactly as in my example. The syntax could be:

```
class C:
    `@`conditional_method(some_function)
    def method_name(self, ...=)
        <the default implementation>
    def method1(...):
        <first alternative implementation of method_name>
    def method2(...):
        <second alternative implementation of method_name>
    ...
```

where some_function expects `self` as argument and returns a string `chosen_name`. And then, `self.method_name` will be overridden by `getattr(self,chosen_name)`; only if self has no attribute `chosen_name` (which is the case, e.g., if `chosen_name=""`), then the default implementation is returned.

Do you think this is a good approach/good syntax?


---

Comment by nthiery created at 2013-08-16 06:29:19

Hi Simon!

Replying to [comment:1 SimonKing]:
> What do you want to happen, if the condition in "conditionally_defined" is not met? Raise an attribute error (probably yes)?

I want the same behavior as for a lazy attribute when the value is
NotImplemented: in that case, the lookup proceeds in the super class
hierarchy. And of course if it's not found there we get an
AttributeError.

> Wouldn't it be nice to have _several_ implementations of a method,
> and choose one of them according to certain parameters?

This indeed sounds like a natural feature, but I don't have a strong
use case yet for it. In all the examples I have in my mind, the
"other" implementations are provided by the super classes. So I would
focus on the decorator for the simple ``conditionally_defined'' case first and gather
experience on its use before thinking about a good syntax for
``several implementations''; it might at then end be just simpler and more
explicit to stick to doing this manually with a lazy attribute as in your example above.

Cheers,
                              Nicolas


---

Comment by SimonKing created at 2013-08-16 08:13:06

Replying to [comment:2 nthiery]:
> I want the same behavior as for a lazy attribute when the value is
> NotImplemented: in that case, the lookup proceeds in the super class
> hierarchy.

Do I understand correctly that you want the following behaviour:

```python
class A(object):
    def my_method(self, *args,**kwargs):
        <default_implementation>
class B(A):
    `@`conditionally_defined(f)
    def my_method(self, *args,**kwargs):
        <other implementation>
```

such that the default implementation is used when `f(self)` evaluates to False (or an attribute error is raised if the the `super(B,B)` does not define `my_method`), and uses the specialised "other implementation" if `f(self)` evaluates to True?

I am pretty sure that one can use lazy_attribute behind the scenes, and the job of ``@`conditionally_defined` would be to create this lazy attribute, so that the user does not need to do it.


---

Comment by nthiery created at 2013-08-16 11:04:10

Replying to [comment:3 SimonKing]:
> Do I understand correctly that you want the following behaviour:
> {{{
> #!python
> class A(object):
>     def my_method(self, *args,**kwargs):
>         <default_implementation>
> class B(A):
>     `@`conditionally_defined(f)
>     def my_method(self, *args,**kwargs):
>         <other implementation>
> }}}
> such that the default implementation is used when `f(self)` evaluates to False (or an attribute error is raised if the the `super(B,B)` does not define `my_method`), and uses the specialised "other implementation" if `f(self)` evaluates to True?

+1

> I am pretty sure that one can use lazy_attribute behind the scenes,
> and the job of ``@`conditionally_defined` would be to create this lazy
> attribute, so that the user does not need to do it.

Definitely!

Cheers,
                          Nicolas


---

Comment by SimonKing created at 2013-08-16 11:06:47

I found out how to deal with cached special (= double underscore) methods -- see #12601. So, I will attempt to make the new decorator work with special methods as well.


---

Comment by SimonKing created at 2013-08-16 11:13:37

What about the documentation? Of course, if we have an instance x and a conditionally defined method meth, then `x.meth` will be a specific implementation, and we get its documentation. But what shall be the documentation of `x.__class__.meth`?

In the simplest approach, it would be the documentation of the default method.

In a less simple approach, it would prepend `"Conditionally defined method: "` to the doc string of the one of the methods (I guess the default is the method inherited from the super class).

In an even less simple approach, it would start with `"Conditionally defined method, choosing from methods with the following documentation:"`, followed by a concatenation of the doc string of the inherited method and the specialised method. The inherited method might be conditional, too. So, we might take care of nesting.

In the most complicated approach, we would even add the documentation of the choosing function to the documentation of the wrapped methods.


---

Comment by nthiery created at 2013-08-16 15:14:07

Replying to [comment:6 SimonKing]:
> What about the documentation? Of course, if we have an instance x and a conditionally defined method meth, then `x.meth` will be a specific implementation, and we get its documentation. But what shall be the documentation of `x.__class__.meth`?
> 
> In the simplest approach, it would be the documentation of the default method.
> 
> In a less simple approach, it would prepend `"Conditionally defined method: "` to the doc string of the one of the methods (I guess the default is the method inherited from the super class).
> 
> In an even less simple approach, it would start with `"Conditionally defined method, choosing from methods with the following documentation:"`, followed by a concatenation of the doc string of the inherited method and the specialised method. The inherited method might be conditional, too. So, we might take care of nesting.
> 
> In the most complicated approach, we would even add the documentation of the choosing function to the documentation of the wrapped methods.

Hmm, good point.

For now I would go for the simplest: just use the documentation of the
method. And add a recommendation that this documentation should
mention that the method is conditionally defined. A typical use case
would then be:


```
    `@`conditionally_defined(hasattr="bar")
    def product(self, x, y):
        """
	Return the product of `x` and `y`.

	.. NOTE::

	    This implementation uses ``self.product_on_basis`` and is
	    only defined if this method is defined.
	"""
	...
```


Once we will have some practical experience, it will be always time to
implement something more sophisticated if we fill it's really needed.

Cheers,
                     Nicolas


---

Comment by SimonKing created at 2013-08-16 16:09:58

Replying to [comment:7 nthiery]:
> For now I would go for the simplest: just use the documentation of the
> method.

Which of them? The one gotten from the super-class, or the one that will only be there under special conditions?


---

Comment by nthiery created at 2013-08-16 16:30:50

Replying to [comment:8 SimonKing]:
> Replying to [comment:7 nthiery]:
> > For now I would go for the simplest: just use the documentation of the
> > method.
> 
> Which of them? The one gotten from the super-class, or the one that will only be there under special conditions?

The one defined under the special condition (as in my example above).


---

Comment by SimonKing created at 2013-08-16 20:42:10

With the patch that I just attached, one can do the following:

```
sage: from sage.misc.conditionally_defined import conditionally_defined
sage: class C(object):     
....:     def some_method(self):
....:         print "method of C"
....:     def __hash__(self):
....:         print "hash of C"
....:         return int(3)
....:     
sage: class D(C):          
....:     `@`conditionally_defined(lambda x: x.con>0)
....:     def some_method(self):
....:         "some doc of some method of D"
....:         print "method of D"
....:     `@`conditionally_defined(lambda x: x.con<0)
....:     def __hash__(self):
....:         "some do of hash of D"
....:         print "hash of D"
....:         return int(14)
....:     
sage: class E(D):          
....:     `@`conditionally_defined(lambda x: x.con>0)
....:     def further_method(self):
....:         "doc of further method"
....:         print "no matter what"
....:     `@`conditionally_defined(lambda x: x.con==0)
....:     def some_method(self):
....:         "this is the doc of some method of E"
....:         print "method of E"
....:         
sage: x = E()
sage: y = E()
sage: z = E()
sage: x.con = 1
sage: y.con = -1
sage: z.con = 0
```


__"Normal" methods__

The implementation of `some_method` is correctly chosen, according to the value of `.con`:

```
sage: x.some_method()
method of D
sage: y.some_method()
method of C
sage: z.some_method()
method of E
```


If there is no definition available in the super-class, only the default method is used:

```
sage: x.further_method()
no matter what
sage: y.further_method()
no matter what
sage: z.further_method()
no matter what
```


__Documentation__

The attribute of the instance is the chosen implementation, thus documented accordingly. The documentation of the attribute of the class is given by the default implementation, and Sage also adds the documentation of the wrapper (I think this is the usual behaviour in Sage):

```
sage: x.some_method?
Type:       instancemethod
String Form:<bound method E.some_method of <__main__.E object at 0x55dfb10>>
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/devel/sage-main/<ipython-input-3-a00430d63569>
Definition: x.some_method(self)
Docstring:  some doc of some method of D
sage: y.some_method?
Type:       instancemethod
String Form:<bound method E.some_method of <__main__.E object at 0x55dfb50>>
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/devel/sage-main/<ipython-input-2-333131ba1041>
Definition: y.some_method(self)
Docstring:  x.__init__(...) initializes x; see help(type(x)) for signature
sage: z.some_method?
Type:       instancemethod
String Form:<bound method E.some_method of <__main__.E object at 0x55df750>>
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/devel/sage-main/<ipython-input-4-1bdca786a56b>
Definition: z.some_method(self)
Docstring:  this is the doc of some method of E
sage: E.some_method?
Type:       conditionally_defined
String Form:Conditionally defined method 'some_method'
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/local/lib/python2.7/site-packages/sage/misc/conditionally_defined.so
Definition: E.some_method(self, meth)
Docstring:  this is the doc of some method of E

Class Docstring:
   A wrapper for methods whose definition depends on the state of an
   instance
Call def:   E.some_method(self, meth)
sage: D.some_method?
Type:       conditionally_defined
String Form:Conditionally defined method 'some_method'
File:       /home/simon/SAGE/prerelease/sage-5.11.beta3/local/lib/python2.7/site-packages/sage/misc/conditionally_defined.so
Definition: D.some_method(self, meth)
Docstring:  some doc of some method of D

Class Docstring:
   A wrapper for methods whose definition depends on the state of an
   instance
Call def:   D.some_method(self, meth)
```


__Special methods__

The hash is correctly chosen for the instance, according to the value of the `.con` attribute:

```
sage: hash(x)
hash of C
3
sage: hash(y)
hash of D
14
sage: hash(z)
hash of C
3
```

I verified that the hash function is not created repeatedly. In particular, changing the value of the `.con ` attribute does not change the hash function---a conditional method is fixed once for all:

```
sage: z.con = -1
sage: hash(z)
hash of C
3
```

Only when we delete the stored choice of an implementation, the changed choice takes effect:

```
sage: del z.__hash__
sage: hash(z)
hash of D
14
```


Nicolas, does this sound like a solution to your feature request? Do you miss something?

We should look at timings, in particular for special methods, I should add documentation, and then you can review it.


---

Comment by nthiery created at 2013-08-17 07:28:57

Nice! this looks good!

Just being curious: does this play well with `@`cached_method? That is, can we do something like:

```
    `@`conditionally_defined(...)
    `@`cached_method
    def ...
```


Could you further implement the `has="..."` (or `hasattr="..."`) argument to ``@`conditionally_defined` as in the example of the ticket description?

The ticket description also mentions conditionally defined nested classes. I actually don't remember putting this there; did I really? Do we have any strong use case? Otherwise I guess we can postpone the feature.

Thanks!


---

Comment by SimonKing created at 2013-08-17 08:00:08

Replying to [comment:11 nthiery]:
> Just being curious: does this play well with `@`cached_method? That is, can we do something like:
> {{{
>     `@`conditionally_defined(...)
>     `@`cached_method
>     def ...
> }}}

Didn't try yet. Ideally, it would also work to do

```
    `@`cached_method
    `@`conditionally_defined
```

meaning that we have a cached method whose underlying implementation depends on a condition. I.e., if the condition is not met, then the method inherited from the super-class is taken, and then cached (even when it is not cached in the super-class).
 
> Could you further implement the `has="..."` (or `hasattr="..."`) argument to ``@`conditionally_defined` as in the example of the ticket description?

I hope so.

> The ticket description also mentions conditionally defined nested classes. I actually don't remember putting this there; did I really? Do we have any strong use case? Otherwise I guess we can postpone the feature.

I think nobody has changed the ticket description after you created it :)

But anyway, I think it can not work with the current implementation, yet. Namely, if the condition is met, then the wrapped "function" will be turned into a bound method (by calling `types.MethodType`). I guess this would fail if the "function" is in fact a class.


---

Comment by nthiery created at 2013-08-17 11:22:46

Replying to [comment:12 SimonKing]:
> I think nobody has changed the ticket description after you created it :)
> 
> But anyway, I think it can not work with the current implementation, yet. Namely, if the condition is met, then the wrapped "function" will be turned into a bound method (by calling `types.MethodType`). I guess this would fail if the "function" is in fact a class.

Ok, just ignore this feature then.


---

Comment by SimonKing created at 2013-08-17 15:14:17

The problem with nested classes is that, if you define

```
class C:
    __metaclass__ = NestedClassMetaclass
    class D:
        pass
```

then _during creation of C_ (`NestedClassMetaclass.__init__(C)`) all attributes of C that are classes get their names changed (here: It becomes "C.D" instead of "D"). But if you pack the nested class into a conditionally_defined decorator, then `NestedClassMetaclass.__init__(C)` will not realise that D is a class, and will thus not change the name.

Moreover, at least in the current implementation, the conditionally_defined decorator operates with the name of the wrapped object. But if this name is not a valid attribute name (such as `"C.D"`) then the whole construction will fail anyway.

In any case, I think it would be more interesting to be able to conditionally define a cached method, in _both_ versions I suggested:

```
    `@`cached_method
    `@`conditionally_defined(...):
    def meth(...):
        ...
```

being a cached method whose underlying implementation is conditional, and

```
    `@`conditionally_defined(...):
    `@`cached_method
    def meth(...):
        ...
```

being a cached method that is only used conditionally.


---

Comment by SimonKing created at 2013-08-17 19:44:18

For now, I think nested classes won't work.

Replying to [comment:14 SimonKing]:
> In any case, I think it would be more interesting to be able to conditionally define a cached method, in _both_ versions I suggested:
> {{{
>     `@`cached_method
>     `@`conditionally_defined(...):
>     def meth(...):
>         ...
> }}}
> being a cached method whose underlying implementation is conditional, and
> {{{
>     `@`conditionally_defined(...):
>     `@`cached_method
>     def meth(...):
>         ...
> }}}
> being a cached method that is only used conditionally.

That's why I add #15056 as a dependency.


---

Comment by SimonKing created at 2013-08-18 16:49:49

At some point, I need to find out what class the default implementation is defined for, so that one can get the non-default implementation by a call to `super`. That's a problem. Currently, I go up the class hierarchy and test whether the conditionally_defined instance is in the `__dict__` of the class. But if the conditionally_defined instance is wrapped in a different wrapper (e.g., a cached_method), then this way of determining the class will fail.

I wonder if Python gives this information automatically, when it invokes `__get__`. To be investigated...


---

Comment by SimonKing created at 2013-08-18 17:25:29

With the latest version of #15056 and the patch that I have just attached, one can do (that's currently the only doctest):

```
    sage: from sage.misc.conditionally_defined import conditionally_defined
    sage: class A(object):
    ....:     `@`cached_method
    ....:     def method1(self, x):
    ....:         print "calling cached method1"
    ....:         return -x
    ....:     def method2(self, x):
    ....:         print "calling method2"
    ....:         return 2*x
    sage: class B(A):
    ....:     `@`conditionally_defined(lambda x: x.con>0)
    ....:     def method1(self, x):
    ....:         print "calling uncached method1"
    ....:         return x^2
    ....:     `@`cached_method
    ....:     `@`conditionally_defined(lambda x: x.con<0)
    ....:     def method2(self, x):
    ....:         print "calling alternative method2"
    ....:         return 2+x
    sage: x = B()
    sage: y = B()
    sage: x.con = 1
    sage: y.con = -1
```


The method `method1` of the two instances `x` or `y` is either a usual method,
or a cached method, depending on the value of the attribute `.con`:

```
    sage: x.method1
    <bound method B.method1 of <__main__.B object at ...>>
    sage: y.method1
    Cached version of <bound method B.method1 of <__main__.B object at ...>>
    sage: x.method1(3)
    calling uncached method1
    9
    sage: x.method1(3)
    calling uncached method1
    9
    sage: y.method1(3)
    calling cached method1
    -3
    sage: y.method1(3) is y.method1(3)
    True
```

The method `method2` is cached, but the underlying function of the cached
method is conditionally defined::

```
    sage: x.method2
    Cached version of <bound method B.method2 of <__main__.B object at ...>>
    sage: y.method2
    Cached version of <bound method B.method2 of <__main__.B object at ...>>
    sage: x.method2(3)
    calling method2
    6
    sage: x.method2(3) is x.method2(3)
    True
    sage: y.method2(3)
    calling alternative method2
    5
    sage: y.method2(3) is y.method2(3)
    True
```


Do you agree that this seems useful?


---

Comment by SimonKing created at 2013-08-18 17:28:48

Replying to [comment:16 SimonKing]:
> At some point, I need to find out what class the default implementation is defined for, so that one can get the non-default implementation by a call to `super`. That's a problem. Currently, I go up the class hierarchy and test whether the conditionally_defined instance is in the `__dict__` of the class. But if the conditionally_defined instance is wrapped in a different wrapper (e.g., a cached_method), then this way of determining the class will fail.
> 
> I wonder if Python gives this information automatically, when it invokes `__get__`. To be investigated...

PS: In my current patch, I trust that the class that Python gives as an argument to `__get__` is the class in which the object-to-be-bound is found. It seems to work.


---

Comment by SimonKing created at 2013-08-18 23:30:54

I updated the "proof of concept" again. In addition to the previous example, the implementation now plays well with the category framework. Namely, in the following example from the doctest, both the default and the non-default implementation of a conditionally defined method are defined in the element classes of categories, and the method which the implementation depends on is defined in the category, too.

Note that one can now provide either a function or a string to the decorator. In the latter case, it tests the instance for the presence of an attribute of the given name.

From the doctests:

```
    sage: from sage.misc.conditionally_defined import conditionally_defined
    sage: from sage.structure.element import Element
```

We define some category with some element method:

```
    sage: class MyCategory(Category):
    ....:     def super_categories(self):
    ....:         return [Objects()]
    ....:     class ElementMethods:
    ....:         def conditional_method(self, x):
    ....:             print "this works without helper"
    ....:             return -x
```

Next, we define a sub-category in which the afore-mentioned element class is
overloaded, provided that the element has an attribute `"helper"`:

```
    sage: class MySubCategory(Category):
    ....:     def super_categories(self):
    ....:         return [MyCategory()]
    ....:     class ElementMethods:
    ....:         `@`conditionally_defined("helper")
    ....:         def conditional_method(self, x):
    ....:             return self.helper(x)^2
```

We define a third category that provides an element method called `"helper"`:

```
    sage: class MyHelperCategory(Category):
    ....:    def super_categories(self):
    ....:        return [Objects()]
    ....:    class ElementMethods:
    ....:         def helper(self, x):
    ....:             print "category helper"
    ....:             return x*2
```

For using a conditionally defined method, it is necessary to either be able to
assign attributes to the instance, or there must be a public attribute
`__cached_methods` of type `<dict>`. Therefore, we create a Python version
of `sage.structure.element.Element`:

```
    sage: class MyElement(Element): pass
```

We define two parents. Both are objects of our second category, which
conditionally overloads an element method. Only the parent `P2` is also an
object of the "helper category", which provides the prerequisite of
overloading the conditional element method:

```
    sage: P1 = Parent(category=MySubCategory())
    sage: P2 = Parent(category=Category.join([MySubCategory(),MyHelperCategory()]))
```

We show that inheritance of a conditionally defined method from a category
even works if the constructed elements are not instances of the category's
element class:

```
    sage: e1 = MyElement(P1)
    sage: e2 = MyElement(P2)
    sage: isinstance(e1, e1.parent().category().element_class)
    False
    sage: isinstance(e2, e2.parent().category().element_class)
    False
```

Now, `e`` does not have a "helper" method, and thus its conditional method
relies on an implementation that does not ue the "helper". But `e2` does
have the "helper" method, and its conditional method makes use of it:

```
    sage: e1.conditional_method(2)
    this works without helper
    -2
    sage: e2.conditional_method(2)
    category helper
    16
```


Nicolas, do you think of further features or use cases? Otherwise, I think I should finalise the patch by adding docs and tests to every method.


---

Comment by nthiery created at 2013-08-19 13:00:04

Replying to [comment:18 SimonKing]:
> > At some point, I need to find out what class the default
> > implementation is defined for, so that one can get the non-default
> > implementation by a call to `super`. That's a problem. Currently,
> > I go up the class hierarchy and test whether the
> > conditionally_defined instance is in the `__dict__` of the
> > class. But if the conditionally_defined instance is wrapped in a
> > different wrapper (e.g., a cached_method), then this way of
> > determining the class will fail.

I haven't looked at the code; just wondering: since ``lazy_attribute``
is already doing something like this could this piece of work be
delegated to it?

> PS: In my current patch, I trust that the class that Python gives as
> an argument to `__get__` is the class in which the
> object-to-be-bound is found. It seems to work.

The Descriptor protocol is described quite in detail in
http://docs.python.org/2/howto/descriptor.html; maybe it says
something about this.


By the way: the

```
    `@`cached_method
    `@`conditionally_method
    ...
```

feature is nice looking for comprehensiveness, but I am really not
sure I have a real use case for it. So if dropping this feature makes
the code simpler, go for it.

Cheers,
                          Nicolas


---

Comment by nthiery created at 2013-08-19 13:01:51

Replying to [comment:19 SimonKing]:
> Nicolas, do you think of further features or use cases? Otherwise, I
> think I should finalise the patch by adding docs and tests to every
> method.

I think this looks great. Go ahead and finalize! Thanks!

(besides, I'd rather use your skills for #10963 :-))

Cheers,


---

Comment by SimonKing created at 2013-08-19 15:00:05

Replying to [comment:20 nthiery]:
> Replying to [comment:18 SimonKing]:
> > > At some point, I need to find out what class the default
> > > implementation is defined for, so that one can get the non-default
> > > implementation by a call to `super`. That's a problem. Currently,
> > > I go up the class hierarchy and test whether the
> > > conditionally_defined instance is in the `__dict__` of the
> > > class. But if the conditionally_defined instance is wrapped in a
> > > different wrapper (e.g., a cached_method), then this way of
> > > determining the class will fail.
> 
> I haven't looked at the code; just wondering: since ``lazy_attribute``
> is already doing something like this could this piece of work be
> delegated to it?

No, because `lazy_attribute` does not care about what is defined in the super-class. But the `conditionally_defined` decorator _has_ to care about what is defined in the super-class, and thus has to know "super with respect to WHAT class".

By the way, a simple lazy attribute would not work on special methods of instances of `<object>`.

> The Descriptor protocol is described quite in detail in
> http://docs.python.org/2/howto/descriptor.html; maybe it says
> something about this.

Thank you, I'll have a look
 
> 
> By the way: the
> {{{
>     `@`cached_method
>     `@`conditionally_method
>     ...
> }}}
> feature is nice looking for comprehensiveness, but I am really not
> sure I have a real use case for it.

No?? Well, you could of course obtain a similar behaviour if you use the `@`cached_method decorator _both_ on the default implementation and the non-default implementation:

```
class A(object):
    `@`cached_method
    def method1(self,...):
        ...
class B(A):
    `@`conditionally_defined(...)
    `@`cached_method
    def method1(self, ...):
        ...
```

This has _nearly_ the same effect as this:

```
class A(object):
    def method1(self,...):
        ...
class B(A):
    `@`cached_method
    `@`conditionally_defined(...)
    def method1(self, ...):
        ...
```


The difference between the two approaches is that in the second approach the class A has a non-cached method1. And perhaps it is intended that it does not have a cache.

> So if dropping this feature makes
> the code simpler, go for it.


```
`@`cached_method
`@`conditionally_defined(...)
```

is implemented in #15056 (which I think is useful independent of conditionally_defined).

```
`@`conditionally_defined(...)
`@`cached_method
```

is implemented here, and it does not pose an additional complication: We want (under a certain condition) to bind a method to an instance, and that's the same as binding a `CachedMethodCaller` to the instance.


---

Comment by SimonKing created at 2013-08-19 15:13:09

By the way, here is yet another example. This time, it is for a special Python method (`__len__`). 

Scenario: We have a class A, with `len` being implemented. But the instances are mutable. in a sub-class B, some instances are immutable (but not all). If an instance is immutable, we want that the length is cached (which is possible by #12601).

This can be done as follows:

```
sage: class A(object):
....:     def __init__(self, n):
....:         self.data = range(n)
....:     def __len__(self):
....:         return len(self.data)
sage: class B(A):                
....:     def __init__(self, n, immutable):
....:         A.__init__(self, n)
....:         if immutable:
....:             self.is_immutable = True
....:     `@`conditionally_defined("is_immutable")
....:     `@`cached_method
....:     def __len__(self):
....:         return super(B,self).__len__()
```

First of all, the length works for both mutable and "immutable" instances of B:

```
sage: a = B(3,False)
sage: b = B(5,True)
sage: len(a)
3
sage: len(b)
5
```

Of course, one can alter both instances, but we see that the length of b is cached, in contrast to the length of a:

```
sage: a.data.append(4)
sage: b.data.append(5)
sage: len(a)
4
sage: len(b)
5
sage: len(b.data)
6
```


Note that the cached length function is very fast. Compare with this:

```
sage: class C(object):
....:     def __len__(self):
....:         return int(5)
....:     
sage: c = C()
sage: len(c)
5
sage: len(b)
5
sage: %timeit len(c)
1000000 loops, best of 3: 793 ns per loop
sage: %timeit len(b)
1000000 loops, best of 3: 377 ns per loop
```


This is because a `CachedMethodCallerNoArgs` has Cython speed.


---

Comment by SimonKing created at 2013-08-19 15:47:19

Dear Nicolas,

Replying to [comment:22 SimonKing]:
> Replying to [comment:20 nthiery]:
> > The Descriptor protocol is described quite in detail in
> > http://docs.python.org/2/howto/descriptor.html; maybe it says
> > something about this.
> 
> Thank you, I'll have a look

I had, and it confirms that the current implementation is OK.


---

Comment by SimonKing created at 2013-08-22 12:48:08

I have attached a new patch version, and now I think the conditionally_defined wrapper is feature-complete. The documentation provides extensive tests.

Restriction:
- We *must* have new style classes, since for an old style class there seems to be no way to access the class hierarchy.

What one can do with the wrapper:
- It works on usual methods and special Python methods (`__hash__`, `__len__`, ...)
- It works well in combination with other wrappers such as cached_method and lazy_attribute.
- It works within the category framework. To make it work, if `B` is a class, `B.bar` must yield the wrapper and not the unbound method in default implementation.
- Even though `B.bar` is a wrapper, it behaves like an unbound method: When calling it like `B.bar(b, *args, **kwds)` with `b` an instance of `B` then it calls the default implementation on `b` with the given additional arguments. Note that this is not necessarily the same as `b.bar(*args,**kwds)`, because the latter may be the non-default implementation inherited from a super-class.
- Introspection works. Again, since `B.bar` is a wrapper and not an unbound method, we need some magic, namely methods `_sage_doc_`, `_sage_src_` etc.

The only thing I can currently think of that does not work:

```
class A(object):
    x = 5
class B(A):
    `@`conditionally_defined(lambda x: x.condition>0)
    x = 7
```

No idea how this can be made work.

I just realise that I forgot to add examples for the introspection method. Once they are added, it can be reviewed!


---

Comment by SimonKing created at 2013-08-22 12:48:08

Changing status from new to needs_review.


---

Comment by SimonKing created at 2013-08-22 13:02:07

To be reviewed


---

Attachment

OK, now the doctest coverage is complete. Ready for review!


---

Comment by SimonKing created at 2013-08-22 20:47:47

It isn't "wishlist" any more....


---

Comment by chapoton created at 2015-05-20 19:28:19

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2015-05-20 19:28:19

needs a git branch, if this is still of any pertinence
