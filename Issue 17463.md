# Issue 17463: wrong symbolic results in case the answer is not known

archive/issues_017463.json:
```json
{
    "body": "CC:  @eviatarbach tmonteil @slel @videlec\n\nA failing example is taken from \n\nhttp://ask.sagemath.org/question/10388/testing-inequalities-in-sage/\n\n```\n\nvar('a','b')\nbool( abs(a+b) <= abs(a) + abs(b) ) # False, expected True or 'Unknown'\nassert (not False == bool( abs(a+b) <= abs(a) + abs(b) ) ) #fails\n```\n\n\nsee also discussion at \nhttps://groups.google.com/d/msg/sage-devel/vNxnHSeRBW4/0OpeL0yv9YUJ\n\nIn that thread the exception variant is preferred in case of 'don't know'\n\nPlease also take into consideration Tristate variants\n( A sandbox for a Tristate class: \nhttps://github.com/jakobkroeker/Tristate.py )\n\nIssue created by migration from https://trac.sagemath.org/ticket/17700\n\n",
    "created_at": "2015-01-30T17:14:22Z",
    "labels": [
        "component: symbolics",
        "critical",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.8",
    "title": "wrong symbolic results in case the answer is not known",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17463",
    "user": "https://trac.sagemath.org/admin/accounts/users/jakobkroeker"
}
```
CC:  @eviatarbach tmonteil @slel @videlec

A failing example is taken from 

http://ask.sagemath.org/question/10388/testing-inequalities-in-sage/

```

var('a','b')
bool( abs(a+b) <= abs(a) + abs(b) ) # False, expected True or 'Unknown'
assert (not False == bool( abs(a+b) <= abs(a) + abs(b) ) ) #fails
```


see also discussion at 
https://groups.google.com/d/msg/sage-devel/vNxnHSeRBW4/0OpeL0yv9YUJ

In that thread the exception variant is preferred in case of 'don't know'

Please also take into consideration Tristate variants
( A sandbox for a Tristate class: 
https://github.com/jakobkroeker/Tristate.py )

Issue created by migration from https://trac.sagemath.org/ticket/17700





---

archive/issue_comments_233033.json:
```json
{
    "body": "Thanks for opening this ticket! I think this is a huge problem in Sage symbolics.\n\nI can't remember what I did to change the behaviour so that when a comparison is made and the result can't be determined it raises an exception instead of returning `False`; I'll try to look into it this weekend.\n\nI like the idea of having a three-valued logic (https://en.wikipedia.org/wiki/Three-valued_logic); unfortunately Python makes this very difficult, as the `Tristate` class shows. There does not seem to be an elegant solution, so I wonder if it's not just best to stick with exceptions.",
    "created_at": "2015-02-27T07:30:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17463#issuecomment-233033",
    "user": "https://github.com/eviatarbach"
}
```

Thanks for opening this ticket! I think this is a huge problem in Sage symbolics.

I can't remember what I did to change the behaviour so that when a comparison is made and the result can't be determined it raises an exception instead of returning `False`; I'll try to look into it this weekend.

I like the idea of having a three-valued logic (https://en.wikipedia.org/wiki/Three-valued_logic); unfortunately Python makes this very difficult, as the `Tristate` class shows. There does not seem to be an elegant solution, so I wonder if it's not just best to stick with exceptions.



---

archive/issue_comments_233034.json:
```json
{
    "body": "I'll gladly do a review of this ticket.",
    "created_at": "2015-02-27T09:21:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17463#issuecomment-233034",
    "user": "https://github.com/rwst"
}
```

I'll gladly do a review of this ticket.



---

archive/issue_comments_233035.json:
```json
{
    "body": "Btw., also the coercion framework occasionally leads to \"surprising\" results (because silently `False` is returned upon comparison when no coercion can be established, such that for example `a == b and a == c` doesn't imply `b == c`).  This and similar has been discussed on sage-devel a couple of times.",
    "created_at": "2015-05-13T12:54:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17463#issuecomment-233035",
    "user": "https://github.com/nexttime"
}
```

Btw., also the coercion framework occasionally leads to "surprising" results (because silently `False` is returned upon comparison when no coercion can be established, such that for example `a == b and a == c` doesn't imply `b == c`).  This and similar has been discussed on sage-devel a couple of times.



---

archive/issue_events_050647.json:
```json
{
    "actor": "https://github.com/nexttime",
    "created_at": "2015-05-13T12:54:50Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "milestone": "sage-6.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17463#event-50647"
}
```



---

archive/issue_comments_233036.json:
```json
{
    "body": "The ticket is about symbolics so let's get concrete. It happens that at the moment I'm implementing more logic affecting comparisons/relations/zero tests of expressions in Pynac. The decision process for the logic in Sage is:\n\n`Expression.__nonzero__()` is called on input of `bool`. `__nonzero__` is the one that should throw an exception for unknown results. In `__nonzero__`,\n1. first the relations of constants are decided\n2. Pynac's `relational_to_bool` is called (`relational::safe_bool()`), it does:\n   1. relations with one or two infinities; any result gets returned by `__nonzero__` right away\n   2. if l.h.s - r.h.s is a Python object (other than `Expression`) compare it to zero, i.e., delegate to the resp. class\n   3. else if relation is >= or <= use positive flag of (l.h.s - r.h.s) or its negative to decide (Pynac-0.3.9.3/0.4.3)\n3. the previous result may now get changed in case of not-equal; already here Maxima may be called (I think this is wrong, Maxima should always be the last resort)\n4. if no assumptions are needed now is time for `test_relation` which has some detailed logic and uses interval fields to disprove relations (\"interval fields never return false positives\"); it already has tristate logic by returning `NotImplemented` if unsure\n5. if the previous neither returns `True/False` return what `symbolic/relation.py:test_relation_maxima()` returns\n   1. the relation is tested and any `True` is returned immediately\n   2. simplification is attempted before returning the final `True/False`\n\nEDIT: `__nonzero__` is not called by Pynac\nEDIT: add info about upcoming Pynac snippet",
    "created_at": "2015-07-17T08:08:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17463#issuecomment-233036",
    "user": "https://github.com/rwst"
}
```

The ticket is about symbolics so let's get concrete. It happens that at the moment I'm implementing more logic affecting comparisons/relations/zero tests of expressions in Pynac. The decision process for the logic in Sage is:

`Expression.__nonzero__()` is called on input of `bool`. `__nonzero__` is the one that should throw an exception for unknown results. In `__nonzero__`,
1. first the relations of constants are decided
2. Pynac's `relational_to_bool` is called (`relational::safe_bool()`), it does:
   1. relations with one or two infinities; any result gets returned by `__nonzero__` right away
   2. if l.h.s - r.h.s is a Python object (other than `Expression`) compare it to zero, i.e., delegate to the resp. class
   3. else if relation is >= or <= use positive flag of (l.h.s - r.h.s) or its negative to decide (Pynac-0.3.9.3/0.4.3)
3. the previous result may now get changed in case of not-equal; already here Maxima may be called (I think this is wrong, Maxima should always be the last resort)
4. if no assumptions are needed now is time for `test_relation` which has some detailed logic and uses interval fields to disprove relations ("interval fields never return false positives"); it already has tristate logic by returning `NotImplemented` if unsure
5. if the previous neither returns `True/False` return what `symbolic/relation.py:test_relation_maxima()` returns
   1. the relation is tested and any `True` is returned immediately
   2. simplification is attempted before returning the final `True/False`

EDIT: `__nonzero__` is not called by Pynac
EDIT: add info about upcoming Pynac snippet



---

archive/issue_events_050648.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-07-19T16:10:08Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "milestone": "sage-6.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17463#event-50648"
}
```



---

archive/issue_events_050649.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-07-19T16:10:08Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "milestone": "sage-6.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/17463#event-50649"
}
```



---

archive/issue_comments_233037.json:
```json
{
    "body": "In https://github.com/pynac/pynac/issues/80 we implement multistate for item 2 above. The Sage part raises a `TypeError` with text `Undecidable relation: ...` if Pynac returns `undecidable` and continues on with item 3/4 in case of `not implemented`.",
    "created_at": "2015-07-19T16:10:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17463#issuecomment-233037",
    "user": "https://github.com/rwst"
}
```

In https://github.com/pynac/pynac/issues/80 we implement multistate for item 2 above. The Sage part raises a `TypeError` with text `Undecidable relation: ...` if Pynac returns `undecidable` and continues on with item 3/4 in case of `not implemented`.



---

archive/issue_comments_233038.json:
```json
{
    "body": "The second issue this ticket depends on concerns the Maxima interface in item 5. There is e.g.:\n\n```\nsage: from sage.symbolic.relation import test_relation_maxima\nsage: test_relation_maxima(I>0)\nFalse\n```\n\nbecause in Maxima\n\n```\n(%i8) is(%i>0);\n(%o8)                               false\n```\n\nso the 'false' result should raise a `NotImplementedError` in `__nonzero__` because Maxima does not distinguish between `false`, `known undecidable`, and `unknown`. This produces hundreds of doctest fails in `symbolics` alone.\n\nMoreover, trying to snatch this decision functionality from Maxima presupposes an independent assumption framework.\n\nEDIT: I is %i in Maxima",
    "created_at": "2015-07-20T07:54:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17463#issuecomment-233038",
    "user": "https://github.com/rwst"
}
```

The second issue this ticket depends on concerns the Maxima interface in item 5. There is e.g.:

```
sage: from sage.symbolic.relation import test_relation_maxima
sage: test_relation_maxima(I>0)
False
```

because in Maxima

```
(%i8) is(%i>0);
(%o8)                               false
```

so the 'false' result should raise a `NotImplementedError` in `__nonzero__` because Maxima does not distinguish between `false`, `known undecidable`, and `unknown`. This produces hundreds of doctest fails in `symbolics` alone.

Moreover, trying to snatch this decision functionality from Maxima presupposes an independent assumption framework.

EDIT: I is %i in Maxima



---

archive/issue_comments_233039.json:
```json
{
    "body": "I started doing some work on this. Since Sage already has an `Unknown` object for representing indeterminate truth values, I thought we could adapt it for use here. Ticket #20920 makes some changes to `Unknown` to raise an error when attempting to evaluate its truth value with `__nonzero__`, as well as adding an `Undecidable` object.",
    "created_at": "2016-07-02T00:20:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17463#issuecomment-233039",
    "user": "https://github.com/eviatarbach"
}
```

I started doing some work on this. Since Sage already has an `Unknown` object for representing indeterminate truth values, I thought we could adapt it for use here. Ticket #20920 makes some changes to `Unknown` to raise an error when attempting to evaluate its truth value with `__nonzero__`, as well as adding an `Undecidable` object.



---

archive/issue_comments_233040.json:
```json
{
    "body": "Great. See also #19040.",
    "created_at": "2016-07-02T04:51:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17463",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17463#issuecomment-233040",
    "user": "https://github.com/rwst"
}
```

Great. See also #19040.
