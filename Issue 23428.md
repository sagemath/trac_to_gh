# Issue 23428: Implement Frobenius formula for Hecke algebra characters

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2017-08-21 15:13:03

CC:  sage-combinat nthiery darij saliola zabrocki andrew.mathas

Keywords: Hecke algebra, characters, days88

This implements the basis qbar (as denoted by Ram-Remmel) for the ring of symmetric functions, which are q-deformations of the powersums. The character table for the Hecke algebra (with quadratic relation T<sup>2</sup> = (q-1)T + q) is obtained as the transition matrix from qbar to Schurs.


---

Comment by tscrim created at 2017-08-21 15:15:55

Changing status from new to needs_info.


---

Comment by tscrim created at 2017-08-21 15:15:55

I called the new basis "Hecke algebra characters," but that is not quite right. However, I am not sure what a better name would be. Any thoughts?
----
New commits:


---

Comment by zabrocki created at 2017-08-21 23:39:26

Its kind of hard to pick a better name from the Ram-Remmel paper.  I think it is the character of a (H_n(q),Gl_n) bi-module so the `hecke_character` basis is not necessarily a bad name, but that means you should be as verbose as possible with the documentation because I don't think that you are going to capture what basis represents in a short name.  I do think that the documentation should include equation (37) from the Remmel-Ram paper.

Try setting `q=-1` (or another root of unity not equal to 1).  It has a bit of a problem there.  There might be some speed-ups you can do over your current implementation because it is (up to constant) a plethysm of the complete basis, but its tough to implement that way if we have to be careful of the root of unity.  I'll try a few things and see if I can come up with something that avoids this problem, but it may not be a basis at a root of unity.


---

Comment by zabrocki created at 2017-08-22 00:50:59

Your conjectured formula for the coproduct is correct and can be derived from plethystic manipulation and equation (37) of Ram-Remmel (i.e. you can remove the warning).

```
qbar_n(X+Y) = h_n((X+Y)(1-1/q))q^n/(q-1) 
# \sum_{r=0}^n h_r(X(1-1/q)) h_{n-r}(Y(1-1/q)) q^n/(q-1)
   + h_n(X(1-1/q))q^n/(q-1) + h_n(Y(1-1/q))q^n/(q-1)
= \sum_{r=1}^{n-1} (q-1) qbar_r(X) qbar_{n-r}(Y) + qbar_n(X) + qbar_n(Y)
```



---

Comment by nthiery created at 2017-08-22 17:03:49

Sounds like a nice addition.

Just a suggestion: what about parametrizing the basis by the two roots  q1, q2 of the quadratic relation (with q2=-1 as default)? This would be consistent with what we did with the non symmetric macdonald polynomials and the `IwahoriHeckeAlgebra`.

Cheers,


---

Comment by zabrocki created at 2017-08-22 17:22:47

I've looked more closely and this set of functions is not a basis for q a root of unity, but rather than preventing the user from entering a root of unity you might want to have them act like the Hall-Littlewood Q basis at a root of unity. In fact, at q=-1 they span the same space of QQ[p_1, p_3, p_5, ...] = the space of Schur's Q functions.
I think that the most natural way of handling this will be to transform p_r -> qbar_\mu by the following relation:


```
(q^r-1)p_r = r*qbar_r - \sum_{i=1}^{r-1} (q-1)(q^i-1) p_i*qbar_{r-i}
```


To implement Nicolas' suggestion we would have to work out the Frobenius formula from the quadratic relation.


---

Comment by tscrim created at 2017-08-22 19:15:53

Replying to [comment:2 zabrocki]:
> Its kind of hard to pick a better name from the Ram-Remmel paper.  I think it is the character of a (H_n(q),Gl_n) bi-module so the `hecke_character` basis is not necessarily a bad name, but that means you should be as verbose as possible with the documentation because I don't think that you are going to capture what basis represents in a short name.  I do think that the documentation should include equation (37) from the Remmel-Ram paper.

Another name that is a little less descriptive but a little more accurate (IMO) would be "deformed powersum." However, I am not convinced that this would be a better name as it is somewhat generic.

> Try setting `q=-1` (or another root of unity not equal to 1).  It has a bit of a problem there.  There might be some speed-ups you can do over your current implementation because it is (up to constant) a plethysm of the complete basis, but its tough to implement that way if we have to be careful of the root of unity.  I'll try a few things and see if I can come up with something that avoids this problem, but it may not be a basis at a root of unity.

We might just want to let it fail with a warning in the documentation about certain values of q are bad (which is a theoretical issue because the Hecke algebra fails to be semisimple).

comment:3 Good to know. I will fix that on the next round of changes.


---

Comment by tscrim created at 2017-08-22 19:23:13

Replying to [comment:5 zabrocki]:
> I've looked more closely and this set of functions is not a basis for q a root of unity, but rather than preventing the user from entering a root of unity you might want to have them act like the Hall-Littlewood Q basis at a root of unity. In fact, at q=-1 they span the same space of QQ[p_1, p_3, p_5, ...] = the space of Schur's Q functions.

So basically do the generic computation and then substitute in. I had thought about that, but I wasn't sure if we wanted it because I wasn't sure if it would still form a basis at these special cases.

> I think that the most natural way of handling this will be to transform p_r -> qbar_\mu by the following relation:
> {{{
> (q^r-1)p_r = r*qbar_r - \sum_{i=1}^{r-1} (q-1)(q^i-1) p_i*qbar_{r-i}
> }}}

Do you think I should add that as an explicit transition morphism as well?

> To implement Nicolas' suggestion we would have to work out the Frobenius formula from the quadratic relation.

That was my thought as well. Andrew, do you by chance know or have a thought about this?


---

Comment by zabrocki created at 2017-08-22 19:46:40

> So basically do the generic computation and then substitute in. I had thought about that, but I wasn't sure if we wanted it because I wasn't sure if it would still form a basis at these special cases.

Well, I think that the generic computation and then specialized is one way of doing it, but maybe not the best.

> > I think that the most natural way of handling this will be to transform p_r -> qbar_\mu by the following relation:
> > {{{
> > (q^r-1)p_r = r*qbar_r - \sum_{i=1}^{r-1} (q-1)(q^i-1) p_i*qbar_{r-i}
> > }}}
> 
> Do you think I should add that as an explicit transition morphism as well?
I think if this transition is implemented (instead of inverting the morphism through the Schur basis) the transition to and from classical bases won't choke unless you start with something that is not in the space.  This is because if `q` is an r'th root of unity then `p_r` is not in the algebra generated by the `qbar_d` but then the coefficient of `p_r` is equal to 0 in all expressions where it appears (so there should be no intermediate steps in going from `p` to `qbar` where you need to divide by 0).

Sage doesn't handle roots of unity very well, but the case when `q=-1` is a well studied space.  The Hall-Littlewood Q-basis specializes to Schur's Q functions.  This is is not well documented in Sage but if you want to work with Schur's Q-functions, you also might want to use this `hecke_character` basis for the same reason.


---

Comment by tscrim created at 2017-08-22 19:53:31

Replying to [comment:8 zabrocki]:
> 
> > So basically do the generic computation and then substitute in. I had thought about that, but I wasn't sure if we wanted it because I wasn't sure if it would still form a basis at these special cases.
> 
> Well, I think that the generic computation and then specialized is one way of doing it, but maybe not the best.
> 
> > > I think that the most natural way of handling this will be to transform p_r -> qbar_\mu by the following relation:
> > > {{{
> > > (q^r-1)p_r = r*qbar_r - \sum_{i=1}^{r-1} (q-1)(q^i-1) p_i*qbar_{r-i}
> > > }}}
> > 
> > Do you think I should add that as an explicit transition morphism as well?
> I think if this transition is implemented (instead of inverting the morphism through the Schur basis) the transition to and from classical bases won't choke unless you start with something that is not in the space.  This is because if `q` is an r'th root of unity then `p_r` is not in the algebra generated by the `qbar_d` but then the coefficient of `p_r` is equal to 0 in all expressions where it appears (so there should be no intermediate steps in going from `p` to `qbar` where you need to divide by 0).

So maybe we do the generic and then specialize for the to/from Schur functions. Then to/from powersums, we use the formula recursively you give above. How does that sound?


---

Comment by nthiery created at 2017-08-22 20:00:12

Replying to [comment:7 tscrim]:
> > To implement Nicolas' suggestion we would have to work out the Frobenius formula from the quadratic relation.
> 
> That was my thought as well. Andrew, do you by chance know or have a thought about this?

In my experience with NS macdo, the formulas for q1,q2 are usually
fairly straightforward to reverse engineer when you have the formulas
for one of the specializations (typically by doing some rescaling of
the T operators). But your mileage may vary.


---

Comment by zabrocki created at 2017-08-22 20:33:13

Replying to [comment:9 tscrim]:
> So maybe we do the generic and then specialize for the to/from Schur functions. Then to/from powersums, we use the formula recursively you give above. How does that sound?

It may take a bit of experimenting to see what is fastest, but it might be that `s->p->qbar` without the generic `q` implementation is faster because inverting a matrix can be slow (and this one isn't triangular) while the `p` and `qbar` are multiplicative bases.


---

Comment by zabrocki created at 2018-04-10 19:03:24

I implemented the change of basis to the power sums because they are both multiplicative.  This is a significant speedup when the degree is large because there is no need to cache the whole change of basis matrix.

This basis does not play nice at roots of unity, so we can't really prevent users from raising errors if q is a root of unity, but my calculations do try to avoid raising errors by doing a few checks before dividing by something that might be 0.
----
New commits:


---

Comment by tscrim created at 2018-04-10 21:42:03

Changing status from needs_info to needs_review.


---

Comment by tscrim created at 2018-04-10 21:42:03

New commits:


---

Comment by git created at 2018-04-10 21:51:16

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2018-04-10 23:07:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2018-04-10 23:12:04

Changing status from needs_review to positive_review.


---

Comment by zabrocki created at 2018-04-10 23:15:38

Note that we did not figure out how to implement a second parameter (as Nicolas suggested in comment 4).  That will have to be left for a future ticket if someone knows the relationship.


---

Comment by vbraun created at 2018-05-08 17:26:23

Resolution: fixed
