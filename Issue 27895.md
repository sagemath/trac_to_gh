# Issue 27895: Avoid initialization of Pari at startup time

Issue created by migration from https://trac.sagemath.org/ticket/28132

Original creator: embray

Original creation time: 2019-07-08 09:00:29

CC:  slelievre mkoeppe

Keywords: pari

I know this is probably non-trivial, as use of Pari is deeply integrated into some modules.

But Pari is by several times the largest single contributor to (the already pretty bad) startup time of Sage on Windows:


```
$ sage -startuptime
## Slowest module imports (excluding / including children)
exclude/ms include/ms   #parents  module name
    24.187     69.950          9  sage.rings.polynomial.multi_polynomial_libsingular
    24.206     47.328          3  sage.graphs.generic_graph
    25.579    466.882         30  sage.matrix.all
    26.151    470.708        289  sage.structure.sage_object
    26.708     26.741          2  sage.parallel.parallelism
    26.780     26.780         43  math
    27.199     27.300          5  sage.libs.singular.singular
    28.246    231.436         14  sage.rings.number_field.number_field
    28.708     35.944          9  sage.combinat
    28.828     52.595          4  sage.structure.formal_sum
    28.856     28.856         53  operator
    29.700     40.641         52  functools
    30.051     30.051         98  sys
    30.725     79.078          2  sage.combinat.root_system
    31.102     31.169          1  sage.combinat.sloane_functions
    31.611     39.301          2  sage.matrix.matrix_mod2_dense
    31.917     31.926          3  pickle
    32.369     85.047         26  sage.combinat.partition
    32.700    247.176         80  sage.rings.ring
    32.745     45.383          4  sage.rings.finite_rings.finite_field_prime_modn
    33.524     43.634          1  xml.dom.minidom
    33.598    206.158         10  sage.modular.modform
    33.683     43.607          2  sage.quadratic_forms.ternary_qf
    37.933     37.933        115  sage.misc.lazy_import
    38.449    340.623         10  sage.interfaces.singular
    39.433     77.988          2  sage.rings.number_field
    39.848     74.714        124  collections
    42.590    114.996          2  sage.combinat.sf
    43.376     43.376        177  six
    45.717    101.240          3  sage.misc.package
    46.638     46.696          5  sage.schemes.projective.projective_subscheme
    47.261     63.320          5  sage.schemes.elliptic_curves
    52.661    198.099         11  sage.rings.polynomial
    53.674     53.962          3  sage.modular.arithgroup.arithgroup_element
    54.008     54.033         18  sage.plot.primitive
    54.895    158.730          3  sage.graphs
    55.323    168.474         21  sage.libs.pynac.pynac
    57.275     69.102          2  sage.combinat.designs.database
    57.565     69.089        178  six.moves
    59.939    171.751          3  psutil
    65.993     65.993         88  copy
    78.810    702.865         18  sage.rings
    81.084    175.522         14  sage.rings.qqbar
   101.130    101.130        590  __future__
   115.469    411.063          4  sage.matrix
   123.568    198.585         35  sage.env
   148.956    167.013         11  sage.interfaces.gap
   194.212  11545.261          5  sage.all
   473.093   4168.063        171  sage
  1360.117   1465.526         34  sage.libs.pari.all
Total time (sum over exclusive time): 11725.730ms
```


(Note: These times are especially bad right now as this computer is already being heavily tasked in the background, but in general this still holds true.)

I realize fully extracting pari from the Sage startup process is not trivial and possibly not even worth the effort.  But it's worth noting that this should be an area of focus for future lazy-import improvements.


---

Comment by jdemeyer created at 2019-07-08 09:13:03

How should I understand this? Would it be possible to profile `import sage.libs.pari` to see in detail what's taking all that time? For example, if it's the `virtual_memory_limit()` call, we could try to do something about that.

On Linux, `import sage.libs.pari` takes about 35ms, which is 2 orders of magnitude faster than on Windows.


---

Comment by embray created at 2019-07-08 11:23:59

Replying to [comment:1 jdemeyer]:
> How should I understand this? Would it be possible to profile `import sage.libs.pari` to see in detail what's taking all that time? For example, if it's the `virtual_memory_limit()` call, we could try to do something about that.
> 
> On Linux, `import sage.libs.pari` takes about 35ms, which is 2 orders of magnitude faster than on Windows.

Interesting...I can confirm about the same.  I (wrongly) assumed that maybe it took up a similar proportion of the time, even if less in overall magnitude, but indeed it's barely a significant portion at all.

Okay, being that it specifically bad on Windows I will concern myself less with mere initialization of pari at startup time, at least for now, and more on which part(s) is/are specifically slow on Windows.

Profiling something like this is slightly tricky: [line_profiler](https://github.com/rkern/line_profiler) can work well, but unfortunately not for profiling module-level code.  You have to wrap everything in functions to get it to work well, I've found.  Another way, which is annoying but usually effective for simple cases, is to just manually sprinkle `time()` calls and print statements about and manually do a binary-like search for which statements are taking the most time.


---

Comment by embray created at 2019-07-08 11:30:10

On my Linux machine, for comparison:


```
$ ./sage -startuptime
## Slowest module imports (excluding / including children)
exclude/ms include/ms   #parents  module name
     3.108      8.143          4  cypari2.pari_instance
     3.152      3.152          2  _ssl
     3.160     17.556         10  sage.interfaces.singular
     3.350     19.718         13  sage.rings.number_field.number_field
     3.374      3.685         28  sage.rings.real_double
     3.449      4.391          7  sage.misc
     3.455     29.250         11  sage.libs.gap.element
     3.505     15.184         20  inspect
     3.654      3.744          5  sage.libs.singular.singular
     3.678     10.988          3  sage.misc.package
     3.803      6.395        158  cysignals.signals
     3.804      3.972          3  sage.rings.polynomial.pbori
     3.867     13.187         38  cypari2.gen
     3.937      9.706          2  sage.rings.number_field
     3.981      4.629        175  six.moves
     4.173      4.266          3  sage.combinat.dyck_word
     4.224      4.230          1  platform
     4.235      4.308          1  sage.graphs.matchpoly
     4.250     17.076         53  sage.rings.polynomial.polynomial_ring_constructor
     4.250     14.122         26  sage.combinat.partition
     4.593      5.740          2  decimal
     4.614      6.759          9  sage.groups.perm_gps.permgroup
     4.891      5.379          4  sage.rings.finite_rings.finite_field_prime_modn
     4.915     10.995          9  sage.rings.polynomial.multi_polynomial_libsingular
     4.963      4.963        577  __future__
     4.974      8.472          3  sage.graphs.generic_graph
     5.034      6.896         28  sage.combinat.permutation
     5.471      6.025          2  sage.matrix.matrix_mod2_dense
     5.502      5.556          1  sage.combinat.sloane_functions
     5.576      6.110          9  sage.combinat
     5.623    115.652        237  sage.rings.integer
     5.813      7.458          5  sage.schemes.elliptic_curves
     5.841     26.203        172  sage.rings.integer_ring
     6.732     30.856         33  sage.libs.pari.all
     7.400     34.057          4  sage.matrix
     7.497     11.922         10  sage.interfaces.gap
     7.577     23.045          2  sage.combinat.sf
     7.646      7.752          2  sage.rings.complex_mpc
     8.013    235.740         16  sage.rings.complex_double
     8.047      8.590          2  tokenize
     9.808     23.963          3  sage.graphs
     9.838     11.370          2  sage.combinat.designs.database
    13.628     13.918          3  sage.modular.arithgroup.arithgroup_element
    17.845     35.725         80  sage.rings.ring
    22.151     45.101          3  psutil
    27.527     80.974         18  sage.rings
    31.641     45.886         14  sage.rings.qqbar
    37.474     54.964         21  sage.libs.pynac.pynac
    63.162    381.349        169  sage
   107.294   1154.145          5  sage.all
Total time (sum over exclusive time): 1175.664ms
```



---

Comment by embray created at 2019-07-08 12:45:57

Here's a result from line-profiling `_get_pari_instance`:


```
Timer unit: 1e-06 s

Total time: 1.31734 s
File: /home/embray/src/sagemath/sage/local/lib/python2.7/site-packages/sage/libs/pari/__init__.py
Function: _get_pari_instance at line 173

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   173                                           @profile
   174                                           def _get_pari_instance():
   175                                               # There are two constraints for the virtual stack size:
   176                                               # 1) on 32-bit systems, even virtual memory can be a scarce
   177                                               #    resource since it is limited by 4GB (of which the kernel
   178                                               #    needs a significant part)
   179                                               # 2) the system should actually be able to handle a stack size
   180                                               #    as large as the complete virtual stack.
   181                                               # As a simple heuristic, we set the virtual stack to 1/4 of the
   182                                               # virtual memory.
   183         1       2898.0   2898.0      0.2      from sage.misc.getusage import virtual_memory_limit
   184
   185         1     104868.0 104868.0      8.0      sizemax = virtual_memory_limit() // 4
   186
   187         1         11.0     11.0      0.0      from sage.env import CYGWIN_VERSION
   188         1          2.0      2.0      0.0      if CYGWIN_VERSION and CYGWIN_VERSION < (2, 5, 2):
   189                                                   # Cygwin's mmap is broken for large NORESERVE mmaps (>~ 4GB) See
   190                                                   # http://trac.sagemath.org/ticket/20463 So we set the max stack
   191                                                   # size to a little below 4GB (putting it right on the margin proves
   192                                                   # too fragile)
   193                                                   #
   194                                                   # The underlying issue is fixed in Cygwin v2.5.2
   195                                                   sizemax = min(sizemax, 0xf0000000)
   196
   197         1       1367.0   1367.0      0.1      from cypari2 import Pari
   198         1    1202219.0 1202219.0     91.3      P = Pari(1000000, sizemax)
   199
   200                                               # pari_init_opts() overrides MPIR's memory allocation functions,
   201                                               # so we need to reset them.
   202         1       5404.0   5404.0      0.4      from sage.ext.memory import init_memory_functions
   203         1          4.0      4.0      0.0      init_memory_functions()
   204
   205                                               # PARI sets debugmem=1 by default but we do not want those warning
   206                                               # messages in Sage.
   207         1        557.0    557.0      0.0      P.default("debugmem", 0)
   208
   209                                               # Make sure pari doesn't use threads, regardless of how it was compiled.
   210                                               # Threads cause some doctest failures (memory issues). Those could probably
   211                                               # be solved without disabling threads. But that would require figuring out
   212                                               # some sensible values for `threadsizemax`. See
   213                                               # https://pari.math.u-bordeaux.fr/dochtml/html/GP_defaults.html
   214         1          8.0      8.0      0.0      P.default("nbthreads", 1)
   215
   216         1          1.0      1.0      0.0      return P
```


Some chunk of the time is spent in `virtual_memory_limit()`, and that's worth looking into.  But the vast majority is actually spent in the `Pari()` initialization itself.


---

Comment by embray created at 2019-07-08 15:18:31

It seems the main culprit, not _too_ surprisingly, is `paristack_setsize` with a large `sizemax`.  If it's smaller, or if `rsize == vsize`, initialization takes mere milliseconds.

_Why_ it's so slow I'm not sure.  It could be a limitation of Cygwin or even Windows, though I do find it a bit strange.

Would it be possible, say, to start out with a very small pari stack, and then increase it later only when needed (or even do something like run a thread in the background to take care of that)?


---

Comment by jdemeyer created at 2019-07-08 19:04:54

I feel a blast from the past... the whole point of `parisizemax` is precisely to avoid resizing the stack on the fly. The idea is to allocate a large "virtual" stack with the intention of using only a small part of it, but having the possibility of using it all if needed.

Before `parisizemax` existed, I recall that Sage used to have a mechanism to retry failed PARI computations if it detected that the PARI stack overflowed. But thanks to `parisizemax`, we got rid of that hack. I'm not looking forward to putting that back.


---

Comment by embray created at 2019-07-09 10:53:14

Replying to [comment:7 jdemeyer]:
> I feel a blast from the past... the whole point of `parisizemax` is precisely to avoid resizing the stack on the fly. The idea is to allocate a large "virtual" stack with the intention of using only a small part of it, but having the possibility of using it all if needed.
> 
> Before `parisizemax` existed, I recall that Sage used to have a mechanism to retry failed PARI computations if it detected that the PARI stack overflowed. But thanks to `parisizemax`, we got rid of that hack. I'm not looking forward to putting that back.

Right, I understand, and I agree.  I wonder if there is some way to still enable that as-needed resizing at the cypari2 level in a manner that's reasonably transparent.  In principle it's good to be able to do anyways.


---

Attachment


---

Comment by jdemeyer created at 2019-07-09 10:55:38

The problem is that you can't know how much PARI stack you need in advance. If you're halfway a computation and suddenly the stack turns out to be too small, then what do you do?


---

Comment by embray created at 2019-07-09 10:57:24

After a bit of experimenting I found the awful truth, which is that on Cygwin (at least the current version I'm on (3.13.0-170)) the time taken for an anonymous `mmap` and `munmap` scales logarithmically (with munmap typically taking ~twice as long for some reason).

On Linux both are more-or-less instant no matter the size.

![](cygwin_mmap.png)


---

Comment by jdemeyer created at 2019-07-09 10:59:18

Thanks for that. Does it depend on the flags, in particular `MAP_NORESERVE`?


---

Comment by embray created at 2019-07-09 11:00:10

Replying to [comment:9 jdemeyer]:
> The problem is that you can't know how much PARI stack you need in advance. If you're halfway a computation and suddenly the stack turns out to be too small, then what do you do?

I guess I still don't know enough about how pari works to really be able to answer that.  What does "halfway [through] a computation" mean in this case?  If some operation fails due to being out of stack space, I thought it was possible to at least detect that, grow the stack, and start over from the last attempted operation (after all, exception handling of this kind is possible even at the assembly level).


---

Comment by jdemeyer created at 2019-07-09 11:03:55

Replying to [comment:12 embray]:
> If some operation fails due to being out of stack space, I thought it was possible to at least detect that, grow the stack

The problem is that you're not guaranteed that you can grow the stack in-place. And PARI doesn't support moving the stack (pointers would become invalid).

The `parisizemax` mechanism does precisely what you suggest, but it reserves a large portion of memory to be sure that the stack can be extended in-place.


---

Attachment


---

Comment by embray created at 2019-07-09 11:14:43

Replying to [comment:11 jdemeyer]:
> Thanks for that. Does it depend on the flags, in particular `MAP_NORESERVE`?

So with MAP_NORESERVE I get more-or-less the same log scaling (beyond sizes of a few MB) but still several orders of magnitude faster.

I also want to check whether this is endemic specifically to Cygwin, or to the underlying Windows API (`VirtualAlloc`).

![](cygwin_mmap_noreserve.png)


---

Comment by embray created at 2019-07-09 12:54:31

One thing that would be helpful is if the cypari interface had an easy way (as a method on the `Pari` class if possible) to resize the stack sizemax allocation later.  I know in principle it's already possible by manually re-calling `Pari.__init__`, but a more dedicated method would be clearer.

That way I could so something like start with a smaller stack (just for startup), but then resize it after Sage's initial startup is complete (how exactly that would work I'm not exactly sure yet; possibly in a thread...).


---

Comment by embray created at 2019-07-09 14:43:10

Looking yet again at `pari_mainstack_alloc`


```c
static void *
pari_mainstack_malloc(size_t size)
{
  /* Check that the system allows reserving "size" bytes. This is just
   * a check, we immediately free the memory. */
  void *b = mmap(NULL, size, PROT_READ|PROT_WRITE,
                             MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
  if (b == MAP_FAILED) return NULL;
  munmap(b, size);

  /* Map again, this time with MAP_NORESERVE. On some operating systems
   * like Cygwin, this is needed because remapping with PROT_NONE and
   * MAP_NORESERVE does not work as expected. */
  b = mmap(NULL, size, PROT_READ|PROT_WRITE,
                       MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);
  if (b == MAP_FAILED) return NULL;
  return b;
}
```


I wonder if the initial "check" is truly necessary.  Yes, it guarantees that the reserved range can theoretically fit in memory, but it makes no guarantee that that memory will be available later if you are overcommitting anyways.

On Windows it guarantees that at that moment I can commit that many pages of physical memory, but then we immediately give up that guarantee and just leave a range of virtual memory addressees reserved, but not the physical memory.  So a later allocation can still fail regardless.

I guess the point is you can prevent someone from allocating more stack than can ever theoretically possibly be used.  But at least in Sage we already doing that, essentially, by limiting the size to a fraction of `virtual_memory_limit()`.

So I wonder if there could be some way to disable this check.  Or at least disable it on Cygwin.  I'm not saying it's useless but it's not especially useful either, especially given the overhead it carries.


---

Comment by jdemeyer created at 2019-07-09 16:26:14

Replying to [comment:16 embray]:
> I wonder if the initial "check" is truly necessary.  Yes, it guarantees that the reserved range can theoretically fit in memory, but it makes no guarantee that that memory will be available later if you are overcommitting anyways.

You should see that initial check as a sanity check: if you're doing something silly like reserving a 1TB stack on a system with 4GB of RAM, you'll get an error there. But you are completely right that it doesn't give any guarantees.

> So I wonder if there could be some way to disable this check.  Or at least disable it on Cygwin.

I'm fine with putting that check inside a `#ifndef __CYGWIN__` (or whatever the right macro is).


---

Comment by mkoeppe created at 2020-09-23 17:58:32

Changing component from interfaces to porting: Cygwin.


---

Comment by embray created at 2021-03-10 15:33:48

I forgot all about this issue.  It should just require a simple patch to PARI.


---

Comment by embray created at 2021-03-10 15:33:48

Set assignee to embray.


---

Comment by embray created at 2021-08-18 16:23:40

Patch attached, finally.
----
New commits:


---

Comment by embray created at 2021-08-18 16:23:40

Changing status from new to needs_review.


---

Comment by embray created at 2021-08-18 16:26:32

Note, I have not tested this due to not having at the moment an up-to-date Cygwin build.  I hope to try it soon.


---

Comment by embray created at 2021-08-20 16:11:49

Seems to work, but based on the testing slelievre and I have done this patch might not be necessary anymore.  It doesn't seem that pari is as significant a startup time contributor as it used to be, and this patch doesn't seem to make a whole lot of difference.

I don't know if it's something cypari2 does differently, or it could be improvements in cygwin's mmap, or even changes in Windows that have sped this up.


---

Comment by embray created at 2021-08-20 16:17:14

It seems there have been recent improvements to Cygwin's mmap (thanks in part to new Windows APIs, when available).  In particular, this looks relevant: https://cygwin.com/git/?p=newlib-cygwin.git;a=blobdiff;f=winsup/cygwin/mmap.cc;h=feb9e5d0edfdec4f92803cd4fffcad6555e76fa2;hp=662489c8c74667744c5664490bd15391dd5ab3b5;hb=8d0a7701aa9e98bda511ba55f5f2dc210722d3e9;hpb=e18f7f99cc63520eca72b990cb73952ed22208e6


---

Comment by slelievre created at 2021-08-21 15:01:10

Some more startup related tickets:

- https://trac.sagemath.org/query?order=id&desc=1&summary=~startup&status=!closed


---

Comment by mkoeppe created at 2021-12-18 19:53:12

Stalled in `needs_review` or `needs_info`; likely won't make it into Sage 9.5.
