# Issue 21635: Conversion from a function field to its field of constants

archive/issues_021635.json:
```json
{
    "body": "Keywords: function field, conversion\n\nCurrently, there is no such conversion\n\n```\nsage: K.<x> = FunctionField(QQ)\nsage: K(1) in QQ\nFalse\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/21872\n\n",
    "created_at": "2016-11-13T14:12:15Z",
    "labels": [
        "component: commutative algebra",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.5",
    "title": "Conversion from a function field to its field of constants",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21635",
    "user": "https://github.com/saraedum"
}
```
Keywords: function field, conversion

Currently, there is no such conversion

```
sage: K.<x> = FunctionField(QQ)
sage: K(1) in QQ
False
```


Issue created by migration from https://trac.sagemath.org/ticket/21872





---

archive/issue_comments_300201.json:
```json
{
    "body": "New commits:",
    "created_at": "2016-11-13T14:56:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300201",
    "user": "https://github.com/saraedum"
}
```

New commits:



---

archive/issue_comments_300202.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-11-13T14:56:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300202",
    "user": "https://github.com/saraedum"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_300203.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-13T14:58:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300203",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_300204.json:
```json
{
    "body": "I ran doctests in `function_fields/`. The documentation builds without errors. Let's see whether the patchbot likes it as well\u2026",
    "created_at": "2016-11-13T15:06:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300204",
    "user": "https://github.com/saraedum"
}
```

I ran doctests in `function_fields/`. The documentation builds without errors. Let's see whether the patchbot likes it as well…



---

archive/issue_comments_300205.json:
```json
{
    "body": "Are you sure that installing a *conversion* map is the right solution? In many similar situations, there is no such map:\n\n\n```\nsage: K.<I>=NumberField(x^2+1)\nsage: K(1) in QQ\nTrue\nsage: QQ._convert_map_from_(K) == None\nsage: P.<t>=ZZ[]\nsage: P(1) in ZZ\nTrue\nsage: ZZ._convert_map_from_(P) == None\nTrue\nsage: L.<u>=FunctionField(QQ) #this is one of your cases\nsage: L(1) in QQ\nFalse\n```\n\n\nIt might be worth checking how these other cases succeed in making this work, and why they're doing it. It might be because their methods predate the coercion framework, but it might also be because introducing cycles in the conversion graph is not preferred.",
    "created_at": "2016-11-13T16:21:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300205",
    "user": "https://github.com/nbruin"
}
```

Are you sure that installing a *conversion* map is the right solution? In many similar situations, there is no such map:


```
sage: K.<I>=NumberField(x^2+1)
sage: K(1) in QQ
True
sage: QQ._convert_map_from_(K) == None
sage: P.<t>=ZZ[]
sage: P(1) in ZZ
True
sage: ZZ._convert_map_from_(P) == None
True
sage: L.<u>=FunctionField(QQ) #this is one of your cases
sage: L(1) in QQ
False
```


It might be worth checking how these other cases succeed in making this work, and why they're doing it. It might be because their methods predate the coercion framework, but it might also be because introducing cycles in the conversion graph is not preferred.



---

archive/issue_comments_300206.json:
```json
{
    "body": "nbruin: Thanks for having a look at this.\n\nConversion to `ZZ` works differently:\n\n```\nsage: sage: K.<I>=NumberField(x^2+1)\nsage: ZZ.convert_map_from(K)\n\nConversion via _integer_ method map:\n  From: Number Field in I with defining polynomial x^2 + 1\n  To:   Integer Ring\nsage: ZZ.convert_map_from(QQ)\n```\n\nSo, this path does not apply for function fields.\n\nAsking for a conversion to `QQ`:\n\n```\nsage: QQ.convert_map_from(K)\nConversion map:\n  From: Number Field in I with defining polynomial x^2 + 1\n  To:   Rational Field\n```\n\nso a `DefaultConvertMap_unique` which\n\n```\n    [\u2026] defers action to the codomain's\n    element_constructor method, WITHOUT passing in the codomain as the\n    first argument. [\u2026]\n```\n\ni.e., the target ring needs to understand what to do with the elements. I certainly do not want to teach the rational ring what a function field element is.\n\nFinally, cycles in conversions are no problem. Conversions are not automatically composed (unlike coercions.)",
    "created_at": "2016-11-13T17:15:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300206",
    "user": "https://github.com/saraedum"
}
```

nbruin: Thanks for having a look at this.

Conversion to `ZZ` works differently:

```
sage: sage: K.<I>=NumberField(x^2+1)
sage: ZZ.convert_map_from(K)

Conversion via _integer_ method map:
  From: Number Field in I with defining polynomial x^2 + 1
  To:   Integer Ring
sage: ZZ.convert_map_from(QQ)
```

So, this path does not apply for function fields.

Asking for a conversion to `QQ`:

```
sage: QQ.convert_map_from(K)
Conversion map:
  From: Number Field in I with defining polynomial x^2 + 1
  To:   Rational Field
```

so a `DefaultConvertMap_unique` which

```
    […] defers action to the codomain's
    element_constructor method, WITHOUT passing in the codomain as the
    first argument. […]
```

i.e., the target ring needs to understand what to do with the elements. I certainly do not want to teach the rational ring what a function field element is.

Finally, cycles in conversions are no problem. Conversions are not automatically composed (unlike coercions.)



---

archive/issue_comments_300207.json:
```json
{
    "body": "I believe that installing a conversion map down to the constant base field is necessary. For the intermediate fields, one could also change `_element_constructor_` to make sense of function field elements but then the `_to_constant_field` would get quite a bit more complicated.",
    "created_at": "2016-11-13T17:31:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300207",
    "user": "https://github.com/saraedum"
}
```

I believe that installing a conversion map down to the constant base field is necessary. For the intermediate fields, one could also change `_element_constructor_` to make sense of function field elements but then the `_to_constant_field` would get quite a bit more complicated.



---

archive/issue_comments_300208.json:
```json
{
    "body": "I agree with Julian that there's no problem having cycles in the conversion graph, and many rings in Sage with a concept of base ring have a conversion back to it for constants.\n\nJulian, have you looked at how this change impacts object creation time for function fields?  Maybe it would be better to implement this in `_convert_map_from_` rather than calling `register_conversion` in `__init__`.  I think `register_conversion` is available for end users who aren't able to modify `_convert_map_from_`.\n\nOtherwise, I'm happy with this change, and willing to give a positive review once we hear back from the patchbot.",
    "created_at": "2016-11-13T17:34:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300208",
    "user": "https://github.com/roed314"
}
```

I agree with Julian that there's no problem having cycles in the conversion graph, and many rings in Sage with a concept of base ring have a conversion back to it for constants.

Julian, have you looked at how this change impacts object creation time for function fields?  Maybe it would be better to implement this in `_convert_map_from_` rather than calling `register_conversion` in `__init__`.  I think `register_conversion` is available for end users who aren't able to modify `_convert_map_from_`.

Otherwise, I'm happy with this change, and willing to give a positive review once we hear back from the patchbot.



---

archive/issue_comments_300209.json:
```json
{
    "body": "For the conversion down to the constant base field, I do not really have an option. (I would have to change `_convert_map_from_` for `Field` or something similar.)\n\n\n```\nsage: K.<x> = FunctionField(QQ)\nsage: from sage.rings.function_field.function_field import FunctionField_polymod\nsage: K.<x> = FunctionField(QQ)\nsage: R.<y> = K[]\nsage: # work around caching by calling the class directly\nsage: %timeit FunctionField_polymod(y^2-x, 'y')\n```\n\nYes, object creation time does go up here from 332 \u00b5s to 555 \u00b5s. I am not sure if that is an issue. Function fields are cached after all, and I have a hard time imagining someone to create tons of them with different defining polynomials. I implemented this with `_convert_map_from_` on the level of function fields (but I still need the `register_conversion_map` for the constant base field) which gets this number down to 440 \u00b5s. Imho, the code is substantially less readable that way. So, about 110 \u00b5s seems to be the cost of a call to `register_conversion_map`.\n\nDavid, what do you think?",
    "created_at": "2016-11-13T18:20:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300209",
    "user": "https://github.com/saraedum"
}
```

For the conversion down to the constant base field, I do not really have an option. (I would have to change `_convert_map_from_` for `Field` or something similar.)


```
sage: K.<x> = FunctionField(QQ)
sage: from sage.rings.function_field.function_field import FunctionField_polymod
sage: K.<x> = FunctionField(QQ)
sage: R.<y> = K[]
sage: # work around caching by calling the class directly
sage: %timeit FunctionField_polymod(y^2-x, 'y')
```

Yes, object creation time does go up here from 332 µs to 555 µs. I am not sure if that is an issue. Function fields are cached after all, and I have a hard time imagining someone to create tons of them with different defining polynomials. I implemented this with `_convert_map_from_` on the level of function fields (but I still need the `register_conversion_map` for the constant base field) which gets this number down to 440 µs. Imho, the code is substantially less readable that way. So, about 110 µs seems to be the cost of a call to `register_conversion_map`.

David, what do you think?



---

archive/issue_comments_300210.json:
```json
{
    "body": "PS: I am planning to install another conversion down to the polynomial ring that is used to implement the elements of the function field, i.e., K(x) to K[x]. Here again, I won't have no choice but to register the conversion in `__init__`, so using `_convert_map_from_` is about 660 \u00b5s or 550 \u00b5s which does not look like that much of a difference anymore.",
    "created_at": "2016-11-13T18:35:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300210",
    "user": "https://github.com/saraedum"
}
```

PS: I am planning to install another conversion down to the polynomial ring that is used to implement the elements of the function field, i.e., K(x) to K[x]. Here again, I won't have no choice but to register the conversion in `__init__`, so using `_convert_map_from_` is about 660 µs or 550 µs which does not look like that much of a difference anymore.



---

archive/issue_comments_300211.json:
```json
{
    "body": "You're right that we'll need `register_conversion_map` for the constant field and for `K[x]`.  I'm fine with a 20% slowdown in parent creation for the sake of readibility, though I would be curious to know if Nils has use cases where he wants to create tons of different function fields and object creation is the bottleneck.  I guess another instance where your approach would cause problems is deeply nested relative extensions of function fields, where the total number of conversion maps created grows quadratically with the depth.  I don't think that's a common use case though....",
    "created_at": "2016-11-13T18:41:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300211",
    "user": "https://github.com/roed314"
}
```

You're right that we'll need `register_conversion_map` for the constant field and for `K[x]`.  I'm fine with a 20% slowdown in parent creation for the sake of readibility, though I would be curious to know if Nils has use cases where he wants to create tons of different function fields and object creation is the bottleneck.  I guess another instance where your approach would cause problems is deeply nested relative extensions of function fields, where the total number of conversion maps created grows quadratically with the depth.  I don't think that's a common use case though....



---

archive/issue_comments_300212.json:
```json
{
    "body": "Replying to [comment:11 roed]:\n> I would be curious to know if Nils has use cases where he wants to create tons of different function fields and object creation is the bottleneck.\n\nI don't have immediate examples, although I could imagine that fibred surfaces (either arithmetic or otherwise) might give rise to such a scenario. The bottleneck could arise if someone wants to try something really easy with the fibers, but ends up creating the fibers as curves and perhaps creating the function fields as an unintended side-effect. I don't know if the kind of slow-downs we're talking about here would be likely to be significant in such a setting.\n\n> I guess another instance where your approach would cause problems is deeply nested relative extensions of function fields, where the total number of conversion maps created grows quadratically with the depth.  I don't think that's a common use case though....\n\nIndeed, but I would suggest being a little conservative with implementing this. Can we first just install the conversion to the base ring and not transitively close over all the base rings below that?\n\nIncidentally, you have to be very careful about how you implement the conversion maps to the base rings. They will be cached on the codomain (i.e., on the base ring), so you should make sure you're *not* storing any references to the domain or its elements in the map object. All of that needs to be recovered from the argument (this is part of the reason why conversion to ZZ is implemented the way it is).\n\nOtherwise, you'll see that function fields over QQ end up not being garbage collected, because an eternal object (QQ) is keeping a reference to them in the form of registered conversion maps.\nThis is why maps in the coercion system do NOT store their domain. See #14711 for some of the black magic that was required.\n\nSo, one thing you should probably test is that\n\n```\nK.<t>=FunctionField(QQ)\nP.<X>=PolynomialRing(K)\nc=1\nwhile True:\n  L=K.extension(X^2-t^2+c*t)\n  u=QQ(L(1))\n```\n\ndoesn't leak.",
    "created_at": "2016-11-13T23:11:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300212",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:11 roed]:
> I would be curious to know if Nils has use cases where he wants to create tons of different function fields and object creation is the bottleneck.

I don't have immediate examples, although I could imagine that fibred surfaces (either arithmetic or otherwise) might give rise to such a scenario. The bottleneck could arise if someone wants to try something really easy with the fibers, but ends up creating the fibers as curves and perhaps creating the function fields as an unintended side-effect. I don't know if the kind of slow-downs we're talking about here would be likely to be significant in such a setting.

> I guess another instance where your approach would cause problems is deeply nested relative extensions of function fields, where the total number of conversion maps created grows quadratically with the depth.  I don't think that's a common use case though....

Indeed, but I would suggest being a little conservative with implementing this. Can we first just install the conversion to the base ring and not transitively close over all the base rings below that?

Incidentally, you have to be very careful about how you implement the conversion maps to the base rings. They will be cached on the codomain (i.e., on the base ring), so you should make sure you're *not* storing any references to the domain or its elements in the map object. All of that needs to be recovered from the argument (this is part of the reason why conversion to ZZ is implemented the way it is).

Otherwise, you'll see that function fields over QQ end up not being garbage collected, because an eternal object (QQ) is keeping a reference to them in the form of registered conversion maps.
This is why maps in the coercion system do NOT store their domain. See #14711 for some of the black magic that was required.

So, one thing you should probably test is that

```
K.<t>=FunctionField(QQ)
P.<X>=PolynomialRing(K)
c=1
while True:
  L=K.extension(X^2-t^2+c*t)
  u=QQ(L(1))
```

doesn't leak.



---

archive/issue_comments_300213.json:
```json
{
    "body": "Replying to [comment:12 nbruin]:\n> Incidentally, you have to be very careful about how you implement the conversion maps to the base rings. They will be cached on the codomain (i.e., on the base ring), so you should make sure you're *not* storing any references to the domain or its elements in the map object. All of that needs to be recovered from the argument (this is part of the reason why conversion to ZZ is implemented the way it is).\n\nGood point; I think the current implementation has this problem.\n\n> Otherwise, you'll see that function fields over QQ end up not being garbage collected, because an eternal object (QQ) is keeping a reference to them in the form of registered conversion maps.\n> This is why maps in the coercion system do NOT store their domain. See #14711 for some of the black magic that was required.\n\n#14711 is interesting.  I'll have to think about how that should affect conversions.  But the memory leak issue definitely should be addressed.\n\n> So, one thing you should probably test is that\n> {{{\n> K.<t>=FunctionField(QQ)\n> P.<X>=PolynomialRing(K)\n> c=1\n> while True:\n>   L=K.extension(X<sup>2-t</sup>2+c*t)\n>   u=QQ(L(1))\n> }}}\n> doesn't leak.\n\nI assume you want to increment `c` inside your loop.",
    "created_at": "2016-11-13T23:29:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300213",
    "user": "https://github.com/roed314"
}
```

Replying to [comment:12 nbruin]:
> Incidentally, you have to be very careful about how you implement the conversion maps to the base rings. They will be cached on the codomain (i.e., on the base ring), so you should make sure you're *not* storing any references to the domain or its elements in the map object. All of that needs to be recovered from the argument (this is part of the reason why conversion to ZZ is implemented the way it is).

Good point; I think the current implementation has this problem.

> Otherwise, you'll see that function fields over QQ end up not being garbage collected, because an eternal object (QQ) is keeping a reference to them in the form of registered conversion maps.
> This is why maps in the coercion system do NOT store their domain. See #14711 for some of the black magic that was required.

#14711 is interesting.  I'll have to think about how that should affect conversions.  But the memory leak issue definitely should be addressed.

> So, one thing you should probably test is that
> {{{
> K.<t>=FunctionField(QQ)
> P.<X>=PolynomialRing(K)
> c=1
> while True:
>   L=K.extension(X<sup>2-t</sup>2+c*t)
>   u=QQ(L(1))
> }}}
> doesn't leak.

I assume you want to increment `c` inside your loop.



---

archive/issue_comments_300214.json:
```json
{
    "body": "Note that #14711 has a TODO of adding an option to `register_conversion` to use weak references as well.  I think we need that option here, but that should solve the problem you've pointed out.",
    "created_at": "2016-11-14T00:35:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300214",
    "user": "https://github.com/roed314"
}
```

Note that #14711 has a TODO of adding an option to `register_conversion` to use weak references as well.  I think we need that option here, but that should solve the problem you've pointed out.



---

archive/issue_comments_300215.json:
```json
{
    "body": "> I assume you want to increment c inside your loop. \nyes, although I now realize that this ticket only seems to be dealing with rational function fields, so the test should be amended accordingly.\n\nReplying to [comment:14 roed]:\n> Note that #14711 has a TODO of adding an option to `register_conversion` to use weak references as well.  I think we need that option here, but that should solve the problem you've pointed out.\n\nYes, with the implementation of the conversion map proposed here, it should. I don't think the maps store any references to the domain internally. In the mean time, you should use something like\n\n```\n   phi = to_be_registered_map\n   phi._make_weak_references() #this should remove the strong references\n   K.register_conversion(phi)\n   del phi #or just make sure that phi doesn't escape elsewhere\n```\n",
    "created_at": "2016-11-14T01:20:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300215",
    "user": "https://github.com/nbruin"
}
```

> I assume you want to increment c inside your loop. 
yes, although I now realize that this ticket only seems to be dealing with rational function fields, so the test should be amended accordingly.

Replying to [comment:14 roed]:
> Note that #14711 has a TODO of adding an option to `register_conversion` to use weak references as well.  I think we need that option here, but that should solve the problem you've pointed out.

Yes, with the implementation of the conversion map proposed here, it should. I don't think the maps store any references to the domain internally. In the mean time, you should use something like

```
   phi = to_be_registered_map
   phi._make_weak_references() #this should remove the strong references
   K.register_conversion(phi)
   del phi #or just make sure that phi doesn't escape elsewhere
```




---

archive/issue_comments_300216.json:
```json
{
    "body": "Thanks for all the input. I had not thought about leaks here.\nSadly, `_make_weak_references()` does not do the trick.\nThe `register_convert_map` implementation has a line that says `self._convert_from_hash.set(mor.domain(),mor)` which does not seem to use weak references.",
    "created_at": "2016-11-14T19:43:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300216",
    "user": "https://github.com/saraedum"
}
```

Thanks for all the input. I had not thought about leaks here.
Sadly, `_make_weak_references()` does not do the trick.
The `register_convert_map` implementation has a line that says `self._convert_from_hash.set(mor.domain(),mor)` which does not seem to use weak references.



---

archive/issue_comments_300217.json:
```json
{
    "body": "Actually `_convert_from_hash` does use weak references, so it must be leaking somewhere else\u2026",
    "created_at": "2016-11-14T19:59:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300217",
    "user": "https://github.com/saraedum"
}
```

Actually `_convert_from_hash` does use weak references, so it must be leaking somewhere else…



---

archive/issue_comments_300218.json:
```json
{
    "body": "Ok. The problem is the `SetMorphism` that I have been using. The parameter `self._to_constant_base_field` that I pass in holds a reference to the function field. I am going to upload a version that uses a proper `FunctionFieldConversionToConstantBaseField` map. Also, I found a way to implement `_conversion_map_from_` that makes the code not unreadable.",
    "created_at": "2016-11-14T20:24:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300218",
    "user": "https://github.com/saraedum"
}
```

Ok. The problem is the `SetMorphism` that I have been using. The parameter `self._to_constant_base_field` that I pass in holds a reference to the function field. I am going to upload a version that uses a proper `FunctionFieldConversionToConstantBaseField` map. Also, I found a way to implement `_conversion_map_from_` that makes the code not unreadable.



---

archive/issue_comments_300219.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-14T20:34:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300219",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_300220.json:
```json
{
    "body": "This needs review again.",
    "created_at": "2016-11-14T20:34:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300220",
    "user": "https://github.com/saraedum"
}
```

This needs review again.



---

archive/issue_comments_300221.json:
```json
{
    "body": "Little doc nitpick:\n\n```\n+    def _to_base_field(self, f):\n...\n+        - ``f`` -- an element of this function field which is already defined\n+          over the base field\n```\n\nyou probably mean \"an element of the function field that lies in the base field\". All elements of the function field are defined *over* the base field by definition.\n\nElsewhere: be careful with calling subfields \"constants\". For instance, the function field `QQ(x)[y]/(y^2-2)` has as constant subfield `QQ(sqrt(2))`, whereas the base field is QQ. Finding the exact constant field (i.e., the algebraic closure of the base field in the function field) takes considerable computation, so I'm not sure this is part of the scope of this ticket.",
    "created_at": "2016-11-14T21:44:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300221",
    "user": "https://github.com/nbruin"
}
```

Little doc nitpick:

```
+    def _to_base_field(self, f):
...
+        - ``f`` -- an element of this function field which is already defined
+          over the base field
```

you probably mean "an element of the function field that lies in the base field". All elements of the function field are defined *over* the base field by definition.

Elsewhere: be careful with calling subfields "constants". For instance, the function field `QQ(x)[y]/(y^2-2)` has as constant subfield `QQ(sqrt(2))`, whereas the base field is QQ. Finding the exact constant field (i.e., the algebraic closure of the base field in the function field) takes considerable computation, so I'm not sure this is part of the scope of this ticket.



---

archive/issue_comments_300222.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-11-15T01:45:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300222",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_300223.json:
```json
{
    "body": "The patchbot complains about `modsym/space.py`. I checked locally and it works fine. (It would also have been very suprising if this made a difference there.)",
    "created_at": "2016-11-17T23:11:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300223",
    "user": "https://github.com/saraedum"
}
```

The patchbot complains about `modsym/space.py`. I checked locally and it works fine. (It would also have been very suprising if this made a difference there.)



---

archive/issue_comments_300224.json:
```json
{
    "body": "I'm happy with the changes.  Nils, thanks for the suggestions: feel free to add yourself as a reviewer.",
    "created_at": "2016-11-18T03:58:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300224",
    "user": "https://github.com/roed314"
}
```

I'm happy with the changes.  Nils, thanks for the suggestions: feel free to add yourself as a reviewer.



---

archive/issue_comments_300225.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-11-18T03:58:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300225",
    "user": "https://github.com/roed314"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_300226.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-11-19T22:09:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21635#issuecomment-300226",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_020437.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2016-11-19T22:09:44Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/21635",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/21635#event-20437"
}
```
