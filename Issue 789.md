# Issue 789: Can't create a submodule over a QQ[x]-module

Issue created by migration from Trac.

Original creator: justin

Original creation time: 2007-10-02 18:04:13

Assignee: was

Create a rank-3 free module M over QQ[x], get a random element, m, from M.  Then try to create the submodule generated by m.  SAGE complains that the module generated by 'm' is not a submodule of M:


```

sage: R1.<x>=PolynomialRing(QQ)
sage: M=FreeModule(R1,3)
sage: m=M.random_element()
sage: N=M.submodule([m])
---------------------------------------------------------------------------
<type 'exceptions.ArithmeticError'>       Traceback (most recent call last)

/SandBox/Justin/sb/sage-2.8.5.1/<ipython console> in <module>()

/SandBox/Justin/sb/sage-2.8.5.1/local/lib/python2.5/site-packages/sage/modules/free_module.py in submodule(self, gens, check, already_echelonized)
   1781         if check:
   1782             if not V.is_submodule(self):
-> 1783                 raise ArithmeticError, "gens does not generate a submodule of self"
   1784         return V
   1785 

<type 'exceptions.ArithmeticError'>: gens does not generate a submodule of self

```




---

Comment by justin created at 2007-10-02 19:30:30

Here's a partial explanation (more to come).

This works:


```
R1.<x>=PolynomialRing(QQ)
M=FreeModule(R1,3)
B=M.basis()
f1=R1.random_element()
f2=R1.random_element()
n1 = f1*B[0]
n2 = f2*B[1]
V3=M.span([n1,n2])
```


This (as above) is problematic:


```
m1 = M.random_element()
m2 = M.random_element()

V4 = M.submodule([m1,m2])
!!!Boom!!!
```


And, we see

```
sage: type(n1)
<type 'sage.modules.free_module_element.FreeModuleElement_generic_dense'>
sage: type(n1) == type(m1)
True
sage: m1.parent() == M
True
sage: n1.parent() == M
True
```



---

Comment by was created at 2007-10-03 01:56:01

The answer:


```
Don't have a patch yet, because I was playing fast and loose with the
source tree.  Here's the change I made:

Original code:
        x = self.fetch('echelon_form')
        if not x is None:
            return x
        R = self.base_ring()
        if not (R == ZZ or R.is_field()):
            try:
                E = self.matrix_over_field()
            except TypeError:
                raise NotImplementedError, "Echelon form not
implemented over '%s'."%R
        else:
            E = self.copy()
        if algorithm == 'default':
            E.echelonize(cutoff=cutoff)
        else:
            E.echelonize(algorithm = algorithm, cutoff=cutoff)

New code (bug commented out):
        x = self.fetch('echelon_form')
        if not x is None:
            return x
        R = self.base_ring()
#         if not (R == ZZ or R.is_field()):
#             try:
#                 E = self.matrix_over_field()
#             except TypeError:
#                 raise NotImplementedError, "Echelon form not
implemented over '%s'."%R
#         else:
#             E = self.copy()
        E = self.copy()
        try:
            if algorithm == 'default':
                E.echelonize(cutoff=cutoff)
            else:
                E.echelonize(algorithm = algorithm, cutoff=cutoff)
        except AttributeError, NotImplementedError:
            raise NotImplementedError, "Echelon form not implemented
over '%s'."%R

With this change, I get the correct answer with the polynomial
example and the ZZ example.

When I get a solid tree, I'll grind out a bundle and attach it to
Trac#789.

Justin

```



---

Comment by justin created at 2007-10-03 03:03:14

HG bundle fixing the bug


---

Attachment


---

Comment by was created at 2007-10-04 19:02:05

Resolution: fixed
