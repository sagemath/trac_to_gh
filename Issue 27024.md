# Issue 27024: Fix a memory leak in libsingular polynomial arithmetic

Issue created by migration from https://trac.sagemath.org/ticket/27261

Original creator: SimonKing

Original creation time: 2019-02-12 14:48:34

CC:  nbruin malb

Keywords: libsingular polynomial memleak

The following leaks (I tested in Py3, but in Py2 it's the same):

```
sage: R.<X,Y> = ZZ[]
sage: P = (X+Y)^120*Y^100
sage: import gc
sage: mem0 = get_memory_usage()
sage: for i in range(1000):
....:     Q = P(X,Y)
....:     del Q
....:     _ = gc.collect()
....:     mem1 = get_memory_usage()
....:     if mem1>mem0:
....:         print(i, mem1-mem0)
....:         mem0 = mem1
....:         
0 0.25
98 0.12890625
128 0.12890625
157 0.12890625
187 0.12890625
216 0.12890625
246 0.12890625
275 0.12890625
305 0.12890625
329 2.0
331 0.12890625
360 0.12890625
390 0.12890625
420 0.1328125
450 0.12890625
479 0.12890625
509 0.12890625
539 0.1328125
569 0.12890625
599 0.1328125
629 0.12890625
659 0.1328125
673 2.0
689 0.12890625
718 0.12890625
748 0.12890625
778 0.1328125
808 0.12890625
822 0.1953125
866 0.12890625
896 0.12890625
925 0.12890625
955 0.12890625
984 0.12890625
```


With #13447 in Py2, the leak is reduced, but still present:

```
sage: mem0 = get_memory_usage()
sage: for i in range(1000):
....:     Q = P(X,Y)
....:     del Q
....:     _ = gc.collect()
....:     mem1 = get_memory_usage()
....:     if mem1>mem0:
....:         print(i, mem1-mem0)
....:         mem0 = mem1
....:         
(147, 0.03125)
(176, 0.12890625)
(206, 0.12890625)
(235, 0.12890625)
(265, 0.12890625)
(294, 0.12890625)
(324, 0.12890625)
(329, 2.0)
(350, 0.12890625)
(379, 0.12890625)
(409, 0.12890625)
(438, 0.12890625)
(468, 0.12890625)
(497, 0.12890625)
(527, 0.12890625)
(556, 0.12890625)
(586, 0.12890625)
(615, 0.12890625)
(645, 0.12890625)
(672, 0.1328125)
(673, 2.0)
(705, 0.12890625)
(734, 0.12890625)
(764, 0.12890625)
(793, 0.12890625)
(823, 0.12890625)
(852, 0.12890625)
(882, 0.12890625)
(911, 0.12890625)
(941, 0.12890625)
(970, 0.12890625)
```


There is a worse leak (even with #13447):

```
sage: for i in range(1000):
....:     Q = P(X+Y,Y)
....:     del Q
....:     _ = gc.collect()
....:     mem1 = get_memory_usage()
....:     if mem1>mem0:
....:         print(i, mem1-mem0)
....:         mem0 = mem1
....:         
(0, 0.546875)
(2, 0.12890625)
(3, 0.2578125)
(4, 0.12890625)
(5, 0.2578125)
(6, 2.2578125)
(7, 0.12890625)
(8, 0.2578125)
(9, 0.2578125)
(10, 0.2578125)
(11, 0.12890625)
(12, 0.2578125)
(13, 2.265625)
(14, 0.12890625)
(15, 0.2578125)
(16, 0.2578125)
(17, 0.12890625)
(18, 0.2578125)
(19, 0.2578125)
(20, 0.12890625)
(21, 2.265625)
(22, 0.2578125)
(23, 0.12890625)
(24, 0.2578125)
(25, 0.2578125)
```


This was reported [on sage-devel](https://groups.google.com/forum/#!topic/sage-devel/iO1SzoW0kcw)


---

Comment by SimonKing created at 2019-02-12 16:21:08

For testing, I changed the code so that the `id()` of any newly created `MPolynomial_libsingular` instance is stored in some set, and is removed from the set as soon as it becomes garbage collected.

Result: In the above examples, the `MPolynomial_libsingular` instances are correctly garbage collected.

Conclusion: The memleak occurs in Sage's usage of libsingular. Apparently the underlying data of a polynomial are not correctly freed when it is deallocated.


---

Comment by SimonKing created at 2019-02-12 16:34:35

Or, another possibility: Some temporary libsingular data created during the computation of Q is not freed.

To detect this, I will try to make the example more fine-grained: Test if the leak occurs if the only arithmetic operation involved is `_add_`, `_mul_` or `__pow__`, respectively. `(X+Y)<sup>120*Y</sup>100` mixes these three operations.


---

Comment by SimonKing created at 2019-02-12 16:44:27

Interestingly, creating a copy of P from scratch does _not_ leak:

```
sage: import gc
sage: R.<X,Y> = ZZ[]
sage: P = (X+Y)^120*Y^100
sage: mem0 = get_memory_usage()
sage: for i in range(500):
....:     Q = (X+Y)^120*Y^100
....:     del Q
....:     _ = gc.collect()
....:     mem1 = get_memory_usage()
....:     if mem1>mem0:
....:         print(i, mem1-mem0)
....:         mem0 = mem1
....:         
(0, 0.1484375)
sage: 
```

So, it seems that calling the polynomial (i.e., `P(X,Y)`) is what is leaking!


---

Comment by SimonKing created at 2019-02-12 16:54:42

Note that there previously was a leak in polynomial evaluation, as by comment in `sage.libs.singular.polynomial.singular_polynomial_call` - see #16958. So, perhaps it didn't get completely fixed?


---

Comment by SimonKing created at 2019-02-12 17:07:20

`singular_polynomial_call` copies the input data before doing the actual call. This, I think, is a waste of time. I tested that taking the copy is _not_ causing the leak, but while we are at it, it could as well be improved, too.


---

Comment by SimonKing created at 2019-02-12 17:16:13

Also, `singular_polynomial_call` has an argument `poly *(*get_element)(object)` that is (at least in the Sage library) always assigned with the function `MPolynomial_libsingular_get_element`, which does nothing more than return the `._poly` of an `MPolynomial_libsingular`.

So, basically the `get_element` argument is void. Should it be removed?


---

Comment by embray created at 2019-03-25 10:56:15

Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)


---

Comment by embray created at 2019-06-14 14:54:19

As the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).


---

Comment by vdelecroix created at 2021-05-06 17:19:59

Stumble upon a similar problem using `.subs()`

```
sage: R.<X,Y> = ZZ[] 
....: import gc 
....: mem0 = get_memory_usage() 
....: for i in range(1000): 
....:     for _ in range(100): 
....:         _ = (X + Y).subs(X=X, Y=Y) 
....:     _ = gc.collect() 
....:     mem1 = get_memory_usage() 
....:     if mem1>mem0: 
....:         print(i, mem1-mem0) 
....:         mem0 = mem1                                                                                                                                                                      
78 0.1328125
100 0.1328125
121 0.12890625
142 0.12890625
164 0.1328125
172 2.0
185 0.12890625
206 0.12890625
228 0.1328125
...
```

See also https://ask.sagemath.org/question/29444/high-memory-usage-when-substituting-variables/


---

Comment by vdelecroix created at 2021-05-06 17:22:32

Since `__call__` calls `subs()` I gues the latter is the culprit.


---

Comment by vdelecroix created at 2021-05-07 08:05:08

New commits:


---

Comment by vdelecroix created at 2021-05-07 08:05:08

Changing status from new to needs_review.


---

Comment by vdelecroix created at 2021-05-07 08:05:08

Changing priority from major to critical.


---

Comment by git created at 2021-05-07 08:20:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-05-07 08:27:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by dimpase created at 2021-05-07 08:37:17

Does `gc.collect()` trigger Singular's GC - does it even have such an option?
It does its own memory management.


---

Comment by vdelecroix created at 2021-05-07 08:46:37

Replying to [comment:16 dimpase]:
> Does `gc.collect()` trigger Singular's GC - does it even have such an option?
> It does its own memory management.

What does this have to do with the problem? The `gc.collect()` can be removed from the snippets. They are here to guarantee that there is no undeleted temporary Python objects lying around and get consistent tests. You can crash sage with

```
sage: R = PolynomialRing(ZZ, 'x', 50)
sage: d = {str(g): g for g in R.gens()}
sage: p = sum(d.values())
sage: while True:
....:     _ = p.subs(**d)
```



---

Comment by dimpase created at 2021-05-07 12:20:31

Changing status from needs_review to needs_work.


---

Comment by dimpase created at 2021-05-07 12:20:31

The following 1-line patch fixes the leak from comment:10 and the 1st leak reported on the ticket.


```diff
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -3620,9 +3620,8 @@ cdef class MPolynomial_libsingular(MPolynomial):
                 res_id = fast_map_common_subexp(from_id, _ring, to_id, _ring)
                 _p = res_id.m[0]
 
-                from_id.m[0] = NULL
+                p_Delete(&from_id.m[0], _ring)
                 res_id.m[0] = NULL
-
                 id_Delete(&from_id, _ring)
                 id_Delete(&res_id, _ring)
 }}}

it does not fix the 2nd leak on the ticket, but I guess it might be that one needs to clean more of these `from_id` parts...


---

Comment by dimpase created at 2021-05-07 12:43:10

It'd be good to have more eyes on this, `subs()` code, preferably of people who wrote chunks of it.


---

Comment by git created at 2021-05-07 12:43:30

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2021-05-07 12:44:44

thx for your input!


---

Comment by vdelecroix created at 2021-05-07 12:44:44

Changing status from needs_work to needs_review.


---

Comment by dimpase created at 2021-05-07 12:46:41

Replying to [comment:17 vdelecroix]:
> Replying to [comment:16 dimpase]:
> > Does `gc.collect()` trigger Singular's GC - does it even have such an option?
> > It does its own memory management.
> 
> What does this have to do with the problem? The `gc.collect()` can be removed from the snippets. They are here to guarantee that there is no undeleted temporary Python objects lying around and get consistent tests. You can crash sage with
> {{{
> sage: R = PolynomialRing(ZZ, 'x', 50)
> sage: d = {str(g): g for g in R.gens()}
> sage: p = sum(d.values())
> sage: while True:
> ....:     _ = p.subs(**d)
> }}}

with the patch I just proposed this can be run seemingly forever, without showing any memory increase after few minutes of CPU time.


---

Comment by git created at 2021-05-07 12:55:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2021-05-07 12:56:20

Replying to [comment:22 dimpase]:
> Replying to [comment:17 vdelecroix]:
> > Replying to [comment:16 dimpase]:
> > > Does `gc.collect()` trigger Singular's GC - does it even have such an option?
> > > It does its own memory management.
> > 
> > What does this have to do with the problem? The `gc.collect()` can be removed from the snippets. They are here to guarantee that there is no undeleted temporary Python objects lying around and get consistent tests. You can crash sage with
> > {{{
> > sage: R = PolynomialRing(ZZ, 'x', 50)
> > sage: d = {str(g): g for g in R.gens()}
> > sage: p = sum(d.values())
> > sage: while True:
> > ....:     _ = p.subs(**d)
> > }}}
> 
> with the patch I just proposed this can be run seemingly forever, without showing any memory increase after few minutes of CPU time.

Very good. This is implemented in commit 19881aa.


---

Comment by dimpase created at 2021-05-07 13:35:13

seems to be a similar bug, from_id, to_id stuff  in `singular_polynomial_call`.
Here is how to trigger it there, (needs `--long`) 

```diff
--- a/src/sage/libs/singular/polynomial.pyx
+++ b/src/sage/libs/singular/polynomial.pyx
@@ -167,12 +167,12 @@ cdef int singular_polynomial_call(poly **ret, poly *p, ring *r, list args, poly
         sage: import gc
         sage: F.<a> = GF(7^2)
         sage: R.<x,y> = F[]
-        sage: p = x+2*y
+        sage: p = (x+2*y)^3
         sage: def leak(N):
         ....:     before = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
         ....:     gc.collect()
         ....:     for i in range(N):
-        ....:         _ = p(a, a)
+        ....:         _ = p(a+x, a)
         ....:     after = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
         ....:     return (after - before) * 1024   # ru_maxrss is in kilobytes
```


gives

```
File "src/sage/libs/singular/polynomial.pyx", line 187, in sage.libs.singular.polynomial.singular_polynomial_call
Failed example:
    for i in range(30):  # long time
        n = leak(10000)
        print("Leaked {} bytes".format(n))
        if n == 0:
            zeros += 1
            if zeros >= 6:
                break
        else:
            zeros = 0
Expected:
    Leaked...
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 0 bytes
Got:
    Leaked 6180864 bytes
    Leaked 3956736 bytes
    Leaked 3923968 bytes
    Leaked 3923968 bytes
...
```



---

Comment by git created at 2021-05-07 13:56:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2021-05-07 13:57:18

True. I moved my test over ZZ in the same file.


---

Comment by dimpase created at 2021-05-07 15:55:25

unfortunately I don't know how to fix the leak in `singular_polynomial_call()`. Trying to do something similar leads tp segfaults.


---

Comment by vdelecroix created at 2021-05-07 16:42:30

Thanks for trying. I update the description. Should we agree on the current status? Should we make it for sage-9.3?


---

Comment by git created at 2021-05-07 16:59:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mwageringel created at 2021-05-08 12:51:08

I believe this indicates that the problem is upstream, in `fast_map_common_subexp`. I have replaced the function by one that does nothing but return a copy of the original polynomial.


```diff
--- a/src/sage/libs/singular/polynomial.pyx
+++ b/src/sage/libs/singular/polynomial.pyx
@@ -173,8 +173,6 @@ cdef int singular_polynomial_call(poly **ret, poly *p, ring *r, list args, poly
         ....:     for i in range(N):
         ....:         _ = p(x, y)
         ....:         _ = p(x + y, y)
-        ....:         _ = p(1, -1)
-        ....:         _ = p(0, 0)
         ....:     gc.collect()
         ....:     after = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
         ....:     return (after - before) * 1024   # ru_maxrss is in kilobytes
@@ -185,7 +183,6 @@ cdef int singular_polynomial_call(poly **ret, poly *p, ring *r, list args, poly
         ....:     gc.collect()
         ....:     before = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
         ....:     for i in range(N):
-        ....:         _ = p(a, a)
         ....:         _ = p(x, y)
         ....:         _ = p(x + y, y)
         ....:         _ = p(a + x, a)
@@ -228,7 +225,7 @@ cdef int singular_polynomial_call(poly **ret, poly *p, ring *r, list args, poly
     from_id.m[0] = p

     rChangeCurrRing(r)
-    cdef ideal *res_id = fast_map_common_subexp(from_id, r, to_id, r)
+    cdef ideal *res_id = dummy_map_common_subexp(from_id, r, to_id)
     ret[0] = res_id.m[0]

     # Unsure why we have to normalize here. See #16958
@@ -243,6 +240,12 @@ cdef int singular_polynomial_call(poly **ret, poly *p, ring *r, list args, poly

     return 0

+# can fail if the result is expected to be constant
+cdef ideal *dummy_map_common_subexp(ideal *from_id, ring *r, ideal *to_id):
+    cdef ideal *res_id = idInit(1, 1)
+    res_id.m[0] = p_Copy(from_id.m[0], r)
+    return res_id
+
 cdef int singular_polynomial_cmp(poly *p, poly *q, ring *r):
     """
     Compare two Singular elements ``p`` and ``q`` in ``r``.
```



```
Got:
    Leaked 0 and 0 bytes
    Leaked 0 and 0 bytes
    Leaked 0 and 0 bytes
    Leaked 0 and 0 bytes
    Leaked 0 and 0 bytes
    Leaked 0 and 0 bytes
```



---

Comment by dimpase created at 2021-05-08 13:33:30

How does one convince the upstream? 
Would writing a C++ program using libsingular suffice?
Or a Singular example would be required?
It could be that Singular does not use this function the way it's used here.
In fact, in Singular it's only called at one place, once, in in `maMapIdeal()`
And the latter is only called once:

```
./Singular/ipshell.cc:  v->data=maMapIdeal(IDIDEAL(w), src_ring, (ideal)theMap, currRing,nMap);
```

in Singular's  shell, so it's probably not too hard to figure out the Singular command calling it.


---

Comment by git created at 2021-05-08 15:05:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2021-05-08 22:48:01

Singular's `subst()` leaks memory very fast, I don't know why we expect anything better from `libsingular`.
E.g.

```
ring r=0,(x,y),dp;
poly p=(x+y)^10;
while (1) {
subst(p,x,x+y);
}
```


takes 30 sec to reach many gigabytes.


---

Comment by vdelecroix created at 2021-05-09 07:54:23

I opened an issue on the singular side https://github.com/Singular/Singular/issues/1089.


---

Comment by vdelecroix created at 2021-05-09 08:24:58

Sage allows some weird things

```
sage: R.<x,y> = ZZ[]
sage: S.<q> = ZZ[]
sage: (x+y).subs(x=q)  # expected
Traceback (most recent call last):
...
TypeError: unsupported operand parent(s) for +:
  'Univariate Polynomial Ring in q over Integer Ring' and
  'Multivariate Polynomial Ring in x, y over Integer Ring'
sage: x.subs(x=q)  # why does it work!?
q
```



---

Comment by vdelecroix created at 2021-05-09 08:25:56

Replying to [comment:36 vdelecroix]:
> Sage allows some weird things
> {{{
> sage: R.<x,y> = ZZ[]
> sage: S.<q> = ZZ[]
> sage: (x+y).subs(x=q)  # expected
> Traceback (most recent call last):
> ...
> TypeError: unsupported operand parent(s) for +:
>   'Univariate Polynomial Ring in q over Integer Ring' and
>   'Multivariate Polynomial Ring in x, y over Integer Ring'
> sage: x.subs(x=q)  # why does it work!?
> q
> }}}

and even worse

```
sage: x(q, y)
q
```



---

Comment by vdelecroix created at 2021-05-09 08:51:06

Replying to [comment:37 vdelecroix]:
> Replying to [comment:36 vdelecroix]:
> > Sage allows some weird things
> > {{{
> > sage: R.<x,y> = ZZ[]
> > sage: S.<q> = ZZ[]
> > sage: (x+y).subs(x=q)  # expected
> > Traceback (most recent call last):
> > ...
> > TypeError: unsupported operand parent(s) for +:
> >   'Univariate Polynomial Ring in q over Integer Ring' and
> >   'Multivariate Polynomial Ring in x, y over Integer Ring'
> > sage: x.subs(x=q)  # why does it work!?
> > q
> > }}}
> 
> and even worse
> {{{
> sage: x(q, y)
> q
> }}}

https://groups.google.com/g/sage-devel/c/vGzNJKAQWbs


---

Comment by git created at 2021-05-19 06:29:50

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2021-05-19 06:33:46

Rebased on 9.3.

I implemented the proposal of Nils Bruin from the sage-devel thread to implement the generic `__call__`. The behaviour is doctested but it would even be better if it was part of the `TestSuite` (see #31668). The doctest fixes from 796e854 (modular forms on Hecke triangle groups) look a bit weird. But at least the output is still correct.


---

Comment by git created at 2021-05-19 08:46:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2021-05-19 13:20:49

testing https://github.com/Singular/Singular/issues/1089#issuecomment-844015795 now


---

Comment by vdelecroix created at 2021-05-19 13:41:17

Replying to [comment:43 dimpase]:
> testing https://github.com/Singular/Singular/issues/1089#issuecomment-844015795 now

Good idea. Thanks.


---

Comment by dimpase created at 2021-05-19 13:54:06

Unfortunately, this Singular patch only fixes the reported in https://github.com/Singular/Singular/issues/1089 problem, but not the leaks here.


---

Comment by vdelecroix created at 2021-05-19 17:06:28

Replying to [comment:46 dimpase]:
> Unfortunately, this Singular patch only fixes the reported in https://github.com/Singular/Singular/issues/1089 problem, but not the leaks here.

It would be nice to track the underlying singular issue. However, this should not hold the ticket any longer.


---

Comment by dimpase created at 2021-05-19 21:42:45

are the leaks in the ticket text now fixed?


---

Comment by vdelecroix created at 2021-05-20 06:24:42

Replying to [comment:48 dimpase]:
> are the leaks in the ticket text now fixed?

Both of them as explained in the ticket description (`subs` thanks to you and `__call__` via naive symbolic evaluation). Also they are both doctested.


---

Comment by dimpase created at 2021-05-20 09:32:38

Should we add the patch from  ​https://github.com/Singular/Singular/issues/1089  here?


---

Comment by vdelecroix created at 2021-05-20 11:54:43

Replying to [comment:50 dimpase]:
> Should we add the patch from  ​https://github.com/Singular/Singular/issues/1089  here?

According to your [comment:46] it does not solve the issue. So I don't see why we should only port this particular bug fix. Furthermore, we do not have any patch to singular in sage. Better keep it that way, no?


---

Comment by dimpase created at 2021-05-20 12:15:43

Replying to [comment:51 vdelecroix]:
> Replying to [comment:50 dimpase]:
> > Should we add the patch from  ​https://github.com/Singular/Singular/issues/1089  here?
> 
> According to your [comment:46] it does not solve the issue. So I don't see why we should only port this particular bug fix. Furthermore, we do not have any patch to singular in sage. Better keep it that way, no?

isn't the bug uncovered in https://github.com/Singular/Singular/issues/1089 sitting in Singular code used by Sage, and may re-surface if not patched?


---

Comment by vdelecroix created at 2021-05-20 12:24:02

Replying to [comment:52 dimpase]:
> Replying to [comment:51 vdelecroix]:
> > Replying to [comment:50 dimpase]:
> > > Should we add the patch from  ​https://github.com/Singular/Singular/issues/1089  here?
> > 
> > According to your [comment:46] it does not solve the issue. So I don't see why we should only port this particular bug fix. Furthermore, we do not have any patch to singular in sage. Better keep it that way, no?
> 
> isn't the bug uncovered in https://github.com/Singular/Singular/issues/1089 sitting in Singular code used by Sage, and may re-surface if not patched?

Maybe. I don't quite see the link with this ticket about `subs` and `__call__`. If you think it is worth adding this patch to singular, please open a ticket mentionning which issue it does solve on the sage side and create a branch.


---

Comment by dimpase created at 2021-05-20 16:03:09

here is another Singular leak demo, not fixed by the patch we discuss:

```
ring r;
map F=r,x+y+z3,y+z+x2z3,z+1+xyz;
poly f=(x+y+z+xz)^10;
matrix m=f;
matrix mm;
while (1) {mm=F(m);}
}}} 

here I checked that the code path goes through `fast_map_common_subexp()`, so this is another leak, hopefully just what we are fighting on this ticket.


---

Comment by dimpase created at 2021-05-20 16:07:23

I've opened  https://github.com/Singular/Singular/issues/1090


---

Comment by git created at 2021-05-23 07:41:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2021-05-23 19:12:05

Replying to [comment:55 dimpase]:
> I've opened  https://github.com/Singular/Singular/issues/1090

Apparently, partially fixed in [b983a8a](https://github.com/Singular/Singular/commit/b983a8a3c4c9303d054079a944ecab5d165f88d4).


---

Comment by @mwageringel created at 2021-05-27 18:26:58

This [ask-sage question](https://ask.sagemath.org/question/57281/performance-of-polynomialring-evaluation/) reports that there is also a performance problem with polynomial evaluation. Could this be related to the issue of this ticket? The example from the linked question is about 10 times slower than the naive Python substitution.


---

Comment by vdelecroix created at 2021-05-27 19:09:42

Replying to [comment:59 gh-mwageringel]:
> This [ask-sage question](https://ask.sagemath.org/question/57281/performance-of-polynomialring-evaluation/) reports that there is also a performance problem with polynomial evaluation. Could this be related to the issue of this ticket? The example from the linked question is about 10 times slower than the naive Python substitution.

This ticket is not about performance issue. But as I mentioned in the ask question switching to naive Python evaluation as done in my branch actually speeds up the evaluation.


---

Comment by vdelecroix created at 2021-05-28 07:33:03

ping?


---

Comment by dimpase created at 2021-05-28 09:05:57

testing...


---

Comment by dimpase created at 2021-05-28 12:05:28

lgtm


---

Comment by dimpase created at 2021-05-28 12:05:28

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2021-05-28 13:41:44

thx


---

Comment by dimpase created at 2021-05-28 18:14:53

one test broken on macOS:

```
File "src/sage/rings/polynomial/multi_polynomial_libsingular.pyx", line 153, in sage.rings.polynomial.multi_polynomial_libsingular
Failed example:
    for i in range(30):
        n = leak_subs(20)
        print("Leaked {} bytes".format(n))
        if n == 0:
            zeros += 1
            if zeros >= 6:
                print("done")
                break
        else:
            zeros = 0
Expected:
    Leaked ...
    ...
    Leaked 0 bytes
    done
Got:
    Leaked 184549376 bytes
    Leaked 12582912 bytes
    Leaked 4194304 bytes
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 8388608 bytes
    Leaked 0 bytes
    Leaked 37748736 bytes
    Leaked 0 bytes
    Leaked 4194304 bytes
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 4194304 bytes
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 4194304 bytes
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 37748736 bytes
    Leaked 4194304 bytes
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 4194304 bytes
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 37748736 bytes
    Leaked 4194304 bytes
    Leaked 0 bytes
    Leaked 0 bytes
    Leaked 4194304 bytes
**********************************************************************
1 item had failures:
   1 of  55 in sage.rings.polynomial.multi_polynomial_libsingular
```

(tested together with #30801, but I guess it doesn't matter.


---

Comment by dimpase created at 2021-05-28 18:14:53

Changing status from positive_review to needs_work.


---

Comment by vdelecroix created at 2021-05-28 19:11:54

The sagemath-singular interface is worse than what I thought. Switching to a generic `subs` function also leak!


---

Comment by git created at 2021-05-28 20:30:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2021-05-29 00:13:14

how about adding latest upstream fixes as patches?
