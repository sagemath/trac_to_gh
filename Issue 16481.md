# Issue 16481: Create a category for Cartesian products of groups

Issue created by migration from https://trac.sagemath.org/ticket/16718

Original creator: tscrim

Original creation time: 2014-07-27 01:29:00

Assignee: tscrim

CC:  ncohen nthiery

Keywords: cartesian product, generators, categories

We can define generators of a Cartesian (direct) product of groups as a Cartesian product of the generators with the identity elements. This will fix the issue noted in https://groups.google.com/forum/#!topic/sage-devel/nlRGZpr_Je8.

```
sage: AG=cartesian_product([CyclicPermutationGroup(5),CyclicPermutationGroup(4),CyclicPermutationGroup(4)])
sage: AG.group_generators()
...
AttributeError: 'CartesianProduct_with_category' object has no attribute 'gens'
sage: AG.j_classes()
...
AttributeError: 'CartesianProduct_with_category' object has no attribute 'gens'
```


We will do so by defining a general method in the appropriate category.


---

Comment by tscrim created at 2014-07-27 05:50:41

Changing status from new to needs_review.


---

Comment by tscrim created at 2014-07-27 05:50:41

This also works for infinitely generated groups, but it's a hack and is work very well. I've also copied this over to monoids as well. A note for the future, these functions should be split if we implement an axiom `FinitelyGenerated`.
----
New commits:


---

Comment by ncohen created at 2014-07-27 08:56:53

Helloooooooooooooooooo !!

Why do you need to implement the same function twice ? Isn't there a way to say that `group_generators = monoid_generators` ?

Nathann


---

Comment by ncohen created at 2014-07-27 20:59:46

Changing status from needs_review to needs_info.


---

Comment by tscrim created at 2014-07-27 21:54:01

It's better to have two separate functions because the number of generators as group is often smaller the number of generators as a monoid (usually by a factor of 2 since the inverses need to be included as generators of the monoid for torsion free generators) -- albeit Sage currently does not make a distinction, nor has the functionality I believe. Plus `group_generators` currently does not call `monoid_generators` and not all groups have a `monoid_generators` method.


---

Comment by tscrim created at 2014-07-27 21:54:01

Changing status from needs_info to needs_review.


---

Comment by ncohen created at 2014-07-28 09:24:41

Hello !
> It's better to have two separate functions because the number of generators as group is often smaller the number of generators as a monoid (usually by a factor of 2 since the inverses need to be included as generators of the monoid for torsion free generators) -- albeit Sage currently does not make a distinction, nor has the functionality I believe. 

The code that only exists in your head again ....

> Plus `group_generators` currently does not call `monoid_generators` and not all groups have a `monoid_generators` method.

Why don't all groups have a `monoid_generators` method ? They are monoids, aren't they ?

Nathann


---

Comment by tscrim created at 2014-07-28 17:25:04

Replying to [comment:5 ncohen]:
> The code that only exists in your head again ....

There's thousands of lines by hundreds of people. `:p`

> > Plus `group_generators` currently does not call `monoid_generators` and not all groups have a `monoid_generators` method.
> 
> Why don't all groups have a `monoid_generators` method ? They are monoids, aren't they ?

Yes, but as I stated above, there are often more generators as a monoid than as a group. For example, take `ZZ` under addition, there is 1 generator as a group (`+1`) but 2 generators as a monoid (`+/-1`). However for C<sub>n</sub> (cyclic group), the generators as a group and as a monoid are the same. I guess we could define the monoid generators as the group generators and their inverses as a general method for general groups and for finite groups, the generators as a group also generate as a monoid. This is now #16725.

As for why this is not there for many groups is that they were implemented before monoids were considered in Sage (I believe).


---

Comment by ncohen created at 2014-07-28 19:35:38

Hello !!

Could you add doctests for the infinite case ?

Also, why `M.monoid_generators().cardinality() != float('inf')` instead of `M.monoid_generators().is_finite()` ?

Nathann


---

Comment by git created at 2014-07-29 21:06:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-07-29 21:15:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-07-29 21:19:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-07-29 21:21:15

Replying to [comment:7 ncohen]:
> Could you add doctests for the infinite case ?

Done.

> Also, why `M.monoid_generators().cardinality() != float('inf')` instead of `M.monoid_generators().is_finite()` ?

I've changed this to `in FiniteEnumeratedSets()` which is more restrictive, but it is safer. I've also added a second safety check in case `*_generators()` returns a tuple or a list (it shouldn't and maybe tuple/list should be considered as a objects in `FiniteEnumeratedSets()`?).


---

Comment by ncohen created at 2014-07-29 21:39:55

Yo.

> I've changed this to `in FiniteEnumeratedSets()` which is more restrictive, but it is safer.

It is also more costly. Really it would all be okay if this was compiled code, but I keep thinking of what happens when a line like 

```
if all(M.monoid_generators() in FiniteEnumeratedSets()
  or isinstance(M.monoid_generators(), (tuple, list)) for M in F):
  ret = [lift(i, gen) for i,M in enumerate(F) for gen in M.monoid_generators()]
```

is executed and it really is awful... `monoid_generators()` is called once or twice per factor, the caching mechanism does its job to return the pre-computed generators if necessary, `FiniteEnumeratedSets()` is also created at each turn and because it is a `UniqueRepresentation` of something there is a lookup going on there too....

> I've also added a second safety check in case `*_generators()` returns a tuple or a list (it shouldn't and maybe tuple/list should be considered as a objects in `FiniteEnumeratedSets()`?).

Don't know ... Then you would have stuff which is detected as `FiniteEnumeratedSet` but does not inherit the methods... Well...

Okay. Despite the fact that I really do not like categories and probably never will, thank you for fixing that, your patch does the job. Can you fix the broken doctests ? It can be set to `positive_review` afterwards.

Nathann


---

Comment by ncohen created at 2014-07-29 21:40:48

Sorry, I forgot to give you the files 

```
----------------------------------------------------------------------
sage -t --long algebras.py  # 1 doctest failed
sage -t --long covariant_functorial_construction.py  # 2 doctests failed
sage -t --long cartesian_product.py  # 3 doctests failed
----------------------------------------------------------------------
```



---

Comment by git created at 2014-07-29 22:00:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2014-07-29 22:10:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2014-07-29 22:12:05

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2014-07-29 22:12:05

Replying to [comment:12 ncohen]:
> It is also more costly. Really it would all be okay if this was compiled code, but I keep thinking of what happens when a line like 
> {{{
> if all(M.monoid_generators() in FiniteEnumeratedSets()
>   or isinstance(M.monoid_generators(), (tuple, list)) for M in F):
>   ret = [lift(i, gen) for i,M in enumerate(F) for gen in M.monoid_generators()]
> }}}
> is executed and it really is awful... `monoid_generators()` is called once or twice per factor, the caching mechanism does its job to return the pre-computed generators if necessary, `FiniteEnumeratedSets()` is also created at each turn and because it is a `UniqueRepresentation` of something there is a lookup going on there too....

I changed it to create `FiniteEnumeratedSets()` outside of the loop (its a micro-optimization: the result is cached and the number of factors is small). However `*_generators` is very rarely to be called twice and not short-circuit the `all` (because `*_generators` should return a `Family`), and it should be cached.

> Don't know ... Then you would have stuff which is detected as `FiniteEnumeratedSet` but does not inherit the methods... Well...

Another question for me to ask Nicolas next time I see him.

> Okay. Despite the fact that I really do not like categories and probably never will, thank you for fixing that, your patch does the job. Can you fix the broken doctests ? It can be set to `positive_review` afterwards.

Thanks Nathann!


---

Comment by ncohen created at 2014-07-30 06:39:04

Yoooooooo !

> I changed it to create `FiniteEnumeratedSets()` outside of the loop (its a micro-optimization: the result is cached and the number of factors is small).

Thanks for that `:-)`

Nathann


---

Comment by vbraun created at 2014-07-31 00:44:28

Resolution: fixed
