# Issue 15144: gens() can mean both module and algebra generators, confusing morphism.pyx

archive/issues_015144.json:
```json
{
    "body": "CC:  @tscrim @xcaruso simonking @nthiery @mezzarobba\n\nKeywords: categories, gens, morphisms, modules\n\n\n```\nsage: D3 = GroupAlgebra(DihedralGroup(3), QQ)\nsage: from sage.categories.modules_with_basis import *\nsage: g = ModuleMorphismByLinearity(domain=D3, codomain=D3, on_basis=lambda x: (D3.zero() if list(x) == [] else D3.basis()[x]))\nsage: g.is_identity()\nTrue\n```\n\n\nOf course, `g` is not the identity. The culprit is here:\n\n\n```\n            gens = domain.gens()\n            for x in gens:\n                if self(x) != x:\n                    return False\n            return True\n```\n\n\nThis is part of the `is_identity` method in `sage/categories/morphism.pyx`. The assumption is that the `gens` method and the morphism refer to the same category, but here they don't: the morphism is a module morphism, while `D3.gens()` refers to the generators as algebra.\n\nNote that the equality check takes the other extreme and seems to only return `True` if the `on_basis` lambda functions of both morphisms are identical (i. e., I can add zero to each image and it doesn't return `True` anymore, even if they are identical).\n\nIssue created by migration from https://trac.sagemath.org/ticket/15381\n\n",
    "created_at": "2013-11-08T02:00:52Z",
    "labels": [
        "categories",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "gens() can mean both module and algebra generators, confusing morphism.pyx",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15144",
    "user": "@darijgr"
}
```
CC:  @tscrim @xcaruso simonking @nthiery @mezzarobba

Keywords: categories, gens, morphisms, modules


```
sage: D3 = GroupAlgebra(DihedralGroup(3), QQ)
sage: from sage.categories.modules_with_basis import *
sage: g = ModuleMorphismByLinearity(domain=D3, codomain=D3, on_basis=lambda x: (D3.zero() if list(x) == [] else D3.basis()[x]))
sage: g.is_identity()
True
```


Of course, `g` is not the identity. The culprit is here:


```
            gens = domain.gens()
            for x in gens:
                if self(x) != x:
                    return False
            return True
```


This is part of the `is_identity` method in `sage/categories/morphism.pyx`. The assumption is that the `gens` method and the morphism refer to the same category, but here they don't: the morphism is a module morphism, while `D3.gens()` refers to the generators as algebra.

Note that the equality check takes the other extreme and seems to only return `True` if the `on_basis` lambda functions of both morphisms are identical (i. e., I can add zero to each image and it doesn't return `True` anymore, even if they are identical).

Issue created by migration from https://trac.sagemath.org/ticket/15381





---

archive/issue_comments_194337.json:
```json
{
    "body": "Thinking about it, I'm not sure if `gens` can be trusted at all, particularly in the case of algebras over different ground rings. Radical suggestion: deprecate it in favor of `group_gens(self)`, `module_gens(self, base_ring)`, `ring_gens(self)` and `algebra_gens(self, base_ring)`?",
    "created_at": "2013-11-08T02:07:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15144",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15144#issuecomment-194337",
    "user": "@darijgr"
}
```

Thinking about it, I'm not sure if `gens` can be trusted at all, particularly in the case of algebras over different ground rings. Radical suggestion: deprecate it in favor of `group_gens(self)`, `module_gens(self, base_ring)`, `ring_gens(self)` and `algebra_gens(self, base_ring)`?



---

archive/issue_comments_194338.json:
```json
{
    "body": "Battle plan:\n\n- Wait for #10963 to be merged.\n\n- Define `monoid_gens(self)`, `group_gens(self)`, `module_gens(self, base_ring)`, `ring_gens(self)` and `algebra_gens(self, base_ring)`.\n\n- For every (relevant) category `C`, define a category-level method `C.object_gens(object)` that calls `object.[whatever]_gens()` where `[whatever]` is the name of the category.\n\n- Redefine `gens(self)` to only work in the case when `self` is DEFINED by generators and relations: for example, if `self` is defined as a polynomial ring (or a quotient thereof), then `gens(self)` should be the (projections of the) indeterminates; but when `self` is (say) a group algebra, `gens(self)` shouldn't be defined at all. For the sake of deprecation, don't actually throw errors but rather return the old result with a deprecation warning.\n\nWhat do you think?",
    "created_at": "2013-11-11T03:12:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15144",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15144#issuecomment-194338",
    "user": "@darijgr"
}
```

Battle plan:

- Wait for #10963 to be merged.

- Define `monoid_gens(self)`, `group_gens(self)`, `module_gens(self, base_ring)`, `ring_gens(self)` and `algebra_gens(self, base_ring)`.

- For every (relevant) category `C`, define a category-level method `C.object_gens(object)` that calls `object.[whatever]_gens()` where `[whatever]` is the name of the category.

- Redefine `gens(self)` to only work in the case when `self` is DEFINED by generators and relations: for example, if `self` is defined as a polynomial ring (or a quotient thereof), then `gens(self)` should be the (projections of the) indeterminates; but when `self` is (say) a group algebra, `gens(self)` shouldn't be defined at all. For the sake of deprecation, don't actually throw errors but rather return the old result with a deprecation warning.

What do you think?



---

archive/issue_comments_194339.json:
```json
{
    "body": "From emails between Nicolas and me:\n\n[Nicolas]\nDo you see other occurrences of this situation? Does it need to be\nhighlighted further right now? This topic is already touched a bit in\nthe discussion about \"the order of super categories\".\n\n[Darij]\n\"hom\" (as in \"PolynomialRing(QQ, 'x').hom\" or \"SymmetricGroup(3).hom\")\nis likely to lead to similar problems (not surprisingly as it relies\non \"gen\" -- it should be supplanted at the same time as \"gen\"). In\ncontrast, \"Hom\" (a method to generate the homspace rather than a\nsingle homomorphsim) is implemented semi-reasonably (it takes a\n\"category\" variable, but unfortunately it ducktypes it if it is not\nprovided, which allows for writing fragile code). Also, this is\nprecisely the type of issue I saw coming with Quotients -- although it\nwas mainly a guess since I don't know what infrastructure will\nactually come for those. More likely it won't be \"Quotients\" but\n\"quotient\" (on objects of categories) causing troubles, since the\n\"quotient of X by I\" depends on what category we consider X to be in.\nI'm not sure if \"extension\", \"cartesian_product\" and the likes will be\nproblematic (depends on how widely they are used). I would rather like\nto have these issues stressed in the documentation.\n\n[Nicolas]\nAgreed!!! They should all accept a category argument if they don't\nyet, and/or be split in separate methods like for algebra_generators\nand friends. And developers should specify the category explicitly\nwhenever there is an ambiguity (e.g. in generic code). I would not\ncall \"ducktyping\" the default category for hom(A,B) though: the\nsemantic is fully specified from A.category() and B.category(), and\nthose are set explicitly by A and B. It's just that you'd better know\nA and B well to predict the result :-)\n\nActually, for hom, you need not only a category argument but also an\nargument to specify how the morphism should be computed, as the two\nthings may differ. You typically may want to implement a Hopf algebra\nmorphism by linearity. For now we have a couple specialized methods\nlike \"module_morphism\", but the more systematic plan to tackle this is\nbriefly stated on:\n\n        http://trac.sagemath.org/ticket/10668#comment:17\n\n[Darij]\n\n\n> Agreed!!! They should all accept a category argument if they don't\n> yet, and/or be split in separate methods like for algebra_generators\n> and friends. And developers should specify the category explicitly\n> whenever there is an ambiguity (e.g. in generic code). I would not\n> call \"ducktyping\" the default category for hom(A,B) though: the\n> semantic is fully specified from A.category() and B.category(), and\n> those are set explicitly by A and B. It's just that you'd better know\n> A and B well to predict the result :-)\n\nYeah, but some constructors decide on the category of the object they\nconstruct at runtime, based on conditions like whether some parameter\ngiven is invertible or not. The category hierarchy is probably not at\nfault here; just saying that things will go wrong every once in a\nwhile.",
    "created_at": "2014-04-25T12:14:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15144",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15144#issuecomment-194339",
    "user": "@darijgr"
}
```

From emails between Nicolas and me:

[Nicolas]
Do you see other occurrences of this situation? Does it need to be
highlighted further right now? This topic is already touched a bit in
the discussion about "the order of super categories".

[Darij]
"hom" (as in "PolynomialRing(QQ, 'x').hom" or "SymmetricGroup(3).hom")
is likely to lead to similar problems (not surprisingly as it relies
on "gen" -- it should be supplanted at the same time as "gen"). In
contrast, "Hom" (a method to generate the homspace rather than a
single homomorphsim) is implemented semi-reasonably (it takes a
"category" variable, but unfortunately it ducktypes it if it is not
provided, which allows for writing fragile code). Also, this is
precisely the type of issue I saw coming with Quotients -- although it
was mainly a guess since I don't know what infrastructure will
actually come for those. More likely it won't be "Quotients" but
"quotient" (on objects of categories) causing troubles, since the
"quotient of X by I" depends on what category we consider X to be in.
I'm not sure if "extension", "cartesian_product" and the likes will be
problematic (depends on how widely they are used). I would rather like
to have these issues stressed in the documentation.

[Nicolas]
Agreed!!! They should all accept a category argument if they don't
yet, and/or be split in separate methods like for algebra_generators
and friends. And developers should specify the category explicitly
whenever there is an ambiguity (e.g. in generic code). I would not
call "ducktyping" the default category for hom(A,B) though: the
semantic is fully specified from A.category() and B.category(), and
those are set explicitly by A and B. It's just that you'd better know
A and B well to predict the result :-)

Actually, for hom, you need not only a category argument but also an
argument to specify how the morphism should be computed, as the two
things may differ. You typically may want to implement a Hopf algebra
morphism by linearity. For now we have a couple specialized methods
like "module_morphism", but the more systematic plan to tackle this is
briefly stated on:

        http://trac.sagemath.org/ticket/10668#comment:17

[Darij]


> Agreed!!! They should all accept a category argument if they don't
> yet, and/or be split in separate methods like for algebra_generators
> and friends. And developers should specify the category explicitly
> whenever there is an ambiguity (e.g. in generic code). I would not
> call "ducktyping" the default category for hom(A,B) though: the
> semantic is fully specified from A.category() and B.category(), and
> those are set explicitly by A and B. It's just that you'd better know
> A and B well to predict the result :-)

Yeah, but some constructors decide on the category of the object they
construct at runtime, based on conditions like whether some parameter
given is invertible or not. The category hierarchy is probably not at
fault here; just saying that things will go wrong every once in a
while.



---

archive/issue_comments_194340.json:
```json
{
    "body": "Replying to [comment:2 darij]:\n> Battle plan:\n> \n> - Wait for #10963 to be merged.\n> \n> - Define `monoid_gens(self)`, `group_gens(self)`, `module_gens(self, base_ring)`, `ring_gens(self)` and `algebra_gens(self, base_ring)`.\n\nFor the record: we already have `semigroup_generators`,\n`monoid_generators`, `group_generators`, `algebra_generators`,\n`basis`, etc. What we need is a more systematical use and\nadvertisement of them. In particular it should be made clear that gens\nis nothing but a short hand for casual interactive use, and should\n*not* be used in code.\n\n`module_generators`, `algebra_generators` and the like need not take a\nbase ring, since they are relative to the distinguished choice of base\nring in the parent.\n\n> - For every (relevant) category `C`, define a category-level method `C.object_gens(object)` that calls `object.[whatever]_gens()` where `[whatever]` is the name of the category.\n> \n> - Redefine `gens(self)` to only work in the case when `self` is DEFINED by generators and relations: for example, if `self` is defined as a polynomial ring (or a quotient thereof), then `gens(self)` should be the (projections of the) indeterminates; but when `self` is (say) a group algebra, `gens(self)` shouldn't be defined at all. For the sake of deprecation, don't actually throw errors but rather return the old result with a deprecation warning.\n\nA weaker step would be to just define `gens` in each category as an\nalias to the generators for this category. With that, gens would refer\nto the most specific one.  Nothing super robust, but sufficient for\ninteractive use.\n\nBy the way: it's best if all the '*_generators' methods would return\nfamilies.\n\nCheers,\n                                   Nicolas",
    "created_at": "2014-04-25T13:44:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15144",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15144#issuecomment-194340",
    "user": "@nthiery"
}
```

Replying to [comment:2 darij]:
> Battle plan:
> 
> - Wait for #10963 to be merged.
> 
> - Define `monoid_gens(self)`, `group_gens(self)`, `module_gens(self, base_ring)`, `ring_gens(self)` and `algebra_gens(self, base_ring)`.

For the record: we already have `semigroup_generators`,
`monoid_generators`, `group_generators`, `algebra_generators`,
`basis`, etc. What we need is a more systematical use and
advertisement of them. In particular it should be made clear that gens
is nothing but a short hand for casual interactive use, and should
*not* be used in code.

`module_generators`, `algebra_generators` and the like need not take a
base ring, since they are relative to the distinguished choice of base
ring in the parent.

> - For every (relevant) category `C`, define a category-level method `C.object_gens(object)` that calls `object.[whatever]_gens()` where `[whatever]` is the name of the category.
> 
> - Redefine `gens(self)` to only work in the case when `self` is DEFINED by generators and relations: for example, if `self` is defined as a polynomial ring (or a quotient thereof), then `gens(self)` should be the (projections of the) indeterminates; but when `self` is (say) a group algebra, `gens(self)` shouldn't be defined at all. For the sake of deprecation, don't actually throw errors but rather return the old result with a deprecation warning.

A weaker step would be to just define `gens` in each category as an
alias to the generators for this category. With that, gens would refer
to the most specific one.  Nothing super robust, but sufficient for
interactive use.

By the way: it's best if all the '*_generators' methods would return
families.

Cheers,
                                   Nicolas



---

archive/issue_comments_194341.json:
```json
{
    "body": "Related (duplicate?): #17768",
    "created_at": "2015-02-11T17:42:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15144",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15144#issuecomment-194341",
    "user": "@mezzarobba"
}
```

Related (duplicate?): #17768



---

archive/issue_comments_194342.json:
```json
{
    "body": "Replying to [comment:9 mmezzarobba]:\n> Related (duplicate?): #17768\n\nStrongly related, but not a duplicate as this could potentially be an issue in other parts of Sage.",
    "created_at": "2015-02-11T18:46:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15144",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15144#issuecomment-194342",
    "user": "@tscrim"
}
```

Replying to [comment:9 mmezzarobba]:
> Related (duplicate?): #17768

Strongly related, but not a duplicate as this could potentially be an issue in other parts of Sage.
