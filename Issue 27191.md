# Issue 27191: Invalid use of sig_on() in acb_calc_func_callback

Issue created by migration from https://trac.sagemath.org/ticket/27428

Original creator: jdemeyer

Original creation time: 2019-03-05 11:47:21

CC:  mmezzarobba

The function `acb_calc_func_callback` ends with a `sig_on()` statement. This makes absolutely no sense at all. This was introduced in #24686.


---

Comment by mmezzarobba created at 2019-03-05 13:34:46

Replying to [ticket:27428 jdemeyer]:
> The function `acb_calc_func_callback` ends with a `sig_on()` statement. This makes absolutely no sense at all (see https://cysignals.readthedocs.io/en/latest/interrupt.html#using-sig-on-and-sig-off).

Thanks for the notice. I think I'm unable to fix the issue by myself, unfortunately.

Is there a description of `sig_on()`/`sig_off()` that explains what they do and where the rules listed in the cysignal manual come from, instead of just saying what one should and shouldn't do? I don't remember the rule that “`sig_off()` should be called before the function that called `sig_on()` returns” being there when we wrote that code (but I may well have missed it).

What is the proper way to handle the case of (i) an external C library (ii) that performs callbacks into Python code (iii) but not very frequent ones, so that one would like the code running between two callbacks to be interruptible?


---

Comment by jdemeyer created at 2019-03-05 14:06:53

Replying to [comment:3 mmezzarobba]:
> Is there a description of `sig_on()`/`sig_off()` that explains what they do and where the rules listed in the cysignal manual come from

Not really, but the important bit to know is that it relies on `setjmp()`/`longjmp()`. So the restriction comes from `setjmp()`. From the [setjmp man page](http://man7.org/linux/man-pages/man3/setjmp.3.html):

```
If the function which called setjmp() returns before longjmp() is called, the behavior is undefined.
```


> I don't remember the rule that “`sig_off()` should be called before the function that called `sig_on()` returns” being there when we wrote that code

How old is your code? That piece of documentation dates from #10109 :-)

> What is the proper way to handle the case of (i) an external C library (ii) that performs callbacks into Python code (iii) but not very frequent ones, so that one would like the code running between two callbacks to be interruptible?

It's complicated. The hardest part is dealing with exceptions. I see that you already have provisions for that using the `ctx` object. An alternative way for dealing with exceptions is `sig_error()`. Note that you still have a lot of Python code unguarded by `try`/`except` which could raise exceptions (even an `assert` statement!).

The easy part is making sure that interrupts cannot happen while executing Python code. That can be done with `sig_block()`/`sig_unblock()`.


---

Comment by jdemeyer created at 2019-03-21 15:05:34

Wrong ticket?


---

Comment by @Hrishabh-yadav created at 2019-03-21 15:08:27

Replying to [comment:6 jdemeyer]:
> Wrong ticket?
I know, It was a mistake.. How do I remove a branch from a ticket


---

Comment by @Hrishabh-yadav created at 2019-03-21 15:10:56

Replying to [comment:7 gh-Hrishabh-yadav]:
> Replying to [comment:6 jdemeyer]:
> > Wrong ticket?
> I know, It was a mistake.. How do I remove a branch from a ticket
Thanks


---

Comment by embray created at 2019-03-25 10:56:15

Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)


---

Comment by embray created at 2019-06-14 14:54:19

As the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).
