# Issue 20492: doctest runner breaks loading modules from packages that use relative imports

Issue created by migration from Trac.

Original creator: embray

Original creation time: 2016-05-31 10:33:15

I encountered this issue when trying to run the doctests in a new sub-package I added to `sage_setup`, in which I used relative imports between the submodules.  Trying to run the doctests on these modules blows up with: `ValueError: Attempted relative import in non-package`

In this particular case I was able to work around this by fiddling with `FileDocTestSource.in_lib` to include all of `sage_setup` (previously it only contained `sage_setup.docbuild`--I can't tell you how much hair I pulled out trying to figure out why the relative imports in `sage_setup.docbuild` were not a problem :)

But in general this won't do if someone wants to test their own package using Sage's doctest runner, if it happens to use relative imports.

The cause of this error is an implementation detail of how relative imports work in Python.  They are _only_ meant to work in modules that belong to a package.  This means the module must have either a correct `__package__` or a `__path__` attribute as it would if it were imported through the normal import system.

In the doctest runner, `FileDocTestSource.create_doctests` calls `sage.repr.load.load` on the module being tested if it is not `in_lib`, which in turn compiles and execs that module in a namespace with `__name__ = '__main__'`.  This won't do when trying to exec a module that belongs to a package if it uses relative imports.

And even if it doesn't use relative imports, but uses absolute imports, it may not import other modules in the same package from the correct path. This statement deserves further explanation:  Say I have a package:


```
foo/
    __init__.py
    a.py
    b.py
```


and `__init__.py` contains:


```python
import foo.a
import foo.b
```


these are perfectly good absolute imports.  Let's also say I have the `foo` package under `mysrc/foo`.  If I then run `./sage -t mysrc/foo/__init__.py` it will `load()` `__init__.py` as a stand-alone module.  The imports in it _might_ work if I happen to have `mysrc/` in my `sys.path`, or if I have installed some version of the `foo` package into my site-packages.  The latter case is especially bad because it means I'm testing `mysrc/foo/__init__.py` in my source tree, but it's importing `foo.a` and `foo.b` from an installed version.

The best workaround, though annoying to do, is when `exec`'ing a module that belongs to a package one needs to "set up" the environment it execs in as though it were imported as part of that package, through the normal import system.  This can mean several things.  Depending on what happens in the package's `__init__.py` (and the `__init__.py` of any super-packages if it is a sub-package) it will mostly likely be necessary to import those packages for the module to run properly at all.

So the thing to do is walk the entire package hierarchy for the module by looking up the directory tree for `__init__.py`s (this may fail to find PEP-420 namespace packages, but that's probably not a problem) and import each package in the hierarchy (making sure to add the package's path to `sys.path`).


---

Comment by jdemeyer created at 2016-09-26 14:59:16

Python's `doctest` module seems to suffer from the same issue. From https://docs.python.org/2/library/doctest.html#simple-usage-checking-examples-in-docstrings:

> {{{
> python -m doctest -v example.py
> }}}
> This will import example.py as a standalone module and run testmod() on it. Note that this may not work correctly if the file is part of a package and imports other submodules from that package.


---

Comment by jdemeyer created at 2016-09-26 15:00:08

Maybe we should just never load the module, i.e. behave as if `in_lib` is always `True`?


---

Comment by jdemeyer created at 2016-09-26 15:02:22

Replying to [comment:2 jdemeyer]:
> Maybe we should just never load the module, i.e. behave as if `in_lib` is always `True`?

Although that would break testing stand-alone single files, which we should probably support.

So a slightly better idea: only load the file if the file being tested is not in a package (i.e. `__init__.py` does not exist).


---

Comment by embray created at 2016-09-26 15:55:06

Another related problem is that all modules listed in `in_lib` make the assumption that the sage package has been imported, and that all global variables in sage are available (and don't need to be imported by the tests).  This is not necessarily true for other packages, which is fine, but it might be unclear to someone writing doctests that this is only a special case for sage itself (or technically, anything listed in `in_lib`).

For packages one could, in principle, import the package, and then remove all of its modules from `sys.modules` (the end result is effectively the same as if you `load()`ed each module individually.  Though I don't know what the advantage would be.


---

Comment by jdemeyer created at 2017-01-24 08:24:04

What do you think of [comment:3]? Load a file if and only if it is _not_ part of a package (i.e. has no `__init__.*` file)

That would be very simple to implement and would probably do the right thing in most use cases.


---

Comment by jdemeyer created at 2017-01-24 09:17:04

I just implemented that.
----
New commits:


---

Comment by jdemeyer created at 2017-01-24 09:17:04

Changing status from new to needs_review.


---

Comment by embray created at 2017-01-25 14:12:44

Changing status from needs_review to positive_review.


---

Comment by embray created at 2017-01-25 14:12:44

I'm honestly not sure how this will work on Python 3, where `__init__.py` is not required for packages.  But I think in Python 3 relative imports are also changed so that loading a module directly (even if it's in a package) will still work properly.   Without a specific example in mind, I suppose it's not worth worrying about right now.

This makes sense to me otherwise.


---

Comment by vbraun created at 2017-01-28 17:03:40

Resolution: fixed
