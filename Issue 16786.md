# Issue 16786: Adding width() function to poset

Issue created by migration from https://trac.sagemath.org/ticket/17023

Original creator: jmantysalo

Original creation time: 2014-09-21 05:54:08

CC:  ncohen

Add a `.widht()` -- i.e. number of elements in the longest antichain -- to poset. Seems to have polynomial time algorithm based on Dilworth's Theorem.


---

Comment by ncohen created at 2014-09-21 10:28:12

I am writing this code right now.


---

Comment by jmantysalo created at 2014-09-21 11:23:09

Fast catch! So there is no function for maximum match at graphs available for wrapping?


---

Comment by ncohen created at 2014-09-21 11:29:23

> Fast catch! So there is no function for maximum match at graphs available for wrapping?

There is, but I want to do the job properly.

You can get the width with `len(Graph(your_poset.hasse_diagram().transitive_closure()).independent_set())` in the meantime.

Nathann


---

Comment by ncohen created at 2014-09-21 11:57:04

Changing status from new to needs_review.


---

Comment by git created at 2014-09-21 11:57:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2014-09-21 12:17:04

Changing status from needs_review to needs_work.


---

Comment by jmantysalo created at 2014-09-21 12:17:04

If `height()` has description "Return the height (number of elements in the longest chain) of the poset.", then I think that this should have

"Return the height (number of elements in the longest antichain) of the poset.

For information about algorithm, see :wikipedia:`Dilworth's_theorem`."

Because Dilworth's theorem is not really part of function definition but an implementation detail.


---

Comment by git created at 2014-09-21 12:31:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2014-09-21 12:32:57

Changing status from needs_work to needs_review.


---

Comment by jmantysalo created at 2014-09-21 15:07:02

Seems to work. I checked extreme cases: empty poset, one-element poset, chains and antichains, all poset of size n up to n=7 and few thousand random posets with varying parameters.

Reading code is propably best done with someone wiser than I am.

One line descriptions should have a dot at the end, because they are full sentences.


---

Comment by chapoton created at 2014-09-24 18:47:50

Hello,

I made a few little changes. Not a review, sorry.
----
New commits:


---

Comment by jmantysalo created at 2014-09-25 05:07:31

About "return" vs. "returns" on documentation: at least http://legacy.python.org/dev/peps/pep-0008/#documentation-strings shows example with "return". There was also some discussion about this at sage-devel -list at last month. Hence I think that Nathan's code follows style manual.


---

Comment by jmantysalo created at 2014-09-25 05:31:36

I did some timings. It seems that for something like `P=Posets.RandomPoset(100,0.15)` or so it is faster to run `max(len(x) for x in P.antichains())` than `P.width()`. On the other hand the measured complexity of `.width()` seems to be polynomial as it should.

I will do more test on faster computer, this was done quickly with an oooold machine.


---

Comment by jmantysalo created at 2014-09-25 07:52:00

How fast is `connected_components()` on graphs? Because this can be done simply by summing widths of connected subposets.

If posets are more "chain-like", then simply looking antichains seems to be faster. For posets more "antichain-like" it is much faster to use this new `.width()` method. Where is the turning point? Can there be some heuristic based on ratio of number of edges to number of vertices?


---

Comment by ncohen created at 2014-09-25 08:08:48

> About "return" vs. "returns" on documentation: at least http://legacy.python.org/dev/peps/pep-0008/#documentation-strings shows example with "return". There was also some discussion about this at sage-devel -list at last month. Hence I think that Nathan's code follows style manual.

I think that it follows manual, for not so long ago one of my patches was set to 'needs_work' because I wrote "returns" instead of "return". I do not care if the convention changes at every review for as long as I am not the one who writes the commits.

Nathann


---

Comment by ncohen created at 2014-09-25 08:09:17

> I did some timings. It seems that for something like `P=Posets.RandomPoset(100,0.15)` or so it is faster to run `max(len(x) for x in P.antichains())` than `P.width()`. On the other hand the measured complexity of `.width()` seems to be polynomial as it should.

Seems that random posets have a very very small width `O_o`

Nathann


---

Comment by jmantysalo created at 2014-09-25 08:25:22

Replying to [comment:16 ncohen]:

> Seems that random posets have a very very small width `O_o`

Actually this has been thinked already. Brinkmann & McKay says at the end of paper Posets on up to 16 points "Our results do not show this behaviour, emphasizing again that the convergence of posets to their asymptotic behaviour is quite slow." Hence no help from that.


---

Comment by ncohen created at 2014-09-25 08:25:49

Hello !

> How fast is `connected_components()` on graphs? Because this can be done simply by summing widths of connected subposets.

What do you mean ? If the poset is not connected you can indeed split it and compute the result on each connected components but I don't think the code I implemented will run any faster because of that. It would decrease the number of antichains though. But add an element superior to all others in your posets and you lost connectivity for the very same width.

> If posets are more "chain-like", then simply looking antichains seems to be faster. For posets more "antichain-like" it is much faster to use this new `.width()` method. Where is the turning point? Can there be some heuristic based on ratio of number of edges to number of vertices?

Well, maybe there is some algorithm to recognize posets with width <=2. And we already have a `is_chain` for width 1. Also, I think that something like 

```
len(Graph(posets.ChainPoset(6).hasse_diagram().transitive_closure()).independent_set())
```

should be a bit faster than enumerating the antichains. Even though enumerating the antichains may be faster for very very line-looking posets, for you don't have any graphs to copy around, ...

Nathann


---

Comment by jmantysalo created at 2014-09-25 12:12:37

You are right, on average connected posets are far more common than non-connected. Hence this should be like it now is.

Duh, should I try to understand theorem and read the code...


---

Comment by jmantysalo created at 2014-09-26 10:32:23

I read the code. As a side not, almost all examples use "P =", you have used "p =".

But as far as I can say, code seems to do what it should. I think this could be marked as positive review after trivial modifications like "returns" vs. "return".


---

Comment by ncohen created at 2014-09-26 13:13:48

> I read the code. As a side not, almost all examples use "P =", you have used "p =".

Pleaaaaaase let's not have a rule about upper/lower case `T_T`

> But as far as I can say, code seems to do what it should. I think this could be marked as positive review after trivial modifications like "returns" vs. "return".

Frédéric ? Could you remove the 's' you added ?

Nathann


---

Comment by chapoton created at 2014-09-26 18:44:48

I think the `s` in the list of methods should stay there for coherence of this list.

As there is no `s` in the first line of the new functions, things are good as they are.

LGTM. Let us not lose time on stupid things.


---

Comment by chapoton created at 2014-09-26 18:44:48

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2014-10-15 18:12:35

Resolution: fixed
