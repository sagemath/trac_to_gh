# Issue 32844: Segmentation fault with integers using musl libc 1.2.2

Issue created by migration from https://trac.sagemath.org/ticket/33081

Original creator: tornaria

Original creation time: 2021-12-26 03:16:38

CC:  @dkwo

Completely deterministic way to reproduce:

```
sage: Integer.factorial(27)

*** SIG 11 *** inside sig_on
do_raise_exception(sig=11)
PyErr_Occurred() = 0
Raising Python exception 0 ms after signal...
---------------------------------------------------------------------------
SignalError                               Traceback (most recent call last)
<ipython-input-1-2b2e17d17d42> in <module>
----> 1 Integer.factorial(Integer(27))

/usr/lib/sage-9.5.beta8/local/var/lib/sage/venv-python3.10/lib/python3.10/site-packages/sage/rings/integer.pyx in sage.rings.integer.Integer.factorial (build/cythonized/sage/rings/integer.c:29386)()
   4476         cdef Integer z = PY_NEW(Integer)
   4477 
-> 4478         sig_on()
   4479         mpz_fac_ui(z.value, mpz_get_ui(self.value))
   4480         sig_off()

SignalError: Segmentation fault
```


This bug was introduced by the fix for #31340.

Analysis:
 - the way `global_dummy_Integer` is created (as the result of 1-1) results on `_mp_alloc = 2`.
 - the second branch of `fast_tp_new()` creates a new Integer for the pool in the following way:
  1. allocate space for the python object `new` using `PyObject_Malloc`.
  2. copy `global_dummy_Integer` to the newly allocated Integer `new`.
  3. allocate one limb for `_mp_d` using `check_malloc()`, since these cannot be shared.
 - At this point the newly created Integer has `_mp_alloc = 2` but only 1 limb allocated in `_mp_d` -- the second limb contains a canary which shouldn't be modified.
 - `mpz_fac_ui` for the value 27 uses both limbs, destroying the canary; later it needs to `realloc(_mp_d)` to 3 limbs causing the segfault.

Note that the bug doesn't seem to manifest itself in glibc or musl 1.1, probably because their allocators don't use canaries and they never allocate less than 16 bytes even if one requests only 8 bytes (1 limb).

Possible solutions:

 1. in `fast_tp_new()` allocate `_mp_alloc` limbs rather than just one.
 
 2. create `global_dummy_Integer` in a way such that `_mp_alloc = 1`. Add an assert so we know when this assumption is broken.

 3. revert #31340 so that `global_dummy_Integer` is allocated with `_mp_alloc = 0`, add an assert so we know when this assumption is broken, and //do not// allocate anything in `fast_tp_new()`

The first solution seems more robust but there's a penalty to be paid because it will need to dereference `global_dummy_Integer.value._mp_alloc` and multiply by that (even though we know it is a fixed constant)

The second and third solutions are similar, but I like 3 better because it avoids an early allocation (maybe the integer will stay as 0 and this allocation will never be needed; maybe we are working with larger integers so we avoid to malloc 1 limb just to realloc to more limbs next).

Note the third solution will //not// work with mpir, but I guess that's ok since mpir is no longer supported.


---

Comment by tornaria created at 2021-12-26 03:21:34

Changing status from new to needs_review.


---

Comment by tornaria created at 2021-12-26 03:21:34

Solution 1:

```
--- a/src/sage/rings/integer.pyx        2021-12-12 07:19:28.000000000 -0300
+++ b/src/sage/rings/integer.pyx        2021-12-25 23:14:30.267376647 -0300
@@ -7345,7 +7352,7 @@
         #  Applications expecting to be compatible with future releases should use
         #  only the documented interfaces described in previous chapters."
         new_mpz = <mpz_ptr>((<Integer>new).value)
-        new_mpz._mp_d = <mp_ptr>check_malloc(GMP_LIMB_BITS >> 3)
+        new_mpz._mp_d = <mp_ptr>check_malloc(new_mpz._mp_alloc * GMP_LIMB_BITS >> 3)

     # This line is only needed if Python is compiled in debugging mode
     # './configure --with-pydebug' or SAGE_DEBUG=yes. If that is the
```

Solution 2:

```
--- a/src/sage/rings/integer.pyx        2021-12-12 07:19:28.000000000 -0300
+++ b/src/sage/rings/integer.pyx        2021-12-25 23:23:31.609200842 -0300
@@ -7267,9 +7267,12 @@
 # We use a global Integer element to steal all the references
 # from. DO NOT INITIALIZE IT AGAIN and DO NOT REFERENCE IT!
 #
-# Use actual calculation to avoid libgmp's new lazy allocation :trac:`31340`
 cdef Integer global_dummy_Integer
-global_dummy_Integer = Integer(1) - Integer(1)
+global_dummy_Integer = Integer()
+# Set to 0 so _mp_d is allocated :trac:`31340`
+mpz_set_ui(global_dummy_Integer.value, 0)
+# Check it has 1 limb allocated, which is assumed later in fast_tp_new()
+assert global_dummy_Integer.value._mp_alloc == 1
 
 
 # A global pool for performance when integers are rapidly created and destroyed.
@@ -7345,6 +7348,7 @@
         #  Applications expecting to be compatible with future releases should use
         #  only the documented interfaces described in previous chapters."
         new_mpz = <mpz_ptr>((<Integer>new).value)
+        # This assumes new_mpz._mp_alloc == 1
         new_mpz._mp_d = <mp_ptr>check_malloc(GMP_LIMB_BITS >> 3)
 
     # This line is only needed if Python is compiled in debugging mode
```

Solution 3:

```
--- a/src/sage/rings/integer.pyx       2021-12-12 07:19:28.000000000 -0300
+++ b/src/sage/rings/integer.pyx        2021-12-25 23:28:29.261100996 -0300
@@ -7267,9 +7267,10 @@
 # We use a global Integer element to steal all the references
 # from. DO NOT INITIALIZE IT AGAIN and DO NOT REFERENCE IT!
 #
-# Use actual calculation to avoid libgmp's new lazy allocation :trac:`31340`
 cdef Integer global_dummy_Integer
-global_dummy_Integer = Integer(1) - Integer(1)
+global_dummy_Integer = Integer()
+# Check nothing is allocated, which is assumed later in fast_tp_new()
+assert global_dummy_Integer.value._mp_alloc == 0
 
 
 # A global pool for performance when integers are rapidly created and destroyed.
@@ -7325,28 +7326,10 @@
 
         # Now set every member as set in z, the global dummy Integer
         # created before this tp_new started to operate.
+        # We assume the mpz in this Integer has no allocation,
+        # hence it is ok to just copy
         memcpy(new, (<void*>global_dummy_Integer), sizeof_Integer )
 
-        # We allocate memory for the _mp_d element of the value of this
-        # new Integer. We allocate one limb. Normally, one would use
-        # mpz_init() for this, but we allocate the memory directly.
-        # This saves time both by avoiding extra function calls and
-        # because the rest of the mpz struct was already initialized
-        # fully using the memcpy above.
-        #
-        # What is done here is potentially very dangerous as it reaches
-        # deeply into the internal structure of GMP. Consequently things
-        # may break if a new release of GMP changes some internals. To
-        # emphasize this, this is what the GMP manual has to say about
-        # the documentation for the struct we are using:
-        #
-        #  "This chapter is provided only for informational purposes and the
-        #  various internals described here may change in future GMP releases.
-        #  Applications expecting to be compatible with future releases should use
-        #  only the documented interfaces described in previous chapters."
-        new_mpz = <mpz_ptr>((<Integer>new).value)
-        new_mpz._mp_d = <mp_ptr>check_malloc(GMP_LIMB_BITS >> 3)
-
     # This line is only needed if Python is compiled in debugging mode
     # './configure --with-pydebug' or SAGE_DEBUG=yes. If that is the
     # case a Python object has a bunch of debugging fields which are
@@ -7395,7 +7378,8 @@ cdef void fast_tp_dealloc(PyObject* o):
             return
 
         # No space in the pool, so just free the mpz_t.
-        sig_free(o_mpz._mp_d)
+        if o_mpz._mp_alloc:
+            sig_free(o_mpz._mp_d)
 
     # Free the object. This assumes that Py_TPFLAGS_HAVE_GC is not
     # set. If it was set another free function would need to be
```


Edit: fixed paths in patch 3

Edit2: added deallocation fix in patch 3.


---

Comment by mkoeppe created at 2021-12-26 04:08:39

I think solution 2 is best


---

Comment by dimpase created at 2021-12-26 10:35:11

Are we running a CI on musl void, or another musl platform, such as Alpine?
(The latter is the distro used by cibuildwheel PyPI wheels builder, perhaps it deserves more attention?)


---

Comment by tornaria created at 2021-12-26 15:08:09

From the commit message:

```
    Reallocate the global dummy Integer to one limb.
    
    This is a better fix for #31340 (memory leak when the global dummy
    Integer is not allocated) and it fixes #33081 (segfault when global
    dummy Integer has more than one limb allocated, detected by malloc
    canaries in musl libc 1.2.2)
    
    Also add a function _check_global_dummy_Integer() whose only purpose is
    to doctest that the global dummy Integer satisfies all the assumptions.
```

----
New commits:


---

Comment by tornaria created at 2021-12-26 15:48:22

I went with solution 2 which is doing precisely what sagemath has been doing for ages (before gmp lazy init).

However, I still think it may be worth doing 3 to avoid allocating memory for 0 which is a very common number. This is tricky to benchmark since the integer pool hides the allocation overhead so one has to disable the pool (just change the value of `integer_pool_size` from 100 to 0).

With the pool disabled, a tight loop allocating 100k integers is 3 times faster with lazy allocation (1.5ns vs 5ns) but I don't know a real life example where this makes a difference so I'll leave it as is.


---

Comment by tornaria created at 2021-12-26 16:06:32

Replying to [comment:3 dimpase]:
> Are we running a CI on musl void, or another musl platform, such as Alpine?
> (The latter is the distro used by cibuildwheel PyPI wheels builder, perhaps it deserves more attention?)

Note void linux currently uses musl 1.1.24, which doesn't have malloc canaries afaik. I do regularly test sagemath on void musl 1.1.24. See https://github.com/void-linux/void-packages/pull/34030 for CI, last time it run 9.5.beta8 and it passes with some patches, e.g. #33047. I'll update to beta9 soon.

It should be possible to have a docker image for void linux running musl 1.2.2 if that's useful. In fact upgrading musl to 1.2.2 shouldn't be a problem on 64 bit (the issue with musl 1.2 is that time_t changed on 32 bit archs so the world needs to be recompiled to upgrade)

Alpine has musl 1.2.2.

Maybe it's possible to use some malloc with canaries and/or other checks even on glibc so memory allocation issues like this one would be catched early.


---

Comment by mkoeppe created at 2021-12-26 20:18:43

Replying to [comment:3 dimpase]:
> Are we running a CI on musl void, or another musl platform, such as Alpine?

We have void in `tox.ini`, so it would only need to be added to the GH Actions platforms.

For alpine, I have opened #33083.


---

Comment by mkoeppe created at 2021-12-26 20:40:58

Replying to [comment:7 mkoeppe]:
> Replying to [comment:3 dimpase]:
> > Are we running a CI on musl void, or another musl platform, such as Alpine?
> 
> We have void in `tox.ini`

However, it seems broken. Opened #33084 for this


---

Comment by mkoeppe created at 2021-12-27 04:52:46

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2021-12-27 04:52:46

I have tested it in https://github.com/mkoeppe/sage/actions/runs/1625005821, looking good.


---

Comment by mkoeppe created at 2022-01-17 21:13:38

Changing priority from critical to blocker.


---

Comment by vbraun created at 2022-01-18 22:01:17

Resolution: fixed
