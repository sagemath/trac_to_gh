# Issue 21103: LatticePoset: bug in testing semidistributivity

Issue created by migration from https://trac.sagemath.org/ticket/21340

Original creator: jmantysalo

Original creation time: 2016-08-26 04:50:24

CC:  leif

Sage says that the Boolean lattice of `2^3=8` elements is not [meet|join]-semidistributive. This is propably due to division by `2` that is not preparsed and was hence missed in my tests.


---

Comment by jmantysalo created at 2016-08-26 07:14:12

Ready for review, but let's first wait if discussion at https://groups.google.com/forum/#!topic/sage-devel/ZtwUc5c4Js0 founds better solution.
----
New commits:


---

Comment by git created at 2016-08-27 05:00:43

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jmantysalo created at 2016-08-27 05:02:48

Leif, can you check this basically one line patch?


---

Comment by jmantysalo created at 2016-08-27 05:02:48

Changing status from new to needs_review.


---

Comment by tscrim created at 2016-08-27 05:05:55

This is a _massive_ hack solution that comes from this behavior:

```sage
sage: log(8, 2)
3
sage: log(8, int(2))
log(8)/log(2)
sage: log(int(8), int(2))
log(8)/log(2)
```

If we are to accept this hack, we should well document it as such.


---

Comment by jmantysalo created at 2016-08-27 05:14:46

Well, of course right solution would be correcting `log`. For example output type should depend on input type, not on input value. But


```
sage: type(log(8, 2))
<type 'sage.rings.integer.Integer'>
sage: type(log(9, 2))
<type 'sage.symbolic.expression.Expression'>
```


Should I just remove the quick test of non-semidistributivity then? Won't make much difference.


---

Comment by tscrim created at 2016-08-27 15:36:13

The biggest thing is just documenting why we are doing certain things, so when we go back and look again or someone else comes and looks at it, it is clear why things were done this way.

One option would be wrapping the inequality test in `bool(...)`. This evaluates the symbolic expression to a boolean and doesn't affect boolean values:

```
sage: bool(13 > 8 * log(8, 2) / 2)
True
sage: bool(12 > 8 * log(8, 2) / 2)
False
sage: bool(True)
True
sage: bool(False)
False
```

Again, there should be a comment. Another option would be to do `log(8,2).n()`, which could introduce some numerical noise. Or just force both values to `ZZ`.


---

Comment by leif created at 2016-08-27 16:46:39

Replying to [comment:7 tscrim]:
> One option would be wrapping the inequality test in `bool(...)`. This evaluates the symbolic expression to a boolean and doesn't affect boolean values:
> {{{
> sage: bool(13 > 8 * log(8, 2) / 2)
> True
> sage: bool(12 > 8 * log(8, 2) / 2)
> False
> sage: bool(True)
> True
> sage: bool(False)
> False
> }}}

Quoting from sage-devel:

```
Ralf Stephan wrote:
> On Saturday, August 27, 2016 at 7:05:28 AM UTC+2, Jori Mäntysalo wrote:
>
>     But shouldn't it work in any case? I.e. comparison of
>     log(a+b*c^2...) to
>     some number should work when a,b,c... are sage Integers.
>
>
> log(integer) will not be expanded numerically except for log(0) and log(1).
> If you want it expanded, either give a float argument, eg log(2.), or
> append n().

N() wasn't the problem, but (also) rounding:

(s is 12 here.)

sage: n*log(n, 2)
24
sage: n*log(n, 2r)
8*log(8)/log(2)
sage: N(n*log(n, 2r))
24.0000000000000
sage: 2*s < n*log(n, 2)
False
sage: 2*s > n*log(n, 2)
False
sage: 2*s > n*log(n, 2r)
24 > 8*log(8)/log(2)
sage: bool(2*s > n*log(n, 2r))
True
sage: bool(2r*s > n*log(n, 2r))
True
sage: bool(2r*s > n*log(n, 2))
False
sage: 24 > N(n*log(n, 2r))
True
```


So I'd suggest to rewrite the code, and/or call the proper `log()`, or (first) check whether `n` is a power of 2.


---

Comment by leif created at 2016-08-27 16:52:06

(The left side of the comparison doesn't matter here, but note that

  `bool(2*s > n*log(n, 2r))`

and

  `bool(2*s > n*log(n, 2))`

give different results due to the behaviour of `log()` and rounding issues.)


---

Comment by jmantysalo created at 2016-08-28 08:11:36

Maybe I just wrote the `log_2` myself:


```
def _log_2(n):
    """
    Return the 2-based logarithm of `n` rounded up.
    
    `n` is assumed to be a positive integer.
    
    EXAMPLES::
        
        sage: sage.combinat.poset.lattices._log_2(10)
        4
    """
    bits = -1
    i = n
    while i:
        i = i >> 1
        bits += 1
    if 1 << bits == n:
        return bits
    return bits+1
```


(On x86 one could use `LZCNT` and `POPCNT`. `:=)`)


---

Comment by leif created at 2016-08-28 12:47:11

See also the `ffs()` family, `[__builtin_]clz()`, ...  (also on ARM etc.)

If you just want to know _whether_ `n` is an exact power of two (<=> n==0 or popcnt(n)==1), you can use `n & ~(n-1) == n`.

You could likewise use Python's `math.log(int(n), 2)`, or various functions from GMP (since Sage Integers are based on `mpz_t`).


---

Comment by jmantysalo created at 2016-08-28 14:59:16

Replying to [comment:11 leif]:

> You could likewise use Python's `math.log(int(n), 2)`, or various functions from GMP (since Sage Integers are based on `mpz_t`).  

Isn't there the same rounding problem with `math.log`?


---

Comment by leif created at 2016-08-28 15:38:19

Replying to [comment:12 jmantysalo]:
> Replying to [comment:11 leif]:
> 
> > You could likewise use Python's `math.log(int(n), 2)`, or various functions from GMP (since Sage Integers are based on `mpz_t`).  
> 
> Isn't there the same rounding problem with `math.log`?

Probably not for true powers of 2; don't know why Sage's log() is so bad in that regard.  (How large does `n`, or  `log(n, 2)`, practically get?)

FWIW, if you want to stay in the integer domain, you could as well use `4`<sup>`s`</sup>`> n`<sup>`n`</sup>, where the right-hand side is as cheap as the left if (`n` is sufficiently small or `ctz(n)` is relatively large or) `n` is a power of 2.

But that's perhaps already towards bike-shedding.

\\

Especially if you know `n` is a power of 2, you could do appropriate rounding as well, but I'd rather fix log() or use a different one.

But doesn't already using `sage.misc.functional.log(n, Integer(2))` solve (or, more precisely, work around) the main problem here?


---

Comment by leif created at 2016-08-28 16:06:14

Replying to [comment:13 leif]:
> Replying to [comment:12 jmantysalo]:
> > Isn't there the same rounding problem with `math.log`?
> 
> Probably not for true powers of 2; don't know why Sage's log() is so bad in that regard.  (How large does `n`, or  `log(n, 2)`, practically get?)

It should be safe up to at least 2<sup>52</sup>+ (maybe even up to 2<sup>1022</sup>+) because Python's `float`s (returned by `math.log()`) are actually `double`s AFAIK.


---

Comment by leif created at 2016-08-28 17:56:32

Distantly related:

While we (you?) are at it, `HasseDiagram` has a couple of `.is_...()` methods which do not return `True` or `False`, but either `None` or some sample.  Shouldn't these return the former unless a keyword argument `certificate` :-) (which they currently don't have) is passed?


---

Comment by jmantysalo created at 2016-08-29 03:44:31

Replying to [comment:15 leif]:
> Distantly related:
> 
> While we (you?) are at it, `HasseDiagram` has a couple of `.is_...()` methods which do not return `True` or `False`, but either `None` or some sample.  Shouldn't these return the former unless a keyword argument `certificate` :-) (which they currently don't have) is passed?

Other than `is_semidistributive`?

But yes, you are right. Kevin said the same at #21002. Suggestion for better name?


---

Comment by git created at 2016-08-30 05:52:49

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jmantysalo created at 2016-08-30 05:53:38

OK, should work now. Also function name changed.


---

Comment by leif created at 2016-08-30 16:11:38

Replying to [comment:18 jmantysalo]:
> OK, should work now. Also function name changed.

Doesn't the latter require a deprecation of the old function first?


---

Comment by leif created at 2016-08-30 16:22:47

Replying to [comment:16 jmantysalo]:
> Replying to [comment:15 leif]:
> > Distantly related:
> > 
> > While we (you?) are at it, `HasseDiagram` has a couple of `.is_...()` methods which do not return `True` or `False`, but either `None` or some sample.  Shouldn't these return the former unless a keyword argument `certificate` :-) (which they currently don't have) is passed?
> 
> Other than `is_semidistributive`?

Yes.  The first (I think) being `.is_complemented(self)`, but there are more IIRC.

\\

> But yes, you are right. Kevin said the same at #21002. Suggestion for better name?

`certify`, `prove[_if_(true|false)]`, `[return_]witness[_if_false]`?  ;-)

(I guess you were referring to `is_...()`, not the keyword argument, though.)

I'd rather keep the `is_...()`, but add (a) keyword or boolean argument(s), and only change the return type(s).

But then you'd have to first make the old behaviour the default, for backwards compatibility.


---

Comment by leif created at 2016-08-30 16:24:11

Perhaps a bit late, but did you look at `Integer.{log,exact_log}()`?


---

Comment by jmantysalo created at 2016-08-31 03:38:48

Replying to [comment:19 leif]:

> > OK, should work now. Also function name changed.
> 
> Doesn't the latter require a deprecation of the old function first?

I have thinked that `hasse_diagram.py` is an internal implementation file that can be changed. And the function is one release old only.


---

Comment by jmantysalo created at 2016-08-31 10:36:37

Replying to [comment:20 leif]:

> (I guess you were referring to `is_...()`, not the keyword argument, though.)
> 
> I'd rather keep the `is_...()`, but add (a) keyword or boolean argument(s), and only change the return type(s).

I can think those later in another ticket. Actually there is more to think about in splitting code in `posets.py` and `lattices.py` vs. `hasse_diagram.py`.

But is there more to do for this ticket?

`exact_log` rounds down, my helper function rounds up. Of course I could use it, but the code would not be much simpler. Waiting for Python 3 and log_2...


---

Comment by jmantysalo created at 2016-09-06 05:49:58

Assuming that #21419 get accepted it offers a faster way to chech if a lattice is semidistributive.


---

Comment by jmantysalo created at 2016-09-13 04:11:44

Just a ping... Currently Sage says that a distributive lattice is not semidistributive, which is bad. There are more to add, but IMO bugs should be corrected first.

Replying to [comment:23 jmantysalo]:

> But is there more to do for this ticket?


---

Comment by chapoton created at 2016-09-14 12:00:39

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2016-09-14 12:00:39

ok, ok. It would have been better to put this log2 in some other place.


---

Comment by jmantysalo created at 2016-09-14 12:06:19

Replying to [comment:26 chapoton]:
> It would have been better to put this log2 in some other place.

But I think that someone, "Frédéric" if I remember the name correctly, is converting [SageMath](SageMath) to Python 3. `:=)` Then we will have `math.log2()`.


---

Comment by vbraun created at 2016-09-16 06:55:21

Resolution: fixed
