# Issue 12696: Attaching a pyx file in the presence of __init__.py results in wrong module names

archive/issues_012696.json:
```json
{
    "body": "Assignee: jason\n\nCreate a new folder (say, /home/simon/SAGE/work/tests/) and create a file test.pyx with the content\n\n```\nclass bla(type):\n    pass\n```\n\n\nStart sage, attach the file, and you will find something like\n\n```\nsage: attach test.pyx\nCompiling ./test.pyx...\nsage: bla.__module__\n'sage: attach test.pyx\nCompiling ./test.pyx...\nsage: bla.__module__\n'_home_simon_SAGE_work_tests_test_pyx_0'\n```\n\n\nThen, create an `__init__.py` file in the same folder. You will find\n\n```\nsage: attach test.pyx\nCompiling ./test.pyx...\nsage: bla.__module__\n'_home_simon_SAGE_work_tests_test_pyx._home_simon_SAGE_work_tests_test_pyx_0'\nsage: sys.modules.has_key(bla.__module__)\nFalse\n```\n\n\nIn fact, even if `__init__.py` is present, the module is still known under the \"short\" name, but the class doesn't know about it:\n\n```\nsage: import _home_simon_SAGE_work_tests_test_pyx_0\nsage: _home_simon_SAGE_work_tests_test_pyx_0.bla\n<class '_home_simon_SAGE_work_tests_test_pyx._home_simon_SAGE_work_tests_test_pyx_0.bla'>\n```\n\n\nPlease change the component if you think that there is one that fits less bad than \"misc\"...\n\nIssue created by migration from https://trac.sagemath.org/ticket/12868\n\n",
    "created_at": "2012-04-22T07:40:45Z",
    "labels": [
        "misc",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Attaching a pyx file in the presence of __init__.py results in wrong module names",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/12696",
    "user": "SimonKing"
}
```
Assignee: jason

Create a new folder (say, /home/simon/SAGE/work/tests/) and create a file test.pyx with the content

```
class bla(type):
    pass
```


Start sage, attach the file, and you will find something like

```
sage: attach test.pyx
Compiling ./test.pyx...
sage: bla.__module__
'sage: attach test.pyx
Compiling ./test.pyx...
sage: bla.__module__
'_home_simon_SAGE_work_tests_test_pyx_0'
```


Then, create an `__init__.py` file in the same folder. You will find

```
sage: attach test.pyx
Compiling ./test.pyx...
sage: bla.__module__
'_home_simon_SAGE_work_tests_test_pyx._home_simon_SAGE_work_tests_test_pyx_0'
sage: sys.modules.has_key(bla.__module__)
False
```


In fact, even if `__init__.py` is present, the module is still known under the "short" name, but the class doesn't know about it:

```
sage: import _home_simon_SAGE_work_tests_test_pyx_0
sage: _home_simon_SAGE_work_tests_test_pyx_0.bla
<class '_home_simon_SAGE_work_tests_test_pyx._home_simon_SAGE_work_tests_test_pyx_0.bla'>
```


Please change the component if you think that there is one that fits less bad than "misc"...

Issue created by migration from https://trac.sagemath.org/ticket/12868





---

archive/issue_comments_151697.json:
```json
{
    "body": "I'm not yet sure whether that's really a bug, or just confusing.  (If I understand correctly, the presence of an `__init__.py` file was unintentional in your case.)\n\nThe behaviour should probably also depend on whether some directory of the path to the attached file is in `PYTHONPATH`.  Haven't yet looked at the code though.\n\n\n\n\n[W.r.t. the component:  \"User interface\" seems a candidate as well.]",
    "created_at": "2012-04-22T14:44:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151697",
    "user": "leif"
}
```

I'm not yet sure whether that's really a bug, or just confusing.  (If I understand correctly, the presence of an `__init__.py` file was unintentional in your case.)

The behaviour should probably also depend on whether some directory of the path to the attached file is in `PYTHONPATH`.  Haven't yet looked at the code though.




[W.r.t. the component:  "User interface" seems a candidate as well.]



---

archive/issue_comments_151698.json:
```json
{
    "body": "Btw., the output of (in your case)\n\n```\nsage: bla?\n```\n\nlooks different as well, depending on whether an `__init__.py` file is present in the same directory.\n\n*Without* one, there's also:\n\n```\nLoaded File:\t/home/leif/.sage/temp/sleepless/16739/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so\nSource File:\t/home/leif/.sage/temp/sleepless/16739/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so\n```\n\n(The attached file is `/tmp/foo/foo.pyx`.)",
    "created_at": "2012-04-22T15:09:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151698",
    "user": "leif"
}
```

Btw., the output of (in your case)

```
sage: bla?
```

looks different as well, depending on whether an `__init__.py` file is present in the same directory.

*Without* one, there's also:

```
Loaded File:	/home/leif/.sage/temp/sleepless/16739/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so
Source File:	/home/leif/.sage/temp/sleepless/16739/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so
```

(The attached file is `/tmp/foo/foo.pyx`.)



---

archive/issue_comments_151699.json:
```json
{
    "body": "Looks like distutils were responsible for that behaviour...",
    "created_at": "2012-04-22T15:35:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151699",
    "user": "leif"
}
```

Looks like distutils were responsible for that behaviour...



---

archive/issue_comments_151700.json:
```json
{
    "body": "In the Cython-generated `.c` file, I see things like\n\n```c\n...\n/* Module declarations from '_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0' */\n#define __Pyx_MODULE_NAME \"_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0\"\nint __pyx_module_is_main__tmp_foo_foo_pyx___tmp_foo_foo_pyx_0 = 0;\n\n/* Implementation of '_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0' */\nstatic char __pyx_k_1[] = \"File: _tmp_foo_foo_pyx_0.pyx (starting at line 2)\";\nstatic char __pyx_k_2[] = \"_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0\";\nstatic char __pyx_k__bar[] = \"bar\";\nstatic char __pyx_k____main__[] = \"__main__\";\nstatic char __pyx_k____test__[] = \"__test__\";\nstatic PyObject *__pyx_n_s_2;\nstatic PyObject *__pyx_n_s____main__;\nstatic PyObject *__pyx_n_s____test__;\nstatic PyObject *__pyx_n_s__bar;\n\nstatic PyMethodDef __pyx_methods[] = {\n  {0, 0, 0, 0}\n};\n\n#if PY_MAJOR_VERSION >= 3\nstatic struct PyModuleDef __pyx_moduledef = {\n    PyModuleDef_HEAD_INIT,\n    __Pyx_NAMESTR(\"_tmp_foo_foo_pyx_0\"),\n    __Pyx_DOCSTR(__pyx_k_1), /* m_doc */\n    -1, /* m_size */\n    __pyx_methods /* m_methods */,\n    NULL, /* m_reload */\n    NULL, /* m_traverse */\n    NULL, /* m_clear */\n    NULL /* m_free */\n};\n#endif\n...\n```\n\nwith an `__init__.py` file present.  (My dummy class is called `bar` rather than `bla`.)\n\nIn the temporary build directory, also a symbolic link to `__init__.py` is created:\n\n```\n/home/leif/.sage/temp/sleepless/17317/spyx/_tmp_foo_foo_pyx:\ntotal 112\ndrwxr-xr-x 3 leif leif  4096 2012-04-22 17:45 .\ndrwxr-xr-x 3 leif leif  4096 2012-04-22 17:45 ..\ndrwxr-xr-x 4 leif leif  4096 2012-04-22 17:45 build\n-rw-r--r-- 1 leif leif     0 2012-04-22 17:45 err\nlrwxrwxrwx 1 leif leif    16 2012-04-22 17:45 foo.pyx -> /tmp/foo/foo.pyx\nlrwxrwxrwx 1 leif leif    20 2012-04-22 17:45 __init__.py -> /tmp/foo/__init__.py\n-rw-r--r-- 1 leif leif  1536 2012-04-22 17:45 log\n-rw-r--r-- 1 leif leif  1400 2012-04-22 17:45 setup.py\n-rw-r--r-- 1 leif leif 46397 2012-04-22 17:45 _tmp_foo_foo_pyx_0.c\n-rw-r--r-- 1 leif leif  3993 2012-04-22 17:45 _tmp_foo_foo_pyx_0.html\n-rw-r--r-- 1 leif leif   157 2012-04-22 17:45 _tmp_foo_foo_pyx_0.pyx\n-rwxr-xr-x 1 leif leif 36595 2012-04-22 17:45 _tmp_foo_foo_pyx_0.so\n```\n\n`setup.py` there looks \"clean\".\n\nSo I'm pretty sure -- if at all -- *distutils* are to blame for the unexpected behaviour, although it seems quite reasonable to me.",
    "created_at": "2012-04-22T16:08:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151700",
    "user": "leif"
}
```

In the Cython-generated `.c` file, I see things like

```c
...
/* Module declarations from '_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0' */
#define __Pyx_MODULE_NAME "_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0"
int __pyx_module_is_main__tmp_foo_foo_pyx___tmp_foo_foo_pyx_0 = 0;

/* Implementation of '_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0' */
static char __pyx_k_1[] = "File: _tmp_foo_foo_pyx_0.pyx (starting at line 2)";
static char __pyx_k_2[] = "_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0";
static char __pyx_k__bar[] = "bar";
static char __pyx_k____main__[] = "__main__";
static char __pyx_k____test__[] = "__test__";
static PyObject *__pyx_n_s_2;
static PyObject *__pyx_n_s____main__;
static PyObject *__pyx_n_s____test__;
static PyObject *__pyx_n_s__bar;

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    __Pyx_NAMESTR("_tmp_foo_foo_pyx_0"),
    __Pyx_DOCSTR(__pyx_k_1), /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif
...
```

with an `__init__.py` file present.  (My dummy class is called `bar` rather than `bla`.)

In the temporary build directory, also a symbolic link to `__init__.py` is created:

```
/home/leif/.sage/temp/sleepless/17317/spyx/_tmp_foo_foo_pyx:
total 112
drwxr-xr-x 3 leif leif  4096 2012-04-22 17:45 .
drwxr-xr-x 3 leif leif  4096 2012-04-22 17:45 ..
drwxr-xr-x 4 leif leif  4096 2012-04-22 17:45 build
-rw-r--r-- 1 leif leif     0 2012-04-22 17:45 err
lrwxrwxrwx 1 leif leif    16 2012-04-22 17:45 foo.pyx -> /tmp/foo/foo.pyx
lrwxrwxrwx 1 leif leif    20 2012-04-22 17:45 __init__.py -> /tmp/foo/__init__.py
-rw-r--r-- 1 leif leif  1536 2012-04-22 17:45 log
-rw-r--r-- 1 leif leif  1400 2012-04-22 17:45 setup.py
-rw-r--r-- 1 leif leif 46397 2012-04-22 17:45 _tmp_foo_foo_pyx_0.c
-rw-r--r-- 1 leif leif  3993 2012-04-22 17:45 _tmp_foo_foo_pyx_0.html
-rw-r--r-- 1 leif leif   157 2012-04-22 17:45 _tmp_foo_foo_pyx_0.pyx
-rwxr-xr-x 1 leif leif 36595 2012-04-22 17:45 _tmp_foo_foo_pyx_0.so
```

`setup.py` there looks "clean".

So I'm pretty sure -- if at all -- *distutils* are to blame for the unexpected behaviour, although it seems quite reasonable to me.



---

archive/issue_comments_151701.json:
```json
{
    "body": "Replying to [comment:4 leif]:\n> So I'm pretty sure -- if at all -- *distutils* are to blame for the unexpected behaviour, although it seems quite reasonable to me.\n\n\nNope, actually *Cython* is causing this, since the following does **not** solve your problem (if it really is one):\n\n```diff\ndiff --git a/sage/misc/cython.py b/sage/misc/cython.py\n--- a/sage/misc/cython.py\n+++ b/sage/misc/cython.py\n@@ -432,6 +432,11 @@\n     SAGE_ROOT  = os.environ['SAGE_ROOT']\n     SAGE_LOCAL = SAGE_ROOT + '/local/'\n \n+# Remove unwanted link to an __init__.py file from the current directory,\n+# i.e., from the temporary build directory only (#12868):\n+if os.path.exists(\"__init__.py\"):\n+    os.unlink(\"__init__.py\")\n+\n extra_link_args =  ['-L' + SAGE_LOCAL + '/lib']\n extra_compile_args = %s\n \n```\n\n\nYou can verify that Cython changes the module name depending on whether an `__init__.py` file is present by\n\n\n```sh\n$ sage --sh -c 'cython test.pyx' && grep '^#.*__Pyx_MODULE_NAME' test.c`\n```\n\n\nAlthough it is not yet clear to me how Cython finds the `__init__.py` if I remove it from the temporary build directory, as there's only the symbolic link to the \"unrelated\" original `.pyx` source file, but probably Cython somehow \"knows\" about the relation.",
    "created_at": "2012-04-22T17:19:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151701",
    "user": "leif"
}
```

Replying to [comment:4 leif]:
> So I'm pretty sure -- if at all -- *distutils* are to blame for the unexpected behaviour, although it seems quite reasonable to me.


Nope, actually *Cython* is causing this, since the following does **not** solve your problem (if it really is one):

```diff
diff --git a/sage/misc/cython.py b/sage/misc/cython.py
--- a/sage/misc/cython.py
+++ b/sage/misc/cython.py
@@ -432,6 +432,11 @@
     SAGE_ROOT  = os.environ['SAGE_ROOT']
     SAGE_LOCAL = SAGE_ROOT + '/local/'
 
+# Remove unwanted link to an __init__.py file from the current directory,
+# i.e., from the temporary build directory only (#12868):
+if os.path.exists("__init__.py"):
+    os.unlink("__init__.py")
+
 extra_link_args =  ['-L' + SAGE_LOCAL + '/lib']
 extra_compile_args = %s
 
```


You can verify that Cython changes the module name depending on whether an `__init__.py` file is present by


```sh
$ sage --sh -c 'cython test.pyx' && grep '^#.*__Pyx_MODULE_NAME' test.c`
```


Although it is not yet clear to me how Cython finds the `__init__.py` if I remove it from the temporary build directory, as there's only the symbolic link to the "unrelated" original `.pyx` source file, but probably Cython somehow "knows" about the relation.



---

archive/issue_comments_151702.json:
```json
{
    "body": "Replying to [comment:5 leif]:\n> ... the following does **not** solve your problem (if it really is one):\n\nWe have a module containing a class bla, but `sys.modules[bla.__module__]` gives a key error. I am surprised that you question whether that is a problem.",
    "created_at": "2012-04-22T17:47:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151702",
    "user": "SimonKing"
}
```

Replying to [comment:5 leif]:
> ... the following does **not** solve your problem (if it really is one):

We have a module containing a class bla, but `sys.modules[bla.__module__]` gives a key error. I am surprised that you question whether that is a problem.



---

archive/issue_comments_151703.json:
```json
{
    "body": "Replying to [comment:6 SimonKing]:\n> Replying to [comment:5 leif]:\n> > ... the following does **not** solve your problem (if it really is one):\n> \n> We have a module containing a class bla, but `sys.modules[bla.__module__]` gives a key error. I am surprised that you question whether that is a problem.\n\nNo, I'd rather say it's a \"user error\"... ;-)\n\nSeriously, my above patch didn't work because the link was removed just too late (since I initially thought the problem was caused by distutils, which it is not).\n\nCurrently changing the patch to remove the (in your opinion) undesirable link to `__init__.py` earlier, such that `cython`, when invoked, won't see it.",
    "created_at": "2012-04-22T17:54:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151703",
    "user": "leif"
}
```

Replying to [comment:6 SimonKing]:
> Replying to [comment:5 leif]:
> > ... the following does **not** solve your problem (if it really is one):
> 
> We have a module containing a class bla, but `sys.modules[bla.__module__]` gives a key error. I am surprised that you question whether that is a problem.

No, I'd rather say it's a "user error"... ;-)

Seriously, my above patch didn't work because the link was removed just too late (since I initially thought the problem was caused by distutils, which it is not).

Currently changing the patch to remove the (in your opinion) undesirable link to `__init__.py` earlier, such that `cython`, when invoked, won't see it.



---

archive/issue_comments_151704.json:
```json
{
    "body": "Replying to [comment:7 leif]:\n> Currently changing the patch to remove the (in your opinion) undesirable link to `__init__.py` earlier, such that `cython`, when invoked, won't see it.\n\nThat wouldn't be a solution. Perhaps the user *wants* (for some reason) to have it in the folder (in particular, it is no user error).\n\nI believe that it should simply not matter for attaching files whether or not `__init__.py` is there. Of course, if you have a Python file and want that you can import (not attach) it, then you would create the `__init__.py` (this is why I created it, anyway).\n\nAttaching a file should be independent from importing, and both should simultaneously be possible. So, unlinking `__init__.py` is bad.\n\nUp to yesterday, I was in the belief that \"attaching a pyx-file\" means that\n\n1. the file is copied into a temporary directory,\n2. the compilation is done there, and\n3. the module is imported from the temporary directory.\n\nSince the temporary directory would not contain `__init__.py`, there should be no problem, isn't it?",
    "created_at": "2012-04-22T18:16:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151704",
    "user": "SimonKing"
}
```

Replying to [comment:7 leif]:
> Currently changing the patch to remove the (in your opinion) undesirable link to `__init__.py` earlier, such that `cython`, when invoked, won't see it.

That wouldn't be a solution. Perhaps the user *wants* (for some reason) to have it in the folder (in particular, it is no user error).

I believe that it should simply not matter for attaching files whether or not `__init__.py` is there. Of course, if you have a Python file and want that you can import (not attach) it, then you would create the `__init__.py` (this is why I created it, anyway).

Attaching a file should be independent from importing, and both should simultaneously be possible. So, unlinking `__init__.py` is bad.

Up to yesterday, I was in the belief that "attaching a pyx-file" means that

1. the file is copied into a temporary directory,
2. the compilation is done there, and
3. the module is imported from the temporary directory.

Since the temporary directory would not contain `__init__.py`, there should be no problem, isn't it?



---

archive/issue_comments_151705.json:
```json
{
    "body": "Replying to [comment:8 SimonKing]:\n> Replying to [comment:7 leif]:\n> > Currently changing the patch to remove the (in your opinion) undesirable link to `__init__.py` earlier, such that `cython`, when invoked, won't see it.\n> \n> That wouldn't be a solution. Perhaps the user *wants* (for some reason) to have it in the folder (in particular, it is no user error).\n\nIn the temporary build folder?  Not sure whether there are situations where this is needed.\n\nThis one works for me:\n\n```patch\ndiff --git a/sage/misc/cython.py b/sage/misc/cython.py\n--- a/sage/misc/cython.py\n+++ b/sage/misc/cython.py\n@@ -382,6 +382,10 @@\n         os.system(cmd)\n         if os.path.exists(\"%s/setup.py\" % build_dir):\n             os.unlink(\"%s/setup.py\" % build_dir)\n+        if os.path.exists(\"%s/__init__.py\" % build_dir):\n+            sys.stderr.write(\"Note: Ignoring %s/__init__.py ...\\n\" % abs_base)\n+            sys.stderr.flush()\n+            os.unlink(\"%s/__init__.py\" % build_dir)\n \n     if compile_message:\n         print \"Compiling %s...\"%filename\n```\n\n\nNo idea whether it breaks anything else.  Note that you have to run `./sage -b` after changing the file, which in turn causes (for whatever reason) dozens of extension modules to get rebuilt.\n\nIn case having `__init__.py` in the temporary build directory is desirable, we could just restore the link after Cython has been run.\n\n\n\n \n> I believe that it should simply not matter for attaching files whether or not `__init__.py` is there. Of course, if you have a Python file and want that you can import (not attach) it, then you would create the `__init__.py` (this is why I created it, anyway).\n> \n> Attaching a file should be independent from importing, and both should simultaneously be possible. So, unlinking `__init__.py` is bad.\n\nImporting in the usual way should still work, since you don't import from the temporary directory, do you?\n\n\n\n\n> Up to yesterday, I was in the belief that \"attaching a pyx-file means\" that\n> \n>  1. the file is copied into a temporary directory,\n>  2. the compilation is done there, and\n>  3. the module is imported from the temporary directory.\n\nThat's correct.  But in addition, symbolic links to any(!) file in the directory containing the attached file are created in the temporary directory (since e.g. you otherwise wouldn't be able to import or include other files in that directory from the attached file).  Above, I've only changed that part.\n\n> Since the temporary directory would not contain `__init__.py`, there should be no problem, isn't it?\n\nThat's what I was saying.  (Unless you try to `import __init__` in the attached file...)",
    "created_at": "2012-04-22T18:42:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151705",
    "user": "leif"
}
```

Replying to [comment:8 SimonKing]:
> Replying to [comment:7 leif]:
> > Currently changing the patch to remove the (in your opinion) undesirable link to `__init__.py` earlier, such that `cython`, when invoked, won't see it.
> 
> That wouldn't be a solution. Perhaps the user *wants* (for some reason) to have it in the folder (in particular, it is no user error).

In the temporary build folder?  Not sure whether there are situations where this is needed.

This one works for me:

```patch
diff --git a/sage/misc/cython.py b/sage/misc/cython.py
--- a/sage/misc/cython.py
+++ b/sage/misc/cython.py
@@ -382,6 +382,10 @@
         os.system(cmd)
         if os.path.exists("%s/setup.py" % build_dir):
             os.unlink("%s/setup.py" % build_dir)
+        if os.path.exists("%s/__init__.py" % build_dir):
+            sys.stderr.write("Note: Ignoring %s/__init__.py ...\n" % abs_base)
+            sys.stderr.flush()
+            os.unlink("%s/__init__.py" % build_dir)
 
     if compile_message:
         print "Compiling %s..."%filename
```


No idea whether it breaks anything else.  Note that you have to run `./sage -b` after changing the file, which in turn causes (for whatever reason) dozens of extension modules to get rebuilt.

In case having `__init__.py` in the temporary build directory is desirable, we could just restore the link after Cython has been run.



 
> I believe that it should simply not matter for attaching files whether or not `__init__.py` is there. Of course, if you have a Python file and want that you can import (not attach) it, then you would create the `__init__.py` (this is why I created it, anyway).
> 
> Attaching a file should be independent from importing, and both should simultaneously be possible. So, unlinking `__init__.py` is bad.

Importing in the usual way should still work, since you don't import from the temporary directory, do you?




> Up to yesterday, I was in the belief that "attaching a pyx-file means" that
> 
>  1. the file is copied into a temporary directory,
>  2. the compilation is done there, and
>  3. the module is imported from the temporary directory.

That's correct.  But in addition, symbolic links to any(!) file in the directory containing the attached file are created in the temporary directory (since e.g. you otherwise wouldn't be able to import or include other files in that directory from the attached file).  Above, I've only changed that part.

> Since the temporary directory would not contain `__init__.py`, there should be no problem, isn't it?

That's what I was saying.  (Unless you try to `import __init__` in the attached file...)



---

archive/issue_comments_151706.json:
```json
{
    "body": "Replying to [comment:9 leif]:\n> > That wouldn't be a solution. Perhaps the user *wants* (for some reason) to have it in the folder (in particular, it is no user error).\n> \n> In the temporary build folder?  Not sure whether there are situations where this is needed.\n\nNo, in the original folder.\n \n> This one works for me:\n> {{{\n> #!patch\n> diff --git a/sage/misc/cython.py b/sage/misc/cython.py\n> --- a/sage/misc/cython.py\n> +++ b/sage/misc/cython.py\n> `@``@` -382,6 +382,10 `@``@`\n>          os.system(cmd)\n>          if os.path.exists(\"%s/setup.py\" % build_dir):\n>              os.unlink(\"%s/setup.py\" % build_dir)\n> +        if os.path.exists(\"%s/__init__.py\" % build_dir):\n> +            sys.stderr.write(\"Note: Ignoring %s/__init__.py ...\\n\" % abs_base)\n> +            sys.stderr.flush()\n> +            os.unlink(\"%s/__init__.py\" % build_dir)\n>  \n>      if compile_message:\n>          print \"Compiling %s...\"%filename\n> }}}\n> ...\n> That's correct.  But in addition, symbolic links to any(!) file in the directory containing the attached file are created in the temporary directory (since e.g. you otherwise wouldn't be able to import or include other files in that directory from the attached file).  Above, I've only changed that part.\n\nI see! So, you are not unlinking it from the original directory.\n\n> That's what I was saying.  (Unless you try to `import __init__` in the attached file...)\n\nHm. Difficult to tell. If you have files `foo.pyx` and `bar.py` in your folder, and in `foo.pyx` you want to do `from bar import Bar`, then I guess you need to have `__init__.py` in *the folder in which the compilation happens*, isn't it? So, there are situations in which the presence of `__init__.py` in the temporary folder (via a symbolic link) makes sense.\n\nThe best solution would be to patch Cython, so that the wrong naming of modules does not occur (in some post above, I think it was shown that the naming is chosen by Cython, not by distutils).",
    "created_at": "2012-04-22T18:56:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151706",
    "user": "SimonKing"
}
```

Replying to [comment:9 leif]:
> > That wouldn't be a solution. Perhaps the user *wants* (for some reason) to have it in the folder (in particular, it is no user error).
> 
> In the temporary build folder?  Not sure whether there are situations where this is needed.

No, in the original folder.
 
> This one works for me:
> {{{
> #!patch
> diff --git a/sage/misc/cython.py b/sage/misc/cython.py
> --- a/sage/misc/cython.py
> +++ b/sage/misc/cython.py
> `@``@` -382,6 +382,10 `@``@`
>          os.system(cmd)
>          if os.path.exists("%s/setup.py" % build_dir):
>              os.unlink("%s/setup.py" % build_dir)
> +        if os.path.exists("%s/__init__.py" % build_dir):
> +            sys.stderr.write("Note: Ignoring %s/__init__.py ...\n" % abs_base)
> +            sys.stderr.flush()
> +            os.unlink("%s/__init__.py" % build_dir)
>  
>      if compile_message:
>          print "Compiling %s..."%filename
> }}}
> ...
> That's correct.  But in addition, symbolic links to any(!) file in the directory containing the attached file are created in the temporary directory (since e.g. you otherwise wouldn't be able to import or include other files in that directory from the attached file).  Above, I've only changed that part.

I see! So, you are not unlinking it from the original directory.

> That's what I was saying.  (Unless you try to `import __init__` in the attached file...)

Hm. Difficult to tell. If you have files `foo.pyx` and `bar.py` in your folder, and in `foo.pyx` you want to do `from bar import Bar`, then I guess you need to have `__init__.py` in *the folder in which the compilation happens*, isn't it? So, there are situations in which the presence of `__init__.py` in the temporary folder (via a symbolic link) makes sense.

The best solution would be to patch Cython, so that the wrong naming of modules does not occur (in some post above, I think it was shown that the naming is chosen by Cython, not by distutils).



---

archive/issue_comments_151707.json:
```json
{
    "body": "Replying to [comment:9 leif]:\n> [...] in addition, symbolic links to any(!) file in the directory containing the attached file are created in the temporary directory (since e.g. you otherwise wouldn't be able to import or include other files in that directory from the attached file).\n\nOf course there are other, probably smarter (though not necessarily simpler) ways to achieve this, e.g. by modifying `sys.path` for the attached module, and by passing according `-I` options to `cython` (although I think the generated `setup.py` already takes care of the latter).",
    "created_at": "2012-04-22T18:57:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151707",
    "user": "leif"
}
```

Replying to [comment:9 leif]:
> [...] in addition, symbolic links to any(!) file in the directory containing the attached file are created in the temporary directory (since e.g. you otherwise wouldn't be able to import or include other files in that directory from the attached file).

Of course there are other, probably smarter (though not necessarily simpler) ways to achieve this, e.g. by modifying `sys.path` for the attached module, and by passing according `-I` options to `cython` (although I think the generated `setup.py` already takes care of the latter).



---

archive/issue_comments_151708.json:
```json
{
    "body": "Replying to [comment:10 SimonKing]:\n> The best solution would be to patch Cython, so that the wrong naming of modules does not occur (in some post above, I think it was shown that the naming is chosen by Cython, not by distutils).\n\nI don't think Cython is wrong by what it does, as `__init__.py` files belong to the package (and hence directory) they're contained in, i.e. `.../<package_name>/__init__.py` belongs to `<package_name>`.  \n\nConsequently, all `.py` and `.pyx` files there also belong to that package, hence their module names get the package prefix.",
    "created_at": "2012-04-22T19:16:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151708",
    "user": "leif"
}
```

Replying to [comment:10 SimonKing]:
> The best solution would be to patch Cython, so that the wrong naming of modules does not occur (in some post above, I think it was shown that the naming is chosen by Cython, not by distutils).

I don't think Cython is wrong by what it does, as `__init__.py` files belong to the package (and hence directory) they're contained in, i.e. `.../<package_name>/__init__.py` belongs to `<package_name>`.  

Consequently, all `.py` and `.pyx` files there also belong to that package, hence their module names get the package prefix.



---

archive/issue_comments_151709.json:
```json
{
    "body": "Replying to [comment:6 SimonKing]:\n> Replying to [comment:5 leif]:\n> > ... the following does **not** solve your problem (if it really is one):\n> \n> We have a module containing a class bla, but `sys.modules[bla.__module__]` gives a key error. I am surprised that you question whether that is a problem.\n\nThat should IMHO be solvable by importing / loading the module differently, although I think you run into the same if for example you create links to extension modules and import from these rather than their original location.  So I'm not sure if it really is an error.",
    "created_at": "2012-04-22T19:33:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151709",
    "user": "leif"
}
```

Replying to [comment:6 SimonKing]:
> Replying to [comment:5 leif]:
> > ... the following does **not** solve your problem (if it really is one):
> 
> We have a module containing a class bla, but `sys.modules[bla.__module__]` gives a key error. I am surprised that you question whether that is a problem.

That should IMHO be solvable by importing / loading the module differently, although I think you run into the same if for example you create links to extension modules and import from these rather than their original location.  So I'm not sure if it really is an error.



---

archive/issue_comments_151710.json:
```json
{
    "body": "Replying to [comment:13 leif]:\n> Replying to [comment:6 SimonKing]:\n> > Replying to [comment:5 leif]:\n> > > ... the following does **not** solve your problem (if it really is one):\n> > \n> > We have a module containing a class bla, but `sys.modules[bla.__module__]` gives a key error. I am surprised that you question whether that is a problem.\n> \n> That should IMHO be solvable by importing / loading the module differently, although I think you run into the same if for example you create links to extension modules and import from these rather than their original location.\n\nI think that's actually a cleaner (and probably also safer) solution.\n\n\n```diff\ndiff --git a/sage/misc/cython.py b/sage/misc/cython.py\n--- a/sage/misc/cython.py\n+++ b/sage/misc/cython.py\n@@ -382,6 +382,10 @@\n         os.system(cmd)\n         if os.path.exists(\"%s/setup.py\" % build_dir):\n             os.unlink(\"%s/setup.py\" % build_dir)\n+        if os.path.exists(\"%s/__init__.py\" % build_dir):\n+            sys.stderr.write(\"Note: Not ignoring %s/__init__.py ...\\n\" % abs_base)\n+            sys.stderr.flush()\n+            # os.unlink(\"%s/__init__.py\" % build_dir)\n \n     if compile_message:\n         print \"Compiling %s...\"%filename\n@@ -527,7 +531,13 @@\n         if os.system(cmd):\n             raise RuntimeError, \"Error making local copy of shared object library for %s\"%filename\n \n-    return name, build_dir\n+    if os.path.exists(\"%s/__init__.py\" % build_dir):\n+        # In that case, the module name Cython creates contains the package\n+        # name, i.e., the name of the directory the file is contained in.\n+        assert not build_dir.endswith(os.path.sep)\n+        return \"%s.%s\" % (base, name), os.path.dirname(build_dir)\n+    else:\n+        return name, build_dir\n \n \n \n```\n\n\nNote that *this* change has the side effect that now `__init__.py` also gets executed, which IMHO is the desired behaviour:\n\n```\nsage: attach(\"/tmp/foo/foo.pyx\")\nNote: Not ignoring /tmp/foo/__init__.py ...\nCompiling /tmp/foo/foo.pyx...\nHello, I'm '/tmp/foo/__init__.py'.\nsage: bar.__module__\n'_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0'\nsage: sys.modules[bar.__module__]\n<module '_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0' from '/home/leif/.sage//temp/sleepless/21086//spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so'>\nsage: bar?\nType:\t\tclassobj\nString Form:\t_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0.bar\nNamespace:\tInteractive\nLoaded File:\t/home/leif/.sage/temp/sleepless/21086/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so\nSource File:\t/home/leif/.sage/temp/sleepless/21086/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so\n\nsage: \n```\n",
    "created_at": "2012-04-22T20:34:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151710",
    "user": "leif"
}
```

Replying to [comment:13 leif]:
> Replying to [comment:6 SimonKing]:
> > Replying to [comment:5 leif]:
> > > ... the following does **not** solve your problem (if it really is one):
> > 
> > We have a module containing a class bla, but `sys.modules[bla.__module__]` gives a key error. I am surprised that you question whether that is a problem.
> 
> That should IMHO be solvable by importing / loading the module differently, although I think you run into the same if for example you create links to extension modules and import from these rather than their original location.

I think that's actually a cleaner (and probably also safer) solution.


```diff
diff --git a/sage/misc/cython.py b/sage/misc/cython.py
--- a/sage/misc/cython.py
+++ b/sage/misc/cython.py
@@ -382,6 +382,10 @@
         os.system(cmd)
         if os.path.exists("%s/setup.py" % build_dir):
             os.unlink("%s/setup.py" % build_dir)
+        if os.path.exists("%s/__init__.py" % build_dir):
+            sys.stderr.write("Note: Not ignoring %s/__init__.py ...\n" % abs_base)
+            sys.stderr.flush()
+            # os.unlink("%s/__init__.py" % build_dir)
 
     if compile_message:
         print "Compiling %s..."%filename
@@ -527,7 +531,13 @@
         if os.system(cmd):
             raise RuntimeError, "Error making local copy of shared object library for %s"%filename
 
-    return name, build_dir
+    if os.path.exists("%s/__init__.py" % build_dir):
+        # In that case, the module name Cython creates contains the package
+        # name, i.e., the name of the directory the file is contained in.
+        assert not build_dir.endswith(os.path.sep)
+        return "%s.%s" % (base, name), os.path.dirname(build_dir)
+    else:
+        return name, build_dir
 
 
 
```


Note that *this* change has the side effect that now `__init__.py` also gets executed, which IMHO is the desired behaviour:

```
sage: attach("/tmp/foo/foo.pyx")
Note: Not ignoring /tmp/foo/__init__.py ...
Compiling /tmp/foo/foo.pyx...
Hello, I'm '/tmp/foo/__init__.py'.
sage: bar.__module__
'_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0'
sage: sys.modules[bar.__module__]
<module '_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0' from '/home/leif/.sage//temp/sleepless/21086//spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so'>
sage: bar?
Type:		classobj
String Form:	_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0.bar
Namespace:	Interactive
Loaded File:	/home/leif/.sage/temp/sleepless/21086/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so
Source File:	/home/leif/.sage/temp/sleepless/21086/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so

sage: 
```




---

archive/issue_comments_151711.json:
```json
{
    "body": "Just checked:  Imports in the attached file also work properly; the imported modules also get the (temporary) package name prepended:\n\n\n```\nsage: attach(\"/tmp/foo/foo.pyx\")\nNote: Not ignoring /tmp/foo/__init__.py ...\nCompiling /tmp/foo/foo.pyx...\nHello, I'm '/tmp/foo/__init__.py'.\nsage: bar.__module__\n'_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0'\nsage: sys.modules[bar.__module__]\n<module '_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0' from '/home/leif/.sage//temp/sleepless/21279//spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so'>\nsage: bar?\nType:\t\tclassobj\nString Form:\t_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0.bar\nNamespace:\tInteractive\nLoaded File:\t/home/leif/.sage/temp/sleepless/21279/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so\nSource File:\t/home/leif/.sage/temp/sleepless/21279/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so\n\nsage: Baz?\nType:\t\tclassobj\nString Form:\t_tmp_foo_foo_pyx.baz.Baz\nNamespace:\tInteractive\nLoaded File:\t/home/leif/.sage/temp/sleepless/21279/spyx/_tmp_foo_foo_pyx/baz.py\nSource File:\t/home/leif/.sage/temp/sleepless/21279/spyx/_tmp_foo_foo_pyx/baz.py\n\nsage: Baz.__module__\n'_tmp_foo_foo_pyx.baz'\nsage: !cat /tmp/foo/foo.pyx\n# foo.pyx\n\nfrom baz import Baz\n\nclass bar:\n    pass\n\nsage: !cat /tmp/foo/baz.py\n# baz.py\n\nclass Baz:\n    pass\nsage: \n```\n",
    "created_at": "2012-04-22T20:51:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151711",
    "user": "leif"
}
```

Just checked:  Imports in the attached file also work properly; the imported modules also get the (temporary) package name prepended:


```
sage: attach("/tmp/foo/foo.pyx")
Note: Not ignoring /tmp/foo/__init__.py ...
Compiling /tmp/foo/foo.pyx...
Hello, I'm '/tmp/foo/__init__.py'.
sage: bar.__module__
'_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0'
sage: sys.modules[bar.__module__]
<module '_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0' from '/home/leif/.sage//temp/sleepless/21279//spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so'>
sage: bar?
Type:		classobj
String Form:	_tmp_foo_foo_pyx._tmp_foo_foo_pyx_0.bar
Namespace:	Interactive
Loaded File:	/home/leif/.sage/temp/sleepless/21279/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so
Source File:	/home/leif/.sage/temp/sleepless/21279/spyx/_tmp_foo_foo_pyx/_tmp_foo_foo_pyx_0.so

sage: Baz?
Type:		classobj
String Form:	_tmp_foo_foo_pyx.baz.Baz
Namespace:	Interactive
Loaded File:	/home/leif/.sage/temp/sleepless/21279/spyx/_tmp_foo_foo_pyx/baz.py
Source File:	/home/leif/.sage/temp/sleepless/21279/spyx/_tmp_foo_foo_pyx/baz.py

sage: Baz.__module__
'_tmp_foo_foo_pyx.baz'
sage: !cat /tmp/foo/foo.pyx
# foo.pyx

from baz import Baz

class bar:
    pass

sage: !cat /tmp/foo/baz.py
# baz.py

class Baz:
    pass
sage: 
```




---

archive/issue_comments_151712.json:
```json
{
    "body": "I'll attach a proper patch after further testing.",
    "created_at": "2012-04-22T21:25:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12696",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12696#issuecomment-151712",
    "user": "leif"
}
```

I'll attach a proper patch after further testing.
