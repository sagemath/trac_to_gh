# Issue 15078: new module: finite state machines, automata, transducers

archive/issues_014841.json:
```json
{
    "body": "CC:  @eviatarbach tmonteil @cheuberg\n\nKeywords: finite state machines, automaton, transducer\n\nThis module adds a class for \n- finite state machine,\n- finite automaton,\n- finite transducer.\n\nApply only [attachment:trac_15078_fsm_automata_transducers.8.patch]\n\nIssue created by migration from https://trac.sagemath.org/ticket/15078\n\n",
    "closed_at": "2013-12-05T08:01:48Z",
    "created_at": "2013-08-22T12:34:31Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.13",
    "title": "new module: finite state machines, automata, transducers",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15078",
    "user": "https://github.com/dkrenn"
}
```
CC:  @eviatarbach tmonteil @cheuberg

Keywords: finite state machines, automaton, transducer

This module adds a class for 
- finite state machine,
- finite automaton,
- finite transducer.

Apply only [attachment:trac_15078_fsm_automata_transducers.8.patch]

Issue created by migration from https://trac.sagemath.org/ticket/15078





---

archive/issue_comments_189051.json:
```json
{
    "body": "Attachment [trac_15078_fsm_automata_transducers.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.patch) by @dkrenn created at 2013-08-22 12:38:25",
    "created_at": "2013-08-22T12:38:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189051",
    "user": "https://github.com/dkrenn"
}
```

Attachment [trac_15078_fsm_automata_transducers.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.patch) by @dkrenn created at 2013-08-22 12:38:25



---

archive/issue_comments_189052.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-08-22T12:39:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189052",
    "user": "https://github.com/dkrenn"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_189053.json:
```json
{
    "body": "The patch does not change anything (except one index.rst and one all.py) in the existing Sage library; please review.",
    "created_at": "2013-08-22T12:42:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189053",
    "user": "https://github.com/dkrenn"
}
```

The patch does not change anything (except one index.rst and one all.py) in the existing Sage library; please review.



---

archive/issue_comments_189054.json:
```json
{
    "body": "Attachment [trac_15078_fsm_docstrings.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_docstrings.patch) by @dkrenn created at 2013-08-22 18:07:19",
    "created_at": "2013-08-22T18:07:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189054",
    "user": "https://github.com/dkrenn"
}
```

Attachment [trac_15078_fsm_docstrings.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_docstrings.patch) by @dkrenn created at 2013-08-22 18:07:19



---

archive/issue_comments_189055.json:
```json
{
    "body": "Attachment [trac_15078_fsm_automata_transducers.2.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.2.patch) by @dkrenn created at 2013-09-03 08:21:31",
    "created_at": "2013-09-03T08:21:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189055",
    "user": "https://github.com/dkrenn"
}
```

Attachment [trac_15078_fsm_automata_transducers.2.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.2.patch) by @dkrenn created at 2013-09-03 08:21:31



---

archive/issue_comments_189056.json:
```json
{
    "body": "Another change in the docstrings, all changes are now in trac_15078_fsm_automata_transducers.2.patch",
    "created_at": "2013-09-03T08:23:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189056",
    "user": "https://github.com/dkrenn"
}
```

Another change in the docstrings, all changes are now in trac_15078_fsm_automata_transducers.2.patch



---

archive/issue_comments_189057.json:
```json
{
    "body": "Here is the report of `pyflakes`\n\nsage/combinat/finite_state_machine.py:293: 'SR' imported but unused\nsage/combinat/finite_state_machine.py:1074: local variable 'from_state' is assigned to but never used\nsage/combinat/finite_state_machine.py:1077: local variable 'to_state' is assigned to but never used\nsage/combinat/finite_state_machine.py:1160: redefinition of unused 'itertools' from line 304\nsage/combinat/finite_state_machine.py:2213: local variable 'to_state' is assigned to but never used\nsage/combinat/finite_state_machine.py:3372: local variable 'new_transition' is assigned to but never used\n\nThis needs to be cleaned",
    "created_at": "2013-09-12T13:02:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189057",
    "user": "https://github.com/fchapoton"
}
```

Here is the report of `pyflakes`

sage/combinat/finite_state_machine.py:293: 'SR' imported but unused
sage/combinat/finite_state_machine.py:1074: local variable 'from_state' is assigned to but never used
sage/combinat/finite_state_machine.py:1077: local variable 'to_state' is assigned to but never used
sage/combinat/finite_state_machine.py:1160: redefinition of unused 'itertools' from line 304
sage/combinat/finite_state_machine.py:2213: local variable 'to_state' is assigned to but never used
sage/combinat/finite_state_machine.py:3372: local variable 'new_transition' is assigned to but never used

This needs to be cleaned



---

archive/issue_comments_189058.json:
```json
{
    "body": "Hi all,\n\nRight now I just have a quick look but\n\n- the lot of examples at the begining are very nice!\n- conditional_iterator is ifilter in the module [itertools](http://docs.python.org/2/library/itertools.html) \n- you should use Word and Words (in sage.combinat.words)\n\nVincent",
    "created_at": "2013-09-12T13:15:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189058",
    "user": "https://github.com/videlec"
}
```

Hi all,

Right now I just have a quick look but

- the lot of examples at the begining are very nice!
- conditional_iterator is ifilter in the module [itertools](http://docs.python.org/2/library/itertools.html) 
- you should use Word and Words (in sage.combinat.words)

Vincent



---

archive/issue_comments_189059.json:
```json
{
    "body": "INPUT/OUTPUT needs to be documented in every method (see developer manual)\n\nAre you sure you need `FSMProcessIterator` in the global namespace? Similarly, instead of `FSMstate` and `FSMtransition`, which are useless by themselves, just do\n\n```\n    sage: fsm = FiniteStateMachine() \n    sage: day = fsm.add_state('day')\n    sage: night = fsm.add_state('night')\n    sage: sunrise = fsm.add_transition(night, day)\n```\nin addition to \n\n```\n    sage: sunrise = fsm.add_transition('night', 'day')\n```\nAlso, instead of reinventing the mutability wheel there is `sage.structure.mutability.Mutability` to inherit from.",
    "created_at": "2013-09-12T14:23:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189059",
    "user": "https://github.com/vbraun"
}
```

INPUT/OUTPUT needs to be documented in every method (see developer manual)

Are you sure you need `FSMProcessIterator` in the global namespace? Similarly, instead of `FSMstate` and `FSMtransition`, which are useless by themselves, just do

```
    sage: fsm = FiniteStateMachine() 
    sage: day = fsm.add_state('day')
    sage: night = fsm.add_state('night')
    sage: sunrise = fsm.add_transition(night, day)
```
in addition to 

```
    sage: sunrise = fsm.add_transition('night', 'day')
```
Also, instead of reinventing the mutability wheel there is `sage.structure.mutability.Mutability` to inherit from.



---

archive/issue_comments_189060.json:
```json
{
    "body": "Nice! I was needing such a class for a while! I don't know if you should really use sage.combinat.words stuff in your code, maybe in a method `def language(self, n)` of `FiniteStateMachine` that would return an iterator over all words of length n recognized by the automaton. Anyhow, sage.combinat.words will definitively benefits from it, for instance for representing automatic sequences.\n\nI agree with both comments of vbraun above. The code is well written. Only small fixes must be done like adding INPUT and OUPUT blocks and follow Python convention of having one space before and after `=` character (except for arguments of a function). See PEP 8 at http://www.python.org/dev/peps/pep-0008/",
    "created_at": "2013-09-12T15:19:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189060",
    "user": "https://github.com/seblabbe"
}
```

Nice! I was needing such a class for a while! I don't know if you should really use sage.combinat.words stuff in your code, maybe in a method `def language(self, n)` of `FiniteStateMachine` that would return an iterator over all words of length n recognized by the automaton. Anyhow, sage.combinat.words will definitively benefits from it, for instance for representing automatic sequences.

I agree with both comments of vbraun above. The code is well written. Only small fixes must be done like adding INPUT and OUPUT blocks and follow Python convention of having one space before and after `=` character (except for arguments of a function). See PEP 8 at http://www.python.org/dev/peps/pep-0008/



---

archive/issue_comments_189061.json:
```json
{
    "body": "for the bot : apply only trac_15078_fsm_automata_transducers.2.patch",
    "created_at": "2013-09-15T18:51:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189061",
    "user": "https://github.com/fchapoton"
}
```

for the bot : apply only trac_15078_fsm_automata_transducers.2.patch



---

archive/issue_comments_189062.json:
```json
{
    "body": "I did some small tests yesterday. Below are few of them.\n\nIn the following example, the output of process should be True, but it returns False. Should the `process` method raise an `NotImplementedError` if the automaton is not deterministic?::\n\n```\n    sage: D = {'A': [('A', 'a'), ('B', 'a'), ('A', 'b')], 'C': [], 'B': [('C', 'b')]}\n    sage: auto = Automaton(D, initial_states=['A'], final_states=['C'])\n    sage: auto.is_deterministic()\n    False\n    sage: auto.process(list('aaab'))\n    (False, State 'A', [])\n```\n\nThe determinisation is broken for this automaton. Why?::\n\n```\n    sage: auto.states()\n    [State 'A', State 'B', State 'C']\n    sage: auto.determinisation()\n    ...\n    LookupError: No state with label State 'A' found.\n```\n\nApparently, label needs to be integers for determinisation to work? ::\n\n```\n    sage: L = [('A', 'A', 0), ('A', 'B', 0), ('A','A',1), ('B','C', 1)]\n    sage: auto = Automaton(L, initial_states=['A'], final_states=['C'])\n    sage: auto.process([0, 0, 0, 1])\n    (False, State 'A', [])\n    sage: auto.determinisation()\n    finite state machine with 3 states\n    sage: auto.determinisation().states()\n    [State frozenset(['A']), State frozenset(['A', 'B']), State frozenset(['A', 'C'])]\n```\n\nCheers!",
    "created_at": "2013-10-02T09:03:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189062",
    "user": "https://github.com/seblabbe"
}
```

I did some small tests yesterday. Below are few of them.

In the following example, the output of process should be True, but it returns False. Should the `process` method raise an `NotImplementedError` if the automaton is not deterministic?::

```
    sage: D = {'A': [('A', 'a'), ('B', 'a'), ('A', 'b')], 'C': [], 'B': [('C', 'b')]}
    sage: auto = Automaton(D, initial_states=['A'], final_states=['C'])
    sage: auto.is_deterministic()
    False
    sage: auto.process(list('aaab'))
    (False, State 'A', [])
```

The determinisation is broken for this automaton. Why?::

```
    sage: auto.states()
    [State 'A', State 'B', State 'C']
    sage: auto.determinisation()
    ...
    LookupError: No state with label State 'A' found.
```

Apparently, label needs to be integers for determinisation to work? ::

```
    sage: L = [('A', 'A', 0), ('A', 'B', 0), ('A','A',1), ('B','C', 1)]
    sage: auto = Automaton(L, initial_states=['A'], final_states=['C'])
    sage: auto.process([0, 0, 0, 1])
    (False, State 'A', [])
    sage: auto.determinisation()
    finite state machine with 3 states
    sage: auto.determinisation().states()
    [State frozenset(['A']), State frozenset(['A', 'B']), State frozenset(['A', 'C'])]
```

Cheers!



---

archive/issue_comments_189063.json:
```json
{
    "body": "Attachment [trac_15078_fsm_automata_transducers.3.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.3.patch) by @dkrenn created at 2013-10-09 11:44:03",
    "created_at": "2013-10-09T11:44:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189063",
    "user": "https://github.com/dkrenn"
}
```

Attachment [trac_15078_fsm_automata_transducers.3.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.3.patch) by @dkrenn created at 2013-10-09 11:44:03



---

archive/issue_comments_189064.json:
```json
{
    "body": "I've uploaded a new patch: http://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.3.patch\nIt is already rebased to 5.12\n\nReplying to [comment:7 chapoton]:\n> Here is the report of `pyflakes` [...]\n> This needs to be cleaned\n\n\nDone.\n\nReplying to [comment:8 vdelecroix]:\n>  - conditional_iterator is ifilter in the module [itertools](http://docs.python.org/2/library/itertools.html) \n\n\nChanged.\n\n>  - you should use Word and Words (in sage.combinat.words)\n\n\nSee #15267 together with comments below.\n\nReplying to [comment:9 vbraun]:\n> INPUT/OUTPUT needs to be documented in every method (see developer manual)\n\n\nDone.\n\n> Are you sure you need `FSMProcessIterator` in the global namespace? Similarly, instead of `FSMstate` and `FSMtransition` [...]\n\n\nThose things are now local. Only `FiniteStateMachine`, `Automaton` and `Transducer` are now global.\n\n> Also, instead of reinventing the mutability wheel there is `sage.structure.mutability.Mutability` to inherit from.\n\n\nThis is now #15266 (which can be solved after #15264). See also the discussion \"Mutability\" on sage-devel \u200bhttps://groups.google.com/forum/#!topic/sage-devel/dnXSgh56Boo\n\nReplying to [comment:10 slabbe]:\n> I don't know if you should really use sage.combinat.words stuff in your code, maybe in a method `def language(self, n)` of `FiniteStateMachine` that would return an iterator over all words of length n recognized by the automaton. Anyhow, sage.combinat.words will definitively benefits from it, for instance for representing automatic sequences.\n\n\nThis is now #15267.\n\n> I agree with both comments of vbraun above. The code is well written. Only small fixes must be done like adding INPUT and OUPUT blocks and follow Python convention of having one space before and after `=` character (except for arguments of a function). See PEP 8 at http://www.python.org/dev/peps/pep-0008/\n\n\nI thought I followed those rules. Anyhow, I found some misplaced spaces and non-spaces. Now changed (and hopefully nothing missed).\n\nReplying to [comment:13 slabbe]:\n> In the following example, the output of process should be True, but it returns False. Should the `process` method raise an `NotImplementedError` if the automaton is not deterministic?::\n> \n> \n> ```\n>     sage: D = {'A': [('A', 'a'), ('B', 'a'), ('A', 'b')], 'C': [], 'B': [('C', 'b')]}\n>     sage: auto = Automaton(D, initial_states=['A'], final_states=['C'])\n>     sage: auto.is_deterministic()\n>     False\n>     sage: auto.process(list('aaab'))\n>     (False, State 'A', [])\n> ```\n\n\nNo, I would not raise a `NotImplementedError`, since it isn't one, but just one possible outcome is given. But I agree that it could be a problem. Therefore I added a comment in the documentation of `process`.\n\n> The determinisation is broken for this automaton. Why?::\n> \n> \n> ```\n>     sage: auto.states()\n>     [State 'A', State 'B', State 'C']\n>     sage: auto.determinisation()\n>     ...\n>     LookupError: No state with label State 'A' found.\n> ```\n\n\nI cannot reproduce this behaviour. Anyhow, I added the example above as a doctest.",
    "created_at": "2013-10-09T12:00:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189064",
    "user": "https://github.com/dkrenn"
}
```

I've uploaded a new patch: http://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.3.patch
It is already rebased to 5.12

Replying to [comment:7 chapoton]:
> Here is the report of `pyflakes` [...]
> This needs to be cleaned


Done.

Replying to [comment:8 vdelecroix]:
>  - conditional_iterator is ifilter in the module [itertools](http://docs.python.org/2/library/itertools.html) 


Changed.

>  - you should use Word and Words (in sage.combinat.words)


See #15267 together with comments below.

Replying to [comment:9 vbraun]:
> INPUT/OUTPUT needs to be documented in every method (see developer manual)


Done.

> Are you sure you need `FSMProcessIterator` in the global namespace? Similarly, instead of `FSMstate` and `FSMtransition` [...]


Those things are now local. Only `FiniteStateMachine`, `Automaton` and `Transducer` are now global.

> Also, instead of reinventing the mutability wheel there is `sage.structure.mutability.Mutability` to inherit from.


This is now #15266 (which can be solved after #15264). See also the discussion "Mutability" on sage-devel ​https://groups.google.com/forum/#!topic/sage-devel/dnXSgh56Boo

Replying to [comment:10 slabbe]:
> I don't know if you should really use sage.combinat.words stuff in your code, maybe in a method `def language(self, n)` of `FiniteStateMachine` that would return an iterator over all words of length n recognized by the automaton. Anyhow, sage.combinat.words will definitively benefits from it, for instance for representing automatic sequences.


This is now #15267.

> I agree with both comments of vbraun above. The code is well written. Only small fixes must be done like adding INPUT and OUPUT blocks and follow Python convention of having one space before and after `=` character (except for arguments of a function). See PEP 8 at http://www.python.org/dev/peps/pep-0008/


I thought I followed those rules. Anyhow, I found some misplaced spaces and non-spaces. Now changed (and hopefully nothing missed).

Replying to [comment:13 slabbe]:
> In the following example, the output of process should be True, but it returns False. Should the `process` method raise an `NotImplementedError` if the automaton is not deterministic?::
> 
> 
> ```
>     sage: D = {'A': [('A', 'a'), ('B', 'a'), ('A', 'b')], 'C': [], 'B': [('C', 'b')]}
>     sage: auto = Automaton(D, initial_states=['A'], final_states=['C'])
>     sage: auto.is_deterministic()
>     False
>     sage: auto.process(list('aaab'))
>     (False, State 'A', [])
> ```


No, I would not raise a `NotImplementedError`, since it isn't one, but just one possible outcome is given. But I agree that it could be a problem. Therefore I added a comment in the documentation of `process`.

> The determinisation is broken for this automaton. Why?::
> 
> 
> ```
>     sage: auto.states()
>     [State 'A', State 'B', State 'C']
>     sage: auto.determinisation()
>     ...
>     LookupError: No state with label State 'A' found.
> ```


I cannot reproduce this behaviour. Anyhow, I added the example above as a doctest.



---

archive/issue_comments_189065.json:
```json
{
    "body": "Attachment [trac_15078_fsm_automata_transducers.4.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.4.patch) by @dkrenn created at 2013-11-04 16:01:40",
    "created_at": "2013-11-04T16:01:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189065",
    "user": "https://github.com/dkrenn"
}
```

Attachment [trac_15078_fsm_automata_transducers.4.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.4.patch) by @dkrenn created at 2013-11-04 16:01:40



---

archive/issue_comments_189066.json:
```json
{
    "body": "There is a new version available: http://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.4.patch \nWe fixed some small bugs, made the output of some functions more consistent, and improved the documentation. \n\nWe'd be happy if someone could review the patch.",
    "created_at": "2013-11-04T16:05:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189066",
    "user": "https://github.com/dkrenn"
}
```

There is a new version available: http://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.4.patch 
We fixed some small bugs, made the output of some functions more consistent, and improved the documentation. 

We'd be happy if someone could review the patch.



---

archive/issue_comments_189067.json:
```json
{
    "body": "Attachment [trac_15078_fsm_automata_transducers.5.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.5.patch) by @dkrenn created at 2013-11-04 17:29:05\n\nThe module is now imported lazy. Updated patch is\n\u200bhttp://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.5.patch",
    "created_at": "2013-11-04T17:29:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189067",
    "user": "https://github.com/dkrenn"
}
```

Attachment [trac_15078_fsm_automata_transducers.5.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.5.patch) by @dkrenn created at 2013-11-04 17:29:05

The module is now imported lazy. Updated patch is
​http://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.5.patch



---

archive/issue_comments_189068.json:
```json
{
    "body": "I had a question concerning the choices you made for the classes. Why did you choose to have only one class `FiniteStateMachine` with the mode argument?\n\n```python\ndef Automaton(*args, **kwargs): \n    return FiniteStateMachine(mode='automaton', *args, **kwargs) \n\ndef Transducer(*args, **kwargs): \n    return FiniteStateMachine(mode='transducer', *args, **kwargs)\n```\n\nThe role of this mode argument is usually done transparently by the classes.\nWas it better than having three classes `class FiniteStateMachine(SageObject)`, `class Automaton(FiniteStateMachine)` and `class Transducer(FiniteStateMachine)` ? Another option closer to what you have done could be two classes : `class Transducer(SageObject)` and `class Automaton(Transducer)` ? All this depends on the way the methods are implemented and how much they depends on the class instance. What would be best do you think?\n\nThere is a Sage Afternoon today in Paris. I hope to have time to take a look more deeply at the most recent version of the patch.",
    "created_at": "2013-11-06T12:31:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189068",
    "user": "https://github.com/seblabbe"
}
```

I had a question concerning the choices you made for the classes. Why did you choose to have only one class `FiniteStateMachine` with the mode argument?

```python
def Automaton(*args, **kwargs): 
    return FiniteStateMachine(mode='automaton', *args, **kwargs) 

def Transducer(*args, **kwargs): 
    return FiniteStateMachine(mode='transducer', *args, **kwargs)
```

The role of this mode argument is usually done transparently by the classes.
Was it better than having three classes `class FiniteStateMachine(SageObject)`, `class Automaton(FiniteStateMachine)` and `class Transducer(FiniteStateMachine)` ? Another option closer to what you have done could be two classes : `class Transducer(SageObject)` and `class Automaton(Transducer)` ? All this depends on the way the methods are implemented and how much they depends on the class instance. What would be best do you think?

There is a Sage Afternoon today in Paris. I hope to have time to take a look more deeply at the most recent version of the patch.



---

archive/issue_comments_189069.json:
```json
{
    "body": "I did a more careful reading of the patch today. All tests passed (5.59s for\n552 tests which is quite efficient). Coverage is 100% (115 of 115).\nDocumentation builds fine without warnings.\n\nI am ready to give a positive review to the patch provided the following three\nmore things are fixed.\n\n1. \n\nIn the file `doc/en/reference/combinat/index.rst`, the finite state\nmodule is at the very end of the list after Miscellaneous and Combinatorial\nmaps. I suggest that you put it before the Words section instead.\n\n2.\n\nThe documentation for the `data` input of `FiniteStateMachine` is not\nproperly documented. It is not usual to see such pseudo code examples and they\nare not easy to read, thus not very usefull (personnaly, my eyes do not want to\nlook at them).\n\n```\n    - ``data`` -- can be any of the following:\n\n      - ``{A:{B:{word_in=0, word_out=1}, C:{word_in=1, word_out=1}, ...}``\n      - ``{A:{B:(0, 1), C:(1, 1), ...}``\n      - ``{A:{B:FSMTransition(A, B, 0, 1), C:FSMTransition(A, C, 1, 1), ...}``\n      - ``{A:[(B, 0, 1), (C, 1, 1)], ...}``\n      - ``{A:[FSMTransition(A, B, 0, 1), FSMTransition(A, C, 1, 1)], ...}``\n      - ``[{from_state:A, to_state:B, word_in:0, word_out:1}, \\\n            from_state:A, to_state:C, word_in:1, word_out:1}, ...]``\n      - ``[(A, B, 0, 1), (A, C, 1, 1), ...]``\n      - ``[FSMTransition(A, B, 0, 1), FSMTransition(A, C, 1, 1), ...]``\n```\n\nI suggest that you follow the documentation of `Graph` which\nis now quite good. See:\n\n```\nsage: Graph?\n```\n\nYou will see that the possible cases of data for `Graph`\nare listed verbosely with english words with empty line in between them.  The\nlist is numeroted with numbers. And the same numbers are used below in the\nexamples section where many examples are provided for *each* case.\n\n3.\n\nMake three classes for `FiniteStateMachine`, `Automaton` and `Transducer`.\n\nIndeed, `FiniteStateMachine` has 77 methods. Of those only 7 of them depends\non the `mode` attribute. I have copied below the relevant part of the code\nwhere the `mode` attribute is used in those six methods:\n\n```python\nclass FiniteStateMachine(SageObject):\n    def __init__(self, ..., mode=None, ...):\n        ...\n        self.mode = mode\n        ...\n    def empty_copy(self, memo=None):\n        ...\n        new.mode = deepcopy(self.mode, memo)\n        ...\n    def _latex_(self):\n        ...\n                    if self.mode == 'automaton':\n                        labels.append(format_transition_label(\n                                transition.word_in))\n                    else:\n                        labels.append(format_transition_label(\n                            transition.word_in) + \"\\\\mid\" + \\\n                                format_transition_label(transition.word_out))\n        ...\n    def projection(self, what='input'):\n        new = self.empty_copy()\n        new.mode='automaton'\n        ...\n    def determinisation(self):\n        assert self.mode == 'automaton'\n        ...\n    def minimization(self, algorithm=None):\n        if self.mode is None:\n            raise NotImplementedError, \"The mode attribute must be set.\"\n        if self.mode == 'transducer':\n            raise NotImplementedError, \"Minimization for Transducer is not implemented. Try the simplification method.\"\n        if not self.mode == 'automaton':\n            raise NotImplementedError\n        ...\n    def simplification(self):\n        if self.mode != 'transducer':\n            raise NotImplementedError, \"Simplification is only implemented for Transducers. For Automata, use minimization instead\"\n        ...\n```\n\nI would leave the 70 methods not mentioned above in the class\n`FiniteStateMachine`. Then, according to how each of the 7 methods are used,\nI would do the following for each of them:\n\n- `__init__`: This method can be kept as it is in the `FiniteStateMachine`\n  class and I believe the line `self.mode = mode` can just be deleted.\n- `empty_copy`: This method can be kept in the `FiniteStateMachine` and I\n  believe the line `new.mode = 'automaton'` can just be deleted.\n- `_latex_`: This method can be kept in the `FiniteStateMachine` and I\n  would move the code depending on the mode inside a method in the classes\n  `Automaton` and `Transducer`. This method could be called\n  `_transition_label` or something like that would return the label of a\n  transition in the according way. Maybe this method will just ask the\n  transition to do it.\n- `projection`: This method can be kept in the `FiniteStateMachine` and\n  could return an instance of an Automaton.\n- `determinisation` and `minimization` : I would put these methods in the class `Automaton`\n- `simplification` : I would put this method in the class `Transducer`\n\nFinally, I would replace the following functions::\n\n```\n    #!python\n    def Transducer(*args, **kwargs):\n        ...\n    def Automaton(*args, **kwargs):\n        ...\n```\n\nby classes with the same docstrings in the following way (the constructor is\nstil the same actually defined for `FiniteStateMachine`)::\n\n```\n    #!python\n    class Transducer(FiniteStateMachine):\n        r\"\"\"\n        same doctrings here as for def Transducer\n        \"\"\"\n        def _transition_label(self, some_args):\n            r\"\"\"\n            Return the proper transition label.\n\n            Method used by ``_latex_`` method\n            \"\"\"\n            ...\n        def simplification(self):\n            ...\n\n    class Automaton(FiniteStateMachine):\n        r\"\"\"\n        same doctrings here as for def Automaton\n        \"\"\"\n        def _transition_label(self, some_args):\n            r\"\"\"\n            Return the proper transition label.\n\n            Method used by ``_latex_`` method\n            \"\"\"\n            ...\n        def determinisation(self):\n            ...\n        def minimization(self):\n            ...\n```\n\nCheers!\n\nS\u00e9bastien",
    "created_at": "2013-11-07T23:25:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189069",
    "user": "https://github.com/seblabbe"
}
```

I did a more careful reading of the patch today. All tests passed (5.59s for
552 tests which is quite efficient). Coverage is 100% (115 of 115).
Documentation builds fine without warnings.

I am ready to give a positive review to the patch provided the following three
more things are fixed.

1. 

In the file `doc/en/reference/combinat/index.rst`, the finite state
module is at the very end of the list after Miscellaneous and Combinatorial
maps. I suggest that you put it before the Words section instead.

2.

The documentation for the `data` input of `FiniteStateMachine` is not
properly documented. It is not usual to see such pseudo code examples and they
are not easy to read, thus not very usefull (personnaly, my eyes do not want to
look at them).

```
    - ``data`` -- can be any of the following:

      - ``{A:{B:{word_in=0, word_out=1}, C:{word_in=1, word_out=1}, ...}``
      - ``{A:{B:(0, 1), C:(1, 1), ...}``
      - ``{A:{B:FSMTransition(A, B, 0, 1), C:FSMTransition(A, C, 1, 1), ...}``
      - ``{A:[(B, 0, 1), (C, 1, 1)], ...}``
      - ``{A:[FSMTransition(A, B, 0, 1), FSMTransition(A, C, 1, 1)], ...}``
      - ``[{from_state:A, to_state:B, word_in:0, word_out:1}, \
            from_state:A, to_state:C, word_in:1, word_out:1}, ...]``
      - ``[(A, B, 0, 1), (A, C, 1, 1), ...]``
      - ``[FSMTransition(A, B, 0, 1), FSMTransition(A, C, 1, 1), ...]``
```

I suggest that you follow the documentation of `Graph` which
is now quite good. See:

```
sage: Graph?
```

You will see that the possible cases of data for `Graph`
are listed verbosely with english words with empty line in between them.  The
list is numeroted with numbers. And the same numbers are used below in the
examples section where many examples are provided for *each* case.

3.

Make three classes for `FiniteStateMachine`, `Automaton` and `Transducer`.

Indeed, `FiniteStateMachine` has 77 methods. Of those only 7 of them depends
on the `mode` attribute. I have copied below the relevant part of the code
where the `mode` attribute is used in those six methods:

```python
class FiniteStateMachine(SageObject):
    def __init__(self, ..., mode=None, ...):
        ...
        self.mode = mode
        ...
    def empty_copy(self, memo=None):
        ...
        new.mode = deepcopy(self.mode, memo)
        ...
    def _latex_(self):
        ...
                    if self.mode == 'automaton':
                        labels.append(format_transition_label(
                                transition.word_in))
                    else:
                        labels.append(format_transition_label(
                            transition.word_in) + "\\mid" + \
                                format_transition_label(transition.word_out))
        ...
    def projection(self, what='input'):
        new = self.empty_copy()
        new.mode='automaton'
        ...
    def determinisation(self):
        assert self.mode == 'automaton'
        ...
    def minimization(self, algorithm=None):
        if self.mode is None:
            raise NotImplementedError, "The mode attribute must be set."
        if self.mode == 'transducer':
            raise NotImplementedError, "Minimization for Transducer is not implemented. Try the simplification method."
        if not self.mode == 'automaton':
            raise NotImplementedError
        ...
    def simplification(self):
        if self.mode != 'transducer':
            raise NotImplementedError, "Simplification is only implemented for Transducers. For Automata, use minimization instead"
        ...
```

I would leave the 70 methods not mentioned above in the class
`FiniteStateMachine`. Then, according to how each of the 7 methods are used,
I would do the following for each of them:

- `__init__`: This method can be kept as it is in the `FiniteStateMachine`
  class and I believe the line `self.mode = mode` can just be deleted.
- `empty_copy`: This method can be kept in the `FiniteStateMachine` and I
  believe the line `new.mode = 'automaton'` can just be deleted.
- `_latex_`: This method can be kept in the `FiniteStateMachine` and I
  would move the code depending on the mode inside a method in the classes
  `Automaton` and `Transducer`. This method could be called
  `_transition_label` or something like that would return the label of a
  transition in the according way. Maybe this method will just ask the
  transition to do it.
- `projection`: This method can be kept in the `FiniteStateMachine` and
  could return an instance of an Automaton.
- `determinisation` and `minimization` : I would put these methods in the class `Automaton`
- `simplification` : I would put this method in the class `Transducer`

Finally, I would replace the following functions::

```
    #!python
    def Transducer(*args, **kwargs):
        ...
    def Automaton(*args, **kwargs):
        ...
```

by classes with the same docstrings in the following way (the constructor is
stil the same actually defined for `FiniteStateMachine`)::

```
    #!python
    class Transducer(FiniteStateMachine):
        r"""
        same doctrings here as for def Transducer
        """
        def _transition_label(self, some_args):
            r"""
            Return the proper transition label.

            Method used by ``_latex_`` method
            """
            ...
        def simplification(self):
            ...

    class Automaton(FiniteStateMachine):
        r"""
        same doctrings here as for def Automaton
        """
        def _transition_label(self, some_args):
            r"""
            Return the proper transition label.

            Method used by ``_latex_`` method
            """
            ...
        def determinisation(self):
            ...
        def minimization(self):
            ...
```

Cheers!

Sébastien



---

archive/issue_comments_189070.json:
```json
{
    "body": "Attachment [trac_15078_fsm_automata_transducers.6.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.6.patch) by @dkrenn created at 2013-11-11 17:48:54\n\nWe have worked in all the comments from above. In particular, `Automaton` and `Transducer` now inherite from `FiniteStateMachine`.",
    "created_at": "2013-11-11T17:48:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189070",
    "user": "https://github.com/dkrenn"
}
```

Attachment [trac_15078_fsm_automata_transducers.6.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.6.patch) by @dkrenn created at 2013-11-11 17:48:54

We have worked in all the comments from above. In particular, `Automaton` and `Transducer` now inherite from `FiniteStateMachine`.



---

archive/issue_comments_189071.json:
```json
{
    "body": "This needs rebasing on beta3:\n\n```\ndarij@travis-virtualbox:~/sage-5.13.beta3/devel/sage-main$ hg qimport ~/patches/trac_15078_fsm_automata_transducers.6.patch \nadding trac_15078_fsm_automata_transducers.6.patch to series file\ndarij@travis-virtualbox:~/sage-5.13.beta3/devel/sage-main$ hg qpushapplying trac_15078_fsm_automata_transducers.6.patch\npatching file doc/en/reference/combinat/index.rst\nHunk #1 FAILED at 78\n1 out of 1 hunks FAILED -- saving rejects to file doc/en/reference/combinat/index.rst.rej\npatch failed, unable to continue (try -v)\npatch failed, rejects left in working dir\nerrors during apply, please fix and refresh trac_15078_fsm_automata_transducers.6.patch\n```",
    "created_at": "2013-11-16T02:36:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189071",
    "user": "https://github.com/darijgr"
}
```

This needs rebasing on beta3:

```
darij@travis-virtualbox:~/sage-5.13.beta3/devel/sage-main$ hg qimport ~/patches/trac_15078_fsm_automata_transducers.6.patch 
adding trac_15078_fsm_automata_transducers.6.patch to series file
darij@travis-virtualbox:~/sage-5.13.beta3/devel/sage-main$ hg qpushapplying trac_15078_fsm_automata_transducers.6.patch
patching file doc/en/reference/combinat/index.rst
Hunk #1 FAILED at 78
1 out of 1 hunks FAILED -- saving rejects to file doc/en/reference/combinat/index.rst.rej
patch failed, unable to continue (try -v)
patch failed, rejects left in working dir
errors during apply, please fix and refresh trac_15078_fsm_automata_transducers.6.patch
```



---

archive/issue_comments_189072.json:
```json
{
    "body": "Attachment [trac_15078_fsm_automata_transducers.7.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.7.patch) by @dkrenn created at 2013-11-16 16:20:32\n\n\u200b\u200bhttp://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.7.patch is rebased to 5.13.beta3.",
    "created_at": "2013-11-16T16:20:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189072",
    "user": "https://github.com/dkrenn"
}
```

Attachment [trac_15078_fsm_automata_transducers.7.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.7.patch) by @dkrenn created at 2013-11-16 16:20:32

​​http://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.7.patch is rebased to 5.13.beta3.



---

archive/issue_comments_189073.json:
```json
{
    "body": "Hi there, I just tested the most recent patch. All test pass. Documentation builds fine again. Correction were made after my previous comments : documentation of the input `FiniteStateMachine` is now great, new classes for `Automaton` and `Transducer` were done.\n\nRelated to the creation of the three classes, I think still another thing must be done : document the differences between them. The user of these classes will know that the three classes exist (because the documentation of one class refers to the other one). The user understand the inputs are the same, but then will ask why should he use one class instead of the other one?\n\n```\n   OUTPUT:\n\n   A finite state machine.\n\n   The object creation of \"Automaton\" and \"Transducer\" is the same as\n   the one described here (i.e. just replace the word\n   \"FiniteStateMachine\" by \"Automaton\" or \"Transducer\").\n```\n\nI am suggesting some fixes below that should help to answer this global question.\n\n1. There should be a new `_repr_` method for Automaton and Transducer (I am sorry I forgot to mention this repr method in my previous comment):\n\n```\nsage: FiniteStateMachine()\nFinite state machine with 0 states\nsage: Automaton()\nAutomaton with 0 states\nsage: Transducer()\nTransducer with 0 states\n```\n\ninstead of\n\n```\nsage: FiniteStateMachine()\nfinite state machine with 0 states\nsage: Automaton()\nfinite state machine with 0 states\nsage: Transducer()\nfinite state machine with 0 states\n```\n\n2. The documentation of `FiniteStateMachine` should include a two line paragraph (maybe before the INPUT block) saying why the user wants to use this class and why the user should prefer to use another class like Automaton or Transducer. For instance : \"For determinisation and minimisation, use Automaton class\".\n\n3. Documentation of Automaton (and Transducer):\n\n```\nclass Automaton(FiniteStateMachine):\n    \"\"\"\n    This creates an automaton, which is a special type of a finite\n    state machine.\n\n    See class :class:`FiniteStateMachine` for more information.\n\n    TESTS::\n\n        sage: Automaton()\n        finite state machine with 0 states\n    \"\"\"\n```\n\nWhy is it special? Mention methods that are defined for Automaton and not for `FiniteStateMachine`. Same comments for Transducer.\n\nThe first example of the documentation of `FiniteStateMachine` uses `word_out` which is not the best first example for the user using `Automaton`. So, I suggest to add an `EXAMPLES::` section in the doc of Automaton class containing the creation of at least one non empty Automaton.\n\n```\nclass Automaton(FiniteStateMachine):\n    r\"\"\"\n    ...\n\n    The inputs are the same as for :class:`FiniteStateMachine`.\n    See class :class:`FiniteStateMachine` for more information.\n\n    EXAMPLES:\n\n        ...\n\n    TESTS::\n\n        sage: Automaton()\n        finite state machine with 0 states\n```\n\n4. A typo (finial) :\n\n```\n* \"initial_states\" and \"final_states\" -- the initial and finial\n```",
    "created_at": "2013-11-25T09:36:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189073",
    "user": "https://github.com/seblabbe"
}
```

Hi there, I just tested the most recent patch. All test pass. Documentation builds fine again. Correction were made after my previous comments : documentation of the input `FiniteStateMachine` is now great, new classes for `Automaton` and `Transducer` were done.

Related to the creation of the three classes, I think still another thing must be done : document the differences between them. The user of these classes will know that the three classes exist (because the documentation of one class refers to the other one). The user understand the inputs are the same, but then will ask why should he use one class instead of the other one?

```
   OUTPUT:

   A finite state machine.

   The object creation of "Automaton" and "Transducer" is the same as
   the one described here (i.e. just replace the word
   "FiniteStateMachine" by "Automaton" or "Transducer").
```

I am suggesting some fixes below that should help to answer this global question.

1. There should be a new `_repr_` method for Automaton and Transducer (I am sorry I forgot to mention this repr method in my previous comment):

```
sage: FiniteStateMachine()
Finite state machine with 0 states
sage: Automaton()
Automaton with 0 states
sage: Transducer()
Transducer with 0 states
```

instead of

```
sage: FiniteStateMachine()
finite state machine with 0 states
sage: Automaton()
finite state machine with 0 states
sage: Transducer()
finite state machine with 0 states
```

2. The documentation of `FiniteStateMachine` should include a two line paragraph (maybe before the INPUT block) saying why the user wants to use this class and why the user should prefer to use another class like Automaton or Transducer. For instance : "For determinisation and minimisation, use Automaton class".

3. Documentation of Automaton (and Transducer):

```
class Automaton(FiniteStateMachine):
    """
    This creates an automaton, which is a special type of a finite
    state machine.

    See class :class:`FiniteStateMachine` for more information.

    TESTS::

        sage: Automaton()
        finite state machine with 0 states
    """
```

Why is it special? Mention methods that are defined for Automaton and not for `FiniteStateMachine`. Same comments for Transducer.

The first example of the documentation of `FiniteStateMachine` uses `word_out` which is not the best first example for the user using `Automaton`. So, I suggest to add an `EXAMPLES::` section in the doc of Automaton class containing the creation of at least one non empty Automaton.

```
class Automaton(FiniteStateMachine):
    r"""
    ...

    The inputs are the same as for :class:`FiniteStateMachine`.
    See class :class:`FiniteStateMachine` for more information.

    EXAMPLES:

        ...

    TESTS::

        sage: Automaton()
        finite state machine with 0 states
```

4. A typo (finial) :

```
* "initial_states" and "final_states" -- the initial and finial
```



---

archive/issue_comments_189074.json:
```json
{
    "body": "Many thanks for your comments.\n\nReplying to [comment:25 slabbe]:\n> 1. There should be a new `_repr_` method for Automaton and Transducer (I am sorry I forgot to mention this repr method in my previous comment):\n\n\nDone.\n\n> 2. The documentation of `FiniteStateMachine` should include a two line paragraph (maybe before the INPUT block) saying why the user wants to use this class and why the user should prefer to use another class like Automaton or Transducer. For instance : \"For determinisation and minimisation, use Automaton class\".\n\n\nDone (Added after the output block, where Automata and Transducer are mentioned; I think this is a good place for it. Also added links to minimization, simplification,... there)\n\n> 3. Documentation of Automaton (and Transducer):\n> \n> \n> ```\n> class Automaton(FiniteStateMachine):\n>     \"\"\"\n>     This creates an automaton, which is a special type of a finite\n>     state machine.\n> ```\n> \n> Why is it special? Mention methods that are defined for Automaton and not for `FiniteStateMachine`. Same comments for Transducer.\n> \n> The first example of the documentation of `FiniteStateMachine` uses `word_out` which is not the best first example for the user using `Automaton`. So, I suggest to add an `EXAMPLES::` section in the doc of Automaton class containing the creation of at least one non empty Automaton.\n\n\nRewritten and examples added.\n\n> 4. A typo (finial) :\n\n\nCorrected.\n\nThese changes can be found in \u200b\u200bhttp://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.8.patch  (which runs in 5.13.beta3).",
    "created_at": "2013-11-25T13:31:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189074",
    "user": "https://github.com/dkrenn"
}
```

Many thanks for your comments.

Replying to [comment:25 slabbe]:
> 1. There should be a new `_repr_` method for Automaton and Transducer (I am sorry I forgot to mention this repr method in my previous comment):


Done.

> 2. The documentation of `FiniteStateMachine` should include a two line paragraph (maybe before the INPUT block) saying why the user wants to use this class and why the user should prefer to use another class like Automaton or Transducer. For instance : "For determinisation and minimisation, use Automaton class".


Done (Added after the output block, where Automata and Transducer are mentioned; I think this is a good place for it. Also added links to minimization, simplification,... there)

> 3. Documentation of Automaton (and Transducer):
> 
> 
> ```
> class Automaton(FiniteStateMachine):
>     """
>     This creates an automaton, which is a special type of a finite
>     state machine.
> ```
> 
> Why is it special? Mention methods that are defined for Automaton and not for `FiniteStateMachine`. Same comments for Transducer.
> 
> The first example of the documentation of `FiniteStateMachine` uses `word_out` which is not the best first example for the user using `Automaton`. So, I suggest to add an `EXAMPLES::` section in the doc of Automaton class containing the creation of at least one non empty Automaton.


Rewritten and examples added.

> 4. A typo (finial) :


Corrected.

These changes can be found in ​​http://trac.sagemath.org/attachment/ticket/15078/trac_15078_fsm_automata_transducers.8.patch  (which runs in 5.13.beta3).



---

archive/issue_comments_189075.json:
```json
{
    "body": "Attachment [trac_15078_fsm_automata_transducers.8.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.8.patch) by @dkrenn created at 2013-11-25 13:31:57",
    "created_at": "2013-11-25T13:31:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189075",
    "user": "https://github.com/dkrenn"
}
```

Attachment [trac_15078_fsm_automata_transducers.8.patch](tarball://root/attachments/some-uuid/ticket15078/trac_15078_fsm_automata_transducers.8.patch) by @dkrenn created at 2013-11-25 13:31:57



---

archive/issue_comments_189076.json:
```json
{
    "body": "Great! Thanks for the changes and your good work answering all of the reviewers comments. I am ready to give a positive review.\n\nSince much time passed since the start of the review, I believe everybody had a chance to give their comments. Hence, I change the status of this ticket to positive review.\n\nS\u00e9bastien",
    "created_at": "2013-11-25T22:39:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189076",
    "user": "https://github.com/seblabbe"
}
```

Great! Thanks for the changes and your good work answering all of the reviewers comments. I am ready to give a positive review.

Since much time passed since the start of the review, I believe everybody had a chance to give their comments. Hence, I change the status of this ticket to positive review.

Sébastien



---

archive/issue_comments_189077.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-11-25T22:48:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189077",
    "user": "https://github.com/seblabbe"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_043384.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-12-05T08:01:48Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15078#event-43384"
}
```



---

archive/issue_comments_189078.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-12-05T08:01:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189078",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_comments_189079.json:
```json
{
    "body": "Hi,\n\nI would like to share some comments on the code on finite state machine that was merged into Sage.\n\nNew modules sometimes takes forever (see for example #10519, #12996) to go into Sage because reviewers are never happy and authors gets tired. So, for the actual ticket #15078, I wanted things to go differently. As a reviewer, I listed a bunch of improvements. Authors made the improvements. I gave positive review. And now it is in Sage. Good!\n\nBut finally, after using the code a little bit since its inclusion into Sage, I realized that I should have asked for more improvements... Anyway, I prefer an active developpment rather than dying code on trac. So I don't regret, considering the above examples, if I gave a too quick positive review.\n\nSo, here are my comments since the inclusion into Sage:\n\n- The basics operations (union, concatenation, intersection, complement, Kleene star) on automaton are not implemented. This might be bad because maybe the chosen representation is not suitable to answer to those basic operations in an efficient way. Or maybe the representation is suitable... Nobody knows.\n- I think for efficiency reasons there should not have a class for states and a class for transitions.\n- I think the class FSMProcessIterator could be changed into a method of the class automaton or finite state machine using yield statement.\n- An easy one: for now `__mul__` is chosen for intersection. It should be `__and__`. Also `__add__` is chosen for union. It should be `__or__`.\n- Documentation of [top level module](http://www.sagemath.org/doc/reference/combinat/sage/combinat/finite_state_machine.html) should not mention FSMState. Also, it should contain good examples of automaton and of transducers.\n\nUnfortunately, I do not have time to work on these things myself. So, I let others on the short term create ticket if they agree with one of the above.\n\nCheers,\n\nS\u00e9bastien",
    "created_at": "2014-03-01T12:04:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189079",
    "user": "https://github.com/seblabbe"
}
```

Hi,

I would like to share some comments on the code on finite state machine that was merged into Sage.

New modules sometimes takes forever (see for example #10519, #12996) to go into Sage because reviewers are never happy and authors gets tired. So, for the actual ticket #15078, I wanted things to go differently. As a reviewer, I listed a bunch of improvements. Authors made the improvements. I gave positive review. And now it is in Sage. Good!

But finally, after using the code a little bit since its inclusion into Sage, I realized that I should have asked for more improvements... Anyway, I prefer an active developpment rather than dying code on trac. So I don't regret, considering the above examples, if I gave a too quick positive review.

So, here are my comments since the inclusion into Sage:

- The basics operations (union, concatenation, intersection, complement, Kleene star) on automaton are not implemented. This might be bad because maybe the chosen representation is not suitable to answer to those basic operations in an efficient way. Or maybe the representation is suitable... Nobody knows.
- I think for efficiency reasons there should not have a class for states and a class for transitions.
- I think the class FSMProcessIterator could be changed into a method of the class automaton or finite state machine using yield statement.
- An easy one: for now `__mul__` is chosen for intersection. It should be `__and__`. Also `__add__` is chosen for union. It should be `__or__`.
- Documentation of [top level module](http://www.sagemath.org/doc/reference/combinat/sage/combinat/finite_state_machine.html) should not mention FSMState. Also, it should contain good examples of automaton and of transducers.

Unfortunately, I do not have time to work on these things myself. So, I let others on the short term create ticket if they agree with one of the above.

Cheers,

Sébastien



---

archive/issue_comments_189080.json:
```json
{
    "body": "Please open up a new ticket -- not many people have closed tickets on their radar.",
    "created_at": "2014-03-01T16:54:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189080",
    "user": "https://github.com/darijgr"
}
```

Please open up a new ticket -- not many people have closed tickets on their radar.



---

archive/issue_comments_189081.json:
```json
{
    "body": "Replying to [comment:32 slabbe]:\n> \n> - An easy one: for now `__mul__` is chosen for intersection. It should be `__and__`. Also `__add__` is chosen for union. It should be `__or__`.\n\nIn #16016 these names are changed.",
    "created_at": "2014-03-26T16:21:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189081",
    "user": "https://trac.sagemath.org/admin/accounts/users/skropf"
}
```

Replying to [comment:32 slabbe]:
> 
> - An easy one: for now `__mul__` is chosen for intersection. It should be `__and__`. Also `__add__` is chosen for union. It should be `__or__`.

In #16016 these names are changed.



---

archive/issue_comments_189082.json:
```json
{
    "body": "Replying to [comment:32 slabbe]:\n>  - The basics operations (union, concatenation, intersection, complement, Kleene star) on automaton are not implemented. This might be bad because maybe the chosen representation is not suitable to answer to those basic operations in an efficient way. Or maybe the representation is suitable... Nobody knows.\n\n\nintersection now is in #16061\n\n>  - Documentation of [top level module](http://www.sagemath.org/doc/reference/combinat/sage/combinat/finite_state_machine.html) should not mention FSMState. Also, it should contain good examples of automaton and of transducers.\n\n\nOne more example has been added in #16143: Standard Binary -> Gray Code.",
    "created_at": "2014-04-12T09:04:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189082",
    "user": "https://github.com/cheuberg"
}
```

Replying to [comment:32 slabbe]:
>  - The basics operations (union, concatenation, intersection, complement, Kleene star) on automaton are not implemented. This might be bad because maybe the chosen representation is not suitable to answer to those basic operations in an efficient way. Or maybe the representation is suitable... Nobody knows.


intersection now is in #16061

>  - Documentation of [top level module](http://www.sagemath.org/doc/reference/combinat/sage/combinat/finite_state_machine.html) should not mention FSMState. Also, it should contain good examples of automaton and of transducers.


One more example has been added in #16143: Standard Binary -> Gray Code.



---

archive/issue_comments_189083.json:
```json
{
    "body": "Replying to [comment:32 slabbe]:\n>  - The basics operations (union, concatenation, intersection, complement, Kleene star) on automaton are not implemented.\n\n\nunion is now #18557.",
    "created_at": "2015-05-31T09:10:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189083",
    "user": "https://github.com/cheuberg"
}
```

Replying to [comment:32 slabbe]:
>  - The basics operations (union, concatenation, intersection, complement, Kleene star) on automaton are not implemented.


union is now #18557.



---

archive/issue_comments_189084.json:
```json
{
    "body": "Replying to [comment:32 slabbe]:\n>  - The basics operations (union, concatenation, intersection, complement, Kleene star) on automaton are not implemented.\n\n\nconcatenation: #18965\ncomplement: #18966\nKleene star: #18964",
    "created_at": "2015-07-29T17:10:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189084",
    "user": "https://github.com/cheuberg"
}
```

Replying to [comment:32 slabbe]:
>  - The basics operations (union, concatenation, intersection, complement, Kleene star) on automaton are not implemented.


concatenation: #18965
complement: #18966
Kleene star: #18964



---

archive/issue_comments_189085.json:
```json
{
    "body": "What is the rationale for this:\n\n```\n    def __iadd__(self, other):\n        raise NotImplementedError\n```\n\nDo you intend to implement this in the future?",
    "created_at": "2016-06-20T09:33:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189085",
    "user": "https://github.com/jdemeyer"
}
```

What is the rationale for this:

```
    def __iadd__(self, other):
        raise NotImplementedError
```

Do you intend to implement this in the future?



---

archive/issue_comments_189086.json:
```json
{
    "body": "Replying to [comment:40 jdemeyer]:\n> What is the rationale for this:\n> \n> ```\n>     def __iadd__(self, other):\n>         raise NotImplementedError\n> ```\n> \n> Do you intend to implement this in the future?\n\n\nNo, I don't think so.",
    "created_at": "2016-06-28T15:48:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15078",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15078#issuecomment-189086",
    "user": "https://github.com/dkrenn"
}
```

Replying to [comment:40 jdemeyer]:
> What is the rationale for this:
> 
> ```
>     def __iadd__(self, other):
>         raise NotImplementedError
> ```
> 
> Do you intend to implement this in the future?


No, I don't think so.
