# Issue 15424: A coercion-related memory leak

archive/issues_015187.json:
```json
{
    "assignees": [],
    "body": "<div id=\"comment:0\"></div>\n\nYet another leak (this test is with #15303):\n\n```\nsage: import gc\nsage: K = IntegerModRing(111115)\nsage: C = type(K)\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])\n1\nsage: K.has_coerce_map_from(ZZ)\nTrue\nsage: del K\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak\n0\nsage: a = K.get_action(ZZ, op=operator.add, self_on_left=True)\nsage: del K,a\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])\n0\nsage: K = IntegerModRing(111115)\nsage: a = K.get_action(ZZ, op=operator.mul, self_on_left=True)\nsage: b = ZZ.get_action(K, op=operator.mul, self_on_left=False)\nsage: del K,a,b\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak\n0\nsage: K = IntegerModRing(111115)\nsage: x = K.one()\nsage: del K,x\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak\n0\nsage: K = IntegerModRing(111115)\nsage: x = K.one()*2\nsage: del K,x\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # LEAK\n1\n```\n\nThis is astonishing. Wouldn't one think that getting (thus, caching) a coercion or getting an action should trigger a leak, or creating an element? No, we actually need to multiply two elements to find the leak.\n\nSurprising:\n\n```\nsage: K = IntegerModRing(111115)\nsage: K.get_action(ZZ, op=operator.mul, self_on_left=True) is None\nTrue\nsage: ZZ.get_action(K, op=operator.mul, self_on_left=True) is None\nTrue\n```\nShouldn't there be an action? OK, perhaps not, since coercion is used for the multiplication:\n\n```\nsage: cm = sage.structure.element.get_coercion_model()\nsage: cm.explain(K,ZZ, op=operator.mul)\nCoercion on right operand via\n    Natural morphism:\n      From: Integer Ring\n      To:   Ring of integers modulo 111115\nArithmetic performed after coercions.\nResult lives in Ring of integers modulo 111115\nRing of integers modulo 111115\n```\nBut if coercion is used, then why is establishing a coercion not enough to trigger the leak? In a new session:\n\n```\nsage: import gc\nsage: K = IntegerModRing(111115)\nsage: C = type(K)\nsage: phi = K.coerce_map_from(ZZ)\nsage: x = phi(2)\nsage: del K,phi,x\nsage: _ = gc.collect()\nsage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])\n0\n```\n\nCC:  @nbruin\n\nComponent: **memleak**\n\nKeywords: **coercion model, weak reference**\n\nReviewer: **Simon King**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/15424_\n\n",
    "closed_at": "2013-11-21T13:02:54Z",
    "created_at": "2013-11-15T16:35:24Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/duplicate",
        "https://github.com/sagemath/sage/labels/memleak"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "A coercion-related memory leak",
    "type": "issue",
    "updated_at": "2013-11-21T13:02:54Z",
    "url": "https://github.com/sagemath/sage/issues/15424",
    "user": "https://github.com/simon-king-jena"
}
```
<div id="comment:0"></div>

Yet another leak (this test is with #15303):

```
sage: import gc
sage: K = IntegerModRing(111115)
sage: C = type(K)
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])
1
sage: K.has_coerce_map_from(ZZ)
True
sage: del K
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak
0
sage: a = K.get_action(ZZ, op=operator.add, self_on_left=True)
sage: del K,a
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])
0
sage: K = IntegerModRing(111115)
sage: a = K.get_action(ZZ, op=operator.mul, self_on_left=True)
sage: b = ZZ.get_action(K, op=operator.mul, self_on_left=False)
sage: del K,a,b
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak
0
sage: K = IntegerModRing(111115)
sage: x = K.one()
sage: del K,x
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # no leak
0
sage: K = IntegerModRing(111115)
sage: x = K.one()*2
sage: del K,x
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)]) # LEAK
1
```

This is astonishing. Wouldn't one think that getting (thus, caching) a coercion or getting an action should trigger a leak, or creating an element? No, we actually need to multiply two elements to find the leak.

Surprising:

```
sage: K = IntegerModRing(111115)
sage: K.get_action(ZZ, op=operator.mul, self_on_left=True) is None
True
sage: ZZ.get_action(K, op=operator.mul, self_on_left=True) is None
True
```
Shouldn't there be an action? OK, perhaps not, since coercion is used for the multiplication:

```
sage: cm = sage.structure.element.get_coercion_model()
sage: cm.explain(K,ZZ, op=operator.mul)
Coercion on right operand via
    Natural morphism:
      From: Integer Ring
      To:   Ring of integers modulo 111115
Arithmetic performed after coercions.
Result lives in Ring of integers modulo 111115
Ring of integers modulo 111115
```
But if coercion is used, then why is establishing a coercion not enough to trigger the leak? In a new session:

```
sage: import gc
sage: K = IntegerModRing(111115)
sage: C = type(K)
sage: phi = K.coerce_map_from(ZZ)
sage: x = phi(2)
sage: del K,phi,x
sage: _ = gc.collect()
sage: len([1 for bla in gc.get_objects() if isinstance(bla,C)])
0
```

CC:  @nbruin

Component: **memleak**

Keywords: **coercion model, weak reference**

Reviewer: **Simon King**

_Issue created by migration from https://trac.sagemath.org/ticket/15424_





---

archive/issue_events_217584.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-15T16:35:24Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "milestone_number": null,
    "milestone_title": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217584"
}
```



---

archive/issue_events_217585.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-15T16:35:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/memleak",
    "label_color": "d73a4a",
    "label_name": "memleak",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217585"
}
```



---

archive/issue_events_217586.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-15T16:35:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217586"
}
```



---

archive/issue_events_217587.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-15T16:35:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217587"
}
```



---

archive/issue_comments_191838.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nI tried to see where the reference can be coming from:\n\n```\n%cpaste\nimport gc\nfrom sage.structure.coerce_dict import *\ndef all_referrers(c,X):\n    found_IDs=set()\n    R=[]\n    new=gc.get_referrers(c)\n    found_IDs.add(id(new))\n    found_IDs.add(id(R))\n    found_IDs.add(id(globals()))    \n    while len(new)>0:\n        r=new.pop()\n        if id(r) in found_IDs or type(r) not in X:\n            print \"skipping\",type(r)\n            continue\n        R.append(r)\n        found_IDs.add(id(r))\n        new.extend(gc.get_referrers(r))\n        print \"type(r)=%s len(R)=%s len(new)=%s\"%(type(r),len(R),len(new))\n    return R\n\ndef getR():\n    K = IntegerModRing(111115)\n    C = type(K)\n    phi = K.coerce_map_from(ZZ)\n    del phi\n    #vary this line:\n    x = K.one()*2\n    #del K,x\n    _ = gc.collect()\n    X=set([list,dict,tuple,\n           RingHomset_generic_with_category,\n           sage.rings.finite_rings.integer_mod.Integer_to_IntegerMod,\n           TripleDict, MonoDict, C])\n    R=all_referrers(list(c for c in gc.get_objects() if isinstance(c,C))[0],X)\n    return R\n--\nRingHomset_generic_with_category=type(ZZ.Hom(QQ))\nR=getR()\n```\nand I found that with `x=K.one()*2` there is also a TripleDict that show up. It's fairly big (44 entries) and the entries all seem to be of the form `D[domain,codomain,None]=morphism from domain to codomain` (or `None` entries). Since the morphism has a strong reference to the codomain, this would keep our ring alive [it doesn't seem like the kind of dictionary that can afford to be weak on its values]. Judging from the entries, this dictionary is a global one. I think there is a ticket somewhere that mentions the same phenomenon (also doing arithmetic), in the context of finite fields. Somewhere from the era when we started to work on #715 in earnest.",
    "created_at": "2013-11-16T01:08:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191838",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:1" align="right">comment:1</div>

I tried to see where the reference can be coming from:

```
%cpaste
import gc
from sage.structure.coerce_dict import *
def all_referrers(c,X):
    found_IDs=set()
    R=[]
    new=gc.get_referrers(c)
    found_IDs.add(id(new))
    found_IDs.add(id(R))
    found_IDs.add(id(globals()))    
    while len(new)>0:
        r=new.pop()
        if id(r) in found_IDs or type(r) not in X:
            print "skipping",type(r)
            continue
        R.append(r)
        found_IDs.add(id(r))
        new.extend(gc.get_referrers(r))
        print "type(r)=%s len(R)=%s len(new)=%s"%(type(r),len(R),len(new))
    return R

def getR():
    K = IntegerModRing(111115)
    C = type(K)
    phi = K.coerce_map_from(ZZ)
    del phi
    #vary this line:
    x = K.one()*2
    #del K,x
    _ = gc.collect()
    X=set([list,dict,tuple,
           RingHomset_generic_with_category,
           sage.rings.finite_rings.integer_mod.Integer_to_IntegerMod,
           TripleDict, MonoDict, C])
    R=all_referrers(list(c for c in gc.get_objects() if isinstance(c,C))[0],X)
    return R
--
RingHomset_generic_with_category=type(ZZ.Hom(QQ))
R=getR()
```
and I found that with `x=K.one()*2` there is also a TripleDict that show up. It's fairly big (44 entries) and the entries all seem to be of the form `D[domain,codomain,None]=morphism from domain to codomain` (or `None` entries). Since the morphism has a strong reference to the codomain, this would keep our ring alive [it doesn't seem like the kind of dictionary that can afford to be weak on its values]. Judging from the entries, this dictionary is a global one. I think there is a ticket somewhere that mentions the same phenomenon (also doing arithmetic), in the context of finite fields. Somewhere from the era when we started to work on #715 in earnest.



---

archive/issue_comments_191839.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nReplying to [@nbruin](#comment%3A1):\n> and I found that with `x=K.one()*2` there is also a TripleDict that show up. It's fairly big (44 entries) and the entries all seem to be of the form `D[domain,codomain,None]=morphism from domain to codomain` (or `None` entries). Since the morphism has a strong reference to the codomain, this would keep our ring alive [it doesn't seem like the kind of dictionary that can afford to be weak on its values]. Judging from the entries, this dictionary is a global one.\n\nHm. Is there any global `TripleDict` beside the one in `sage.categories.homset`? With grep, I found none. But in this case, the values would not be morphisms but homsets.",
    "created_at": "2013-11-16T16:05:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191839",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

Replying to [@nbruin](#comment%3A1):
> and I found that with `x=K.one()*2` there is also a TripleDict that show up. It's fairly big (44 entries) and the entries all seem to be of the form `D[domain,codomain,None]=morphism from domain to codomain` (or `None` entries). Since the morphism has a strong reference to the codomain, this would keep our ring alive [it doesn't seem like the kind of dictionary that can afford to be weak on its values]. Judging from the entries, this dictionary is a global one.

Hm. Is there any global `TripleDict` beside the one in `sage.categories.homset`? With grep, I found none. But in this case, the values would not be morphisms but homsets.



---

archive/issue_comments_191840.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI just notice: #14711 is still in need of review. I am currently building the branch from there, to see if it fixes the problem from here.",
    "created_at": "2013-11-16T16:19:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191840",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

I just notice: #14711 is still in need of review. I am currently building the branch from there, to see if it fixes the problem from here.



---

archive/issue_comments_191841.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nReplying to [@simon-king-jena](#comment%3A3):\n> I just notice: #14711 is still in need of review. I am currently building the branch from there, to see if it fixes the problem from here.\n\nNo, it does not.",
    "created_at": "2013-11-16T17:11:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191841",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

Replying to [@simon-king-jena](#comment%3A3):
> I just notice: #14711 is still in need of review. I am currently building the branch from there, to see if it fixes the problem from here.

No, it does not.



---

archive/issue_comments_191842.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nOK, looking at the referrers to the TripleDict I get a  sage.structure.coerce.CoercionModel_cache_maps `sage.structure.coerce.CoercionModel_cache_maps`, so I guess it's not a \"global\" cache but one stored on an object that has an awfully long lifespan.\n\nCorrection: the values are either `None` or a pair of maps. So I guess the keys are not domain and codomain but parents of pairs of elements and the pair of maps are the ones that map into the common parent.\n\nSo my guess is that this cache is used when determining a common parent and then stores the maps needed to get to that. It seems to me we can mitigate this leak considerably if we DON'T store the maps here if we find a coercion from one into the other would do the job: instead store a symbolic \"coerce_to_first\" or \"coerce_to_second\" value in there.\n\nIn cases where there is a genuine third parent into which we're mapping, it's a little safer: then the codomain at least doesn't keep alive the keys. It's unclear to me how long we should be keeping the common overparent in that case. This cache will mean its life is bounded below by the shortest life time of the two \"covered\" parents.",
    "created_at": "2013-11-16T18:14:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191842",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:5" align="right">comment:5</div>

OK, looking at the referrers to the TripleDict I get a  sage.structure.coerce.CoercionModel_cache_maps `sage.structure.coerce.CoercionModel_cache_maps`, so I guess it's not a "global" cache but one stored on an object that has an awfully long lifespan.

Correction: the values are either `None` or a pair of maps. So I guess the keys are not domain and codomain but parents of pairs of elements and the pair of maps are the ones that map into the common parent.

So my guess is that this cache is used when determining a common parent and then stores the maps needed to get to that. It seems to me we can mitigate this leak considerably if we DON'T store the maps here if we find a coercion from one into the other would do the job: instead store a symbolic "coerce_to_first" or "coerce_to_second" value in there.

In cases where there is a genuine third parent into which we're mapping, it's a little safer: then the codomain at least doesn't keep alive the keys. It's unclear to me how long we should be keeping the common overparent in that case. This cache will mean its life is bounded below by the shortest life time of the two "covered" parents.



---

archive/issue_comments_191843.json:
```json
{
    "body": "Attachment: **[chain.png](https://github.com/sagemath/sage/files/ticket15424/chain.png)**\n\nA reference chain preventing an integer mod ring from garbage collection",
    "created_at": "2013-11-16T18:15:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191843",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment: **[chain.png](https://github.com/sagemath/sage/files/ticket15424/chain.png)**

A reference chain preventing an integer mod ring from garbage collection



---

archive/issue_comments_191844.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nThe attached picture shows that the offending reference chain starts in the module `sage.functions.other` (which I have never even heard of) and proceeds (via some `__dict__` of 73 items) to `CoercionModel_cache_maps`, which then references a `TripleDict`.",
    "created_at": "2013-11-16T18:18:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191844",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

The attached picture shows that the offending reference chain starts in the module `sage.functions.other` (which I have never even heard of) and proceeds (via some `__dict__` of 73 items) to `CoercionModel_cache_maps`, which then references a `TripleDict`.



---

archive/issue_comments_191845.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nIndeed, `sage.functions.other` contains the line `coercion_model = sage.structure.element.get_coercion_model()`. But I think keeping a reference to the coercion model must be legal. Hence I need to look further.",
    "created_at": "2013-11-16T18:20:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191845",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

Indeed, `sage.functions.other` contains the line `coercion_model = sage.structure.element.get_coercion_model()`. But I think keeping a reference to the coercion model must be legal. Hence I need to look further.



---

archive/issue_comments_191846.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nOuch. I thought that in our coercion model, maps and actions are cached on the level of parents. Now I see that they *additionally* are cached in the coercion model!\n\nApparently this additional cache is not always used. For example, it is not used if you just do `K.coerce_map_from(ZZ)`. But it seems that a coercion map *is* stored in the additional cache if you do a multiplication.\n\nAnd then you have a strongly referenced `TripleDict`, a key `(ZZ,K,None)` and a morphism `phi:ZZ->K` as value. Even with #14711, `phi` would strongly reference `K`. `ZZ` is immortal. Hence, the callback for the item `(ZZ,K,None):phi` will never be called.\n\nWhat shall we do about it? Isn't it the case that we are only storing maps that already are cached on the level of parents? Then it would be safe to just store a *weak* reference to this map, and the problem was solved.",
    "created_at": "2013-11-16T18:30:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191846",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:8" align="right">comment:8</div>

Ouch. I thought that in our coercion model, maps and actions are cached on the level of parents. Now I see that they *additionally* are cached in the coercion model!

Apparently this additional cache is not always used. For example, it is not used if you just do `K.coerce_map_from(ZZ)`. But it seems that a coercion map *is* stored in the additional cache if you do a multiplication.

And then you have a strongly referenced `TripleDict`, a key `(ZZ,K,None)` and a morphism `phi:ZZ->K` as value. Even with #14711, `phi` would strongly reference `K`. `ZZ` is immortal. Hence, the callback for the item `(ZZ,K,None):phi` will never be called.

What shall we do about it? Isn't it the case that we are only storing maps that already are cached on the level of parents? Then it would be safe to just store a *weak* reference to this map, and the problem was solved.



---

archive/issue_comments_191847.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nPS: Similarly for `CoercionModel_cache_maps._action_maps`.",
    "created_at": "2013-11-16T18:49:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191847",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:9" align="right">comment:9</div>

PS: Similarly for `CoercionModel_cache_maps._action_maps`.



---

archive/issue_comments_191848.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nPPS: Which means that we need to make maps weakrefable (actions already are weakrefable).",
    "created_at": "2013-11-16T19:29:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191848",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:10" align="right">comment:10</div>

PPS: Which means that we need to make maps weakrefable (actions already are weakrefable).



---

archive/issue_comments_191849.json:
```json
{
    "body": "Branch: **[u/SimonKing/ticket/15424](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15424)**",
    "created_at": "2013-11-16T19:55:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191849",
    "user": "https://github.com/simon-king-jena"
}
```

Branch: **[u/SimonKing/ticket/15424](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15424)**



---

archive/issue_comments_191850.json:
```json
{
    "body": "Author: **Simon King**",
    "created_at": "2013-11-16T20:02:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191850",
    "user": "https://github.com/simon-king-jena"
}
```

Author: **Simon King**



---

archive/issue_comments_191851.json:
```json
{
    "body": "Commit: **[`b052e5e`](https://github.com/sagemath/sagetrac-mirror/commit/b052e5eef195a755a7eebeac931bd64d936348b8)**",
    "created_at": "2013-11-16T20:02:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191851",
    "user": "https://github.com/simon-king-jena"
}
```

Commit: **[`b052e5e`](https://github.com/sagemath/sagetrac-mirror/commit/b052e5eef195a755a7eebeac931bd64d936348b8)**



---

archive/issue_comments_191852.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nI did not run the complete doctests, but I have added a new test that shows that I have fixed the problem. It is orthogonal to #14711.\n\nAs I said above: The idea is to only keep a weak reference from coercion model to coerce maps, which needs to make morphisms weakrefable, and which should be safe because the maps are cached on their dodomain anyway.\n\n---\nNew commits:\n<table><tr><td><code>[b052e5e](https://github.com/sagemath/sagetrac-mirror/commit/b052e5e)</code></td><td><code>Coercion model should only store weak references to coerce maps</code></td></tr></table>\n",
    "created_at": "2013-11-16T20:02:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191852",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:12" align="right">comment:12</div>

I did not run the complete doctests, but I have added a new test that shows that I have fixed the problem. It is orthogonal to #14711.

As I said above: The idea is to only keep a weak reference from coercion model to coerce maps, which needs to make morphisms weakrefable, and which should be safe because the maps are cached on their dodomain anyway.

---
New commits:
<table><tr><td><code>[b052e5e](https://github.com/sagemath/sagetrac-mirror/commit/b052e5e)</code></td><td><code>Coercion model should only store weak references to coerce maps</code></td></tr></table>




---

archive/issue_events_217588.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-16T20:02:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217588"
}
```



---

archive/issue_comments_191853.json:
```json
{
    "body": "Changed keywords from none to **coercion model, weak reference**",
    "created_at": "2013-11-16T20:02:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191853",
    "user": "https://github.com/simon-king-jena"
}
```

Changed keywords from none to **coercion model, weak reference**



---

archive/issue_comments_191854.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nArgh. Schemes seem to hate me.\n\nAlmost always when I implement something that fixes a problem, it turns out that some examples from sage.schemes will fail, because the elliptic curve code relies on what I intended to fix.\n\nBut this time it is extreme:\n\n```\nsage -t src/sage/schemes/elliptic_curves/ell_rational_field.py  # 652 doctests failed\n```",
    "created_at": "2013-11-16T20:20:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191854",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:13" align="right">comment:13</div>

Argh. Schemes seem to hate me.

Almost always when I implement something that fixes a problem, it turns out that some examples from sage.schemes will fail, because the elliptic curve code relies on what I intended to fix.

But this time it is extreme:

```
sage -t src/sage/schemes/elliptic_curves/ell_rational_field.py  # 652 doctests failed
```



---

archive/issue_comments_191855.json:
```json
{
    "body": "Work Issues: **Convince elliptic curves to not fail**",
    "created_at": "2013-11-16T20:20:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191855",
    "user": "https://github.com/simon-king-jena"
}
```

Work Issues: **Convince elliptic curves to not fail**



---

archive/issue_events_217589.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-16T20:23:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217589"
}
```



---

archive/issue_events_217590.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-16T20:23:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217590"
}
```



---

archive/issue_comments_191856.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nDon't store weakrefs as values in `TripleDict` and `MonoDict`. That's what we have `weakvalues=True` for. Or are you afraid the callback is too expensive to handle?",
    "created_at": "2013-11-16T20:55:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191856",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:15" align="right">comment:15</div>

Don't store weakrefs as values in `TripleDict` and `MonoDict`. That's what we have `weakvalues=True` for. Or are you afraid the callback is too expensive to handle?



---

archive/issue_comments_191857.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nReplying to [@nbruin](#comment%3A15):\n> Don't store weakrefs as values in `TripleDict` and `MonoDict`. That's what we have `weakvalues=True` for.\n\nOops, I forgot about this.\n\n> Or are you afraid the callback is too expensive to handle?\n\nNo. `CoercionModel_cache_maps._coercion_maps` stores tuples (namely: pairs of coercion maps, in both directions, hence, often `(mor,None)` or `(None,mor)`). We can't weakref the tuples. However, we could have a weakrefable extension type with two cdef attributes, so that we can store this instead.",
    "created_at": "2013-11-16T22:08:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191857",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:16" align="right">comment:16</div>

Replying to [@nbruin](#comment%3A15):
> Don't store weakrefs as values in `TripleDict` and `MonoDict`. That's what we have `weakvalues=True` for.

Oops, I forgot about this.

> Or are you afraid the callback is too expensive to handle?

No. `CoercionModel_cache_maps._coercion_maps` stores tuples (namely: pairs of coercion maps, in both directions, hence, often `(mor,None)` or `(None,mor)`). We can't weakref the tuples. However, we could have a weakrefable extension type with two cdef attributes, so that we can store this instead.



---

archive/issue_comments_191858.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nReplying to [@simon-king-jena](#comment%3A16):\n> We can't weakref the tuples. However, we could have a weakrefable extension type with two cdef attributes, so that we can store this instead.\n\nNo, this won't work, because there would be no reference back to the pair, and thus it would be immediately garbage collected.",
    "created_at": "2013-11-16T22:14:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191858",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:17" align="right">comment:17</div>

Replying to [@simon-king-jena](#comment%3A16):
> We can't weakref the tuples. However, we could have a weakrefable extension type with two cdef attributes, so that we can store this instead.

No, this won't work, because there would be no reference back to the pair, and thus it would be immediately garbage collected.



---

archive/issue_comments_191859.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nFound it: #14058 seems relevant. Especially read the sage-devel thread referenced there. We've thought quite a bit about this stuff before. Especially with the newly MUCH better lookup performance of `TripleDict` and `MonoDict`, we may be able to afford some more lookup indirection.",
    "created_at": "2013-11-16T22:22:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191859",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:18" align="right">comment:18</div>

Found it: #14058 seems relevant. Especially read the sage-devel thread referenced there. We've thought quite a bit about this stuff before. Especially with the newly MUCH better lookup performance of `TripleDict` and `MonoDict`, we may be able to afford some more lookup indirection.



---

archive/issue_comments_191860.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nReplying to [@nbruin](#comment%3A18):\n> Found it: #14058 seems relevant. Especially read the sage-devel thread referenced there. We've thought quite a bit about this stuff before. Especially with the newly MUCH better lookup performance of `TripleDict` and `MonoDict`, we may be able to afford some more lookup indirection.\n\nOK, then let us see if it fixes the problem.",
    "created_at": "2013-11-16T23:28:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191860",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:19" align="right">comment:19</div>

Replying to [@nbruin](#comment%3A18):
> Found it: #14058 seems relevant. Especially read the sage-devel thread referenced there. We've thought quite a bit about this stuff before. Especially with the newly MUCH better lookup performance of `TripleDict` and `MonoDict`, we may be able to afford some more lookup indirection.

OK, then let us see if it fixes the problem.



---

archive/issue_comments_191861.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nYep, #14058 fixes the problem. Then I give a review to this ticket, saying that it is a duplicate and please be resolved as such.",
    "created_at": "2013-11-16T23:51:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191861",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:20" align="right">comment:20</div>

Yep, #14058 fixes the problem. Then I give a review to this ticket, saying that it is a duplicate and please be resolved as such.



---

archive/issue_events_217591.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-16T23:51:40Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217591"
}
```



---

archive/issue_events_217592.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-16T23:51:40Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217592"
}
```



---

archive/issue_events_217593.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-16T23:51:40Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "milestone_number": null,
    "milestone_title": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217593"
}
```



---

archive/issue_comments_191862.json:
```json
{
    "body": "Changed work issues from **Convince elliptic curves to not fail** to none",
    "created_at": "2013-11-16T23:51:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191862",
    "user": "https://github.com/simon-king-jena"
}
```

Changed work issues from **Convince elliptic curves to not fail** to none



---

archive/issue_comments_191863.json:
```json
{
    "body": "Changed author from **Simon King** to none",
    "created_at": "2013-11-16T23:51:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191863",
    "user": "https://github.com/simon-king-jena"
}
```

Changed author from **Simon King** to none



---

archive/issue_comments_191864.json:
```json
{
    "body": "Reviewer: **Simon King**",
    "created_at": "2013-11-16T23:51:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191864",
    "user": "https://github.com/simon-king-jena"
}
```

Reviewer: **Simon King**



---

archive/issue_events_217594.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-21T13:02:54Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217594"
}
```



---

archive/issue_events_217595.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-21T13:02:54Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/duplicate",
    "label_color": "c6c6c6",
    "label_name": "duplicate",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217595"
}
```



---

archive/issue_comments_191865.json:
```json
{
    "body": "Changed branch from **[u/SimonKing/ticket/15424](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15424)** to none",
    "created_at": "2013-11-21T13:02:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191865",
    "user": "https://github.com/jdemeyer"
}
```

Changed branch from **[u/SimonKing/ticket/15424](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15424)** to none



---

archive/issue_comments_191866.json:
```json
{
    "body": "Changed commit from **[`b052e5e`](https://github.com/sagemath/sagetrac-mirror/commit/b052e5eef195a755a7eebeac931bd64d936348b8)** to none",
    "created_at": "2013-11-21T13:02:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15424#issuecomment-191866",
    "user": "https://github.com/jdemeyer"
}
```

Changed commit from **[`b052e5e`](https://github.com/sagemath/sagetrac-mirror/commit/b052e5eef195a755a7eebeac931bd64d936348b8)** to none



---

archive/issue_events_217596.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-21T13:02:54Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217596"
}
```



---

archive/issue_events_217597.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-21T13:02:54Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/15424",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15424#event-217597"
}
```
