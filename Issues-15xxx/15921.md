# Issue 15921: work around Maxima fpprintprec bug and other ARM-specific problems

archive/issues_015684.json:
```json
{
    "assignees": [],
    "body": "[Maxima uses CL FORMAT function wrongly](https://groups.google.com/d/msg/sage-devel/oRpkswzpK38/rNVbVN2RyEcJ), resulting in outputting wrong number of digits for floats (one extra), and \ncontradicting its own manual on fpprintprec. In particular it outputs too many digits on ix86 and ix86_64, which got in Sage's doctests. As a result, doctests fail on ARM.\n\nThe fixes are to convert the results into `RealField(prec)`, with appropriate `prec` \n(at least 54, or sometimes more). This ticket also fixes ARM-specific numerical noise stemming \nfrom various other upstream problems, such as `eglibc` loss of precision in `lgamma`. \n\n**CC:**  @vbraun snark\n\n**Keywords:** Maxima, fpprintprec, ARM\n\n**Branch/Commit:** [b8fea1cb11554aff202cd669342136d5a4ea084c](https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c)\n\n**Upstream:** Reported upstream. Developers acknowledge bug.\n\n**Reviewer:** Peter Bruin, Volker Braun\n\n**Author:** Dmitrii Pasechnik\n\nIssue created by migration from https://trac.sagemath.org/ticket/15921\n\n",
    "closed_at": "2014-05-21T20:56:06Z",
    "created_at": "2014-03-12T09:04:07Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/component%3A%20calculus",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.3",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "work around Maxima fpprintprec bug and other ARM-specific problems",
    "type": "issue",
    "updated_at": "2014-05-21T20:56:06Z",
    "url": "https://github.com/sagemath/sage/issues/15921",
    "user": "https://github.com/dimpase"
}
```
[Maxima uses CL FORMAT function wrongly](https://groups.google.com/d/msg/sage-devel/oRpkswzpK38/rNVbVN2RyEcJ), resulting in outputting wrong number of digits for floats (one extra), and 
contradicting its own manual on fpprintprec. In particular it outputs too many digits on ix86 and ix86_64, which got in Sage's doctests. As a result, doctests fail on ARM.

The fixes are to convert the results into `RealField(prec)`, with appropriate `prec` 
(at least 54, or sometimes more). This ticket also fixes ARM-specific numerical noise stemming 
from various other upstream problems, such as `eglibc` loss of precision in `lgamma`. 

**CC:**  @vbraun snark

**Keywords:** Maxima, fpprintprec, ARM

**Branch/Commit:** [b8fea1cb11554aff202cd669342136d5a4ea084c](https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c)

**Upstream:** Reported upstream. Developers acknowledge bug.

**Reviewer:** Peter Bruin, Volker Braun

**Author:** Dmitrii Pasechnik

Issue created by migration from https://trac.sagemath.org/ticket/15921





---

archive/issue_events_193856.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2014-03-12T09:04:07Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "milestone_number": null,
    "milestone_title": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193856"
}
```



---

archive/issue_events_193857.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2014-03-12T09:04:07Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20calculus",
    "label_color": "08517b",
    "label_name": "component: calculus",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193857"
}
```



---

archive/issue_events_193858.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2014-03-12T09:04:07Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "008080",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193858"
}
```



---

archive/issue_events_193859.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2014-04-03T23:25:03Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "rename": {
        "from": "work around Maxima fpprintprec bug",
        "to": "work around Maxima fpprintprec bug and other ARM-specific problems"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193859"
}
```



---

archive/issue_comments_204301.json:
```json
{
    "body": "**Branch:** [u/dimpase/arm_fixes](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/arm_fixes)",
    "created_at": "2014-04-03T23:25:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204301",
    "user": "https://github.com/dimpase"
}
```

**Branch:** [u/dimpase/arm_fixes](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/arm_fixes)



---

archive/issue_comments_204302.json:
```json
{
    "body": "<a id='comment:1'>**Comment 1:**</a>\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7c532abee02b2c1e5005da408fb6420fc2dece89\">7c532ab</a></td><td><code>Merge branch 'develop' of trac.sagemath.org:sage into arm_fixes</code></td></tr></table>\n\noops, wrong commit/branch...",
    "created_at": "2014-04-03T23:25:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204302",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:1'>**Comment 1:**</a>
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7c532abee02b2c1e5005da408fb6420fc2dece89">7c532ab</a></td><td><code>Merge branch 'develop' of trac.sagemath.org:sage into arm_fixes</code></td></tr></table>

oops, wrong commit/branch...



---

archive/issue_comments_204303.json:
```json
{
    "body": "**Commit:** [7c532abee02b2c1e5005da408fb6420fc2dece89](https://github.com/sagemath/sagetrac-mirror/commit/7c532abee02b2c1e5005da408fb6420fc2dece89)",
    "created_at": "2014-04-03T23:25:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204303",
    "user": "https://github.com/dimpase"
}
```

**Commit:** [7c532abee02b2c1e5005da408fb6420fc2dece89](https://github.com/sagemath/sagetrac-mirror/commit/7c532abee02b2c1e5005da408fb6420fc2dece89)



---

archive/issue_comments_204304.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,4 +1,6 @@\n [Maxima uses CL FORMAT function wrongly](https://groups.google.com/d/msg/sage-devel/oRpkswzpK38/rNVbVN2RyEcJ), resulting in outputting wrong number of digits for floats (one extra), and \n contradicting its own manual on fpprintprec. In particular it outputs too many digits on ix86 and ix86_64, which got in Sage's doctests. As a result, doctests fail on ARM.\n \n-The fix is to replace the extra digit in doctests by dot.\n+The fixes are to convert the results into `RealField(prec)`, with appropriate `prec` \n+(at least 54, or sometimes more). This ticket also fixes ARM-specific numerical noise stemming \n+from various other upstream problems, such as `eglibc` loss of precision in `lgamma`. \n``````\n",
    "created_at": "2014-04-03T23:25:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204304",
    "user": "https://github.com/dimpase"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,4 +1,6 @@
 [Maxima uses CL FORMAT function wrongly](https://groups.google.com/d/msg/sage-devel/oRpkswzpK38/rNVbVN2RyEcJ), resulting in outputting wrong number of digits for floats (one extra), and 
 contradicting its own manual on fpprintprec. In particular it outputs too many digits on ix86 and ix86_64, which got in Sage's doctests. As a result, doctests fail on ARM.
 
-The fix is to replace the extra digit in doctests by dot.
+The fixes are to convert the results into `RealField(prec)`, with appropriate `prec` 
+(at least 54, or sometimes more). This ticket also fixes ARM-specific numerical noise stemming 
+from various other upstream problems, such as `eglibc` loss of precision in `lgamma`. 
``````




---

archive/issue_comments_204305.json:
```json
{
    "body": "**Changing commit** from \"[7c532abee02b2c1e5005da408fb6420fc2dece89](https://github.com/sagemath/sagetrac-mirror/commit/7c532abee02b2c1e5005da408fb6420fc2dece89)\" to \"[079bb9af4f12892268a19f0d218ac96bd72466f4](https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4)\".",
    "created_at": "2014-04-03T23:31:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204305",
    "user": "https://github.com/dimpase"
}
```

**Changing commit** from "[7c532abee02b2c1e5005da408fb6420fc2dece89](https://github.com/sagemath/sagetrac-mirror/commit/7c532abee02b2c1e5005da408fb6420fc2dece89)" to "[079bb9af4f12892268a19f0d218ac96bd72466f4](https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4)".



---

archive/issue_comments_204306.json:
```json
{
    "body": "**Changing branch** from \"[u/dimpase/arm_fixes](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/arm_fixes)\" to \"[u/dimpase/arm_fixes_etc](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/arm_fixes_etc)\".",
    "created_at": "2014-04-03T23:31:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204306",
    "user": "https://github.com/dimpase"
}
```

**Changing branch** from "[u/dimpase/arm_fixes](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/arm_fixes)" to "[u/dimpase/arm_fixes_etc](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/arm_fixes_etc)".



---

archive/issue_comments_204307.json:
```json
{
    "body": "<a id='comment:2'>**Comment 2:**</a>\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a7b7bf231d79a18fb10fe9757b1f2d81f5d0b850\">a7b7bf2</a></td><td><code>Numerical noise patches for ARM. As well, added # long time to many</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4\">079bb9a</a></td><td><code>replacing HG with git in examples</code></td></tr></table>\n",
    "created_at": "2014-04-03T23:31:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204307",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:2'>**Comment 2:**</a>
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a7b7bf231d79a18fb10fe9757b1f2d81f5d0b850">a7b7bf2</a></td><td><code>Numerical noise patches for ARM. As well, added # long time to many</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4">079bb9a</a></td><td><code>replacing HG with git in examples</code></td></tr></table>




---

archive/issue_comments_204308.json:
```json
{
    "body": "<a id='comment:3'>**Comment 3:**</a>\nstrangely enough, I sometimes get test timeouts in `plot/plot.py` when doing `make ptest`, but never for `make test`. Anyhow, please review.",
    "created_at": "2014-04-05T23:25:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204308",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:3'>**Comment 3:**</a>
strangely enough, I sometimes get test timeouts in `plot/plot.py` when doing `make ptest`, but never for `make test`. Anyhow, please review.



---

archive/issue_events_193860.json:
```json
{
    "actor": "https://github.com/dimpase",
    "created_at": "2014-04-05T23:25:45Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "008080",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193860"
}
```



---

archive/issue_events_193861.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "milestone_number": null,
    "milestone_title": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193861"
}
```



---

archive/issue_events_193862.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "milestone_number": null,
    "milestone_title": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193862"
}
```



---

archive/issue_comments_204309.json:
```json
{
    "body": "<a id='comment:5'>**Comment 5:**</a>\n\"doctest\" is both \"doc\" and \"test\" ; for the \"test\" part, making the precision of computations explicit is nice, but for the \"doc\" part, those computations are ugly: isn't it possible to do something better-looking?",
    "created_at": "2014-05-12T08:23:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204309",
    "user": "https://github.com/sagetrac-Snark"
}
```

<a id='comment:5'>**Comment 5:**</a>
"doctest" is both "doc" and "test" ; for the "test" part, making the precision of computations explicit is nice, but for the "doc" part, those computations are ugly: isn't it possible to do something better-looking?



---

archive/issue_comments_204310.json:
```json
{
    "body": "<a id='comment:6'>**Comment 6:**</a>\nReplying to [Snark](#comment%3A5):\n> \"doctest\" is both \"doc\" and \"test\" ; for the \"test\" part, making the precision of computations explicit is nice, but for the \"doc\" part, those computations are ugly: isn't it possible to do something better-looking?\n\nDo you mean to ask me do document adding things like `RealField(54)` ?",
    "created_at": "2014-05-12T12:08:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204310",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:6'>**Comment 6:**</a>
Replying to [Snark](#comment%3A5):
> "doctest" is both "doc" and "test" ; for the "test" part, making the precision of computations explicit is nice, but for the "doc" part, those computations are ugly: isn't it possible to do something better-looking?

Do you mean to ask me do document adding things like `RealField(54)` ?



---

archive/issue_comments_204311.json:
```json
{
    "body": "<a id='comment:7'>**Comment 7:**</a>\nReplying to [@dimpase](#comment%3A6):\n> Replying to [Snark](#comment%3A5):\n> > \"doctest\" is both \"doc\" and \"test\" ; for the \"test\" part, making the precision of computations explicit is nice, but for the \"doc\" part, those computations are ugly: isn't it possible to do something better-looking?\n\n> \n> Do you mean to ask me do document adding things like `RealField(54)` ?\n\nNo : I mean if some poor user types \"help(Gamma)\" and gets explained in the examples to type \"RealField(54)(Gamma(6))\", then that is bad.\n\nI propose to let the computation be just \"Gamma(6)\" and add a tolerance comment to check the answer (\"# abs tol 1e-11\"). That way we have a good doc and a correct test, hence a nice doctest.",
    "created_at": "2014-05-12T18:53:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204311",
    "user": "https://github.com/sagetrac-Snark"
}
```

<a id='comment:7'>**Comment 7:**</a>
Replying to [@dimpase](#comment%3A6):
> Replying to [Snark](#comment%3A5):
> > "doctest" is both "doc" and "test" ; for the "test" part, making the precision of computations explicit is nice, but for the "doc" part, those computations are ugly: isn't it possible to do something better-looking?

> 
> Do you mean to ask me do document adding things like `RealField(54)` ?

No : I mean if some poor user types "help(Gamma)" and gets explained in the examples to type "RealField(54)(Gamma(6))", then that is bad.

I propose to let the computation be just "Gamma(6)" and add a tolerance comment to check the answer ("# abs tol 1e-11"). That way we have a good doc and a correct test, hence a nice doctest.



---

archive/issue_comments_204312.json:
```json
{
    "body": "<a id='comment:8'>**Comment 8:**</a>\nReplying to [Snark](#comment%3A7):\n\n> No : I mean if some poor user types \"help(Gamma)\" and gets explained in the examples to type \"RealField(54)(Gamma(6))\", then that is bad.\n> \n> I propose to let the computation be just \"Gamma(6)\" and add a tolerance comment to check the answer (\"# abs tol 1e-11\"). That way we have a good doc and a correct test, hence a nice doctest.\n\nHow about putting what you suggest into the Examples section, and things like `RealField(54)(Gamma(6))` into the Tests section\n(latter with a proper comment, explaining what's going on)?",
    "created_at": "2014-05-12T19:01:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204312",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:8'>**Comment 8:**</a>
Replying to [Snark](#comment%3A7):

> No : I mean if some poor user types "help(Gamma)" and gets explained in the examples to type "RealField(54)(Gamma(6))", then that is bad.
> 
> I propose to let the computation be just "Gamma(6)" and add a tolerance comment to check the answer ("# abs tol 1e-11"). That way we have a good doc and a correct test, hence a nice doctest.

How about putting what you suggest into the Examples section, and things like `RealField(54)(Gamma(6))` into the Tests section
(latter with a proper comment, explaining what's going on)?



---

archive/issue_comments_204313.json:
```json
{
    "body": "<a id='comment:9'>**Comment 9:**</a>\nIt seems to me that converting to a `RealField` is not only (possibly confusing) noise for the reader; it could also hide potential future precision bugs.\n\nIs there any chance that the Maxima bug will get fixed soon?\n\nAlso, maybe I misunderstand, but what makes conversion of floats into a `RealField` with *higher* precision suppress numerical noise (mentioned in the ticket description)?",
    "created_at": "2014-05-12T19:54:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204313",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:9'>**Comment 9:**</a>
It seems to me that converting to a `RealField` is not only (possibly confusing) noise for the reader; it could also hide potential future precision bugs.

Is there any chance that the Maxima bug will get fixed soon?

Also, maybe I misunderstand, but what makes conversion of floats into a `RealField` with *higher* precision suppress numerical noise (mentioned in the ticket description)?



---

archive/issue_comments_204314.json:
```json
{
    "body": "<a id='comment:10'>**Comment 10:**</a>\nReplying to [@pjbruin](#comment%3A9):\n> It seems to me that converting to a `RealField` is not only (possibly confusing) noise for the reader; it could also hide potential future precision bugs.\n> \n> Is there any chance that the Maxima bug will get fixed soon?\n\nall I know about this is in the thread cited in the ticket description.\n\n> \n> Also, maybe I misunderstand, but what makes conversion of floats into a `RealField` with *higher* precision suppress numerical noise (mentioned in the ticket description)?\n\nprobably it should be classified as \"numerical noise\", but as \"precision/formatting/rounding bugs\". And the latter are Maxima, and perhaps also the ECL's interpretation of a particular case of undefined behaviour.   Hmm, perhaps it's also some specifically Sage problem:\n\n```\nsage: .4980113944988315\n0.498011394498831\nsage: .49801139449883150\n0.498011394498832 \n```\nConversion into `RealField(54)` appears to fix this discrepancy (I don't know why).\n\n```\nsage: RealField(54)(.49801139449883150)\n0.498011394498832\nsage: RealField(54)(.4980113944988315)\n0.498011394498832\n```\n\nBy the way, Python behaves differently, but still confusing :\n\n```\n$ python\nPython 2.7.5 (default, Aug 25 2013, 00:04:04) \n[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> .4980113944988315\n0.4980113944988315\n>>> .49801139449883150\n0.4980113944988315\n>>> .49801139449883155\n0.49801139449883153\n>>> .49801139449883156\n0.4980113944988316\n>>> \n```\nIn particular that `55` at the end being printed as `53`, and rounding `56` at the end as `60`, but keeping `55` as just `55`.\n\nOne reason against just putting ellipses is that this is a sure way to hide this problem forever...",
    "created_at": "2014-05-12T20:43:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204314",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:10'>**Comment 10:**</a>
Replying to [@pjbruin](#comment%3A9):
> It seems to me that converting to a `RealField` is not only (possibly confusing) noise for the reader; it could also hide potential future precision bugs.
> 
> Is there any chance that the Maxima bug will get fixed soon?

all I know about this is in the thread cited in the ticket description.

> 
> Also, maybe I misunderstand, but what makes conversion of floats into a `RealField` with *higher* precision suppress numerical noise (mentioned in the ticket description)?

probably it should be classified as "numerical noise", but as "precision/formatting/rounding bugs". And the latter are Maxima, and perhaps also the ECL's interpretation of a particular case of undefined behaviour.   Hmm, perhaps it's also some specifically Sage problem:

```
sage: .4980113944988315
0.498011394498831
sage: .49801139449883150
0.498011394498832 
```
Conversion into `RealField(54)` appears to fix this discrepancy (I don't know why).

```
sage: RealField(54)(.49801139449883150)
0.498011394498832
sage: RealField(54)(.4980113944988315)
0.498011394498832
```

By the way, Python behaves differently, but still confusing :

```
$ python
Python 2.7.5 (default, Aug 25 2013, 00:04:04) 
[GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.0.68)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> .4980113944988315
0.4980113944988315
>>> .49801139449883150
0.4980113944988315
>>> .49801139449883155
0.49801139449883153
>>> .49801139449883156
0.4980113944988316
>>> 
```
In particular that `55` at the end being printed as `53`, and rounding `56` at the end as `60`, but keeping `55` as just `55`.

One reason against just putting ellipses is that this is a sure way to hide this problem forever...



---

archive/issue_comments_204315.json:
```json
{
    "body": "<a id='comment:11'>**Comment 11:**</a>\nReplying to [@dimpase](#comment%3A10):\n> Replying to [@pjbruin](#comment%3A9):\n> > Also, maybe I misunderstand, but what makes conversion of floats into a `RealField` with *higher* precision suppress numerical noise (mentioned in the ticket description)?\n\n> \n> probably it should be classified as \"numerical noise\", but as \"precision/formatting/rounding bugs\". And the latter are Maxima, and perhaps also the ECL's interpretation of a particular case of undefined behaviour.   Hmm, perhaps it's also some specifically Sage problem:\n> \n> ```\n> sage: .4980113944988315\n> 0.498011394498831\n> sage: .49801139449883150\n> 0.498011394498832 \n> ```\n> Conversion into `RealField(54)` appears to fix this discrepancy (I don't know why).\n> \n> ```\n> sage: RealField(54)(.49801139449883150)\n> 0.498011394498832\n> sage: RealField(54)(.4980113944988315)\n> 0.498011394498832\n> ```\n\nPart of the subtlety is that the real number whose decimal expansion is `.4980113944988315000000...` does not have a finite binary expansion:\n\n```\nsage: a=.4980113944988315\nsage: a.prec()\n53\nsage: a.str(base=2)\n'0.011111110111110110101100101111000110100001100111111010'\nsage: b=.49801139449883150\nsage: b.prec()\n54\nsage: b.str(base=2)\n'0.0111111101111101101011001011110001101000011001111110101'\nsage: c=.498011394498831500000000000\nsage: c.str(base=2)\n'0.0111111101111101101011001011110001101000011001111110100111111111110011011100001100100101'\n```\nAt least this is consistent with normal rounding rules.\n\nThere is another subtlety, namely that `a` is a `RealLiteral` and remembers its decimal expansion, which demonstrates its effect when you convert `a` into a field with higher precision.  (See also [sort:date/sage-devel/c2Ih4uglTgQ/siUeEa4fz64J this sage-devel discussion](https://groups.google.com/forum/#!searchin/sage-devel/RealLiteral).) Instead of extending by 0, it gives the same binary expansion as `c`:\n\n```\ntype(a)\n<type 'sage.rings.real_mpfr.RealLiteral'>\nsage: RealField(c.prec())(a).str(base=2)\n'0.0111111101111101101011001011110001101000011001111110100111111111110011011100001100100101'\n```\nNow I don't know if this is what behind your observation; at least the output of `elliptic_e()` seems to be a `RealNumber`, not a `RealLiteral`.\n\n> One reason against just putting ellipses is that this is a sure way to hide this problem forever...\n\nYes, but I'd say the same holds for the `RealField(prec)(0.123)` solution...  I tend towards `# abs tol`/`# rel tol` as the least invasive solution, although that could also hide precision bugs.",
    "created_at": "2014-05-12T21:46:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204315",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:11'>**Comment 11:**</a>
Replying to [@dimpase](#comment%3A10):
> Replying to [@pjbruin](#comment%3A9):
> > Also, maybe I misunderstand, but what makes conversion of floats into a `RealField` with *higher* precision suppress numerical noise (mentioned in the ticket description)?

> 
> probably it should be classified as "numerical noise", but as "precision/formatting/rounding bugs". And the latter are Maxima, and perhaps also the ECL's interpretation of a particular case of undefined behaviour.   Hmm, perhaps it's also some specifically Sage problem:
> 
> ```
> sage: .4980113944988315
> 0.498011394498831
> sage: .49801139449883150
> 0.498011394498832 
> ```
> Conversion into `RealField(54)` appears to fix this discrepancy (I don't know why).
> 
> ```
> sage: RealField(54)(.49801139449883150)
> 0.498011394498832
> sage: RealField(54)(.4980113944988315)
> 0.498011394498832
> ```

Part of the subtlety is that the real number whose decimal expansion is `.4980113944988315000000...` does not have a finite binary expansion:

```
sage: a=.4980113944988315
sage: a.prec()
53
sage: a.str(base=2)
'0.011111110111110110101100101111000110100001100111111010'
sage: b=.49801139449883150
sage: b.prec()
54
sage: b.str(base=2)
'0.0111111101111101101011001011110001101000011001111110101'
sage: c=.498011394498831500000000000
sage: c.str(base=2)
'0.0111111101111101101011001011110001101000011001111110100111111111110011011100001100100101'
```
At least this is consistent with normal rounding rules.

There is another subtlety, namely that `a` is a `RealLiteral` and remembers its decimal expansion, which demonstrates its effect when you convert `a` into a field with higher precision.  (See also [sort:date/sage-devel/c2Ih4uglTgQ/siUeEa4fz64J this sage-devel discussion](https://groups.google.com/forum/#!searchin/sage-devel/RealLiteral).) Instead of extending by 0, it gives the same binary expansion as `c`:

```
type(a)
<type 'sage.rings.real_mpfr.RealLiteral'>
sage: RealField(c.prec())(a).str(base=2)
'0.0111111101111101101011001011110001101000011001111110100111111111110011011100001100100101'
```
Now I don't know if this is what behind your observation; at least the output of `elliptic_e()` seems to be a `RealNumber`, not a `RealLiteral`.

> One reason against just putting ellipses is that this is a sure way to hide this problem forever...

Yes, but I'd say the same holds for the `RealField(prec)(0.123)` solution...  I tend towards `# abs tol`/`# rel tol` as the least invasive solution, although that could also hide precision bugs.



---

archive/issue_comments_204316.json:
```json
{
    "body": "<a id='comment:12'>**Comment 12:**</a>\nReplying to [@pjbruin](#comment%3A11):\n> Now I don't know if this is what behind your observation; at least the output of `elliptic_e()` seems to be a `RealNumber`, not a `RealLiteral`.\n> \n\non different platforms Maxima's `elliptic_e()` outputs different number of digits.\n\n```\nMaxima on ARM:\n(%i1) elliptic_e(0.5, 0.1);\n(%o1)                          .4980113944988315\n\nas compared to x86_64:\n(%i1) elliptic_e(0.5, 0.1);\n(%o1)                         .49801139449883153 \n```\n\n(and Maxima with different Lisps does different things on the same platform, too - in some case just 14 digits...)\n\nActually, as you mention, on `x86_64` the number of digits is too big for `RealField(53)`. I have no idea whether this is handled gracefully by Sage, or not.\n\n> Yes, but I'd say the same holds for the `RealField(prec)(0.123)` solution...  I tend towards `# abs tol`/`# rel tol` as the least invasive solution, although that could also hide precision bugs.\n\nWell, it is a mess anyway. I'd be glad to have it off my shoulders one way or another.",
    "created_at": "2014-05-13T15:21:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204316",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:12'>**Comment 12:**</a>
Replying to [@pjbruin](#comment%3A11):
> Now I don't know if this is what behind your observation; at least the output of `elliptic_e()` seems to be a `RealNumber`, not a `RealLiteral`.
> 

on different platforms Maxima's `elliptic_e()` outputs different number of digits.

```
Maxima on ARM:
(%i1) elliptic_e(0.5, 0.1);
(%o1)                          .4980113944988315

as compared to x86_64:
(%i1) elliptic_e(0.5, 0.1);
(%o1)                         .49801139449883153 
```

(and Maxima with different Lisps does different things on the same platform, too - in some case just 14 digits...)

Actually, as you mention, on `x86_64` the number of digits is too big for `RealField(53)`. I have no idea whether this is handled gracefully by Sage, or not.

> Yes, but I'd say the same holds for the `RealField(prec)(0.123)` solution...  I tend towards `# abs tol`/`# rel tol` as the least invasive solution, although that could also hide precision bugs.

Well, it is a mess anyway. I'd be glad to have it off my shoulders one way or another.



---

archive/issue_comments_204317.json:
```json
{
    "body": "<a id='comment:13'>**Comment 13:**</a>\nCould it be solved by setting Maxima's `fpprintprec` option to the correct value depending on the platform?  I think `RealField(53)` prints numbers with 15 significant digits.  In Maxima with ECL on x86_64 (`sage --maxima`), I get\n\n```\n(%i19) fpprintprec: 13;\n(%o19)                                13\n(%i20) elliptic_e(0.5, 0.1);\n(%o20)                          .49801139449883\n(%i21) fpprintprec: 14;\n(%o21)                                14\n(%i22) elliptic_e(0.5, 0.1);\n(%o22)                         .498011394498832\n(%i23) fpprintprec: 15;\n(%o23)                                15\n(%i24) elliptic_e(0.5, 0.1);\n(%o24)                         .4980113944988315\n(%i25) fpprintprec: 16;\n(%o25)                                16\n(%i26) elliptic_e(0.5, 0.1);\n(%o26)                        .49801139449883153\n```\nso `fpprintprec` should presumably be set to 14.  Maybe we could do something like first setting `fpprintprec` to 15, count with how many digits Maxima prints `1/3.0`, and then adjusting `fpprintprec` by how much this differs from 15.",
    "created_at": "2014-05-13T16:51:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204317",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:13'>**Comment 13:**</a>
Could it be solved by setting Maxima's `fpprintprec` option to the correct value depending on the platform?  I think `RealField(53)` prints numbers with 15 significant digits.  In Maxima with ECL on x86_64 (`sage --maxima`), I get

```
(%i19) fpprintprec: 13;
(%o19)                                13
(%i20) elliptic_e(0.5, 0.1);
(%o20)                          .49801139449883
(%i21) fpprintprec: 14;
(%o21)                                14
(%i22) elliptic_e(0.5, 0.1);
(%o22)                         .498011394498832
(%i23) fpprintprec: 15;
(%o23)                                15
(%i24) elliptic_e(0.5, 0.1);
(%o24)                         .4980113944988315
(%i25) fpprintprec: 16;
(%o25)                                16
(%i26) elliptic_e(0.5, 0.1);
(%o26)                        .49801139449883153
```
so `fpprintprec` should presumably be set to 14.  Maybe we could do something like first setting `fpprintprec` to 15, count with how many digits Maxima prints `1/3.0`, and then adjusting `fpprintprec` by how much this differs from 15.



---

archive/issue_comments_204318.json:
```json
{
    "body": "<a id='comment:14'>**Comment 14:**</a>\nThis seems to correctly set the `fpprintprec`; on my x86_64 system it leads to lots of doctest failures where the number of digits printed is now one less than before.\n\n```diff\ndiff --git a/src/sage/interfaces/maxima.py b/src/sage/interfaces/maxima.py\nindex 7603881..7a36885 100644\n--- a/src/sage/interfaces/maxima.py\n+++ b/src/sage/interfaces/maxima.py\n@@ -136,6 +136,8 @@ http://maxima.sourceforge.net/docs/intromax/intromax.html.\n \n     sage: maxima.eval('fpprec : 100')\n     '100'\n+    sage: maxima.eval('fpprintprec : 100')\n+    '100'\n     sage: a.bfloat()\n     8.20121933088197564152489730020812442785204843859314941221237124017312418754011041266612384955016056b1\n \n@@ -362,6 +364,8 @@ Obtaining digits of `\\pi`::\n \n     sage: maxima.eval('fpprec : 100')\n     '100'\n+    sage: maxima.eval('fpprintprec : 100')\n+    '100'\n     sage: maxima(pi).bfloat()\n     3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068b0\n \n@@ -594,6 +598,12 @@ class Maxima(MaximaAbstract, Expect):\n         # Remove limit on the max heapsize (since otherwise it defaults\n         # to 256MB with ECL).\n         self._sendline(\":lisp (ext:set-limit 'ext:heap-size 0)\")\n+\n+        # Adjust the precision (see Trac #15921)\n+        self._sendline('fpprintprec : 15;')\n+        s = self._eval_line('1/3.0;')\n+        self._sendline('fpprintprec : {};'.format(30 - s.count('3')))\n+\n         self._eval_line('0;')\n \n     def __reduce__(self):\ndiff --git a/src/sage/interfaces/maxima_lib.py b/src/sage/interfaces/maxima_lib.py\nindex 643ac0f..5c94370 100644\n--- a/src/sage/interfaces/maxima_lib.py\n+++ b/src/sage/interfaces/maxima_lib.py\n@@ -331,6 +331,12 @@ class MaximaLib(MaximaAbstract):\n         self.__init_code = init_code\n \n         MaximaAbstract.__init__(self,\"maxima_lib\")\n+\n+        # Adjust the precision (see Trac #15921)\n+        self._eval_line('fpprintprec : 15')\n+        s = self._eval_line('1/3.0;')\n+        self._eval_line('fpprintprec : {}'.format(30 - s.count('3')))\n+\n         self.__seq = 0\n \n     def _coerce_from_special_method(self, x):\ndiff --git a/src/sage/symbolic/constants.py b/src/sage/symbolic/constants.py\nindex 6f76834..5917fba 100644\n--- a/src/sage/symbolic/constants.py\n+++ b/src/sage/symbolic/constants.py\n@@ -160,6 +160,8 @@ EXAMPLES: Arithmetic with constants\n     sage: pim = maxima(pi)\n     sage: maxima.eval('fpprec : 100')\n     '100'\n+    sage: maxima.eval('fpprintprec: 100')\n+    '100'\n     sage: pim.bfloat()\n     3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068b0\n```\nDo you think this approach would be worth trying?",
    "created_at": "2014-05-13T18:15:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204318",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:14'>**Comment 14:**</a>
This seems to correctly set the `fpprintprec`; on my x86_64 system it leads to lots of doctest failures where the number of digits printed is now one less than before.

```diff
diff --git a/src/sage/interfaces/maxima.py b/src/sage/interfaces/maxima.py
index 7603881..7a36885 100644
--- a/src/sage/interfaces/maxima.py
+++ b/src/sage/interfaces/maxima.py
@@ -136,6 +136,8 @@ http://maxima.sourceforge.net/docs/intromax/intromax.html.
 
     sage: maxima.eval('fpprec : 100')
     '100'
+    sage: maxima.eval('fpprintprec : 100')
+    '100'
     sage: a.bfloat()
     8.20121933088197564152489730020812442785204843859314941221237124017312418754011041266612384955016056b1
 
@@ -362,6 +364,8 @@ Obtaining digits of `\pi`::
 
     sage: maxima.eval('fpprec : 100')
     '100'
+    sage: maxima.eval('fpprintprec : 100')
+    '100'
     sage: maxima(pi).bfloat()
     3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068b0
 
@@ -594,6 +598,12 @@ class Maxima(MaximaAbstract, Expect):
         # Remove limit on the max heapsize (since otherwise it defaults
         # to 256MB with ECL).
         self._sendline(":lisp (ext:set-limit 'ext:heap-size 0)")
+
+        # Adjust the precision (see Trac #15921)
+        self._sendline('fpprintprec : 15;')
+        s = self._eval_line('1/3.0;')
+        self._sendline('fpprintprec : {};'.format(30 - s.count('3')))
+
         self._eval_line('0;')
 
     def __reduce__(self):
diff --git a/src/sage/interfaces/maxima_lib.py b/src/sage/interfaces/maxima_lib.py
index 643ac0f..5c94370 100644
--- a/src/sage/interfaces/maxima_lib.py
+++ b/src/sage/interfaces/maxima_lib.py
@@ -331,6 +331,12 @@ class MaximaLib(MaximaAbstract):
         self.__init_code = init_code
 
         MaximaAbstract.__init__(self,"maxima_lib")
+
+        # Adjust the precision (see Trac #15921)
+        self._eval_line('fpprintprec : 15')
+        s = self._eval_line('1/3.0;')
+        self._eval_line('fpprintprec : {}'.format(30 - s.count('3')))
+
         self.__seq = 0
 
     def _coerce_from_special_method(self, x):
diff --git a/src/sage/symbolic/constants.py b/src/sage/symbolic/constants.py
index 6f76834..5917fba 100644
--- a/src/sage/symbolic/constants.py
+++ b/src/sage/symbolic/constants.py
@@ -160,6 +160,8 @@ EXAMPLES: Arithmetic with constants
     sage: pim = maxima(pi)
     sage: maxima.eval('fpprec : 100')
     '100'
+    sage: maxima.eval('fpprintprec: 100')
+    '100'
     sage: pim.bfloat()
     3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068b0
```
Do you think this approach would be worth trying?



---

archive/issue_comments_204319.json:
```json
{
    "body": "<a id='comment:15'>**Comment 15:**</a>\nLet me try this on ARM. Could you please add your patch as an attachment to the ticket?",
    "created_at": "2014-05-13T18:40:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204319",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:15'>**Comment 15:**</a>
Let me try this on ARM. Could you please add your patch as an attachment to the ticket?



---

archive/issue_comments_204320.json:
```json
{
    "body": "set fpprintprec so that Maxima outputs 15 digits of precision",
    "created_at": "2014-05-13T19:54:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204320",
    "user": "https://github.com/pjbruin"
}
```

set fpprintprec so that Maxima outputs 15 digits of precision



---

archive/issue_comments_204321.json:
```json
{
    "body": "<a id='comment:16'>**Comment 16:**</a>\n**Attachment:** [fpprintprec.patch.gz](https://github.com/sagemath/sage/files/ticket15921/fpprintprec.patch.gz)\n\nIf we take this approach, we should probably have two separate tickets, one for the Maxima bug and one for ARM-specific issues.  Also, the duplicated code in this patch should be in `maxima_abstract.py`.",
    "created_at": "2014-05-13T19:57:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204321",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:16'>**Comment 16:**</a>
**Attachment:** [fpprintprec.patch.gz](https://github.com/sagemath/sage/files/ticket15921/fpprintprec.patch.gz)

If we take this approach, we should probably have two separate tickets, one for the Maxima bug and one for ARM-specific issues.  Also, the duplicated code in this patch should be in `maxima_abstract.py`.



---

archive/issue_comments_204322.json:
```json
{
    "body": "<a id='comment:17'>**Comment 17:**</a>\nI'm starting to think that we shouldn't try to limit `fpprintprec` after all, because this will only introduce unnecessary rounding errors.  A more robust solution would be to leave it as 0 and to set `maxfpprintprec` (which is 16 by default) to 20 or some other sufficiently high value, so that the output precision is only controlled by the Lisp implementation (and the platform).  At least on x86_64 with ECL, both the length and the least significant digits are unpredictable: dividing some powers of 10 by 3 gives a result that looks like\n\n```\n3.333333333333333493e-5 \n3.333333333333333222e-4 \n0.003333333333333333 \n0.03333333333333333 \n0.3333333333333333 \n3.3333333333333335 \n33.333333333333336 \n333.3333333333333 \n3333.3333333333335 \n33333.333333333336 \n333333.3333333333 \n3333333.3333333335 \n3.3333333333333332093e+7 \n3.3333333333333331347e+8 \n```\nThe '...335' at the end of 3.33... is clearly wrong, but limiting the precision would turn that into ...34, which is even worse.  I have the feeling that we should just live with the above values and insert `# abs tol` and `# rel tol` in doctests where appropriate.\n\nAfter doing the above computation with three Lisp variants (ECL, GCL and SBCL) I have the impression that GCL has the best floating-point accuracy, ECL the worst, and SBCL is in between.  I don't know whether this is caused by differences in the floating-point internals or in the Lisp `format` function.",
    "created_at": "2014-05-14T19:20:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204322",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:17'>**Comment 17:**</a>
I'm starting to think that we shouldn't try to limit `fpprintprec` after all, because this will only introduce unnecessary rounding errors.  A more robust solution would be to leave it as 0 and to set `maxfpprintprec` (which is 16 by default) to 20 or some other sufficiently high value, so that the output precision is only controlled by the Lisp implementation (and the platform).  At least on x86_64 with ECL, both the length and the least significant digits are unpredictable: dividing some powers of 10 by 3 gives a result that looks like

```
3.333333333333333493e-5 
3.333333333333333222e-4 
0.003333333333333333 
0.03333333333333333 
0.3333333333333333 
3.3333333333333335 
33.333333333333336 
333.3333333333333 
3333.3333333333335 
33333.333333333336 
333333.3333333333 
3333333.3333333335 
3.3333333333333332093e+7 
3.3333333333333331347e+8 
```
The '...335' at the end of 3.33... is clearly wrong, but limiting the precision would turn that into ...34, which is even worse.  I have the feeling that we should just live with the above values and insert `# abs tol` and `# rel tol` in doctests where appropriate.

After doing the above computation with three Lisp variants (ECL, GCL and SBCL) I have the impression that GCL has the best floating-point accuracy, ECL the worst, and SBCL is in between.  I don't know whether this is caused by differences in the floating-point internals or in the Lisp `format` function.



---

archive/issue_comments_204323.json:
```json
{
    "body": "<a id='comment:18'>**Comment 18:**</a>\nReplying to [@pjbruin](#comment%3A17):\n> I'm starting to think that we shouldn't try to limit `fpprintprec` after all, because this will only introduce unnecessary rounding errors.  A more robust solution would be to leave it as 0 and to set `maxfpprintprec` (which is 16 by default) to 20 or some other sufficiently high value, so that the output precision is only controlled by the Lisp implementation (and the platform).  At least on x86_64 with ECL, both the length and the least significant digits are unpredictable: dividing some powers of 10 by 3 gives a result that looks like\n> \n> ```\n> 3.333333333333333493e-5 \n> 3.333333333333333222e-4 \n> 0.003333333333333333 \n> 0.03333333333333333 \n> 0.3333333333333333 \n> 3.3333333333333335 \n> 33.333333333333336 \n> 333.3333333333333 \n> 3333.3333333333335 \n> 33333.333333333336 \n> 333333.3333333333 \n> 3333333.3333333335 \n> 3.3333333333333332093e+7 \n> 3.3333333333333331347e+8 \n> ```\n\nhow do you get this output?\nIs it printed by Sage, or by Maxima, or by ECL?\n\nFor me ECL prints something like\n\n```\n>> (float (/ (expt 10. 3) 3))                   \n333.33334\n```\neven though\n\n```\n>> (float-precision (float (/ (expt 10. 3) 3)))\n24\n```",
    "created_at": "2014-05-15T13:33:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204323",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:18'>**Comment 18:**</a>
Replying to [@pjbruin](#comment%3A17):
> I'm starting to think that we shouldn't try to limit `fpprintprec` after all, because this will only introduce unnecessary rounding errors.  A more robust solution would be to leave it as 0 and to set `maxfpprintprec` (which is 16 by default) to 20 or some other sufficiently high value, so that the output precision is only controlled by the Lisp implementation (and the platform).  At least on x86_64 with ECL, both the length and the least significant digits are unpredictable: dividing some powers of 10 by 3 gives a result that looks like
> 
> ```
> 3.333333333333333493e-5 
> 3.333333333333333222e-4 
> 0.003333333333333333 
> 0.03333333333333333 
> 0.3333333333333333 
> 3.3333333333333335 
> 33.333333333333336 
> 333.3333333333333 
> 3333.3333333333335 
> 33333.333333333336 
> 333333.3333333333 
> 3333333.3333333335 
> 3.3333333333333332093e+7 
> 3.3333333333333331347e+8 
> ```

how do you get this output?
Is it printed by Sage, or by Maxima, or by ECL?

For me ECL prints something like

```
>> (float (/ (expt 10. 3) 3))                   
333.33334
```
even though

```
>> (float-precision (float (/ (expt 10. 3) 3)))
24
```



---

archive/issue_comments_204324.json:
```json
{
    "body": "<a id='comment:19'>**Comment 19:**</a>\nThis is using Maxima, which outputs floating numbers using the Lisp `format` function.  On ARM the commands (same which I used to get the above output on `x86_64`) and output look as follows:\n\n```\npbruin@node3eth0:~/src/sage$ ./sage --maxima\n...\nMaxima 5.29.1 http://maxima.sourceforge.net\nusing Lisp ECL 12.12.1\n...\n(%i1) maxfpprintprec: 100;\n(%o1)                                 100\n(%i2) for i: -4 thru 9 do print(10^i/3.0);\n3.3333333333333337e-5 \n3.333333333333333e-4 \n0.003333333333333333 \n0.03333333333333333 \n0.3333333333333333 \n3.3333333333333335 \n33.333333333333336 \n333.3333333333333 \n3333.3333333333335 \n33333.333333333336 \n333333.3333333333 \n3333333.3333333335 \n3.333333333333333e+7 \n3.333333333333333e+8 \n(%o2)                                done\n```",
    "created_at": "2014-05-15T14:15:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204324",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:19'>**Comment 19:**</a>
This is using Maxima, which outputs floating numbers using the Lisp `format` function.  On ARM the commands (same which I used to get the above output on `x86_64`) and output look as follows:

```
pbruin@node3eth0:~/src/sage$ ./sage --maxima
...
Maxima 5.29.1 http://maxima.sourceforge.net
using Lisp ECL 12.12.1
...
(%i1) maxfpprintprec: 100;
(%o1)                                 100
(%i2) for i: -4 thru 9 do print(10^i/3.0);
3.3333333333333337e-5 
3.333333333333333e-4 
0.003333333333333333 
0.03333333333333333 
0.3333333333333333 
3.3333333333333335 
33.333333333333336 
333.3333333333333 
3333.3333333333335 
33333.333333333336 
333333.3333333333 
3333333.3333333335 
3.333333333333333e+7 
3.333333333333333e+8 
(%o2)                                done
```



---

archive/issue_comments_204325.json:
```json
{
    "body": "set maxfpprintprec to 21 (better alternative to fpprintprec.patch; passes tests)",
    "created_at": "2014-05-15T17:16:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204325",
    "user": "https://github.com/pjbruin"
}
```

set maxfpprintprec to 21 (better alternative to fpprintprec.patch; passes tests)



---

archive/issue_comments_204326.json:
```json
{
    "body": "<a id='comment:20'>**Comment 20:**</a>\n**Attachment:** [maxfpprintprec.patch.gz](https://github.com/sagemath/sage/files/ticket15921/maxfpprintprec.patch.gz)\n\nOn both ARM and x86_64, the only noticeable effect of setting `maxfpprintprec: 21` (see [attachment:maxfpprintprec.patch](https://github.com/sagemath/sage/files/ticket15921/maxfpprintprec.patch)) is that Maxima now prints floating point numbers in (-1, 1) starting with `(-)0.` instead of just `(-).`.  This is of course fairly limited, but still nice.  In a stand-alone Maxima compiled with GCL or SBCL, it actually yields one extra digit of accuracy (meaning that the last digit is in general wrong, but it not rounded away and thereby corrupting the previous digit).  I could not find an example where this happens on ECL, so that Sage would benefit from it.\n\nIt seems that we still need a separate fix for the following doctest failures on ARM (note that the last two are identical, so we could remove the first one):\n\n```\nFile \"src/sage/symbolic/expression.pyx\", line 7340, in sage.symbolic.expression.Expression.gamma\nFailed example:\n    SR(10.0r).gamma()\nExpected:\n    362880.0\nGot:\n    362880.00000000047\nFile \"src/sage/functions/bessel.py\", line 1618, in sage.functions.bessel._Bessel.__call__\nFailed example:\n    _Bessel(20,algorithm='maxima')(5.0)\nExpected:\n    27.703300521289436e-12\nGot:\n    27.70330052128944e-12\nFile \"src/sage/functions/other.py\", line 663, in sage.functions.other.Function_gamma.__init__\nFailed example:\n    gamma1(float(6))\nExpected:\n    120.0\nGot:\n    119.99999999999997\nFile \"src/sage/functions/special.py\", line 705, in sage.functions.special.elliptic_j.EllipticE\nFailed example:\n    elliptic_e(0.5, 0.1)\nExpected:\n    0.498011394498832\nGot:\n    0.498011394498831\nFile \"src/sage/functions/special.py\", line 715, in sage.functions.special.elliptic_j.EllipticE.__init__\nFailed example:\n    elliptic_e(0.5, 0.1)\nExpected:\n    0.498011394498832\nGot:\n    0.498011394498831\n```\nPatch coming soon.  (Sticking to patches instead of a Git branch to make it easier to sort out what do here and what to do on a separate ticket.)",
    "created_at": "2014-05-15T17:48:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204326",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:20'>**Comment 20:**</a>
**Attachment:** [maxfpprintprec.patch.gz](https://github.com/sagemath/sage/files/ticket15921/maxfpprintprec.patch.gz)

On both ARM and x86_64, the only noticeable effect of setting `maxfpprintprec: 21` (see [attachment:maxfpprintprec.patch](https://github.com/sagemath/sage/files/ticket15921/maxfpprintprec.patch)) is that Maxima now prints floating point numbers in (-1, 1) starting with `(-)0.` instead of just `(-).`.  This is of course fairly limited, but still nice.  In a stand-alone Maxima compiled with GCL or SBCL, it actually yields one extra digit of accuracy (meaning that the last digit is in general wrong, but it not rounded away and thereby corrupting the previous digit).  I could not find an example where this happens on ECL, so that Sage would benefit from it.

It seems that we still need a separate fix for the following doctest failures on ARM (note that the last two are identical, so we could remove the first one):

```
File "src/sage/symbolic/expression.pyx", line 7340, in sage.symbolic.expression.Expression.gamma
Failed example:
    SR(10.0r).gamma()
Expected:
    362880.0
Got:
    362880.00000000047
File "src/sage/functions/bessel.py", line 1618, in sage.functions.bessel._Bessel.__call__
Failed example:
    _Bessel(20,algorithm='maxima')(5.0)
Expected:
    27.703300521289436e-12
Got:
    27.70330052128944e-12
File "src/sage/functions/other.py", line 663, in sage.functions.other.Function_gamma.__init__
Failed example:
    gamma1(float(6))
Expected:
    120.0
Got:
    119.99999999999997
File "src/sage/functions/special.py", line 705, in sage.functions.special.elliptic_j.EllipticE
Failed example:
    elliptic_e(0.5, 0.1)
Expected:
    0.498011394498832
Got:
    0.498011394498831
File "src/sage/functions/special.py", line 715, in sage.functions.special.elliptic_j.EllipticE.__init__
Failed example:
    elliptic_e(0.5, 0.1)
Expected:
    0.498011394498832
Got:
    0.498011394498831
```
Patch coming soon.  (Sticking to patches instead of a Git branch to make it easier to sort out what do here and what to do on a separate ticket.)



---

archive/issue_comments_204327.json:
```json
{
    "body": "<a id='comment:21'>**Comment 21:**</a>\nAs a mostly irrelevant side remark, here is a curious error message from the doctest framework:\n\n```\nFile \"src/sage/functions/special.py\", line 705, in sage.functions.special.elliptic_j.EllipticE\nFailed example:\n    elliptic_e(0.5, 0.1)  # abs tol 1e-15\nExpected:\n    0.498011394498832\nGot:\n    0.498011394498831\nTolerance exceeded: 1e-15 > 1e-15\n```\nI'll just change it to 2e-15, then...",
    "created_at": "2014-05-15T18:09:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204327",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:21'>**Comment 21:**</a>
As a mostly irrelevant side remark, here is a curious error message from the doctest framework:

```
File "src/sage/functions/special.py", line 705, in sage.functions.special.elliptic_j.EllipticE
Failed example:
    elliptic_e(0.5, 0.1)  # abs tol 1e-15
Expected:
    0.498011394498832
Got:
    0.498011394498831
Tolerance exceeded: 1e-15 > 1e-15
```
I'll just change it to 2e-15, then...



---

archive/issue_comments_204328.json:
```json
{
    "body": "fix some special function values and precision",
    "created_at": "2014-05-15T18:30:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204328",
    "user": "https://github.com/pjbruin"
}
```

fix some special function values and precision



---

archive/issue_comments_204329.json:
```json
{
    "body": "<a id='comment:22'>**Comment 22:**</a>\n**Attachment:** [special_functions_precision.patch.gz](https://github.com/sagemath/sage/files/ticket15921/special_functions_precision.patch.gz)\n\nSee attachment.  I also discovered (by comparing with PARI) that the output of the Bessel function was in fact less correct (on both ARM and x86_64) than the doctest suggested.  I changed the output to match the actual value instead of Maxima's approximation, and added a suitable `rel tol` marker.  Is there a general rule saying whether one should resolve such discrepancies like this?",
    "created_at": "2014-05-15T18:34:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204329",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:22'>**Comment 22:**</a>
**Attachment:** [special_functions_precision.patch.gz](https://github.com/sagemath/sage/files/ticket15921/special_functions_precision.patch.gz)

See attachment.  I also discovered (by comparing with PARI) that the output of the Bessel function was in fact less correct (on both ARM and x86_64) than the doctest suggested.  I changed the output to match the actual value instead of Maxima's approximation, and added a suitable `rel tol` marker.  Is there a general rule saying whether one should resolve such discrepancies like this?



---

archive/issue_comments_204330.json:
```json
{
    "body": "<a id='comment:23'>**Comment 23:**</a>\nReplying to [@pjbruin](#comment%3A22):\n> See attachment.  I also discovered (by comparing with PARI) that the output of the Bessel function was in fact less correct (on both ARM and x86_64) than the doctest suggested.  I changed the output to match the actual value instead of Maxima's approximation, and added a suitable `rel tol` marker.  Is there a general rule saying whether one should resolve such discrepancies like this?\n\nperhaps, report upstream? By the way, do you know whether Maxima uses double precision CL floats in that kinds of functions?",
    "created_at": "2014-05-15T18:50:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204330",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:23'>**Comment 23:**</a>
Replying to [@pjbruin](#comment%3A22):
> See attachment.  I also discovered (by comparing with PARI) that the output of the Bessel function was in fact less correct (on both ARM and x86_64) than the doctest suggested.  I changed the output to match the actual value instead of Maxima's approximation, and added a suitable `rel tol` marker.  Is there a general rule saying whether one should resolve such discrepancies like this?

perhaps, report upstream? By the way, do you know whether Maxima uses double precision CL floats in that kinds of functions?



---

archive/issue_comments_204331.json:
```json
{
    "body": "<a id='comment:24'>**Comment 24:**</a>\nIt seems so; the following is based on `bessel.lisp` (case of real and positive order and argument) and reproduces the numerical inaccuracy (enter `to_lisp();` in Maxima and then input this):\n\n```cl\n(let ((order 20)\n      (arg 5))\n  (multiple-value-bind (n alpha) (floor (float order))\n    (let ((jvals (make-array (1+ n) :element-type 'flonum)))\n      (slatec:dbesj (abs (float arg)) alpha (1+ n) jvals 0)\n      (aref jvals n))))\n```\nThe Lisp function `slatec:dbesj` was apparently automatically translated from Fortran.",
    "created_at": "2014-05-15T19:34:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204331",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:24'>**Comment 24:**</a>
It seems so; the following is based on `bessel.lisp` (case of real and positive order and argument) and reproduces the numerical inaccuracy (enter `to_lisp();` in Maxima and then input this):

```cl
(let ((order 20)
      (arg 5))
  (multiple-value-bind (n alpha) (floor (float order))
    (let ((jvals (make-array (1+ n) :element-type 'flonum)))
      (slatec:dbesj (abs (float arg)) alpha (1+ n) jvals 0)
      (aref jvals n))))
```
The Lisp function `slatec:dbesj` was apparently automatically translated from Fortran.



---

archive/issue_comments_204332.json:
```json
{
    "body": "<a id='comment:25'>**Comment 25:**</a>\nIt doesn't matter so much, the default implementation of the user-accessible Bessel *J*-function is OK:\n\n```\nsage: bessel_J(20, 5).N(100)\n2.7703300521289416873940187368e-11\nsage: pari(20).besselj(5, precision=100)\n2.77033005212894168739401873681733200777 E-11\n```",
    "created_at": "2014-05-15T19:46:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204332",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:25'>**Comment 25:**</a>
It doesn't matter so much, the default implementation of the user-accessible Bessel *J*-function is OK:

```
sage: bessel_J(20, 5).N(100)
2.7703300521289416873940187368e-11
sage: pari(20).besselj(5, precision=100)
2.77033005212894168739401873681733200777 E-11
```



---

archive/issue_comments_204333.json:
```json
{
    "body": "**Reviewer:** Peter Bruin",
    "created_at": "2014-05-17T14:49:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204333",
    "user": "https://github.com/pjbruin"
}
```

**Reviewer:** Peter Bruin



---

archive/issue_comments_204334.json:
```json
{
    "body": "<a id='comment:26'>**Comment 26:**</a>\nI redid a few tests after upgrading to Maxima 5.33.0 (#13973), and nothing really changed, except the change from `.123...` to `0.123...` is also done (upstream, differently than in [by this upgrade.  May I propose that we just apply the changes from [attachment:special_functions_precision.patch](https://github.com/sagemath/sage/files/ticket15921/fbbcd2f77a7c01438beda92e2ee58e85.patch](https://github.com/sagemath/sage/files/ticket15921/03cc6fcd4b0a5cf8aee3874f721a6664.patch))) to solve the precision problems in this ticket?\n\nI'm happy with the other changes you made, even though they don't really seem to be related to ARM, Maxima or precision.  Two trivial remarks:\n- The message `Doctesting files changed since the last git commit` doesn't seem to have a full stop at the end when I run `sage -t --new`.\n- Does the `show_default()` doctest in `graphics.py` really take a long time?",
    "created_at": "2014-05-17T14:49:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204334",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:26'>**Comment 26:**</a>
I redid a few tests after upgrading to Maxima 5.33.0 (#13973), and nothing really changed, except the change from `.123...` to `0.123...` is also done (upstream, differently than in [by this upgrade.  May I propose that we just apply the changes from [attachment:special_functions_precision.patch](https://github.com/sagemath/sage/files/ticket15921/fbbcd2f77a7c01438beda92e2ee58e85.patch](https://github.com/sagemath/sage/files/ticket15921/03cc6fcd4b0a5cf8aee3874f721a6664.patch))) to solve the precision problems in this ticket?

I'm happy with the other changes you made, even though they don't really seem to be related to ARM, Maxima or precision.  Two trivial remarks:
- The message `Doctesting files changed since the last git commit` doesn't seem to have a full stop at the end when I run `sage -t --new`.
- Does the `show_default()` doctest in `graphics.py` really take a long time?



---

archive/issue_comments_204335.json:
```json
{
    "body": "<a id='comment:27'>**Comment 27:**</a>\nReplying to [@pjbruin](#comment%3A26):\n> I redid a few tests after upgrading to Maxima 5.33.0 (#13973), and nothing really changed, except the change from `.123...` to `0.123...` is also done (upstream, differently than in [by this upgrade.  May I propose that we just apply the changes from [attachment:special_functions_precision.patch](https://github.com/sagemath/sage/files/ticket15921/fbbcd2f77a7c01438beda92e2ee58e85.patch](https://github.com/sagemath/sage/files/ticket15921/03cc6fcd4b0a5cf8aee3874f721a6664.patch))) to solve the precision problems in this ticket?\n\nI wonder about the `# For ARM: rel tol 2e-15` tag.\nHow does it work? Or is this just a comment? \n\n> \n> I'm happy with the other changes you made, even though they don't really seem to be related to ARM, Maxima or precision.  Two trivial remarks:\n> - The message `Doctesting files changed since the last git commit` doesn't seem to have a full stop at the end when I run `sage -t --new`.\n> - Does the `show_default()` doctest in `graphics.py` really take a long time?\n\nI did timings of tests on ARM and added `#long time` to these above certain thresholds.\n\nIt's not 100% clear what changes you propose. Can you do a reviewer's git branch (or a patch)?",
    "created_at": "2014-05-19T13:51:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204335",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:27'>**Comment 27:**</a>
Replying to [@pjbruin](#comment%3A26):
> I redid a few tests after upgrading to Maxima 5.33.0 (#13973), and nothing really changed, except the change from `.123...` to `0.123...` is also done (upstream, differently than in [by this upgrade.  May I propose that we just apply the changes from [attachment:special_functions_precision.patch](https://github.com/sagemath/sage/files/ticket15921/fbbcd2f77a7c01438beda92e2ee58e85.patch](https://github.com/sagemath/sage/files/ticket15921/03cc6fcd4b0a5cf8aee3874f721a6664.patch))) to solve the precision problems in this ticket?

I wonder about the `# For ARM: rel tol 2e-15` tag.
How does it work? Or is this just a comment? 

> 
> I'm happy with the other changes you made, even though they don't really seem to be related to ARM, Maxima or precision.  Two trivial remarks:
> - The message `Doctesting files changed since the last git commit` doesn't seem to have a full stop at the end when I run `sage -t --new`.
> - Does the `show_default()` doctest in `graphics.py` really take a long time?

I did timings of tests on ARM and added `#long time` to these above certain thresholds.

It's not 100% clear what changes you propose. Can you do a reviewer's git branch (or a patch)?



---

archive/issue_comments_204336.json:
```json
{
    "body": "<a id='comment:28'>**Comment 28:**</a>\nReplying to [@dimpase](#comment%3A27):\n> Replying to [@pjbruin](#comment%3A26):\n> > I redid a few tests after upgrading to Maxima 5.33.0 (#13973), and nothing really changed, except the change from `.123...` to `0.123...` is also done (upstream, differently than in [by this upgrade.  May I propose that we just apply the changes from [attachment:special_functions_precision.patch](https://github.com/sagemath/sage/files/ticket15921/fbbcd2f77a7c01438beda92e2ee58e85.patch](https://github.com/sagemath/sage/files/ticket15921/03cc6fcd4b0a5cf8aee3874f721a6664.patch))) to solve the precision problems in this ticket?\n\n> \n> I wonder about the `# For ARM: rel tol 2e-15` tag.\n> How does it work? Or is this just a comment? \n\nThe `rel tol 2e-15` is a magic marker telling the doctest framework not to complain about numerical errors smaller than this tolerance; see [Special markup to influence tests](http://sagemath.org/doc/developer/coding_basics.html#special-markup-to-influence-tests).  The comment \"for ARM\" is just a comment to clarify that the error can be this large on ARM.  Normally the relative error in basic functions like the gamma function should be roughly bounded by 2e-16 (since this is approximately 2<sup>-52</sup> and doubles have 53 bits of precision) and hence be invisible when printing with 16 decimal digits of precision.\n\n> > \n> > I'm happy with the other changes you made, even though they don't really seem to be related to ARM, Maxima or precision.  Two trivial remarks:\n> > - The message `Doctesting files changed since the last git commit` doesn't seem to have a full stop at the end when I run `sage -t --new`.\n> > - Does the `show_default()` doctest in `graphics.py` really take a long time?\n\n> \n> I did timings of tests on ARM and added `#long time` to these above certain thresholds.\n\nI wonder why it takes so long on ARM; when testing `show_default()` on an x86_64 it only seems to take 316 microseconds for the first time (`%timeit -n 1 -r 1 show_default()`) and an average of 11.4 microseconds when running it many times.\n> It's not 100% clear what changes you propose. Can you do a reviewer's git branch (or a patch)?\n\nOK, coming soon.",
    "created_at": "2014-05-19T16:34:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204336",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:28'>**Comment 28:**</a>
Replying to [@dimpase](#comment%3A27):
> Replying to [@pjbruin](#comment%3A26):
> > I redid a few tests after upgrading to Maxima 5.33.0 (#13973), and nothing really changed, except the change from `.123...` to `0.123...` is also done (upstream, differently than in [by this upgrade.  May I propose that we just apply the changes from [attachment:special_functions_precision.patch](https://github.com/sagemath/sage/files/ticket15921/fbbcd2f77a7c01438beda92e2ee58e85.patch](https://github.com/sagemath/sage/files/ticket15921/03cc6fcd4b0a5cf8aee3874f721a6664.patch))) to solve the precision problems in this ticket?

> 
> I wonder about the `# For ARM: rel tol 2e-15` tag.
> How does it work? Or is this just a comment? 

The `rel tol 2e-15` is a magic marker telling the doctest framework not to complain about numerical errors smaller than this tolerance; see [Special markup to influence tests](http://sagemath.org/doc/developer/coding_basics.html#special-markup-to-influence-tests).  The comment "for ARM" is just a comment to clarify that the error can be this large on ARM.  Normally the relative error in basic functions like the gamma function should be roughly bounded by 2e-16 (since this is approximately 2<sup>-52</sup> and doubles have 53 bits of precision) and hence be invisible when printing with 16 decimal digits of precision.

> > 
> > I'm happy with the other changes you made, even though they don't really seem to be related to ARM, Maxima or precision.  Two trivial remarks:
> > - The message `Doctesting files changed since the last git commit` doesn't seem to have a full stop at the end when I run `sage -t --new`.
> > - Does the `show_default()` doctest in `graphics.py` really take a long time?

> 
> I did timings of tests on ARM and added `#long time` to these above certain thresholds.

I wonder why it takes so long on ARM; when testing `show_default()` on an x86_64 it only seems to take 316 microseconds for the first time (`%timeit -n 1 -r 1 show_default()`) and an average of 11.4 microseconds when running it many times.
> It's not 100% clear what changes you propose. Can you do a reviewer's git branch (or a patch)?

OK, coming soon.



---

archive/issue_comments_204337.json:
```json
{
    "body": "**Changing commit** from \"[079bb9af4f12892268a19f0d218ac96bd72466f4](https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4)\" to \"[b8fea1cb11554aff202cd669342136d5a4ea084c](https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c)\".",
    "created_at": "2014-05-20T15:19:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204337",
    "user": "https://github.com/pjbruin"
}
```

**Changing commit** from "[079bb9af4f12892268a19f0d218ac96bd72466f4](https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4)" to "[b8fea1cb11554aff202cd669342136d5a4ea084c](https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c)".



---

archive/issue_comments_204338.json:
```json
{
    "body": "**Changing branch** from \"[u/dimpase/arm_fixes_etc](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/arm_fixes_etc)\" to \"[u/pbruin/15921-arm_fixes](https://github.com/sagemath/sagetrac-mirror/tree/u/pbruin/15921-arm_fixes)\".",
    "created_at": "2014-05-20T15:19:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204338",
    "user": "https://github.com/pjbruin"
}
```

**Changing branch** from "[u/dimpase/arm_fixes_etc](https://github.com/sagemath/sagetrac-mirror/tree/u/dimpase/arm_fixes_etc)" to "[u/pbruin/15921-arm_fixes](https://github.com/sagemath/sagetrac-mirror/tree/u/pbruin/15921-arm_fixes)".



---

archive/issue_comments_204339.json:
```json
{
    "body": "<a id='comment:29'>**Comment 29:**</a>\nHere is a reviewer branch, let me know if you think this is a good approach.\n\nI am actually not too happy with making these error tolerances too large in the case of the gamma function; I would say this is such an elementary function that it should really be correct up to the last one or two bit.  Hence it would also be reasonable to decide that these are really bugs in whichever library this is implemented in on ARM, and hence should keep giving doctest failures on ARM.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a7b7bf231d79a18fb10fe9757b1f2d81f5d0b850\">a7b7bf2</a></td><td><code>Numerical noise patches for ARM. As well, added # long time to many</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4\">079bb9a</a></td><td><code>replacing HG with git in examples</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c\">b8fea1c</a></td><td><code>Trac 15921: fix some special function values and precision</code></td></tr></table>\n",
    "created_at": "2014-05-20T15:19:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204339",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:29'>**Comment 29:**</a>
Here is a reviewer branch, let me know if you think this is a good approach.

I am actually not too happy with making these error tolerances too large in the case of the gamma function; I would say this is such an elementary function that it should really be correct up to the last one or two bit.  Hence it would also be reasonable to decide that these are really bugs in whichever library this is implemented in on ARM, and hence should keep giving doctest failures on ARM.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a7b7bf231d79a18fb10fe9757b1f2d81f5d0b850">a7b7bf2</a></td><td><code>Numerical noise patches for ARM. As well, added # long time to many</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4">079bb9a</a></td><td><code>replacing HG with git in examples</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c">b8fea1c</a></td><td><code>Trac 15921: fix some special function values and precision</code></td></tr></table>




---

archive/issue_comments_204340.json:
```json
{
    "body": "<a id='comment:30'>**Comment 30:**</a>\nReplying to [@pjbruin](#comment%3A29):\n> Here is a reviewer branch, let me know if you think this is a good approach.\n> \n> I am actually not too happy with making these error tolerances too large in the case of the gamma function; I would say this is such an elementary function that it should really be correct up to the last one or two bit.  Hence it would also be reasonable to decide that these are really bugs in whichever library this is implemented in on ARM, and hence should keep giving doctest failures on ARM.\n\nThe problem is that then it is hard to run patchbots on an ARM system, as they will always return failures...\n\n> ---\n> **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a7b7bf231d79a18fb10fe9757b1f2d81f5d0b850\">a7b7bf2</a></td><td><code>Numerical noise patches for ARM. As well, added # long time to many</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4\">079bb9a</a></td><td><code>replacing HG with git in examples</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c\">b8fea1c</a></td><td><code>Trac 15921: fix some special function values and precision</code></td></tr></table>\n",
    "created_at": "2014-05-20T15:37:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204340",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:30'>**Comment 30:**</a>
Replying to [@pjbruin](#comment%3A29):
> Here is a reviewer branch, let me know if you think this is a good approach.
> 
> I am actually not too happy with making these error tolerances too large in the case of the gamma function; I would say this is such an elementary function that it should really be correct up to the last one or two bit.  Hence it would also be reasonable to decide that these are really bugs in whichever library this is implemented in on ARM, and hence should keep giving doctest failures on ARM.

The problem is that then it is hard to run patchbots on an ARM system, as they will always return failures...

> ---
> **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a7b7bf231d79a18fb10fe9757b1f2d81f5d0b850">a7b7bf2</a></td><td><code>Numerical noise patches for ARM. As well, added # long time to many</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/079bb9af4f12892268a19f0d218ac96bd72466f4">079bb9a</a></td><td><code>replacing HG with git in examples</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c">b8fea1c</a></td><td><code>Trac 15921: fix some special function values and precision</code></td></tr></table>




---

archive/issue_comments_204341.json:
```json
{
    "body": "<a id='comment:31'>**Comment 31:**</a>\nReplying to [@dimpase](#comment%3A30):\n> Replying to [@pjbruin](#comment%3A29):\n> > I am actually not too happy with making these error tolerances too large in the case of the gamma function; I would say this is such an elementary function that it should really be correct up to the last one or two bit.  Hence it would also be reasonable to decide that these are really bugs in whichever library this is implemented in on ARM, and hence should keep giving doctest failures on ARM.\n\n> \n> The problem is that then it is hard to run patchbots on an ARM system, as they will always return failures...\n\nIf I understand correctly (from your comments on this tickets and [here](https://bugs.launchpad.net/ubuntu/+source/eglibc/+bug/713985)) the failure arises because of a bad eglibc implementation of `lgamma` (log gamma), so it should really be fixed upstream.\n\nNow I just noticed on [http://www.eglibc.org/](http://www.eglibc.org/) that eglibc is no longer maintained.  Is it recommended to use the normal glibc on ARM nowadays, and does the bug also exist there?",
    "created_at": "2014-05-20T16:09:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204341",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:31'>**Comment 31:**</a>
Replying to [@dimpase](#comment%3A30):
> Replying to [@pjbruin](#comment%3A29):
> > I am actually not too happy with making these error tolerances too large in the case of the gamma function; I would say this is such an elementary function that it should really be correct up to the last one or two bit.  Hence it would also be reasonable to decide that these are really bugs in whichever library this is implemented in on ARM, and hence should keep giving doctest failures on ARM.

> 
> The problem is that then it is hard to run patchbots on an ARM system, as they will always return failures...

If I understand correctly (from your comments on this tickets and [here](https://bugs.launchpad.net/ubuntu/+source/eglibc/+bug/713985)) the failure arises because of a bad eglibc implementation of `lgamma` (log gamma), so it should really be fixed upstream.

Now I just noticed on [http://www.eglibc.org/](http://www.eglibc.org/) that eglibc is no longer maintained.  Is it recommended to use the normal glibc on ARM nowadays, and does the bug also exist there?



---

archive/issue_comments_204342.json:
```json
{
    "body": "<a id='comment:32'>**Comment 32:**</a>\nThe error is actually 2 ulp, so it is correct \"up to the last two bit\". \n\nEdit: referring to the `gamma(float(6))` example",
    "created_at": "2014-05-20T18:27:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204342",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:32'>**Comment 32:**</a>
The error is actually 2 ulp, so it is correct "up to the last two bit". 

Edit: referring to the `gamma(float(6))` example



---

archive/issue_comments_204343.json:
```json
{
    "body": "<a id='comment:33'>**Comment 33:**</a>\nAlso, Dima's arm box in Oxford uses Ubuntu EGLIBC 2.15-0ubuntu20.2",
    "created_at": "2014-05-20T18:35:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204343",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:33'>**Comment 33:**</a>
Also, Dima's arm box in Oxford uses Ubuntu EGLIBC 2.15-0ubuntu20.2



---

archive/issue_comments_204344.json:
```json
{
    "body": "<a id='comment:34'>**Comment 34:**</a>\nReplying to [@vbraun](#comment%3A33):\n> Also, Dima's arm box in Oxford uses Ubuntu EGLIBC 2.15-0ubuntu20.2\n\nI'm presently building glibc-2.19 on this arm box, to see if any good comes out of it.\n\nBy the way, even Ubuntu 14 still uses EGLIBC.",
    "created_at": "2014-05-20T18:39:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204344",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:34'>**Comment 34:**</a>
Replying to [@vbraun](#comment%3A33):
> Also, Dima's arm box in Oxford uses Ubuntu EGLIBC 2.15-0ubuntu20.2

I'm presently building glibc-2.19 on this arm box, to see if any good comes out of it.

By the way, even Ubuntu 14 still uses EGLIBC.



---

archive/issue_comments_204345.json:
```json
{
    "body": "<a id='comment:35'>**Comment 35:**</a>\n`glibc 2.19` provides a proper implementation of `tgamma` on ARM. With it I get `tgamma(6.0)=120.000000...`, while still `exp(lgamma(6.0))=119.99999999999997157829`, just as with `eglibc`.\n\nOn the ARM box `glibc 2.19` is installed in `/home/dimpase/sage`. I link with the static `/home/dimpase/sage/lib/libm.a`.\n\nthe sources are in `/home/dimpase/sage/glibc-2.19`.",
    "created_at": "2014-05-20T19:32:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204345",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:35'>**Comment 35:**</a>
`glibc 2.19` provides a proper implementation of `tgamma` on ARM. With it I get `tgamma(6.0)=120.000000...`, while still `exp(lgamma(6.0))=119.99999999999997157829`, just as with `eglibc`.

On the ARM box `glibc 2.19` is installed in `/home/dimpase/sage`. I link with the static `/home/dimpase/sage/lib/libm.a`.

the sources are in `/home/dimpase/sage/glibc-2.19`.



---

archive/issue_comments_204346.json:
```json
{
    "body": "<a id='comment:36'>**Comment 36:**</a>\nWhat is the upstream status for the Maxima fpprintprec bug? If there is a fix then we should just go with upstream instead of increasing our tolerances imho. Its not cool of maxima to print too many digits.\n\nAs for the eglibc issue, I'm in favor of increasing the tolerance there. At the end of the day that seems to be a valid implementation choice as for how to implement tgamma, and 2 ulp isn't the end of the world.",
    "created_at": "2014-05-21T12:58:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204346",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:36'>**Comment 36:**</a>
What is the upstream status for the Maxima fpprintprec bug? If there is a fix then we should just go with upstream instead of increasing our tolerances imho. Its not cool of maxima to print too many digits.

As for the eglibc issue, I'm in favor of increasing the tolerance there. At the end of the day that seems to be a valid implementation choice as for how to implement tgamma, and 2 ulp isn't the end of the world.



---

archive/issue_comments_204347.json:
```json
{
    "body": "<a id='comment:37'>**Comment 37:**</a>\nReplying to [@vbraun](#comment%3A36):\n> What is the upstream status for the Maxima fpprintprec bug? If there is a fix then we should just go with upstream instead of increasing our tolerances imho. Its not cool of maxima to print too many digits.\n\nI reminded Robert Dodier about it recently, and he was going to have a look this week. No further word from him yet.\n> \n> As for the eglibc issue, I'm in favor of increasing the tolerance there. At the end of the day that seems to be a valid implementation choice as for how to implement tgamma, and 2 ulp isn't the end of the world.",
    "created_at": "2014-05-21T13:40:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204347",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:37'>**Comment 37:**</a>
Replying to [@vbraun](#comment%3A36):
> What is the upstream status for the Maxima fpprintprec bug? If there is a fix then we should just go with upstream instead of increasing our tolerances imho. Its not cool of maxima to print too many digits.

I reminded Robert Dodier about it recently, and he was going to have a look this week. No further word from him yet.
> 
> As for the eglibc issue, I'm in favor of increasing the tolerance there. At the end of the day that seems to be a valid implementation choice as for how to implement tgamma, and 2 ulp isn't the end of the world.



---

archive/issue_comments_204348.json:
```json
{
    "body": "<a id='comment:38'>**Comment 38:**</a>\nReplying to [@vbraun](#comment%3A36):\n> What is the upstream status for the Maxima fpprintprec bug? If there is a fix then we should just go with upstream instead of increasing our tolerances imho. Its not cool of maxima to print too many digits.\n\nI don't think a change in upstream will help us.  Besides, I see printing too many digits as a feature in this case, since printing 17 decimal digits guarantees exact conversion of floats with 53 bits of precision.\n\nWhat explains the difference between ARM and x86_64 in the cases of interest for us is just floating point noise.  There are only two Maxima-related affected doctests.  The first one is\n\n```\nsage: from sage.functions.bessel import _Bessel\nsage: _Bessel(20,algorithm='maxima')(5.0)\n27.70330052128944e-12   # ARM\n27.703300521289436e-12  # x86_64\n```\nIn this case, the number of digits does differ, but the correct answer is 2.770330052128941687...e-11, so the last 1-2 digits are wrong in both cases.\n\nAnother issue here is that this example has two digits before the decimal point, instead of one.  This is apparently an ECL issue, since Maxima on GCL or SBCL only prints one digit before the point.\n\nThe second relevant doctest is\n\n```\nelliptic_e(0.5, 0.1)\n0.498011394498831  # ARM\n0.498011394498832  # x86_64\n```\nHere the number of digits is the same, and the correct answer is 0.49801139449883153311546...\n\nSo I think for these two doctests we should just specify a tolerance.\n\n> As for the eglibc issue, I'm in favor of increasing the tolerance there. At the end of the day that seems to be a valid implementation choice as for how to implement tgamma, and 2 ulp isn't the end of the world.\n\nFor the gamma(10) doctest the relative error is roughly 1.3e-15 (9 ulp).  OK, it isn't the end of the world, and it doesn't seem to increase for larger arguments, but one would expect the gamma function to have a smaller error (which is the case for other architectures, according to the glibc Info manual).",
    "created_at": "2014-05-21T14:20:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204348",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:38'>**Comment 38:**</a>
Replying to [@vbraun](#comment%3A36):
> What is the upstream status for the Maxima fpprintprec bug? If there is a fix then we should just go with upstream instead of increasing our tolerances imho. Its not cool of maxima to print too many digits.

I don't think a change in upstream will help us.  Besides, I see printing too many digits as a feature in this case, since printing 17 decimal digits guarantees exact conversion of floats with 53 bits of precision.

What explains the difference between ARM and x86_64 in the cases of interest for us is just floating point noise.  There are only two Maxima-related affected doctests.  The first one is

```
sage: from sage.functions.bessel import _Bessel
sage: _Bessel(20,algorithm='maxima')(5.0)
27.70330052128944e-12   # ARM
27.703300521289436e-12  # x86_64
```
In this case, the number of digits does differ, but the correct answer is 2.770330052128941687...e-11, so the last 1-2 digits are wrong in both cases.

Another issue here is that this example has two digits before the decimal point, instead of one.  This is apparently an ECL issue, since Maxima on GCL or SBCL only prints one digit before the point.

The second relevant doctest is

```
elliptic_e(0.5, 0.1)
0.498011394498831  # ARM
0.498011394498832  # x86_64
```
Here the number of digits is the same, and the correct answer is 0.49801139449883153311546...

So I think for these two doctests we should just specify a tolerance.

> As for the eglibc issue, I'm in favor of increasing the tolerance there. At the end of the day that seems to be a valid implementation choice as for how to implement tgamma, and 2 ulp isn't the end of the world.

For the gamma(10) doctest the relative error is roughly 1.3e-15 (9 ulp).  OK, it isn't the end of the world, and it doesn't seem to increase for larger arguments, but one would expect the gamma function to have a smaller error (which is the case for other architectures, according to the glibc Info manual).



---

archive/issue_comments_204349.json:
```json
{
    "body": "<a id='comment:39'>**Comment 39:**</a>\nReplying to [@pjbruin](#comment%3A38):\n> \n> What explains the difference between ARM and x86_64 in the cases of interest for us is just floating point noise. \n\nperhaps I should clarify the issue that is behind the gamma-function related things.\nOne can have the same C code for x86_64 and for ARM which will produce different FP results, if one uses the `long double` type.\nThe latter is 16 bytes on x86_64, but only 8 bytes on ARM. I'm 99% sure this is the problem behind the eglibc issue.",
    "created_at": "2014-05-21T14:30:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204349",
    "user": "https://github.com/dimpase"
}
```

<a id='comment:39'>**Comment 39:**</a>
Replying to [@pjbruin](#comment%3A38):
> 
> What explains the difference between ARM and x86_64 in the cases of interest for us is just floating point noise. 

perhaps I should clarify the issue that is behind the gamma-function related things.
One can have the same C code for x86_64 and for ARM which will produce different FP results, if one uses the `long double` type.
The latter is 16 bytes on x86_64, but only 8 bytes on ARM. I'm 99% sure this is the problem behind the eglibc issue.



---

archive/issue_events_193863.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-05-21T15:31:26Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "008080",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193863"
}
```



---

archive/issue_events_193864.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-05-21T15:31:26Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "008080",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193864"
}
```



---

archive/issue_comments_204350.json:
```json
{
    "body": "**Author:** Dmitrii Pasechnik",
    "created_at": "2014-05-21T15:31:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204350",
    "user": "https://github.com/vbraun"
}
```

**Author:** Dmitrii Pasechnik



---

archive/issue_comments_204351.json:
```json
{
    "body": "<a id='comment:40'>**Comment 40:**</a>\nAgree. In general we should probably err on the lenient side for RDF evaluation, its a speed vs. accuracy tradeoff.",
    "created_at": "2014-05-21T15:31:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204351",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:40'>**Comment 40:**</a>
Agree. In general we should probably err on the lenient side for RDF evaluation, its a speed vs. accuracy tradeoff.



---

archive/issue_comments_204352.json:
```json
{
    "body": "**Changing reviewer** from \"Peter Bruin\" to \"Peter Bruin, Volker Braun\".",
    "created_at": "2014-05-21T15:31:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204352",
    "user": "https://github.com/vbraun"
}
```

**Changing reviewer** from "Peter Bruin" to "Peter Bruin, Volker Braun".



---

archive/issue_events_193865.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-05-21T20:56:06Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "008080",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193865"
}
```



---

archive/issue_events_193866.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "9a4b0b83fa06a113c485f22f37af02c24ef35e90",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2014-05-21T20:56:06Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15921#event-193866"
}
```



---

archive/issue_comments_204353.json:
```json
{
    "body": "**Changing branch** from \"[u/pbruin/15921-arm_fixes](https://github.com/sagemath/sagetrac-mirror/tree/u/pbruin/15921-arm_fixes)\" to \"[b8fea1cb11554aff202cd669342136d5a4ea084c](https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c)\".",
    "created_at": "2014-05-21T20:56:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15921",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15921#issuecomment-204353",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[u/pbruin/15921-arm_fixes](https://github.com/sagemath/sagetrac-mirror/tree/u/pbruin/15921-arm_fixes)" to "[b8fea1cb11554aff202cd669342136d5a4ea084c](https://github.com/sagemath/sagetrac-mirror/commit/b8fea1cb11554aff202cd669342136d5a4ea084c)".
