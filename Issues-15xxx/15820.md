# Issue 15820: Implement sequences of bounded integers

archive/issues_015583.json:
```json
{
    "body": "#12630 has introduced tools to compute with quiver algebras and quiver representations. It is all Python code, paths being internally stored by lists of labelled edges of digraphs.\n\nThe aim of this ticket is to provide an efficient implementation of lists of bounded integers, with concatenation. This can be used to implement paths of a quiver more efficiently, but can also have different applications (say, elements of free groups, or other applications in sage-combinat).\n\n\n**CC:**  JStarx @jhpalmieri @williamstein stumpc5 @saliola @simon-king-jena gmoose05 @nthiery @avirmaux @nathanncohen @hivert\n\n**Keywords:** sequence bounded integer\n\n**Branch:** [4e9e1c51f6524bfa2d2c55d197b82a983dd01184](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)\n\n**Reviewer:** Jeroen Demeyer, Simon King\n\n**Author:** Simon King, Jeroen Demeyer\n\n**Dependencies:** #17195, #17196\n\nIssue created by migration from https://trac.sagemath.org/ticket/15820\n\n",
    "closed_at": "2014-12-12T12:29:50Z",
    "created_at": "2014-02-14T17:31:31Z",
    "labels": [
        "component: algebra",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Implement sequences of bounded integers",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15820",
    "user": "https://github.com/simon-king-jena"
}
```
#12630 has introduced tools to compute with quiver algebras and quiver representations. It is all Python code, paths being internally stored by lists of labelled edges of digraphs.

The aim of this ticket is to provide an efficient implementation of lists of bounded integers, with concatenation. This can be used to implement paths of a quiver more efficiently, but can also have different applications (say, elements of free groups, or other applications in sage-combinat).


**CC:**  JStarx @jhpalmieri @williamstein stumpc5 @saliola @simon-king-jena gmoose05 @nthiery @avirmaux @nathanncohen @hivert

**Keywords:** sequence bounded integer

**Branch:** [4e9e1c51f6524bfa2d2c55d197b82a983dd01184](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)

**Reviewer:** Jeroen Demeyer, Simon King

**Author:** Simon King, Jeroen Demeyer

**Dependencies:** #17195, #17196

Issue created by migration from https://trac.sagemath.org/ticket/15820





---

archive/issue_comments_203798.json:
```json
{
    "body": "<a id='comment:1'></a>\nThere are various possible more or less obvious data formats:\n\n1. Store a path as `char*` or `unsigned int*`, hence, as a list of integers, each integer corresponding to one edge of the quiver. `char*` would bound the total number of edges of the quiver to 256 (which might be too small), whereas `unsigned int*` might consume to much memory.\n2. Store a path as `char*`, each integer corresponding to an outgoing edge of a vertex. Hence, the total number of edges may be arbitrary, we only have a local bound of 128 on the number of outgoing edges---this hopefully is enough (it certainly is enough for me).\n3. As in 1., but the representation is compressed: If we have less than 128 edges, then one byte can represent a pair of edges, and a single 32- or 64-bit int could store even longer sequences of edges.\n4. As in 2., but the representation is compressed: If each vertex has less than 8 outgoing edges, then a byte can represent a pair and a single 32-bit word can represent a 10-tuple of edges (if I did not miscalculate).\n\nIn 2. and 4. (and probably in 1. and 3. as well) we should explicitly store the start and end point of the path. The length should probably be stored as well.\n\nIn my applications, the following operations on paths are needed to be fast: Concatenation, hash/comparison, testing whether a path p starts with a path q, and less important whether a path p contains a path q.\n\nConcatenation is particularly easy in 1. and 2. (just concatenation of lists, which is achieved by memcopy). It is a bit more difficult in 3. and 4., where the bytes of the second factor need to be shifted to get the compressed data seamless.\n\nHash and comparison are easy in all four formats, but of course best speed would be obtained in 4., simply since the amount of data that needs to be processed is smaller than in 1.-3.\n\nIn all four proposed data formats, it is easy to test whether path p starts with path q. Again, having the data stored in as little memory as possible will speed things up.\n\nIt is easy in 1. to test whether path p *contains* path q (as a subpath that is not necessarily an initial segment), whereas this becomes a bit more difficult in 2.-4.\n\nWhat format would you suggest? Perhaps it makes sense to have some initial implementations of all four, and then compare directly.",
    "created_at": "2014-02-14T17:49:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203798",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
There are various possible more or less obvious data formats:

1. Store a path as `char*` or `unsigned int*`, hence, as a list of integers, each integer corresponding to one edge of the quiver. `char*` would bound the total number of edges of the quiver to 256 (which might be too small), whereas `unsigned int*` might consume to much memory.
2. Store a path as `char*`, each integer corresponding to an outgoing edge of a vertex. Hence, the total number of edges may be arbitrary, we only have a local bound of 128 on the number of outgoing edges---this hopefully is enough (it certainly is enough for me).
3. As in 1., but the representation is compressed: If we have less than 128 edges, then one byte can represent a pair of edges, and a single 32- or 64-bit int could store even longer sequences of edges.
4. As in 2., but the representation is compressed: If each vertex has less than 8 outgoing edges, then a byte can represent a pair and a single 32-bit word can represent a 10-tuple of edges (if I did not miscalculate).

In 2. and 4. (and probably in 1. and 3. as well) we should explicitly store the start and end point of the path. The length should probably be stored as well.

In my applications, the following operations on paths are needed to be fast: Concatenation, hash/comparison, testing whether a path p starts with a path q, and less important whether a path p contains a path q.

Concatenation is particularly easy in 1. and 2. (just concatenation of lists, which is achieved by memcopy). It is a bit more difficult in 3. and 4., where the bytes of the second factor need to be shifted to get the compressed data seamless.

Hash and comparison are easy in all four formats, but of course best speed would be obtained in 4., simply since the amount of data that needs to be processed is smaller than in 1.-3.

In all four proposed data formats, it is easy to test whether path p starts with path q. Again, having the data stored in as little memory as possible will speed things up.

It is easy in 1. to test whether path p *contains* path q (as a subpath that is not necessarily an initial segment), whereas this becomes a bit more difficult in 2.-4.

What format would you suggest? Perhaps it makes sense to have some initial implementations of all four, and then compare directly.



---

archive/issue_comments_203799.json:
```json
{
    "body": "<a id='comment:2'></a>\nI'd say:\n- Some implementation without limitations (the one from the previous ticket I guess)\n- Whichever of 1-4 that covers your needs (256 edges for Gr\u00f6bner bases\n  calculations this should be already quite big, right?)\n- As much as possible of the code shared between all implementations to make it easy to add new ones if deemed useful.\n\nBut that's just my 2 cents ... I don't have specific experience!\n\nCheers,",
    "created_at": "2014-02-16T08:47:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203799",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:2'></a>
I'd say:
- Some implementation without limitations (the one from the previous ticket I guess)
- Whichever of 1-4 that covers your needs (256 edges for Gröbner bases
  calculations this should be already quite big, right?)
- As much as possible of the code shared between all implementations to make it easy to add new ones if deemed useful.

But that's just my 2 cents ... I don't have specific experience!

Cheers,



---

archive/issue_comments_203800.json:
```json
{
    "body": "<a id='comment:3'></a>\nHi Nicolas,\n\nReplying to [nthiery](#comment%3A2):\n> - Some implementation without limitations (the one from the previous ticket I guess)\n\n\nAn implementation which represents edges by `unsigned long long` can be considered \"unlimited\".\n\n> - Whichever of 1-4 that covers your needs (256 edges for Gr\u00f6bner bases\n>   calculations this should be already quite big, right?)\n\n\nYes, but I want a general code.\n\n> - As much as possible of the code shared between all implementations to make it easy to add new ones if deemed useful.\n\n\nActually, on the level of paths, the implementations come in pairs: The compressed representations differ from the non-compressed---at the end of the day, we just have different ways of representing sequences of integers. Only when it comes to interpreting a sequence of integers as a path in a quiver will we have further differences: Does \"[1,2]\" mean \"start with arrow 1 of the quiver and continue with arrow 2 of the quiver\", or does it mean \"travel along the outgoing arrow 1 of the vertex we are currently located at, and then continue with outgoing arrow 2 of the vertex we just arrived at\".\n\nCurrently, I prefer a compressed representation by `unsigned long long*`. Rationale:\n- This will work even for extremely large quivers---the only restriction is, that the number of edges can be represented as an `unsigned long long` (a larger quiver won't fit into computer's memory anyway).\n- For small quivers, even paths of length 10 will easily fit into a single `unsigned long long`. That's quite efficient, both memory- and speed-wise.\n\nA bit later I will post experimental code (not yet talking about quiver paths but about sequences of integers) giving some evidence on efficiency. And then we can still see how we interpret the integer sequences: Having a global or a local list of arrows?",
    "created_at": "2014-02-16T09:05:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203800",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Hi Nicolas,

Replying to [nthiery](#comment%3A2):
> - Some implementation without limitations (the one from the previous ticket I guess)


An implementation which represents edges by `unsigned long long` can be considered "unlimited".

> - Whichever of 1-4 that covers your needs (256 edges for Gröbner bases
>   calculations this should be already quite big, right?)


Yes, but I want a general code.

> - As much as possible of the code shared between all implementations to make it easy to add new ones if deemed useful.


Actually, on the level of paths, the implementations come in pairs: The compressed representations differ from the non-compressed---at the end of the day, we just have different ways of representing sequences of integers. Only when it comes to interpreting a sequence of integers as a path in a quiver will we have further differences: Does "[1,2]" mean "start with arrow 1 of the quiver and continue with arrow 2 of the quiver", or does it mean "travel along the outgoing arrow 1 of the vertex we are currently located at, and then continue with outgoing arrow 2 of the vertex we just arrived at".

Currently, I prefer a compressed representation by `unsigned long long*`. Rationale:
- This will work even for extremely large quivers---the only restriction is, that the number of edges can be represented as an `unsigned long long` (a larger quiver won't fit into computer's memory anyway).
- For small quivers, even paths of length 10 will easily fit into a single `unsigned long long`. That's quite efficient, both memory- and speed-wise.

A bit later I will post experimental code (not yet talking about quiver paths but about sequences of integers) giving some evidence on efficiency. And then we can still see how we interpret the integer sequences: Having a global or a local list of arrows?



---

archive/issue_comments_203801.json:
```json
{
    "body": "<a id='comment:4'></a>\nI have attached a toy (or proof-of-concept) implementation; see [attachment:path_test.pyx]. In a *real* implementation in\ncompressed representation, it would be the job of a `PathSemigroup` to find\nout how many edges fit into one word. And of course, in the toy implementation\nI am not trying to translate an integer sequence into the string\nrepresentation of an element of the path semigroup.\n\nWhat implementation would you suggest to use in \"reality\"? Is there another implementation of \"sequences of bounded integers\" that you would recommend? And would you enumerate the arrows of a quiver locally (i.e., only number the outgoing edges at each vertex) or globally? The former will result in better compression, but would make it more difficult to test for paths p,q whether there are paths r,s with `p==r*q*s`.\n\nNow for the timings, and sorry for the long post...\n\nHere, I am timing concatenation, hash, comparison, comparing initial\nsegments. In all examples, we use the following paths of various sizes.\n\n```\np5 = Path(ZZ, 5, range(5), 1, 1)\np25 = Path(ZZ, 25, range(25), 1, 1)\np50 = Path(ZZ, 50, range(50), 1, 1)\np100 = Path(ZZ, 100, range(100), 1, 1)\np1000 = Path(ZZ, 1000, range(1000), 1, 1)\nq5 = Path(ZZ, 5, range(1,6), 1, 1)\nq25 = Path(ZZ, 25, range(1,26), 1, 1)\nq50 = Path(ZZ, 50, range(1,51), 1, 1)\nq100 = Path(ZZ, 100, range(1,101), 1, 1)\nq1000 = Path(ZZ, 1000, range(1,1001), 1, 1)\nr5 = Path(ZZ, 5, range(1,5)+[0], 1, 1)\nr25 = Path(ZZ, 25, range(1,25)+[0], 1, 1)\nr50 = Path(ZZ, 50, range(1,50)+[0], 1, 1)\nr100 = Path(ZZ, 100, range(1,100)+[0], 1, 1)\nr1000 = Path(ZZ, 1000, range(1,1000)+[0], 1, 1)\ns5 = Path(ZZ, 5, range(5), 1, 1)\ns25 = Path(ZZ, 25, range(25), 1, 1)\ns50 = Path(ZZ, 50, range(50), 1, 1)\ns100 = Path(ZZ, 100, range(100), 1, 1)\ns1000 = Path(ZZ, 1000, range(1000), 1, 1)\n```\n\nWe are doing the following tests.\n\nConcatenation:\n\n```\n%timeit p5*q5\n%timeit p5*q25\n%timeit p25*q25\n%timeit p25*q50\n%timeit p50*q50\n%timeit p50*q100\n%timeit p100*q100\n%timeit p100*q1000\n%timeit p1000*q1000\n```\n\nHash:\n\n```\n%timeit hash(p5)\n%timeit hash(p25)\n%timeit hash(p50)\n%timeit hash(p100)\n%timeit hash(p1000)\n```\n\nComparison:\n1. equal\n\n```\n%timeit p5==s5\n%timeit p25==s25\n%timeit p50==s50\n%timeit p100==s100\n%timeit p1000==s1000\n```\n2. obviously different (first item differs)\n\n```\n%timeit p5==r5\n%timeit p25==r25\n%timeit p50==r50\n%timeit p100==r100\n%timeit p1000==r1000\n```\n3. less obviously different (only the last item differs)\n\n```\n%timeit q5==r5\n%timeit q25==r25\n%timeit q50==r50\n%timeit q100==r100\n%timeit q1000==r1000\n```\n\nStartswith:\n\n```\n%timeit q1000.startswith(q100)  # it does start with\n%timeit q1000.startswith(r100)  # it doesn't start with\n```\n\n**__Uncompressed integer lists__**\n\nHere, we define `Path=Path_v1` (see [attachment:path_test.pyx]).\n\n__Using `ctypedef unsigned long block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 739 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 769 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 801 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 810 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 885 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 959 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 1.02 us per loop\nsage: %timeit p100*q1000\n100000 loops, best of 3: 1.99 us per loop\nsage: %timeit p1000*q1000\n100000 loops, best of 3: 3.06 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 135 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 166 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 214 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 333 ns per loop\nsage: %timeit hash(p1000)\n100000 loops, best of 3: 2.09 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 1.63 us per loop\nsage: %timeit p25==s25\n100000 loops, best of 3: 5.91 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 11 us per loop\nsage: %timeit p100==s100\n10000 loops, best of 3: 23 us per loop\nsage: %timeit p1000==s1000\n1000 loops, best of 3: 212 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 634 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 659 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 659 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 686 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 698 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 1.65 us per loop\nsage: %timeit q25==r25\n100000 loops, best of 3: 5.83 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 11.5 us per loop\nsage: %timeit q100==r100\n10000 loops, best of 3: 22 us per loop\nsage: %timeit q1000==r1000\n1000 loops, best of 3: 213 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 325 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 311 ns per loop\n```\n\n__Using `ctypedef unsigned short block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 700 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 738 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 820 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 769 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 808 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 877 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 909 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.49 us per loop\nsage: %timeit p1000*q1000\n100000 loops, best of 3: 2.13 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 138 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 179 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 236 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 383 ns per loop\nsage: %timeit hash(p1000)\n100000 loops, best of 3: 2.61 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 1.08 us per loop\nsage: %timeit p25==s25\n100000 loops, best of 3: 3.42 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 6.53 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 14.9 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 137 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 613 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 591 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 602 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 603 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 635 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 1.15 us per loop\nsage: %timeit q25==r25\n100000 loops, best of 3: 3.63 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 6.45 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 12.8 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 140 us per loop\nsage: q1000.startswith(q100)\nTrue\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 336 ns per loop\nsage: q1000.startswith(r100)\nFalse\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 325 ns per loop\n```\n\n__Using `ctypedef unsigned char block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 679 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 693 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 725 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 760 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 772 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 761 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 790 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.1 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.31 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 133 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 176 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 234 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 374 ns per loop\nsage: %timeit hash(p1000)\n100000 loops, best of 3: 2.53 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 1.08 us per loop\nsage: %timeit p25==s25\n100000 loops, best of 3: 3.36 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 6.3 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 12.5 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 121 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 581 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 589 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 599 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 599 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 636 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 1.06 us per loop\nsage: %timeit q25==r25\n100000 loops, best of 3: 3.46 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 6.51 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 12.7 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 121 us per loop\nsage: q1000.startswith(q100)\nTrue\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 324 ns per loop\nsage: %timeit q1000.startswith(r100) \n1000000 loops, best of 3: 315 ns per loop\n```\n\n**__Compressed integer lists__**\n\nHere, we define `Path=Path_v2` (see [attachment:path_test.pyx]), and do\n\n```\nsage: SizeManager.set_edge_number(27)\n```\nso that there is a total of only 27 edges (resp. 27 is the maximal number of\noutgoing arrows on a vertex). In particular, all integers in the sequences\nbelow are taken \"mod 27\". Since 27 has length 5 bits, a compressed\nrepresentation using `unsigned char*` won't make sense. Hence, I am only\ntesting long and short.\n\n__Using `ctypedef unsigned long block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 676 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 671 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 683 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 725 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 759 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 787 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 811 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.44 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.61 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 132 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 134 ns per loop\nsage: %timeit hash(p50)\n10000000 loops, best of 3: 142 ns per loop\nsage: %timeit hash(p100)\n10000000 loops, best of 3: 155 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 466 ns per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 710 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 1.71 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 2.6 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 4.4 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 38 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 692 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 715 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 724 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 729 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 752 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 706 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 1.69 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 2.59 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 4.4 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 37.6 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 272 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 257 ns per loop\n```\n\n__Using `ctypedef unsigned short block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 718 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 682 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 710 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 740 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 722 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 781 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 858 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.98 us per loop\nsage: %timeit p1000*q1000\n100000 loops, best of 3: 2.17 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 132 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 148 ns per loop\nsage: %timeit hash(p50)\n10000000 loops, best of 3: 168 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 206 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 951 ns per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 723 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 1.77 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 2.93 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 5.32 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 47.5 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 577 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 586 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 599 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 588 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 607 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 754 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 1.87 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 2.89 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 5.28 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 47.3 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 272 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 256 ns per loop\n```",
    "created_at": "2014-02-16T11:05:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203801",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
I have attached a toy (or proof-of-concept) implementation; see [attachment:path_test.pyx]. In a *real* implementation in
compressed representation, it would be the job of a `PathSemigroup` to find
out how many edges fit into one word. And of course, in the toy implementation
I am not trying to translate an integer sequence into the string
representation of an element of the path semigroup.

What implementation would you suggest to use in "reality"? Is there another implementation of "sequences of bounded integers" that you would recommend? And would you enumerate the arrows of a quiver locally (i.e., only number the outgoing edges at each vertex) or globally? The former will result in better compression, but would make it more difficult to test for paths p,q whether there are paths r,s with `p==r*q*s`.

Now for the timings, and sorry for the long post...

Here, I am timing concatenation, hash, comparison, comparing initial
segments. In all examples, we use the following paths of various sizes.

```
p5 = Path(ZZ, 5, range(5), 1, 1)
p25 = Path(ZZ, 25, range(25), 1, 1)
p50 = Path(ZZ, 50, range(50), 1, 1)
p100 = Path(ZZ, 100, range(100), 1, 1)
p1000 = Path(ZZ, 1000, range(1000), 1, 1)
q5 = Path(ZZ, 5, range(1,6), 1, 1)
q25 = Path(ZZ, 25, range(1,26), 1, 1)
q50 = Path(ZZ, 50, range(1,51), 1, 1)
q100 = Path(ZZ, 100, range(1,101), 1, 1)
q1000 = Path(ZZ, 1000, range(1,1001), 1, 1)
r5 = Path(ZZ, 5, range(1,5)+[0], 1, 1)
r25 = Path(ZZ, 25, range(1,25)+[0], 1, 1)
r50 = Path(ZZ, 50, range(1,50)+[0], 1, 1)
r100 = Path(ZZ, 100, range(1,100)+[0], 1, 1)
r1000 = Path(ZZ, 1000, range(1,1000)+[0], 1, 1)
s5 = Path(ZZ, 5, range(5), 1, 1)
s25 = Path(ZZ, 25, range(25), 1, 1)
s50 = Path(ZZ, 50, range(50), 1, 1)
s100 = Path(ZZ, 100, range(100), 1, 1)
s1000 = Path(ZZ, 1000, range(1000), 1, 1)
```

We are doing the following tests.

Concatenation:

```
%timeit p5*q5
%timeit p5*q25
%timeit p25*q25
%timeit p25*q50
%timeit p50*q50
%timeit p50*q100
%timeit p100*q100
%timeit p100*q1000
%timeit p1000*q1000
```

Hash:

```
%timeit hash(p5)
%timeit hash(p25)
%timeit hash(p50)
%timeit hash(p100)
%timeit hash(p1000)
```

Comparison:
1. equal

```
%timeit p5==s5
%timeit p25==s25
%timeit p50==s50
%timeit p100==s100
%timeit p1000==s1000
```
2. obviously different (first item differs)

```
%timeit p5==r5
%timeit p25==r25
%timeit p50==r50
%timeit p100==r100
%timeit p1000==r1000
```
3. less obviously different (only the last item differs)

```
%timeit q5==r5
%timeit q25==r25
%timeit q50==r50
%timeit q100==r100
%timeit q1000==r1000
```

Startswith:

```
%timeit q1000.startswith(q100)  # it does start with
%timeit q1000.startswith(r100)  # it doesn't start with
```

**__Uncompressed integer lists__**

Here, we define `Path=Path_v1` (see [attachment:path_test.pyx]).

__Using `ctypedef unsigned long block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 739 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 769 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 801 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 810 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 885 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 959 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 1.02 us per loop
sage: %timeit p100*q1000
100000 loops, best of 3: 1.99 us per loop
sage: %timeit p1000*q1000
100000 loops, best of 3: 3.06 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 135 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 166 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 214 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 333 ns per loop
sage: %timeit hash(p1000)
100000 loops, best of 3: 2.09 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 1.63 us per loop
sage: %timeit p25==s25
100000 loops, best of 3: 5.91 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 11 us per loop
sage: %timeit p100==s100
10000 loops, best of 3: 23 us per loop
sage: %timeit p1000==s1000
1000 loops, best of 3: 212 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 634 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 659 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 659 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 686 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 698 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 1.65 us per loop
sage: %timeit q25==r25
100000 loops, best of 3: 5.83 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 11.5 us per loop
sage: %timeit q100==r100
10000 loops, best of 3: 22 us per loop
sage: %timeit q1000==r1000
1000 loops, best of 3: 213 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 325 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 311 ns per loop
```

__Using `ctypedef unsigned short block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 700 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 738 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 820 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 769 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 808 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 877 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 909 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.49 us per loop
sage: %timeit p1000*q1000
100000 loops, best of 3: 2.13 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 138 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 179 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 236 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 383 ns per loop
sage: %timeit hash(p1000)
100000 loops, best of 3: 2.61 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 1.08 us per loop
sage: %timeit p25==s25
100000 loops, best of 3: 3.42 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 6.53 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 14.9 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 137 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 613 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 591 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 602 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 603 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 635 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 1.15 us per loop
sage: %timeit q25==r25
100000 loops, best of 3: 3.63 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 6.45 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 12.8 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 140 us per loop
sage: q1000.startswith(q100)
True
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 336 ns per loop
sage: q1000.startswith(r100)
False
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 325 ns per loop
```

__Using `ctypedef unsigned char block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 679 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 693 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 725 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 760 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 772 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 761 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 790 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.1 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.31 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 133 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 176 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 234 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 374 ns per loop
sage: %timeit hash(p1000)
100000 loops, best of 3: 2.53 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 1.08 us per loop
sage: %timeit p25==s25
100000 loops, best of 3: 3.36 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 6.3 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 12.5 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 121 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 581 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 589 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 599 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 599 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 636 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 1.06 us per loop
sage: %timeit q25==r25
100000 loops, best of 3: 3.46 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 6.51 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 12.7 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 121 us per loop
sage: q1000.startswith(q100)
True
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 324 ns per loop
sage: %timeit q1000.startswith(r100) 
1000000 loops, best of 3: 315 ns per loop
```

**__Compressed integer lists__**

Here, we define `Path=Path_v2` (see [attachment:path_test.pyx]), and do

```
sage: SizeManager.set_edge_number(27)
```
so that there is a total of only 27 edges (resp. 27 is the maximal number of
outgoing arrows on a vertex). In particular, all integers in the sequences
below are taken "mod 27". Since 27 has length 5 bits, a compressed
representation using `unsigned char*` won't make sense. Hence, I am only
testing long and short.

__Using `ctypedef unsigned long block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 676 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 671 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 683 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 725 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 759 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 787 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 811 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.44 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.61 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 132 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 134 ns per loop
sage: %timeit hash(p50)
10000000 loops, best of 3: 142 ns per loop
sage: %timeit hash(p100)
10000000 loops, best of 3: 155 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 466 ns per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 710 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 1.71 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 2.6 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 4.4 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 38 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 692 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 715 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 724 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 729 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 752 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 706 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 1.69 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 2.59 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 4.4 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 37.6 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 272 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 257 ns per loop
```

__Using `ctypedef unsigned short block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 718 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 682 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 710 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 740 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 722 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 781 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 858 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.98 us per loop
sage: %timeit p1000*q1000
100000 loops, best of 3: 2.17 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 132 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 148 ns per loop
sage: %timeit hash(p50)
10000000 loops, best of 3: 168 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 206 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 951 ns per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 723 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 1.77 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 2.93 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 5.32 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 47.5 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 577 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 586 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 599 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 588 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 607 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 754 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 1.87 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 2.89 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 5.28 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 47.3 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 272 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 256 ns per loop
```



---

archive/issue_comments_203802.json:
```json
{
    "body": "<a id='comment:5'></a>\nIt turns out that there are bugs in the toy code. But that's no surprise...",
    "created_at": "2014-02-16T13:24:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203802",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
It turns out that there are bugs in the toy code. But that's no surprise...



---

archive/issue_comments_203803.json:
```json
{
    "body": "<a id='comment:6'></a>\nI have fixed the problems in [attachment:path_test.pyx].\n\nIt was:\n1. bitshift by a wrong offset, and\n2. the bits that aren't used (e.g., the last 4 bits of an uint64_t when storing 12 arrows of size 5 bits) should be kept blank.\n\nThe latter involves an additional bitwise \"and\". So, probably the timings will slightly deteriorate.",
    "created_at": "2014-02-16T19:32:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203803",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
I have fixed the problems in [attachment:path_test.pyx].

It was:
1. bitshift by a wrong offset, and
2. the bits that aren't used (e.g., the last 4 bits of an uint64_t when storing 12 arrows of size 5 bits) should be kept blank.

The latter involves an additional bitwise "and". So, probably the timings will slightly deteriorate.



---

archive/issue_comments_203804.json:
```json
{
    "body": "<a id='comment:7'></a>\nThere is one other variation that I want to test.\n\nCurrently, if the number of edges fits into 5 bits, then a 64 bit word is filled with data of 12 edges, plus 4 bits of garbage. The garbage must always be zero bits, for otherwise the shift operations would pollute real data with the garbage bits. To keep the garbage zero involves additional operations.\n\nAlternatively, one could try to put fewer arrows into one word, so that there are *no* garbage bits. This could be done by encoding each arrow by a number of bits that is a power of 2. Hence, in the setting above, one would encode each edge by 8 rather than 5 bits, fitting 8 arrows into one 64 bit word. It is less dense, however the code gets simpler and should have less overhead.",
    "created_at": "2014-02-16T20:24:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203804",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
There is one other variation that I want to test.

Currently, if the number of edges fits into 5 bits, then a 64 bit word is filled with data of 12 edges, plus 4 bits of garbage. The garbage must always be zero bits, for otherwise the shift operations would pollute real data with the garbage bits. To keep the garbage zero involves additional operations.

Alternatively, one could try to put fewer arrows into one word, so that there are *no* garbage bits. This could be done by encoding each arrow by a number of bits that is a power of 2. Hence, in the setting above, one would encode each edge by 8 rather than 5 bits, fitting 8 arrows into one 64 bit word. It is less dense, however the code gets simpler and should have less overhead.



---

archive/issue_comments_203805.json:
```json
{
    "body": "<a id='comment:8'></a>\nI have replaced [attachment:path_test.pyx] again, adding two more implementations.\n\nDo you have further suggestions on storage of lists of bounded integers? If you haven't, then I'll try to assess the timings stated in the various comments, according to what I expect to be useful in my applications.\n\nHere are details on the two new implementations:\n\nIn `Path_v3`, I use Sage's `Integer` class as bit list. Sounds crazy, but it works rather well. I assume that bitshifts and comparison (and that's what we are using here) are internally written in assembler, and for us, the additional benefit is that we do not need to take care about the size of blocks (8 bit? 32 bit? 64 bit? 128 bit?) in which we store stuff---`Integer` does it for us. Perhaps the timings could be improved further by using the underlying c-library (GMP's `mpz_t`) directly.\n\nIn `Path_v4`, I provide a slightly simplified version of `Path_v2`: The data is compressed, but so that the chunks used to store one arrow fit seamlessly into a memory block. Hence, when we use 64-bit blocks, and have 27 arrows, then `Path_v2` would store the arrows in chunks of 5 bit (hence, it can store 12 arrows in one memory block, leaving 4 bit empty), whereas `Path_v4` would store the arrows in chunks of 8 bit (hence, it can only store 8 arrows in one memory block, but since this fits neatly into one memory block, the code can be simplified).\n\nThe timings for `Path_v3`:\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 645 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 631 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 635 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 1.23 us per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 1.82 us per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 1.83 us per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 1.37 us per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.82 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.78 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 164 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 197 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 210 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 274 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 1.94 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 667 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 638 ns per loop\nsage: %timeit p50==s50\n1000000 loops, best of 3: 693 ns per loop\nsage: %timeit p100==s100\n1000000 loops, best of 3: 658 ns per loop\nsage: %timeit p1000==s1000\n1000000 loops, best of 3: 817 ns per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 746 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 723 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 769 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 731 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 733 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 710 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 733 ns per loop\nsage: %timeit q50==r50\n1000000 loops, best of 3: 718 ns per loop\nsage: %timeit q100==r100\n1000000 loops, best of 3: 719 ns per loop\nsage: %timeit q1000==r1000\n1000000 loops, best of 3: 755 ns per loop\nsage: %timeit q1000.startswith(q100)\n100000 loops, best of 3: 2.46 us per loop\nsage: %timeit q1000.startswith(r100)\n100000 loops, best of 3: 2.45 us per loop\n```\n\nThe timings for `Path_v4`:\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 730 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 762 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 806 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 849 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 854 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 931 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 930 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.97 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.45 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 136 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 148 ns per loop\nsage: %timeit hash(p50)\n10000000 loops, best of 3: 159 ns per loop\nsage: %timeit hash(p100)\n10000000 loops, best of 3: 182 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 600 ns per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 700 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 1.65 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 2.48 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 4.21 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 36.4 us per loop\nsage: %timeit p5==r5\n100000 loops, best of 3: 706 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 764 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 740 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 742 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 822 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 693 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 1.6 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 2.54 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 4.27 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 37.1 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 255 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 243 ns per loop\n```",
    "created_at": "2014-02-18T12:21:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203805",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
I have replaced [attachment:path_test.pyx] again, adding two more implementations.

Do you have further suggestions on storage of lists of bounded integers? If you haven't, then I'll try to assess the timings stated in the various comments, according to what I expect to be useful in my applications.

Here are details on the two new implementations:

In `Path_v3`, I use Sage's `Integer` class as bit list. Sounds crazy, but it works rather well. I assume that bitshifts and comparison (and that's what we are using here) are internally written in assembler, and for us, the additional benefit is that we do not need to take care about the size of blocks (8 bit? 32 bit? 64 bit? 128 bit?) in which we store stuff---`Integer` does it for us. Perhaps the timings could be improved further by using the underlying c-library (GMP's `mpz_t`) directly.

In `Path_v4`, I provide a slightly simplified version of `Path_v2`: The data is compressed, but so that the chunks used to store one arrow fit seamlessly into a memory block. Hence, when we use 64-bit blocks, and have 27 arrows, then `Path_v2` would store the arrows in chunks of 5 bit (hence, it can store 12 arrows in one memory block, leaving 4 bit empty), whereas `Path_v4` would store the arrows in chunks of 8 bit (hence, it can only store 8 arrows in one memory block, but since this fits neatly into one memory block, the code can be simplified).

The timings for `Path_v3`:

```
sage: %timeit p5*q5
1000000 loops, best of 3: 645 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 631 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 635 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 1.23 us per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 1.82 us per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 1.83 us per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 1.37 us per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.82 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.78 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 164 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 197 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 210 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 274 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 1.94 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 667 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 638 ns per loop
sage: %timeit p50==s50
1000000 loops, best of 3: 693 ns per loop
sage: %timeit p100==s100
1000000 loops, best of 3: 658 ns per loop
sage: %timeit p1000==s1000
1000000 loops, best of 3: 817 ns per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 746 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 723 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 769 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 731 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 733 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 710 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 733 ns per loop
sage: %timeit q50==r50
1000000 loops, best of 3: 718 ns per loop
sage: %timeit q100==r100
1000000 loops, best of 3: 719 ns per loop
sage: %timeit q1000==r1000
1000000 loops, best of 3: 755 ns per loop
sage: %timeit q1000.startswith(q100)
100000 loops, best of 3: 2.46 us per loop
sage: %timeit q1000.startswith(r100)
100000 loops, best of 3: 2.45 us per loop
```

The timings for `Path_v4`:

```
sage: %timeit p5*q5
1000000 loops, best of 3: 730 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 762 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 806 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 849 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 854 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 931 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 930 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.97 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.45 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 136 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 148 ns per loop
sage: %timeit hash(p50)
10000000 loops, best of 3: 159 ns per loop
sage: %timeit hash(p100)
10000000 loops, best of 3: 182 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 600 ns per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 700 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 1.65 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 2.48 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 4.21 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 36.4 us per loop
sage: %timeit p5==r5
100000 loops, best of 3: 706 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 764 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 740 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 742 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 822 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 693 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 1.6 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 2.54 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 4.27 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 37.1 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 255 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 243 ns per loop
```



---

archive/issue_comments_203806.json:
```json
{
    "body": "<a id='comment:9'></a>\nHmmm. Perhaps I should have a look at `sage/misc/bitset.pxi`.",
    "created_at": "2014-02-18T12:28:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203806",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Hmmm. Perhaps I should have a look at `sage/misc/bitset.pxi`.



---

archive/issue_comments_203807.json:
```json
{
    "body": "<a id='comment:10'></a>\nI couldn't directly use `sage/misc/bitset`, but I could learn from it: I have improved the `Path_v4` implementation (here, the arrows will be encoded by chunks of memory whose size is a power of 2). This was possible by using `memcmp` in some place (not in the method `startswith()`, where a loop over the data is faster than memcmp) and, in particular, use bitshift operations to replace multiplications and integer divisions (this is only possible with `Path_v4`, since here the factors are powers of 2 and can thus correspond to shifts).\n\nNew timings with `Path=Path_v4` and `SizeManager.set_edge_number(27)`:\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 684 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 726 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 798 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 862 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 827 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 924 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 915 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.91 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.42 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 148 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 158 ns per loop\nsage: %timeit hash(p50)\n10000000 loops, best of 3: 171 ns per loop\nsage: %timeit hash(p100)\n10000000 loops, best of 3: 194 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 594 ns per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 498 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 547 ns per loop\nsage: %timeit p50==s50\n1000000 loops, best of 3: 631 ns per loop\nsage: %timeit p100==s100\n1000000 loops, best of 3: 712 ns per loop\nsage: %timeit p1000==s1000\n100000 loops, best of 3: 2.42 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 499 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 514 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 549 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 526 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 545 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 506 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 544 ns per loop\nsage: %timeit q50==r50\n1000000 loops, best of 3: 589 ns per loop\nsage: %timeit q100==r100\n1000000 loops, best of 3: 704 ns per loop\nsage: %timeit q1000==r1000\n100000 loops, best of 3: 2.48 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 263 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 232 ns per loop\n```",
    "created_at": "2014-02-18T17:23:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203807",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:10'></a>
I couldn't directly use `sage/misc/bitset`, but I could learn from it: I have improved the `Path_v4` implementation (here, the arrows will be encoded by chunks of memory whose size is a power of 2). This was possible by using `memcmp` in some place (not in the method `startswith()`, where a loop over the data is faster than memcmp) and, in particular, use bitshift operations to replace multiplications and integer divisions (this is only possible with `Path_v4`, since here the factors are powers of 2 and can thus correspond to shifts).

New timings with `Path=Path_v4` and `SizeManager.set_edge_number(27)`:

```
sage: %timeit p5*q5
1000000 loops, best of 3: 684 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 726 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 798 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 862 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 827 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 924 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 915 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.91 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.42 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 148 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 158 ns per loop
sage: %timeit hash(p50)
10000000 loops, best of 3: 171 ns per loop
sage: %timeit hash(p100)
10000000 loops, best of 3: 194 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 594 ns per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 498 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 547 ns per loop
sage: %timeit p50==s50
1000000 loops, best of 3: 631 ns per loop
sage: %timeit p100==s100
1000000 loops, best of 3: 712 ns per loop
sage: %timeit p1000==s1000
100000 loops, best of 3: 2.42 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 499 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 514 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 549 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 526 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 545 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 506 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 544 ns per loop
sage: %timeit q50==r50
1000000 loops, best of 3: 589 ns per loop
sage: %timeit q100==r100
1000000 loops, best of 3: 704 ns per loop
sage: %timeit q1000==r1000
100000 loops, best of 3: 2.48 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 263 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 232 ns per loop
```



---

archive/issue_comments_203808.json:
```json
{
    "body": "<a id='comment:11'></a>\nPS: I chose 27 edges, since this should be particularly bad for `Path_v4`. Indeed, in `Path_v2`, 12 arrows can be put into one `uint64_t`, whereas in `Path_v4` only 8 arrows fit into one `uint64_t`. So, if `Path_v4` turns out to be faster than `Path_v2` with 27 edges, then it is likely to be *generally* faster, I think.",
    "created_at": "2014-02-18T17:27:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203808",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'></a>
PS: I chose 27 edges, since this should be particularly bad for `Path_v4`. Indeed, in `Path_v2`, 12 arrows can be put into one `uint64_t`, whereas in `Path_v4` only 8 arrows fit into one `uint64_t`. So, if `Path_v4` turns out to be faster than `Path_v2` with 27 edges, then it is likely to be *generally* faster, I think.



---

archive/issue_comments_203809.json:
```json
{
    "body": "<a id='comment:12'></a>\nFrom my side, this is the last part of the proof-of-concept implementations, before assessing the benchmark tests and choosing an implementation for the elements of path semigroups...\n\nIn `Path_v5`, I am using the GMP library directly, thus avoiding some overhead compared with `Path_v3`. The timings I get (with `Path=Path_v5` and `SizeManager.set_edge_number(27)`):\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 720 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 814 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 823 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 808 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 828 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 890 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 866 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.18 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.38 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 159 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 171 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 198 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 266 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 1.93 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 466 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 509 ns per loop\nsage: %timeit p50==s50\n1000000 loops, best of 3: 495 ns per loop\nsage: %timeit p100==s100\n1000000 loops, best of 3: 485 ns per loop\nsage: %timeit p1000==s1000\n1000000 loops, best of 3: 693 ns per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 451 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 468 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 463 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 468 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 482 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 448 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 462 ns per loop\nsage: %timeit q50==r50\n1000000 loops, best of 3: 448 ns per loop\nsage: %timeit q100==r100\n1000000 loops, best of 3: 457 ns per loop\nsage: %timeit q1000==r1000\n1000000 loops, best of 3: 470 ns per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 673 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 657 ns per loop\n```",
    "created_at": "2014-02-18T23:02:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203809",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:12'></a>
From my side, this is the last part of the proof-of-concept implementations, before assessing the benchmark tests and choosing an implementation for the elements of path semigroups...

In `Path_v5`, I am using the GMP library directly, thus avoiding some overhead compared with `Path_v3`. The timings I get (with `Path=Path_v5` and `SizeManager.set_edge_number(27)`):

```
sage: %timeit p5*q5
1000000 loops, best of 3: 720 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 814 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 823 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 808 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 828 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 890 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 866 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.18 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.38 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 159 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 171 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 198 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 266 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 1.93 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 466 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 509 ns per loop
sage: %timeit p50==s50
1000000 loops, best of 3: 495 ns per loop
sage: %timeit p100==s100
1000000 loops, best of 3: 485 ns per loop
sage: %timeit p1000==s1000
1000000 loops, best of 3: 693 ns per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 451 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 468 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 463 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 468 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 482 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 448 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 462 ns per loop
sage: %timeit q50==r50
1000000 loops, best of 3: 448 ns per loop
sage: %timeit q100==r100
1000000 loops, best of 3: 457 ns per loop
sage: %timeit q1000==r1000
1000000 loops, best of 3: 470 ns per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 673 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 657 ns per loop
```



---

archive/issue_comments_203810.json:
```json
{
    "body": "<a id='comment:13'></a>\nHmmmmmmm... Well, looks like the last one is the best, even though it is a bit slow for hashing. If the sizeof a block is a power of two it should be quite good, don't you think ?\n\nThis being said, perhaps  it should be implemented like the bitset stuff, in a algebraic-free file, to store sequences of integers as you said.\n\nHow do you define your hashing function and your comparison function, by the way ?\n\nNathann",
    "created_at": "2014-02-20T17:08:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203810",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:13'></a>
Hmmmmmmm... Well, looks like the last one is the best, even though it is a bit slow for hashing. If the sizeof a block is a power of two it should be quite good, don't you think ?

This being said, perhaps  it should be implemented like the bitset stuff, in a algebraic-free file, to store sequences of integers as you said.

How do you define your hashing function and your comparison function, by the way ?

Nathann



---

archive/issue_comments_203811.json:
```json
{
    "body": "<a id='comment:14'></a>\nReplying to [ncohen](#comment%3A13):\n> Hmmmmmmm... Well, looks like the last one is the best, even though it is a bit slow for hashing.\n\n\nWhat do you mean by \"the last one\"? Using GMP's `mpz_t`directly, which is `Path_v5` in the attachment? Or the improved \"semicompressed\" version of `uint64_t*` (storing chunks of size `2^n` rather then in the smallest possible chunk size), which is `Path_v4`?\n\n> If the sizeof a block is a power of two it should be quite good, don't you think ?\n\n\nShould be. My own summary of the timings above would be this. We have 6 benchmarks, and in the following list I am giving for each benchmark a small, a medium and a large example. In the end, `+` or `-` indicate whether the respective implementation did well/poorly in the three examples.\n\n1. Concatenation\n\n```\n                     5x5   50x50  1000x1000\nUncompressed long : 739 ns  885 ns 3.06 us  - -\nUncompressed short: 700 ns  808 ns 2.13 us\nUncompressed char : 679 ns  772 ns 1.31 us    +\nCompressed   long : 676 ns  759 ns 1.61 us\nCompressed   short: 718 ns  722 ns 1.98 us   +\nSemicompr.   long : 684 ns  827 ns 1.42 us\nInteger           : 645 ns 1.82 us 1.78 us  +-\nGMP          mpz_t: 723 ns  799 ns 1.41 us\n```\n\n2. Hash\n\n```\n                     5      100     1000\nUncompressed long : 135 ns 333 ns  2.09 us  +\nUncompressed short: 138 ns 383 ns  2.61 us  +--\nUncompressed char : 133 ns 374 ns  2.53 us  +\nCompressed   long : 132 ns 155 ns   466 ns  +++\nCompressed   short: 132 ns 206 ns   951 ns  +\nSemicompr.   long : 148 ns 194 ns   594 ns\nInteger           : 164 ns 274 ns  1.94 us  -\nGMP          mpz_t: 159 ns 266 ns  1.93 us\n```\n\n3. == for equal paths\n\n```\n                     5       100     1000\nUncompressed long : 1.63 us 23   us  212   us ---\nUncompressed short: 1.08 us 14.9 us  137   us\nUncompressed char : 1.08 us 12.5 us  121   us\nCompressed   long :  710 ns  4.4 us   38   us\nCompressed   short:  723 ns  5.3 us   47.5 us\nSemicompr.   long :  498 ns  712 ns    2.4 us\nInteger           :  667 ns  658 ns    817 ns\nGMP          mpz_t:  466 ns  485 ns    693 ns +++\n```\n\n4. == for \"easily\" unequal paths\n\n```\n                     5       100     1000\nUncompressed long : 634 ns   686 ns   698 ns\nUncompressed short: 613 ns   603 ns   635 ns\nUncompressed char : 581 ns   599 ns   636 ns\nCompressed   long : 692 ns   729 ns   752 ns  --\nCompressed   short: 577 ns   588 ns   607 ns\nSemicompr.   long : 499 ns   526 ns   545 ns\nInteger           : 746 ns   731 ns   733 ns --\nGMP          mpz_t: 451 ns   468 ns   482 ns +++\n```\n\n5. == for \"difficult\" unequal paths\n\n```\n                     5       100      1000\nUncompressed long : 1.65 us   22 us    213 us   ---\nUncompressed short: 1.15 us   12.8 us  140 us\nUncompressed char : 1.06 us   12.7 us  121 us\nCompressed   long :  706 ns    4.4 us   37.6 us\nCompressed   short:  754 ns    5.3 us   47.3 us\nSemicompr.   long :  506 ns    704 ns   2.5 us\nInteger           :  710 ns    719 ns   755 ns\nGMP          mpz_t:  448 ns    457 ns   470 ns  +++\n```\n\n6. startswith (here we only have one example size, one where the answer is True, and one where the answer is False)\n\n```\n                     yes      no\nUncompressed long :  325 ns  311 ns\nUncompressed short:  336 ns  325 ns\nUncompressed char :  324 ns  315 ns\nCompressed   long :  272 ns  257 ns  +\nCompressed   short:  272 ns  256 ns  +\nSemicompr.   long :  263 ns  232 ns  ++\nInteger           : 2.46 us 2.45 us  --\nGMP          mpz_t:  673 ns  657 ns\n```\n\nSo, I don't think there is a clear winner in the competition.\n\n> This being said, perhaps  it should be implemented like the bitset stuff, in a algebraic-free file, to store sequences of integers as you said.\n\n\nYes, it would make sense.\n\n> How do you define your hashing function and your comparison function, by the way ?\n\n\nDepends on the implementation. Of course, when I use `Integer` or `mpz_t`, I am using the hash function provided by GMP. When I implement a `block*`, where `block` is either `char`, `uint32_t` or `uint64_t`, I am using some hash function for lists that I found in the internet a while ago (I don't recall where). It is as follows:\n\n```python\n    def __hash__(self):\n        cdef block h\n        cdef block* ptr\n        h = <block>(self.start^(self.end<<16)^(self._len))\n        ptr = <block *>self.data\n        cdef size_t i\n        h ^= FNV_offset\n        for i from 0<=i<self._len:\n            h ^= ptr[i]\n            h *= FNV_prime\n        if h==-1:\n            return -2\n        return h\n```\nwhere `FNV_prime` and `FNV_offset` depend on the architecture. I am surprised that this is faster than GMP's hash function.",
    "created_at": "2014-02-21T12:12:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203811",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>
Replying to [ncohen](#comment%3A13):
> Hmmmmmmm... Well, looks like the last one is the best, even though it is a bit slow for hashing.


What do you mean by "the last one"? Using GMP's `mpz_t`directly, which is `Path_v5` in the attachment? Or the improved "semicompressed" version of `uint64_t*` (storing chunks of size `2^n` rather then in the smallest possible chunk size), which is `Path_v4`?

> If the sizeof a block is a power of two it should be quite good, don't you think ?


Should be. My own summary of the timings above would be this. We have 6 benchmarks, and in the following list I am giving for each benchmark a small, a medium and a large example. In the end, `+` or `-` indicate whether the respective implementation did well/poorly in the three examples.

1. Concatenation

```
                     5x5   50x50  1000x1000
Uncompressed long : 739 ns  885 ns 3.06 us  - -
Uncompressed short: 700 ns  808 ns 2.13 us
Uncompressed char : 679 ns  772 ns 1.31 us    +
Compressed   long : 676 ns  759 ns 1.61 us
Compressed   short: 718 ns  722 ns 1.98 us   +
Semicompr.   long : 684 ns  827 ns 1.42 us
Integer           : 645 ns 1.82 us 1.78 us  +-
GMP          mpz_t: 723 ns  799 ns 1.41 us
```

2. Hash

```
                     5      100     1000
Uncompressed long : 135 ns 333 ns  2.09 us  +
Uncompressed short: 138 ns 383 ns  2.61 us  +--
Uncompressed char : 133 ns 374 ns  2.53 us  +
Compressed   long : 132 ns 155 ns   466 ns  +++
Compressed   short: 132 ns 206 ns   951 ns  +
Semicompr.   long : 148 ns 194 ns   594 ns
Integer           : 164 ns 274 ns  1.94 us  -
GMP          mpz_t: 159 ns 266 ns  1.93 us
```

3. == for equal paths

```
                     5       100     1000
Uncompressed long : 1.63 us 23   us  212   us ---
Uncompressed short: 1.08 us 14.9 us  137   us
Uncompressed char : 1.08 us 12.5 us  121   us
Compressed   long :  710 ns  4.4 us   38   us
Compressed   short:  723 ns  5.3 us   47.5 us
Semicompr.   long :  498 ns  712 ns    2.4 us
Integer           :  667 ns  658 ns    817 ns
GMP          mpz_t:  466 ns  485 ns    693 ns +++
```

4. == for "easily" unequal paths

```
                     5       100     1000
Uncompressed long : 634 ns   686 ns   698 ns
Uncompressed short: 613 ns   603 ns   635 ns
Uncompressed char : 581 ns   599 ns   636 ns
Compressed   long : 692 ns   729 ns   752 ns  --
Compressed   short: 577 ns   588 ns   607 ns
Semicompr.   long : 499 ns   526 ns   545 ns
Integer           : 746 ns   731 ns   733 ns --
GMP          mpz_t: 451 ns   468 ns   482 ns +++
```

5. == for "difficult" unequal paths

```
                     5       100      1000
Uncompressed long : 1.65 us   22 us    213 us   ---
Uncompressed short: 1.15 us   12.8 us  140 us
Uncompressed char : 1.06 us   12.7 us  121 us
Compressed   long :  706 ns    4.4 us   37.6 us
Compressed   short:  754 ns    5.3 us   47.3 us
Semicompr.   long :  506 ns    704 ns   2.5 us
Integer           :  710 ns    719 ns   755 ns
GMP          mpz_t:  448 ns    457 ns   470 ns  +++
```

6. startswith (here we only have one example size, one where the answer is True, and one where the answer is False)

```
                     yes      no
Uncompressed long :  325 ns  311 ns
Uncompressed short:  336 ns  325 ns
Uncompressed char :  324 ns  315 ns
Compressed   long :  272 ns  257 ns  +
Compressed   short:  272 ns  256 ns  +
Semicompr.   long :  263 ns  232 ns  ++
Integer           : 2.46 us 2.45 us  --
GMP          mpz_t:  673 ns  657 ns
```

So, I don't think there is a clear winner in the competition.

> This being said, perhaps  it should be implemented like the bitset stuff, in a algebraic-free file, to store sequences of integers as you said.


Yes, it would make sense.

> How do you define your hashing function and your comparison function, by the way ?


Depends on the implementation. Of course, when I use `Integer` or `mpz_t`, I am using the hash function provided by GMP. When I implement a `block*`, where `block` is either `char`, `uint32_t` or `uint64_t`, I am using some hash function for lists that I found in the internet a while ago (I don't recall where). It is as follows:

```python
    def __hash__(self):
        cdef block h
        cdef block* ptr
        h = <block>(self.start^(self.end<<16)^(self._len))
        ptr = <block *>self.data
        cdef size_t i
        h ^= FNV_offset
        for i from 0<=i<self._len:
            h ^= ptr[i]
            h *= FNV_prime
        if h==-1:
            return -2
        return h
```
where `FNV_prime` and `FNV_offset` depend on the architecture. I am surprised that this is faster than GMP's hash function.



---

archive/issue_comments_203812.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n #12630 has introduced tools to compute with quiver algebras and quiver representations. It is all Python code, paths being internally stored by lists of labelled edges of digraphs.\n \n-The aim of this ticket is to provide a more efficient implementation of the (partial) semigroup that is formed by the paths of a quiver, multiplied by concatenation.\n+The aim of this ticket is to provide an efficient implementation of lists of bounded integers, with concatenation. This can be used to implement paths of a quiver more efficiently, but can also have different applications (say, elements of free groups, or other applications in sage-combinat).\n \n``````\n",
    "created_at": "2014-02-22T14:40:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203812",
    "user": "https://github.com/simon-king-jena"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
 #12630 has introduced tools to compute with quiver algebras and quiver representations. It is all Python code, paths being internally stored by lists of labelled edges of digraphs.
 
-The aim of this ticket is to provide a more efficient implementation of the (partial) semigroup that is formed by the paths of a quiver, multiplied by concatenation.
+The aim of this ticket is to provide an efficient implementation of lists of bounded integers, with concatenation. This can be used to implement paths of a quiver more efficiently, but can also have different applications (say, elements of free groups, or other applications in sage-combinat).
 
``````




---

archive/issue_events_143573.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-02-22T14:40:48Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "rename": {
        "from": "Improve efficiency of the path semigroup",
        "to": "Implement sequences of bounded integers"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143573"
}
```



---

archive/issue_comments_203813.json:
```json
{
    "body": "<a id='comment:16'></a>\nAs Nathann has mentioned, it would make sense to provide a general implementation of sequences of bounded integers (independent of quiver paths), and then quiver paths can inherit from it later. That's why I changed the ticket description.",
    "created_at": "2014-02-22T14:42:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203813",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:16'></a>
As Nathann has mentioned, it would make sense to provide a general implementation of sequences of bounded integers (independent of quiver paths), and then quiver paths can inherit from it later. That's why I changed the ticket description.



---

archive/issue_comments_203814.json:
```json
{
    "body": "**Changing keywords** from \"quiver path algebra efficiency\" to \"sequence bounded integer\".",
    "created_at": "2014-02-22T14:42:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203814",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing keywords** from "quiver path algebra efficiency" to "sequence bounded integer".



---

archive/issue_comments_203815.json:
```json
{
    "body": "**Changing dependencies** from \"#12630\" to \"\".",
    "created_at": "2014-02-24T13:21:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203815",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing dependencies** from "#12630" to "".



---

archive/attachments_020503.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "path_test.pyx",
    "asset_url": "tarball://root/attachments/some-uuid/ticket15820/path_test.pyx",
    "created_at": "2014-02-24T14:37:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "attachment",
    "url": "https://github.com/assets/some-id/some-uuid.pyx",
    "user": "https://github.com/simon-king-jena"
}
```



---

archive/issue_comments_203816.json:
```json
{
    "body": "A proof of concept",
    "created_at": "2014-02-24T14:37:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203816",
    "user": "https://github.com/simon-king-jena"
}
```

A proof of concept



---

archive/issue_comments_203817.json:
```json
{
    "body": "<a id='comment:18'></a>\nFor completeness, I have added `Path_v6`, which uses Python's `tuple` under the hood (which is an obvious way to implement paths, too).\n\nResult:\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 439 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 542 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 612 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 869 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 1.1 us per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 1.39 us per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 1.41 us per loop\nsage: %timeit p100*q1000\n100000 loops, best of 3: 5.04 us per loop\nsage: %timeit p1000*q1000\n100000 loops, best of 3: 11 us per loop\nsage: %timeit hash(p5)\n1000000 loops, best of 3: 245 ns per loop\nsage: %timeit hash(p25)\n1000000 loops, best of 3: 532 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 884 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 1.63 us per loop\nsage: %timeit hash(p1000)\n100000 loops, best of 3: 14.6 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 885 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 1.71 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 2.63 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 4.53 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 39.3 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 785 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 829 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 799 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 791 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 822 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 1.48 us per loop\nsage: %timeit q25==r25\n100000 loops, best of 3: 3.72 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 6.63 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 12.5 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 116 us per loop\nsage: %timeit q1000.startswith(q100)\n100000 loops, best of 3: 4.7 us per loop\nsage: %timeit q1000.startswith(r100)\n100000 loops, best of 3: 4.72 us per loop\n```\n\nThe comparison with the other implementations becomes this:\n\n1. Concatenation\n\n```\n                     5x5   50x50  1000x1000\nUncompressed long : 739 ns  885 ns 3.06 us  - -\nUncompressed short: 700 ns  808 ns 2.13 us\nUncompressed char : 679 ns  772 ns 1.31 us    +\nCompressed   long : 676 ns  759 ns 1.61 us\nCompressed   short: 718 ns  722 ns 1.98 us   +\nSemicompr.   long : 684 ns  827 ns 1.42 us\nInteger           : 645 ns 1.82 us 1.78 us   -\nGMP          mpz_t: 723 ns  799 ns 1.41 us\ntuple             : 439 ns  1.1 us 11   us  + -\n```\n\n2. Hash\n\n```\n                     5       100     1000\nUncompressed long : 135 ns  333 ns  2.09 us  +\nUncompressed short: 138 ns  383 ns  2.61 us  +--\nUncompressed char : 133 ns  374 ns  2.53 us  +\nCompressed   long : 132 ns  155 ns   466 ns  +++\nCompressed   short: 132 ns  206 ns   951 ns  +\nSemicompr.   long : 148 ns  194 ns   594 ns\nInteger           : 164 ns  274 ns  1.94 us  \nGMP          mpz_t: 159 ns  266 ns  1.93 us\ntuple             : 245 ns 1.63 us 14.6  us  ---\n```\n\n3. == for equal paths\n\n```\n                     5       100     1000\nUncompressed long : 1.63 us 23   us  212   us ---\nUncompressed short: 1.08 us 14.9 us  137   us\nUncompressed char : 1.08 us 12.5 us  121   us\nCompressed   long :  710 ns  4.4 us   38   us\nCompressed   short:  723 ns  5.3 us   47.5 us\nSemicompr.   long :  498 ns  712 ns    2.4 us\nInteger           :  667 ns  658 ns    817 ns\nGMP          mpz_t:  466 ns  485 ns    693 ns +++\ntuple             :  885 ns  4.5 us   39.3 us\n```\n\n4. == for \"easily\" unequal paths\n\n```\n                     5       100     1000\nUncompressed long : 634 ns   686 ns   698 ns\nUncompressed short: 613 ns   603 ns   635 ns\nUncompressed char : 581 ns   599 ns   636 ns\nCompressed   long : 692 ns   729 ns   752 ns \nCompressed   short: 577 ns   588 ns   607 ns\nSemicompr.   long : 499 ns   526 ns   545 ns\nInteger           : 746 ns   731 ns   733 ns \nGMP          mpz_t: 451 ns   468 ns   482 ns +++\ntuple             : 785 ns   791 ns   822 ns ---\n```\n\n5. == for \"difficult\" unequal paths\n\n```\n                     5       100      1000\nUncompressed long : 1.65 us   22   us  213 us   ---\nUncompressed short: 1.15 us   12.8 us  140 us\nUncompressed char : 1.06 us   12.7 us  121 us\nCompressed   long :  706 ns    4.4 us   37.6 us\nCompressed   short:  754 ns    5.3 us   47.3 us\nSemicompr.   long :  506 ns    704 ns   2.5 us\nInteger           :  710 ns    719 ns   755 ns\nGMP          mpz_t:  448 ns    457 ns   470 ns  +++\ntuple             : 1.48 us   12.5 us  116 us\n```\n\n6. startswith\n\n```\n                     yes      no\nUncompressed long :  325 ns  311 ns\nUncompressed short:  336 ns  325 ns\nUncompressed char :  324 ns  315 ns\nCompressed   long :  272 ns  257 ns  +\nCompressed   short:  272 ns  256 ns  +\nSemicompr.   long :  263 ns  232 ns  ++\nInteger           : 2.46 us 2.45 us  \nGMP          mpz_t:  673 ns  657 ns\ntuple             : 4.7  us 4.72 us  --\n```\n\nSo, using tuples is best for concatenation of short paths, but that's the only case where it is not too slow.",
    "created_at": "2014-02-24T14:42:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203817",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'></a>
For completeness, I have added `Path_v6`, which uses Python's `tuple` under the hood (which is an obvious way to implement paths, too).

Result:

```
sage: %timeit p5*q5
1000000 loops, best of 3: 439 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 542 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 612 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 869 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 1.1 us per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 1.39 us per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 1.41 us per loop
sage: %timeit p100*q1000
100000 loops, best of 3: 5.04 us per loop
sage: %timeit p1000*q1000
100000 loops, best of 3: 11 us per loop
sage: %timeit hash(p5)
1000000 loops, best of 3: 245 ns per loop
sage: %timeit hash(p25)
1000000 loops, best of 3: 532 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 884 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 1.63 us per loop
sage: %timeit hash(p1000)
100000 loops, best of 3: 14.6 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 885 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 1.71 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 2.63 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 4.53 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 39.3 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 785 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 829 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 799 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 791 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 822 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 1.48 us per loop
sage: %timeit q25==r25
100000 loops, best of 3: 3.72 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 6.63 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 12.5 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 116 us per loop
sage: %timeit q1000.startswith(q100)
100000 loops, best of 3: 4.7 us per loop
sage: %timeit q1000.startswith(r100)
100000 loops, best of 3: 4.72 us per loop
```

The comparison with the other implementations becomes this:

1. Concatenation

```
                     5x5   50x50  1000x1000
Uncompressed long : 739 ns  885 ns 3.06 us  - -
Uncompressed short: 700 ns  808 ns 2.13 us
Uncompressed char : 679 ns  772 ns 1.31 us    +
Compressed   long : 676 ns  759 ns 1.61 us
Compressed   short: 718 ns  722 ns 1.98 us   +
Semicompr.   long : 684 ns  827 ns 1.42 us
Integer           : 645 ns 1.82 us 1.78 us   -
GMP          mpz_t: 723 ns  799 ns 1.41 us
tuple             : 439 ns  1.1 us 11   us  + -
```

2. Hash

```
                     5       100     1000
Uncompressed long : 135 ns  333 ns  2.09 us  +
Uncompressed short: 138 ns  383 ns  2.61 us  +--
Uncompressed char : 133 ns  374 ns  2.53 us  +
Compressed   long : 132 ns  155 ns   466 ns  +++
Compressed   short: 132 ns  206 ns   951 ns  +
Semicompr.   long : 148 ns  194 ns   594 ns
Integer           : 164 ns  274 ns  1.94 us  
GMP          mpz_t: 159 ns  266 ns  1.93 us
tuple             : 245 ns 1.63 us 14.6  us  ---
```

3. == for equal paths

```
                     5       100     1000
Uncompressed long : 1.63 us 23   us  212   us ---
Uncompressed short: 1.08 us 14.9 us  137   us
Uncompressed char : 1.08 us 12.5 us  121   us
Compressed   long :  710 ns  4.4 us   38   us
Compressed   short:  723 ns  5.3 us   47.5 us
Semicompr.   long :  498 ns  712 ns    2.4 us
Integer           :  667 ns  658 ns    817 ns
GMP          mpz_t:  466 ns  485 ns    693 ns +++
tuple             :  885 ns  4.5 us   39.3 us
```

4. == for "easily" unequal paths

```
                     5       100     1000
Uncompressed long : 634 ns   686 ns   698 ns
Uncompressed short: 613 ns   603 ns   635 ns
Uncompressed char : 581 ns   599 ns   636 ns
Compressed   long : 692 ns   729 ns   752 ns 
Compressed   short: 577 ns   588 ns   607 ns
Semicompr.   long : 499 ns   526 ns   545 ns
Integer           : 746 ns   731 ns   733 ns 
GMP          mpz_t: 451 ns   468 ns   482 ns +++
tuple             : 785 ns   791 ns   822 ns ---
```

5. == for "difficult" unequal paths

```
                     5       100      1000
Uncompressed long : 1.65 us   22   us  213 us   ---
Uncompressed short: 1.15 us   12.8 us  140 us
Uncompressed char : 1.06 us   12.7 us  121 us
Compressed   long :  706 ns    4.4 us   37.6 us
Compressed   short:  754 ns    5.3 us   47.3 us
Semicompr.   long :  506 ns    704 ns   2.5 us
Integer           :  710 ns    719 ns   755 ns
GMP          mpz_t:  448 ns    457 ns   470 ns  +++
tuple             : 1.48 us   12.5 us  116 us
```

6. startswith

```
                     yes      no
Uncompressed long :  325 ns  311 ns
Uncompressed short:  336 ns  325 ns
Uncompressed char :  324 ns  315 ns
Compressed   long :  272 ns  257 ns  +
Compressed   short:  272 ns  256 ns  +
Semicompr.   long :  263 ns  232 ns  ++
Integer           : 2.46 us 2.45 us  
GMP          mpz_t:  673 ns  657 ns
tuple             : 4.7  us 4.72 us  --
```

So, using tuples is best for concatenation of short paths, but that's the only case where it is not too slow.



---

archive/issue_comments_203818.json:
```json
{
    "body": "<a id='comment:19'></a>\nWell, given the outcomes I guess it mostly depends on your own practical applications ?... `:-)`\n\nI also wonder (because I hate them) how much time is spent dealing with parents. But all your implementations have to go through that at the moment so it does not change your comparisons.\n\nWell, I am back to work at long long last. With a computer AND a screen. And in Brussels, which counts for the good mood `:-P`\n\nHave fuuuuuuuuuuuuuun !\n\nNathann",
    "created_at": "2014-03-04T16:54:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203818",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:19'></a>
Well, given the outcomes I guess it mostly depends on your own practical applications ?... `:-)`

I also wonder (because I hate them) how much time is spent dealing with parents. But all your implementations have to go through that at the moment so it does not change your comparisons.

Well, I am back to work at long long last. With a computer AND a screen. And in Brussels, which counts for the good mood `:-P`

Have fuuuuuuuuuuuuuun !

Nathann



---

archive/issue_comments_203819.json:
```json
{
    "body": "<a id='comment:20'></a>\nHi Nathann,\n\nReplying to [ncohen](#comment%3A19):\n> I also wonder (because I hate them) how much time is spent dealing with parents.\n\n\nWell, at some point parents *have* to come into play, namely when I want to implement not just sequences of bounded integers, but elements of the path semigroup of a quiver.\n\nThe strategical question is: Should the data defining a path be stored in an attribute of that path (the attribute would be an instance of `BoundedIntegerSequence`), or should the path itself be an instance of `BoundedIntegerSequence`? In the former case, it would be perfectly fine to have sequences of bounded integers parent-less; but I worry about an overhead of accessing the attribute. In the latter case, `BoundedIntegerSequence` should already be a sub-class of `sage.structure.element.Element` (and have a parent), since Cython does not allow multiple inheritance.\n\nI tend to the latter solution also for a different reason: Instances of `BoundedIntegerSequence` have to know the bound for their elements, because the data storage depends on that bound. For efficiency (see attachment), several other constants are derived from that bound, and used in the algorithms.\n\nShould each instance of `BoundedIntegerSequence` know about all these bounds? Or should there be a common parent for all sequences of integers that are bounded by a number B?\n\nI tend to the latter. If you assign *several* ints (the afore-mentioned constants) to an instance of `BoundedIntegerSequence`, it will likely be more time consuming (during initialisation) than to store just a single data (namely the parent).\n\nThat said, looking up the constants via the parent would be more time-consuming than looking up constants that are stored directly in the element.\n\nDifficult....",
    "created_at": "2014-03-04T18:46:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203819",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:20'></a>
Hi Nathann,

Replying to [ncohen](#comment%3A19):
> I also wonder (because I hate them) how much time is spent dealing with parents.


Well, at some point parents *have* to come into play, namely when I want to implement not just sequences of bounded integers, but elements of the path semigroup of a quiver.

The strategical question is: Should the data defining a path be stored in an attribute of that path (the attribute would be an instance of `BoundedIntegerSequence`), or should the path itself be an instance of `BoundedIntegerSequence`? In the former case, it would be perfectly fine to have sequences of bounded integers parent-less; but I worry about an overhead of accessing the attribute. In the latter case, `BoundedIntegerSequence` should already be a sub-class of `sage.structure.element.Element` (and have a parent), since Cython does not allow multiple inheritance.

I tend to the latter solution also for a different reason: Instances of `BoundedIntegerSequence` have to know the bound for their elements, because the data storage depends on that bound. For efficiency (see attachment), several other constants are derived from that bound, and used in the algorithms.

Should each instance of `BoundedIntegerSequence` know about all these bounds? Or should there be a common parent for all sequences of integers that are bounded by a number B?

I tend to the latter. If you assign *several* ints (the afore-mentioned constants) to an instance of `BoundedIntegerSequence`, it will likely be more time consuming (during initialisation) than to store just a single data (namely the parent).

That said, looking up the constants via the parent would be more time-consuming than looking up constants that are stored directly in the element.

Difficult....



---

archive/issue_comments_203820.json:
```json
{
    "body": "<a id='comment:21'></a>\nHellooooo Simon !\n\nHmmmm... All this is important to settle before implementing those BoundedIntegerSequences objects somewhere indeed.\n\nWhat I thought you intended was to write a very low-level data structure somewhere in the misc/ folder. The kind of stuff that one does not use by mistake, the kind of stuff that ones does not use without reading the manual first. So I thought it would not exactly check its input, trusting blindly the developer and being as efficient as possible.\n\nThen, I thought you would have a higher-level algebraic stuff with parents colors and blinking lights that would check their input indeed, and be what we want a user-friendly object to be.\n\nBut I actually have only one question: I don't know how you intend to use all this in the end, but I got the impression that several functions may have to generate a LOT of paths in order to compute some small data, and throw all the paths away once the computations have ended. Do you want do create high-level objects in those functions or not ?\n\nIf you don't, then perhaps you would be better with only low-level objects that you know how to use, which would not have to waste time (if time is actually wasted) on high-level problems.\n\nAnd so I thought that you high-level objects would have a variable which would be this low-level object, etc, etc... \n\nWhat do you have in mind ?\n\nNathann",
    "created_at": "2014-03-04T20:03:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203820",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:21'></a>
Hellooooo Simon !

Hmmmm... All this is important to settle before implementing those BoundedIntegerSequences objects somewhere indeed.

What I thought you intended was to write a very low-level data structure somewhere in the misc/ folder. The kind of stuff that one does not use by mistake, the kind of stuff that ones does not use without reading the manual first. So I thought it would not exactly check its input, trusting blindly the developer and being as efficient as possible.

Then, I thought you would have a higher-level algebraic stuff with parents colors and blinking lights that would check their input indeed, and be what we want a user-friendly object to be.

But I actually have only one question: I don't know how you intend to use all this in the end, but I got the impression that several functions may have to generate a LOT of paths in order to compute some small data, and throw all the paths away once the computations have ended. Do you want do create high-level objects in those functions or not ?

If you don't, then perhaps you would be better with only low-level objects that you know how to use, which would not have to waste time (if time is actually wasted) on high-level problems.

And so I thought that you high-level objects would have a variable which would be this low-level object, etc, etc... 

What do you have in mind ?

Nathann



---

archive/issue_comments_203821.json:
```json
{
    "body": "<a id='comment:22'></a>\nHi Nathann,\n\nReplying to [ncohen](#comment%3A21):\n> What I thought you intended was to write a very low-level data structure somewhere in the misc/ folder.\n\n\nI somehow do.\n\n> The kind of stuff that one does not use by mistake,\n\n\nWhy? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).\n\n> Then, I thought you would have a higher-level algebraic stuff with parents colors and blinking lights that would check their input indeed, and be what we want a user-friendly object to be.\n\n\nAgain *ideally*: Blinking colours should only be added when one really implements paths in quivers.\n\n> But I actually have only one question: I don't know how you intend to use all this in the end, but I got the impression that several functions may have to generate a LOT of paths in order to compute some small data, and throw all the paths away once the computations have ended. Do you want do create high-level objects in those functions or not ?\n\n\nGood point. So, you mean that these functions should actually *not* create fully-fledged quiver paths, but should just operate on instances of `BoundedIntegerSequence`, and only in the end interpret them as paths, when the battle smoke has vanished.\n\n> And so I thought that you high-level objects would have a variable which would be this low-level object, etc, etc... \n\n\nYes, probably that's better.\n\nSo, perhaps I should really do `cdef class BoundedIntegerSequence(tuple)` rather than `cdef class BoundedIntegerSequence(MonoidElement)`.\n\nBut then, what to do with all these internally used constants that are needed even for the low-level functionality of `BoundedIntegerSequence`? Would you prefer to compute and store these constants 10000 times when creating 10000 sequences of integers bounded by `B`? Or would you prefer to compute and store these constants only once, namely in a parent that hosts all sequences of integers with a fixed bound?\n\nOr do you have a third solution for storing/accessing these constants efficiently?",
    "created_at": "2014-03-04T21:13:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203821",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:22'></a>
Hi Nathann,

Replying to [ncohen](#comment%3A21):
> What I thought you intended was to write a very low-level data structure somewhere in the misc/ folder.


I somehow do.

> The kind of stuff that one does not use by mistake,


Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).

> Then, I thought you would have a higher-level algebraic stuff with parents colors and blinking lights that would check their input indeed, and be what we want a user-friendly object to be.


Again *ideally*: Blinking colours should only be added when one really implements paths in quivers.

> But I actually have only one question: I don't know how you intend to use all this in the end, but I got the impression that several functions may have to generate a LOT of paths in order to compute some small data, and throw all the paths away once the computations have ended. Do you want do create high-level objects in those functions or not ?


Good point. So, you mean that these functions should actually *not* create fully-fledged quiver paths, but should just operate on instances of `BoundedIntegerSequence`, and only in the end interpret them as paths, when the battle smoke has vanished.

> And so I thought that you high-level objects would have a variable which would be this low-level object, etc, etc... 


Yes, probably that's better.

So, perhaps I should really do `cdef class BoundedIntegerSequence(tuple)` rather than `cdef class BoundedIntegerSequence(MonoidElement)`.

But then, what to do with all these internally used constants that are needed even for the low-level functionality of `BoundedIntegerSequence`? Would you prefer to compute and store these constants 10000 times when creating 10000 sequences of integers bounded by `B`? Or would you prefer to compute and store these constants only once, namely in a parent that hosts all sequences of integers with a fixed bound?

Or do you have a third solution for storing/accessing these constants efficiently?



---

archive/issue_comments_203822.json:
```json
{
    "body": "<a id='comment:23'></a>\nHelloooooo !!\n\n> Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).\n\n\nWhy do you want it to inherit from tuple ? I do not know the effect of such a thing, what it brings and what should be feared\n\n> Good point. So, you mean that these functions should actually *not* create fully-fledged quiver paths, but should just operate on instances of `BoundedIntegerSequence`, and only in the end interpret them as paths, when the battle smoke has vanished.\n\n\nWell, yep. Only create the  high-level stuff with possible  overhead when you need it. And you end up knowing exactly what your code does when you are writing the code of your time-critical function.\n\n> So, perhaps I should really do `cdef class BoundedIntegerSequence(tuple)` rather than `cdef class BoundedIntegerSequence(MonoidElement)`.\n\n\nHmmm.. I still don't get why you want it to inherit from  tuple. My natural move would be to implement this as a C structure, not even a object `:-P`\n\n> But then, what to do with all these internally used constants that are needed even for the low-level functionality of `BoundedIntegerSequence`? Would you prefer to compute and store these constants 10000 times when creating 10000 sequences of integers bounded by `B`? Or would you prefer to compute and store these constants only once, namely in a parent that hosts all sequences of integers with a fixed bound?\n\n\nWell, somehow that's already what we do with graph backends. We have a Generic Backend, extended twice in  Dense Graphs and Sparse Graphs. And all the constants needed by the data structures are stored in the corresponding files. You could have a `BoundedIntegerSequence` class implementing no function at all, extended by alld ifferent implementations of the data structures you want. Even in the same file.\n\n... And we don't need parents for that `:-PPPP`\n\nNathann",
    "created_at": "2014-03-05T10:09:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203822",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:23'></a>
Helloooooo !!

> Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).


Why do you want it to inherit from tuple ? I do not know the effect of such a thing, what it brings and what should be feared

> Good point. So, you mean that these functions should actually *not* create fully-fledged quiver paths, but should just operate on instances of `BoundedIntegerSequence`, and only in the end interpret them as paths, when the battle smoke has vanished.


Well, yep. Only create the  high-level stuff with possible  overhead when you need it. And you end up knowing exactly what your code does when you are writing the code of your time-critical function.

> So, perhaps I should really do `cdef class BoundedIntegerSequence(tuple)` rather than `cdef class BoundedIntegerSequence(MonoidElement)`.


Hmmm.. I still don't get why you want it to inherit from  tuple. My natural move would be to implement this as a C structure, not even a object `:-P`

> But then, what to do with all these internally used constants that are needed even for the low-level functionality of `BoundedIntegerSequence`? Would you prefer to compute and store these constants 10000 times when creating 10000 sequences of integers bounded by `B`? Or would you prefer to compute and store these constants only once, namely in a parent that hosts all sequences of integers with a fixed bound?


Well, somehow that's already what we do with graph backends. We have a Generic Backend, extended twice in  Dense Graphs and Sparse Graphs. And all the constants needed by the data structures are stored in the corresponding files. You could have a `BoundedIntegerSequence` class implementing no function at all, extended by alld ifferent implementations of the data structures you want. Even in the same file.

... And we don't need parents for that `:-PPPP`

Nathann



---

archive/issue_comments_203823.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [ncohen](#comment%3A23):\n> > Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).\n\n> \n> Why do you want it to inherit from tuple ?\n\n\nBy analogy to `Sequence_generic` (which inherits from `list`):\n\n```\nsage: S = Sequence([1,2,3])\nsage: type(S)\n<class 'sage.structure.sequence.Sequence_generic'>\nsage: type(S).mro()\n[sage.structure.sequence.Sequence_generic,\n sage.structure.sage_object.SageObject,\n list,\n object]\n```\n\n> Well, somehow that's already what we do with graph backends. We have a Generic Backend, extended twice in  Dense Graphs and Sparse Graphs. And all the constants needed by the data structures are stored in the corresponding files.\n\n\nNo, that's a different situation. If you have a sequence `S1` of integers bounded by `B1` and a sequence `S2` of integers bounded by `B2` then the constants for `S1` are different from the constants of `S2`. So, it is not really a \"global\" constant that is shared by all instances of a certain data structure (and could thus be put into a file), but when you do, for example, `for x in B1` then you'll need *different* constants than when you do `for x in B2`.\n\nSo, these constants are not shared by all sequences, but by all sequence that share the same bound. Thus, it seems natural (to me, at least) to have one object `O(B)` that is shared by all sequences of bound `B`, so that `O(B)` provides the constants that belong to `B`.\n\nSure, `O(B)` could be written in C as well. But why not making it a parent, when all what we do is letting each sequence have a pointer to `O(B)`?",
    "created_at": "2014-03-05T11:24:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203823",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:24'></a>
Replying to [ncohen](#comment%3A23):
> > Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).

> 
> Why do you want it to inherit from tuple ?


By analogy to `Sequence_generic` (which inherits from `list`):

```
sage: S = Sequence([1,2,3])
sage: type(S)
<class 'sage.structure.sequence.Sequence_generic'>
sage: type(S).mro()
[sage.structure.sequence.Sequence_generic,
 sage.structure.sage_object.SageObject,
 list,
 object]
```

> Well, somehow that's already what we do with graph backends. We have a Generic Backend, extended twice in  Dense Graphs and Sparse Graphs. And all the constants needed by the data structures are stored in the corresponding files.


No, that's a different situation. If you have a sequence `S1` of integers bounded by `B1` and a sequence `S2` of integers bounded by `B2` then the constants for `S1` are different from the constants of `S2`. So, it is not really a "global" constant that is shared by all instances of a certain data structure (and could thus be put into a file), but when you do, for example, `for x in B1` then you'll need *different* constants than when you do `for x in B2`.

So, these constants are not shared by all sequences, but by all sequence that share the same bound. Thus, it seems natural (to me, at least) to have one object `O(B)` that is shared by all sequences of bound `B`, so that `O(B)` provides the constants that belong to `B`.

Sure, `O(B)` could be written in C as well. But why not making it a parent, when all what we do is letting each sequence have a pointer to `O(B)`?



---

archive/issue_comments_203824.json:
```json
{
    "body": "<a id='comment:25'></a>\n> By analogy to `Sequence_generic` (which inherits from `list`):\n\n\n?...\n\nWell. And why is that a good idea ? `:-P`\n\n> No, that's a different situation. If you have a sequence `S1` of integers bounded by `B1` and a sequence `S2` of integers bounded by `B2` then the constants for `S1` are different from the constants of `S2`. So, it is not really a \"global\" constant that is shared by all instances of a certain data structure (and could thus be put into a file), but when you do, for example, `for x in B1` then you'll need *different* constants than when you do `for x in B2`.\n\n\nHmmmm... I see. Well, isn't your only parameter the number of bits you need to store each entry ? If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?\n\nIf it is a power of 2, then perhaps templates are sufficient, i.e. \"one data structure per value of this parameter\". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`\n\nI'd say.... 4,8,16,32 ? `:-)`\n\n> So, these constants are not shared by all sequences, but by all sequence that share the same bound. Thus, it seems natural (to me, at least) to have one object `O(B)` that is shared by all sequences of bound `B`, so that `O(B)` provides the constants that belong to `B`.\n\n\nIf your data structure is not an object, you could also add this width parameter as an input of the functions you use ? I guess all Bounded Sequence Integer that you use in the same function would have the same bound.\n\nBut admittedly I love to split hairs. Tell me if you think that this is going too far `:-P`\n\n> Sure, `O(B)` could be written in C as well. But why not making it a parent, when all what we do is letting each sequence have a pointer to `O(B)`?\n\n\nAhahahah. That's up to you. I just hate Sage's parents/elements. I would live happy with a C pointer I can  control, but not witha framework that I do not understand. If you understand it, then you know what you are doing. I don't `:-P`\n\nNathann",
    "created_at": "2014-03-05T11:37:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203824",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:25'></a>
> By analogy to `Sequence_generic` (which inherits from `list`):


?...

Well. And why is that a good idea ? `:-P`

> No, that's a different situation. If you have a sequence `S1` of integers bounded by `B1` and a sequence `S2` of integers bounded by `B2` then the constants for `S1` are different from the constants of `S2`. So, it is not really a "global" constant that is shared by all instances of a certain data structure (and could thus be put into a file), but when you do, for example, `for x in B1` then you'll need *different* constants than when you do `for x in B2`.


Hmmmm... I see. Well, isn't your only parameter the number of bits you need to store each entry ? If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?

If it is a power of 2, then perhaps templates are sufficient, i.e. "one data structure per value of this parameter". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`

I'd say.... 4,8,16,32 ? `:-)`

> So, these constants are not shared by all sequences, but by all sequence that share the same bound. Thus, it seems natural (to me, at least) to have one object `O(B)` that is shared by all sequences of bound `B`, so that `O(B)` provides the constants that belong to `B`.


If your data structure is not an object, you could also add this width parameter as an input of the functions you use ? I guess all Bounded Sequence Integer that you use in the same function would have the same bound.

But admittedly I love to split hairs. Tell me if you think that this is going too far `:-P`

> Sure, `O(B)` could be written in C as well. But why not making it a parent, when all what we do is letting each sequence have a pointer to `O(B)`?


Ahahahah. That's up to you. I just hate Sage's parents/elements. I would live happy with a C pointer I can  control, but not witha framework that I do not understand. If you understand it, then you know what you are doing. I don't `:-P`

Nathann



---

archive/issue_comments_203825.json:
```json
{
    "body": "<a id='comment:26'></a>\nReplying to [ncohen](#comment%3A25):\n> Hmmmm... I see. Well, isn't your only parameter the number of bits you need to store each entry ?\n\n\nNo. We have\n\n```c\ncdef Integer NumberArrows\ncdef Integer IntegerMask\ncdef size_t ArrowBitSize, BigArrowBitSize\ncdef block* bitmask = NULL\ncdef block DataMask, BitMask\ncdef size_t ArrowsPerBlock, BigArrowsPerBlock\ncdef size_t ModBAPB, DivBAPB, TimesBABS, TimesBlockSize\n```\n\nFor example, `ModBAPB` is used to replace `n%BigArrowsPerBlock` by a bit-wise `and`, which is noticeably faster.\n\n> If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?\n\n\nDepending on the implementation...\n\n\n> If it is a power of 2, then perhaps templates are sufficient, i.e. \"one data structure per value of this parameter\". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`\n\n\nIsn't duplication of code supposed to smell?\n\n> If your data structure is not an object, you could also add this width parameter as an input of the functions you use ? I guess all Bounded Sequence Integer that you use in the same function would have the same bound.\n\n\nDo I understand correctly: You suggest that we should *not* provide a class `BoundedIntegerSequence` that can be used interactively in Sage, but you suggest that we should just provide a couple of functions that operate on C structures (say, `mpz_t` or `usigned long*`) and can only be used in Cython code?\n\nThen it would be better to revert this ticket to its original purpose: There would be...\n1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,\n2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,\n3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).\n\n> But admittedly I love to split hairs. Tell me if you think that this is going too far `:-P`\n\n\nNo problem. I just want to know if people see the need to have a Cython implementation of sequences of bounded integers, for use in Python.\n\n> Ahahahah. That's up to you. I just hate Sage's parents/elements. I would live happy with a C pointer I can  control, but not witha framework that I do not understand.\n\n\nMaking it something like a container rather than a fully fledged parent would be an option, from my perspective.",
    "created_at": "2014-03-05T20:03:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203825",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:26'></a>
Replying to [ncohen](#comment%3A25):
> Hmmmm... I see. Well, isn't your only parameter the number of bits you need to store each entry ?


No. We have

```c
cdef Integer NumberArrows
cdef Integer IntegerMask
cdef size_t ArrowBitSize, BigArrowBitSize
cdef block* bitmask = NULL
cdef block DataMask, BitMask
cdef size_t ArrowsPerBlock, BigArrowsPerBlock
cdef size_t ModBAPB, DivBAPB, TimesBABS, TimesBlockSize
```

For example, `ModBAPB` is used to replace `n%BigArrowsPerBlock` by a bit-wise `and`, which is noticeably faster.

> If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?


Depending on the implementation...


> If it is a power of 2, then perhaps templates are sufficient, i.e. "one data structure per value of this parameter". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`


Isn't duplication of code supposed to smell?

> If your data structure is not an object, you could also add this width parameter as an input of the functions you use ? I guess all Bounded Sequence Integer that you use in the same function would have the same bound.


Do I understand correctly: You suggest that we should *not* provide a class `BoundedIntegerSequence` that can be used interactively in Sage, but you suggest that we should just provide a couple of functions that operate on C structures (say, `mpz_t` or `usigned long*`) and can only be used in Cython code?

Then it would be better to revert this ticket to its original purpose: There would be...
1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,
2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,
3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).

> But admittedly I love to split hairs. Tell me if you think that this is going too far `:-P`


No problem. I just want to know if people see the need to have a Cython implementation of sequences of bounded integers, for use in Python.

> Ahahahah. That's up to you. I just hate Sage's parents/elements. I would live happy with a C pointer I can  control, but not witha framework that I do not understand.


Making it something like a container rather than a fully fledged parent would be an option, from my perspective.



---

archive/issue_comments_203826.json:
```json
{
    "body": "<a id='comment:27'></a>\nReplying to [SimonKing](#comment%3A26):\n> Making it something like a container rather than a fully fledged parent would be an option, from my perspective.\n\n\n...  I mean, for `BoundedIntegerSequence`. Of course, `Path` must have a parent (the path semigroup of a quiver).",
    "created_at": "2014-03-05T20:04:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203826",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:27'></a>
Replying to [SimonKing](#comment%3A26):
> Making it something like a container rather than a fully fledged parent would be an option, from my perspective.


...  I mean, for `BoundedIntegerSequence`. Of course, `Path` must have a parent (the path semigroup of a quiver).



---

archive/issue_comments_203827.json:
```json
{
    "body": "<a id='comment:28'></a>\nJust a random thought. Some issues here are of the same nature as what was discussed around ClonableElement and its subclasses. Maybe there is stuff to share with it, especially if one ends up inheriting from Element.",
    "created_at": "2014-03-07T08:56:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203827",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:28'></a>
Just a random thought. Some issues here are of the same nature as what was discussed around ClonableElement and its subclasses. Maybe there is stuff to share with it, especially if one ends up inheriting from Element.



---

archive/issue_comments_203828.json:
```json
{
    "body": "<a id='comment:29'></a>\nI just had a look at `ClonableElement`, and one immediate thought is: Why are C-pointers allocated in `__init__`? That's clearly the purpose of `__cinit__`, in particular if said C-pointers are freed in `__dealloc__`.\n\nDo we want to have sequences of bounded integers for use in Python? Then one possible way would be:\n\n- have some inline cdef functions that operate on certain (templated?) C data structures\n- use these in a sub-class of `ClonableElement` (so that we can have sequences of bounded integers used in python)\n- use these in a `Path` class, to be used in path semigroups.",
    "created_at": "2014-03-07T09:13:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203828",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:29'></a>
I just had a look at `ClonableElement`, and one immediate thought is: Why are C-pointers allocated in `__init__`? That's clearly the purpose of `__cinit__`, in particular if said C-pointers are freed in `__dealloc__`.

Do we want to have sequences of bounded integers for use in Python? Then one possible way would be:

- have some inline cdef functions that operate on certain (templated?) C data structures
- use these in a sub-class of `ClonableElement` (so that we can have sequences of bounded integers used in python)
- use these in a `Path` class, to be used in path semigroups.



---

archive/issue_comments_203829.json:
```json
{
    "body": "<a id='comment:30'></a>\nYooooooo !!!\n\n> No. We have\n> \n> ```c\n> cdef Integer NumberArrows\n> cdef Integer IntegerMask\n> cdef size_t ArrowBitSize, BigArrowBitSize\n> cdef block* bitmask = NULL\n> cdef block DataMask, BitMask\n> cdef size_t ArrowsPerBlock, BigArrowsPerBlock\n> cdef size_t ModBAPB, DivBAPB, TimesBABS, TimesBlockSize\n> ```\n\n\nHmmmm.. Can't they all be deduced from the type of implementation (compressed long, for instance) and the number  of bits per entry then ?\n> \n> For example, `ModBAPB` is used to replace `n%BigArrowsPerBlock` by a bit-wise `and`, which is noticeably faster.\n\n\nYepyep of course.\n\n> > If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?\n\n> \n> Depending on the implementation...\n\n\nOkay....\n\n> > If it is a power of 2, then perhaps templates are sufficient, i.e. \"one data structure per value of this parameter\". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`\n\n> \n> Isn't duplication of code supposed to smell?\n\n\nWell, if it is a template the code is only implemented once. And it will generate several data structures at compile time indeed, but each of them will have a hardcoded constant, and  you only implement one.\n\n> Do I understand correctly: You suggest that we should *not* provide a class `BoundedIntegerSequence` that can be used interactively in Sage, but you suggest that we should just provide a couple of functions that operate on C structures (say, `mpz_t` or `usigned long*`) and can only be used in Cython code?\n\n\nThat's what I had in mind, but you make decisions here, pick what you like.\n\nIt's a bit how bitsets are implemented. A C data structure, and an object wrapper on top of it. Or C Graphs, with a data structure on top of it. It is how Permutations should be implemented, too `:-P`\n\nWell, you have a C object that you use when you want performance, and when you don't care you use the higher-level implementations.\n\n> Then it would be better to revert this ticket to its original purpose: There would be...\n> 1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,\n> 2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,\n> 3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).\n\n\nWell, I like this plan. What do you think ? Does it displease you in any way ?\n\n> No problem. I just want to know if people see the need to have a Cython implementation of sequences of bounded integers, for use in Python.\n\n\nI do not see how I could use it in my code at the moment, but I like the idea of having such a data structure somewhere, ready to be used. Most importantly, if you want speed, I think  that having it available at two different levels is a safe bet. You write more code, but you will know how computations are spent in your time-critical functions.\n\nNathann",
    "created_at": "2014-03-07T09:28:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203829",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:30'></a>
Yooooooo !!!

> No. We have
> 
> ```c
> cdef Integer NumberArrows
> cdef Integer IntegerMask
> cdef size_t ArrowBitSize, BigArrowBitSize
> cdef block* bitmask = NULL
> cdef block DataMask, BitMask
> cdef size_t ArrowsPerBlock, BigArrowsPerBlock
> cdef size_t ModBAPB, DivBAPB, TimesBABS, TimesBlockSize
> ```


Hmmmm.. Can't they all be deduced from the type of implementation (compressed long, for instance) and the number  of bits per entry then ?
> 
> For example, `ModBAPB` is used to replace `n%BigArrowsPerBlock` by a bit-wise `and`, which is noticeably faster.


Yepyep of course.

> > If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?

> 
> Depending on the implementation...


Okay....

> > If it is a power of 2, then perhaps templates are sufficient, i.e. "one data structure per value of this parameter". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`

> 
> Isn't duplication of code supposed to smell?


Well, if it is a template the code is only implemented once. And it will generate several data structures at compile time indeed, but each of them will have a hardcoded constant, and  you only implement one.

> Do I understand correctly: You suggest that we should *not* provide a class `BoundedIntegerSequence` that can be used interactively in Sage, but you suggest that we should just provide a couple of functions that operate on C structures (say, `mpz_t` or `usigned long*`) and can only be used in Cython code?


That's what I had in mind, but you make decisions here, pick what you like.

It's a bit how bitsets are implemented. A C data structure, and an object wrapper on top of it. Or C Graphs, with a data structure on top of it. It is how Permutations should be implemented, too `:-P`

Well, you have a C object that you use when you want performance, and when you don't care you use the higher-level implementations.

> Then it would be better to revert this ticket to its original purpose: There would be...
> 1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,
> 2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,
> 3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).


Well, I like this plan. What do you think ? Does it displease you in any way ?

> No problem. I just want to know if people see the need to have a Cython implementation of sequences of bounded integers, for use in Python.


I do not see how I could use it in my code at the moment, but I like the idea of having such a data structure somewhere, ready to be used. Most importantly, if you want speed, I think  that having it available at two different levels is a safe bet. You write more code, but you will know how computations are spent in your time-critical functions.

Nathann



---

archive/issue_comments_203830.json:
```json
{
    "body": "<a id='comment:31'></a>\nHi Nathann,\n\nReplying to [ncohen](#comment%3A30):\n> Hmmmm.. Can't they all be deduced from the type of implementation (compressed long, for instance) and the number  of bits per entry then ?\n\n\nSure. And you want to do this same computation `10^7` times?\n\n> > Isn't duplication of code supposed to smell?\n\n> \n> Well, if it is a template the code is only implemented once. And it will generate several data structures at compile time indeed, but each of them will have a hardcoded constant, and  you only implement one.\n\n\nYes. Probably my problem is that I don't think \"C++\", but I think \"Cython\". And there it is a bit clumsy (I think templating is mimicked in Cython by including .pxi files, isn't it?).\n \n> That's what I had in mind, but you make decisions here, pick what you like.\n> \n> It's a bit how bitsets are implemented.\n\n\nRight, that's what I have looked at, and think makes sense here. Up to the constants.\n\n> > Then it would be better to revert this ticket to its original purpose: There would be...\n> > 1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,\n> > 2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,\n> > 3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).\n  \n> \n> Well, I like this plan. What do you think ? Does it displease you in any way ?\n\n\nNo, it is one possibility.",
    "created_at": "2014-03-07T09:48:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203830",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:31'></a>
Hi Nathann,

Replying to [ncohen](#comment%3A30):
> Hmmmm.. Can't they all be deduced from the type of implementation (compressed long, for instance) and the number  of bits per entry then ?


Sure. And you want to do this same computation `10^7` times?

> > Isn't duplication of code supposed to smell?

> 
> Well, if it is a template the code is only implemented once. And it will generate several data structures at compile time indeed, but each of them will have a hardcoded constant, and  you only implement one.


Yes. Probably my problem is that I don't think "C++", but I think "Cython". And there it is a bit clumsy (I think templating is mimicked in Cython by including .pxi files, isn't it?).
 
> That's what I had in mind, but you make decisions here, pick what you like.
> 
> It's a bit how bitsets are implemented.


Right, that's what I have looked at, and think makes sense here. Up to the constants.

> > Then it would be better to revert this ticket to its original purpose: There would be...
> > 1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,
> > 2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,
> > 3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).
  
> 
> Well, I like this plan. What do you think ? Does it displease you in any way ?


No, it is one possibility.



---

archive/issue_comments_203831.json:
```json
{
    "body": "<a id='comment:33'></a>\n> Sure. And you want to do this same computation `10^7` times?\n\n\nI don't get it. If the width is a power of two, then there are 6 possible values, i.e. 2^1, 2^2, 2^3, 2^4, 2^5, 2^6. Otherwise you have at most 64, but really who cares in the end ?\n\n> Yes. Probably my problem is that I don't think \"C++\", but I think \"Cython\". And there it is a bit clumsy (I think templating is mimicked in Cython by including .pxi files, isn't it?).\n\n\nI am thinking of this :\nhttp://stackoverflow.com/questions/4840819/c-template-specialization-with-constant-value\n\nThat's C++, and I don't see how to do it in Cython, though. The point is that you can parameter a data structure with a constant value, and the data structure will be compiled for each value of the constant *that appears in the code at compile-time* (not all possible values, or course). The point is that the code is optimized while knowing the value(which can lead to optimization) and also that  you can do things that would not be possible otherwise, like \"cdef int a[k]\" where k is a (templated) variable.\n\nNathann",
    "created_at": "2014-03-07T12:15:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203831",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:33'></a>
> Sure. And you want to do this same computation `10^7` times?


I don't get it. If the width is a power of two, then there are 6 possible values, i.e. 2^1, 2^2, 2^3, 2^4, 2^5, 2^6. Otherwise you have at most 64, but really who cares in the end ?

> Yes. Probably my problem is that I don't think "C++", but I think "Cython". And there it is a bit clumsy (I think templating is mimicked in Cython by including .pxi files, isn't it?).


I am thinking of this :
http://stackoverflow.com/questions/4840819/c-template-specialization-with-constant-value

That's C++, and I don't see how to do it in Cython, though. The point is that you can parameter a data structure with a constant value, and the data structure will be compiled for each value of the constant *that appears in the code at compile-time* (not all possible values, or course). The point is that the code is optimized while knowing the value(which can lead to optimization) and also that  you can do things that would not be possible otherwise, like "cdef int a[k]" where k is a (templated) variable.

Nathann



---

archive/issue_comments_203832.json:
```json
{
    "body": "<a id='comment:34'></a>\nReplying to [ncohen](#comment%3A33):\n> > Sure. And you want to do this same computation `10^7` times?\n  \n> \n> I don't get it. If the width is a power of two, then there are 6 possible values, i.e. 2^1, 2^2, 2^3, 2^4, 2^5, 2^6. Otherwise you have at most 64, but really who cares in the end ?\n\n\nApparently I am not used to templated code...\n\nI was somehow thinking that you suggested to keep the bitlength of the upper bound for the integers as the *only* parameter, which means that you would need to compute all the other things either for each operation or (when storing it as attribute of the sequences) for each sequence.\n\n> I am thinking of this :\n> http://stackoverflow.com/questions/4840819/c-template-specialization-with-constant-value\n> \n> That's C++, and I don't see how to do it in Cython, though.\n\n\nPart of the question is: Do we want to use gmp as backend? Or do we want to (re-)implement operations on densely packed `long*` by ourselves? Given the timings, gmp *is* an option.\n\nAnyway, I'll have a look at the stackoverflow discussion. Thank you for the pointer!\n\nThe next question then is how to access the code from Cython. I've done this with C, but not C++.",
    "created_at": "2014-03-07T13:20:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203832",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:34'></a>
Replying to [ncohen](#comment%3A33):
> > Sure. And you want to do this same computation `10^7` times?
  
> 
> I don't get it. If the width is a power of two, then there are 6 possible values, i.e. 2^1, 2^2, 2^3, 2^4, 2^5, 2^6. Otherwise you have at most 64, but really who cares in the end ?


Apparently I am not used to templated code...

I was somehow thinking that you suggested to keep the bitlength of the upper bound for the integers as the *only* parameter, which means that you would need to compute all the other things either for each operation or (when storing it as attribute of the sequences) for each sequence.

> I am thinking of this :
> http://stackoverflow.com/questions/4840819/c-template-specialization-with-constant-value
> 
> That's C++, and I don't see how to do it in Cython, though.


Part of the question is: Do we want to use gmp as backend? Or do we want to (re-)implement operations on densely packed `long*` by ourselves? Given the timings, gmp *is* an option.

Anyway, I'll have a look at the stackoverflow discussion. Thank you for the pointer!

The next question then is how to access the code from Cython. I've done this with C, but not C++.



---

archive/issue_comments_203833.json:
```json
{
    "body": "<a id='comment:35'></a>\n> Apparently I am not used to templated code...\n> \n> I was somehow thinking that you suggested to keep the bitlength of the upper bound for the integers as the *only* parameter, which means that you would need to compute all the other things either for each operation or (when storing it as attribute of the sequences) for each sequence.\n\n\nNonono. Somehow, you can think of templates as a way to \"script\" the generation of code. You write some code with a constant k which is never defined anywhere, and then you say \"compile one  version of this code for each k in 1, 2, 3, 4, 5, 6. You end up with several data structures implemented, each with a hardcoded value. And then you can create an object `cdef LongCompressedPath<5> my_path` in which the hardcoded bound is `2^5`. You just have many additional types, each  with  its own constant.\n\n> Part of the question is: Do we want to use gmp as backend? Or do we want to (re-)implement operations on densely packed `long*` by ourselves? Given the timings, gmp *is* an option.\n\n\nYep, you are right. Depends on how you weight the operations that you will need: it looks okay for concatenations and bad for startwith, but I expect that the most time consuming operation will be concatenation ? You are the one who needs it `:-)`\n\n> Anyway, I'll have a look at the stackoverflow discussion. Thank you for the pointer!\n> \n> The next question then is how to access the code from Cython. I've done this with C, but not C++.\n\n\nHMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?\n\nNathann",
    "created_at": "2014-03-07T13:35:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203833",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:35'></a>
> Apparently I am not used to templated code...
> 
> I was somehow thinking that you suggested to keep the bitlength of the upper bound for the integers as the *only* parameter, which means that you would need to compute all the other things either for each operation or (when storing it as attribute of the sequences) for each sequence.


Nonono. Somehow, you can think of templates as a way to "script" the generation of code. You write some code with a constant k which is never defined anywhere, and then you say "compile one  version of this code for each k in 1, 2, 3, 4, 5, 6. You end up with several data structures implemented, each with a hardcoded value. And then you can create an object `cdef LongCompressedPath<5> my_path` in which the hardcoded bound is `2^5`. You just have many additional types, each  with  its own constant.

> Part of the question is: Do we want to use gmp as backend? Or do we want to (re-)implement operations on densely packed `long*` by ourselves? Given the timings, gmp *is* an option.


Yep, you are right. Depends on how you weight the operations that you will need: it looks okay for concatenations and bad for startwith, but I expect that the most time consuming operation will be concatenation ? You are the one who needs it `:-)`

> Anyway, I'll have a look at the stackoverflow discussion. Thank you for the pointer!
> 
> The next question then is how to access the code from Cython. I've done this with C, but not C++.


HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?

Nathann



---

archive/issue_events_143574.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143574"
}
```



---

archive/issue_events_143575.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143575"
}
```



---

archive/issue_comments_203834.json:
```json
{
    "body": "<a id='comment:37'></a>\nHi Nathann,\n\nsorry for the long silence!\n\nReplying to [ncohen](#comment%3A35):\n> HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?\n\n\nDid you find out how templated code can be written in Cython? If you have asked on cython-devel (so far I have only posted on cython-users) or have another pointer, then please tell me. If not, tell me also...\n\nCheers,\nSimon",
    "created_at": "2014-05-11T16:05:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203834",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:37'></a>
Hi Nathann,

sorry for the long silence!

Replying to [ncohen](#comment%3A35):
> HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?


Did you find out how templated code can be written in Cython? If you have asked on cython-devel (so far I have only posted on cython-users) or have another pointer, then please tell me. If not, tell me also...

Cheers,
Simon



---

archive/issue_comments_203835.json:
```json
{
    "body": "<a id='comment:38'></a>\nHi Nathann,\n\nwouldn't the following be close to templates?\n\nIn Cython:\n\n```\ncimport cython\n\nctypedef fused str_or_int:\n    str\n    int\n\ncpdef str_or_int times_two(str_or_int var):\n    return var+var\n\ndef show_me():\n    cdef str a = 'a'\n    cdef int b = 3\n    print 'str', times_two(a)\n    print 'int', times_two(b)\n```\nand this results in\n\n```\nsage: show_me()\nstr aa\nint 6\n```",
    "created_at": "2014-05-11T16:26:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203835",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:38'></a>
Hi Nathann,

wouldn't the following be close to templates?

In Cython:

```
cimport cython

ctypedef fused str_or_int:
    str
    int

cpdef str_or_int times_two(str_or_int var):
    return var+var

def show_me():
    cdef str a = 'a'
    cdef int b = 3
    print 'str', times_two(a)
    print 'int', times_two(b)
```
and this results in

```
sage: show_me()
str aa
int 6
```



---

archive/issue_comments_203836.json:
```json
{
    "body": "<a id='comment:39'></a>\nOr perhaps a better example, showing that the fused type is used to choose code at compile time: Put the following into a cell of the notebook\n\n```\n%cython\ncimport cython\n\nctypedef fused str_or_int:\n    str\n    int\ncpdef str_or_int times_two(str_or_int var):\n    if str_or_int is int:\n        return var*2\n    else:\n        return var+var\ndef test():\n    cdef int a = 3\n    cdef str b = 'b'\n    a = times_two(a)\n    b = times_two(b)\n```\nand look at the resulting code. The line `a = times_two(a)` becomes\n\n```\n __pyx_v_a = __pyx_fuse_1__pyx_f_68_home_king__sage_sage_notebook_sagenb_home_admin_2_code_sage4_spyx_0_times_two(__pyx_v_a, 0);\n```\nwhereas `b = times_two(b)` becomes\n\n```\n__pyx_t_1 = __pyx_fuse_0__pyx_f_68_home_king__sage_sage_notebook_sagenb_home_admin_2_code_sage4_spyx_0_times_two(__pyx_v_b, 0);\n```\nand one can check that Cython created two different C-functions `__pyx_fuse_0...` and `__pyx_fuse_1...` for the two possible (type-dependent!) versions of `times_two`.",
    "created_at": "2014-05-11T16:53:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203836",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:39'></a>
Or perhaps a better example, showing that the fused type is used to choose code at compile time: Put the following into a cell of the notebook

```
%cython
cimport cython

ctypedef fused str_or_int:
    str
    int
cpdef str_or_int times_two(str_or_int var):
    if str_or_int is int:
        return var*2
    else:
        return var+var
def test():
    cdef int a = 3
    cdef str b = 'b'
    a = times_two(a)
    b = times_two(b)
```
and look at the resulting code. The line `a = times_two(a)` becomes

```
 __pyx_v_a = __pyx_fuse_1__pyx_f_68_home_king__sage_sage_notebook_sagenb_home_admin_2_code_sage4_spyx_0_times_two(__pyx_v_a, 0);
```
whereas `b = times_two(b)` becomes

```
__pyx_t_1 = __pyx_fuse_0__pyx_f_68_home_king__sage_sage_notebook_sagenb_home_admin_2_code_sage4_spyx_0_times_two(__pyx_v_b, 0);
```
and one can check that Cython created two different C-functions `__pyx_fuse_0...` and `__pyx_fuse_1...` for the two possible (type-dependent!) versions of `times_two`.



---

archive/issue_comments_203837.json:
```json
{
    "body": "<a id='comment:40'></a>\nAnd here an example showing that it pays off, speed-wise:\n\nIn a .pyx file:\n\n```\ncimport cython\n\nctypedef fused str_or_int:\n    str\n    int\n\ncpdef str_or_int times_two(str_or_int var):\n    if str_or_int is int:\n        return var+var\n    else:\n        return var+var\n\ncpdef untyped_times_two(var):\n    return var+var\n\ncpdef int int_times_two(int var):\n    return var+var\n\ncpdef str str_times_two(str var):\n    return var+var\n\ndef test1():\n    cdef int a = 3\n    cdef str b = 'b'\n    a = times_two(a)\n    b = times_two(b)\n\ndef test2():\n    cdef int a = 3\n    cdef str b = 'b'\n    a = untyped_times_two(a)\n    b = untyped_times_two(b)\n\ndef test3():\n    cdef int a = 3\n    cdef str b = 'b'\n    a = int_times_two(a)\n    b = str_times_two(b)\n```\nAttach the .pyx file to Sage, and get this:\n\n```\nage: %attach /home/king/Sage/work/templates/test.pyx\nCompiling /home/king/Sage/work/templates/test.pyx...\nsage: %timeit test1()\n10000000 loops, best of 3: 159 ns per loop\nsage: %timeit test2()\n1000000 loops, best of 3: 199 ns per loop\nsage: %timeit test3()\n10000000 loops, best of 3: 168 ns per loop\n```\n\nEDIT: I have replaced the original example by something fairer, where it says `var+var` everywhere, but in the templated version Cython can choose the c-implementation of `var+var` at compile time, whereas it can't (and hence loses time when running the code) in the untemplated version.\n\nEDIT 2: The new example also shows that choosing a specialised implementation manually is not faster than Cython using templates.",
    "created_at": "2014-05-11T16:59:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203837",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:40'></a>
And here an example showing that it pays off, speed-wise:

In a .pyx file:

```
cimport cython

ctypedef fused str_or_int:
    str
    int

cpdef str_or_int times_two(str_or_int var):
    if str_or_int is int:
        return var+var
    else:
        return var+var

cpdef untyped_times_two(var):
    return var+var

cpdef int int_times_two(int var):
    return var+var

cpdef str str_times_two(str var):
    return var+var

def test1():
    cdef int a = 3
    cdef str b = 'b'
    a = times_two(a)
    b = times_two(b)

def test2():
    cdef int a = 3
    cdef str b = 'b'
    a = untyped_times_two(a)
    b = untyped_times_two(b)

def test3():
    cdef int a = 3
    cdef str b = 'b'
    a = int_times_two(a)
    b = str_times_two(b)
```
Attach the .pyx file to Sage, and get this:

```
age: %attach /home/king/Sage/work/templates/test.pyx
Compiling /home/king/Sage/work/templates/test.pyx...
sage: %timeit test1()
10000000 loops, best of 3: 159 ns per loop
sage: %timeit test2()
1000000 loops, best of 3: 199 ns per loop
sage: %timeit test3()
10000000 loops, best of 3: 168 ns per loop
```

EDIT: I have replaced the original example by something fairer, where it says `var+var` everywhere, but in the templated version Cython can choose the c-implementation of `var+var` at compile time, whereas it can't (and hence loses time when running the code) in the untemplated version.

EDIT 2: The new example also shows that choosing a specialised implementation manually is not faster than Cython using templates.



---

archive/issue_comments_203838.json:
```json
{
    "body": "<a id='comment:41'></a>\nHellooooooooooooooooo !!!\n\n> EDIT: I have replaced the original example by something fairer, where it says `var+var` everywhere, but in the templated version Cython can choose the c-implementation of `var+var` at compile time, whereas it can't (and hence loses time when running the code) in the untemplated version.\n\n\nHMmmmmm... Does it make any difference ? gcc should resolve those \"if\" at compile-time, so if Cython creates two version of the function with an \"if\" inside depending on the type, gcc should not include it in the final binary as the constants involved can be defined at compile-time.\n\nAnyway, that's a good news ! `:-D`\n\nNathann",
    "created_at": "2014-05-12T10:05:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203838",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:41'></a>
Hellooooooooooooooooo !!!

> EDIT: I have replaced the original example by something fairer, where it says `var+var` everywhere, but in the templated version Cython can choose the c-implementation of `var+var` at compile time, whereas it can't (and hence loses time when running the code) in the untemplated version.


HMmmmmm... Does it make any difference ? gcc should resolve those "if" at compile-time, so if Cython creates two version of the function with an "if" inside depending on the type, gcc should not include it in the final binary as the constants involved can be defined at compile-time.

Anyway, that's a good news ! `:-D`

Nathann



---

archive/issue_comments_203839.json:
```json
{
    "body": "<a id='comment:42'></a>\nYooooooooooo !!\n\n> > HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?\n  \n> \n> Did you find out how templated code can be written in Cython? If you have asked on cython-devel (so far I have only posted on cython-users) or have another pointer, then please tell me. If not, tell me also...\n\n\nAhahah.. Well, no ... When I ask a question I do not do anything before I get an answer, soooooooooo I never did it `:-P`\n\nI ask a question, then forget everything about it. When I get the answer I do what should be done `:-P`\n\nNathann",
    "created_at": "2014-05-12T10:06:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203839",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:42'></a>
Yooooooooooo !!

> > HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?
  
> 
> Did you find out how templated code can be written in Cython? If you have asked on cython-devel (so far I have only posted on cython-users) or have another pointer, then please tell me. If not, tell me also...


Ahahah.. Well, no ... When I ask a question I do not do anything before I get an answer, soooooooooo I never did it `:-P`

I ask a question, then forget everything about it. When I get the answer I do what should be done `:-P`

Nathann



---

archive/issue_comments_203840.json:
```json
{
    "body": "<a id='comment:43'></a>\nHi Nathann,\n\nReplying to [ncohen](#comment%3A41):\n> HMmmmmm... Does it make any difference ? gcc should resolve those \"if\" at compile-time, so if Cython creates two version of the function with an \"if\" inside depending on the type, gcc should not include it in the final binary as the constants involved can be defined at compile-time.\n\n\nYes, it is indeed resolved at compile time. Two c-functions are created, and only the part of the code relevant for the respective code branch appears in the c-function.\n\nIn other words, I now plan to create cdef functions like this:\n\n```python\nctypedef seq_t:\n    first_implementation\n    second_implementation\n\ncdef seq_t concat(seq_t x, seq_t y):\n    if seq_t is first_implementation:\n        <do stuff for 1st implementation>\n    else:\n        <do stuff for 2nd implementation>\n```\nand then, in other modules (perhaps also in `src/sage/combinat/words/word_datatypes.pyx`?), one could uniformly call `concat(a,b)`, provided that the type of `a` and `b` are known at compile time (or write `concat[first_implementation](a,b)` explicitly).\n\nI think that such Cython code will be sufficiently nice to read, and the resulting C-code will be sufficiently fast.\n\n> Anyway, that's a good news ! `:-D`\n\n\nIndeed!\n\nSimon",
    "created_at": "2014-05-12T10:21:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203840",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:43'></a>
Hi Nathann,

Replying to [ncohen](#comment%3A41):
> HMmmmmm... Does it make any difference ? gcc should resolve those "if" at compile-time, so if Cython creates two version of the function with an "if" inside depending on the type, gcc should not include it in the final binary as the constants involved can be defined at compile-time.


Yes, it is indeed resolved at compile time. Two c-functions are created, and only the part of the code relevant for the respective code branch appears in the c-function.

In other words, I now plan to create cdef functions like this:

```python
ctypedef seq_t:
    first_implementation
    second_implementation

cdef seq_t concat(seq_t x, seq_t y):
    if seq_t is first_implementation:
        <do stuff for 1st implementation>
    else:
        <do stuff for 2nd implementation>
```
and then, in other modules (perhaps also in `src/sage/combinat/words/word_datatypes.pyx`?), one could uniformly call `concat(a,b)`, provided that the type of `a` and `b` are known at compile time (or write `concat[first_implementation](a,b)` explicitly).

I think that such Cython code will be sufficiently nice to read, and the resulting C-code will be sufficiently fast.

> Anyway, that's a good news ! `:-D`


Indeed!

Simon



---

archive/issue_comments_203841.json:
```json
{
    "body": "<a id='comment:44'></a>\n> I think that such Cython code will be sufficiently nice to read, and the resulting C-code will be sufficiently fast.\n\n\n+1\n\nNathann",
    "created_at": "2014-05-12T10:23:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203841",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:44'></a>
> I think that such Cython code will be sufficiently nice to read, and the resulting C-code will be sufficiently fast.


+1

Nathann



---

archive/issue_comments_203842.json:
```json
{
    "body": "<a id='comment:45'></a>\nHmmm. Meanwhile I am a bit less positive about fused types. Let `seq_t` be a fused type for different implementations.\n\n- Fused types can not be used in iterators. I.e., the following is refused:\n\n  ```\n  def iter_seq(seq_t S):\n      for <bla>:\n          <do something>\n          yield x\n  ```\n- Fused types can not be used as attributes of cdef classes. I.e., the following is refused:\n\n  ```\n  cdef class BoundedIntSeq:\n      cdef seq_t seq\n      def __mul__(self, other):\n          <do type check>\n          cdef seq_t out = concat_seq(self.seq, other.seq)\n          <create and return new instance of BoundedIntSeq using \"out\">\n  ```\n\nHence, it seems that one needs to create two separate iterators, and it also seems that one needs code duplication. I.e., when `impl1` and `impl2` are two specialisations of the fused type `seq_t`, then one has to have\n\n```\ncdef class BoundedIntSeq_impl1:\n    cdef impl1 seq\n    def __mul__(self, other):\n        ...\n        cdef impl1 out = concat_seq(self.seq, other.seq)\ncdef class BoundedIntSeq_impl2:\n    cdef impl2 seq\n    def __mul__(self, other):\n        ...\n        cdef impl2 out = concat_seq(self.seq, other.seq)\n```\nThis mainly amounts to cut-and-paste, but is ugly!\n\nI think I'll ask on cython-users if there are known ideas to solve this more elegantly.",
    "created_at": "2014-05-12T14:41:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203842",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:45'></a>
Hmmm. Meanwhile I am a bit less positive about fused types. Let `seq_t` be a fused type for different implementations.

- Fused types can not be used in iterators. I.e., the following is refused:

  ```
  def iter_seq(seq_t S):
      for <bla>:
          <do something>
          yield x
  ```
- Fused types can not be used as attributes of cdef classes. I.e., the following is refused:

  ```
  cdef class BoundedIntSeq:
      cdef seq_t seq
      def __mul__(self, other):
          <do type check>
          cdef seq_t out = concat_seq(self.seq, other.seq)
          <create and return new instance of BoundedIntSeq using "out">
  ```

Hence, it seems that one needs to create two separate iterators, and it also seems that one needs code duplication. I.e., when `impl1` and `impl2` are two specialisations of the fused type `seq_t`, then one has to have

```
cdef class BoundedIntSeq_impl1:
    cdef impl1 seq
    def __mul__(self, other):
        ...
        cdef impl1 out = concat_seq(self.seq, other.seq)
cdef class BoundedIntSeq_impl2:
    cdef impl2 seq
    def __mul__(self, other):
        ...
        cdef impl2 out = concat_seq(self.seq, other.seq)
```
This mainly amounts to cut-and-paste, but is ugly!

I think I'll ask on cython-users if there are known ideas to solve this more elegantly.



---

archive/issue_comments_203843.json:
```json
{
    "body": "<a id='comment:46'></a>\nSome variation on the theme: One can create fused types from two cdef classes, and then one can work with specialisations of functions as follows:\n\n```python\n\nctypedef fused str_or_int:\n    str\n    int\n\n# make the function do different things on different types,\n# to better see the difference\ncpdef str_or_int times_two(str_or_int var):\n    if str_or_int is int:\n        return var+var\n    else:\n        return var+'+'+var\n\n# forward declaration of cdef classes and their fusion\ncdef class Bar_int\ncdef class Bar_str\ncdef fused Bar:\n    Bar_int\n    Bar_str\n\n# a function that can be specialised to either of the two extension classes\ndef twice(Bar self):\n    # and inside, we specialised a function depending\n    # on the type of an attribute --- at compile time!!\n    return type(self)(times_two(self.data))\n\ncdef class Bar_str:\n    cdef str data\n    def __init__(self, data):\n        self.data = data\n    def __repr__(self):\n        return self.data\n    # First possibility: Use the \"templated\" function as a method\n    twice_ = twice[Bar_str]\n    # second possibility: Wrap the \"templated\" function\n    cpdef Bar_str twice__(self):\n        return twice(self)\n\n# The same, with the other Specialisation of <Bar>\ncdef class Bar_int:\n    cdef int data\n    def __init__(self, data):\n        self.data = data\n    def __repr__(self):\n        return \"int(%d)\"%self.data\n    twice_ = twice[Bar_int]\n    cpdef Bar_int twice__(self):\n        return twice(self)\n```\nTime-wise, we see that wrapping the \"templated\" function is slower than using it as an attribute:\n\n```\nsage: b1 = Bar_str('abc')\nsage: b1.twice_()\nabc+abc\nsage: b1.twice__()\nabc+abc\nsage: %timeit b1.twice_()\n1000000 loops, best of 3: 759 ns per loop\nsage: %timeit b1.twice__()\n100000 loops, best of 3: 13.7 \u00b5s per loop\nsage: b2 = Bar_int(5)\nsage: b2.twice_()\nint(10)\nsage: b2.twice__()\nint(10)\nsage: %timeit b2.twice_()\n1000000 loops, best of 3: 539 ns per loop\nsage: %timeit b2.twice__()\n100000 loops, best of 3: 9.2 \u00b5s per loop\n```\n\n__Summary and further comments__\n\n- We can reduce the code duplication to something like this:\n\n  ```\n  <define templated function foo_ depending on a fused type Bar with specialisations Bar1, Bar2,...>\n  cdef class Bar1:\n      foo = foo_[Bar1]\n  cdef class Bar2:\n      foo = foo_[Bar2]\n  ...\n  ```\n  I hope this level of copy-and-paste can be afforded. At least, it gives good speed.\n- In my tests I found the following:\n  - It is impossible to make `foo_` a cpdef function. Otherwise, the assignment `foo = foo_` fails with the statement that `foo_` can not be turned into a Python type.\n  - It is impossible to chose the same name for the templated function and for the method it is turned into. Doing\n\n    ```\n    class Bar1:\n        foo_ = foo_\n    ```\n    results in an error saying that `Bar1` has not attribute `foo_`.\n  - With the syntax above, both `twice_` and `twice__` have been put into the class' `__dict__`. I did not succeed to turn it into the equivalent of a cdef method.",
    "created_at": "2014-05-12T17:27:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203843",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:46'></a>
Some variation on the theme: One can create fused types from two cdef classes, and then one can work with specialisations of functions as follows:

```python

ctypedef fused str_or_int:
    str
    int

# make the function do different things on different types,
# to better see the difference
cpdef str_or_int times_two(str_or_int var):
    if str_or_int is int:
        return var+var
    else:
        return var+'+'+var

# forward declaration of cdef classes and their fusion
cdef class Bar_int
cdef class Bar_str
cdef fused Bar:
    Bar_int
    Bar_str

# a function that can be specialised to either of the two extension classes
def twice(Bar self):
    # and inside, we specialised a function depending
    # on the type of an attribute --- at compile time!!
    return type(self)(times_two(self.data))

cdef class Bar_str:
    cdef str data
    def __init__(self, data):
        self.data = data
    def __repr__(self):
        return self.data
    # First possibility: Use the "templated" function as a method
    twice_ = twice[Bar_str]
    # second possibility: Wrap the "templated" function
    cpdef Bar_str twice__(self):
        return twice(self)

# The same, with the other Specialisation of <Bar>
cdef class Bar_int:
    cdef int data
    def __init__(self, data):
        self.data = data
    def __repr__(self):
        return "int(%d)"%self.data
    twice_ = twice[Bar_int]
    cpdef Bar_int twice__(self):
        return twice(self)
```
Time-wise, we see that wrapping the "templated" function is slower than using it as an attribute:

```
sage: b1 = Bar_str('abc')
sage: b1.twice_()
abc+abc
sage: b1.twice__()
abc+abc
sage: %timeit b1.twice_()
1000000 loops, best of 3: 759 ns per loop
sage: %timeit b1.twice__()
100000 loops, best of 3: 13.7 µs per loop
sage: b2 = Bar_int(5)
sage: b2.twice_()
int(10)
sage: b2.twice__()
int(10)
sage: %timeit b2.twice_()
1000000 loops, best of 3: 539 ns per loop
sage: %timeit b2.twice__()
100000 loops, best of 3: 9.2 µs per loop
```

__Summary and further comments__

- We can reduce the code duplication to something like this:

  ```
  <define templated function foo_ depending on a fused type Bar with specialisations Bar1, Bar2,...>
  cdef class Bar1:
      foo = foo_[Bar1]
  cdef class Bar2:
      foo = foo_[Bar2]
  ...
  ```
  I hope this level of copy-and-paste can be afforded. At least, it gives good speed.
- In my tests I found the following:
  - It is impossible to make `foo_` a cpdef function. Otherwise, the assignment `foo = foo_` fails with the statement that `foo_` can not be turned into a Python type.
  - It is impossible to chose the same name for the templated function and for the method it is turned into. Doing

    ```
    class Bar1:
        foo_ = foo_
    ```
    results in an error saying that `Bar1` has not attribute `foo_`.
  - With the syntax above, both `twice_` and `twice__` have been put into the class' `__dict__`. I did not succeed to turn it into the equivalent of a cdef method.



---

archive/issue_comments_203844.json:
```json
{
    "body": "<a id='comment:47'></a>\nI did a lot of benchmark tests for the different implementations (using `long*` or `char*` or `mpz_t` to store sequences of bounded integers, using cdef functions that operate on fused types) and eventually found that using GMP (i.e., `mpz_t`) is fastest in *all* tests, by a wide margin.\n\nWhy did I not find this result before? Well, part of the reason is that GMP sometimes provides different functions to do the same job, and in the past few days I considerably improved my usage of the various possibilities. For example, `mpz_t` can be initialised in different ways. If one uses `mpz_init`, then the assignment that will follow results in a re-allocation. Since the length of the concatenation of two tuples is known in advance, prescribing the number of to-be-allocated bits with `mpz_init2` resulted in a speed-up of concatenation, actually it became twice as fast.\n\nAnd this result is not surprising. After all, GMP has to implement the same bitshift and comparison operations for bit arrays that I was implementing in the \"`long*`\" approach, too. But GMP probably uses implementation techniques that I can not even dream of.\n\nNow, my plan is to\n- create some `ctypedef struct bounded_int_tuple` that is based on `mpz_t` and is the underlying C structure for tuples of bounded integers\n- provide a collection of cdef (inline) functions, operating on `bounded_int_tuple`, for concatenation, copying, comparison and so on\n- wrap it in a cdef class `BoundedIntegerTuple`. This will probably *not* derive from `Element`: I think it makes no difference from the point of view of memory efficiency whether each `BoundedIntegerTuple` stores a pointer to the parent of \"all tuples of integers bounded by `B`\" or directly stores `B` as an unsigned int.\n\nIn a subsequent ticket, I plan to use it for quiver paths, and if the combinat crowd cares, they can use it to make parts of sage.combinat.words a lot faster.\n\nComments? Requests? Suggestion of alternatives?",
    "created_at": "2014-05-25T11:43:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203844",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:47'></a>
I did a lot of benchmark tests for the different implementations (using `long*` or `char*` or `mpz_t` to store sequences of bounded integers, using cdef functions that operate on fused types) and eventually found that using GMP (i.e., `mpz_t`) is fastest in *all* tests, by a wide margin.

Why did I not find this result before? Well, part of the reason is that GMP sometimes provides different functions to do the same job, and in the past few days I considerably improved my usage of the various possibilities. For example, `mpz_t` can be initialised in different ways. If one uses `mpz_init`, then the assignment that will follow results in a re-allocation. Since the length of the concatenation of two tuples is known in advance, prescribing the number of to-be-allocated bits with `mpz_init2` resulted in a speed-up of concatenation, actually it became twice as fast.

And this result is not surprising. After all, GMP has to implement the same bitshift and comparison operations for bit arrays that I was implementing in the "`long*`" approach, too. But GMP probably uses implementation techniques that I can not even dream of.

Now, my plan is to
- create some `ctypedef struct bounded_int_tuple` that is based on `mpz_t` and is the underlying C structure for tuples of bounded integers
- provide a collection of cdef (inline) functions, operating on `bounded_int_tuple`, for concatenation, copying, comparison and so on
- wrap it in a cdef class `BoundedIntegerTuple`. This will probably *not* derive from `Element`: I think it makes no difference from the point of view of memory efficiency whether each `BoundedIntegerTuple` stores a pointer to the parent of "all tuples of integers bounded by `B`" or directly stores `B` as an unsigned int.

In a subsequent ticket, I plan to use it for quiver paths, and if the combinat crowd cares, they can use it to make parts of sage.combinat.words a lot faster.

Comments? Requests? Suggestion of alternatives?



---

archive/issue_comments_203845.json:
```json
{
    "body": "<a id='comment:48'></a>\nNone from me. I keep being impressed at how much testing/researching you put into this quiver features... I really wonder what you will do with it in the end `;-)`\n\nNathann",
    "created_at": "2014-05-25T15:39:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203845",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:48'></a>
None from me. I keep being impressed at how much testing/researching you put into this quiver features... I really wonder what you will do with it in the end `;-)`

Nathann



---

archive/issue_comments_203846.json:
```json
{
    "body": "**Branch:** [u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)",
    "created_at": "2014-05-27T15:54:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203846",
    "user": "https://github.com/simon-king-jena"
}
```

**Branch:** [u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)



---

archive/issue_comments_203847.json:
```json
{
    "body": "<a id='comment:50'></a>\nI have pushed a branch with an initial implementation of bounded integer sequences. I took care of error handling: I think you will find that those GMP commands that may result in a memory error are wrapped in sig_on()/sig_off(), and the cdef boilerplate functions do propagate errors. In fact, in some of my tests, I was hitting Ctrl-C, and it worked.\n\nThe rest of this post is about benchmarks. I compare against Python tuples---which is of course ambitious, and you will find that not in all situations tuples are slower than bounded integer sequences. However, one should see it positively: The bounded integer sequences implemented here have features very similar to tuples, and there *are* operations for which they are a lot faster than tuples. It all depends on the length and the bound of the sequence. That's why I think that it is a reasonable contribution. And to make it faster (without Python classes), one can still use the cdef boilerplate functions. Generally, it seems that long bounded integer sequences are faster than long tuples, but short tuples are faster than short sequences. For hash, bounded integer sequences are pretty good, but they suck in accessing items, or in slicing with step different from 1.\n\nIn contrast to tuples, bounded integer sequences also provide fairly quick tests for whether a sequences starts with a given sequence, or whether a sequence contains a certain sub-sequence. This is a feature I took from strings.\n\nHere are the tests, with different sizes and bounds. Variable names starting with \"T\" hold tuples, those starting with \"S\" hold bounded integer sequences.\n\n```\nsage: from sage.structure.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\n```\n\n__Iteration__\n\n```\nsage: timeit(\"x=[y for y in T0]\", number=1000000)\n1000000 loops, best of 3: 783 ns per loop\nsage: timeit(\"x=[y for y in T1]\", number=1000000)\n1000000 loops, best of 3: 1.48 \u00b5s per loop\nsage: timeit(\"x=[y for y in T2]\", number=100000)\n100000 loops, best of 3: 4.3 \u00b5s per loop\nsage: timeit(\"x=[y for y in T3]\", number=1000)\n1000 loops, best of 3: 245 \u00b5s per loop\nsage: timeit(\"x=[y for y in S0]\", number=1000000)\n1000000 loops, best of 3: 2.38 \u00b5s per loop\nsage: timeit(\"x=[y for y in S1]\", number=100000)\n100000 loops, best of 3: 4.1 \u00b5s per loop\nsage: timeit(\"x=[y for y in S2]\", number=100000)\n100000 loops, best of 3: 10.1 \u00b5s per loop\nsage: timeit(\"x=[y for y in S3]\", number=1000)\n1000 loops, best of 3: 1.79 ms per loop\n```\n\n__Slicing__\n\nBounded integer sequences are immutable and hence copied by identity. But let us do slicing, dropping the last item:\n\n```\nsage: timeit(\"x=T3[:-1]\", number=100000)\n100000 loops, best of 3: 19.5 \u00b5s per loop\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 3.48 \u00b5s per loop\n```\nSlicing with `step!=1` is much slower, though:\n\n```\nsage: timeit(\"x=T3[:-1:2]\", number=100000)\n100000 loops, best of 3: 11.7 \u00b5s per loop\nsage: timeit(\"x=S3[:-1:2]\", number=1000)\n1000 loops, best of 3: 2.23 ms per loop\n```\nPerhaps I should mark it \"TODO\"...\n\n__Accessing single items__\n\nShort sequences\n\n```\nsage: timeit(\"x=T0[1]\", number=1000000)\n1000000 loops, best of 3: 361 ns per loop\nsage: timeit(\"x=T0[4]\", number=1000000)\n1000000 loops, best of 3: 373 ns per loop\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 959 ns per loop\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 960 ns per loop\n```\nLarge sequences (time also depends on the bound for the integer sequence!)\n\n```\nsage: timeit(\"x=T3[1]\", number=1000000)\n1000000 loops, best of 3: 359 ns per loop\nsage: timeit(\"x=T3[4500]\", number=1000000)\n1000000 loops, best of 3: 382 ns per loop\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 1.97 \u00b5s per loop\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 1.49 \u00b5s per loop\n```\n\n__Comparison__\n\nNote that comparison of bounded integer sequences works different from comparison of tuples or lists, as detailed in the documentation.\n\nWe compare sequences that are equal but non-identical, that differ in early items, or that differ in late items.\n\n```\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: T0x = tuple(L0x); T1x = tuple(L1x); T2x = tuple(L2x); T3x = tuple(L3x)\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: T0y = tuple(L0); T1y = tuple(L1); T2y = tuple(L2); T3y = tuple(L3)\nsage: S1y = BoundedIntegerSequence(8, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S1y==S1!=S1x, S1y is not S1\n(True, True)\n```\nEarly differences:\n\n```\nsage: timeit(\"T0==T0x\", number=1000000)\n1000000 loops, best of 3: 143 ns per loop\nsage: timeit(\"T1==T1x\", number=1000000)\n1000000 loops, best of 3: 145 ns per loop\nsage: timeit(\"T2==T2x\", number=1000000)\n1000000 loops, best of 3: 143 ns per loop\nsage: timeit(\"T3==T3x\", number=1000000)\n1000000 loops, best of 3: 161 ns per loop\nsage: timeit(\"S0==S0x\", number=1000000)\n1000000 loops, best of 3: 538 ns per loop\nsage: timeit(\"S1==S1x\", number=1000000)\n1000000 loops, best of 3: 550 ns per loop\nsage: timeit(\"S2==S2x\", number=1000000)\n1000000 loops, best of 3: 490 ns per loop\nsage: timeit(\"S3==S3x\", number=1000000)\n1000000 loops, best of 3: 559 ns per loop\n```\nEqual sequences:\n\n```\nsage: timeit(\"T0==T0y\", number=1000000)\n1000000 loops, best of 3: 169 ns per loop\nsage: timeit(\"T1==T1y\", number=1000000)\n1000000 loops, best of 3: 255 ns per loop\nsage: timeit(\"T2==T2y\", number=1000000)\n1000000 loops, best of 3: 597 ns per loop\nsage: timeit(\"T3==T3y\", number=100000)\n100000 loops, best of 3: 47.8 \u00b5s per loop\nsage: timeit(\"S0==S0y\", number=1000000)\n1000000 loops, best of 3: 511 ns per loop\nsage: timeit(\"S1==S1y\", number=1000000)\n1000000 loops, best of 3: 493 ns per loop\nsage: timeit(\"S2==S2y\", number=1000000)\n1000000 loops, best of 3: 583 ns per loop\nsage: timeit(\"S3==S3y\", number=1000000)\n1000000 loops, best of 3: 1.41 \u00b5s per loop\n```\nLate differences:\n\n```\nsage: T0z1 = T0+T0\nsage: T0z2 = T0+T0x\nsage: T1z1 = T1+T1\nsage: T1z2 = T1+T1x\nsage: T2z1 = T2+T2\nsage: T2z2 = T2+T2x\nsage: T3z1 = T3+T3\nsage: T3z2 = T3+T3x\nsage: timeit(\"T0z1==T0z2\", number=100000)\n100000 loops, best of 3: 206 ns per loop\nsage: timeit(\"T1z1==T1z2\", number=100000)\n100000 loops, best of 3: 308 ns per loop\nsage: timeit(\"T2z1==T2z2\", number=100000)\n100000 loops, best of 3: 640 ns per loop\nsage: timeit(\"T3z1==T3z2\", number=100000)\n100000 loops, best of 3: 47.8 \u00b5s per loop\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0z1==S0z2\", number=100000)\n100000 loops, best of 3: 585 ns per loop\nsage: timeit(\"S1z1==S1z2\", number=100000)\n100000 loops, best of 3: 494 ns per loop\nsage: timeit(\"S2z1==S2z2\", number=100000)\n100000 loops, best of 3: 555 ns per loop\nsage: timeit(\"S3z1==S3z2\", number=100000)\n100000 loops, best of 3: 578 ns per loop\n```\n\n__Hash__\n\nThis is the only operation for which bounded integer sequences seem to be consistently faster than tuples:\n\n```\nsage: timeit(\"hash(T0)\", number=100000)\n100000 loops, best of 3: 179 ns per loop\nsage: timeit(\"hash(T0)\", number=1000000)\n1000000 loops, best of 3: 177 ns per loop\nsage: timeit(\"hash(T1)\", number=1000000)\n1000000 loops, best of 3: 267 ns per loop\nsage: timeit(\"hash(T2)\", number=1000000)\n1000000 loops, best of 3: 584 ns per loop\nsage: timeit(\"hash(T3)\", number=100000)\n100000 loops, best of 3: 45.3 \u00b5s per loop\nsage: timeit(\"hash(S0)\", number=1000000)\n1000000 loops, best of 3: 145 ns per loop\nsage: timeit(\"hash(S1)\", number=1000000)\n1000000 loops, best of 3: 153 ns per loop\nsage: timeit(\"hash(S2)\", number=1000000)\n1000000 loops, best of 3: 194 ns per loop\nsage: timeit(\"hash(S3)\", number=1000000)\n1000000 loops, best of 3: 8.97 \u00b5s per loop\n```\n\n__Concatenation__\n\n```\nsage: timeit(\"T0+T0\", number=1000000)\n1000000 loops, best of 3: 200 ns per loop\nsage: timeit(\"T1+T1\", number=1000000)\n1000000 loops, best of 3: 311 ns per loop\nsage: timeit(\"T2+T2\", number=1000000)\n1000000 loops, best of 3: 742 ns per loop\nsage: timeit(\"T3+T3\", number=10000)\n10000 loops, best of 3: 40.3 \u00b5s per loop\nsage: timeit(\"S0+S0\", number=1000000)\n1000000 loops, best of 3: 576 ns per loop\nsage: timeit(\"S1+S1\", number=1000000)\n1000000 loops, best of 3: 590 ns per loop\nsage: timeit(\"S2+S2\", number=1000000)\n1000000 loops, best of 3: 618 ns per loop\nsage: timeit(\"S3+S3\", number=1000000)\n1000000 loops, best of 3: 2.17 \u00b5s per loop\n```\n\n__Subsequences__\n\nRecall the definition of `S0z1` etc. We find:\n\n```\nsage: S0z2.startswith(S0)\nTrue\nsage: S0z2.startswith(S0x)\nFalse\nsage: S0x in S0z2\nTrue\nsage: timeit(\"S0z2.startswith(S0)\", number=1000000)\n1000000 loops, best of 3: 239 ns per loop\nsage: timeit(\"S0z2.startswith(S0x)\", number=1000000)\n1000000 loops, best of 3: 241 ns per loop\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 694 ns per loop\nsage: timeit(\"S1z2.startswith(S1)\", number=1000000)\n1000000 loops, best of 3: 227 ns per loop\nsage: timeit(\"S1z2.startswith(S1x)\", number=1000000)\n1000000 loops, best of 3: 223 ns per loop\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 1.08 \u00b5s per loop\nsage: timeit(\"S2z2.startswith(S2)\", number=1000000)\n1000000 loops, best of 3: 247 ns per loop\nsage: timeit(\"S2z2.startswith(S2x)\", number=1000000)\n1000000 loops, best of 3: 230 ns per loop\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 3.21 \u00b5s per loop\nsage: timeit(\"S3z2.startswith(S3)\", number=1000000)\n1000000 loops, best of 3: 989 ns per loop\nsage: timeit(\"S3z2.startswith(S3x)\", number=1000000)\n1000000 loops, best of 3: 218 ns per loop\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 3.57 ms per loop\n```\nI wonder if the latter could be improved. Another \"TODO\"...\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8\">5dc78c5</a></td><td><code>Implement sequences of bounded integers</code></td></tr></table>\n",
    "created_at": "2014-05-27T16:02:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203847",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:50'></a>
I have pushed a branch with an initial implementation of bounded integer sequences. I took care of error handling: I think you will find that those GMP commands that may result in a memory error are wrapped in sig_on()/sig_off(), and the cdef boilerplate functions do propagate errors. In fact, in some of my tests, I was hitting Ctrl-C, and it worked.

The rest of this post is about benchmarks. I compare against Python tuples---which is of course ambitious, and you will find that not in all situations tuples are slower than bounded integer sequences. However, one should see it positively: The bounded integer sequences implemented here have features very similar to tuples, and there *are* operations for which they are a lot faster than tuples. It all depends on the length and the bound of the sequence. That's why I think that it is a reasonable contribution. And to make it faster (without Python classes), one can still use the cdef boilerplate functions. Generally, it seems that long bounded integer sequences are faster than long tuples, but short tuples are faster than short sequences. For hash, bounded integer sequences are pretty good, but they suck in accessing items, or in slicing with step different from 1.

In contrast to tuples, bounded integer sequences also provide fairly quick tests for whether a sequences starts with a given sequence, or whether a sequence contains a certain sub-sequence. This is a feature I took from strings.

Here are the tests, with different sizes and bounds. Variable names starting with "T" hold tuples, those starting with "S" hold bounded integer sequences.

```
sage: from sage.structure.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
```

__Iteration__

```
sage: timeit("x=[y for y in T0]", number=1000000)
1000000 loops, best of 3: 783 ns per loop
sage: timeit("x=[y for y in T1]", number=1000000)
1000000 loops, best of 3: 1.48 µs per loop
sage: timeit("x=[y for y in T2]", number=100000)
100000 loops, best of 3: 4.3 µs per loop
sage: timeit("x=[y for y in T3]", number=1000)
1000 loops, best of 3: 245 µs per loop
sage: timeit("x=[y for y in S0]", number=1000000)
1000000 loops, best of 3: 2.38 µs per loop
sage: timeit("x=[y for y in S1]", number=100000)
100000 loops, best of 3: 4.1 µs per loop
sage: timeit("x=[y for y in S2]", number=100000)
100000 loops, best of 3: 10.1 µs per loop
sage: timeit("x=[y for y in S3]", number=1000)
1000 loops, best of 3: 1.79 ms per loop
```

__Slicing__

Bounded integer sequences are immutable and hence copied by identity. But let us do slicing, dropping the last item:

```
sage: timeit("x=T3[:-1]", number=100000)
100000 loops, best of 3: 19.5 µs per loop
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 3.48 µs per loop
```
Slicing with `step!=1` is much slower, though:

```
sage: timeit("x=T3[:-1:2]", number=100000)
100000 loops, best of 3: 11.7 µs per loop
sage: timeit("x=S3[:-1:2]", number=1000)
1000 loops, best of 3: 2.23 ms per loop
```
Perhaps I should mark it "TODO"...

__Accessing single items__

Short sequences

```
sage: timeit("x=T0[1]", number=1000000)
1000000 loops, best of 3: 361 ns per loop
sage: timeit("x=T0[4]", number=1000000)
1000000 loops, best of 3: 373 ns per loop
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 959 ns per loop
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 960 ns per loop
```
Large sequences (time also depends on the bound for the integer sequence!)

```
sage: timeit("x=T3[1]", number=1000000)
1000000 loops, best of 3: 359 ns per loop
sage: timeit("x=T3[4500]", number=1000000)
1000000 loops, best of 3: 382 ns per loop
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 1.97 µs per loop
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 1.49 µs per loop
```

__Comparison__

Note that comparison of bounded integer sequences works different from comparison of tuples or lists, as detailed in the documentation.

We compare sequences that are equal but non-identical, that differ in early items, or that differ in late items.

```
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: T0x = tuple(L0x); T1x = tuple(L1x); T2x = tuple(L2x); T3x = tuple(L3x)
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: T0y = tuple(L0); T1y = tuple(L1); T2y = tuple(L2); T3y = tuple(L3)
sage: S1y = BoundedIntegerSequence(8, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S1y==S1!=S1x, S1y is not S1
(True, True)
```
Early differences:

```
sage: timeit("T0==T0x", number=1000000)
1000000 loops, best of 3: 143 ns per loop
sage: timeit("T1==T1x", number=1000000)
1000000 loops, best of 3: 145 ns per loop
sage: timeit("T2==T2x", number=1000000)
1000000 loops, best of 3: 143 ns per loop
sage: timeit("T3==T3x", number=1000000)
1000000 loops, best of 3: 161 ns per loop
sage: timeit("S0==S0x", number=1000000)
1000000 loops, best of 3: 538 ns per loop
sage: timeit("S1==S1x", number=1000000)
1000000 loops, best of 3: 550 ns per loop
sage: timeit("S2==S2x", number=1000000)
1000000 loops, best of 3: 490 ns per loop
sage: timeit("S3==S3x", number=1000000)
1000000 loops, best of 3: 559 ns per loop
```
Equal sequences:

```
sage: timeit("T0==T0y", number=1000000)
1000000 loops, best of 3: 169 ns per loop
sage: timeit("T1==T1y", number=1000000)
1000000 loops, best of 3: 255 ns per loop
sage: timeit("T2==T2y", number=1000000)
1000000 loops, best of 3: 597 ns per loop
sage: timeit("T3==T3y", number=100000)
100000 loops, best of 3: 47.8 µs per loop
sage: timeit("S0==S0y", number=1000000)
1000000 loops, best of 3: 511 ns per loop
sage: timeit("S1==S1y", number=1000000)
1000000 loops, best of 3: 493 ns per loop
sage: timeit("S2==S2y", number=1000000)
1000000 loops, best of 3: 583 ns per loop
sage: timeit("S3==S3y", number=1000000)
1000000 loops, best of 3: 1.41 µs per loop
```
Late differences:

```
sage: T0z1 = T0+T0
sage: T0z2 = T0+T0x
sage: T1z1 = T1+T1
sage: T1z2 = T1+T1x
sage: T2z1 = T2+T2
sage: T2z2 = T2+T2x
sage: T3z1 = T3+T3
sage: T3z2 = T3+T3x
sage: timeit("T0z1==T0z2", number=100000)
100000 loops, best of 3: 206 ns per loop
sage: timeit("T1z1==T1z2", number=100000)
100000 loops, best of 3: 308 ns per loop
sage: timeit("T2z1==T2z2", number=100000)
100000 loops, best of 3: 640 ns per loop
sage: timeit("T3z1==T3z2", number=100000)
100000 loops, best of 3: 47.8 µs per loop
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0z1==S0z2", number=100000)
100000 loops, best of 3: 585 ns per loop
sage: timeit("S1z1==S1z2", number=100000)
100000 loops, best of 3: 494 ns per loop
sage: timeit("S2z1==S2z2", number=100000)
100000 loops, best of 3: 555 ns per loop
sage: timeit("S3z1==S3z2", number=100000)
100000 loops, best of 3: 578 ns per loop
```

__Hash__

This is the only operation for which bounded integer sequences seem to be consistently faster than tuples:

```
sage: timeit("hash(T0)", number=100000)
100000 loops, best of 3: 179 ns per loop
sage: timeit("hash(T0)", number=1000000)
1000000 loops, best of 3: 177 ns per loop
sage: timeit("hash(T1)", number=1000000)
1000000 loops, best of 3: 267 ns per loop
sage: timeit("hash(T2)", number=1000000)
1000000 loops, best of 3: 584 ns per loop
sage: timeit("hash(T3)", number=100000)
100000 loops, best of 3: 45.3 µs per loop
sage: timeit("hash(S0)", number=1000000)
1000000 loops, best of 3: 145 ns per loop
sage: timeit("hash(S1)", number=1000000)
1000000 loops, best of 3: 153 ns per loop
sage: timeit("hash(S2)", number=1000000)
1000000 loops, best of 3: 194 ns per loop
sage: timeit("hash(S3)", number=1000000)
1000000 loops, best of 3: 8.97 µs per loop
```

__Concatenation__

```
sage: timeit("T0+T0", number=1000000)
1000000 loops, best of 3: 200 ns per loop
sage: timeit("T1+T1", number=1000000)
1000000 loops, best of 3: 311 ns per loop
sage: timeit("T2+T2", number=1000000)
1000000 loops, best of 3: 742 ns per loop
sage: timeit("T3+T3", number=10000)
10000 loops, best of 3: 40.3 µs per loop
sage: timeit("S0+S0", number=1000000)
1000000 loops, best of 3: 576 ns per loop
sage: timeit("S1+S1", number=1000000)
1000000 loops, best of 3: 590 ns per loop
sage: timeit("S2+S2", number=1000000)
1000000 loops, best of 3: 618 ns per loop
sage: timeit("S3+S3", number=1000000)
1000000 loops, best of 3: 2.17 µs per loop
```

__Subsequences__

Recall the definition of `S0z1` etc. We find:

```
sage: S0z2.startswith(S0)
True
sage: S0z2.startswith(S0x)
False
sage: S0x in S0z2
True
sage: timeit("S0z2.startswith(S0)", number=1000000)
1000000 loops, best of 3: 239 ns per loop
sage: timeit("S0z2.startswith(S0x)", number=1000000)
1000000 loops, best of 3: 241 ns per loop
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 694 ns per loop
sage: timeit("S1z2.startswith(S1)", number=1000000)
1000000 loops, best of 3: 227 ns per loop
sage: timeit("S1z2.startswith(S1x)", number=1000000)
1000000 loops, best of 3: 223 ns per loop
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 1.08 µs per loop
sage: timeit("S2z2.startswith(S2)", number=1000000)
1000000 loops, best of 3: 247 ns per loop
sage: timeit("S2z2.startswith(S2x)", number=1000000)
1000000 loops, best of 3: 230 ns per loop
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 3.21 µs per loop
sage: timeit("S3z2.startswith(S3)", number=1000000)
1000000 loops, best of 3: 989 ns per loop
sage: timeit("S3z2.startswith(S3x)", number=1000000)
1000000 loops, best of 3: 218 ns per loop
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 3.57 ms per loop
```
I wonder if the latter could be improved. Another "TODO"...

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8">5dc78c5</a></td><td><code>Implement sequences of bounded integers</code></td></tr></table>




---

archive/issue_comments_203848.json:
```json
{
    "body": "**Author:** Simon King",
    "created_at": "2014-05-27T16:02:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203848",
    "user": "https://github.com/simon-king-jena"
}
```

**Author:** Simon King



---

archive/issue_events_143576.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-27T16:02:09Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143576"
}
```



---

archive/issue_comments_203849.json:
```json
{
    "body": "**Commit:** [5dc78c5f5f647bf95b98da916d7086fae539ffb8](https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8)",
    "created_at": "2014-05-27T16:02:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203849",
    "user": "https://github.com/simon-king-jena"
}
```

**Commit:** [5dc78c5f5f647bf95b98da916d7086fae539ffb8](https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8)



---

archive/issue_comments_203850.json:
```json
{
    "body": "<a id='comment:51'></a>\nReplying to [ncohen](#comment%3A48):\n> None from me. I keep being impressed at how much testing/researching you put into this quiver features... I really wonder what you will do with it in the end `;-)`\n\n\n- Gr\u00f6bner bases for modules over path algebra quotients.\n- In particular, an implementation of the non-commutative version of Faug\u00e8re's F5 algorithm that I have described in my latest article.\n- Compute minimal generating sets for modules over so-called \"basic algebras\" (that's a special type of path algebra quotients), which is possible with the non-commutative F5, as shown in my latest article.\n- Use all this to compute minimal projective resolutions of basic algebras, but please be faster than what we currently do in our optional group cohomology spkg. Currently, we use a method of David Green for computing the minimal resolutions; but F5 should be more efficient---theoretically...\n\nThat said: I guess it would make sense to adopt bounded integer sequences in appropriate parts of sage.combinat.words, but I leave this to others.",
    "created_at": "2014-05-27T16:10:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203850",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:51'></a>
Replying to [ncohen](#comment%3A48):
> None from me. I keep being impressed at how much testing/researching you put into this quiver features... I really wonder what you will do with it in the end `;-)`


- Gröbner bases for modules over path algebra quotients.
- In particular, an implementation of the non-commutative version of Faugère's F5 algorithm that I have described in my latest article.
- Compute minimal generating sets for modules over so-called "basic algebras" (that's a special type of path algebra quotients), which is possible with the non-commutative F5, as shown in my latest article.
- Use all this to compute minimal projective resolutions of basic algebras, but please be faster than what we currently do in our optional group cohomology spkg. Currently, we use a method of David Green for computing the minimal resolutions; but F5 should be more efficient---theoretically...

That said: I guess it would make sense to adopt bounded integer sequences in appropriate parts of sage.combinat.words, but I leave this to others.



---

archive/issue_comments_203851.json:
```json
{
    "body": "<a id='comment:52'></a>\nHellooooooo Simon !\n\nSorry but I only began to read your code and now I should really go get some\nsleep. I paste my current notes here in the meantime, but I am a long way from a\nproper review job.\n\n- bounded integer sequence, biseq. What about \"integer sequence\" ? All integers\n  are \"bounded\" on a computer. Why add this \"bounded\" everywhere ? biseq -> iseq\n  ?\n\n- `# Bitsize of \"data\"` --> bitsize of the whole sequence\n\n- itembitsize --> necessarily a power of 2 ?\n\n- `#cdef inline void dealloc_biseq(biseq_t S)` : why there if commented ?\n\n- `list2biseq` (and others) -> `list_to_biseq` ?\n\n- Comments on the function definitions --> Move it to the function's doc, even\n  if it is their only content ?\n\n- Could you write some doc, even if it is just one line, for cdef functions ? A\n  bit like what we have for bitsets ? Something like\n\n```\ncdef biseq_t* allocate_biseq(size_t l, unsigned long int itemsize):\n     \"\"\"\n     Allocates a sequences of l integers stored on itemsize bits each.\n     \"\"\"\n```\n\n- I just figured out that you may have wanted to keep this list of functions\n  above with short descriptions as an 'index' of what the file does. If so, it\n  would be cool to do it in the html doc instead ! It is nice to have\n  documentation for C functions even if you have to do it by hand.. An example\n  there :\n  http://www.sagemath.org/doc/reference/graphs/sage/graphs/base/static_sparse_graph.html\n\n- list2biseq --> I wondered why this function wouldn't return a new biseq buil\n  from a list instead of modifying an existing one.... Performance issue ? Is\n  that critical in some cases ?\n\nNathann",
    "created_at": "2014-05-27T22:22:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203851",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:52'></a>
Hellooooooo Simon !

Sorry but I only began to read your code and now I should really go get some
sleep. I paste my current notes here in the meantime, but I am a long way from a
proper review job.

- bounded integer sequence, biseq. What about "integer sequence" ? All integers
  are "bounded" on a computer. Why add this "bounded" everywhere ? biseq -> iseq
  ?

- `# Bitsize of "data"` --> bitsize of the whole sequence

- itembitsize --> necessarily a power of 2 ?

- `#cdef inline void dealloc_biseq(biseq_t S)` : why there if commented ?

- `list2biseq` (and others) -> `list_to_biseq` ?

- Comments on the function definitions --> Move it to the function's doc, even
  if it is their only content ?

- Could you write some doc, even if it is just one line, for cdef functions ? A
  bit like what we have for bitsets ? Something like

```
cdef biseq_t* allocate_biseq(size_t l, unsigned long int itemsize):
     """
     Allocates a sequences of l integers stored on itemsize bits each.
     """
```

- I just figured out that you may have wanted to keep this list of functions
  above with short descriptions as an 'index' of what the file does. If so, it
  would be cool to do it in the html doc instead ! It is nice to have
  documentation for C functions even if you have to do it by hand.. An example
  there :
  http://www.sagemath.org/doc/reference/graphs/sage/graphs/base/static_sparse_graph.html

- list2biseq --> I wondered why this function wouldn't return a new biseq buil
  from a list instead of modifying an existing one.... Performance issue ? Is
  that critical in some cases ?

Nathann



---

archive/issue_comments_203852.json:
```json
{
    "body": "<a id='comment:53'></a>\nReplying to [ncohen](#comment%3A52):\n> - bounded integer sequence, biseq. What about \"integer sequence\" ?\n\n\nNot good, because...\n\n>  All integers are \"bounded\" on a computer. Why add this \"bounded\" everywhere ? biseq -> iseq\n\n\n... the computer's integer bound is chosen when you buy the machine, but not when you create the sequence.\n\nThe point is that each \"bounded integer sequence\" has a bound `B` that can be *chosen upon initialisation* so that any item of the sequence is smaller than `B`.\n\n> - `# Bitsize of \"data\"` --> bitsize of the whole sequence\n\n\nOK.\n \n> - itembitsize --> necessarily a power of 2 ?\n\n\nNo. Here, it is really \"bit\" size. So, the number tells how many bits will be reserved to store one item. Hence, the bound `B` above is a power of two, namely `2^itembitsize`.\n\n> - `#cdef inline void dealloc_biseq(biseq_t S)` : why there if commented ?\n\n\nBecause I forgot to remove it.\n\n> - `list2biseq` (and others) -> `list_to_biseq` ?\n\n\nAcceptable.\n\n> - Comments on the function definitions --> Move it to the function's doc, even\n>   if it is their only content ?\n> - Could you write some doc, even if it is just one line, for cdef functions ? \n\n\nI wouldn't remove the comments from the pxd file, but certainly some documentation should be added to the cdef functions in the pyx file. I wonder if this should be by comments in the code or by a doc string. After all, the doc string will not be visible (cdef functions won't appear in the docs, as they can not imported).\n\n> - I just figured out that you may have wanted to keep this list of functions\n>   above with short descriptions as an 'index' of what the file does. If so, it\n>   would be cool to do it in the html doc instead !\n\n\nYou mean: \"This file provides the following boilerplate functions, that you can cimport for usage in Cython code: ...\"?\n\n> - list2biseq --> I wondered why this function wouldn't return a new biseq buil\n>   from a list instead of modifying an existing one.... Performance issue ? Is\n>   that critical in some cases ?\n\n\nThis is motivated by my usage in the `BoundedIntegerSequence` wrapper. As usual, there is `__cinit__` which does memory allocations (as much as I know, it is recommended to not do this kind of things in `__init__`). Hence, when `__init__` is called (and I think filling data into the allocated memory is the job of `__init__`, not of `__cinit__`), then the integer sequence already is allocated, and just needs to be filled.",
    "created_at": "2014-05-28T10:14:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203852",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:53'></a>
Replying to [ncohen](#comment%3A52):
> - bounded integer sequence, biseq. What about "integer sequence" ?


Not good, because...

>  All integers are "bounded" on a computer. Why add this "bounded" everywhere ? biseq -> iseq


... the computer's integer bound is chosen when you buy the machine, but not when you create the sequence.

The point is that each "bounded integer sequence" has a bound `B` that can be *chosen upon initialisation* so that any item of the sequence is smaller than `B`.

> - `# Bitsize of "data"` --> bitsize of the whole sequence


OK.
 
> - itembitsize --> necessarily a power of 2 ?


No. Here, it is really "bit" size. So, the number tells how many bits will be reserved to store one item. Hence, the bound `B` above is a power of two, namely `2^itembitsize`.

> - `#cdef inline void dealloc_biseq(biseq_t S)` : why there if commented ?


Because I forgot to remove it.

> - `list2biseq` (and others) -> `list_to_biseq` ?


Acceptable.

> - Comments on the function definitions --> Move it to the function's doc, even
>   if it is their only content ?
> - Could you write some doc, even if it is just one line, for cdef functions ? 


I wouldn't remove the comments from the pxd file, but certainly some documentation should be added to the cdef functions in the pyx file. I wonder if this should be by comments in the code or by a doc string. After all, the doc string will not be visible (cdef functions won't appear in the docs, as they can not imported).

> - I just figured out that you may have wanted to keep this list of functions
>   above with short descriptions as an 'index' of what the file does. If so, it
>   would be cool to do it in the html doc instead !


You mean: "This file provides the following boilerplate functions, that you can cimport for usage in Cython code: ..."?

> - list2biseq --> I wondered why this function wouldn't return a new biseq buil
>   from a list instead of modifying an existing one.... Performance issue ? Is
>   that critical in some cases ?


This is motivated by my usage in the `BoundedIntegerSequence` wrapper. As usual, there is `__cinit__` which does memory allocations (as much as I know, it is recommended to not do this kind of things in `__init__`). Hence, when `__init__` is called (and I think filling data into the allocated memory is the job of `__init__`, not of `__cinit__`), then the integer sequence already is allocated, and just needs to be filled.



---

archive/issue_comments_203853.json:
```json
{
    "body": "<a id='comment:54'></a>\nSorry it that's a stupid question (I only glanced through the code), but why are you using `mpz`'s and not `mpn`'s? It looks like you are already doing most if not all memory management by hand...",
    "created_at": "2014-05-28T12:41:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203853",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:54'></a>
Sorry it that's a stupid question (I only glanced through the code), but why are you using `mpz`'s and not `mpn`'s? It looks like you are already doing most if not all memory management by hand...



---

archive/issue_comments_203854.json:
```json
{
    "body": "<a id='comment:55'></a>\nReplying to [mmezzarobba](#comment%3A54):\n> Sorry it that's a stupid question (I only glanced through the code), but why are you using `mpz`'s and not `mpn`'s?\n\n\nSimply because I did not succeed in finding what functions are available for `mpn_t`. So, if you can give me a pointer (similar to [the documentation for `mpz_t`](https://gmplib.org/manual/Integer-Functions.html#Integer-Functions)), I'd appreciate. Probably non-signed types will be a tad faster than signed types.\n\n> It looks like you are already doing most if not all memory management by hand...\n\n\nWhat would be the alternative to doing so? I mean, what I need is some tool to quickly operate on large bit arrays by shift operations, preferably also with a good and fast hash function, and without the need to think about the number of bits fitting into a byte or a long. I tried to implement this myself, using `char*` or `long*` (which would also mean to take care of allocating and freeing), but `mpz_t` turns out to be faster.\n\nSo, if you know another tool, that is perhaps more directly dedicated to bit arrays, then please tell!",
    "created_at": "2014-05-28T14:23:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203854",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:55'></a>
Replying to [mmezzarobba](#comment%3A54):
> Sorry it that's a stupid question (I only glanced through the code), but why are you using `mpz`'s and not `mpn`'s?


Simply because I did not succeed in finding what functions are available for `mpn_t`. So, if you can give me a pointer (similar to [the documentation for `mpz_t`](https://gmplib.org/manual/Integer-Functions.html#Integer-Functions)), I'd appreciate. Probably non-signed types will be a tad faster than signed types.

> It looks like you are already doing most if not all memory management by hand...


What would be the alternative to doing so? I mean, what I need is some tool to quickly operate on large bit arrays by shift operations, preferably also with a good and fast hash function, and without the need to think about the number of bits fitting into a byte or a long. I tried to implement this myself, using `char*` or `long*` (which would also mean to take care of allocating and freeing), but `mpz_t` turns out to be faster.

So, if you know another tool, that is perhaps more directly dedicated to bit arrays, then please tell!



---

archive/issue_comments_203855.json:
```json
{
    "body": "<a id='comment:56'></a>\nReplying to [SimonKing](#comment%3A55):\n> Simply because I did not succeed in finding what functions are available for `mpn_t`. So, if you can give me a pointer (similar to [the documentation for `mpz_t`](https://gmplib.org/manual/Integer-Functions.html#Integer-Functions)), I'd appreciate.\n\n\nThe documentation for `mpn_*` is at https://gmplib.org/manual/Low_002dlevel-Functions.html\n\n> > It looks like you are already doing most if not all memory management by hand...\n\n> \n> What would be the alternative to doing so?\n\n\nI'm not saying I see one, only that, as far as I understand, automatic memory management is the main advantage of `mpz_t` over `mpn_*` when you are dealing with nonnegative integers (hence my first question).",
    "created_at": "2014-05-28T14:36:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203855",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:56'></a>
Replying to [SimonKing](#comment%3A55):
> Simply because I did not succeed in finding what functions are available for `mpn_t`. So, if you can give me a pointer (similar to [the documentation for `mpz_t`](https://gmplib.org/manual/Integer-Functions.html#Integer-Functions)), I'd appreciate.


The documentation for `mpn_*` is at https://gmplib.org/manual/Low_002dlevel-Functions.html

> > It looks like you are already doing most if not all memory management by hand...

> 
> What would be the alternative to doing so?


I'm not saying I see one, only that, as far as I understand, automatic memory management is the main advantage of `mpz_t` over `mpn_*` when you are dealing with nonnegative integers (hence my first question).



---

archive/issue_comments_203856.json:
```json
{
    "body": "<a id='comment:57'></a>\nReplying to [mmezzarobba](#comment%3A56):\n> The documentation for `mpn_*` is at https://gmplib.org/manual/Low_002dlevel-Functions.html\n\n\nThank you, I'll have a look and will try to compare.\n \n> > > It looks like you are already doing most if not all memory management by hand...\n\n> > \n> > What would be the alternative to doing so?\n\n> \n> I'm not saying I see one, only that, as far as I understand, automatic memory management is the main advantage of `mpz_t` over `mpn_*` when you are dealing with nonnegative integers (hence my first question).\n\n\nNow I understand what you mean by your statement that I did all memory management by hand: I am not using `mpz_init` but `mpz_init2`, telling exactly how many bits I will need. I found that it has a noticeable impact on performance, since otherwise re-allocations will happen internally.",
    "created_at": "2014-05-28T14:45:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203856",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:57'></a>
Replying to [mmezzarobba](#comment%3A56):
> The documentation for `mpn_*` is at https://gmplib.org/manual/Low_002dlevel-Functions.html


Thank you, I'll have a look and will try to compare.
 
> > > It looks like you are already doing most if not all memory management by hand...

> > 
> > What would be the alternative to doing so?

> 
> I'm not saying I see one, only that, as far as I understand, automatic memory management is the main advantage of `mpz_t` over `mpn_*` when you are dealing with nonnegative integers (hence my first question).


Now I understand what you mean by your statement that I did all memory management by hand: I am not using `mpz_init` but `mpz_init2`, telling exactly how many bits I will need. I found that it has a noticeable impact on performance, since otherwise re-allocations will happen internally.



---

archive/issue_comments_203857.json:
```json
{
    "body": "<a id='comment:58'></a>\nReplying to [SimonKing](#comment%3A57):\n> Now I understand what you mean by your statement that I did all memory management by hand: I am not using `mpz_init` but `mpz_init2`\n\n\nYes, exactly. Sorry if I wasn't clear!",
    "created_at": "2014-05-28T14:51:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203857",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:58'></a>
Replying to [SimonKing](#comment%3A57):
> Now I understand what you mean by your statement that I did all memory management by hand: I am not using `mpz_init` but `mpz_init2`


Yes, exactly. Sorry if I wasn't clear!



---

archive/issue_comments_203858.json:
```json
{
    "body": "<a id='comment:59'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7ceac67e9c46343b83922d853f262f6b06635453\">7ceac67</a></td><td><code>Merge branch 'develop' into ticket/15820</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301\">efef80b</a></td><td><code>Relocate bounded integer sequences (sage.misc, not sage.structure)</code></td></tr></table>\n",
    "created_at": "2014-05-30T12:55:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203858",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:59'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7ceac67e9c46343b83922d853f262f6b06635453">7ceac67</a></td><td><code>Merge branch 'develop' into ticket/15820</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301">efef80b</a></td><td><code>Relocate bounded integer sequences (sage.misc, not sage.structure)</code></td></tr></table>




---

archive/issue_comments_203859.json:
```json
{
    "body": "**Changing commit** from \"[5dc78c5f5f647bf95b98da916d7086fae539ffb8](https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8)\" to \"[efef80bea22840f618335b7dd6f5d3e9a64fa301](https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301)\".",
    "created_at": "2014-05-30T12:55:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203859",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[5dc78c5f5f647bf95b98da916d7086fae539ffb8](https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8)" to "[efef80bea22840f618335b7dd6f5d3e9a64fa301](https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301)".



---

archive/issue_comments_203860.json:
```json
{
    "body": "<a id='comment:60'></a>\nI have at some point merged the latest beta. Sorry, I keep forgetting that merging stuff prematurely is bad. Main point was to relocate the code from sage.structure to sage.misc.\n\nI don't think I will use `mpn_*`. It just seems too low-level. For example, I see `mpn_lshift` and `mpn_rshift` operations, but they operate on limbs, not on bit arrays. Hence, in order to implement a bitshift on bit arrays (which is what I need in concatenation and many other operations), I'd still need to invest a lot of work, essentially what I have done with the proof-of-concept using `long*` to store bit arrays. I doubt that in the end it would be any faster than using `mpz_mul_2exp` and friends.\n\nDocumentation of the cdef functions is still missing, this is what I intend to do next.",
    "created_at": "2014-05-30T13:03:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203860",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:60'></a>
I have at some point merged the latest beta. Sorry, I keep forgetting that merging stuff prematurely is bad. Main point was to relocate the code from sage.structure to sage.misc.

I don't think I will use `mpn_*`. It just seems too low-level. For example, I see `mpn_lshift` and `mpn_rshift` operations, but they operate on limbs, not on bit arrays. Hence, in order to implement a bitshift on bit arrays (which is what I need in concatenation and many other operations), I'd still need to invest a lot of work, essentially what I have done with the proof-of-concept using `long*` to store bit arrays. I doubt that in the end it would be any faster than using `mpz_mul_2exp` and friends.

Documentation of the cdef functions is still missing, this is what I intend to do next.



---

archive/issue_comments_203861.json:
```json
{
    "body": "**Work_Issues:** Document cdef functions",
    "created_at": "2014-05-30T13:03:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203861",
    "user": "https://github.com/simon-king-jena"
}
```

**Work_Issues:** Document cdef functions



---

archive/issue_events_143577.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-30T13:03:53Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143577"
}
```



---

archive/issue_events_143578.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-30T13:03:53Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143578"
}
```



---

archive/issue_comments_203862.json:
```json
{
    "body": "<a id='comment:61'></a>\nIf you use mpz functions, then getting/setting a single entry will be O(n) instead of O(1), and iterating over all entries or creating a sequence from a list of integers will be O(n<sup>2</sup>) instead of O(n). This makes the implementation rather useless for a lot of applications where a datatype like this would be useful (say if you want to store a million small integers in a memory-efficient way). With mpn functions, you can get the optimal complexity.",
    "created_at": "2014-05-30T16:10:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203862",
    "user": "https://github.com/fredrik-johansson"
}
```

<a id='comment:61'></a>
If you use mpz functions, then getting/setting a single entry will be O(n) instead of O(1), and iterating over all entries or creating a sequence from a list of integers will be O(n<sup>2</sup>) instead of O(n). This makes the implementation rather useless for a lot of applications where a datatype like this would be useful (say if you want to store a million small integers in a memory-efficient way). With mpn functions, you can get the optimal complexity.



---

archive/issue_comments_203863.json:
```json
{
    "body": "<a id='comment:62'></a>\nReplying to [fredrik.johansson](#comment%3A61):\n> If you use mpz functions, then getting/setting a single entry will be O(n) instead of O(1), and iterating over all entries or creating a sequence from a list of integers will be O(n<sup>2</sup>) instead of O(n).\n\n\nRight, iteration, access to single items and creation from a list is not as fast as it could be. Can you point me to examples (in Sage? Elsewhere?) showeing how to use 'mpn_*`?\n\nPS: I also forgot to implement pickling.",
    "created_at": "2014-05-30T20:47:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203863",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:62'></a>
Replying to [fredrik.johansson](#comment%3A61):
> If you use mpz functions, then getting/setting a single entry will be O(n) instead of O(1), and iterating over all entries or creating a sequence from a list of integers will be O(n<sup>2</sup>) instead of O(n).


Right, iteration, access to single items and creation from a list is not as fast as it could be. Can you point me to examples (in Sage? Elsewhere?) showeing how to use 'mpn_*`?

PS: I also forgot to implement pickling.



---

archive/issue_comments_203864.json:
```json
{
    "body": "**Changing work_issues** from \"Document cdef functions\" to \"Document cdef functions. Pickling\".",
    "created_at": "2014-05-30T20:47:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203864",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "Document cdef functions" to "Document cdef functions. Pickling".



---

archive/issue_comments_203865.json:
```json
{
    "body": "<a id='comment:63'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8\">64ac7ba</a></td><td><code>Pickling of bounded integer sequence. Documentation of cdef functions</code></td></tr></table>\n",
    "created_at": "2014-05-30T21:43:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203865",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:63'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8">64ac7ba</a></td><td><code>Pickling of bounded integer sequence. Documentation of cdef functions</code></td></tr></table>




---

archive/issue_comments_203866.json:
```json
{
    "body": "**Changing commit** from \"[efef80bea22840f618335b7dd6f5d3e9a64fa301](https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301)\" to \"[64ac7bab9d4c85136e9845878d69d82be7c300f8](https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8)\".",
    "created_at": "2014-05-30T21:43:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203866",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[efef80bea22840f618335b7dd6f5d3e9a64fa301](https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301)" to "[64ac7bab9d4c85136e9845878d69d82be7c300f8](https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8)".



---

archive/issue_comments_203867.json:
```json
{
    "body": "**Changing work_issues** from \"Document cdef functions. Pickling\" to \"Use mpn_* for speedup of iteration and item access\".",
    "created_at": "2014-05-30T21:46:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203867",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "Document cdef functions. Pickling" to "Use mpn_* for speedup of iteration and item access".



---

archive/issue_comments_203868.json:
```json
{
    "body": "<a id='comment:64'></a>\nI have documented the cdef functions, and I have implemented pickling. Again (at least for long sequence), this is faster than for ordinary tuples:\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: L = [randint(0,26) for i in range(5000)]\nsage: S = BoundedIntegerSequence(32, L)\nsage: %timeit loads(dumps(S))\n1000 loops, best of 3: 407 \u00b5s per loop\nsage: T = tuple(S)\nsage: %timeit loads(dumps(T))\n100 loops, best of 3: 2.02 ms per loop\n```\n\nI hope there is a nice example for `mpn_*` somewhere.",
    "created_at": "2014-05-30T21:46:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203868",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:64'></a>
I have documented the cdef functions, and I have implemented pickling. Again (at least for long sequence), this is faster than for ordinary tuples:

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: L = [randint(0,26) for i in range(5000)]
sage: S = BoundedIntegerSequence(32, L)
sage: %timeit loads(dumps(S))
1000 loops, best of 3: 407 µs per loop
sage: T = tuple(S)
sage: %timeit loads(dumps(T))
100 loops, best of 3: 2.02 ms per loop
```

I hope there is a nice example for `mpn_*` somewhere.



---

archive/issue_comments_203869.json:
```json
{
    "body": "<a id='comment:65'></a>\nHooray, using mpn_* improves the time to access item 2000 in an integer sequence of bound 32 from 1.49 \u00b5s to 545 ns. With tuples, the access time is 362 ns. So, that's almost competitive.",
    "created_at": "2014-05-31T19:25:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203869",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:65'></a>
Hooray, using mpn_* improves the time to access item 2000 in an integer sequence of bound 32 from 1.49 µs to 545 ns. With tuples, the access time is 362 ns. So, that's almost competitive.



---

archive/issue_comments_203870.json:
```json
{
    "body": "<a id='comment:66'></a>\nAnother hooray: Conversion of a list of 5000 integers to a bounded integer sequence of bound 32 improved from 3.25 ms to 75.3 \u00b5s. Conversion to a tuple only takes 19.6 \u00b5s, but I doubt that this will be possible to beat.",
    "created_at": "2014-06-01T01:57:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203870",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:66'></a>
Another hooray: Conversion of a list of 5000 integers to a bounded integer sequence of bound 32 improved from 3.25 ms to 75.3 µs. Conversion to a tuple only takes 19.6 µs, but I doubt that this will be possible to beat.



---

archive/issue_comments_203871.json:
```json
{
    "body": "<a id='comment:67'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/050b118c9ce92b3c640ad4ea66b5c02dce87a172\">050b118</a></td><td><code>Improve access to items of bounded integer sequences</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c2e35470203398b1636175965cc8b1fdc89549b9\">c2e3547</a></td><td><code>Improve conversion \"list->bounded integer sequence\"</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7\">836f63f</a></td><td><code>Improve iteration and list/string conversion of bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-06-01T12:02:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203871",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:67'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/050b118c9ce92b3c640ad4ea66b5c02dce87a172">050b118</a></td><td><code>Improve access to items of bounded integer sequences</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c2e35470203398b1636175965cc8b1fdc89549b9">c2e3547</a></td><td><code>Improve conversion "list->bounded integer sequence"</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7">836f63f</a></td><td><code>Improve iteration and list/string conversion of bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_203872.json:
```json
{
    "body": "**Changing commit** from \"[64ac7bab9d4c85136e9845878d69d82be7c300f8](https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8)\" to \"[836f63fb96241033953e42d6d18becfaa4fe33b7](https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7)\".",
    "created_at": "2014-06-01T12:02:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203872",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[64ac7bab9d4c85136e9845878d69d82be7c300f8](https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8)" to "[836f63fb96241033953e42d6d18becfaa4fe33b7](https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7)".



---

archive/issue_comments_203873.json:
```json
{
    "body": "<a id='comment:68'></a>\nThere remains to improve computation of the index of an item or of a sub-sequence, and slicing. When this is done, I'll provide updated benchmarks.",
    "created_at": "2014-06-01T12:03:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203873",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:68'></a>
There remains to improve computation of the index of an item or of a sub-sequence, and slicing. When this is done, I'll provide updated benchmarks.



---

archive/issue_comments_203874.json:
```json
{
    "body": "<a id='comment:69'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515\">c8a299b</a></td><td><code>More documentation of bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-06-01T12:37:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203874",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:69'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515">c8a299b</a></td><td><code>More documentation of bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_203875.json:
```json
{
    "body": "**Changing commit** from \"[836f63fb96241033953e42d6d18becfaa4fe33b7](https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7)\" to \"[c8a299ba54fa05d6851fd492019d9996e7e31515](https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515)\".",
    "created_at": "2014-06-01T12:37:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203875",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[836f63fb96241033953e42d6d18becfaa4fe33b7](https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7)" to "[c8a299ba54fa05d6851fd492019d9996e7e31515](https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515)".



---

archive/issue_comments_203876.json:
```json
{
    "body": "<a id='comment:70'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/775d7955c67cb27af3ec8877491a3d7478fa8579\">775d795</a></td><td><code>Improve index computation for bounded integer sequences</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/391a102f2b5623979c214a725092eeb3dbe180f6\">391a102</a></td><td><code>Improve bounded integer subsequent containment test</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644\">735939e</a></td><td><code>Improve slicing of bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-06-03T10:13:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203876",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:70'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/775d7955c67cb27af3ec8877491a3d7478fa8579">775d795</a></td><td><code>Improve index computation for bounded integer sequences</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/391a102f2b5623979c214a725092eeb3dbe180f6">391a102</a></td><td><code>Improve bounded integer subsequent containment test</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644">735939e</a></td><td><code>Improve slicing of bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_203877.json:
```json
{
    "body": "**Changing commit** from \"[c8a299ba54fa05d6851fd492019d9996e7e31515](https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515)\" to \"[735939e593c9c302ff42c4973cbfe2e48eb22644](https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644)\".",
    "created_at": "2014-06-03T10:13:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203877",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[c8a299ba54fa05d6851fd492019d9996e7e31515](https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515)" to "[735939e593c9c302ff42c4973cbfe2e48eb22644](https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644)".



---

archive/issue_comments_203878.json:
```json
{
    "body": "<a id='comment:71'></a>\nUsing the `mpn_*` function was a very good idea. Some basic operations are a lot faster now. Here I am repeating (and slightly extending) my earlier benchmarks for those operations that have changed in the recent commits:\n\n__The test bed__\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\n```\n\n__Conversion list -> tuple/sequence__\n\n```\nsage: %timeit x = tuple(L0)\n1000000 loops, best of 3: 307 ns per loop\nsage: %timeit x = tuple(L1)\n1000000 loops, best of 3: 369 ns per loop\nsage: %timeit x = tuple(L2)\n1000000 loops, best of 3: 534 ns per loop\nsage: %timeit x = tuple(L3)\n10000 loops, best of 3: 19.6 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.34 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n1000000 loops, best of 3: 1.57 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n100000 loops, best of 3: 2.06 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n10000 loops, best of 3: 76.7 \u00b5s per loop\n```\nConversion to a tuple seems to be roughly 4 times faster. But I don't think this will be critical (at least not in my own applications...)\n\n__Conversion tuple/sequence -> list__\n\n```\nsage: %timeit x = list(T0)\n1000000 loops, best of 3: 537 ns per loop\nsage: %timeit x = list(T1)\n1000000 loops, best of 3: 624 ns per loop\nsage: %timeit x = list(T2)\n1000000 loops, best of 3: 752 ns per loop\nsage: %timeit x = list(T3)\n100000 loops, best of 3: 22.6 \u00b5s per loop\nsage: %timeit x = list(S0)\n1000000 loops, best of 3: 1.58 \u00b5s per loop\nsage: %timeit x = list(S1)\n100000 loops, best of 3: 2.06 \u00b5s per loop\nsage: %timeit x = list(S2)\n100000 loops, best of 3: 4.19 \u00b5s per loop\nsage: %timeit x = list(S3)\n1000 loops, best of 3: 253 \u00b5s per loop\nsage: %timeit x = S0.list()\n1000000 loops, best of 3: 1.05 \u00b5s per loop\nsage: %timeit x = S1.list()\n1000000 loops, best of 3: 1.87 \u00b5s per loop\nsage: %timeit x = S2.list()\n100000 loops, best of 3: 4.95 \u00b5s per loop\nsage: %timeit x = S3.list()\n1000 loops, best of 3: 306 \u00b5s per loop\n```\nThe gap between lists and sequences strongly depends on the bound of the sequence, which is not much of a surprise. Anyway, it is faster than before.\n\n__Slicing__\n\nFor step 1, short tuples are faster than short sequences, but long sequences are faster than long tuples:\n\n```\nsage: timeit(\"x=T0[:-1]\", number=100000)\n100000 loops, best of 3: 479 ns per loop\nsage: timeit(\"x=T1[:-1]\", number=100000)\n100000 loops, best of 3: 548 ns per loop\nsage: timeit(\"x=T2[:-1]\", number=100000)\n100000 loops, best of 3: 773 ns per loop\nsage: timeit(\"x=T3[:-1]\", number=100000)\n100000 loops, best of 3: 19.6 \u00b5s per loop\nsage: timeit(\"x=S0[:-1]\", number=100000)\n100000 loops, best of 3: 1.75 \u00b5s per loop\nsage: timeit(\"x=S1[:-1]\", number=100000)\n100000 loops, best of 3: 1.8 \u00b5s per loop\nsage: timeit(\"x=S2[:-1]\", number=100000)\n100000 loops, best of 3: 1.77 \u00b5s per loop\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 2.4 \u00b5s per loop\n```\nAs before, a step different from 1 is bad for sequences. However, there is an improvement compared with the previous timings:\n\n```\nsage: timeit(\"x=T2[:-1:2]\", number=100000)\n100000 loops, best of 3: 944 ns per loop\nsage: timeit(\"x=T3[:-1:2]\", number=100000)\n100000 loops, best of 3: 11.8 \u00b5s per loop\nsage: timeit(\"x=S2[:-1:2]\", number=10000)\n10000 loops, best of 3: 2.7 \u00b5s per loop\nsage: timeit(\"x=S3[:-1:2]\", number=10000)\n10000 loops, best of 3: 52.2 \u00b5s per loop\n```\n\n__Accessing single items__\n\nBounded integer sequences can now compete with tuples, both short and long!\n\n```\nsage: timeit(\"x=T0[1]\", number=1000000)\n1000000 loops, best of 3: 349 ns per loop\nsage: timeit(\"x=T0[4]\", number=1000000)\n1000000 loops, best of 3: 351 ns per loop\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 354 ns per loop\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 355 ns per loop\nsage: timeit(\"x=T3[1]\", number=1000000)\n1000000 loops, best of 3: 346 ns per loop\nsage: timeit(\"x=T3[4500]\", number=1000000)\n1000000 loops, best of 3: 347 ns per loop\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 350 ns per loop\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 370 ns per loop\n```\n\n__Containment tests__\n\nHere we talk about operations that do not exist in this form for tuples (e.g., subsequence tests). They have been improved by the latest commits:\n\n```\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: S1y = BoundedIntegerSequence(16, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S1y==S1!=S1x, S1y is not S1\n(True, True)\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0z2.startswith(S0)\", number=1000000)\n1000000 loops, best of 3: 230 ns per loop\nsage: timeit(\"S0z2.startswith(S0x)\", number=1000000)\n1000000 loops, best of 3: 236 ns per loop\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 511 ns per loop\nsage: timeit(\"S1z2.startswith(S1)\", number=1000000)\n1000000 loops, best of 3: 215 ns per loop\nsage: timeit(\"S1z2.startswith(S1x)\", number=1000000)\n1000000 loops, best of 3: 219 ns per loop\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 692 ns per loop\nsage: timeit(\"S2z2.startswith(S2)\", number=1000000)\n1000000 loops, best of 3: 238 ns per loop\nsage: timeit(\"S2z2.startswith(S2x)\", number=1000000)\n1000000 loops, best of 3: 228 ns per loop\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 1.92 \u00b5s per loop\nsage: timeit(\"S3z2.startswith(S3)\", number=1000000)\n1000000 loops, best of 3: 981 ns per loop\nsage: timeit(\"S3z2.startswith(S3x)\", number=1000000)\n1000000 loops, best of 3: 213 ns per loop\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 2.41 ms per loop\n```\n\n__Conclusion__\n\n- Slicing and iteration are still a weak point of bounded integer sequences. However, there is an improvement by the latest commits.\n- Access to single items is now competitive. Some other operations have been competitive or superior before.\n- Probably iteration and slicing could be improved with more complicated code: Currently, I take a single item, do a bitshift (which is faster than before!) and then proceed with the next item. But since several items usually fit into one \"limb\" (this is how GMP stores the data), it would be possible to accumulate a group of items into one limb, then do a *single* bitshift for this group of items, and then proceed to the next group of items. I would consider to implement it if my own applications show the need for it...\n\nNeeds review, I think! Please check if I produced a memory leak (by not freeing allocated temporary data), a memory corruption (by messing up in the case of items that are stored exactly on the seam between two limbs), or functions in which a memory error or keyboard interrupt would not be propagated. I plan to do such tests, too, but I suppose 4 or 6 eyes see more than 2.",
    "created_at": "2014-06-03T11:17:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203878",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:71'></a>
Using the `mpn_*` function was a very good idea. Some basic operations are a lot faster now. Here I am repeating (and slightly extending) my earlier benchmarks for those operations that have changed in the recent commits:

__The test bed__

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
```

__Conversion list -> tuple/sequence__

```
sage: %timeit x = tuple(L0)
1000000 loops, best of 3: 307 ns per loop
sage: %timeit x = tuple(L1)
1000000 loops, best of 3: 369 ns per loop
sage: %timeit x = tuple(L2)
1000000 loops, best of 3: 534 ns per loop
sage: %timeit x = tuple(L3)
10000 loops, best of 3: 19.6 µs per loop
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.34 µs per loop
sage: %timeit x = BoundedIntegerSequence(16, L1)
1000000 loops, best of 3: 1.57 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L2)
100000 loops, best of 3: 2.06 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L3)
10000 loops, best of 3: 76.7 µs per loop
```
Conversion to a tuple seems to be roughly 4 times faster. But I don't think this will be critical (at least not in my own applications...)

__Conversion tuple/sequence -> list__

```
sage: %timeit x = list(T0)
1000000 loops, best of 3: 537 ns per loop
sage: %timeit x = list(T1)
1000000 loops, best of 3: 624 ns per loop
sage: %timeit x = list(T2)
1000000 loops, best of 3: 752 ns per loop
sage: %timeit x = list(T3)
100000 loops, best of 3: 22.6 µs per loop
sage: %timeit x = list(S0)
1000000 loops, best of 3: 1.58 µs per loop
sage: %timeit x = list(S1)
100000 loops, best of 3: 2.06 µs per loop
sage: %timeit x = list(S2)
100000 loops, best of 3: 4.19 µs per loop
sage: %timeit x = list(S3)
1000 loops, best of 3: 253 µs per loop
sage: %timeit x = S0.list()
1000000 loops, best of 3: 1.05 µs per loop
sage: %timeit x = S1.list()
1000000 loops, best of 3: 1.87 µs per loop
sage: %timeit x = S2.list()
100000 loops, best of 3: 4.95 µs per loop
sage: %timeit x = S3.list()
1000 loops, best of 3: 306 µs per loop
```
The gap between lists and sequences strongly depends on the bound of the sequence, which is not much of a surprise. Anyway, it is faster than before.

__Slicing__

For step 1, short tuples are faster than short sequences, but long sequences are faster than long tuples:

```
sage: timeit("x=T0[:-1]", number=100000)
100000 loops, best of 3: 479 ns per loop
sage: timeit("x=T1[:-1]", number=100000)
100000 loops, best of 3: 548 ns per loop
sage: timeit("x=T2[:-1]", number=100000)
100000 loops, best of 3: 773 ns per loop
sage: timeit("x=T3[:-1]", number=100000)
100000 loops, best of 3: 19.6 µs per loop
sage: timeit("x=S0[:-1]", number=100000)
100000 loops, best of 3: 1.75 µs per loop
sage: timeit("x=S1[:-1]", number=100000)
100000 loops, best of 3: 1.8 µs per loop
sage: timeit("x=S2[:-1]", number=100000)
100000 loops, best of 3: 1.77 µs per loop
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 2.4 µs per loop
```
As before, a step different from 1 is bad for sequences. However, there is an improvement compared with the previous timings:

```
sage: timeit("x=T2[:-1:2]", number=100000)
100000 loops, best of 3: 944 ns per loop
sage: timeit("x=T3[:-1:2]", number=100000)
100000 loops, best of 3: 11.8 µs per loop
sage: timeit("x=S2[:-1:2]", number=10000)
10000 loops, best of 3: 2.7 µs per loop
sage: timeit("x=S3[:-1:2]", number=10000)
10000 loops, best of 3: 52.2 µs per loop
```

__Accessing single items__

Bounded integer sequences can now compete with tuples, both short and long!

```
sage: timeit("x=T0[1]", number=1000000)
1000000 loops, best of 3: 349 ns per loop
sage: timeit("x=T0[4]", number=1000000)
1000000 loops, best of 3: 351 ns per loop
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 354 ns per loop
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 355 ns per loop
sage: timeit("x=T3[1]", number=1000000)
1000000 loops, best of 3: 346 ns per loop
sage: timeit("x=T3[4500]", number=1000000)
1000000 loops, best of 3: 347 ns per loop
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 350 ns per loop
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 370 ns per loop
```

__Containment tests__

Here we talk about operations that do not exist in this form for tuples (e.g., subsequence tests). They have been improved by the latest commits:

```
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: S1y = BoundedIntegerSequence(16, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S1y==S1!=S1x, S1y is not S1
(True, True)
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0z2.startswith(S0)", number=1000000)
1000000 loops, best of 3: 230 ns per loop
sage: timeit("S0z2.startswith(S0x)", number=1000000)
1000000 loops, best of 3: 236 ns per loop
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 511 ns per loop
sage: timeit("S1z2.startswith(S1)", number=1000000)
1000000 loops, best of 3: 215 ns per loop
sage: timeit("S1z2.startswith(S1x)", number=1000000)
1000000 loops, best of 3: 219 ns per loop
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 692 ns per loop
sage: timeit("S2z2.startswith(S2)", number=1000000)
1000000 loops, best of 3: 238 ns per loop
sage: timeit("S2z2.startswith(S2x)", number=1000000)
1000000 loops, best of 3: 228 ns per loop
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 1.92 µs per loop
sage: timeit("S3z2.startswith(S3)", number=1000000)
1000000 loops, best of 3: 981 ns per loop
sage: timeit("S3z2.startswith(S3x)", number=1000000)
1000000 loops, best of 3: 213 ns per loop
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 2.41 ms per loop
```

__Conclusion__

- Slicing and iteration are still a weak point of bounded integer sequences. However, there is an improvement by the latest commits.
- Access to single items is now competitive. Some other operations have been competitive or superior before.
- Probably iteration and slicing could be improved with more complicated code: Currently, I take a single item, do a bitshift (which is faster than before!) and then proceed with the next item. But since several items usually fit into one "limb" (this is how GMP stores the data), it would be possible to accumulate a group of items into one limb, then do a *single* bitshift for this group of items, and then proceed to the next group of items. I would consider to implement it if my own applications show the need for it...

Needs review, I think! Please check if I produced a memory leak (by not freeing allocated temporary data), a memory corruption (by messing up in the case of items that are stored exactly on the seam between two limbs), or functions in which a memory error or keyboard interrupt would not be propagated. I plan to do such tests, too, but I suppose 4 or 6 eyes see more than 2.



---

archive/issue_events_143579.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-03T11:17:38Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143579"
}
```



---

archive/issue_events_143580.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-03T11:17:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143580"
}
```



---

archive/issue_comments_203879.json:
```json
{
    "body": "<a id='comment:72'></a>\nI found failures in *some* runs:\n\n```\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-10-7f6bcfa0.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n**********************************************************************\nFile \"src/sage/misc/bounded_integer_sequences.pyx\", line 1059, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__\nFailed example:\n    S+T\nExpected:\n    <4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 15>\nGot:\n    <4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 31>\n**********************************************************************\n1 item had failures:\n   1 of  10 in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__\n    [178 tests, 1 failure, 0.79 s]\n----------------------------------------------------------------------\nsage -t src/sage/misc/bounded_integer_sequences.pyx  # 1 doctest failed\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-15-6cf37501.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.78 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-20-d43d6691.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n**********************************************************************\nFile \"src/sage/misc/bounded_integer_sequences.pyx\", line 1061, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__\nFailed example:\n    T+S\nExpected:\n    <4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 9>\nGot:\n    <4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 25>\n**********************************************************************\n1 item had failures:\n   1 of  10 in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__\n    [178 tests, 1 failure, 0.78 s]\n----------------------------------------------------------------------\nsage -t src/sage/misc/bounded_integer_sequences.pyx  # 1 doctest failed\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-25-04f71350.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.78 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-29-a2a81517.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.79 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-33-e89cc5fe.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.81 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-38-83426cf0.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.79 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\n```\n\nMy first guess is that this comes from using `sage_malloc` in some places, i.e., I should zero the memory first.",
    "created_at": "2014-06-03T11:35:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203879",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:72'></a>
I found failures in *some* runs:

```
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-10-7f6bcfa0.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
**********************************************************************
File "src/sage/misc/bounded_integer_sequences.pyx", line 1059, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__
Failed example:
    S+T
Expected:
    <4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 15>
Got:
    <4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 31>
**********************************************************************
1 item had failures:
   1 of  10 in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__
    [178 tests, 1 failure, 0.79 s]
----------------------------------------------------------------------
sage -t src/sage/misc/bounded_integer_sequences.pyx  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-15-6cf37501.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.78 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-20-d43d6691.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
**********************************************************************
File "src/sage/misc/bounded_integer_sequences.pyx", line 1061, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__
Failed example:
    T+S
Expected:
    <4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 9>
Got:
    <4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 25>
**********************************************************************
1 item had failures:
   1 of  10 in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__
    [178 tests, 1 failure, 0.78 s]
----------------------------------------------------------------------
sage -t src/sage/misc/bounded_integer_sequences.pyx  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-25-04f71350.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.78 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-29-a2a81517.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.79 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-33-e89cc5fe.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.81 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-38-83426cf0.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.79 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
```

My first guess is that this comes from using `sage_malloc` in some places, i.e., I should zero the memory first.



---

archive/issue_comments_203880.json:
```json
{
    "body": "**Changing work_issues** from \"Use mpn_* for speedup of iteration and item access\" to \"Fix flakyness in adding sequences\".",
    "created_at": "2014-06-03T11:35:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203880",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "Use mpn_* for speedup of iteration and item access" to "Fix flakyness in adding sequences".



---

archive/issue_events_143581.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-03T11:35:54Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143581"
}
```



---

archive/issue_events_143582.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-03T11:35:54Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143582"
}
```



---

archive/issue_comments_203881.json:
```json
{
    "body": "<a id='comment:73'></a>\nThere is something seriously broken, and apparently in the last limb of stuff:\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])\nsage: T = BoundedIntegerSequence(21, [4,1,6,2,8,15])\nsage: S+T\n<4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 15>\nsage: T+S\n<4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 9>\nsage: S+T\n<4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 31>\n```\nMy current guess is that in some place I get the number of limbs wrong when I manually assign it to the underlying `mpz_t`.",
    "created_at": "2014-06-03T13:36:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203881",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:73'></a>
There is something seriously broken, and apparently in the last limb of stuff:

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])
sage: T = BoundedIntegerSequence(21, [4,1,6,2,8,15])
sage: S+T
<4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 15>
sage: T+S
<4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 9>
sage: S+T
<4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 31>
```
My current guess is that in some place I get the number of limbs wrong when I manually assign it to the underlying `mpz_t`.



---

archive/issue_comments_203882.json:
```json
{
    "body": "<a id='comment:74'></a>\nNow I can explain what goes wrong in above example.\n\nGMP has its limbs, and I have my sequence items. In the example, each item consumes 5 bit, but each limb comprises 32 bit. As it happens, the last bit of my last item is 0, and the last limb *only* stores this single zero bit. Hence, when I ask GMP to do high-level operations (which makes sense for concatenation, I wouldn't like to do it low-level), GMP tries to be clever and drops the last limb, since it is zero. But when I transform the result to a list, I want to access the last bit. But since the last bit is not in a limb any longer, it belongs to non-allocated memory. Hence, randomly, the last bit can be 0 or 1, which explains why in the example above the difference between the correct and the wrong last item is 16.\n\nSo, what I should do: When transforming a sequence to a string or list (or when iterating), I should check whether I am running outside of GMP's limbs. Alternatively, I should provide a bit 1 right behind of my last item, so that GMP will not drop the last limb (as I forced it to be non-zero).",
    "created_at": "2014-06-03T14:30:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203882",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:74'></a>
Now I can explain what goes wrong in above example.

GMP has its limbs, and I have my sequence items. In the example, each item consumes 5 bit, but each limb comprises 32 bit. As it happens, the last bit of my last item is 0, and the last limb *only* stores this single zero bit. Hence, when I ask GMP to do high-level operations (which makes sense for concatenation, I wouldn't like to do it low-level), GMP tries to be clever and drops the last limb, since it is zero. But when I transform the result to a list, I want to access the last bit. But since the last bit is not in a limb any longer, it belongs to non-allocated memory. Hence, randomly, the last bit can be 0 or 1, which explains why in the example above the difference between the correct and the wrong last item is 16.

So, what I should do: When transforming a sequence to a string or list (or when iterating), I should check whether I am running outside of GMP's limbs. Alternatively, I should provide a bit 1 right behind of my last item, so that GMP will not drop the last limb (as I forced it to be non-zero).



---

archive/issue_comments_203883.json:
```json
{
    "body": "<a id='comment:75'></a>\nAlternatively, I could replace all `mpz_*` by `mpn_*`. But that would be boring.",
    "created_at": "2014-06-03T14:35:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203883",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:75'></a>
Alternatively, I could replace all `mpz_*` by `mpn_*`. But that would be boring.



---

archive/issue_comments_203884.json:
```json
{
    "body": "<a id='comment:76'></a>\nPS: Adding sequences that are constant zero exhibits the same problem.",
    "created_at": "2014-06-03T14:52:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203884",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:76'></a>
PS: Adding sequences that are constant zero exhibits the same problem.



---

archive/issue_comments_203885.json:
```json
{
    "body": "<a id='comment:77'></a>\nI found examples that used to trigger the above-mentioned problems reliably. So, they will be added to the docs. I fixed the iteration problem, but I am still struggling with pickling.",
    "created_at": "2014-06-04T15:15:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203885",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:77'></a>
I found examples that used to trigger the above-mentioned problems reliably. So, they will be added to the docs. I fixed the iteration problem, but I am still struggling with pickling.



---

archive/issue_comments_203886.json:
```json
{
    "body": "<a id='comment:78'></a>\nVery odd. Could it be that I hit a bug in GMP in the conversion of an integer to a string representation at base `2^n`? Namely, in my examples, the 32-adic string representation used to pickle a bounded integer sequence is not representing the stored bit array, but the 31-adic or 10-adic string representation works fine (but probably is slower).\n\nThis seems to happen when the last limb used to store a GMP integer is in fact zero.",
    "created_at": "2014-06-04T15:36:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203886",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:78'></a>
Very odd. Could it be that I hit a bug in GMP in the conversion of an integer to a string representation at base `2^n`? Namely, in my examples, the 32-adic string representation used to pickle a bounded integer sequence is not representing the stored bit array, but the 31-adic or 10-adic string representation works fine (but probably is slower).

This seems to happen when the last limb used to store a GMP integer is in fact zero.



---

archive/issue_comments_203887.json:
```json
{
    "body": "<a id='comment:79'></a>\nYes, setting the `_mp_size` field of `__mpz_struct` in such a way that the limb `_mp_d[_mp_size-1]` is non-zero solves the problem. I thought GMP would cope with \"superfluous\" zeroes, but in string representation it does not.\n\nSo, I have to check where I have been lazy with the `_mp_size` field when using `mpn_*` functions.",
    "created_at": "2014-06-04T15:56:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203887",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:79'></a>
Yes, setting the `_mp_size` field of `__mpz_struct` in such a way that the limb `_mp_d[_mp_size-1]` is non-zero solves the problem. I thought GMP would cope with "superfluous" zeroes, but in string representation it does not.

So, I have to check where I have been lazy with the `_mp_size` field when using `mpn_*` functions.



---

archive/issue_comments_203888.json:
```json
{
    "body": "<a id='comment:80'></a>\nCurrent status is a struggle with sub-sequence recognition in the presence of trailing zeroes.\n\nHere is the type of examples that I propose:\n- Use a sequence of length 7 with a bound of 32. Then, we need 35 bit to store the sequence.\n- At least on my machine, a GMP limb comprises 32 bit. Hence, the above sequence fits into two limbs, we only use three bit of the second limb.\n- Choose the last item of the sequence such that it fits into 2 bit. Then, the three bit stored in the second limb are zero.\n- Now, do an operation that involves a `mpz_*` function to create a new bounded integer sequence, *only* adding trailing zeroes. This currently is in concatenation and slicing. This may result in GMP cutting off the trailing zeroes.\n\nWhen we then do operations involving `mpn_*` functions, it is needed to take care of the cut off bits (and treat them as zero). My current private branch (not pushed yet) involves several tests that are failing with the branch currently attached here, but succeed in my current branch.\n\nStill failing is this:\n\n```\n            sage: X = BoundedIntegerSequence(21, [4,1,6,2,7,2,3])\n            sage: S = BoundedIntegerSequence(21, [0,0,0,0,0,0,0])\n            sage: loads(dumps(X+S))\n            <4, 1, 6, 2, 7, 2, 3, 0, 0, 0, 0, 0, 0, 0>\n            sage: loads(dumps(X+S)) == X+S\n            True\n            sage: T = BoundedIntegerSequence(21, [0,4,0,1,0,6,0,2,0,7,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0])\n            sage: T[3::2]==(X+S)[1:]\n            True\n            sage: T[3::2] in X+S\n            False     # should return True!\n```\n\nEDIT: Recall that providing bound 21 will internally changed into the next power of two, hence, 32.",
    "created_at": "2014-06-05T15:01:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203888",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:80'></a>
Current status is a struggle with sub-sequence recognition in the presence of trailing zeroes.

Here is the type of examples that I propose:
- Use a sequence of length 7 with a bound of 32. Then, we need 35 bit to store the sequence.
- At least on my machine, a GMP limb comprises 32 bit. Hence, the above sequence fits into two limbs, we only use three bit of the second limb.
- Choose the last item of the sequence such that it fits into 2 bit. Then, the three bit stored in the second limb are zero.
- Now, do an operation that involves a `mpz_*` function to create a new bounded integer sequence, *only* adding trailing zeroes. This currently is in concatenation and slicing. This may result in GMP cutting off the trailing zeroes.

When we then do operations involving `mpn_*` functions, it is needed to take care of the cut off bits (and treat them as zero). My current private branch (not pushed yet) involves several tests that are failing with the branch currently attached here, but succeed in my current branch.

Still failing is this:

```
            sage: X = BoundedIntegerSequence(21, [4,1,6,2,7,2,3])
            sage: S = BoundedIntegerSequence(21, [0,0,0,0,0,0,0])
            sage: loads(dumps(X+S))
            <4, 1, 6, 2, 7, 2, 3, 0, 0, 0, 0, 0, 0, 0>
            sage: loads(dumps(X+S)) == X+S
            True
            sage: T = BoundedIntegerSequence(21, [0,4,0,1,0,6,0,2,0,7,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0])
            sage: T[3::2]==(X+S)[1:]
            True
            sage: T[3::2] in X+S
            False     # should return True!
```

EDIT: Recall that providing bound 21 will internally changed into the next power of two, hence, 32.



---

archive/issue_comments_203889.json:
```json
{
    "body": "**Changing commit** from \"[735939e593c9c302ff42c4973cbfe2e48eb22644](https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644)\" to \"[c900a2cd4045aa3463be31d76c9f047b05571958](https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958)\".",
    "created_at": "2014-06-05T21:10:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203889",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[735939e593c9c302ff42c4973cbfe2e48eb22644](https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644)" to "[c900a2cd4045aa3463be31d76c9f047b05571958](https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958)".



---

archive/issue_comments_203890.json:
```json
{
    "body": "<a id='comment:81'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958\">c900a2c</a></td><td><code>Take care of GMP's removal of trailing zeroes</code></td></tr></table>\n",
    "created_at": "2014-06-05T21:10:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203890",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:81'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958">c900a2c</a></td><td><code>Take care of GMP's removal of trailing zeroes</code></td></tr></table>




---

archive/issue_events_143583.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-05T21:14:02Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143583"
}
```



---

archive/issue_events_143584.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-05T21:14:02Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143584"
}
```



---

archive/issue_comments_203891.json:
```json
{
    "body": "**Changing work_issues** from \"Fix flakyness in adding sequences\" to \"\".",
    "created_at": "2014-06-05T21:14:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203891",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "Fix flakyness in adding sequences" to "".



---

archive/issue_comments_203892.json:
```json
{
    "body": "<a id='comment:82'></a>\nI solved the problems with wrong sizes / trailing zeroes. I added all tests that used to fail with previous versions as doc tests. All tests are passing now. Hence: Needs review again. Tomorrow, I'll provide new timings, as the new sanity checks may result in a small slow-down. We will see...",
    "created_at": "2014-06-05T21:14:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203892",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:82'></a>
I solved the problems with wrong sizes / trailing zeroes. I added all tests that used to fail with previous versions as doc tests. All tests are passing now. Hence: Needs review again. Tomorrow, I'll provide new timings, as the new sanity checks may result in a small slow-down. We will see...



---

archive/issue_comments_203893.json:
```json
{
    "body": "<a id='comment:83'></a>\nRepeating the tests, in each case (even when the underlying function has not changed) stating the timing of the old code:\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.4 \u00b5s per loop  # was 1.34 \u00b5s\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n1000000 loops, best of 3: 1.59 \u00b5s per loop # was 1.57 \u00b5s\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n100000 loops, best of 3: 2.13 \u00b5s per loop  # was 2.06 \u00b5s\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n10000 loops, best of 3: 76.3 \u00b5s per loop   # was 76.7 \u00b5s\n```\nIt surprises me that some of the following became faster:\n\n```\nsage: %timeit x = list(S0)\n1000000 loops, best of 3: 1.55 \u00b5s per loop # was 1.58 \u00b5s\nsage: %timeit x = list(S1)\n100000 loops, best of 3: 2.14 \u00b5s per loop  # was 2.06 \u00b5s\nsage: %timeit x = list(S2)\n100000 loops, best of 3: 4.31 \u00b5s per loop  # was 4.19 \u00b5s\nsage: %timeit x = list(S3)\n1000 loops, best of 3: 274 \u00b5s per loop     # was 253 \u00b5s\nsage: %timeit x = S0.list()\n1000000 loops, best of 3: 810 ns per loop  # was 1.05 \u00b5s\nsage: %timeit x = S1.list()\n1000000 loops, best of 3: 1.22 \u00b5s per loop # was 1.87 \u00b5s\nsage: %timeit x = S2.list()\n100000 loops, best of 3: 2.9 \u00b5s per loop   # was 4.95 \u00b5s\nsage: %timeit x = S3.list()\n10000 loops, best of 3: 105 \u00b5s per loop    # was 306 \u00b5s\n```\n\n```\nsage: timeit(\"x=S0[:-1]\", number=100000)\n100000 loops, best of 3: 1.76 \u00b5s per loop  # was 1.75 \u00b5s\nsage: timeit(\"x=S1[:-1]\", number=100000)\n100000 loops, best of 3: 1.76 \u00b5s per loop  # was 1.8 \u00b5s\nsage: timeit(\"x=S2[:-1]\", number=100000)\n100000 loops, best of 3: 1.78 \u00b5s per loop  # was 1.77 \u00b5s\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 2.46 \u00b5s per loop  # was 2.4 \u00b5s\n```\n\n```\nsage: timeit(\"x=S2[:-1:2]\", number=10000)\n10000 loops, best of 3: 2.68 \u00b5s per loop   # was 2.7 \u00b5s\nsage: timeit(\"x=S3[:-1:2]\", number=10000)\n10000 loops, best of 3: 52.2 \u00b5s per loop   # was 52.2 \u00b5s\n```\nThe following apparently became slower:\n\n```\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 370 ns per loop  # was 354 ns\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 375 ns per loop  # was 355 ns\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 371 ns per loop  # was 350 ns\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 391 ns per loop  # was 370 ns\n```\n\n```\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: S1y = BoundedIntegerSequence(16, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S1y==S1!=S1x, S1y is not S1\n(True, True)\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0z2.startswith(S0)\", number=1000000)\n1000000 loops, best of 3: 233 ns per loop  # was 230 ns\nsage: timeit(\"S0z2.startswith(S0x)\", number=1000000)\n1000000 loops, best of 3: 238 ns per loop  # was 236 ns\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 457 ns per loop  # was 511 ns\nsage: timeit(\"S1z2.startswith(S1)\", number=1000000)\n1000000 loops, best of 3: 219 ns per loop  # was 215 ns\nsage: timeit(\"S1z2.startswith(S1x)\", number=1000000)\n1000000 loops, best of 3: 223 ns per loop  # was 219 ns\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 813 ns per loop  # was 692 ns\nsage: timeit(\"S2z2.startswith(S2)\", number=1000000)\n1000000 loops, best of 3: 244 ns per loop  # was 238 ns\nsage: timeit(\"S2z2.startswith(S2x)\", number=1000000)\n1000000 loops, best of 3: 223 ns per loop  # was 228 ns\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 5.59 \u00b5s per loop # was 1.92 \u00b5s\nsage: timeit(\"S3z2.startswith(S3)\", number=1000000)\n1000000 loops, best of 3: 990 ns per loop  # was 981 ns\nsage: timeit(\"S3z2.startswith(S3x)\", number=1000000)\n1000000 loops, best of 3: 216 ns per loop  # was 213 ns\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 2.33 ms per loop    # was 2.41 ms\n```\n\nSo, overall, I think that the timings are still decent and it makes sense to use bounded integer sequences as replacement of tuples in some applications.",
    "created_at": "2014-06-06T11:36:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203893",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:83'></a>
Repeating the tests, in each case (even when the underlying function has not changed) stating the timing of the old code:

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.4 µs per loop  # was 1.34 µs
sage: %timeit x = BoundedIntegerSequence(16, L1)
1000000 loops, best of 3: 1.59 µs per loop # was 1.57 µs
sage: %timeit x = BoundedIntegerSequence(32, L2)
100000 loops, best of 3: 2.13 µs per loop  # was 2.06 µs
sage: %timeit x = BoundedIntegerSequence(32, L3)
10000 loops, best of 3: 76.3 µs per loop   # was 76.7 µs
```
It surprises me that some of the following became faster:

```
sage: %timeit x = list(S0)
1000000 loops, best of 3: 1.55 µs per loop # was 1.58 µs
sage: %timeit x = list(S1)
100000 loops, best of 3: 2.14 µs per loop  # was 2.06 µs
sage: %timeit x = list(S2)
100000 loops, best of 3: 4.31 µs per loop  # was 4.19 µs
sage: %timeit x = list(S3)
1000 loops, best of 3: 274 µs per loop     # was 253 µs
sage: %timeit x = S0.list()
1000000 loops, best of 3: 810 ns per loop  # was 1.05 µs
sage: %timeit x = S1.list()
1000000 loops, best of 3: 1.22 µs per loop # was 1.87 µs
sage: %timeit x = S2.list()
100000 loops, best of 3: 2.9 µs per loop   # was 4.95 µs
sage: %timeit x = S3.list()
10000 loops, best of 3: 105 µs per loop    # was 306 µs
```

```
sage: timeit("x=S0[:-1]", number=100000)
100000 loops, best of 3: 1.76 µs per loop  # was 1.75 µs
sage: timeit("x=S1[:-1]", number=100000)
100000 loops, best of 3: 1.76 µs per loop  # was 1.8 µs
sage: timeit("x=S2[:-1]", number=100000)
100000 loops, best of 3: 1.78 µs per loop  # was 1.77 µs
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 2.46 µs per loop  # was 2.4 µs
```

```
sage: timeit("x=S2[:-1:2]", number=10000)
10000 loops, best of 3: 2.68 µs per loop   # was 2.7 µs
sage: timeit("x=S3[:-1:2]", number=10000)
10000 loops, best of 3: 52.2 µs per loop   # was 52.2 µs
```
The following apparently became slower:

```
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 370 ns per loop  # was 354 ns
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 375 ns per loop  # was 355 ns
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 371 ns per loop  # was 350 ns
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 391 ns per loop  # was 370 ns
```

```
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: S1y = BoundedIntegerSequence(16, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S1y==S1!=S1x, S1y is not S1
(True, True)
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0z2.startswith(S0)", number=1000000)
1000000 loops, best of 3: 233 ns per loop  # was 230 ns
sage: timeit("S0z2.startswith(S0x)", number=1000000)
1000000 loops, best of 3: 238 ns per loop  # was 236 ns
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 457 ns per loop  # was 511 ns
sage: timeit("S1z2.startswith(S1)", number=1000000)
1000000 loops, best of 3: 219 ns per loop  # was 215 ns
sage: timeit("S1z2.startswith(S1x)", number=1000000)
1000000 loops, best of 3: 223 ns per loop  # was 219 ns
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 813 ns per loop  # was 692 ns
sage: timeit("S2z2.startswith(S2)", number=1000000)
1000000 loops, best of 3: 244 ns per loop  # was 238 ns
sage: timeit("S2z2.startswith(S2x)", number=1000000)
1000000 loops, best of 3: 223 ns per loop  # was 228 ns
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 5.59 µs per loop # was 1.92 µs
sage: timeit("S3z2.startswith(S3)", number=1000000)
1000000 loops, best of 3: 990 ns per loop  # was 981 ns
sage: timeit("S3z2.startswith(S3x)", number=1000000)
1000000 loops, best of 3: 216 ns per loop  # was 213 ns
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 2.33 ms per loop    # was 2.41 ms
```

So, overall, I think that the timings are still decent and it makes sense to use bounded integer sequences as replacement of tuples in some applications.



---

archive/issue_comments_203894.json:
```json
{
    "body": "<a id='comment:84'></a>\n> So, overall, I think that the timings are still decent and it makes sense to use bounded integer sequences as replacement of tuples in some applications.\n\n\nEspecially since they are probably MUCH more compact in memory.\n\nNathann",
    "created_at": "2014-06-07T09:05:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203894",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:84'></a>
> So, overall, I think that the timings are still decent and it makes sense to use bounded integer sequences as replacement of tuples in some applications.


Especially since they are probably MUCH more compact in memory.

Nathann



---

archive/issue_comments_203895.json:
```json
{
    "body": "**Changing commit** from \"[c900a2cd4045aa3463be31d76c9f047b05571958](https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958)\" to \"[1192c211965ea1dcf1fdbaeaec7e68bf61ba265e](https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e)\".",
    "created_at": "2014-06-09T07:28:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203895",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[c900a2cd4045aa3463be31d76c9f047b05571958](https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958)" to "[1192c211965ea1dcf1fdbaeaec7e68bf61ba265e](https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e)".



---

archive/issue_comments_203896.json:
```json
{
    "body": "<a id='comment:85'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e\">1192c21</a></td><td><code>Allow empty slices; bounded integer sequence -> bool</code></td></tr></table>\n",
    "created_at": "2014-06-09T07:28:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203896",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:85'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e">1192c21</a></td><td><code>Allow empty slices; bounded integer sequence -> bool</code></td></tr></table>




---

archive/issue_comments_203897.json:
```json
{
    "body": "<a id='comment:86'></a>\nI just fixed a segfault that has occurred for empty slices, and I implemented conversion sequence to bool (in the usual way: A sequence is nonzero if and only if it has a positive length). Still needs review...",
    "created_at": "2014-06-09T07:30:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203897",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:86'></a>
I just fixed a segfault that has occurred for empty slices, and I implemented conversion sequence to bool (in the usual way: A sequence is nonzero if and only if it has a positive length). Still needs review...



---

archive/issue_comments_203898.json:
```json
{
    "body": "<a id='comment:87'></a>\nSigh. I hate trailing zeroes.\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: (BoundedIntegerSequence(21, [0,0]) + BoundedIntegerSequence(21, [0,0]))\n<16, 0, 30, 30>\n```",
    "created_at": "2014-06-11T14:52:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203898",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:87'></a>
Sigh. I hate trailing zeroes.

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: (BoundedIntegerSequence(21, [0,0]) + BoundedIntegerSequence(21, [0,0]))
<16, 0, 30, 30>
```



---

archive/issue_comments_203899.json:
```json
{
    "body": "**Work_Issues:** Fix other out of bound errors",
    "created_at": "2014-06-11T14:52:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203899",
    "user": "https://github.com/simon-king-jena"
}
```

**Work_Issues:** Fix other out of bound errors



---

archive/issue_events_143585.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-11T14:52:23Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143585"
}
```



---

archive/issue_events_143586.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-11T14:52:23Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143586"
}
```



---

archive/issue_comments_203900.json:
```json
{
    "body": "<a id='comment:88'></a>\nMy original plan was to provide a function to compute the maximal overlap of sequences in the follow-up ticket #16453. However, while I am at fixing bugs, I'll move this new function to here.",
    "created_at": "2014-06-11T14:56:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203900",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:88'></a>
My original plan was to provide a function to compute the maximal overlap of sequences in the follow-up ticket #16453. However, while I am at fixing bugs, I'll move this new function to here.



---

archive/issue_comments_203901.json:
```json
{
    "body": "<a id='comment:89'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410\">ff4477a</a></td><td><code>Remove biseq_to_str. Add max_overlap. Fix boundary violations</code></td></tr></table>\n",
    "created_at": "2014-06-11T15:13:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203901",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:89'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410">ff4477a</a></td><td><code>Remove biseq_to_str. Add max_overlap. Fix boundary violations</code></td></tr></table>




---

archive/issue_comments_203902.json:
```json
{
    "body": "**Changing commit** from \"[1192c211965ea1dcf1fdbaeaec7e68bf61ba265e](https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e)\" to \"[ff4477a1600b44031c2fb962ff3c5ab24c110410](https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410)\".",
    "created_at": "2014-06-11T15:13:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203902",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1192c211965ea1dcf1fdbaeaec7e68bf61ba265e](https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e)" to "[ff4477a1600b44031c2fb962ff3c5ab24c110410](https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410)".



---

archive/issue_comments_203903.json:
```json
{
    "body": "<a id='comment:90'></a>\nDone!\n\nNathann, while I was at it, I have removed the `biseq_to_str` function, as we have discussed off-trac.",
    "created_at": "2014-06-11T15:14:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203903",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:90'></a>
Done!

Nathann, while I was at it, I have removed the `biseq_to_str` function, as we have discussed off-trac.



---

archive/issue_events_143587.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-11T15:14:54Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143587"
}
```



---

archive/issue_events_143588.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-11T15:14:54Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143588"
}
```



---

archive/issue_comments_203904.json:
```json
{
    "body": "**Changing work_issues** from \"Fix other out of bound errors\" to \"Fix containement test\".",
    "created_at": "2014-07-15T13:06:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203904",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "Fix other out of bound errors" to "Fix containement test".



---

archive/issue_comments_203905.json:
```json
{
    "body": "<a id='comment:91'></a>\nAgain, there is trouble with zeroes. The sequence `<0>` is currently considered a subsequence of the sequence  `<1,2,3>`:\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: S1 = BoundedIntegerSequence(3,[1,3])\nsage: S2 = BoundedIntegerSequence(3,[0])\nsage: S2 in S1    # very wrong\nTrue\nsage: S1.startswith(S2) # correct\nFalse\n```",
    "created_at": "2014-07-15T13:06:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203905",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:91'></a>
Again, there is trouble with zeroes. The sequence `<0>` is currently considered a subsequence of the sequence  `<1,2,3>`:

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: S1 = BoundedIntegerSequence(3,[1,3])
sage: S2 = BoundedIntegerSequence(3,[0])
sage: S2 in S1    # very wrong
True
sage: S1.startswith(S2) # correct
False
```



---

archive/issue_events_143589.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-07-15T13:06:06Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143589"
}
```



---

archive/issue_events_143590.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-07-15T13:06:06Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143590"
}
```



---

archive/issue_comments_203906.json:
```json
{
    "body": "<a id='comment:92'></a>\nIt seems that the problem lies in `mpz_congruent_2exp_p(A, B, nbits)`: In the problematic situation, `A==0`, `B==13` and `nbits==2`. It should be the case that the function returns \"False\", since 13 is not congruent to 0 modulo 4 (i.e. modulo two bits). But it doesn't. And that's totally weird. I'll try to reproduce it independent of the bounded integer sequences, i.e., I will see if it is a horribly GMP bug. Probably it isn't.",
    "created_at": "2014-07-15T14:42:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203906",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:92'></a>
It seems that the problem lies in `mpz_congruent_2exp_p(A, B, nbits)`: In the problematic situation, `A==0`, `B==13` and `nbits==2`. It should be the case that the function returns "False", since 13 is not congruent to 0 modulo 4 (i.e. modulo two bits). But it doesn't. And that's totally weird. I'll try to reproduce it independent of the bounded integer sequences, i.e., I will see if it is a horribly GMP bug. Probably it isn't.



---

archive/issue_comments_203907.json:
```json
{
    "body": "<a id='comment:93'></a>\nYes, it isn't:\n\n```\nsage: cython(\"\"\"\n....: include \"sage/libs/ntl/decl.pxi\"\n....: def test(x,y):\n....:     cdef mpz_t a,b\n....:     mpz_init_set_ui(a, x)\n....:     mpz_init_set_ui(b, y)\n....:     print mpz_congruent_2exp_p(a,b,2)\n....:     print mpz_get_ui(a), \"vs\", mpz_get_ui(b)\n....:     print (<__mpz_struct*>a)._mp_size\n....:     print (<__mpz_struct*>b)._mp_size\n....:     mpz_clear(a)\n....:     mpz_clear(b)\n....: \"\"\")\nsage: test(0,13)\nFalse\n0 vs 13\n0\n1\n```\nMy current impression is that in *the same* situation as above, `mpz_congruent_2exp_p` gives the wrong result (`True`) in the bounded integer sequence code. Strange.",
    "created_at": "2014-07-15T14:49:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203907",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:93'></a>
Yes, it isn't:

```
sage: cython("""
....: include "sage/libs/ntl/decl.pxi"
....: def test(x,y):
....:     cdef mpz_t a,b
....:     mpz_init_set_ui(a, x)
....:     mpz_init_set_ui(b, y)
....:     print mpz_congruent_2exp_p(a,b,2)
....:     print mpz_get_ui(a), "vs", mpz_get_ui(b)
....:     print (<__mpz_struct*>a)._mp_size
....:     print (<__mpz_struct*>b)._mp_size
....:     mpz_clear(a)
....:     mpz_clear(b)
....: """)
sage: test(0,13)
False
0 vs 13
0
1
```
My current impression is that in *the same* situation as above, `mpz_congruent_2exp_p` gives the wrong result (`True`) in the bounded integer sequence code. Strange.



---

archive/issue_comments_203908.json:
```json
{
    "body": "<a id='comment:94'></a>\nArgh, now I see the difference: By a bug, I somehow managed to give the number 13 the size zero. mpz_congruent_2exp_p thus believes that 13==0 and correctly concludes that 0 is congruent 13 modulo 4.",
    "created_at": "2014-07-15T15:00:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203908",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:94'></a>
Argh, now I see the difference: By a bug, I somehow managed to give the number 13 the size zero. mpz_congruent_2exp_p thus believes that 13==0 and correctly concludes that 0 is congruent 13 modulo 4.



---

archive/issue_comments_203909.json:
```json
{
    "body": "**Changing commit** from \"[ff4477a1600b44031c2fb962ff3c5ab24c110410](https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410)\" to \"[93546db866564a80d80df30de48934697e2b0d1d](https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d)\".",
    "created_at": "2014-07-22T11:37:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203909",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ff4477a1600b44031c2fb962ff3c5ab24c110410](https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410)" to "[93546db866564a80d80df30de48934697e2b0d1d](https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d)".



---

archive/issue_comments_203910.json:
```json
{
    "body": "<a id='comment:95'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fd1675d01a5d5ef78f6bbd204ecc4a6b08fb46b4\">fd1675d</a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d\">93546db</a></td><td><code>Fix subsequence containment test.</code></td></tr></table>\n",
    "created_at": "2014-07-22T11:37:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203910",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:95'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fd1675d01a5d5ef78f6bbd204ecc4a6b08fb46b4">fd1675d</a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d">93546db</a></td><td><code>Fix subsequence containment test.</code></td></tr></table>




---

archive/issue_comments_203911.json:
```json
{
    "body": "**Changing work_issues** from \"Fix containement test\" to \"\".",
    "created_at": "2014-07-22T11:39:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203911",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "Fix containement test" to "".



---

archive/issue_events_143591.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-07-22T11:39:51Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143591"
}
```



---

archive/issue_events_143592.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-07-22T11:39:51Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143592"
}
```



---

archive/issue_comments_203912.json:
```json
{
    "body": "<a id='comment:96'></a>\nThe problem is fixed. I inserted comments into the code that hopefully explain what happens in the subsequence containment test.\n\nDoctests pass (including a new test that has previously failed), hence, it needs review again!",
    "created_at": "2014-07-22T11:39:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203912",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:96'></a>
The problem is fixed. I inserted comments into the code that hopefully explain what happens in the subsequence containment test.

Doctests pass (including a new test that has previously failed), hence, it needs review again!



---

archive/issue_events_143593.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143593"
}
```



---

archive/issue_events_143594.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143594"
}
```



---

archive/issue_comments_203913.json:
```json
{
    "body": "<a id='comment:98'></a>\nstill two failing doctests, see patchbot report",
    "created_at": "2014-08-24T20:27:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203913",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:98'></a>
still two failing doctests, see patchbot report



---

archive/issue_events_143595.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2014-08-24T20:27:59Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143595"
}
```



---

archive/issue_events_143596.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2014-08-24T20:27:59Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143596"
}
```



---

archive/issue_comments_203914.json:
```json
{
    "body": "<a id='comment:99'></a>\nReplying to [chapoton](#comment%3A98):\n> still two failing doctests, see patchbot report\n\n\nThis is all very odd. All pathchbots report the same error, but I don't see it on my own machine. So far, I don't know where I could start debugging.",
    "created_at": "2014-08-25T11:06:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203914",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:99'></a>
Replying to [chapoton](#comment%3A98):
> still two failing doctests, see patchbot report


This is all very odd. All pathchbots report the same error, but I don't see it on my own machine. So far, I don't know where I could start debugging.



---

archive/issue_comments_203915.json:
```json
{
    "body": "<a id='comment:0'></a>\nIs it perhaps the case that something relevant (GMP) was upgraded after sage-6.3.beta5? That's the version that I use on my laptop.",
    "created_at": "2014-08-25T11:10:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203915",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Is it perhaps the case that something relevant (GMP) was upgraded after sage-6.3.beta5? That's the version that I use on my laptop.



---

archive/issue_comments_203916.json:
```json
{
    "body": "<a id='comment:1'></a>\nCurrently I won't upgrade to sage-6.4, as I am rather busy with another project. Could one of you please test if the error appears in sage-6.4 but not in sage-6.3?",
    "created_at": "2014-08-25T12:50:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203916",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Currently I won't upgrade to sage-6.4, as I am rather busy with another project. Could one of you please test if the error appears in sage-6.4 but not in sage-6.3?



---

archive/issue_comments_203917.json:
```json
{
    "body": "<a id='comment:2'></a>\nI will test on 6.4.beta1. Building right now.",
    "created_at": "2014-08-25T13:00:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203917",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:2'></a>
I will test on 6.4.beta1. Building right now.



---

archive/issue_comments_203918.json:
```json
{
    "body": "<a id='comment:3'></a>\nI confirm the doctest failures on 6.4.beta1:\n\n```\n\nsage -t --long src/sage/misc/bounded_integer_sequences.pyx\n**********************************************************************\nFile \"src/sage/misc/bounded_integer_sequences.pyx\", line 1086, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__getitem__\nFailed example:\n    S[1::2]\nExpected:\n    <1, 2, 20>\nGot:\n    <1, 6, 23>\n**********************************************************************\nFile \"src/sage/misc/bounded_integer_sequences.pyx\", line 1088, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__getitem__\nFailed example:\n    S[-1::-2]\nExpected:\n    <9, 7, 6, 4>\nGot:\n    <9, 7, 22, 15>\n\n\n```",
    "created_at": "2014-08-25T13:46:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203918",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:3'></a>
I confirm the doctest failures on 6.4.beta1:

```

sage -t --long src/sage/misc/bounded_integer_sequences.pyx
**********************************************************************
File "src/sage/misc/bounded_integer_sequences.pyx", line 1086, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__getitem__
Failed example:
    S[1::2]
Expected:
    <1, 2, 20>
Got:
    <1, 6, 23>
**********************************************************************
File "src/sage/misc/bounded_integer_sequences.pyx", line 1088, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__getitem__
Failed example:
    S[-1::-2]
Expected:
    <9, 7, 6, 4>
Got:
    <9, 7, 22, 15>


```



---

archive/issue_comments_203919.json:
```json
{
    "body": "<a id='comment:4'></a>\nInteresting!\n\nSo, what has changed between sage-6.3.b5 and sage-6.4.b1? Specifically, has something happened with GMP?",
    "created_at": "2014-08-25T14:06:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203919",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
Interesting!

So, what has changed between sage-6.3.b5 and sage-6.4.b1? Specifically, has something happened with GMP?



---

archive/issue_comments_203920.json:
```json
{
    "body": "<a id='comment:5'></a>\nPS: Can you reproduce it on the command line?\n\nAt some point I should upgrade, to fix the issue...",
    "created_at": "2014-08-25T14:12:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203920",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
PS: Can you reproduce it on the command line?

At some point I should upgrade, to fix the issue...



---

archive/issue_comments_203921.json:
```json
{
    "body": "<a id='comment:6'></a>\nYes, same behaviour in the command line.",
    "created_at": "2014-08-25T14:17:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203921",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:6'></a>
Yes, same behaviour in the command line.



---

archive/issue_comments_203922.json:
```json
{
    "body": "<a id='comment:7'></a>\nI have upgraded now, and I do *not* see the error.\n\nSo, what could we do to trace the problem down?",
    "created_at": "2014-08-26T11:24:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203922",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
I have upgraded now, and I do *not* see the error.

So, what could we do to trace the problem down?



---

archive/issue_comments_203923.json:
```json
{
    "body": "<a id='comment:8'></a>\nSince I cannot reproduce the problem myself, could you please help me by providing some internal data? Perhaps there are different architectures (32bit or 64bit, big or little endian) at work?\n\nPlease add the following as a method of `BoundedIntegerSequence`:\n\n```python\n    def inspect(self):\n        cdef __mpz_struct seq\n        seq = deref(<__mpz_struct*>self.data.data)\n        print \"bitsize\",self.data.bitsize\n        print \"itembitsize\",self.data.itembitsize\n        print \"mask_item\", Integer(self.data.mask_item).binary()\n        print \"length\", self.data.length\n        print \"GMP size\", seq._mp_size\n        print \"GMP alloc\", seq._mp_alloc\n        print '.'.join([Integer(seq._mp_d[limb]).binary().rjust(mp_bits_per_limb,'0') for limb in range(seq._mp_size-1,-1,-1)])\n```\nWith this, I get\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])\nsage: S.inspect()\nbitsize 35\nitembitsize 5\nmask_item 11111\nlength 7\nGMP size 2\nGMP alloc 3\n00000000000000000000000000000010.01101000011100010001100000100100\nsage: S[1::2]\n<1, 2, 20>\nsage: (S[1::2]).inspect()\nbitsize 15\nitembitsize 5\nmask_item 11111\nlength 3\nGMP size 1\nGMP alloc 2\n00000000000000000101000001000001\nsage: S[-1::-2]\n<9, 7, 6, 4>\nsage: (S[-1::-2]).inspect()\nbitsize 20\nitembitsize 5\nmask_item 11111\nlength 4\nGMP size 1\nGMP alloc 2\n00000000000000100001100011101001\n```\nWhat do you get instead?",
    "created_at": "2014-08-26T13:16:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203923",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Since I cannot reproduce the problem myself, could you please help me by providing some internal data? Perhaps there are different architectures (32bit or 64bit, big or little endian) at work?

Please add the following as a method of `BoundedIntegerSequence`:

```python
    def inspect(self):
        cdef __mpz_struct seq
        seq = deref(<__mpz_struct*>self.data.data)
        print "bitsize",self.data.bitsize
        print "itembitsize",self.data.itembitsize
        print "mask_item", Integer(self.data.mask_item).binary()
        print "length", self.data.length
        print "GMP size", seq._mp_size
        print "GMP alloc", seq._mp_alloc
        print '.'.join([Integer(seq._mp_d[limb]).binary().rjust(mp_bits_per_limb,'0') for limb in range(seq._mp_size-1,-1,-1)])
```
With this, I get

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])
sage: S.inspect()
bitsize 35
itembitsize 5
mask_item 11111
length 7
GMP size 2
GMP alloc 3
00000000000000000000000000000010.01101000011100010001100000100100
sage: S[1::2]
<1, 2, 20>
sage: (S[1::2]).inspect()
bitsize 15
itembitsize 5
mask_item 11111
length 3
GMP size 1
GMP alloc 2
00000000000000000101000001000001
sage: S[-1::-2]
<9, 7, 6, 4>
sage: (S[-1::-2]).inspect()
bitsize 20
itembitsize 5
mask_item 11111
length 4
GMP size 1
GMP alloc 2
00000000000000100001100011101001
```
What do you get instead?



---

archive/issue_comments_203924.json:
```json
{
    "body": "<a id='comment:9'></a>\ngot that :\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])\nsage: S.inspect()\nbitsize 35\nitembitsize 5\nmask_item 11111\nlength 7\nGMP size 1\nGMP alloc 2\n0000000000000000000000000000001001101000011100010001100000100100\nsage: S[1::2]\n<1, 6, 23>\nsage: (S[1::2]).inspect()\nbitsize 15\nitembitsize 5\nmask_item 11111\nlength 3\nGMP size 1\nGMP alloc 2\n0000000000000000000000000000000000010011110111111101110011000001\nsage: S[-1::-2]\n<9, 7, 22, 15>\nsage: (S[-1::-2]).inspect()\nbitsize 20\nitembitsize 5\nmask_item 11111\nlength 4\nGMP size 1\nGMP alloc 2\n0000000000000001001101000011101011101100011101111101100011101001\n```",
    "created_at": "2014-08-26T13:31:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203924",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:9'></a>
got that :

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])
sage: S.inspect()
bitsize 35
itembitsize 5
mask_item 11111
length 7
GMP size 1
GMP alloc 2
0000000000000000000000000000001001101000011100010001100000100100
sage: S[1::2]
<1, 6, 23>
sage: (S[1::2]).inspect()
bitsize 15
itembitsize 5
mask_item 11111
length 3
GMP size 1
GMP alloc 2
0000000000000000000000000000000000010011110111111101110011000001
sage: S[-1::-2]
<9, 7, 22, 15>
sage: (S[-1::-2]).inspect()
bitsize 20
itembitsize 5
mask_item 11111
length 4
GMP size 1
GMP alloc 2
0000000000000001001101000011101011101100011101111101100011101001
```



---

archive/issue_comments_203925.json:
```json
{
    "body": "<a id='comment:0'></a>\nThank you! So, one obvious difference is that on your computer, GMP uses chunks of 64 bit to store long integers, whereas it is only 32 bit on my machine (even though it is a 64 bit CPU). I'll see if I can make sense of the error.",
    "created_at": "2014-08-26T13:40:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203925",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Thank you! So, one obvious difference is that on your computer, GMP uses chunks of 64 bit to store long integers, whereas it is only 32 bit on my machine (even though it is a 64 bit CPU). I'll see if I can make sense of the error.



---

archive/issue_comments_203926.json:
```json
{
    "body": "<a id='comment:1'></a>\nAnother interesting point is that the single limb used to store `S[1::2]` resp. `S[-1::-2]` on your machine is full of junk bits.\n\nAnyway, what surprises me is the following: Up to know, all problems arose because of a misfit where two limbs meet. But here, for the first time, we have errors occurring in a *single* limb.",
    "created_at": "2014-08-26T13:47:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203926",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Another interesting point is that the single limb used to store `S[1::2]` resp. `S[-1::-2]` on your machine is full of junk bits.

Anyway, what surprises me is the following: Up to know, all problems arose because of a misfit where two limbs meet. But here, for the first time, we have errors occurring in a *single* limb.



---

archive/issue_comments_203927.json:
```json
{
    "body": "<a id='comment:2'></a>\nHooray, I can reproduce the problem on my machine, with a different example!\n\nThe key is (as on your machine) to create a sequence that fits inside a single limb, an then slice:\n\n```\nsage: S = BoundedIntegerSequence(8, [4,1,6,2,7,2,5,5,2])\nsage: S\n<4, 1, 6, 2, 7, 2, 5, 5, 2>\nsage: S[1::2]\n<1, 6, 7, 7>\nsage: S[-1::-2]\n<2, 5, 7, 6, 7>\n```\nThe sequence above is of length 9, with items fitting into 3 bit. Hence, 27 bit are used, whereas one limb comprises 32 bits.\n\nSo, stuff for debugging!",
    "created_at": "2014-08-26T14:07:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203927",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Hooray, I can reproduce the problem on my machine, with a different example!

The key is (as on your machine) to create a sequence that fits inside a single limb, an then slice:

```
sage: S = BoundedIntegerSequence(8, [4,1,6,2,7,2,5,5,2])
sage: S
<4, 1, 6, 2, 7, 2, 5, 5, 2>
sage: S[1::2]
<1, 6, 7, 7>
sage: S[-1::-2]
<2, 5, 7, 6, 7>
```
The sequence above is of length 9, with items fitting into 3 bit. Hence, 27 bit are used, whereas one limb comprises 32 bits.

So, stuff for debugging!



---

archive/issue_comments_203928.json:
```json
{
    "body": "<a id='comment:3'></a>\nGot it!\n\nIn some branches of the `slice_biseq` function, I forgot to restrict the to-be-copied data down to the bitsize of items (i.e., I forgot `...&S.mask_item`). This oversight only happened in branches dealing with the case that everything fits within a single limb. Hence, no error in the old doctest for me (because it comprises two limbs on my machine), but an error for you (because it comprises a single limb on your machine).",
    "created_at": "2014-08-26T20:24:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203928",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Got it!

In some branches of the `slice_biseq` function, I forgot to restrict the to-be-copied data down to the bitsize of items (i.e., I forgot `...&S.mask_item`). This oversight only happened in branches dealing with the case that everything fits within a single limb. Hence, no error in the old doctest for me (because it comprises two limbs on my machine), but an error for you (because it comprises a single limb on your machine).



---

archive/issue_comments_203929.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3b2f7138142f6672beb43ee77d187393e5405a21\">3b2f713</a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9\">c69c67c</a></td><td><code>Use a bitmask when slicing bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-08-26T20:28:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203929",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3b2f7138142f6672beb43ee77d187393e5405a21">3b2f713</a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9">c69c67c</a></td><td><code>Use a bitmask when slicing bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_203930.json:
```json
{
    "body": "**Changing commit** from \"[93546db866564a80d80df30de48934697e2b0d1d](https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d)\" to \"[c69c67ccf3093a3c947ebbe83d5224daf695c3f9](https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9)\".",
    "created_at": "2014-08-26T20:28:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203930",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[93546db866564a80d80df30de48934697e2b0d1d](https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d)" to "[c69c67ccf3093a3c947ebbe83d5224daf695c3f9](https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9)".



---

archive/issue_events_143597.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-08-26T20:31:51Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143597"
}
```



---

archive/issue_events_143598.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-08-26T20:31:51Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143598"
}
```



---

archive/issue_comments_203931.json:
```json
{
    "body": "<a id='comment:5'></a>\nThe fix is pushed, and of course the example that was failing on my machine has become a new doctest.",
    "created_at": "2014-08-26T20:31:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203931",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
The fix is pushed, and of course the example that was failing on my machine has become a new doctest.



---

archive/issue_comments_203932.json:
```json
{
    "body": "**Changing commit** from \"[c69c67ccf3093a3c947ebbe83d5224daf695c3f9](https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9)\" to \"[b331dc4f12e7291e9537f607ed155085cabc3fcd](https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd)\".",
    "created_at": "2014-09-02T12:50:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203932",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[c69c67ccf3093a3c947ebbe83d5224daf695c3f9](https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9)" to "[b331dc4f12e7291e9537f607ed155085cabc3fcd](https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd)".



---

archive/issue_comments_203933.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd\">b331dc4</a></td><td><code>Fix mem leak converting zero-valued biseq_t to list</code></td></tr></table>\n",
    "created_at": "2014-09-02T12:50:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203933",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd">b331dc4</a></td><td><code>Fix mem leak converting zero-valued biseq_t to list</code></td></tr></table>




---

archive/issue_comments_203934.json:
```json
{
    "body": "<a id='comment:7'></a>\nI have fixed a memory leak: In the function `biseq_to_list`, some temporary buffer was allocated, but in the case that the sequence is zero valued, the function returns without freeing the buffer. Solution: Only allocate the buffer *after* checking that the sequence is not zero valued.\n\nStill needing review (hint-hint)...",
    "created_at": "2014-09-02T12:52:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203934",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
I have fixed a memory leak: In the function `biseq_to_list`, some temporary buffer was allocated, but in the case that the sequence is zero valued, the function returns without freeing the buffer. Solution: Only allocate the buffer *after* checking that the sequence is not zero valued.

Still needing review (hint-hint)...



---

archive/issue_events_143599.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-09-03T09:12:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143599"
}
```



---

archive/issue_events_143600.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-09-03T09:12:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143600"
}
```



---

archive/issue_comments_203935.json:
```json
{
    "body": "**Work_Issues:** memory corruption",
    "created_at": "2014-09-03T09:12:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203935",
    "user": "https://github.com/simon-king-jena"
}
```

**Work_Issues:** memory corruption



---

archive/issue_comments_203936.json:
```json
{
    "body": "<a id='comment:8'></a>\nI found that the following function (written into `bouned_integer_sequences.pyx`) achieves to crash sage:\n\n```python\ndef _biseq_stresstest():\n    cdef int i\n    from sage.misc.prandom import randint\n    cdef list L = [BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))]) for y in range(100)]\n    cdef int branch\n    cdef BoundedIntegerSequence S, T\n    for i from 0<=i<10000:\n        if (i%1000) == 0:\n            print i\n        branch = randint(0,4)\n        if branch == 0:\n            L[randint(0,99)] = L[randint(0,99)]+L[randint(0,99)]\n        elif branch == 1:\n            x = randint(0,99)\n            if len(L[x]):\n                y = randint(0,len(L[x])-1)\n                z = randint(y,len(L[x])-1)\n                L[randint(0,99)] = L[x][y:z]\n            else:\n                L[x] = BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))])\n        elif branch == 2:\n            t = list(L[randint(0,99)])\n            t = repr(L[randint(0,99)])\n            t = L[randint(0,99)].list()\n        elif branch == 3:\n            x = randint(0,99)\n            if len(L[x]):\n                t = L[x][randint(0,len(L[x])-1)]\n                try:\n                    t = L[x].index(t)\n                except ValueError:\n                    print L[x]\n                    print t\n                    raise\n            else:\n                L[x] = BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))])\n        elif branch == 4:\n            S = L[randint(0,99)]\n            T = L[randint(0,99)]\n            startswith_biseq(S.data,T.data)\n            contains_biseq(S.data, T.data, 0)\n            max_overlap_biseq(S.data, T.data)\n```\n\nCan someone please see what happens on other machines? On mine (with the above function, but also with something that was supposed to be the corner stone in my current project), crashes occur in `sage_free` or `mpz_clear`. Surprisingly, the variables-to-be-freed/cleared should be just fine, in some cases they haven't even been touched after allocation.\n\nMy wild guess is that using `sage_malloc` (in `bounded_integer_sequences.pyx`) somehow interferes with gmp's (mpir's?) memory management. Even if the reason is different, I suppose it would make sense to get rid of `sage_malloc` and `sage_free` in my code. After all, I use it for buffers whose length is known at compile time. Hence, I should better use arrays.\n\nSo, my plan is: Use arrays instead of `sage_malloc`, and hope that this is enough to let above function pass, which would then become a doctest.",
    "created_at": "2014-09-03T09:12:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203936",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
I found that the following function (written into `bouned_integer_sequences.pyx`) achieves to crash sage:

```python
def _biseq_stresstest():
    cdef int i
    from sage.misc.prandom import randint
    cdef list L = [BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))]) for y in range(100)]
    cdef int branch
    cdef BoundedIntegerSequence S, T
    for i from 0<=i<10000:
        if (i%1000) == 0:
            print i
        branch = randint(0,4)
        if branch == 0:
            L[randint(0,99)] = L[randint(0,99)]+L[randint(0,99)]
        elif branch == 1:
            x = randint(0,99)
            if len(L[x]):
                y = randint(0,len(L[x])-1)
                z = randint(y,len(L[x])-1)
                L[randint(0,99)] = L[x][y:z]
            else:
                L[x] = BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))])
        elif branch == 2:
            t = list(L[randint(0,99)])
            t = repr(L[randint(0,99)])
            t = L[randint(0,99)].list()
        elif branch == 3:
            x = randint(0,99)
            if len(L[x]):
                t = L[x][randint(0,len(L[x])-1)]
                try:
                    t = L[x].index(t)
                except ValueError:
                    print L[x]
                    print t
                    raise
            else:
                L[x] = BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))])
        elif branch == 4:
            S = L[randint(0,99)]
            T = L[randint(0,99)]
            startswith_biseq(S.data,T.data)
            contains_biseq(S.data, T.data, 0)
            max_overlap_biseq(S.data, T.data)
```

Can someone please see what happens on other machines? On mine (with the above function, but also with something that was supposed to be the corner stone in my current project), crashes occur in `sage_free` or `mpz_clear`. Surprisingly, the variables-to-be-freed/cleared should be just fine, in some cases they haven't even been touched after allocation.

My wild guess is that using `sage_malloc` (in `bounded_integer_sequences.pyx`) somehow interferes with gmp's (mpir's?) memory management. Even if the reason is different, I suppose it would make sense to get rid of `sage_malloc` and `sage_free` in my code. After all, I use it for buffers whose length is known at compile time. Hence, I should better use arrays.

So, my plan is: Use arrays instead of `sage_malloc`, and hope that this is enough to let above function pass, which would then become a doctest.



---

archive/issue_comments_203937.json:
```json
{
    "body": "<a id='comment:9'></a>\nHmm. Using, for example,\n\n```python\n    cdef mp_limb_t tmp_limb[1]\n```\ninstead of\n\n```python\n    cdef mp_limb_t *tmp_limb\n    tmp_limb = <mp_limb_t*>sage_malloc(sizeof(mp_limb_t))\n```\ncompiles, but then it seems that the `mpn_*` functions do not correctly put values into the arrays, when I give them `tmp_limb` as argument.\n\nQuestion to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?",
    "created_at": "2014-09-03T10:13:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203937",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Hmm. Using, for example,

```python
    cdef mp_limb_t tmp_limb[1]
```
instead of

```python
    cdef mp_limb_t *tmp_limb
    tmp_limb = <mp_limb_t*>sage_malloc(sizeof(mp_limb_t))
```
compiles, but then it seems that the `mpn_*` functions do not correctly put values into the arrays, when I give them `tmp_limb` as argument.

Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?



---

archive/issue_comments_203938.json:
```json
{
    "body": "<a id='comment:120'></a>\nReplying to [SimonKing](#comment%3A119):\n> Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?\n\n\nForget the question. The problem was somewhere else. Now I think I can make arrays works as replacement for the current usage of `sage_malloc`.",
    "created_at": "2014-09-03T10:35:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203938",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:120'></a>
Replying to [SimonKing](#comment%3A119):
> Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?


Forget the question. The problem was somewhere else. Now I think I can make arrays works as replacement for the current usage of `sage_malloc`.



---

archive/issue_comments_203939.json:
```json
{
    "body": "<a id='comment:121'></a>\nReplying to [SimonKing](#comment%3A120):\n> Replying to [SimonKing](#comment%3A119):\n> > Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?\n\n> \n> Forget the question. The problem was somewhere else. Now I think I can make arrays works as replacement for the current usage of `sage_malloc`.\n\n\nDo *not* forget the question. There is something extremely strange going on. When I insert a print statement after assigning the size of an `__mpz_struct*`, then things work. **Without the print statement**, the assignment of the size is ignored and the value incorrectly left zero.\n\nSo, how can a print statement influence whether or not some value of a variable in GMP is assigned?",
    "created_at": "2014-09-03T10:48:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203939",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:121'></a>
Replying to [SimonKing](#comment%3A120):
> Replying to [SimonKing](#comment%3A119):
> > Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?

> 
> Forget the question. The problem was somewhere else. Now I think I can make arrays works as replacement for the current usage of `sage_malloc`.


Do *not* forget the question. There is something extremely strange going on. When I insert a print statement after assigning the size of an `__mpz_struct*`, then things work. **Without the print statement**, the assignment of the size is ignored and the value incorrectly left zero.

So, how can a print statement influence whether or not some value of a variable in GMP is assigned?



---

archive/issue_comments_203940.json:
```json
{
    "body": "**Changing commit** from \"[b331dc4f12e7291e9537f607ed155085cabc3fcd](https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd)\" to \"[7b53dc82d032d5a787e10731938f9048b620031b](https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b)\".",
    "created_at": "2014-09-03T13:44:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203940",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[b331dc4f12e7291e9537f607ed155085cabc3fcd](https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd)" to "[7b53dc82d032d5a787e10731938f9048b620031b](https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b)".



---

archive/issue_comments_203941.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b\">7b53dc8</a></td><td><code>Try to improve memory management for biseq_t, and add a stress test</code></td></tr></table>\n",
    "created_at": "2014-09-03T13:44:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203941",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b">7b53dc8</a></td><td><code>Try to improve memory management for biseq_t, and add a stress test</code></td></tr></table>




---

archive/issue_comments_203942.json:
```json
{
    "body": "<a id='comment:3'></a>\nI have replaced `sage_malloc` by arrays, since the array size is known at compile time. I think this is a good idea anyway, and the doctests pass.\n\nBut not all is good, and here I need help: `_biseq_stresstest()` either crashes with `free(): invalid next size (fast)`, or it raises a value error stating that some element is not in a bounded integer sequence, even though by construction it is contained. So, memory management still goes havoc.\n\nAny clues or pointers?",
    "created_at": "2014-09-03T13:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203942",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
I have replaced `sage_malloc` by arrays, since the array size is known at compile time. I think this is a good idea anyway, and the doctests pass.

But not all is good, and here I need help: `_biseq_stresstest()` either crashes with `free(): invalid next size (fast)`, or it raises a value error stating that some element is not in a bounded integer sequence, even though by construction it is contained. So, memory management still goes havoc.

Any clues or pointers?



---

archive/issue_comments_203943.json:
```json
{
    "body": "<a id='comment:4'></a>\nI was running it under valgrind---and as a result, I did not see a crash! However, the other problem (a value error when a sequence is supposed to return the index of one of its elements) still persists under valgrind.\n\nConcerning the crash: What can one do to further debug if a crash can not be reproduced with valgrind?",
    "created_at": "2014-09-03T14:37:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203943",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
I was running it under valgrind---and as a result, I did not see a crash! However, the other problem (a value error when a sequence is supposed to return the index of one of its elements) still persists under valgrind.

Concerning the crash: What can one do to further debug if a crash can not be reproduced with valgrind?



---

archive/issue_comments_203944.json:
```json
{
    "body": "<a id='comment:5'></a>\nPS: I can not quit sage when I run it under valgrind---\"quit\" has no effect!",
    "created_at": "2014-09-03T14:38:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203944",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
PS: I can not quit sage when I run it under valgrind---"quit" has no effect!



---

archive/issue_comments_203945.json:
```json
{
    "body": "<a id='comment:6'></a>\nEven \"pkill python\" did not achieve to finish the valgrinded Sage session. Boy, am I fed up now. Time to call it a day.",
    "created_at": "2014-09-03T14:40:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203945",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
Even "pkill python" did not achieve to finish the valgrinded Sage session. Boy, am I fed up now. Time to call it a day.



---

archive/issue_comments_203946.json:
```json
{
    "body": "<a id='comment:7'></a>\nActually I realise that I made a severe mistake all the time. `concat_biseq` returns a pointer to a local variable, and I did so in order to make it possible to propagate errors (by saying `... except NULL`). But returning a pointer to a local variable can not possibly work.\n\nSince I want to propagate errors, I suppose it will be better to consistently work with pointers. I'll rewrite the module accordingly...",
    "created_at": "2014-09-03T16:37:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203946",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Actually I realise that I made a severe mistake all the time. `concat_biseq` returns a pointer to a local variable, and I did so in order to make it possible to propagate errors (by saying `... except NULL`). But returning a pointer to a local variable can not possibly work.

Since I want to propagate errors, I suppose it will be better to consistently work with pointers. I'll rewrite the module accordingly...



---

archive/issue_comments_203947.json:
```json
{
    "body": "<a id='comment:8'></a>\nIt seems that that was the reason indeed! After rewriting everything so that\n`biseq_t` becomes a pointer to a struct (before, `biseq_t` *was* the\nstruct), all doctests pass, and the stresstest doesn't crash.\n\nBut not all is good: The stresstest doesn't crash, but sporadically it finds\ncan not find the index of an element of a sequence. So, needs work and I will not push yet, but it is\nalmost done.",
    "created_at": "2014-09-03T17:15:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203947",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
It seems that that was the reason indeed! After rewriting everything so that
`biseq_t` becomes a pointer to a struct (before, `biseq_t` *was* the
struct), all doctests pass, and the stresstest doesn't crash.

But not all is good: The stresstest doesn't crash, but sporadically it finds
can not find the index of an element of a sequence. So, needs work and I will not push yet, but it is
almost done.



---

archive/issue_comments_203948.json:
```json
{
    "body": "<a id='comment:9'></a>\nThe stresstest found that the following fails:\n\n```\n            sage: S = BoundedIntegerSequence(6, [3, 5, 3, 1, 5, 2, 2, 5, 3, 3, 4])\n            sage: S[-1]\n            4\n```\nCurrently it returns 0.",
    "created_at": "2014-09-03T17:19:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203948",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
The stresstest found that the following fails:

```
            sage: S = BoundedIntegerSequence(6, [3, 5, 3, 1, 5, 2, 2, 5, 3, 3, 4])
            sage: S[-1]
            4
```
Currently it returns 0.



---

archive/issue_comments_203949.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7c9f0f28529af66a5c0a00a8c0116ed02ac58f5a\">7c9f0f2</a></td><td><code>Biseq refactored, so that only pointers are passed around.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2\">0aa3cbc</a></td><td><code>Fix corner cases in item access for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-09-03T20:18:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203949",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7c9f0f28529af66a5c0a00a8c0116ed02ac58f5a">7c9f0f2</a></td><td><code>Biseq refactored, so that only pointers are passed around.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2">0aa3cbc</a></td><td><code>Fix corner cases in item access for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_203950.json:
```json
{
    "body": "**Changing commit** from \"[7b53dc82d032d5a787e10731938f9048b620031b](https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b)\" to \"[0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2](https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2)\".",
    "created_at": "2014-09-03T20:18:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203950",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7b53dc82d032d5a787e10731938f9048b620031b](https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b)" to "[0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2](https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2)".



---

archive/issue_comments_203951.json:
```json
{
    "body": "<a id='comment:1'></a>\nThe stress test is really valuable. I found several small problems concerning corner cases. And, as I have announced, I have reworked the code so that only \"proper\" pointers rather than stupid references to local variables are passed around.\n\nThere remain problems, though. In the doctests, I have commented out the stresstest, because there are STILL crashes. This time, `mpz_clear` sometimes doesn't work. My wild guess is that at some point I write out of bounds when using `mpn_*`-functions.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7c9f0f28529af66a5c0a00a8c0116ed02ac58f5a\">7c9f0f2</a></td><td><code>Biseq refactored, so that only pointers are passed around.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2\">0aa3cbc</a></td><td><code>Fix corner cases in item access for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-09-03T20:23:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203951",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
The stress test is really valuable. I found several small problems concerning corner cases. And, as I have announced, I have reworked the code so that only "proper" pointers rather than stupid references to local variables are passed around.

There remain problems, though. In the doctests, I have commented out the stresstest, because there are STILL crashes. This time, `mpz_clear` sometimes doesn't work. My wild guess is that at some point I write out of bounds when using `mpn_*`-functions.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7c9f0f28529af66a5c0a00a8c0116ed02ac58f5a">7c9f0f2</a></td><td><code>Biseq refactored, so that only pointers are passed around.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2">0aa3cbc</a></td><td><code>Fix corner cases in item access for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_203952.json:
```json
{
    "body": "<a id='comment:2'></a>\nHooray, by inserting explicit range checks, I found that I am indeed writing out of allocated area in `slice_biseq`. That (and similar errors?) will hopefully explain the crashes...",
    "created_at": "2014-09-04T12:37:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203952",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Hooray, by inserting explicit range checks, I found that I am indeed writing out of allocated area in `slice_biseq`. That (and similar errors?) will hopefully explain the crashes...



---

archive/issue_comments_203953.json:
```json
{
    "body": "**Changing commit** from \"[0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2](https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2)\" to \"[f20dc096832f260edee2f28b3007bf42263f54ac](https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac)\".",
    "created_at": "2014-09-04T15:20:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203953",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2](https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2)" to "[f20dc096832f260edee2f28b3007bf42263f54ac](https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac)".



---

archive/issue_comments_203954.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac\">f20dc09</a></td><td><code>Fix writing out of bounds, and assert that the bounds are respected</code></td></tr></table>\n",
    "created_at": "2014-09-04T15:20:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203954",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac">f20dc09</a></td><td><code>Fix writing out of bounds, and assert that the bounds are respected</code></td></tr></table>




---

archive/issue_events_143601.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-09-04T15:26:46Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143601"
}
```



---

archive/issue_events_143602.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-09-04T15:26:46Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143602"
}
```



---

archive/issue_comments_203955.json:
```json
{
    "body": "<a id='comment:4'></a>\nIn the new commit, I added assertions to make sure that I am not writing into non-allocated memory. So, the code should now be water proof in that regard.\n\nAll tests pass, including the \"stress test\". So, it can be reviewed now!\n\nQuestion to the reviewer: Can the assertions be removed? After all, what is being asserted is just that some variables are correctly computed, but this can in principle be checked by reading the code. Or are assertions (even in relatively tight loops) cheap enough?",
    "created_at": "2014-09-04T15:26:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203955",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
In the new commit, I added assertions to make sure that I am not writing into non-allocated memory. So, the code should now be water proof in that regard.

All tests pass, including the "stress test". So, it can be reviewed now!

Question to the reviewer: Can the assertions be removed? After all, what is being asserted is just that some variables are correctly computed, but this can in principle be checked by reading the code. Or are assertions (even in relatively tight loops) cheap enough?



---

archive/issue_comments_203956.json:
```json
{
    "body": "<a id='comment:135'></a>\nReplying to [SimonKing](#comment%3A134):\n> Question to the reviewer: Can the assertions be removed? After all, what is being asserted is just that some variables are correctly computed, but this can in principle be checked by reading the code. Or are assertions (even in relatively tight loops) cheap enough?\n\n\nIf you run `Python` with the option `-O`, all the assert calls are ignored. \nSomething similar should be doable, at compile time of course, for Cython.\n\nMost programming languages support this to encourage developpers to never remove asserts. We really should have this feature in Sage. A good starting point would be to have `sage -O` call `Python -O`.\n\nCheers,\n                                     Nicolas",
    "created_at": "2014-09-04T15:37:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203956",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:135'></a>
Replying to [SimonKing](#comment%3A134):
> Question to the reviewer: Can the assertions be removed? After all, what is being asserted is just that some variables are correctly computed, but this can in principle be checked by reading the code. Or are assertions (even in relatively tight loops) cheap enough?


If you run `Python` with the option `-O`, all the assert calls are ignored. 
Something similar should be doable, at compile time of course, for Cython.

Most programming languages support this to encourage developpers to never remove asserts. We really should have this feature in Sage. A good starting point would be to have `sage -O` call `Python -O`.

Cheers,
                                     Nicolas



---

archive/issue_comments_203957.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652\">cea38bb</a></td><td><code>Change doc according to the changed functionality of list_to_biseq</code></td></tr></table>\n",
    "created_at": "2014-09-04T16:06:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203957",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652">cea38bb</a></td><td><code>Change doc according to the changed functionality of list_to_biseq</code></td></tr></table>




---

archive/issue_comments_203958.json:
```json
{
    "body": "**Changing commit** from \"[f20dc096832f260edee2f28b3007bf42263f54ac](https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac)\" to \"[cea38bb0a7d6f748cfc1feef357df5e22eb7b652](https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652)\".",
    "created_at": "2014-09-04T16:06:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203958",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f20dc096832f260edee2f28b3007bf42263f54ac](https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac)" to "[cea38bb0a7d6f748cfc1feef357df5e22eb7b652](https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652)".



---

archive/issue_comments_203959.json:
```json
{
    "body": "**Changing work_issues** from \"memory corruption\" to \"\".",
    "created_at": "2014-09-04T22:18:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203959",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "memory corruption" to "".



---

archive/issue_comments_203960.json:
```json
{
    "body": "**Changing commit** from \"[cea38bb0a7d6f748cfc1feef357df5e22eb7b652](https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652)\" to \"[4611f8aa591616f118b50ebc2d2516c635e40318](https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318)\".",
    "created_at": "2014-09-04T22:39:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203960",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[cea38bb0a7d6f748cfc1feef357df5e22eb7b652](https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652)" to "[4611f8aa591616f118b50ebc2d2516c635e40318](https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318)".



---

archive/issue_comments_203961.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318\">4611f8a</a></td><td><code>Minor changes in the docs</code></td></tr></table>\n",
    "created_at": "2014-09-04T22:39:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203961",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318">4611f8a</a></td><td><code>Minor changes in the docs</code></td></tr></table>




---

archive/issue_comments_203962.json:
```json
{
    "body": "**Changing commit** from \"[4611f8aa591616f118b50ebc2d2516c635e40318](https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318)\" to \"[815d77c77f48605ea33b87a88120aaabadfb5f7f](https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f)\".",
    "created_at": "2014-09-05T10:58:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203962",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[4611f8aa591616f118b50ebc2d2516c635e40318](https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318)" to "[815d77c77f48605ea33b87a88120aaabadfb5f7f](https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f)".



---

archive/issue_comments_203963.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f\">815d77c</a></td><td><code>mpn_r/lshift should only be used with strictly positive shift</code></td></tr></table>\n",
    "created_at": "2014-09-05T10:58:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203963",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f">815d77c</a></td><td><code>mpn_r/lshift should only be used with strictly positive shift</code></td></tr></table>




---

archive/issue_comments_203964.json:
```json
{
    "body": "<a id='comment:0'></a>\nThis is to explain the most recent commit: By doing some non-commutative Gr\u00f6bner basis computations relying on \"biseq_t\", I obtained crashes apparently caused by the `slice_biseq` function. It is using `mpn_rshift`, and it did so even when the shift was zero. However, I found in the docs that the shift is supposed to be at least 1. Hence, when there is no shift, I am now using `mpn_copyi` instead. Hope it helps to prevent the crash...",
    "created_at": "2014-09-05T12:25:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203964",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
This is to explain the most recent commit: By doing some non-commutative Gröbner basis computations relying on "biseq_t", I obtained crashes apparently caused by the `slice_biseq` function. It is using `mpn_rshift`, and it did so even when the shift was zero. However, I found in the docs that the shift is supposed to be at least 1. Hence, when there is no shift, I am now using `mpn_copyi` instead. Hope it helps to prevent the crash...



---

archive/issue_comments_203965.json:
```json
{
    "body": "<a id='comment:1'></a>\nArgh. No, it did not fix the crash in my Gr\u00f6bner basis application. Anyway, I still think the commit makes sense.",
    "created_at": "2014-09-05T12:26:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203965",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Argh. No, it did not fix the crash in my Gröbner basis application. Anyway, I still think the commit makes sense.



---

archive/issue_comments_203966.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a\">6dfb1cb</a></td><td><code>Make contains_biseq interruptible and add to its doc</code></td></tr></table>\n",
    "created_at": "2014-10-04T18:41:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203966",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a">6dfb1cb</a></td><td><code>Make contains_biseq interruptible and add to its doc</code></td></tr></table>




---

archive/issue_comments_203967.json:
```json
{
    "body": "**Changing commit** from \"[815d77c77f48605ea33b87a88120aaabadfb5f7f](https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f)\" to \"[6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a](https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a)\".",
    "created_at": "2014-10-04T18:41:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203967",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[815d77c77f48605ea33b87a88120aaabadfb5f7f](https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f)" to "[6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a](https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a)".



---

archive/issue_comments_203968.json:
```json
{
    "body": "<a id='comment:3'></a>\nI'm getting three valgrind warnings (#15586):\n\n```\nsage: sage: from sage.misc.bounded_integer_sequences import _biseq_stresstest\nsage: _biseq_stresstest()\n==3937== Invalid read of size 8\n==3937==    at 0x30A524B0: __gmpn_rshift (rshift.c:55)\n==3937==    by 0x48CCB50B: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2611)\n==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)\n==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n[...]\n==3937==  Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd\n==3937==    at 0x4C29BCF: malloc (vg_replace_malloc.c:296)\n==3937==    by 0x142EC8FD: sage_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)\n==3937==    by 0x142EC9E4: sage_gmp_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)\n==3937==    by 0x30A439EE: __gmpz_init2 (init2.c:33)\n==3937==    by 0x48CCE302: __pyx_f_4sage_4misc_25bounded_integer_sequences_concat_biseq (bounded_integer_sequences.c:2256)\n==3937==    by 0x48CD6806: __pyx_pf_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_31__add__ (bounded_integer_sequences.c:7201)\n==3937==    by 0x48CD6806: __pyx_pw_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_32__add__ (bounded_integer_sequences.c:7078)\n==3937==    by 0x4E80BC8: binary_op1 (abstract.c:945)\n==3937==    by 0x4E80BC8: PyNumber_Add (abstract.c:1185)\n==3937==    by 0x48CD39AD: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8281)\n==3937==    by 0x48CD39AD: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n[...]\n==3937== Conditional jump or move depends on uninitialised value(s)\n==3937==    at 0x48CCB5C3: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2828)\n==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)\n==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n==3937==    by 0x4F3F24F: PyEval_EvalCodeEx (ceval.c:3265)\n==3937==    by 0x4F3F378: PyEval_EvalCode (ceval.c:673)\n```\nThe middle one is almost certainly an error, the other two don't look too good either.",
    "created_at": "2014-10-12T12:24:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203968",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:3'></a>
I'm getting three valgrind warnings (#15586):

```
sage: sage: from sage.misc.bounded_integer_sequences import _biseq_stresstest
sage: _biseq_stresstest()
==3937== Invalid read of size 8
==3937==    at 0x30A524B0: __gmpn_rshift (rshift.c:55)
==3937==    by 0x48CCB50B: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2611)
==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)
==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
==3937==    by 0x4F3E768: call_function (ceval.c:4017)
==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
[...]
==3937==  Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd
==3937==    at 0x4C29BCF: malloc (vg_replace_malloc.c:296)
==3937==    by 0x142EC8FD: sage_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)
==3937==    by 0x142EC9E4: sage_gmp_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)
==3937==    by 0x30A439EE: __gmpz_init2 (init2.c:33)
==3937==    by 0x48CCE302: __pyx_f_4sage_4misc_25bounded_integer_sequences_concat_biseq (bounded_integer_sequences.c:2256)
==3937==    by 0x48CD6806: __pyx_pf_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_31__add__ (bounded_integer_sequences.c:7201)
==3937==    by 0x48CD6806: __pyx_pw_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_32__add__ (bounded_integer_sequences.c:7078)
==3937==    by 0x4E80BC8: binary_op1 (abstract.c:945)
==3937==    by 0x4E80BC8: PyNumber_Add (abstract.c:1185)
==3937==    by 0x48CD39AD: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8281)
==3937==    by 0x48CD39AD: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
==3937==    by 0x4F3E768: call_function (ceval.c:4017)
==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
[...]
==3937== Conditional jump or move depends on uninitialised value(s)
==3937==    at 0x48CCB5C3: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2828)
==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)
==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
==3937==    by 0x4F3E768: call_function (ceval.c:4017)
==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
==3937==    by 0x4F3F24F: PyEval_EvalCodeEx (ceval.c:3265)
==3937==    by 0x4F3F378: PyEval_EvalCode (ceval.c:673)
```
The middle one is almost certainly an error, the other two don't look too good either.



---

archive/issue_comments_203969.json:
```json
{
    "body": "<a id='comment:144'></a>\nGood that I added the stress test!\n\nReplying to [vbraun](#comment%3A143):\n> I'm getting three valgrind warnings (#15586):\n> \n> ```\n> sage: sage: from sage.misc.bounded_integer_sequences import _biseq_stresstest\n> sage: _biseq_stresstest()\n> ==3937== Invalid read of size 8\n> ==3937==    at 0x30A524B0: __gmpn_rshift (rshift.c:55)\n> ==3937==    by 0x48CCB50B: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2611)\n> ==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)\n> ==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n> [...]\n> ==3937==  Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd\n> ==3937==    at 0x4C29BCF: malloc (vg_replace_malloc.c:296)\n> ==3937==    by 0x142EC8FD: sage_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)\n> ==3937==    by 0x142EC9E4: sage_gmp_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)\n> ==3937==    by 0x30A439EE: __gmpz_init2 (init2.c:33)\n> ==3937==    by 0x48CCE302: __pyx_f_4sage_4misc_25bounded_integer_sequences_concat_biseq (bounded_integer_sequences.c:2256)\n> ==3937==    by 0x48CD6806: __pyx_pf_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_31__add__ (bounded_integer_sequences.c:7201)\n> ==3937==    by 0x48CD6806: __pyx_pw_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_32__add__ (bounded_integer_sequences.c:7078)\n> ==3937==    by 0x4E80BC8: binary_op1 (abstract.c:945)\n> ==3937==    by 0x4E80BC8: PyNumber_Add (abstract.c:1185)\n> ==3937==    by 0x48CD39AD: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8281)\n> ==3937==    by 0x48CD39AD: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n> [...]\n> ```\n\nDo I understand correctly: It means that `contains_biseq` could read and `concat_biseq` could write stuff in non-allocated memory?\n\n> ```\n> ==3937== Conditional jump or move depends on uninitialised value(s)\n> ==3937==    at 0x48CCB5C3: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2828)\n> ==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)\n> ==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n> ==3937==    by 0x4F3F24F: PyEval_EvalCodeEx (ceval.c:3265)\n> ==3937==    by 0x4F3F378: PyEval_EvalCode (ceval.c:673)\n> ```\n> The middle one is almost certainly an error, the other two don't look too good either.\n\n\nWill the given line numbers (2611, 2256, 2828) be the same on my machine?",
    "created_at": "2014-10-12T20:09:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203969",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:144'></a>
Good that I added the stress test!

Replying to [vbraun](#comment%3A143):
> I'm getting three valgrind warnings (#15586):
> 
> ```
> sage: sage: from sage.misc.bounded_integer_sequences import _biseq_stresstest
> sage: _biseq_stresstest()
> ==3937== Invalid read of size 8
> ==3937==    at 0x30A524B0: __gmpn_rshift (rshift.c:55)
> ==3937==    by 0x48CCB50B: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2611)
> ==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)
> ==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)
> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
> [...]
> ==3937==  Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd
> ==3937==    at 0x4C29BCF: malloc (vg_replace_malloc.c:296)
> ==3937==    by 0x142EC8FD: sage_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)
> ==3937==    by 0x142EC9E4: sage_gmp_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)
> ==3937==    by 0x30A439EE: __gmpz_init2 (init2.c:33)
> ==3937==    by 0x48CCE302: __pyx_f_4sage_4misc_25bounded_integer_sequences_concat_biseq (bounded_integer_sequences.c:2256)
> ==3937==    by 0x48CD6806: __pyx_pf_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_31__add__ (bounded_integer_sequences.c:7201)
> ==3937==    by 0x48CD6806: __pyx_pw_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_32__add__ (bounded_integer_sequences.c:7078)
> ==3937==    by 0x4E80BC8: binary_op1 (abstract.c:945)
> ==3937==    by 0x4E80BC8: PyNumber_Add (abstract.c:1185)
> ==3937==    by 0x48CD39AD: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8281)
> ==3937==    by 0x48CD39AD: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)
> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
> [...]
> ```

Do I understand correctly: It means that `contains_biseq` could read and `concat_biseq` could write stuff in non-allocated memory?

> ```
> ==3937== Conditional jump or move depends on uninitialised value(s)
> ==3937==    at 0x48CCB5C3: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2828)
> ==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)
> ==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)
> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
> ==3937==    by 0x4F3F24F: PyEval_EvalCodeEx (ceval.c:3265)
> ==3937==    by 0x4F3F378: PyEval_EvalCode (ceval.c:673)
> ```
> The middle one is almost certainly an error, the other two don't look too good either.


Will the given line numbers (2611, 2256, 2828) be the same on my machine?



---

archive/issue_comments_203970.json:
```json
{
    "body": "<a id='comment:5'></a>\nI think they are, but I wouldn't bet anything on it ;-)",
    "created_at": "2014-10-12T20:28:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203970",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:5'></a>
I think they are, but I wouldn't bet anything on it ;-)



---

archive/issue_comments_203971.json:
```json
{
    "body": "<a id='comment:6'></a>\n1) is `contains_biseq` reading into unallocated memory, and 2) says that the invalid read is just beyond what `concat_biseq` allocated.",
    "created_at": "2014-10-12T20:35:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203971",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:6'></a>
1) is `contains_biseq` reading into unallocated memory, and 2) says that the invalid read is just beyond what `concat_biseq` allocated.



---

archive/issue_comments_203972.json:
```json
{
    "body": "<a id='comment:147'></a>\nReplying to [vbraun](#comment%3A146):\n> 1) is `contains_biseq` reading into unallocated memory, and 2) says that the invalid read is just beyond what `concat_biseq` allocated.\n\n\nSigh. Could be that I even don't see where 1), 2) and 3) are in the valgrind log...\n\nConcerning the invalid read of size 8 by `__gmpn_rshift`: I think I recall that at some point I wanted to avoid considering cases and thus allowed to rshift memory that partially is uninitialised, since after the shift I would only access the bytes that were allocated. Probably this is improper and should be fixed.\n\nConcerning `Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd`: I thought this means I am writing into non-allocated memory. But by your new comment, I understand that this just indicates where the memory accessed by the previous item (`__gmpn_rshift`) was allocated. I guess I need an explanation.\n\nConcerning `Conditional jump or move depends on uninitialised value(s)`: Is this independent of the two previous points? Or does it concern the same example and the same memory location?",
    "created_at": "2014-10-13T08:23:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203972",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:147'></a>
Replying to [vbraun](#comment%3A146):
> 1) is `contains_biseq` reading into unallocated memory, and 2) says that the invalid read is just beyond what `concat_biseq` allocated.


Sigh. Could be that I even don't see where 1), 2) and 3) are in the valgrind log...

Concerning the invalid read of size 8 by `__gmpn_rshift`: I think I recall that at some point I wanted to avoid considering cases and thus allowed to rshift memory that partially is uninitialised, since after the shift I would only access the bytes that were allocated. Probably this is improper and should be fixed.

Concerning `Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd`: I thought this means I am writing into non-allocated memory. But by your new comment, I understand that this just indicates where the memory accessed by the previous item (`__gmpn_rshift`) was allocated. I guess I need an explanation.

Concerning `Conditional jump or move depends on uninitialised value(s)`: Is this independent of the two previous points? Or does it concern the same example and the same memory location?



---

archive/issue_comments_203973.json:
```json
{
    "body": "<a id='comment:8'></a>\nWith the updated valgrind they are the only errors while running the testsuite(!). Trivial to spot. Its possible that they are false positives if you use only certain bit positions, but zeroing out the memory doesn't cost much in terms of runtime and can save us a lot of work if your calculations about bit patterns are off by one ;-)",
    "created_at": "2014-10-13T08:27:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203973",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:8'></a>
With the updated valgrind they are the only errors while running the testsuite(!). Trivial to spot. Its possible that they are false positives if you use only certain bit positions, but zeroing out the memory doesn't cost much in terms of runtime and can save us a lot of work if your calculations about bit patterns are off by one ;-)



---

archive/issue_comments_203974.json:
```json
{
    "body": "<a id='comment:149'></a>\nReplying to [vbraun](#comment%3A148):\n> With the updated valgrind they are the only errors while running the testsuite(!).\n\n\nWow, that's excellent news (except for my code `:-/`)!\n\n> Trivial to spot. Its possible that they are false positives if you use only certain bit positions, but zeroing out the memory doesn't cost much in terms of runtime and can save us a lot of work if your calculations about bit patterns are off by one ;-)\n\n\nTrue. Anyway, to fix it I probably need answers to my questions from [comment:147](#comment%3A147) in order to know exactly what to do.",
    "created_at": "2014-10-13T09:38:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203974",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:149'></a>
Replying to [vbraun](#comment%3A148):
> With the updated valgrind they are the only errors while running the testsuite(!).


Wow, that's excellent news (except for my code `:-/`)!

> Trivial to spot. Its possible that they are false positives if you use only certain bit positions, but zeroing out the memory doesn't cost much in terms of runtime and can save us a lot of work if your calculations about bit patterns are off by one ;-)


True. Anyway, to fix it I probably need answers to my questions from [comment:147](#comment%3A147) in order to know exactly what to do.



---

archive/issue_comments_203975.json:
```json
{
    "body": "<a id='comment:0'></a>\nIn the first one you are reading past the end of the buffer from unallocated memory. Either you need to allocate enough (round up) or also handle the cases where you have less than a full 8 bytes. Even though its highly unlikely, reading past the end could even result in a segfault if the process space happens to end there.",
    "created_at": "2014-10-13T12:16:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203975",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:0'></a>
In the first one you are reading past the end of the buffer from unallocated memory. Either you need to allocate enough (round up) or also handle the cases where you have less than a full 8 bytes. Even though its highly unlikely, reading past the end could even result in a segfault if the process space happens to end there.



---

archive/issue_comments_203976.json:
```json
{
    "body": "<a id='comment:1'></a>\nIf it's an \"invalid read of size 8\" and \"0 bytes after a block\" in mpn_copyi, chances are it's not a bug. GMP/MPIR will sometimes read 16 aligned bytes at a time when there are just 8 bytes left to copy, on certain architectures where this is safe. This might be the case in mpn_rshift too.\n\nIf you're absolutely sure that your code should be correct there, you could try compiling MPIR with assembly optimizations disabled and see if the error goes away. Or easier, temporarily replace the mpn_rshift in your code with a plain C implementation (e.g. the one in mpn/generic/rshift.c in MPIR).\n\nThe \"Conditional jump or move depends on uninitialised value\" is absolutely a bug.",
    "created_at": "2014-10-13T12:47:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203976",
    "user": "https://github.com/fredrik-johansson"
}
```

<a id='comment:1'></a>
If it's an "invalid read of size 8" and "0 bytes after a block" in mpn_copyi, chances are it's not a bug. GMP/MPIR will sometimes read 16 aligned bytes at a time when there are just 8 bytes left to copy, on certain architectures where this is safe. This might be the case in mpn_rshift too.

If you're absolutely sure that your code should be correct there, you could try compiling MPIR with assembly optimizations disabled and see if the error goes away. Or easier, temporarily replace the mpn_rshift in your code with a plain C implementation (e.g. the one in mpn/generic/rshift.c in MPIR).

The "Conditional jump or move depends on uninitialised value" is absolutely a bug.



---

archive/issue_comments_203977.json:
```json
{
    "body": "<a id='comment:152'></a>\nReplying to [vbraun](#comment%3A145):\n> I think they (the line numbers, SK) are (the same on different machines, SK), but I wouldn't bet anything on it ;-)\n\n\nHmm. The conditional jump occurs in line 2828 of the c-file, but this is:\n\n```\n  /* \"sage/misc/bounded_integer_sequences.pyx\":398\n *             n += S1.itembitsize\n *     mpz_clear(tmp)\n *     return -1             # <<<<<<<<<<<<<<\n * \n * cdef int index_biseq(biseq_t S, int item, size_t start) except -2:\n */   #### Here is 2828\n  __pyx_r = -1;\n  goto __pyx_L0;\n```\nHm. Volker, could you provide the location of the conditional jump that is giving you the warning?",
    "created_at": "2014-10-13T15:32:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203977",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:152'></a>
Replying to [vbraun](#comment%3A145):
> I think they (the line numbers, SK) are (the same on different machines, SK), but I wouldn't bet anything on it ;-)


Hmm. The conditional jump occurs in line 2828 of the c-file, but this is:

```
  /* "sage/misc/bounded_integer_sequences.pyx":398
 *             n += S1.itembitsize
 *     mpz_clear(tmp)
 *     return -1             # <<<<<<<<<<<<<<
 * 
 * cdef int index_biseq(biseq_t S, int item, size_t start) except -2:
 */   #### Here is 2828
  __pyx_r = -1;
  goto __pyx_L0;
```
Hm. Volker, could you provide the location of the conditional jump that is giving you the warning?



---

archive/issue_comments_203978.json:
```json
{
    "body": "<a id='comment:3'></a>\nI had a chat with Nathann today. He asked me about the data structure used by GMP, which is mainly `long*` (aka \"limb\"), plus some information on the number of limbs used and the number of limbs allocated. `long*` is also used by `sage.misc.bitset`.\n\nWhat I am implementing here is in fact quite similar to bitsets (one item of a bounded integer sequence corresponds to a chunk of bits, but otherwise it is the same). So, he suggested to not duplicate code, but make mutual use.\n\nI have looked at the bitset code in the past, but apparently it was long before I implemented bounded integer sequences: Now I realize that much of what I do here is actually done in `sage.misc.bitset`! So, definitely I should reuse the code. Hence, marking it as \"needs work\" for now, as the code will totally change.\n\nSuggestion: I'll add to `sage.misc.bitset` what is not already there, and then `sage.misc.bounded_integer_sequence` will not provide all the boilerplate code, but only provide the Python layer to comfortably use bounded integer sequences.",
    "created_at": "2014-10-15T11:57:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203978",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
I had a chat with Nathann today. He asked me about the data structure used by GMP, which is mainly `long*` (aka "limb"), plus some information on the number of limbs used and the number of limbs allocated. `long*` is also used by `sage.misc.bitset`.

What I am implementing here is in fact quite similar to bitsets (one item of a bounded integer sequence corresponds to a chunk of bits, but otherwise it is the same). So, he suggested to not duplicate code, but make mutual use.

I have looked at the bitset code in the past, but apparently it was long before I implemented bounded integer sequences: Now I realize that much of what I do here is actually done in `sage.misc.bitset`! So, definitely I should reuse the code. Hence, marking it as "needs work" for now, as the code will totally change.

Suggestion: I'll add to `sage.misc.bitset` what is not already there, and then `sage.misc.bounded_integer_sequence` will not provide all the boilerplate code, but only provide the Python layer to comfortably use bounded integer sequences.



---

archive/issue_comments_203979.json:
```json
{
    "body": "**Work_Issues:** Rework by using Sage's existing bitset code",
    "created_at": "2014-10-15T11:57:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203979",
    "user": "https://github.com/simon-king-jena"
}
```

**Work_Issues:** Rework by using Sage's existing bitset code



---

archive/issue_events_143603.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-15T11:57:13Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143603"
}
```



---

archive/issue_events_143604.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-15T11:57:13Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143604"
}
```



---

archive/issue_comments_203980.json:
```json
{
    "body": "<a id='comment:4'></a>\nI do need a bit more for `biseq_t` than what is provided by `bitset_t`. For example, I need to store the information how many bits are required to store one item on the list. But anyway, I will now try to rewrite my code.",
    "created_at": "2014-10-15T13:53:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203980",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
I do need a bit more for `biseq_t` than what is provided by `bitset_t`. For example, I need to store the information how many bits are required to store one item on the list. But anyway, I will now try to rewrite my code.



---

archive/issue_comments_203981.json:
```json
{
    "body": "**Changing commit** from \"[6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a](https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a)\" to \"[47c639d55d3c07670b8b52a629f7cf86a8beb7ce](https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce)\".",
    "created_at": "2014-10-18T13:38:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203981",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a](https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a)" to "[47c639d55d3c07670b8b52a629f7cf86a8beb7ce](https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce)".



---

archive/issue_comments_203982.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bfd7898a1f883c931026f46a526a0ec88bd73db6\">bfd7898</a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820, since apparently the bitset code changed</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce\">47c639d</a></td><td><code>Rewrite bounded integer sequences using sage.misc.bitset</code></td></tr></table>\n",
    "created_at": "2014-10-18T13:38:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203982",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bfd7898a1f883c931026f46a526a0ec88bd73db6">bfd7898</a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820, since apparently the bitset code changed</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce">47c639d</a></td><td><code>Rewrite bounded integer sequences using sage.misc.bitset</code></td></tr></table>




---

archive/issue_events_143605.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-18T13:45:20Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143605"
}
```



---

archive/issue_events_143606.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-18T13:45:20Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143606"
}
```



---

archive/issue_comments_203983.json:
```json
{
    "body": "**Changing work_issues** from \"Rework by using Sage's existing bitset code\" to \"\".",
    "created_at": "2014-10-18T13:45:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203983",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "Rework by using Sage's existing bitset code" to "".



---

archive/issue_comments_203984.json:
```json
{
    "body": "<a id='comment:6'></a>\nBy suggestion of Nathann, I am now reusing part of the existing code from `sage.misc.bitset`. Main advantage is the fact that (in contrast to the `mpz_*` functions) leading zeros will not be silently removed, which means that I could avoid many special cases.\n\nHopefully Nathann will find the new version of the code a lot less frightening than the old version...\n\nNeeds review again, and soonish I will update the timings that have occasionally been mentioned in comments above.",
    "created_at": "2014-10-18T13:45:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203984",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
By suggestion of Nathann, I am now reusing part of the existing code from `sage.misc.bitset`. Main advantage is the fact that (in contrast to the `mpz_*` functions) leading zeros will not be silently removed, which means that I could avoid many special cases.

Hopefully Nathann will find the new version of the code a lot less frightening than the old version...

Needs review again, and soonish I will update the timings that have occasionally been mentioned in comments above.



---

archive/issue_comments_203985.json:
```json
{
    "body": "<a id='comment:7'></a>\nLet us compare the performance tests from [comment:83](#comment%3A83) (also adding tests for\npickling) with the new code version (I am testing on the same laptop, thus,\nhopefully a comparison makes sense):\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.15 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n1000000 loops, best of 3: 1.35 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n1000000 loops, best of 3: 1.88 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n10000 loops, best of 3: 70.5 \u00b5s per loop\n```\n--> Became all faster\n\n```\nsage: %timeit x = list(S0)\n1000000 loops, best of 3: 1.43 \u00b5s per loop\nsage: %timeit x = list(S1)\n100000 loops, best of 3: 1.84 \u00b5s per loop\nsage: %timeit x = list(S2)\n100000 loops, best of 3: 4.41 \u00b5s per loop\nsage: %timeit x = list(S3)\n1000 loops, best of 3: 304 \u00b5s per loop\nsage: %timeit x = S0.list()\n1000000 loops, best of 3: 666 ns per loop\nsage: %timeit x = S1.list()\n1000000 loops, best of 3: 1.2 \u00b5s per loop\nsage: %timeit x = S2.list()\n100000 loops, best of 3: 2.77 \u00b5s per loop\nsage: %timeit x = S3.list()\n10000 loops, best of 3: 112 \u00b5s per loop\n```\n--> Became faster at least for short sequences, which is the case I am mainly\ninterested in\n\n```\nsage: timeit(\"x=S0[:-1]\", number=100000)\n100000 loops, best of 3: 1.49 \u00b5s per loop\nsage: timeit(\"x=S1[:-1]\", number=100000)\n100000 loops, best of 3: 1.52 \u00b5s per loop\nsage: timeit(\"x=S2[:-1]\", number=100000)\n100000 loops, best of 3: 1.52 \u00b5s per loop\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 2.29 \u00b5s per loop\n```\n--> Became all faster\n\n```\nsage: timeit(\"x=S2[:-1:2]\", number=10000)\n10000 loops, best of 3: 2.5 \u00b5s per loop\nsage: timeit(\"x=S3[:-1:2]\", number=10000)\n10000 loops, best of 3: 62.2 \u00b5s per loop\n```\n--> Became faster for the shorter sequence\n\n```\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 340 ns per loop\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 339 ns per loop\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 339 ns per loop\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 345 ns per loop\n```\n--> Became all faster\n\n```\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: S1y = BoundedIntegerSequence(16, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S1y==S1!=S1x, S1y is not S1\n(True, True)\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0z2.startswith(S0)\", number=1000000)\n1000000 loops, best of 3: 210 ns per loop\nsage: timeit(\"S0z2.startswith(S0x)\", number=1000000)\n1000000 loops, best of 3: 211 ns per loop\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 368 ns per loop\nsage: timeit(\"S1z2.startswith(S1)\", number=1000000)\n1000000 loops, best of 3: 200 ns per loop\nsage: timeit(\"S1z2.startswith(S1x)\", number=1000000)\n1000000 loops, best of 3: 199 ns per loop\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 542 ns per loop\nsage: timeit(\"S2z2.startswith(S2)\", number=1000000)\n1000000 loops, best of 3: 219 ns per loop\nsage: timeit(\"S2z2.startswith(S2x)\", number=1000000)\n1000000 loops, best of 3: 205 ns per loop\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 2.33 \u00b5s per loop\nsage: timeit(\"S3z2.startswith(S3)\", number=1000000)\n1000000 loops, best of 3: 963 ns per loop\nsage: timeit(\"S3z2.startswith(S3x)\", number=1000000)\n1000000 loops, best of 3: 201 ns per loop\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 2.36 ms per loop\n```\n--> All but the last became faster, which is excellent for my applications, as\nI am using subsequence containment tests fairly often.\n\nAdditional timings for pickling, comparing Python lists with bounded integer\nsequences:\n\n```\nsage: %timeit loads(dumps(L0))\n10000 loops, best of 3: 39.5 \u00b5s per loop\nsage: %timeit loads(dumps(L1))\n10000 loops, best of 3: 43.9 \u00b5s per loop\nsage: %timeit loads(dumps(L2))\n10000 loops, best of 3: 65.5 \u00b5s per loop\nsage: %timeit loads(dumps(L3))\n100 loops, best of 3: 2.13 ms per loop\nsage: %timeit loads(dumps(S0))\n10000 loops, best of 3: 68.7 \u00b5s per loop\nsage: %timeit loads(dumps(S1))\n10000 loops, best of 3: 72.1 \u00b5s per loop\nsage: %timeit loads(dumps(S2))\n10000 loops, best of 3: 87 \u00b5s per loop\nsage: %timeit loads(dumps(S3))\n1000 loops, best of 3: 1.06 ms per loop\n```\n--> Pickling of short bounded integer sequences has an overhead, but longer\nsequences are pickled faster, due to the more compact representation.\n\nI think that one can say that the new code version results in an overall performance gain,\nand I suppose it is less frightening now.",
    "created_at": "2014-10-18T14:11:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203985",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Let us compare the performance tests from [comment:83](#comment%3A83) (also adding tests for
pickling) with the new code version (I am testing on the same laptop, thus,
hopefully a comparison makes sense):

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.15 µs per loop
sage: %timeit x = BoundedIntegerSequence(16, L1)
1000000 loops, best of 3: 1.35 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L2)
1000000 loops, best of 3: 1.88 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L3)
10000 loops, best of 3: 70.5 µs per loop
```
--> Became all faster

```
sage: %timeit x = list(S0)
1000000 loops, best of 3: 1.43 µs per loop
sage: %timeit x = list(S1)
100000 loops, best of 3: 1.84 µs per loop
sage: %timeit x = list(S2)
100000 loops, best of 3: 4.41 µs per loop
sage: %timeit x = list(S3)
1000 loops, best of 3: 304 µs per loop
sage: %timeit x = S0.list()
1000000 loops, best of 3: 666 ns per loop
sage: %timeit x = S1.list()
1000000 loops, best of 3: 1.2 µs per loop
sage: %timeit x = S2.list()
100000 loops, best of 3: 2.77 µs per loop
sage: %timeit x = S3.list()
10000 loops, best of 3: 112 µs per loop
```
--> Became faster at least for short sequences, which is the case I am mainly
interested in

```
sage: timeit("x=S0[:-1]", number=100000)
100000 loops, best of 3: 1.49 µs per loop
sage: timeit("x=S1[:-1]", number=100000)
100000 loops, best of 3: 1.52 µs per loop
sage: timeit("x=S2[:-1]", number=100000)
100000 loops, best of 3: 1.52 µs per loop
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 2.29 µs per loop
```
--> Became all faster

```
sage: timeit("x=S2[:-1:2]", number=10000)
10000 loops, best of 3: 2.5 µs per loop
sage: timeit("x=S3[:-1:2]", number=10000)
10000 loops, best of 3: 62.2 µs per loop
```
--> Became faster for the shorter sequence

```
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 340 ns per loop
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 339 ns per loop
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 339 ns per loop
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 345 ns per loop
```
--> Became all faster

```
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: S1y = BoundedIntegerSequence(16, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S1y==S1!=S1x, S1y is not S1
(True, True)
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0z2.startswith(S0)", number=1000000)
1000000 loops, best of 3: 210 ns per loop
sage: timeit("S0z2.startswith(S0x)", number=1000000)
1000000 loops, best of 3: 211 ns per loop
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 368 ns per loop
sage: timeit("S1z2.startswith(S1)", number=1000000)
1000000 loops, best of 3: 200 ns per loop
sage: timeit("S1z2.startswith(S1x)", number=1000000)
1000000 loops, best of 3: 199 ns per loop
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 542 ns per loop
sage: timeit("S2z2.startswith(S2)", number=1000000)
1000000 loops, best of 3: 219 ns per loop
sage: timeit("S2z2.startswith(S2x)", number=1000000)
1000000 loops, best of 3: 205 ns per loop
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 2.33 µs per loop
sage: timeit("S3z2.startswith(S3)", number=1000000)
1000000 loops, best of 3: 963 ns per loop
sage: timeit("S3z2.startswith(S3x)", number=1000000)
1000000 loops, best of 3: 201 ns per loop
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 2.36 ms per loop
```
--> All but the last became faster, which is excellent for my applications, as
I am using subsequence containment tests fairly often.

Additional timings for pickling, comparing Python lists with bounded integer
sequences:

```
sage: %timeit loads(dumps(L0))
10000 loops, best of 3: 39.5 µs per loop
sage: %timeit loads(dumps(L1))
10000 loops, best of 3: 43.9 µs per loop
sage: %timeit loads(dumps(L2))
10000 loops, best of 3: 65.5 µs per loop
sage: %timeit loads(dumps(L3))
100 loops, best of 3: 2.13 ms per loop
sage: %timeit loads(dumps(S0))
10000 loops, best of 3: 68.7 µs per loop
sage: %timeit loads(dumps(S1))
10000 loops, best of 3: 72.1 µs per loop
sage: %timeit loads(dumps(S2))
10000 loops, best of 3: 87 µs per loop
sage: %timeit loads(dumps(S3))
1000 loops, best of 3: 1.06 ms per loop
```
--> Pickling of short bounded integer sequences has an overhead, but longer
sequences are pickled faster, due to the more compact representation.

I think that one can say that the new code version results in an overall performance gain,
and I suppose it is less frightening now.



---

archive/issue_comments_203986.json:
```json
{
    "body": "**Changing commit** from \"[47c639d55d3c07670b8b52a629f7cf86a8beb7ce](https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce)\" to \"[e3260e2d9f5bf0483770cc5235c00cd24c4eb310](https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310)\".",
    "created_at": "2014-10-18T15:28:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203986",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[47c639d55d3c07670b8b52a629f7cf86a8beb7ce](https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce)" to "[e3260e2d9f5bf0483770cc5235c00cd24c4eb310](https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310)".



---

archive/issue_comments_203987.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310\">e3260e2</a></td><td><code>Typographical improvements</code></td></tr></table>\n",
    "created_at": "2014-10-18T15:28:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203987",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310">e3260e2</a></td><td><code>Typographical improvements</code></td></tr></table>




---

archive/issue_comments_203988.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1\">aac3a04</a></td><td><code>Fix cornercase in unpickling</code></td></tr></table>\n",
    "created_at": "2014-10-18T22:13:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203988",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1">aac3a04</a></td><td><code>Fix cornercase in unpickling</code></td></tr></table>




---

archive/issue_comments_203989.json:
```json
{
    "body": "**Changing commit** from \"[e3260e2d9f5bf0483770cc5235c00cd24c4eb310](https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310)\" to \"[aac3a049805ab29aea8a0d3439c1eadf6605eab1](https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1)\".",
    "created_at": "2014-10-18T22:13:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203989",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[e3260e2d9f5bf0483770cc5235c00cd24c4eb310](https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310)" to "[aac3a049805ab29aea8a0d3439c1eadf6605eab1](https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1)".



---

archive/issue_comments_203990.json:
```json
{
    "body": "**Changing commit** from \"[aac3a049805ab29aea8a0d3439c1eadf6605eab1](https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1)\" to \"[b182ba27bdaeb0f066daf1b575db3588b3195f89](https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89)\".",
    "created_at": "2014-10-19T09:00:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203990",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[aac3a049805ab29aea8a0d3439c1eadf6605eab1](https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1)" to "[b182ba27bdaeb0f066daf1b575db3588b3195f89](https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89)".



---

archive/issue_comments_203991.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89\">b182ba2</a></td><td><code>Use mpn_l/rshift only with nonzero shift</code></td></tr></table>\n",
    "created_at": "2014-10-19T09:00:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203991",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89">b182ba2</a></td><td><code>Use mpn_l/rshift only with nonzero shift</code></td></tr></table>




---

archive/issue_comments_203992.json:
```json
{
    "body": "<a id='comment:1'></a>\nJust randomly looking through this patch...\n\nI don't like to put this in `src/sage/misc`. There is already too much stuff there. I think we need an additional top-level directory for basic data structures like this (bitset also should be in there). What do you think of `src/sage/data_structures`?",
    "created_at": "2014-10-21T13:44:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203992",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:1'></a>
Just randomly looking through this patch...

I don't like to put this in `src/sage/misc`. There is already too much stuff there. I think we need an additional top-level directory for basic data structures like this (bitset also should be in there). What do you think of `src/sage/data_structures`?



---

archive/issue_comments_203993.json:
```json
{
    "body": "<a id='comment:2'></a>\nAlso, instead of `allocate_biseq()`, I would use `biseq_init()` to be more analogous to `mpz_init()` and `bitset_init()`. More generally, replace `foo_biseq()` by `biseq_foo()`.",
    "created_at": "2014-10-21T13:47:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203993",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>
Also, instead of `allocate_biseq()`, I would use `biseq_init()` to be more analogous to `mpz_init()` and `bitset_init()`. More generally, replace `foo_biseq()` by `biseq_foo()`.



---

archive/issue_comments_203994.json:
```json
{
    "body": "<a id='comment:3'></a>\nPlease don't `cdef extern from \"gmp.h\"`, use `from sage.libs.gmp.mpn cimport *` or something.",
    "created_at": "2014-10-21T13:48:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203994",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>
Please don't `cdef extern from "gmp.h"`, use `from sage.libs.gmp.mpn cimport *` or something.



---

archive/issue_comments_203995.json:
```json
{
    "body": "<a id='comment:164'></a>\nReplying to [jdemeyer](#comment%3A161):\n> Just randomly looking through this patch...\n> \n> I don't like to put this in `src/sage/misc`. There is already too much stuff there. I think we need an additional top-level directory for basic data structures like this (bitset also should be in there). What do you think of `src/sage/data_structures`?\n\n\nI think this question has been discussed on another ticket that I authored. My impression from the discussion was that \"structural\" stuff should either go to `sage/structure` or `sage/misc`. It should be the former, if it is about structures that only make sense in Sage (Parents, elements, ...), whereas `sage/misc` is for structure that would also make sense without Sage. I thought that bounded integer sequences belong to the latter, and I would also think that `TripleDict` and `MonoDict` should better be in `sage/misc` (the only reason for them being in `sage/structure` is the fact that they were introduced for coercion, which is Sage specific).\n\nSo, I think `sage/misc` is a good place. But I wouldn't mind to introduce a third structural module, `sage/data_structures`. On a different ticket?",
    "created_at": "2014-10-21T13:58:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203995",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:164'></a>
Replying to [jdemeyer](#comment%3A161):
> Just randomly looking through this patch...
> 
> I don't like to put this in `src/sage/misc`. There is already too much stuff there. I think we need an additional top-level directory for basic data structures like this (bitset also should be in there). What do you think of `src/sage/data_structures`?


I think this question has been discussed on another ticket that I authored. My impression from the discussion was that "structural" stuff should either go to `sage/structure` or `sage/misc`. It should be the former, if it is about structures that only make sense in Sage (Parents, elements, ...), whereas `sage/misc` is for structure that would also make sense without Sage. I thought that bounded integer sequences belong to the latter, and I would also think that `TripleDict` and `MonoDict` should better be in `sage/misc` (the only reason for them being in `sage/structure` is the fact that they were introduced for coercion, which is Sage specific).

So, I think `sage/misc` is a good place. But I wouldn't mind to introduce a third structural module, `sage/data_structures`. On a different ticket?



---

archive/issue_comments_203996.json:
```json
{
    "body": "<a id='comment:165'></a>\nReplying to [jdemeyer](#comment%3A162):\n> Also, instead of `allocate_biseq()`, I would use `biseq_init()` to be more analogous to `mpz_init()` and `bitset_init()`.\n> More generally, replace `foo_biseq()` by `biseq_foo()`.\n\n\nOk, makes sense.",
    "created_at": "2014-10-21T14:00:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203996",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:165'></a>
Replying to [jdemeyer](#comment%3A162):
> Also, instead of `allocate_biseq()`, I would use `biseq_init()` to be more analogous to `mpz_init()` and `bitset_init()`.
> More generally, replace `foo_biseq()` by `biseq_foo()`.


Ok, makes sense.



---

archive/issue_comments_203997.json:
```json
{
    "body": "<a id='comment:166'></a>\nReplying to [jdemeyer](#comment%3A163):\n> Please don't `cdef extern from \"gmp.h\"`, use `from sage.libs.gmp.mpn cimport *` or something.\n\n\nIs it available from there? If it is, then I should certainly do it in that way.",
    "created_at": "2014-10-21T14:03:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203997",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:166'></a>
Replying to [jdemeyer](#comment%3A163):
> Please don't `cdef extern from "gmp.h"`, use `from sage.libs.gmp.mpn cimport *` or something.


Is it available from there? If it is, then I should certainly do it in that way.



---

archive/issue_comments_203998.json:
```json
{
    "body": "<a id='comment:167'></a>\nReplying to [SimonKing](#comment%3A166):\n> Replying to [jdemeyer](#comment%3A163):\n> > Please don't `cdef extern from \"gmp.h\"`, use `from sage.libs.gmp.mpn cimport *` or something.\n\n> \n> Is it available from there? If it is, then I should certainly do it in that way.\n\n\n`mp_bits_per_limb` is not available from there, hence, I still import it from gmp.h.\n\nFor now I will not introduce a new `sage.data_structures`.\n\nAfter running tests, I will push a commit that address your other comments.",
    "created_at": "2014-10-21T14:34:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203998",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:167'></a>
Replying to [SimonKing](#comment%3A166):
> Replying to [jdemeyer](#comment%3A163):
> > Please don't `cdef extern from "gmp.h"`, use `from sage.libs.gmp.mpn cimport *` or something.

> 
> Is it available from there? If it is, then I should certainly do it in that way.


`mp_bits_per_limb` is not available from there, hence, I still import it from gmp.h.

For now I will not introduce a new `sage.data_structures`.

After running tests, I will push a commit that address your other comments.



---

archive/issue_comments_203999.json:
```json
{
    "body": "**Changing commit** from \"[b182ba27bdaeb0f066daf1b575db3588b3195f89](https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89)\" to \"[1f5a53e7b23e406c553d789f83604cd4a7f90655](https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655)\".",
    "created_at": "2014-10-21T14:36:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-203999",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[b182ba27bdaeb0f066daf1b575db3588b3195f89](https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89)" to "[1f5a53e7b23e406c553d789f83604cd4a7f90655](https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655)".



---

archive/issue_comments_204000.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655\">1f5a53e</a></td><td><code>Change the naming schemes of functions according to conventions in gmp and bitset</code></td></tr></table>\n",
    "created_at": "2014-10-21T14:36:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204000",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655">1f5a53e</a></td><td><code>Change the naming schemes of functions according to conventions in gmp and bitset</code></td></tr></table>




---

archive/issue_comments_204001.json:
```json
{
    "body": "<a id='comment:169'></a>\nReplying to [SimonKing](#comment%3A164):\n> On a different ticket?\n\nIt makes no sense to first introduce a new module on this ticket and then make a new ticket to immediately move that new module somewhere else (requiring changing import statements and everything). If it were an existing module, things would be different.\n\nThe problem with `src/sage/misc` is that it contains a lot of various things. Usually \"misc\" is used when something doesn't belong to any other category. But it's clear that there are a lot of modules defining data structures in `misc` (but also other stuff like `temporary_file`). I think it makes sense to group these in `src/sage/data_structures` (or another name, whatever) instead of dumping everything in `misc`.",
    "created_at": "2014-10-21T15:34:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204001",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:169'></a>
Replying to [SimonKing](#comment%3A164):
> On a different ticket?

It makes no sense to first introduce a new module on this ticket and then make a new ticket to immediately move that new module somewhere else (requiring changing import statements and everything). If it were an existing module, things would be different.

The problem with `src/sage/misc` is that it contains a lot of various things. Usually "misc" is used when something doesn't belong to any other category. But it's clear that there are a lot of modules defining data structures in `misc` (but also other stuff like `temporary_file`). I think it makes sense to group these in `src/sage/data_structures` (or another name, whatever) instead of dumping everything in `misc`.



---

archive/issue_comments_204002.json:
```json
{
    "body": "<a id='comment:170'></a>\nReplying to [SimonKing](#comment%3A167):\n> `mp_bits_per_limb` is not available from there, hence, I still import it from gmp.h.\n\nNo, *do* cimport it from `sage.libs.gmp.types` and add the declaration there.",
    "created_at": "2014-10-21T15:42:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204002",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:170'></a>
Replying to [SimonKing](#comment%3A167):
> `mp_bits_per_limb` is not available from there, hence, I still import it from gmp.h.

No, *do* cimport it from `sage.libs.gmp.types` and add the declaration there.



---

archive/issue_comments_204003.json:
```json
{
    "body": "<a id='comment:1'></a>\nThis documentation of `ctypedef struct biseq` should be expanded. When reading it, it is really not clear to me what the various fields mean (especially `\"bla&mask_item\" greps onethe item bla starts with` makes no sense) and how the data structure works. If you're trying too hard to get everything one line, use\n\n```\nctypedef struct biseq:\n    # comment about data\n    bitset_t data\n\n    # comment about itembitsize\n    # comment about itembitsize\n    # comment about itembitsize\n    mp_bitcnt_t itembitsize\n...\n```",
    "created_at": "2014-10-21T15:48:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204003",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:1'></a>
This documentation of `ctypedef struct biseq` should be expanded. When reading it, it is really not clear to me what the various fields mean (especially `"bla&mask_item" greps onethe item bla starts with` makes no sense) and how the data structure works. If you're trying too hard to get everything one line, use

```
ctypedef struct biseq:
    # comment about data
    bitset_t data

    # comment about itembitsize
    # comment about itembitsize
    # comment about itembitsize
    mp_bitcnt_t itembitsize
...
```



---

archive/issue_events_143607.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-21T15:48:44Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143607"
}
```



---

archive/issue_events_143608.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-21T15:48:44Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143608"
}
```



---

archive/issue_comments_204004.json:
```json
{
    "body": "<a id='comment:3'></a>\n`first_bits_equal` -> `biseq_first_bits_equal`",
    "created_at": "2014-10-21T15:49:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204004",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>
`first_bits_equal` -> `biseq_first_bits_equal`



---

archive/issue_comments_204005.json:
```json
{
    "body": "<a id='comment:4'></a>\nAlso: I think you use `int` in a lot of places where you really want a `long` or `mp_limb_t` or `mp_size_t` or `Py_ssize_t`.",
    "created_at": "2014-10-21T15:53:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204005",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
Also: I think you use `int` in a lot of places where you really want a `long` or `mp_limb_t` or `mp_size_t` or `Py_ssize_t`.



---

archive/issue_comments_204006.json:
```json
{
    "body": "<a id='comment:5'></a>\n`list_to_biseq` seems to leak memory if the `biseq_t` was already initialized. I don't mind, but it should be documented, since it's not obvious without reading the code.\n\nAlso in `list_to_biseq`, the branch `if ln>mp_bits_per_limb:` leaks `tmp`.",
    "created_at": "2014-10-21T16:00:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204006",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
`list_to_biseq` seems to leak memory if the `biseq_t` was already initialized. I don't mind, but it should be documented, since it's not obvious without reading the code.

Also in `list_to_biseq`, the branch `if ln>mp_bits_per_limb:` leaks `tmp`.



---

archive/issue_comments_204007.json:
```json
{
    "body": "<a id='comment:176'></a>\nReplying to [jdemeyer](#comment%3A169):\n> Replying to [SimonKing](#comment%3A164):\n> > On a different ticket?\n\n> It makes no sense to first introduce a new module on this ticket and then make a new ticket to immediately move that new module somewhere else\n\nExcept that the new ticket is not just about moving `sage.misc.bounded_integer_sequences` to `sage.data_structures.bounded_integer_sequences`, but moves a whole lot more.\n\nOn THIS ticket, it does not make sense to dooe the big move from `sage.misc` to `sage.data_structures`, since this ticket is about introducing bounded integer sequences",
    "created_at": "2014-10-21T16:03:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204007",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:176'></a>
Replying to [jdemeyer](#comment%3A169):
> Replying to [SimonKing](#comment%3A164):
> > On a different ticket?

> It makes no sense to first introduce a new module on this ticket and then make a new ticket to immediately move that new module somewhere else

Except that the new ticket is not just about moving `sage.misc.bounded_integer_sequences` to `sage.data_structures.bounded_integer_sequences`, but moves a whole lot more.

On THIS ticket, it does not make sense to dooe the big move from `sage.misc` to `sage.data_structures`, since this ticket is about introducing bounded integer sequences



---

archive/issue_comments_204008.json:
```json
{
    "body": "<a id='comment:177'></a>\nReplying to [jdemeyer](#comment%3A169):\n> The problem with `src/sage/misc` is that it contains a lot of various things. Usually \"misc\" is used when something doesn't belong to any other category.\n\n\nYeah, and most of the time this is stuff that does not really belong to Sage in the first place, and should eventually be moved to upstream libraries. In some sense, it can be seen as a feature that it looks wrong there: it gives an incent for developpers to finally take on the task of actually moving the stuff upstream.",
    "created_at": "2014-10-21T16:10:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204008",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:177'></a>
Replying to [jdemeyer](#comment%3A169):
> The problem with `src/sage/misc` is that it contains a lot of various things. Usually "misc" is used when something doesn't belong to any other category.


Yeah, and most of the time this is stuff that does not really belong to Sage in the first place, and should eventually be moved to upstream libraries. In some sense, it can be seen as a feature that it looks wrong there: it gives an incent for developpers to finally take on the task of actually moving the stuff upstream.



---

archive/issue_comments_204009.json:
```json
{
    "body": "<a id='comment:178'></a>\nReplying to [jdemeyer](#comment%3A174):\n> Also: I think you use `int` in a lot of places where you really want a `long` or `mp_limb_t` or `mp_size_t` or `Py_ssize_t`.\n\n\nI tried to be consistent. However, I do not find documentation: What is the purpose of `mp_size_t` versus `mp_bitcnt_t`?",
    "created_at": "2014-10-21T16:11:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204009",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:178'></a>
Replying to [jdemeyer](#comment%3A174):
> Also: I think you use `int` in a lot of places where you really want a `long` or `mp_limb_t` or `mp_size_t` or `Py_ssize_t`.


I tried to be consistent. However, I do not find documentation: What is the purpose of `mp_size_t` versus `mp_bitcnt_t`?



---

archive/issue_comments_204010.json:
```json
{
    "body": "<a id='comment:179'></a>\nReplying to [SimonKing](#comment%3A176):\n> On THIS ticket, it does not make sense to do the big move from `sage.misc` to `sage.data_structures`\n\nOf course not. But I meant to add the new module `bounded_integer_sequences` to `sage.data_structures` (the result being that this would be the only module inside `sage.data_structures`). Putting it in the correct place immediately is better than first putting it somewhere else and then moving it.",
    "created_at": "2014-10-21T16:11:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204010",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:179'></a>
Replying to [SimonKing](#comment%3A176):
> On THIS ticket, it does not make sense to do the big move from `sage.misc` to `sage.data_structures`

Of course not. But I meant to add the new module `bounded_integer_sequences` to `sage.data_structures` (the result being that this would be the only module inside `sage.data_structures`). Putting it in the correct place immediately is better than first putting it somewhere else and then moving it.



---

archive/issue_comments_204011.json:
```json
{
    "body": "<a id='comment:0'></a>\nStrangely, in gmp.h, I see that `mp_size_t` is `long long int`, hence, it is a *signed* type, in contrast to Python's `size_t`.",
    "created_at": "2014-10-21T16:14:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204011",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Strangely, in gmp.h, I see that `mp_size_t` is `long long int`, hence, it is a *signed* type, in contrast to Python's `size_t`.



---

archive/issue_comments_204012.json:
```json
{
    "body": "<a id='comment:181'></a>\nReplying to [jdemeyer](#comment%3A179):\n> Replying to [SimonKing](#comment%3A176):\n> > On THIS ticket, it does not make sense to do the big move from `sage.misc` to `sage.data_structures`\n\n> Of course not. But I meant to add the new module `bounded_integer_sequences` to `sage.data_structures` (the result being that this would be the only module inside `sage.data_structures`).\n\nOK. This I could do.",
    "created_at": "2014-10-21T16:15:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204012",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:181'></a>
Replying to [jdemeyer](#comment%3A179):
> Replying to [SimonKing](#comment%3A176):
> > On THIS ticket, it does not make sense to do the big move from `sage.misc` to `sage.data_structures`

> Of course not. But I meant to add the new module `bounded_integer_sequences` to `sage.data_structures` (the result being that this would be the only module inside `sage.data_structures`).

OK. This I could do.



---

archive/issue_comments_204013.json:
```json
{
    "body": "<a id='comment:2'></a>\nReplying to [jdemeyer](#comment%3A174):\n> I tried to be consistent.\n\nThe problem is that `mp_bits_per_limb` is about the number of bits in `mp_limb_t`, not the number of bits in `int`. And using `int` for indices is inconsistent with Python which uses `Py_ssize_t` (which should be the same as `mp_size_t`).",
    "created_at": "2014-10-21T16:16:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204013",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>
Replying to [jdemeyer](#comment%3A174):
> I tried to be consistent.

The problem is that `mp_bits_per_limb` is about the number of bits in `mp_limb_t`, not the number of bits in `int`. And using `int` for indices is inconsistent with Python which uses `Py_ssize_t` (which should be the same as `mp_size_t`).



---

archive/issue_comments_204014.json:
```json
{
    "body": "<a id='comment:3'></a>\nI would say: use `mp_size_t` for indices, `mp_limb_t` for the actual integers inside your sequences.",
    "created_at": "2014-10-21T16:19:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204014",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>
I would say: use `mp_size_t` for indices, `mp_limb_t` for the actual integers inside your sequences.



---

archive/issue_comments_204015.json:
```json
{
    "body": "<a id='comment:184'></a>\nReplying to [jdemeyer](#comment%3A182):\n> Replying to [jdemeyer](#comment%3A174):\n> > I tried to be consistent.\n\n> The problem is that `mp_bits_per_limb` is about the number of bits in `mp_limb_t`, not the number of bits in `int`. And using `int` for indices is inconsistent with Python which uses `Py_ssize_t` (which should be the same as `mp_size_t`).\n\nOK. So, I should use `mp_size_t` for indices. But what should I use `mp_bitcnt_t` for?",
    "created_at": "2014-10-21T16:21:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204015",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:184'></a>
Replying to [jdemeyer](#comment%3A182):
> Replying to [jdemeyer](#comment%3A174):
> > I tried to be consistent.

> The problem is that `mp_bits_per_limb` is about the number of bits in `mp_limb_t`, not the number of bits in `int`. And using `int` for indices is inconsistent with Python which uses `Py_ssize_t` (which should be the same as `mp_size_t`).

OK. So, I should use `mp_size_t` for indices. But what should I use `mp_bitcnt_t` for?



---

archive/issue_comments_204016.json:
```json
{
    "body": "<a id='comment:185'></a>\nReplying to [jdemeyer](#comment%3A183):\n> I would say: use `mp_size_t` for indices, `mp_limb_t` for the actual integers inside your sequences.\n\n\nIf I am not mistaken, I always use `mp_limb_t` for the limbs. If you find a spot where this is not the case, please tell me.",
    "created_at": "2014-10-21T16:23:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204016",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:185'></a>
Replying to [jdemeyer](#comment%3A183):
> I would say: use `mp_size_t` for indices, `mp_limb_t` for the actual integers inside your sequences.


If I am not mistaken, I always use `mp_limb_t` for the limbs. If you find a spot where this is not the case, please tell me.



---

archive/issue_comments_204017.json:
```json
{
    "body": "<a id='comment:186'></a>\nReplying to [SimonKing](#comment%3A184):\n> But what should I use `mp_bitcnt_t` for?\n\nAny time you need a count of bits (which is always positive!)...",
    "created_at": "2014-10-21T16:24:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204017",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:186'></a>
Replying to [SimonKing](#comment%3A184):
> But what should I use `mp_bitcnt_t` for?

Any time you need a count of bits (which is always positive!)...



---

archive/issue_comments_204018.json:
```json
{
    "body": "<a id='comment:187'></a>\nReplying to [SimonKing](#comment%3A185):\n> If you find a spot where this is not the case, please tell me.\n\n\n```\n cdef int biseq_getitem(biseq_t S, mp_size_t index) except -1\n      ^^^\n```",
    "created_at": "2014-10-21T16:25:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204018",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:187'></a>
Replying to [SimonKing](#comment%3A185):
> If you find a spot where this is not the case, please tell me.


```
 cdef int biseq_getitem(biseq_t S, mp_size_t index) except -1
      ^^^
```



---

archive/issue_comments_204019.json:
```json
{
    "body": "<a id='comment:8'></a>\nI would say: when in doubt between `mp_size_t` and `mp_bitcnt_t`, use `mp_size_t`.\n\nWhen in doubt between `int` and anything else: use the anything else.",
    "created_at": "2014-10-21T16:27:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204019",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
I would say: when in doubt between `mp_size_t` and `mp_bitcnt_t`, use `mp_size_t`.

When in doubt between `int` and anything else: use the anything else.



---

archive/issue_comments_204020.json:
```json
{
    "body": "<a id='comment:189'></a>\nReplying to [jdemeyer](#comment%3A186):\n> Replying to [SimonKing](#comment%3A184):\n> > But what should I use `mp_bitcnt_t` for?\n\n> Any time you need a count of bits (which is always positive!)...\n\nYou mean, in particular, that I should *not* use it for an index? Hence, if I want to refer to bit number `b` in limb number `l`, then both `b` and `l` should be `mp_size_t`? Currently, I try to consistently use `mp_bitcnt_t` for `b` and `mp_size_t` for `l`.",
    "created_at": "2014-10-21T16:33:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204020",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:189'></a>
Replying to [jdemeyer](#comment%3A186):
> Replying to [SimonKing](#comment%3A184):
> > But what should I use `mp_bitcnt_t` for?

> Any time you need a count of bits (which is always positive!)...

You mean, in particular, that I should *not* use it for an index? Hence, if I want to refer to bit number `b` in limb number `l`, then both `b` and `l` should be `mp_size_t`? Currently, I try to consistently use `mp_bitcnt_t` for `b` and `mp_size_t` for `l`.



---

archive/issue_comments_204021.json:
```json
{
    "body": "<a id='comment:190'></a>\nReplying to [jdemeyer](#comment%3A187):\n> Replying to [SimonKing](#comment%3A185):\n> > If you find a spot where this is not the case, please tell me.\n\n> {{{\n> cdef int biseq_getitem(biseq_t S, mp_size_t index) except -1\n>      <sup>^</sup>\n> }}}\n\n\nRationale: This function does not return a limb, but only one item (and a limb may comprise many items). To keep them apart, I chose a different type. Moreover, I consider `mp_limb_t` as a type that belongs to gmp. But the return type of that function should belong to the \"Python world\".",
    "created_at": "2014-10-21T16:36:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204021",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:190'></a>
Replying to [jdemeyer](#comment%3A187):
> Replying to [SimonKing](#comment%3A185):
> > If you find a spot where this is not the case, please tell me.

> {{{
> cdef int biseq_getitem(biseq_t S, mp_size_t index) except -1
>      <sup>^</sup>
> }}}


Rationale: This function does not return a limb, but only one item (and a limb may comprise many items). To keep them apart, I chose a different type. Moreover, I consider `mp_limb_t` as a type that belongs to gmp. But the return type of that function should belong to the "Python world".



---

archive/issue_comments_204022.json:
```json
{
    "body": "<a id='comment:192'></a>\nReplying to [SimonKing](#comment%3A190):\n> I consider `mp_limb_t` as a type that belongs to gmp. But the return type of that function should belong to the \"Python world\".\n\n`int` doesn't belong to the Python world either (don't confuse Cython `int` with Python `int`!)",
    "created_at": "2014-10-21T17:18:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204022",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:192'></a>
Replying to [SimonKing](#comment%3A190):
> I consider `mp_limb_t` as a type that belongs to gmp. But the return type of that function should belong to the "Python world".

`int` doesn't belong to the Python world either (don't confuse Cython `int` with Python `int`!)



---

archive/issue_comments_204023.json:
```json
{
    "body": "<a id='comment:193'></a>\nReplying to [SimonKing](#comment%3A189):\n> Replying to [jdemeyer](#comment%3A186):\n> > Replying to [SimonKing](#comment%3A184):\n> > > But what should I use `mp_bitcnt_t` for?\n\n> > Any time you need a count of bits (which is always positive!)...\n> \n> You mean, in particular, that I should *not* use it for an index? Hence, if I want to refer to bit number `b` in limb number `l`, then both `b` and `l` should be `mp_size_t`? Currently, I try to consistently use `mp_bitcnt_t` for `b` and `mp_size_t` for `l`.\n\nUsing `mp_bitcnt_t` for this is fine, when I said \"index\" I meant index like for Python `__getitem__`",
    "created_at": "2014-10-21T17:20:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204023",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:193'></a>
Replying to [SimonKing](#comment%3A189):
> Replying to [jdemeyer](#comment%3A186):
> > Replying to [SimonKing](#comment%3A184):
> > > But what should I use `mp_bitcnt_t` for?

> > Any time you need a count of bits (which is always positive!)...
> 
> You mean, in particular, that I should *not* use it for an index? Hence, if I want to refer to bit number `b` in limb number `l`, then both `b` and `l` should be `mp_size_t`? Currently, I try to consistently use `mp_bitcnt_t` for `b` and `mp_size_t` for `l`.

Using `mp_bitcnt_t` for this is fine, when I said "index" I meant index like for Python `__getitem__`



---

archive/issue_comments_204024.json:
```json
{
    "body": "<a id='comment:194'></a>\nReplying to [SimonKing](#comment%3A190):\n> To keep them apart, I chose a different type.\n\nIf that's the main motivation, define a new type:\n\n```\nctypedef mp_limb_t biseq_item_t\n```",
    "created_at": "2014-10-21T17:22:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204024",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:194'></a>
Replying to [SimonKing](#comment%3A190):
> To keep them apart, I chose a different type.

If that's the main motivation, define a new type:

```
ctypedef mp_limb_t biseq_item_t
```



---

archive/issue_comments_204025.json:
```json
{
    "body": "<a id='comment:5'></a>\nAlso, if `bound` is of type `mp_limb_t`, then the following check is not needed at all:\n\n```\nmpz_init_set_ui(tmp, bound-1)\nln = mpz_sizeinbase(tmp, 2)\nif ln>mp_bits_per_limb:\n    raise ValueError(\"The integer bound {} does not fit into {}\".format(bound, mp_bits_per_limb))\n```",
    "created_at": "2014-10-21T17:26:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204025",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
Also, if `bound` is of type `mp_limb_t`, then the following check is not needed at all:

```
mpz_init_set_ui(tmp, bound-1)
ln = mpz_sizeinbase(tmp, 2)
if ln>mp_bits_per_limb:
    raise ValueError("The integer bound {} does not fit into {}".format(bound, mp_bits_per_limb))
```



---

archive/issue_comments_204026.json:
```json
{
    "body": "<a id='comment:6'></a>\nOne more reason for using \"int\" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.",
    "created_at": "2014-10-21T18:25:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204026",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
One more reason for using "int" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.



---

archive/issue_comments_204027.json:
```json
{
    "body": "<a id='comment:197'></a>\nReplying to [SimonKing](#comment%3A196):\n> One more reason for using \"int\" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.\n\nThat's not one more reason to use `int`, it's one less reason to use `mp_limb_t`. With `mp_limb_signed_t` (which isn't declared but should be in `src/sage/libs/gmp/types.pxd`), you shouldn't have this problem.",
    "created_at": "2014-10-21T18:33:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204027",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:197'></a>
Replying to [SimonKing](#comment%3A196):
> One more reason for using "int" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.

That's not one more reason to use `int`, it's one less reason to use `mp_limb_t`. With `mp_limb_signed_t` (which isn't declared but should be in `src/sage/libs/gmp/types.pxd`), you shouldn't have this problem.



---

archive/issue_comments_204028.json:
```json
{
    "body": "<a id='comment:8'></a>\nBut with a better specification of the `biseq` struct (see [comment:171]) I might give a better recommendation about which types to use.",
    "created_at": "2014-10-21T18:39:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204028",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
But with a better specification of the `biseq` struct (see [comment:171]) I might give a better recommendation about which types to use.



---

archive/issue_comments_204029.json:
```json
{
    "body": "<a id='comment:199'></a>\nReplying to [jdemeyer](#comment%3A197):\n> Replying to [SimonKing](#comment%3A196):\n> > One more reason for using \"int\" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.\n\n> That's not one more reason to use `int`, it's one less reason to use `mp_limb_t`. With `mp_limb_signed_t` (which isn't declared but should be in `src/sage/libs/gmp/types.pxd`), you shouldn't have this problem.\n\nThere may be a problem with either `int` or `mp_limb_signed_t`: If the bound for the integer sequence is very large, then a single item would fill a whole `mp_limb_t`. However, this would not fit into a *signed* int/limb.\n\nSo, at the moment, it seems to me that `ctypedef mp_limb_t biseq_item_t` is preferred. Since the `__repr__` method is not time-critical, I suggest to do the transformation from `mp_limb_t` to a nicely printed type there. I would accept that `__getitem__` returns something that is not so nicely printed.",
    "created_at": "2014-10-21T19:39:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204029",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:199'></a>
Replying to [jdemeyer](#comment%3A197):
> Replying to [SimonKing](#comment%3A196):
> > One more reason for using "int" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.

> That's not one more reason to use `int`, it's one less reason to use `mp_limb_t`. With `mp_limb_signed_t` (which isn't declared but should be in `src/sage/libs/gmp/types.pxd`), you shouldn't have this problem.

There may be a problem with either `int` or `mp_limb_signed_t`: If the bound for the integer sequence is very large, then a single item would fill a whole `mp_limb_t`. However, this would not fit into a *signed* int/limb.

So, at the moment, it seems to me that `ctypedef mp_limb_t biseq_item_t` is preferred. Since the `__repr__` method is not time-critical, I suggest to do the transformation from `mp_limb_t` to a nicely printed type there. I would accept that `__getitem__` returns something that is not so nicely printed.



---

archive/issue_comments_204030.json:
```json
{
    "body": "**Changing commit** from \"[1f5a53e7b23e406c553d789f83604cd4a7f90655](https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655)\" to \"[ef69d1e6eb30a9551bb45d1e91f6180454d78b86](https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86)\".",
    "created_at": "2014-10-21T21:46:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204030",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1f5a53e7b23e406c553d789f83604cd4a7f90655](https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655)" to "[ef69d1e6eb30a9551bb45d1e91f6180454d78b86](https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86)".



---

archive/issue_comments_204031.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86\">ef69d1e</a></td><td><code>Create sage.data_structures, move biseq into it, and amend types in biseq</code></td></tr></table>\n",
    "created_at": "2014-10-21T21:46:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204031",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86">ef69d1e</a></td><td><code>Create sage.data_structures, move biseq into it, and amend types in biseq</code></td></tr></table>




---

archive/issue_comments_204032.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5\">83be138</a></td><td><code>Reword documentation of biseq_s</code></td></tr></table>\n",
    "created_at": "2014-10-21T21:51:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204032",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5">83be138</a></td><td><code>Reword documentation of biseq_s</code></td></tr></table>




---

archive/issue_comments_204033.json:
```json
{
    "body": "**Changing commit** from \"[ef69d1e6eb30a9551bb45d1e91f6180454d78b86](https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86)\" to \"[83be138062f619a237e86650807c44b38eec94e5](https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5)\".",
    "created_at": "2014-10-21T21:51:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204033",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ef69d1e6eb30a9551bb45d1e91f6180454d78b86](https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86)" to "[83be138062f619a237e86650807c44b38eec94e5](https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5)".



---

archive/issue_events_143609.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-21T22:17:21Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143609"
}
```



---

archive/issue_events_143610.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-21T22:17:21Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143610"
}
```



---

archive/issue_comments_204034.json:
```json
{
    "body": "<a id='comment:2'></a>\nI hope my preceding comments do address your concerns, Jeroen. One more thing: Bitset has `cdef struct bitset_s` and `ctypedef bitset_s bitset_t[1]`. To be consistent with it, I changed `biseq` into `biseq_s`, so that I now have `cdef struct biseq_s` and `ctypedef biseq_s biseq_t[1]`.",
    "created_at": "2014-10-21T22:17:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204034",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
I hope my preceding comments do address your concerns, Jeroen. One more thing: Bitset has `cdef struct bitset_s` and `ctypedef bitset_s bitset_t[1]`. To be consistent with it, I changed `biseq` into `biseq_s`, so that I now have `cdef struct biseq_s` and `ctypedef biseq_s biseq_t[1]`.



---

archive/issue_comments_204035.json:
```json
{
    "body": "<a id='comment:3'></a>\nIn the \"documentation\" of `biseq_s`, this sentence is still way too vague to be useful: `Use bitsets to store the data, which in turn is based on GMP integers`. Like: what is \"the data\" and how is it stored in the bitset?\n\nAnd it's not really true that bitset is based on GMP integers. It's just an array of limbs but we use GMP/MPIR `mpn_` functions for some manipulations.",
    "created_at": "2014-10-22T06:30:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204035",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>
In the "documentation" of `biseq_s`, this sentence is still way too vague to be useful: `Use bitsets to store the data, which in turn is based on GMP integers`. Like: what is "the data" and how is it stored in the bitset?

And it's not really true that bitset is based on GMP integers. It's just an array of limbs but we use GMP/MPIR `mpn_` functions for some manipulations.



---

archive/issue_events_143611.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-22T06:30:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143611"
}
```



---

archive/issue_events_143612.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-22T06:30:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143612"
}
```



---

archive/issue_comments_204036.json:
```json
{
    "body": "<a id='comment:5'></a>\nAre you using anything from NTL? If not, why the\n\n```\ninclude \"sage/libs/ntl/decl.pxi\"\n```",
    "created_at": "2014-10-22T06:41:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204036",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
Are you using anything from NTL? If not, why the

```
include "sage/libs/ntl/decl.pxi"
```



---

archive/issue_comments_204037.json:
```json
{
    "body": "**Changing commit** from \"[83be138062f619a237e86650807c44b38eec94e5](https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5)\" to \"[1fb819cb133e2b94bfc9222585b8762ee5efad21](https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21)\".",
    "created_at": "2014-10-22T09:37:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204037",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[83be138062f619a237e86650807c44b38eec94e5](https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5)" to "[1fb819cb133e2b94bfc9222585b8762ee5efad21](https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21)".



---

archive/issue_comments_204038.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21\">1fb819c</a></td><td><code>Remove a needless cimport, clarify documentation of biseq_s</code></td></tr></table>\n",
    "created_at": "2014-10-22T09:37:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204038",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21">1fb819c</a></td><td><code>Remove a needless cimport, clarify documentation of biseq_s</code></td></tr></table>




---

archive/issue_events_143613.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-22T09:47:47Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143613"
}
```



---

archive/issue_events_143614.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-22T09:47:47Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143614"
}
```



---

archive/issue_comments_204039.json:
```json
{
    "body": "<a id='comment:7'></a>\nThe import from ntl has indeed been useless.\n\nIs the description of `biseq_s` clear enough now?",
    "created_at": "2014-10-22T09:47:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204039",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
The import from ntl has indeed been useless.

Is the description of `biseq_s` clear enough now?



---

archive/issue_comments_204040.json:
```json
{
    "body": "<a id='comment:208'></a>\nReplying to [SimonKing](#comment%3A207):\n> Is the description of `biseq_s` clear enough now?\n\nAdd that the items in the sequence are non-negative integers and that `itembitsize` is in `[1 .. GMP_LIMB_BITS]` (assuming both these statements are true).\n\nAnd I guess that `mask_item` equals `limb_lower_bits_up(itembitsize)`, where `limb_lower_bits_up` is the function defined in `src/sage/misc/bitset.pxi`.",
    "created_at": "2014-10-22T10:45:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204040",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:208'></a>
Replying to [SimonKing](#comment%3A207):
> Is the description of `biseq_s` clear enough now?

Add that the items in the sequence are non-negative integers and that `itembitsize` is in `[1 .. GMP_LIMB_BITS]` (assuming both these statements are true).

And I guess that `mask_item` equals `limb_lower_bits_up(itembitsize)`, where `limb_lower_bits_up` is the function defined in `src/sage/misc/bitset.pxi`.



---

archive/issue_comments_204041.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827\">e166d38</a></td><td><code>Further clarification of biseq_s doc.</code></td></tr></table>\n",
    "created_at": "2014-10-22T11:28:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204041",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827">e166d38</a></td><td><code>Further clarification of biseq_s doc.</code></td></tr></table>




---

archive/issue_comments_204042.json:
```json
{
    "body": "**Changing commit** from \"[1fb819cb133e2b94bfc9222585b8762ee5efad21](https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21)\" to \"[e166d38d8be72453d42325c5f6a73592ddeb3827](https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827)\".",
    "created_at": "2014-10-22T11:28:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204042",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1fb819cb133e2b94bfc9222585b8762ee5efad21](https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21)" to "[e166d38d8be72453d42325c5f6a73592ddeb3827](https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827)".



---

archive/issue_comments_204043.json:
```json
{
    "body": "<a id='comment:210'></a>\nReplying to [jdemeyer](#comment%3A208):\n> Replying to [SimonKing](#comment%3A207):\n> > Is the description of `biseq_s` clear enough now?\n\n> Add that the items in the sequence are non-negative integers and that `itembitsize` is in `[1 .. GMP_LIMB_BITS]` (assuming both these statements are true).\n\nDone.\n\n> And I guess that `mask_item` equals `limb_lower_bits_up(itembitsize)`, where `limb_lower_bits_up` is the function defined in `src/sage/misc/bitset.pxi`.\n\n\nIt could be that you just spotted a bug (corner case). I define it as `((<mp_limb_t>1)<<itembitsize)-1`, which is `limb_lower_bits_down`. And that's to say: If the itembitsize is mp_bits_per_limb (which should be allowed), then the mask is 0, but it should be all bits 1.\n\nTrying to construct a test to see if it really is a bug...\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827\">e166d38</a></td><td><code>Further clarification of biseq_s doc.</code></td></tr></table>\n",
    "created_at": "2014-10-22T11:38:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204043",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:210'></a>
Replying to [jdemeyer](#comment%3A208):
> Replying to [SimonKing](#comment%3A207):
> > Is the description of `biseq_s` clear enough now?

> Add that the items in the sequence are non-negative integers and that `itembitsize` is in `[1 .. GMP_LIMB_BITS]` (assuming both these statements are true).

Done.

> And I guess that `mask_item` equals `limb_lower_bits_up(itembitsize)`, where `limb_lower_bits_up` is the function defined in `src/sage/misc/bitset.pxi`.


It could be that you just spotted a bug (corner case). I define it as `((<mp_limb_t>1)<<itembitsize)-1`, which is `limb_lower_bits_down`. And that's to say: If the itembitsize is mp_bits_per_limb (which should be allowed), then the mask is 0, but it should be all bits 1.

Trying to construct a test to see if it really is a bug...

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827">e166d38</a></td><td><code>Further clarification of biseq_s doc.</code></td></tr></table>




---

archive/issue_comments_204044.json:
```json
{
    "body": "<a id='comment:1'></a>\nYes, it is a bug:\n\n```\nsage: B = BoundedIntegerSequence(2^32-1, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])\nsage: B\n<0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0>\n```\nThank you for spotting it!",
    "created_at": "2014-10-22T11:40:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204044",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Yes, it is a bug:

```
sage: B = BoundedIntegerSequence(2^32-1, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])
sage: B
<0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0>
```
Thank you for spotting it!



---

archive/issue_comments_204045.json:
```json
{
    "body": "<a id='comment:2'></a>\nHang on, I'm working on a reviewer patch.",
    "created_at": "2014-10-22T11:43:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204045",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>
Hang on, I'm working on a reviewer patch.



---

archive/issue_comments_204046.json:
```json
{
    "body": "<a id='comment:3'></a>\nQuestion: what is the reason that you allow a length of `0`, requiring lots of special cases in the code?\nI.e. why not replace\n\n```\n    if S.length:\n        if R.length:\n            bitset_realloc(R.data, S.data.size)\n        else:\n            bitset_init(R.data, S.data.size)\n        mpn_copyi(R.data.bits, S.data.bits, S.data.limbs)\n    elif R.length:\n        bitset_free(R.data)\n```\nby\n\n```\n    bitset_realloc(R.data, S.data.size)\n    mpn_copyi(R.data.bits, S.data.bits, S.data.limbs)\n```",
    "created_at": "2014-10-22T11:45:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204046",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>
Question: what is the reason that you allow a length of `0`, requiring lots of special cases in the code?
I.e. why not replace

```
    if S.length:
        if R.length:
            bitset_realloc(R.data, S.data.size)
        else:
            bitset_init(R.data, S.data.size)
        mpn_copyi(R.data.bits, S.data.bits, S.data.limbs)
    elif R.length:
        bitset_free(R.data)
```
by

```
    bitset_realloc(R.data, S.data.size)
    mpn_copyi(R.data.bits, S.data.bits, S.data.limbs)
```



---

archive/issue_comments_204047.json:
```json
{
    "body": "<a id='comment:4'></a>\nI see, bitset doesn't allow a length of 0. Perhaps this (artificial?) limitation on bitsets should be removed first...",
    "created_at": "2014-10-22T11:49:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204047",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
I see, bitset doesn't allow a length of 0. Perhaps this (artificial?) limitation on bitsets should be removed first...



---

archive/issue_comments_204048.json:
```json
{
    "body": "**Changing commit** from \"[e166d38d8be72453d42325c5f6a73592ddeb3827](https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827)\" to \"[3d293b96fa5a584684efbaae8fe667b885618797](https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797)\".",
    "created_at": "2014-10-22T11:50:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204048",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[e166d38d8be72453d42325c5f6a73592ddeb3827](https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827)" to "[3d293b96fa5a584684efbaae8fe667b885618797](https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797)".



---

archive/issue_comments_204049.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797\">3d293b9</a></td><td><code>Fixing a corner case</code></td></tr></table>\n",
    "created_at": "2014-10-22T11:50:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204049",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797">3d293b9</a></td><td><code>Fixing a corner case</code></td></tr></table>




---

archive/issue_comments_204050.json:
```json
{
    "body": "<a id='comment:216'></a>\nReplying to [jdemeyer](#comment%3A212):\n> Hang on, I'm working on a reviewer patch.\n\n\nSorry, I pushed already.",
    "created_at": "2014-10-22T11:50:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204050",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:216'></a>
Replying to [jdemeyer](#comment%3A212):
> Hang on, I'm working on a reviewer patch.


Sorry, I pushed already.



---

archive/issue_comments_204051.json:
```json
{
    "body": "<a id='comment:7'></a>\n...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.",
    "created_at": "2014-10-22T11:51:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204051",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>
...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.



---

archive/issue_comments_204052.json:
```json
{
    "body": "<a id='comment:218'></a>\nReplying to [jdemeyer](#comment%3A214):\n> I see, bitset doesn't allow a length of 0.\n\n\nExactly. I do need bounded integer sequences of length zero, but then I can not initialise the corresponding bitset (since it is required to have positive length). Therefore the special cases.",
    "created_at": "2014-10-22T11:52:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204052",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:218'></a>
Replying to [jdemeyer](#comment%3A214):
> I see, bitset doesn't allow a length of 0.


Exactly. I do need bounded integer sequences of length zero, but then I can not initialise the corresponding bitset (since it is required to have positive length). Therefore the special cases.



---

archive/issue_comments_204053.json:
```json
{
    "body": "<a id='comment:219'></a>\nReplying to [SimonKing](#comment%3A216):\n> Sorry, I pushed already.\n\nNo problem, it's just a small fix. Can you leave the branch alone for a while now?",
    "created_at": "2014-10-22T11:52:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204053",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:219'></a>
Replying to [SimonKing](#comment%3A216):
> Sorry, I pushed already.

No problem, it's just a small fix. Can you leave the branch alone for a while now?



---

archive/issue_events_143615.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-22T11:52:32Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143615"
}
```



---

archive/issue_events_143616.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-22T11:52:32Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143616"
}
```



---

archive/issue_comments_204054.json:
```json
{
    "body": "<a id='comment:220'></a>\nReplying to [jdemeyer](#comment%3A217):\n> ...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.\n\n\nI am not sure if I want this, since in some cases (at least in my applications) I ask `self.data.size` for the bitlength of the sequence, and thus I would need other special cases there.",
    "created_at": "2014-10-22T11:53:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204054",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:220'></a>
Replying to [jdemeyer](#comment%3A217):
> ...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.


I am not sure if I want this, since in some cases (at least in my applications) I ask `self.data.size` for the bitlength of the sequence, and thus I would need other special cases there.



---

archive/issue_comments_204055.json:
```json
{
    "body": "<a id='comment:1'></a>\nOTOH, I just see that in theses cases (e.g., concatenation of biseq) I already have special cases for length 0. So, it would not be a loss to re-organise the special casing...",
    "created_at": "2014-10-22T11:57:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204055",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
OTOH, I just see that in theses cases (e.g., concatenation of biseq) I already have special cases for length 0. So, it would not be a loss to re-organise the special casing...



---

archive/issue_comments_204056.json:
```json
{
    "body": "<a id='comment:222'></a>\nReplying to [SimonKing](#comment%3A220):\n> Replying to [jdemeyer](#comment%3A217):\n> > ...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.\n\n> \n> I am not sure if I want this, since in some cases (at least in my applications) I ask `self.data.size` for the bitlength of the sequence, and thus I would need other special cases there.\n\nI would prefer not to assume that `data.size == length * itembitsize`. For example, it might turn out to be more efficient to store some extra bits (1 extra limb for example).",
    "created_at": "2014-10-22T12:07:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204056",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:222'></a>
Replying to [SimonKing](#comment%3A220):
> Replying to [jdemeyer](#comment%3A217):
> > ...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.

> 
> I am not sure if I want this, since in some cases (at least in my applications) I ask `self.data.size` for the bitlength of the sequence, and thus I would need other special cases there.

I would prefer not to assume that `data.size == length * itembitsize`. For example, it might turn out to be more efficient to store some extra bits (1 extra limb for example).



---

archive/issue_comments_204057.json:
```json
{
    "body": "<a id='comment:3'></a>\nI will rename `list_to_biseq` -> `biseq_init_list` if you don't mind.",
    "created_at": "2014-10-22T12:10:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204057",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>
I will rename `list_to_biseq` -> `biseq_init_list` if you don't mind.



---

archive/issue_comments_204058.json:
```json
{
    "body": "<a id='comment:4'></a>\nI would also prefer to remove `biseq_copy` since it's a dangerous function: it assumes that the `biseq` has been allocated but it throws away the current contents.\n\nBetter to split this operation in two: changing `biseq_copy` to `biseq_init_copy` assuming it was not allocated. If you really want something like `biseq_copy`, just use `biseq_dealloc` and `biseq_init_copy`.",
    "created_at": "2014-10-22T12:13:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204058",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
I would also prefer to remove `biseq_copy` since it's a dangerous function: it assumes that the `biseq` has been allocated but it throws away the current contents.

Better to split this operation in two: changing `biseq_copy` to `biseq_init_copy` assuming it was not allocated. If you really want something like `biseq_copy`, just use `biseq_dealloc` and `biseq_init_copy`.



---

archive/issue_comments_204059.json:
```json
{
    "body": "**Dependencies:** #17195",
    "created_at": "2014-10-22T12:21:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204059",
    "user": "https://github.com/jdemeyer"
}
```

**Dependencies:** #17195



---

archive/issue_comments_204060.json:
```json
{
    "body": "<a id='comment:6'></a>\nWhy should there be a dependency on cython upgrade?",
    "created_at": "2014-10-22T12:34:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204060",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
Why should there be a dependency on cython upgrade?



---

archive/issue_comments_204061.json:
```json
{
    "body": "**Changing dependencies** from \"#17195\" to \"#17195, #17196\".",
    "created_at": "2014-10-22T13:14:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204061",
    "user": "https://github.com/jdemeyer"
}
```

**Changing dependencies** from "#17195" to "#17195, #17196".



---

archive/issue_comments_204062.json:
```json
{
    "body": "<a id='comment:228'></a>\nReplying to [SimonKing](#comment%3A226):\n> Why should there be a dependency on cython upgrade?\n\nOnly the newest Cython has declarations for the `PySlice` API, so you can use `PySlice_GetIndicesEx()` easily.",
    "created_at": "2014-10-22T13:16:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204062",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:228'></a>
Replying to [SimonKing](#comment%3A226):
> Why should there be a dependency on cython upgrade?

Only the newest Cython has declarations for the `PySlice` API, so you can use `PySlice_GetIndicesEx()` easily.



---

archive/issue_comments_204063.json:
```json
{
    "body": "**Changing dependencies** from \"#17195, #17196\" to \"#17195\".",
    "created_at": "2014-10-22T13:18:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204063",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing dependencies** from "#17195, #17196" to "#17195".



---

archive/issue_comments_204064.json:
```json
{
    "body": "<a id='comment:9'></a>\nAs much as I know, I don't use the bitset functions for which there is a requirement of equality of size. Hence, I don't think #17196 is a dependency.",
    "created_at": "2014-10-22T13:18:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204064",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
As much as I know, I don't use the bitset functions for which there is a requirement of equality of size. Hence, I don't think #17196 is a dependency.



---

archive/issue_comments_204065.json:
```json
{
    "body": "<a id='comment:230'></a>\nReplying to [SimonKing](#comment%3A229):\n> As much as I know, I don't use the bitset functions for which there is a requirement of equality of size.\n\nYes, you don't use them but you *should* use those functions. It will simplify a lot of things.",
    "created_at": "2014-10-22T13:21:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204065",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:230'></a>
Replying to [SimonKing](#comment%3A229):
> As much as I know, I don't use the bitset functions for which there is a requirement of equality of size.

Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.



---

archive/issue_comments_204066.json:
```json
{
    "body": "<a id='comment:231'></a>\nReplying to [jdemeyer](#comment%3A230):\n> Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.\n\nFor example, `biseq_concat` is broken in the case where `(S1.data.size)%mp_bits_per_limb + (S2.data.size)%mp_bits_per_limb > mp_bits_per_limb`.",
    "created_at": "2014-10-22T13:59:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204066",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:231'></a>
Replying to [jdemeyer](#comment%3A230):
> Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.

For example, `biseq_concat` is broken in the case where `(S1.data.size)%mp_bits_per_limb + (S2.data.size)%mp_bits_per_limb > mp_bits_per_limb`.



---

archive/issue_comments_204067.json:
```json
{
    "body": "<a id='comment:232'></a>\nReplying to [jdemeyer](#comment%3A231):\n> Replying to [jdemeyer](#comment%3A230):\n> > Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.\n\n> For example, `biseq_concat` is broken in the case where `(S1.data.size)%mp_bits_per_limb + (S2.data.size)%mp_bits_per_limb > mp_bits_per_limb`.\n\nReally? OK, I'll try to find an example that exposes the problem.",
    "created_at": "2014-10-22T14:02:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204067",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:232'></a>
Replying to [jdemeyer](#comment%3A231):
> Replying to [jdemeyer](#comment%3A230):
> > Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.

> For example, `biseq_concat` is broken in the case where `(S1.data.size)%mp_bits_per_limb + (S2.data.size)%mp_bits_per_limb > mp_bits_per_limb`.

Really? OK, I'll try to find an example that exposes the problem.



---

archive/issue_comments_204068.json:
```json
{
    "body": "<a id='comment:3'></a>\n\n```\nsage: B = BoundedIntegerSequence(2^30-1, [1])\nsage: B\n<1>\nsage: B+B\n<1, 1>\n```\nWhere's the problem?",
    "created_at": "2014-10-22T14:04:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204068",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>

```
sage: B = BoundedIntegerSequence(2^30-1, [1])
sage: B
<1>
sage: B+B
<1, 1>
```
Where's the problem?



---

archive/issue_comments_204069.json:
```json
{
    "body": "<a id='comment:4'></a>\nCould you try again with a larger value of `1`?",
    "created_at": "2014-10-22T14:06:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204069",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
Could you try again with a larger value of `1`?



---

archive/issue_comments_204070.json:
```json
{
    "body": "<a id='comment:5'></a>\nHere it is:\n\n```\nsage: B = BoundedIntegerSequence(2^30-1, [2^30-1])\nsage: B\n<1073741823>\nsage: B+B\n<1073741823, 3>\n```\nOK, this requires a fix.",
    "created_at": "2014-10-22T14:08:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204070",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
Here it is:

```
sage: B = BoundedIntegerSequence(2^30-1, [2^30-1])
sage: B
<1073741823>
sage: B+B
<1073741823, 3>
```
OK, this requires a fix.



---

archive/issue_comments_204071.json:
```json
{
    "body": "<a id='comment:6'></a>\nDo I understand correctly: At #17196, shift and comparison operations should be introduced that behave well wrt bitsizes, and then these operations should replace the mpn_... that I am using here.",
    "created_at": "2014-10-22T14:13:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204071",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
Do I understand correctly: At #17196, shift and comparison operations should be introduced that behave well wrt bitsizes, and then these operations should replace the mpn_... that I am using here.



---

archive/issue_comments_204072.json:
```json
{
    "body": "<a id='comment:237'></a>\nReplying to [SimonKing](#comment%3A236):\n> Do I understand correctly: At #17196, shift and comparison operations should be introduced that behave well wrt bitsizes, and then these operations should replace the mpn_... that I am using here.\n\nYes.",
    "created_at": "2014-10-22T14:14:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204072",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:237'></a>
Replying to [SimonKing](#comment%3A236):
> Do I understand correctly: At #17196, shift and comparison operations should be introduced that behave well wrt bitsizes, and then these operations should replace the mpn_... that I am using here.

Yes.



---

archive/issue_comments_204073.json:
```json
{
    "body": "**Changing dependencies** from \"#17195\" to \"#17195, #17196\".",
    "created_at": "2014-10-22T14:14:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204073",
    "user": "https://github.com/jdemeyer"
}
```

**Changing dependencies** from "#17195" to "#17195, #17196".



---

archive/issue_comments_204074.json:
```json
{
    "body": "**Changing branch** from \"[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)\" to \"[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)\".",
    "created_at": "2014-10-22T15:07:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204074",
    "user": "https://github.com/jdemeyer"
}
```

**Changing branch** from "[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)" to "[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)".



---

archive/issue_comments_204075.json:
```json
{
    "body": "<a id='comment:9'></a>\nIn `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be a feature?\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8c69daf5a4cdbb08f39ca577c9c02bfe483969b9\">8c69daf</a></td><td><code>Upgrade Cython to 0.21.1</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8\">88e5eca</a></td><td><code>Merge branch 'ticket/17195' into ticket/15820</code></td></tr></table>\n",
    "created_at": "2014-10-22T16:07:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204075",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:9'></a>
In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be a feature?

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8c69daf5a4cdbb08f39ca577c9c02bfe483969b9">8c69daf</a></td><td><code>Upgrade Cython to 0.21.1</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8">88e5eca</a></td><td><code>Merge branch 'ticket/17195' into ticket/15820</code></td></tr></table>




---

archive/issue_comments_204076.json:
```json
{
    "body": "**Changing commit** from \"[3d293b96fa5a584684efbaae8fe667b885618797](https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797)\" to \"[88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8](https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8)\".",
    "created_at": "2014-10-22T16:07:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204076",
    "user": "https://github.com/jdemeyer"
}
```

**Changing commit** from "[3d293b96fa5a584684efbaae8fe667b885618797](https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797)" to "[88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8](https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8)".



---

archive/issue_comments_204077.json:
```json
{
    "body": "<a id='comment:0'></a>\nLast commit is totally work in progress.",
    "created_at": "2014-10-22T16:09:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204077",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:0'></a>
Last commit is totally work in progress.



---

archive/issue_comments_204078.json:
```json
{
    "body": "**Changing commit** from \"[88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8](https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8)\" to \"[ab2f0c2bf3b68e4e979650f5554d529e5b7ea625](https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625)\".",
    "created_at": "2014-10-22T16:10:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204078",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8](https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8)" to "[ab2f0c2bf3b68e4e979650f5554d529e5b7ea625](https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625)".



---

archive/issue_comments_204079.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625\">ab2f0c2</a></td><td><code>Various reviewer fixes</code></td></tr></table>\n",
    "created_at": "2014-10-22T16:10:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204079",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625">ab2f0c2</a></td><td><code>Various reviewer fixes</code></td></tr></table>




---

archive/issue_comments_204080.json:
```json
{
    "body": "<a id='comment:2'></a>\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625\">ab2f0c2</a></td><td><code>Various reviewer fixes</code></td></tr></table>\n",
    "created_at": "2014-10-22T16:10:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204080",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625">ab2f0c2</a></td><td><code>Various reviewer fixes</code></td></tr></table>




---

archive/issue_comments_204081.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/83f8a5648815d7c25eb0c9f9b4bdaf04dd90335e\">83f8a56</a></td><td><code>Relax assumptions for bitset functions</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3ae75a1f8fcfee0f78faf9bb4bb006149b535c45\">3ae75a1</a></td><td><code>Move bitset to sage.data_structures</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7a955118f13e91ca6829b9da06172873f13f5b0b\">7a95511</a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a\">815a40d</a></td><td><code>Various reviewer fixes</code></td></tr></table>\n",
    "created_at": "2014-10-23T07:23:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204081",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/83f8a5648815d7c25eb0c9f9b4bdaf04dd90335e">83f8a56</a></td><td><code>Relax assumptions for bitset functions</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3ae75a1f8fcfee0f78faf9bb4bb006149b535c45">3ae75a1</a></td><td><code>Move bitset to sage.data_structures</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7a955118f13e91ca6829b9da06172873f13f5b0b">7a95511</a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a">815a40d</a></td><td><code>Various reviewer fixes</code></td></tr></table>




---

archive/issue_comments_204082.json:
```json
{
    "body": "**Changing commit** from \"[ab2f0c2bf3b68e4e979650f5554d529e5b7ea625](https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625)\" to \"[815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a](https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a)\".",
    "created_at": "2014-10-23T07:23:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204082",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ab2f0c2bf3b68e4e979650f5554d529e5b7ea625](https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625)" to "[815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a](https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a)".



---

archive/issue_comments_204083.json:
```json
{
    "body": "<a id='comment:4'></a>\nWhat exactly does cython.overflowcheck do? Check whether the given arguments fit into the prescribed data types without truncation?",
    "created_at": "2014-10-23T08:01:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204083",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
What exactly does cython.overflowcheck do? Check whether the given arguments fit into the prescribed data types without truncation?



---

archive/issue_comments_204084.json:
```json
{
    "body": "<a id='comment:245'></a>\nReplying to [SimonKing](#comment%3A244):\n> What exactly does cython.overflowcheck do?\n\nSee [http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html): for this application, it checks that the multiplication `totalbitsize = l * itemsize` doesn't overflow.",
    "created_at": "2014-10-23T08:10:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204084",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:245'></a>
Replying to [SimonKing](#comment%3A244):
> What exactly does cython.overflowcheck do?

See [http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html): for this application, it checks that the multiplication `totalbitsize = l * itemsize` doesn't overflow.



---

archive/issue_comments_204085.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d\">8d16a61</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-10-23T08:18:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204085",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d">8d16a61</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_204086.json:
```json
{
    "body": "**Changing commit** from \"[815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a](https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a)\" to \"[8d16a61d2874a38e10233cdf434db3854bd5ee0d](https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d)\".",
    "created_at": "2014-10-23T08:18:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204086",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a](https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a)" to "[8d16a61d2874a38e10233cdf434db3854bd5ee0d](https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d)".



---

archive/issue_comments_204087.json:
```json
{
    "body": "**Changing commit** from \"[8d16a61d2874a38e10233cdf434db3854bd5ee0d](https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d)\" to \"[8d59d141b7090fb6e5f6529b968e224ec0e5f73b](https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b)\".",
    "created_at": "2014-10-23T08:51:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204087",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[8d16a61d2874a38e10233cdf434db3854bd5ee0d](https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d)" to "[8d59d141b7090fb6e5f6529b968e224ec0e5f73b](https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b)".



---

archive/issue_comments_204088.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b\">8d59d14</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-10-23T08:51:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204088",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b">8d59d14</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_204089.json:
```json
{
    "body": "**Changing author** from \"Simon King\" to \"Simon King, Jeroen Demeyer\".",
    "created_at": "2014-10-23T09:24:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204089",
    "user": "https://github.com/jdemeyer"
}
```

**Changing author** from "Simon King" to "Simon King, Jeroen Demeyer".



---

archive/issue_comments_204090.json:
```json
{
    "body": "<a id='comment:249'></a>\nReplying to [jdemeyer](#comment%3A245):\n> Replying to [SimonKing](#comment%3A244):\n> > What exactly does cython.overflowcheck do?\n\n> See [http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html): for this application, it checks that the multiplication `totalbitsize = l * itemsize` doesn't overflow.\n\nAha! So, it does not just check an overflow of the arguments, but it checks overflows happening in the innards of the function. Cool!",
    "created_at": "2014-10-23T10:01:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204090",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:249'></a>
Replying to [jdemeyer](#comment%3A245):
> Replying to [SimonKing](#comment%3A244):
> > What exactly does cython.overflowcheck do?

> See [http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html): for this application, it checks that the multiplication `totalbitsize = l * itemsize` doesn't overflow.

Aha! So, it does not just check an overflow of the arguments, but it checks overflows happening in the innards of the function. Cool!



---

archive/issue_comments_204091.json:
```json
{
    "body": "**Changing commit** from \"[8d59d141b7090fb6e5f6529b968e224ec0e5f73b](https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b)\" to \"[d22c1ca23727402e376c7f772c2f51b8ed6af1f1](https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1)\".",
    "created_at": "2014-10-23T10:10:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204091",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[8d59d141b7090fb6e5f6529b968e224ec0e5f73b](https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b)" to "[d22c1ca23727402e376c7f772c2f51b8ed6af1f1](https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1)".



---

archive/issue_comments_204092.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d\">23762a3</a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610\">4aafd2f</a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1\">d22c1ca</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-10-23T10:10:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204092",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d">23762a3</a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610">4aafd2f</a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1">d22c1ca</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_204093.json:
```json
{
    "body": "<a id='comment:251'></a>\nReplying to [SimonKing](#comment%3A249):\n> So, it does not just check an overflow of the arguments\n\nIn fact, it does not check overflow of the arguments.\n\nOverflow checking of the arguments should happen in *calling* the function, not in the function itself.\n\nAlso note that Cython always does overflow checking when converting from Python types to C types, but not by default between C types.",
    "created_at": "2014-10-23T10:15:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204093",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:251'></a>
Replying to [SimonKing](#comment%3A249):
> So, it does not just check an overflow of the arguments

In fact, it does not check overflow of the arguments.

Overflow checking of the arguments should happen in *calling* the function, not in the function itself.

Also note that Cython always does overflow checking when converting from Python types to C types, but not by default between C types.



---

archive/issue_comments_204094.json:
```json
{
    "body": "<a id='comment:2'></a>\nIs sagemath.org down? I can not build your branch, since downloading the new cython package fails.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d\">23762a3</a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610\">4aafd2f</a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1\">d22c1ca</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d\">23762a3</a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610\">4aafd2f</a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1\">d22c1ca</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-10-23T10:19:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204094",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Is sagemath.org down? I can not build your branch, since downloading the new cython package fails.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d">23762a3</a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610">4aafd2f</a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1">d22c1ca</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d">23762a3</a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610">4aafd2f</a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1">d22c1ca</a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_204095.json:
```json
{
    "body": "<a id='comment:253'></a>\nReplying to [SimonKing](#comment%3A252):\n> Is sagemath.org down? I can not build your branch, since downloading the new cython package fails.\n\nThe new Cython package isn't yet merged, so you have to manually follow the instructions at #17195 (don't forget the renaming!)",
    "created_at": "2014-10-23T10:22:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204095",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:253'></a>
Replying to [SimonKing](#comment%3A252):
> Is sagemath.org down? I can not build your branch, since downloading the new cython package fails.

The new Cython package isn't yet merged, so you have to manually follow the instructions at #17195 (don't forget the renaming!)



---

archive/issue_comments_204096.json:
```json
{
    "body": "<a id='comment:4'></a>\nMy intention for this ticket is to implement an additional function `biseq_setitem()` to set one item and then implement the `biseq` functions using either `biseq_getitem()/biseq_setitem()` or `bitset` functions. In cases where this cannot be done, add the required primitives and use those. The end result will hopefully be a lot less code without loss of efficiency.",
    "created_at": "2014-10-23T10:27:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204096",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
My intention for this ticket is to implement an additional function `biseq_setitem()` to set one item and then implement the `biseq` functions using either `biseq_getitem()/biseq_setitem()` or `bitset` functions. In cases where this cannot be done, add the required primitives and use those. The end result will hopefully be a lot less code without loss of efficiency.



---

archive/issue_comments_204097.json:
```json
{
    "body": "<a id='comment:5'></a>\nIn case that you missed it, I am copying this question I asked before:\n\nIn `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?",
    "created_at": "2014-10-23T10:28:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204097",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
In case that you missed it, I am copying this question I asked before:

In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?



---

archive/issue_comments_204098.json:
```json
{
    "body": "<a id='comment:256'></a>\nReplying to [jdemeyer](#comment%3A254):\n> My intention for this ticket is to implement an additional function `biseq_setitem()` to set one item and then implement the `biseq` functions using either `biseq_getitem()/biseq_setitem()` or `bitset` functions. In cases where this cannot be done, add the required primitives and use those. The end result will hopefully be a lot less code without loss of efficiency.\n\n\nAre you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?",
    "created_at": "2014-10-23T10:31:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204098",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:256'></a>
Replying to [jdemeyer](#comment%3A254):
> My intention for this ticket is to implement an additional function `biseq_setitem()` to set one item and then implement the `biseq` functions using either `biseq_getitem()/biseq_setitem()` or `bitset` functions. In cases where this cannot be done, add the required primitives and use those. The end result will hopefully be a lot less code without loss of efficiency.


Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?



---

archive/issue_comments_204099.json:
```json
{
    "body": "<a id='comment:257'></a>\nReplying to [SimonKing](#comment%3A256):\n> Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?\n\n\nI don't quite understand what you refer to. Which function do you think would become slower?",
    "created_at": "2014-10-23T10:35:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204099",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:257'></a>
Replying to [SimonKing](#comment%3A256):
> Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?


I don't quite understand what you refer to. Which function do you think would become slower?



---

archive/issue_comments_204100.json:
```json
{
    "body": "<a id='comment:258'></a>\nReplying to [jdemeyer](#comment%3A255):\n> In case that you missed it, I am copying this question I asked before:\n> \n> In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?\n\n\nWhat do you mean by \"randomly truncated\"? The given integers are replaced by their remainder modulo the \"mangled\" bound (i.e., the smallest power of two that is greater or equal the given bound). It is documented, and it isn't random.",
    "created_at": "2014-10-23T10:38:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204100",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:258'></a>
Replying to [jdemeyer](#comment%3A255):
> In case that you missed it, I am copying this question I asked before:
> 
> In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?


What do you mean by "randomly truncated"? The given integers are replaced by their remainder modulo the "mangled" bound (i.e., the smallest power of two that is greater or equal the given bound). It is documented, and it isn't random.



---

archive/issue_comments_204101.json:
```json
{
    "body": "<a id='comment:259'></a>\nReplying to [SimonKing](#comment%3A258):\n> Replying to [jdemeyer](#comment%3A255):\n> > In case that you missed it, I am copying this question I asked before:\n> > \n> > In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?\n\n> \n> What do you mean by \"randomly truncated\"? The given integers are replaced by their remainder modulo the \"mangled\" bound (i.e., the smallest power of two that is greater or equal the given bound). It is documented, and it isn't random.\n\nOK, I didn't literally mean \"random\", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?",
    "created_at": "2014-10-23T10:42:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204101",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:259'></a>
Replying to [SimonKing](#comment%3A258):
> Replying to [jdemeyer](#comment%3A255):
> > In case that you missed it, I am copying this question I asked before:
> > 
> > In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?

> 
> What do you mean by "randomly truncated"? The given integers are replaced by their remainder modulo the "mangled" bound (i.e., the smallest power of two that is greater or equal the given bound). It is documented, and it isn't random.

OK, I didn't literally mean "random", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?



---

archive/issue_comments_204102.json:
```json
{
    "body": "<a id='comment:260'></a>\nReplying to [jdemeyer](#comment%3A257):\n> Replying to [SimonKing](#comment%3A256):\n> > Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?\n\n> \n> I don't quite understand what you refer to. Which function do you think would become slower?\n\n\n`BoundedIntegerSequence.__iter__` and `biseq_to_list` would probably become\nslower. Currently, one limb is shifted with mpn_rshift, and then all items in\nthis limb are extracted by `>>` in this single limb, before mpn_rshifting the\nnext limb. If I understand correctly, you are planning to replace this by\n`biseq_getitem`, which means that you mpn_rshift a limb and extract the first\nitem of it, then mpn_rshift the same limb again for the second item.\n\nI suppose repeated use of mpn_rshift is slower than a single mpn_rshift\nfollowed by repeated single-limb-`>>`.",
    "created_at": "2014-10-23T10:43:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204102",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:260'></a>
Replying to [jdemeyer](#comment%3A257):
> Replying to [SimonKing](#comment%3A256):
> > Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?

> 
> I don't quite understand what you refer to. Which function do you think would become slower?


`BoundedIntegerSequence.__iter__` and `biseq_to_list` would probably become
slower. Currently, one limb is shifted with mpn_rshift, and then all items in
this limb are extracted by `>>` in this single limb, before mpn_rshifting the
next limb. If I understand correctly, you are planning to replace this by
`biseq_getitem`, which means that you mpn_rshift a limb and extract the first
item of it, then mpn_rshift the same limb again for the second item.

I suppose repeated use of mpn_rshift is slower than a single mpn_rshift
followed by repeated single-limb-`>>`.



---

archive/issue_comments_204103.json:
```json
{
    "body": "<a id='comment:261'></a>\nReplying to [jdemeyer](#comment%3A259):\n> OK, I didn't literally mean \"random\", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?\n\n\nYou mean one should just raise an error? OK, that's another possibility.",
    "created_at": "2014-10-23T10:43:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204103",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:261'></a>
Replying to [jdemeyer](#comment%3A259):
> OK, I didn't literally mean "random", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?


You mean one should just raise an error? OK, that's another possibility.



---

archive/issue_comments_204104.json:
```json
{
    "body": "<a id='comment:2'></a>\nWhy did you introduce\n\n```\nassert S1.itembitsize == S2.itembitsize\n```\n?\n\nI think that generally it is not the job of boilerplate functions to do bound checking. If you want to do bound checking, then do so on the level of `BoundedIntegerSequence`, but not on the level of `biseq_t`.",
    "created_at": "2014-10-23T11:44:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204104",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Why did you introduce

```
assert S1.itembitsize == S2.itembitsize
```
?

I think that generally it is not the job of boilerplate functions to do bound checking. If you want to do bound checking, then do so on the level of `BoundedIntegerSequence`, but not on the level of `biseq_t`.



---

archive/issue_comments_204105.json:
```json
{
    "body": "<a id='comment:3'></a>\nPerhaps we should consider to change the hash function for bitsets (see the comments for the hash of bounded integer sequences that you removed). But I suppose this should not be done on this ticket.\n\nMy summary:\n- We have different functions that assume that the given sequences have equivalent bounds. In most cases, the assumption is not checked, with exception of the one assert that you introduced. I vote for removing the assert.\n- I don't think iteration should use `biseq_getitem` to extract items one by one. Instead, the current idea (\"shift enough data so that one limb is full and extract items from this single limb\") should be preserved.\n- I like your change to `biseq_getitem`, where you avoid using `mpn_rshift` for just one/two limbs. I think the same change could be done in `biseq_slice` in the case `step!=1`, and also in iteration.\n\nOther than that, your changes seem fine to me. I suggest to do the \"replacement of one/two limb shifts\", unless you beat me to it.",
    "created_at": "2014-10-23T12:05:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204105",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Perhaps we should consider to change the hash function for bitsets (see the comments for the hash of bounded integer sequences that you removed). But I suppose this should not be done on this ticket.

My summary:
- We have different functions that assume that the given sequences have equivalent bounds. In most cases, the assumption is not checked, with exception of the one assert that you introduced. I vote for removing the assert.
- I don't think iteration should use `biseq_getitem` to extract items one by one. Instead, the current idea ("shift enough data so that one limb is full and extract items from this single limb") should be preserved.
- I like your change to `biseq_getitem`, where you avoid using `mpn_rshift` for just one/two limbs. I think the same change could be done in `biseq_slice` in the case `step!=1`, and also in iteration.

Other than that, your changes seem fine to me. I suggest to do the "replacement of one/two limb shifts", unless you beat me to it.



---

archive/issue_comments_204106.json:
```json
{
    "body": "**Reviewer:** Simon King",
    "created_at": "2014-10-23T12:06:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204106",
    "user": "https://github.com/simon-king-jena"
}
```

**Reviewer:** Simon King



---

archive/issue_comments_204107.json:
```json
{
    "body": "<a id='comment:5'></a>\nConcerning the assert: The only place in which `biseq_init_concat` is used does in fact check compatibility of bounds, and raises a `ValueError` if they are not compatible. Hence, the assert statement is redundant.",
    "created_at": "2014-10-23T12:09:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204107",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
Concerning the assert: The only place in which `biseq_init_concat` is used does in fact check compatibility of bounds, and raises a `ValueError` if they are not compatible. Hence, the assert statement is redundant.



---

archive/issue_comments_204108.json:
```json
{
    "body": "**Changing branch** from \"[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)\" to \"[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)\".",
    "created_at": "2014-10-23T12:50:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204108",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing branch** from "[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)" to "[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)".



---

archive/issue_comments_204109.json:
```json
{
    "body": "<a id='comment:7'></a>\nFrom my perspective, it is good to go...\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e\">41c40cf</a></td><td><code>Don't use mpn_rshift for shifting two limbs</code></td></tr></table>\n",
    "created_at": "2014-10-23T12:51:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204109",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
From my perspective, it is good to go...

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e">41c40cf</a></td><td><code>Don't use mpn_rshift for shifting two limbs</code></td></tr></table>




---

archive/issue_comments_204110.json:
```json
{
    "body": "**Changing commit** from \"[d22c1ca23727402e376c7f772c2f51b8ed6af1f1](https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1)\" to \"[41c40cf2c59734e7e665ba9c2350da2930c9cc8e](https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e)\".",
    "created_at": "2014-10-23T12:51:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204110",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing commit** from "[d22c1ca23727402e376c7f772c2f51b8ed6af1f1](https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1)" to "[41c40cf2c59734e7e665ba9c2350da2930c9cc8e](https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e)".



---

archive/issue_events_143617.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-23T12:51:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143617"
}
```



---

archive/issue_events_143618.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-23T12:51:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143618"
}
```



---

archive/issue_comments_204111.json:
```json
{
    "body": "<a id='comment:268'></a>\nReplying to [SimonKing](#comment%3A263):\n> - We have different functions that assume that the given sequences have equivalent bounds. In most cases, the assumption is not checked, with exception of the one assert that you introduced. I vote for removing the assert.\n \nOK then, no problem.",
    "created_at": "2014-10-23T13:11:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204111",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:268'></a>
Replying to [SimonKing](#comment%3A263):
> - We have different functions that assume that the given sequences have equivalent bounds. In most cases, the assumption is not checked, with exception of the one assert that you introduced. I vote for removing the assert.
 
OK then, no problem.



---

archive/issue_comments_204112.json:
```json
{
    "body": "<a id='comment:9'></a>\nLet's do some benchmarks:\n\n1. With the latest commit:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(2, [1]*100000)\nsage: timeit('B.list()')\n625 loops, best of 3: 965 \u00b5s per loop\nsage: timeit('list(B)')\n125 loops, best of 3: 1.73 ms per loop\nsage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)\nsage: timeit('B.list()')\n625 loops, best of 3: 1.1 ms per loop\nsage: timeit('list(B)')\n125 loops, best of 3: 1.91 ms per loop\n```\n\n2. With 88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(2, [1]*100000)\nsage: timeit('B.list()')\n125 loops, best of 3: 3 ms per loop\nsage: timeit('list(B)')\n125 loops, best of 3: 3.87 ms per loop\nsage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)\nsage: timeit('B.list()')\n125 loops, best of 3: 3.68 ms per loop\nsage: timeit('list(B)')\n125 loops, best of 3: 4.47 ms per loop\n```",
    "created_at": "2014-10-23T13:25:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204112",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:9'></a>
Let's do some benchmarks:

1. With the latest commit:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(2, [1]*100000)
sage: timeit('B.list()')
625 loops, best of 3: 965 µs per loop
sage: timeit('list(B)')
125 loops, best of 3: 1.73 ms per loop
sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)
sage: timeit('B.list()')
625 loops, best of 3: 1.1 ms per loop
sage: timeit('list(B)')
125 loops, best of 3: 1.91 ms per loop
```

2. With 88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(2, [1]*100000)
sage: timeit('B.list()')
125 loops, best of 3: 3 ms per loop
sage: timeit('list(B)')
125 loops, best of 3: 3.87 ms per loop
sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)
sage: timeit('B.list()')
125 loops, best of 3: 3.68 ms per loop
sage: timeit('list(B)')
125 loops, best of 3: 4.47 ms per loop
```



---

archive/issue_comments_204113.json:
```json
{
    "body": "<a id='comment:270'></a>\nReplying to [SimonKing](#comment%3A260):\n> `BoundedIntegerSequence.__iter__` and `biseq_to_list` would probably become\n> slower. Currently, one limb is shifted with mpn_rshift, and then all items in\n> this limb are extracted by `>>` in this single limb, before mpn_rshifting the\n> next limb. If I understand correctly, you are planning to replace this by\n> `biseq_getitem`, which means that you mpn_rshift a limb and extract the first\n> item of it, then mpn_rshift the same limb again for the second item.\n> \n> I suppose repeated use of mpn_rshift is slower than a single mpn_rshift\n> followed by repeated single-limb-`>>`.\n\nAs you can see, I implemented `biseq_getitem()` much faster than that, so I doubt there is still a slowdown for using repeated calls to `biseq_getitem()`.",
    "created_at": "2014-10-23T13:27:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204113",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:270'></a>
Replying to [SimonKing](#comment%3A260):
> `BoundedIntegerSequence.__iter__` and `biseq_to_list` would probably become
> slower. Currently, one limb is shifted with mpn_rshift, and then all items in
> this limb are extracted by `>>` in this single limb, before mpn_rshifting the
> next limb. If I understand correctly, you are planning to replace this by
> `biseq_getitem`, which means that you mpn_rshift a limb and extract the first
> item of it, then mpn_rshift the same limb again for the second item.
> 
> I suppose repeated use of mpn_rshift is slower than a single mpn_rshift
> followed by repeated single-limb-`>>`.

As you can see, I implemented `biseq_getitem()` much faster than that, so I doubt there is still a slowdown for using repeated calls to `biseq_getitem()`.



---

archive/issue_comments_204114.json:
```json
{
    "body": "<a id='comment:271'></a>\nReplying to [SimonKing](#comment%3A261):\n> Replying to [jdemeyer](#comment%3A259):\n> > OK, I didn't literally mean \"random\", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?\n\n> \n> You mean one should just raise an error? OK, that's another possibility.\n\nYes, that is what I mean.",
    "created_at": "2014-10-23T13:28:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204114",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:271'></a>
Replying to [SimonKing](#comment%3A261):
> Replying to [jdemeyer](#comment%3A259):
> > OK, I didn't literally mean "random", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?

> 
> You mean one should just raise an error? OK, that's another possibility.

Yes, that is what I mean.



---

archive/issue_comments_204115.json:
```json
{
    "body": "<a id='comment:2'></a>\nI just notice that you removed `biseq_to_list`. Why? Is there no speed penalty for using iterator instead?",
    "created_at": "2014-10-23T13:34:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204115",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
I just notice that you removed `biseq_to_list`. Why? Is there no speed penalty for using iterator instead?



---

archive/issue_comments_204116.json:
```json
{
    "body": "<a id='comment:273'></a>\nReplying to [SimonKing](#comment%3A272):\n> I just notice that you removed `biseq_to_list`.\n\nJust use `[biseq_getitem_py(self.data, i) for i in range(self.data.length)]`",
    "created_at": "2014-10-23T13:37:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204116",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:273'></a>
Replying to [SimonKing](#comment%3A272):
> I just notice that you removed `biseq_to_list`.

Just use `[biseq_getitem_py(self.data, i) for i in range(self.data.length)]`



---

archive/issue_comments_204117.json:
```json
{
    "body": "<a id='comment:4'></a>\nAlso, I think that `biseq_to_list` is something which belongs in the Python interface, not the C interface.",
    "created_at": "2014-10-23T13:37:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204117",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
Also, I think that `biseq_to_list` is something which belongs in the Python interface, not the C interface.



---

archive/issue_comments_204118.json:
```json
{
    "body": "<a id='comment:275'></a>\nI only see this comment after posting my previous comment.\n\nReplying to [jdemeyer](#comment%3A269):\n> Let's do some benchmarks:\n> \n> 1. With the latest commit:\n> \n> ```\n> sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\n> sage: B = BoundedIntegerSequence(2, [1]*100000)\n> sage: timeit('B.list()')\n> 625 loops, best of 3: 965 \u00b5s per loop\n> sage: timeit('list(B)')\n> 125 loops, best of 3: 1.73 ms per loop\n> sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)\n> sage: timeit('B.list()')\n> 625 loops, best of 3: 1.1 ms per loop\n> sage: timeit('list(B)')\n> 125 loops, best of 3: 1.91 ms per loop\n> ```\n> \n> 2. With 88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8:\n> \n> ```\n> sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\n> sage: B = BoundedIntegerSequence(2, [1]*100000)\n> sage: timeit('B.list()')\n> 125 loops, best of 3: 3 ms per loop\n> sage: timeit('list(B)')\n> 125 loops, best of 3: 3.87 ms per loop\n> sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)\n> sage: timeit('B.list()')\n> 125 loops, best of 3: 3.68 ms per loop\n> sage: timeit('list(B)')\n> 125 loops, best of 3: 4.47 ms per loop\n> ```\n\n\nOK, excellent, then I think it is ok to drop biseq_to_list.",
    "created_at": "2014-10-23T13:48:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204118",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:275'></a>
I only see this comment after posting my previous comment.

Replying to [jdemeyer](#comment%3A269):
> Let's do some benchmarks:
> 
> 1. With the latest commit:
> 
> ```
> sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
> sage: B = BoundedIntegerSequence(2, [1]*100000)
> sage: timeit('B.list()')
> 625 loops, best of 3: 965 µs per loop
> sage: timeit('list(B)')
> 125 loops, best of 3: 1.73 ms per loop
> sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)
> sage: timeit('B.list()')
> 625 loops, best of 3: 1.1 ms per loop
> sage: timeit('list(B)')
> 125 loops, best of 3: 1.91 ms per loop
> ```
> 
> 2. With 88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8:
> 
> ```
> sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
> sage: B = BoundedIntegerSequence(2, [1]*100000)
> sage: timeit('B.list()')
> 125 loops, best of 3: 3 ms per loop
> sage: timeit('list(B)')
> 125 loops, best of 3: 3.87 ms per loop
> sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)
> sage: timeit('B.list()')
> 125 loops, best of 3: 3.68 ms per loop
> sage: timeit('list(B)')
> 125 loops, best of 3: 4.47 ms per loop
> ```


OK, excellent, then I think it is ok to drop biseq_to_list.



---

archive/issue_comments_204119.json:
```json
{
    "body": "<a id='comment:6'></a>\nIf I understand correctly, the only remaining issue is whether we silently truncate the input, or raise an error if the given items are too large. I have no preference here, so, you may make it a reviewer patch.",
    "created_at": "2014-10-23T13:52:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204119",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
If I understand correctly, the only remaining issue is whether we silently truncate the input, or raise an error if the given items are too large. I have no preference here, so, you may make it a reviewer patch.



---

archive/issue_comments_204120.json:
```json
{
    "body": "<a id='comment:7'></a>\nSigh. After merging this into #16453, I get several segmentation faults.",
    "created_at": "2014-10-23T13:58:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204120",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Sigh. After merging this into #16453, I get several segmentation faults.



---

archive/issue_comments_204121.json:
```json
{
    "body": "<a id='comment:278'></a>\nReplying to [SimonKing](#comment%3A277):\n> Sigh. After merging this into #16453, I get several segmentation faults.\n\n\nBut fortunately this ticket is not to blame for it `:-)`",
    "created_at": "2014-10-23T14:08:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204121",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:278'></a>
Replying to [SimonKing](#comment%3A277):
> Sigh. After merging this into #16453, I get several segmentation faults.


But fortunately this ticket is not to blame for it `:-)`



---

archive/issue_comments_204122.json:
```json
{
    "body": "<a id='comment:9'></a>\nI am going to leave this ticket alone for at least a few days.\n\nI do think there is still a lot of improvement, mainly simplification:\n1. Implement `biseq_setitem()` and use that in a lot of places.\n2. Implement `mpn_equal_bits_shifted()` to compare bit patterns efficiently for equality and use this for `biseq_max_overlap` and `biseq_contains`.",
    "created_at": "2014-10-23T14:20:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204122",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:9'></a>
I am going to leave this ticket alone for at least a few days.

I do think there is still a lot of improvement, mainly simplification:
1. Implement `biseq_setitem()` and use that in a lot of places.
2. Implement `mpn_equal_bits_shifted()` to compare bit patterns efficiently for equality and use this for `biseq_max_overlap` and `biseq_contains`.



---

archive/issue_comments_204123.json:
```json
{
    "body": "**Changing branch** from \"[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)\" to \"[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)\".",
    "created_at": "2014-10-23T14:22:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204123",
    "user": "https://github.com/jdemeyer"
}
```

**Changing branch** from "[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)" to "[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)".



---

archive/issue_comments_204124.json:
```json
{
    "body": "<a id='comment:1'></a>\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3\">9056cf6</a></td><td><code>Fix handling of bound in biseq_init_list</code></td></tr></table>\n",
    "created_at": "2014-10-23T14:22:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204124",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:1'></a>
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3">9056cf6</a></td><td><code>Fix handling of bound in biseq_init_list</code></td></tr></table>




---

archive/issue_comments_204125.json:
```json
{
    "body": "**Changing commit** from \"[41c40cf2c59734e7e665ba9c2350da2930c9cc8e](https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e)\" to \"[9056cf636b65d30c5c89bc151c7740c1ea1143d3](https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3)\".",
    "created_at": "2014-10-23T14:22:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204125",
    "user": "https://github.com/jdemeyer"
}
```

**Changing commit** from "[41c40cf2c59734e7e665ba9c2350da2930c9cc8e](https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e)" to "[9056cf636b65d30c5c89bc151c7740c1ea1143d3](https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3)".



---

archive/issue_comments_204126.json:
```json
{
    "body": "<a id='comment:282'></a>\nReplying to [jdemeyer](#comment%3A279):\n> 1. Implement `biseq_setitem()` and use that in a lot of places.\n\n\n`BoundedIntegerSequence` was (originally) thought of as being immutable (it is hashable). Hence, so far, I only see application in `biseq_init_list` and `biseq_slice`. OK, that's something...\n\n> 2. Implement `mpn_equal_bits_shifted()` to compare bit patterns efficiently for equality and use this for `biseq_max_overlap` and `biseq_contains`.\n\n\n+1.",
    "created_at": "2014-10-23T14:46:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204126",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:282'></a>
Replying to [jdemeyer](#comment%3A279):
> 1. Implement `biseq_setitem()` and use that in a lot of places.


`BoundedIntegerSequence` was (originally) thought of as being immutable (it is hashable). Hence, so far, I only see application in `biseq_init_list` and `biseq_slice`. OK, that's something...

> 2. Implement `mpn_equal_bits_shifted()` to compare bit patterns efficiently for equality and use this for `biseq_max_overlap` and `biseq_contains`.


+1.



---

archive/issue_comments_204127.json:
```json
{
    "body": "<a id='comment:3'></a>\nWould it be acceptable that `biseq_setitem(S,index,item)` assumes that `S[item]` is zero before the assignment? This condition holds in the two applications I can think of.\n\nOf course, I could additionally provide a function that sets a previously existing item to zero.",
    "created_at": "2014-10-23T15:14:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204127",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Would it be acceptable that `biseq_setitem(S,index,item)` assumes that `S[item]` is zero before the assignment? This condition holds in the two applications I can think of.

Of course, I could additionally provide a function that sets a previously existing item to zero.



---

archive/issue_comments_204128.json:
```json
{
    "body": "<a id='comment:284'></a>\nReplying to [SimonKing](#comment%3A283):\n> Would it be acceptable that `biseq_setitem(S,index,item)` assumes that `S[item]` is zero before the assignment?\n\nThen I would call it `biseq_inititem(S, index, item)`.",
    "created_at": "2014-10-23T15:45:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204128",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:284'></a>
Replying to [SimonKing](#comment%3A283):
> Would it be acceptable that `biseq_setitem(S,index,item)` assumes that `S[item]` is zero before the assignment?

Then I would call it `biseq_inititem(S, index, item)`.



---

archive/issue_comments_204129.json:
```json
{
    "body": "**Changing branch** from \"[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)\" to \"[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)\".",
    "created_at": "2014-10-23T17:47:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204129",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing branch** from "[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)" to "[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)".



---

archive/issue_comments_204130.json:
```json
{
    "body": "<a id='comment:6'></a>\nIt will be more efficient to declare `biseq_inititem` as `cdef inline void`.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051\">e9c779a</a></td><td><code>Simplify code by using biseq_getitem/biseq_inititem</code></td></tr></table>\n",
    "created_at": "2014-10-23T17:53:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204130",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:6'></a>
It will be more efficient to declare `biseq_inititem` as `cdef inline void`.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051">e9c779a</a></td><td><code>Simplify code by using biseq_getitem/biseq_inititem</code></td></tr></table>




---

archive/issue_comments_204131.json:
```json
{
    "body": "**Changing commit** from \"[9056cf636b65d30c5c89bc151c7740c1ea1143d3](https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3)\" to \"[e9c779ae629dbec356bb8546e3974e2a67050051](https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051)\".",
    "created_at": "2014-10-23T17:53:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204131",
    "user": "https://github.com/jdemeyer"
}
```

**Changing commit** from "[9056cf636b65d30c5c89bc151c7740c1ea1143d3](https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3)" to "[e9c779ae629dbec356bb8546e3974e2a67050051](https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051)".



---

archive/issue_comments_204132.json:
```json
{
    "body": "<a id='comment:7'></a>\nConcerning `enumerate()`: I have no idea if Cython optimizes this. If not, you better just manually keep track of `index`.",
    "created_at": "2014-10-23T17:55:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204132",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>
Concerning `enumerate()`: I have no idea if Cython optimizes this. If not, you better just manually keep track of `index`.



---

archive/issue_comments_204133.json:
```json
{
    "body": "<a id='comment:8'></a>\nWhy did you change `if item_limb > bound` to `if item > bound`? The former is a C comparison, therefore faster.",
    "created_at": "2014-10-23T17:57:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204133",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
Why did you change `if item_limb > bound` to `if item > bound`? The former is a C comparison, therefore faster.



---

archive/issue_comments_204134.json:
```json
{
    "body": "<a id='comment:289'></a>\nReplying to [jdemeyer](#comment%3A286):\n> It will be more efficient to declare `biseq_inititem` as `cdef inline void`.\n\nMore generally: if you have `cdef` or `cpdef` functions returning nothing and you don't require exception handling, then using `void` as return type is more efficient (without it, the functions return the Python value `None`).",
    "created_at": "2014-10-23T18:00:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204134",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:289'></a>
Replying to [jdemeyer](#comment%3A286):
> It will be more efficient to declare `biseq_inititem` as `cdef inline void`.

More generally: if you have `cdef` or `cpdef` functions returning nothing and you don't require exception handling, then using `void` as return type is more efficient (without it, the functions return the Python value `None`).



---

archive/issue_comments_204135.json:
```json
{
    "body": "<a id='comment:290'></a>\nReplying to [jdemeyer](#comment%3A288):\n> Why did you change `if item_limb > bound` to `if item > bound`? The former is a C comparison, therefore faster.\n\n\nSure. But you did `item_limb = item` without testing whether `item > bound`, which means that item_limb could end up *below* the bound. Hence, you'd have the random truncation that you wanted to avoid.",
    "created_at": "2014-10-23T18:00:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204135",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:290'></a>
Replying to [jdemeyer](#comment%3A288):
> Why did you change `if item_limb > bound` to `if item > bound`? The former is a C comparison, therefore faster.


Sure. But you did `item_limb = item` without testing whether `item > bound`, which means that item_limb could end up *below* the bound. Hence, you'd have the random truncation that you wanted to avoid.



---

archive/issue_comments_204136.json:
```json
{
    "body": "<a id='comment:291'></a>\nReplying to [SimonKing](#comment%3A290):\n> But you did `item_limb = item` without testing whether `item > bound`, which means that item_limb could end up *below* the bound.\n\nNot true because the assignment `item_limb = item` is a Python -> C conversion which is always checked:\n\n```\nsage: BoundedIntegerSequence(100, [2^256])\n---------------------------------------------------------------------------\nOverflowError                             Traceback (most recent call last)\n<ipython-input-6-ba7f864a5712> in <module>()\n----> 1 BoundedIntegerSequence(Integer(100), [Integer(2)**Integer(256)])\n\n/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.BoundedIntegerSequence.__init__ (build/cythonized/sage/data_structures/bounded_integer_sequences.c:7798)()\n\n/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.biseq_init_list (build/cythonized/sage/data_structures/bounded_integer_sequences.c:5706)()\n\nOverflowError: long int too large to convert\n```\n(perhaps add this as doctest)",
    "created_at": "2014-10-23T18:19:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204136",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:291'></a>
Replying to [SimonKing](#comment%3A290):
> But you did `item_limb = item` without testing whether `item > bound`, which means that item_limb could end up *below* the bound.

Not true because the assignment `item_limb = item` is a Python -> C conversion which is always checked:

```
sage: BoundedIntegerSequence(100, [2^256])
---------------------------------------------------------------------------
OverflowError                             Traceback (most recent call last)
<ipython-input-6-ba7f864a5712> in <module>()
----> 1 BoundedIntegerSequence(Integer(100), [Integer(2)**Integer(256)])

/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.BoundedIntegerSequence.__init__ (build/cythonized/sage/data_structures/bounded_integer_sequences.c:7798)()

/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.biseq_init_list (build/cythonized/sage/data_structures/bounded_integer_sequences.c:5706)()

OverflowError: long int too large to convert
```
(perhaps add this as doctest)



---

archive/issue_comments_204137.json:
```json
{
    "body": "<a id='comment:2'></a>\nI repeated the timings from commit:157, but still with the `item<=bound` test (so, initialisation time might improve).\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\n```\n\n```\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.45 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n100000 loops, best of 3: 2.1 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n100000 loops, best of 3: 4.28 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n1000 loops, best of 3: 300 \u00b5s per loop\n```\n--> Became much slower\n\n```\nsage: %timeit x = list(S0)\n1000000 loops, best of 3: 1.44 \u00b5s per loop\nsage: %timeit x = list(S1)\n100000 loops, best of 3: 2.18 \u00b5s per loop\nsage: %timeit x = list(S2)\n100000 loops, best of 3: 4.29 \u00b5s per loop\nsage: %timeit x = list(S3)\n1000 loops, best of 3: 286 \u00b5s per loop\nsage: %timeit x = S0.list()\n1000000 loops, best of 3: 697 ns per loop\nsage: %timeit x = S1.list()\n1000000 loops, best of 3: 1.2 \u00b5s per loop\nsage: %timeit x = S2.list()\n100000 loops, best of 3: 2.78 \u00b5s per loop\nsage: %timeit x = S3.list()\n10000 loops, best of 3: 135 \u00b5s per loop\n```\n--> not much conclusive\n\n```\nsage: timeit(\"x=S0[:-1]\", number=100000)\n100000 loops, best of 3: 815 ns per loop\nsage: timeit(\"x=S1[:-1]\", number=100000)\n100000 loops, best of 3: 846 ns per loop\nsage: timeit(\"x=S2[:-1]\", number=100000)\n100000 loops, best of 3: 845 ns per loop\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 1.62 \u00b5s per loop\nsage: timeit(\"x=S2[:-1:2]\", number=10000)\n10000 loops, best of 3: 1.55 \u00b5s per loop\nsage: timeit(\"x=S3[:-1:2]\", number=10000)\n10000 loops, best of 3: 49.8 \u00b5s per loop\n```\n--> Became *much* faster\n\n```\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 354 ns per loop\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 355 ns per loop\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 339 ns per loop\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 346 ns per loop\n```\n--> Became perhaps slower.\n\nWhat does that all mean?\n\nFor my applications not very much, actually, because what I care about is not\ninitialisation from lists and direct item access and not slices with step\ndifferent from one, but I do care about:\n- Testing for subsequence containment, comparison and hash\n- Slicing with step one\n- Concatenation.\n\nSo, I leave it up to you whether clarity of code is more important than the\nabove slow-down...",
    "created_at": "2014-10-23T18:24:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204137",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
I repeated the timings from commit:157, but still with the `item<=bound` test (so, initialisation time might improve).

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
```

```
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.45 µs per loop
sage: %timeit x = BoundedIntegerSequence(16, L1)
100000 loops, best of 3: 2.1 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L2)
100000 loops, best of 3: 4.28 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L3)
1000 loops, best of 3: 300 µs per loop
```
--> Became much slower

```
sage: %timeit x = list(S0)
1000000 loops, best of 3: 1.44 µs per loop
sage: %timeit x = list(S1)
100000 loops, best of 3: 2.18 µs per loop
sage: %timeit x = list(S2)
100000 loops, best of 3: 4.29 µs per loop
sage: %timeit x = list(S3)
1000 loops, best of 3: 286 µs per loop
sage: %timeit x = S0.list()
1000000 loops, best of 3: 697 ns per loop
sage: %timeit x = S1.list()
1000000 loops, best of 3: 1.2 µs per loop
sage: %timeit x = S2.list()
100000 loops, best of 3: 2.78 µs per loop
sage: %timeit x = S3.list()
10000 loops, best of 3: 135 µs per loop
```
--> not much conclusive

```
sage: timeit("x=S0[:-1]", number=100000)
100000 loops, best of 3: 815 ns per loop
sage: timeit("x=S1[:-1]", number=100000)
100000 loops, best of 3: 846 ns per loop
sage: timeit("x=S2[:-1]", number=100000)
100000 loops, best of 3: 845 ns per loop
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 1.62 µs per loop
sage: timeit("x=S2[:-1:2]", number=10000)
10000 loops, best of 3: 1.55 µs per loop
sage: timeit("x=S3[:-1:2]", number=10000)
10000 loops, best of 3: 49.8 µs per loop
```
--> Became *much* faster

```
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 354 ns per loop
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 355 ns per loop
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 339 ns per loop
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 346 ns per loop
```
--> Became perhaps slower.

What does that all mean?

For my applications not very much, actually, because what I care about is not
initialisation from lists and direct item access and not slices with step
different from one, but I do care about:
- Testing for subsequence containment, comparison and hash
- Slicing with step one
- Concatenation.

So, I leave it up to you whether clarity of code is more important than the
above slow-down...



---

archive/issue_comments_204138.json:
```json
{
    "body": "<a id='comment:3'></a>\nIf you do timings, please keep in mind [comment:286].",
    "created_at": "2014-10-23T18:31:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204138",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>
If you do timings, please keep in mind [comment:286].



---

archive/issue_comments_204139.json:
```json
{
    "body": "<a id='comment:4'></a>\nRight. When using `item_limb`, the timings for initialisation from lists become good:\n\n```\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.27 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n1000000 loops, best of 3: 1.51 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n1000000 loops, best of 3: 1.88 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n10000 loops, best of 3: 65.5 \u00b5s per loop\n```",
    "created_at": "2014-10-23T18:41:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204139",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
Right. When using `item_limb`, the timings for initialisation from lists become good:

```
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.27 µs per loop
sage: %timeit x = BoundedIntegerSequence(16, L1)
1000000 loops, best of 3: 1.51 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L2)
1000000 loops, best of 3: 1.88 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L3)
10000 loops, best of 3: 65.5 µs per loop
```



---

archive/issue_comments_204140.json:
```json
{
    "body": "<a id='comment:295'></a>\nReplying to [jdemeyer](#comment%3A293):\n> If you do timings, please keep in mind [comment:286].\n\n\nThe timings are after using `inline void`.",
    "created_at": "2014-10-23T18:42:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204140",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:295'></a>
Replying to [jdemeyer](#comment%3A293):
> If you do timings, please keep in mind [comment:286].


The timings are after using `inline void`.



---

archive/issue_comments_204141.json:
```json
{
    "body": "**Changing commit** from \"[e9c779ae629dbec356bb8546e3974e2a67050051](https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051)\" to \"[7d258591bab37466eb6392443ed2e84cf699102c](https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c)\".",
    "created_at": "2014-10-23T18:45:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204141",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[e9c779ae629dbec356bb8546e3974e2a67050051](https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051)" to "[7d258591bab37466eb6392443ed2e84cf699102c](https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c)".



---

archive/issue_comments_204142.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/acf2a7552bb19d3a9692c8f23a487c50f9e5b4d8\">acf2a75</a></td><td><code>Declare some functions as 'cdef inline void'</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c\">7d25859</a></td><td><code>Speed-up for testing bounds</code></td></tr></table>\n",
    "created_at": "2014-10-23T18:45:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204142",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/acf2a7552bb19d3a9692c8f23a487c50f9e5b4d8">acf2a75</a></td><td><code>Declare some functions as 'cdef inline void'</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c">7d25859</a></td><td><code>Speed-up for testing bounds</code></td></tr></table>




---

archive/issue_comments_204143.json:
```json
{
    "body": "<a id='comment:7'></a>\nI know it's really a detail, but I intentionally used `repr(item)` to display the error message\n\n```\nraise ValueError(\"list item %r larger than %s\"%(item, bound) )\n```\n\nThis way, the error message refers to the list item as given by the user, which might be some strange Python type which prints differently.",
    "created_at": "2014-10-23T19:39:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204143",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>
I know it's really a detail, but I intentionally used `repr(item)` to display the error message

```
raise ValueError("list item %r larger than %s"%(item, bound) )
```

This way, the error message refers to the list item as given by the user, which might be some strange Python type which prints differently.



---

archive/issue_comments_204144.json:
```json
{
    "body": "<a id='comment:8'></a>\nSomething else: the implementation of `biseq_getitem_py` using `PyInt_FromSize_t` gives a good reason to have `biseq_item_t == size_t`. Because of this, I would propose to remove the `biseq_item_t` type again and replace it by an explicit `size_t`.",
    "created_at": "2014-10-23T19:41:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204144",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
Something else: the implementation of `biseq_getitem_py` using `PyInt_FromSize_t` gives a good reason to have `biseq_item_t == size_t`. Because of this, I would propose to remove the `biseq_item_t` type again and replace it by an explicit `size_t`.



---

archive/issue_comments_204145.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e\">8a10b73</a></td><td><code>Use plain size_t, not biseq_item_t</code></td></tr></table>\n",
    "created_at": "2014-10-24T05:32:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204145",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e">8a10b73</a></td><td><code>Use plain size_t, not biseq_item_t</code></td></tr></table>




---

archive/issue_comments_204146.json:
```json
{
    "body": "**Changing commit** from \"[7d258591bab37466eb6392443ed2e84cf699102c](https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c)\" to \"[8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e](https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e)\".",
    "created_at": "2014-10-24T05:32:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204146",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7d258591bab37466eb6392443ed2e84cf699102c](https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c)" to "[8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e](https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e)".



---

archive/issue_comments_204147.json:
```json
{
    "body": "**Changing commit** from \"[8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e](https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e)\" to \"[fa7cde09b93359371f236ce6da13bb8f5a947a08](https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08)\".",
    "created_at": "2014-10-24T06:08:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204147",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e](https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e)" to "[fa7cde09b93359371f236ce6da13bb8f5a947a08](https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08)".



---

archive/issue_comments_204148.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08\">fa7cde0</a></td><td><code>Use original data in error message</code></td></tr></table>\n",
    "created_at": "2014-10-24T06:08:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204148",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08">fa7cde0</a></td><td><code>Use original data in error message</code></td></tr></table>




---

archive/issue_comments_204149.json:
```json
{
    "body": "**Changing commit** from \"[fa7cde09b93359371f236ce6da13bb8f5a947a08](https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08)\" to \"[6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb](https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb)\".",
    "created_at": "2014-10-24T11:14:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204149",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[fa7cde09b93359371f236ce6da13bb8f5a947a08](https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08)" to "[6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb](https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb)".



---

archive/issue_comments_204150.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb\">6e03f19</a></td><td><code>Code and speed improvement for biseq containment test</code></td></tr></table>\n",
    "created_at": "2014-10-24T11:14:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204150",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb">6e03f19</a></td><td><code>Code and speed improvement for biseq containment test</code></td></tr></table>




---

archive/issue_comments_204151.json:
```json
{
    "body": "<a id='comment:2'></a>\nI have implemented `mpn_equal_bits_shifted`. I do *not* use `mpn_rshift`\nfollowed be `mpn_cmp`, since this would mean to touch each limb twice (once\nfor shifting, once for comparison), even if the difference occurs early in the\nsequence. Of course, using such function simplifies the code of\n`biseq_contains` and `biseq_max_overlap` considerably.\n\nHere I redo the containment tests from [comment:157](#comment%3A157), giving timings with the new\ncode and (in brackets) with the previous code (I would not directly compare\nwith [comment:157](#comment%3A157), since the previous code differs too much from the code back\nat [comment:157](#comment%3A157)).\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: S1y = BoundedIntegerSequence(16, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 190 ns per loop  (384 ns per loop)\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 282 ns per loop  (519 ns per loop)\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 644 ns per loop  (2.1 \u00b5s per loop)\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 50.2 \u00b5s per loop    (2.36 ms per loop)\n```\n\nSo, there is a very clear improvement, and this time it concerns a function\nthat I use very extensively in my applications.\n\nJeroen, I think that with the new commit I addressed all of your concerns,\nhence, for now I will move on to the follow-up tickets (i.e., cythoned quiver\npaths and the non-commutative F5 algorithm that is not on trac yet).",
    "created_at": "2014-10-24T11:17:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204151",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
I have implemented `mpn_equal_bits_shifted`. I do *not* use `mpn_rshift`
followed be `mpn_cmp`, since this would mean to touch each limb twice (once
for shifting, once for comparison), even if the difference occurs early in the
sequence. Of course, using such function simplifies the code of
`biseq_contains` and `biseq_max_overlap` considerably.

Here I redo the containment tests from [comment:157](#comment%3A157), giving timings with the new
code and (in brackets) with the previous code (I would not directly compare
with [comment:157](#comment%3A157), since the previous code differs too much from the code back
at [comment:157](#comment%3A157)).

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: S1y = BoundedIntegerSequence(16, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 190 ns per loop  (384 ns per loop)
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 282 ns per loop  (519 ns per loop)
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 644 ns per loop  (2.1 µs per loop)
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 50.2 µs per loop    (2.36 ms per loop)
```

So, there is a very clear improvement, and this time it concerns a function
that I use very extensively in my applications.

Jeroen, I think that with the new commit I addressed all of your concerns,
hence, for now I will move on to the follow-up tickets (i.e., cythoned quiver
paths and the non-commutative F5 algorithm that is not on trac yet).



---

archive/issue_events_143619.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T08:01:05Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143619"
}
```



---

archive/issue_events_143620.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T08:01:05Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143620"
}
```



---

archive/issue_comments_204152.json:
```json
{
    "body": "<a id='comment:303'></a>\n(never mind)",
    "created_at": "2014-10-27T08:01:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204152",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:303'></a>
(never mind)



---

archive/issue_events_143621.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T08:06:33Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143621"
}
```



---

archive/issue_events_143622.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T08:06:33Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143622"
}
```



---

archive/issue_comments_204153.json:
```json
{
    "body": "<a id='comment:5'></a>\n`__iter__` and `biseq_index` should be implemented in terms of `biseq_getitem()` (or a good reason given why this is a bad idea).",
    "created_at": "2014-10-27T17:23:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204153",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
`__iter__` and `biseq_index` should be implemented in terms of `biseq_getitem()` (or a good reason given why this is a bad idea).



---

archive/issue_events_143623.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T17:23:10Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143623"
}
```



---

archive/issue_events_143624.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T17:23:10Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143624"
}
```



---

archive/issue_comments_204154.json:
```json
{
    "body": "<a id='comment:7'></a>\nIn `biseq_init_list`, iteration is about 10% faster the following way:\n\n```\nfor item in data:\n    item_limb = item\n    index += 1\n```\ninstead of\n\n```\nfor index from 0<=index<R.length:\n    item_limb = data[index]\n```",
    "created_at": "2014-10-27T18:08:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204154",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>
In `biseq_init_list`, iteration is about 10% faster the following way:

```
for item in data:
    item_limb = item
    index += 1
```
instead of

```
for index from 0<=index<R.length:
    item_limb = data[index]
```



---

archive/issue_comments_204155.json:
```json
{
    "body": "<a id='comment:8'></a>\n`biseq_clearitem` must be added to the `.pxd` file",
    "created_at": "2014-10-27T18:12:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204155",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
`biseq_clearitem` must be added to the `.pxd` file



---

archive/issue_comments_204156.json:
```json
{
    "body": "<a id='comment:9'></a>\nIn `biseq_slice`, the case `step == 1` should also be implemented using bitset primitives.",
    "created_at": "2014-10-27T18:16:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204156",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:9'></a>
In `biseq_slice`, the case `step == 1` should also be implemented using bitset primitives.



---

archive/issue_comments_204157.json:
```json
{
    "body": "<a id='comment:0'></a>\nShould I make these changes or will you? I'm just asking to avoid duplicate work.",
    "created_at": "2014-10-27T21:32:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204157",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:0'></a>
Should I make these changes or will you? I'm just asking to avoid duplicate work.



---

archive/issue_comments_204158.json:
```json
{
    "body": "<a id='comment:311'></a>\nReplying to [jdemeyer](#comment%3A310):\n> Should I make these changes or will you? I'm just asking to avoid duplicate work.\n\n\nI will try today.",
    "created_at": "2014-10-28T07:12:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204158",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:311'></a>
Replying to [jdemeyer](#comment%3A310):
> Should I make these changes or will you? I'm just asking to avoid duplicate work.


I will try today.



---

archive/issue_comments_204159.json:
```json
{
    "body": "<a id='comment:2'></a>\nWhile I am at it, I will also make `biseq_max_overlap`, `biseq_index` and `biseq_contains` return `mp_size_t`, not `int`. After all, they return an index in a bounded integer sequence (or -1 if not found, or -2 on error), and I think we have agreed that indices should be `mp_size_t`.",
    "created_at": "2014-10-28T09:46:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204159",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
While I am at it, I will also make `biseq_max_overlap`, `biseq_index` and `biseq_contains` return `mp_size_t`, not `int`. After all, they return an index in a bounded integer sequence (or -1 if not found, or -2 on error), and I think we have agreed that indices should be `mp_size_t`.



---

archive/issue_comments_204160.json:
```json
{
    "body": "<a id='comment:3'></a>\nCurrently, when calling `B.index(i)`, `i` is compared modulo the `B.bound()` with the items of `B`. Taking `i` modulo the bound is currently done in `biseq_index`. I suggest to move this to `B.index`, since generally I want to avoid bound checking etc. in the boilerplate functions.",
    "created_at": "2014-10-28T09:55:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204160",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Currently, when calling `B.index(i)`, `i` is compared modulo the `B.bound()` with the items of `B`. Taking `i` modulo the bound is currently done in `biseq_index`. I suggest to move this to `B.index`, since generally I want to avoid bound checking etc. in the boilerplate functions.



---

archive/issue_comments_204161.json:
```json
{
    "body": "<a id='comment:314'></a>\nReplying to [SimonKing](#comment%3A312):\n> While I am at it, I will also make `biseq_max_overlap`, `biseq_index` and `biseq_contains` return `mp_size_t`, not `int`. After all, they return an index in a bounded integer sequence (or -1 if not found, or -2 on error), and I think we have agreed that indices should be `mp_size_t`.\n\n\nI hadn't noticed, but yes: that should certainly be changed.",
    "created_at": "2014-10-28T09:55:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204161",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:314'></a>
Replying to [SimonKing](#comment%3A312):
> While I am at it, I will also make `biseq_max_overlap`, `biseq_index` and `biseq_contains` return `mp_size_t`, not `int`. After all, they return an index in a bounded integer sequence (or -1 if not found, or -2 on error), and I think we have agreed that indices should be `mp_size_t`.


I hadn't noticed, but yes: that should certainly be changed.



---

archive/issue_comments_204162.json:
```json
{
    "body": "<a id='comment:315'></a>\nReplying to [SimonKing](#comment%3A313):\n> Currently, when calling `B.index(i)`, `i` is compared modulo the `B.bound()` with the items of `B`. Taking `i` modulo the bound is currently done in `biseq_index`. I suggest to move this to `B.index`\n\nI would remove this modulo operation completely. If the item is too large or too small, treat it as not found.",
    "created_at": "2014-10-28T09:58:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204162",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:315'></a>
Replying to [SimonKing](#comment%3A313):
> Currently, when calling `B.index(i)`, `i` is compared modulo the `B.bound()` with the items of `B`. Taking `i` modulo the bound is currently done in `biseq_index`. I suggest to move this to `B.index`

I would remove this modulo operation completely. If the item is too large or too small, treat it as not found.



---

archive/issue_comments_204163.json:
```json
{
    "body": "<a id='comment:6'></a>\nIn `biseq_index`, use `size_t` for `item`.",
    "created_at": "2014-10-28T10:02:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204163",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:6'></a>
In `biseq_index`, use `size_t` for `item`.



---

archive/issue_comments_204164.json:
```json
{
    "body": "<a id='comment:317'></a>\nReplying to [jdemeyer](#comment%3A316):\n> In `biseq_index`, use `size_t` for `item`.\n\n\nSince `biseq_getitem` returns a `size_t`, or is there another reason?",
    "created_at": "2014-10-28T10:28:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204164",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:317'></a>
Replying to [jdemeyer](#comment%3A316):
> In `biseq_index`, use `size_t` for `item`.


Since `biseq_getitem` returns a `size_t`, or is there another reason?



---

archive/issue_comments_204165.json:
```json
{
    "body": "<a id='comment:318'></a>\nReplying to [jdemeyer](#comment%3A315):\n> I would remove this modulo operation completely. If the item is too large or too small, treat it as not found.\n\n\nOK, but I'll do this test in `BoundedIntegerSequence.index`, not in `biseq_index`.",
    "created_at": "2014-10-28T10:29:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204165",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:318'></a>
Replying to [jdemeyer](#comment%3A315):
> I would remove this modulo operation completely. If the item is too large or too small, treat it as not found.


OK, but I'll do this test in `BoundedIntegerSequence.index`, not in `biseq_index`.



---

archive/issue_comments_204166.json:
```json
{
    "body": "<a id='comment:9'></a>\nShould I use `biseq_getitem_py` both in `BoundedIntegerSequence.__iter__` and `BoundedIntegerSequence.list`? Or should one of them use `biseq_getitem` for efficiency?",
    "created_at": "2014-10-28T10:33:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204166",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Should I use `biseq_getitem_py` both in `BoundedIntegerSequence.__iter__` and `BoundedIntegerSequence.list`? Or should one of them use `biseq_getitem` for efficiency?



---

archive/issue_comments_204167.json:
```json
{
    "body": "<a id='comment:320'></a>\nReplying to [jdemeyer](#comment%3A309):\n> In `biseq_slice`, the case `step == 1` should also be implemented using bitset primitives.\n\n\nProblem: We would need a bitset primitive that shifts a *part* of a bitset S. Currently, `bitset_rshift` shifts all of S, not just a part of S.\n\nI see four ways to proceed:\n- Write a new primitive `bitset_rshift_subset`, which means code duplication\n- Add an optional argument to `bitset_rshift`, which means that all places using this function must be changed.\n- Change `bitset_rshift` so that no assumption on the size of source and target are needed: We just shift the minimum of the number of limbs that is available in the source and of the number of limbs that fits into the target.\n- Do not use bitset primitives in `biseq_slice`.",
    "created_at": "2014-10-28T10:55:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204167",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:320'></a>
Replying to [jdemeyer](#comment%3A309):
> In `biseq_slice`, the case `step == 1` should also be implemented using bitset primitives.


Problem: We would need a bitset primitive that shifts a *part* of a bitset S. Currently, `bitset_rshift` shifts all of S, not just a part of S.

I see four ways to proceed:
- Write a new primitive `bitset_rshift_subset`, which means code duplication
- Add an optional argument to `bitset_rshift`, which means that all places using this function must be changed.
- Change `bitset_rshift` so that no assumption on the size of source and target are needed: We just shift the minimum of the number of limbs that is available in the source and of the number of limbs that fits into the target.
- Do not use bitset primitives in `biseq_slice`.



---

archive/issue_comments_204168.json:
```json
{
    "body": "<a id='comment:1'></a>\nPS: My favourite would be to modify `bitset_rshift` (and `bitset_lshift`) to make it robust against reading/writing out of bound, in the sense that `bitset_rshift(R,S,n)` moves a subset of S that fits into R.",
    "created_at": "2014-10-28T11:00:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204168",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
PS: My favourite would be to modify `bitset_rshift` (and `bitset_lshift`) to make it robust against reading/writing out of bound, in the sense that `bitset_rshift(R,S,n)` moves a subset of S that fits into R.



---

archive/issue_comments_204169.json:
```json
{
    "body": "**Changing commit** from \"[6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb](https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb)\" to \"[b5b066dc218d7fb6e5e13eb19cce4720d4a2d057](https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057)\".",
    "created_at": "2014-10-28T15:34:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204169",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb](https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb)" to "[b5b066dc218d7fb6e5e13eb19cce4720d4a2d057](https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057)".



---

archive/issue_comments_204170.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057\">b5b066d</a></td><td><code>Code simplification for biseq_*, bound check for bitset shifts</code></td></tr></table>\n",
    "created_at": "2014-10-28T15:34:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204170",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057">b5b066d</a></td><td><code>Code simplification for biseq_*, bound check for bitset shifts</code></td></tr></table>




---

archive/issue_comments_204171.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b\">43f78ad</a></td><td><code>Adding a reference to trac</code></td></tr></table>\n",
    "created_at": "2014-10-28T15:35:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204171",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b">43f78ad</a></td><td><code>Adding a reference to trac</code></td></tr></table>




---

archive/issue_comments_204172.json:
```json
{
    "body": "**Changing commit** from \"[b5b066dc218d7fb6e5e13eb19cce4720d4a2d057](https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057)\" to \"[43f78ad50eee7259ab06d5eec1d4cdb03a43f50b](https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b)\".",
    "created_at": "2014-10-28T15:35:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204172",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[b5b066dc218d7fb6e5e13eb19cce4720d4a2d057](https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057)" to "[43f78ad50eee7259ab06d5eec1d4cdb03a43f50b](https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b)".



---

archive/issue_comments_204173.json:
```json
{
    "body": "<a id='comment:4'></a>\nIn the new commits I addressed (I hope) all issues that we discussed yesterday\nand today.\n\nTimings without the new commits:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(27, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])\nsage: %timeit B.list()\n1000000 loops, best of 3: 1.64 \u00b5s per loop\nsage: %timeit list(B)\n100000 loops, best of 3: 2.57 \u00b5s per loop\nsage: %timeit B[2:-2]\n1000000 loops, best of 3: 1.13 \u00b5s per loop\nsage: L = [randint(0,7) for _ in range(1000)]\nsage: %timeit B = BoundedIntegerSequence(8, L)\n100000 loops, best of 3: 13 \u00b5s per loop\nsage: B = BoundedIntegerSequence(8, L)\nsage: %timeit B.list()\n10000 loops, best of 3: 31.5 \u00b5s per loop\nsage: %timeit list(B)\n10000 loops, best of 3: 55 \u00b5s per loop\nsage: %timeit B[3:800]\n1000000 loops, best of 3: 1.26 \u00b5s per loop\n```\n\nAnd with the new commit:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(27, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])\nsage: %timeit B.list()\n1000000 loops, best of 3: 1.6 \u00b5s per loop\nsage: %timeit list(B)\n100000 loops, best of 3: 2.62 \u00b5s per loop\nsage: %timeit B[2:-2]\n1000000 loops, best of 3: 1.12 \u00b5s per loop\nsage: L = [randint(0,7) for _ in range(1000)]\nsage: %timeit B = BoundedIntegerSequence(8, L)\n100000 loops, best of 3: 11.5 \u00b5s per loop\nsage: B = BoundedIntegerSequence(8, L)\nsage: %timeit B.list()\n10000 loops, best of 3: 30.8 \u00b5s per loop\nsage: %timeit list(B)\n10000 loops, best of 3: 64.9 \u00b5s per loop\nsage: %timeit B[3:800]\n1000000 loops, best of 3: 1.27 \u00b5s per loop\n```\n\nApparently, creation from a list became faster, iteration over a long\nlist became 10% slower (but in my appliations, I do not iterate over the items\nof a bounded integer sequence, hence, I don't care about the slow-down), and\neverything else did not change significantly.\n\nAnd the code became clearer, which is a plus. I hope you'll find that my\nchanges to `bitset_rshift` and `bitset_lshift` make sense.",
    "created_at": "2014-10-28T15:41:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204173",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
In the new commits I addressed (I hope) all issues that we discussed yesterday
and today.

Timings without the new commits:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(27, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])
sage: %timeit B.list()
1000000 loops, best of 3: 1.64 µs per loop
sage: %timeit list(B)
100000 loops, best of 3: 2.57 µs per loop
sage: %timeit B[2:-2]
1000000 loops, best of 3: 1.13 µs per loop
sage: L = [randint(0,7) for _ in range(1000)]
sage: %timeit B = BoundedIntegerSequence(8, L)
100000 loops, best of 3: 13 µs per loop
sage: B = BoundedIntegerSequence(8, L)
sage: %timeit B.list()
10000 loops, best of 3: 31.5 µs per loop
sage: %timeit list(B)
10000 loops, best of 3: 55 µs per loop
sage: %timeit B[3:800]
1000000 loops, best of 3: 1.26 µs per loop
```

And with the new commit:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(27, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])
sage: %timeit B.list()
1000000 loops, best of 3: 1.6 µs per loop
sage: %timeit list(B)
100000 loops, best of 3: 2.62 µs per loop
sage: %timeit B[2:-2]
1000000 loops, best of 3: 1.12 µs per loop
sage: L = [randint(0,7) for _ in range(1000)]
sage: %timeit B = BoundedIntegerSequence(8, L)
100000 loops, best of 3: 11.5 µs per loop
sage: B = BoundedIntegerSequence(8, L)
sage: %timeit B.list()
10000 loops, best of 3: 30.8 µs per loop
sage: %timeit list(B)
10000 loops, best of 3: 64.9 µs per loop
sage: %timeit B[3:800]
1000000 loops, best of 3: 1.27 µs per loop
```

Apparently, creation from a list became faster, iteration over a long
list became 10% slower (but in my appliations, I do not iterate over the items
of a bounded integer sequence, hence, I don't care about the slow-down), and
everything else did not change significantly.

And the code became clearer, which is a plus. I hope you'll find that my
changes to `bitset_rshift` and `bitset_lshift` make sense.



---

archive/issue_events_143625.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-28T15:41:18Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143625"
}
```



---

archive/issue_events_143626.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-28T15:41:18Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143626"
}
```



---

archive/issue_comments_204174.json:
```json
{
    "body": "<a id='comment:326'></a>\nGiven the new code, the comment\n\n```\nItems will not just be compared by congruence modulo the bound of the\nsequence, but by equality.\n```\nno longer makes sense.",
    "created_at": "2014-10-28T15:54:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204174",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:326'></a>
Given the new code, the comment

```
Items will not just be compared by congruence modulo the bound of the
sequence, but by equality.
```
no longer makes sense.



---

archive/issue_comments_204175.json:
```json
{
    "body": "<a id='comment:7'></a>\nI would replace the doc\n\n```\nIf the result of the shift would exceed the size of ``r``, then it\nwill be cut.\n```\nby something like\n\n```\nThere are no assumptions on the sizes of ``a`` and ``r``.\nBits which are shifted outside of the resulting bitset are discarded.\n```",
    "created_at": "2014-10-28T15:58:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204175",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>
I would replace the doc

```
If the result of the shift would exceed the size of ``r``, then it
will be cut.
```
by something like

```
There are no assumptions on the sizes of ``a`` and ``r``.
Bits which are shifted outside of the resulting bitset are discarded.
```



---

archive/issue_comments_204176.json:
```json
{
    "body": "<a id='comment:8'></a>\nIn\n\n```\nraise ValueError(\"list item {} larger than {}\".format(data[index], bound) )\n```\nreplace `data[index]` by `item`.",
    "created_at": "2014-10-28T15:59:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204176",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
In

```
raise ValueError("list item {} larger than {}".format(data[index], bound) )
```
replace `data[index]` by `item`.



---

archive/issue_comments_204177.json:
```json
{
    "body": "**Changing commit** from \"[43f78ad50eee7259ab06d5eec1d4cdb03a43f50b](https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b)\" to \"[7a0dd469527c8a4f39d8d891703fcf5feecda9a1](https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1)\".",
    "created_at": "2014-10-28T16:43:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204177",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[43f78ad50eee7259ab06d5eec1d4cdb03a43f50b](https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b)" to "[7a0dd469527c8a4f39d8d891703fcf5feecda9a1](https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1)".



---

archive/issue_comments_204178.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1\">7a0dd46</a></td><td><code>Some improvements of the doc</code></td></tr></table>\n",
    "created_at": "2014-10-28T16:43:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204178",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1">7a0dd46</a></td><td><code>Some improvements of the doc</code></td></tr></table>




---

archive/issue_comments_204179.json:
```json
{
    "body": "<a id='comment:0'></a>\nDone!\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1\">7a0dd46</a></td><td><code>Some improvements of the doc</code></td></tr></table>\n",
    "created_at": "2014-10-28T16:43:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204179",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Done!

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1">7a0dd46</a></td><td><code>Some improvements of the doc</code></td></tr></table>




---

archive/issue_events_143627.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-29T00:04:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143627"
}
```



---

archive/issue_events_143628.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-29T00:04:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143628"
}
```



---

archive/issue_comments_204180.json:
```json
{
    "body": "<a id='comment:1'></a>\nI found a bug (probably in slicing):\n\n```\nsage: B1 = BoundedIntegerSequence(8, [0,7])\nsage: B2 = BoundedIntegerSequence(8, [2,1,4])\nsage: B1[0:1]+B2\n<0, 7, 1, 4>\nsage: B1[0:1]\n<0>\n```\n\nMy diagnose is that the top bits of the slice (those exceeding the size) have not been cleared. This doesn't show when printing it, but concatenation does rely on the top bits being cleared.",
    "created_at": "2014-10-29T00:04:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204180",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
I found a bug (probably in slicing):

```
sage: B1 = BoundedIntegerSequence(8, [0,7])
sage: B2 = BoundedIntegerSequence(8, [2,1,4])
sage: B1[0:1]+B2
<0, 7, 1, 4>
sage: B1[0:1]
<0>
```

My diagnose is that the top bits of the slice (those exceeding the size) have not been cleared. This doesn't show when printing it, but concatenation does rely on the top bits being cleared.



---

archive/issue_comments_204181.json:
```json
{
    "body": "**Changing commit** from \"[7a0dd469527c8a4f39d8d891703fcf5feecda9a1](https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1)\" to \"[6723c7e44dbae3118e3dff259fd0e633915b53c9](https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9)\".",
    "created_at": "2014-10-29T00:45:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204181",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7a0dd469527c8a4f39d8d891703fcf5feecda9a1](https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1)" to "[6723c7e44dbae3118e3dff259fd0e633915b53c9](https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9)".



---

archive/issue_comments_204182.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9\">6723c7e</a></td><td><code>Fix highest bits of bitsets after fixing</code></td></tr></table>\n",
    "created_at": "2014-10-29T00:45:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204182",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9">6723c7e</a></td><td><code>Fix highest bits of bitsets after fixing</code></td></tr></table>




---

archive/issue_events_143629.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-29T00:45:35Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143629"
}
```



---

archive/issue_events_143630.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-29T00:45:35Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143630"
}
```



---

archive/issue_comments_204183.json:
```json
{
    "body": "<a id='comment:3'></a>\nFixed and tested...\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9\">6723c7e</a></td><td><code>Fix highest bits of bitsets after fixing</code></td></tr></table>\n",
    "created_at": "2014-10-29T00:45:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204183",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Fixed and tested...

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9">6723c7e</a></td><td><code>Fix highest bits of bitsets after fixing</code></td></tr></table>




---

archive/issue_comments_204184.json:
```json
{
    "body": "<a id='comment:4'></a>\nFor consistency, `biseq_slice` should be renamed `biseq_init_slice`.",
    "created_at": "2014-10-29T09:55:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204184",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'></a>
For consistency, `biseq_slice` should be renamed `biseq_init_slice`.



---

archive/issue_comments_204185.json:
```json
{
    "body": "**Changing reviewer** from \"Simon King\" to \"Jeroen Demeyer, Simon King\".",
    "created_at": "2014-10-29T09:58:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204185",
    "user": "https://github.com/jdemeyer"
}
```

**Changing reviewer** from "Simon King" to "Jeroen Demeyer, Simon King".



---

archive/issue_comments_204186.json:
```json
{
    "body": "<a id='comment:5'></a>\nModulo this comment about `biseq_init_slice`, I think the public biseq interface looks good.\n\nI have not looked at all the changes of the last few days and I don't feel like doing that now. I do plan to review this ticket in some time with a fresh look (of course, other reviewers are always welcome). In any case, I think the current branch works well enough that you can use it for your other tickets.",
    "created_at": "2014-10-29T09:58:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204186",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
Modulo this comment about `biseq_init_slice`, I think the public biseq interface looks good.

I have not looked at all the changes of the last few days and I don't feel like doing that now. I do plan to review this ticket in some time with a fresh look (of course, other reviewers are always welcome). In any case, I think the current branch works well enough that you can use it for your other tickets.



---

archive/issue_comments_204187.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0\">b6ef6d5</a></td><td><code>Rename biseq_slice -> biseq_init_slice</code></td></tr></table>\n",
    "created_at": "2014-10-29T14:06:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204187",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0">b6ef6d5</a></td><td><code>Rename biseq_slice -> biseq_init_slice</code></td></tr></table>




---

archive/issue_comments_204188.json:
```json
{
    "body": "**Changing commit** from \"[6723c7e44dbae3118e3dff259fd0e633915b53c9](https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9)\" to \"[b6ef6d5c5faffe4059b1539f00e25dd98b9481c0](https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0)\".",
    "created_at": "2014-10-29T14:06:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204188",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[6723c7e44dbae3118e3dff259fd0e633915b53c9](https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9)" to "[b6ef6d5c5faffe4059b1539f00e25dd98b9481c0](https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0)".



---

archive/issue_comments_204189.json:
```json
{
    "body": "<a id='comment:7'></a>\nIn `biseq_init_slice(biseq_t R, biseq_t S, mp_size_t start, mp_size_t stop, int step)`, the `step` argument should also be `mp_size_t`.",
    "created_at": "2014-10-30T10:05:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204189",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>
In `biseq_init_slice(biseq_t R, biseq_t S, mp_size_t start, mp_size_t stop, int step)`, the `step` argument should also be `mp_size_t`.



---

archive/issue_comments_204190.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d\">0e51c4a</a></td><td><code>Change the type of an argument</code></td></tr></table>\n",
    "created_at": "2014-10-30T10:55:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204190",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d">0e51c4a</a></td><td><code>Change the type of an argument</code></td></tr></table>




---

archive/issue_comments_204191.json:
```json
{
    "body": "**Changing commit** from \"[b6ef6d5c5faffe4059b1539f00e25dd98b9481c0](https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0)\" to \"[0e51c4a8ae1720e301b4d57ee51289de475bf51d](https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d)\".",
    "created_at": "2014-10-30T10:55:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204191",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[b6ef6d5c5faffe4059b1539f00e25dd98b9481c0](https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0)" to "[0e51c4a8ae1720e301b4d57ee51289de475bf51d](https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d)".



---

archive/issue_comments_204192.json:
```json
{
    "body": "**Changing branch** from \"[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)\" to \"[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)\".",
    "created_at": "2014-10-30T16:34:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204192",
    "user": "https://github.com/jdemeyer"
}
```

**Changing branch** from "[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)" to "[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)".



---

archive/issue_comments_204193.json:
```json
{
    "body": "**Changing commit** from \"[0e51c4a8ae1720e301b4d57ee51289de475bf51d](https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d)\" to \"[d46a22d394c0c3556bd297427614bbc43140efb3](https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3)\".",
    "created_at": "2014-10-30T16:34:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204193",
    "user": "https://github.com/jdemeyer"
}
```

**Changing commit** from "[0e51c4a8ae1720e301b4d57ee51289de475bf51d](https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d)" to "[d46a22d394c0c3556bd297427614bbc43140efb3](https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3)".



---

archive/issue_comments_204194.json:
```json
{
    "body": "<a id='comment:0'></a>\nResolved easy merge conflict.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3\">d46a22d</a></td><td><code>Merge remote-tracking branch 'origin/develop' into ticket/15820</code></td></tr></table>\n",
    "created_at": "2014-10-30T16:34:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204194",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:0'></a>
Resolved easy merge conflict.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3">d46a22d</a></td><td><code>Merge remote-tracking branch 'origin/develop' into ticket/15820</code></td></tr></table>




---

archive/issue_comments_204195.json:
```json
{
    "body": "<a id='comment:1'></a>\nCan the review be finished? #16453 and #17435 depend on it.",
    "created_at": "2014-12-03T14:36:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204195",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Can the review be finished? #16453 and #17435 depend on it.



---

archive/issue_comments_204196.json:
```json
{
    "body": "<a id='comment:2'></a>\nPS: The errors that *some* patchbots report seem unrelated. And I don't see what the coverage script is complaining about. Coverage of the new stuff is 100%.",
    "created_at": "2014-12-03T14:40:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204196",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
PS: The errors that *some* patchbots report seem unrelated. And I don't see what the coverage script is complaining about. Coverage of the new stuff is 100%.



---

archive/issue_comments_204197.json:
```json
{
    "body": "**Changing commit** from \"[d46a22d394c0c3556bd297427614bbc43140efb3](https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3)\" to \"[7e5f21754e6c056d71609830729c093ba09b56a6](https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6)\".",
    "created_at": "2014-12-03T21:28:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204197",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[d46a22d394c0c3556bd297427614bbc43140efb3](https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3)" to "[7e5f21754e6c056d71609830729c093ba09b56a6](https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6)".



---

archive/issue_comments_204198.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6\">7e5f217</a></td><td><code>Reorganize logic of bitset shifts</code></td></tr></table>\n",
    "created_at": "2014-12-03T21:28:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204198",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6">7e5f217</a></td><td><code>Reorganize logic of bitset shifts</code></td></tr></table>




---

archive/issue_comments_204199.json:
```json
{
    "body": "**Changing commit** from \"[7e5f21754e6c056d71609830729c093ba09b56a6](https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6)\" to \"[0c646186f3522ab9bf3210ddc9bd3baf7b1b4664](https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664)\".",
    "created_at": "2014-12-04T09:42:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204199",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7e5f21754e6c056d71609830729c093ba09b56a6](https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6)" to "[0c646186f3522ab9bf3210ddc9bd3baf7b1b4664](https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664)".



---

archive/issue_comments_204200.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d0a5c78fc58c86fa830c6223d735a1507b3c434c\">d0a5c78</a></td><td><code>Move bitset_fix() function</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664\">0c64618</a></td><td><code>Documentation fixes</code></td></tr></table>\n",
    "created_at": "2014-12-04T09:42:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204200",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d0a5c78fc58c86fa830c6223d735a1507b3c434c">d0a5c78</a></td><td><code>Move bitset_fix() function</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664">0c64618</a></td><td><code>Documentation fixes</code></td></tr></table>




---

archive/issue_comments_204201.json:
```json
{
    "body": "**Changing commit** from \"[0c646186f3522ab9bf3210ddc9bd3baf7b1b4664](https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664)\" to \"[58f5f57bd3d620b571ce2c8d1e8da372f5171fdf](https://github.com/sagemath/sagetrac-mirror/commit/58f5f57bd3d620b571ce2c8d1e8da372f5171fdf)\".",
    "created_at": "2014-12-04T12:36:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204201",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[0c646186f3522ab9bf3210ddc9bd3baf7b1b4664](https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664)" to "[58f5f57bd3d620b571ce2c8d1e8da372f5171fdf](https://github.com/sagemath/sagetrac-mirror/commit/58f5f57bd3d620b571ce2c8d1e8da372f5171fdf)".



---

archive/issue_comments_204202.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/93e64fd518f9088da631e6b4126c740f7722af77\">93e64fd</a></td><td><code>Always raise OverflowError if list item is out of bounds</code></td></tr></table>\n",
    "created_at": "2014-12-04T12:36:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204202",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/93e64fd518f9088da631e6b4126c740f7722af77">93e64fd</a></td><td><code>Always raise OverflowError if list item is out of bounds</code></td></tr></table>




---

archive/issue_comments_204203.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8\">411fe4e</a></td><td><code>Simplify/fix the logic of some biseq functions</code></td></tr></table>\n",
    "created_at": "2014-12-04T12:38:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204203",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8">411fe4e</a></td><td><code>Simplify/fix the logic of some biseq functions</code></td></tr></table>




---

archive/issue_comments_204204.json:
```json
{
    "body": "**Changing commit** from \"[58f5f57bd3d620b571ce2c8d1e8da372f5171fdf](https://github.com/sagemath/sagetrac-mirror/commit/58f5f57bd3d620b571ce2c8d1e8da372f5171fdf)\" to \"[411fe4e04b87e5fdf87e4c3f4052e6747e09eca8](https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8)\".",
    "created_at": "2014-12-04T12:38:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204204",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[58f5f57bd3d620b571ce2c8d1e8da372f5171fdf](https://github.com/sagemath/sagetrac-mirror/commit/58f5f57bd3d620b571ce2c8d1e8da372f5171fdf)" to "[411fe4e04b87e5fdf87e4c3f4052e6747e09eca8](https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8)".



---

archive/issue_comments_204205.json:
```json
{
    "body": "**Changing commit** from \"[411fe4e04b87e5fdf87e4c3f4052e6747e09eca8](https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8)\" to \"[8db9f6542a54ead67c1df3d069103b620e85eea6](https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6)\".",
    "created_at": "2014-12-04T14:31:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204205",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[411fe4e04b87e5fdf87e4c3f4052e6747e09eca8](https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8)" to "[8db9f6542a54ead67c1df3d069103b620e85eea6](https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6)".



---

archive/issue_comments_204206.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cf166a67ba74f42f619671129f09028b9c174a1d\">cf166a6</a></td><td><code>Generalise biseq_max_overlap() and rename as biseq_reverse_contains()</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6\">8db9f65</a></td><td><code>Various improvements to BoundedIntegerSequence</code></td></tr></table>\n",
    "created_at": "2014-12-04T14:31:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204206",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cf166a67ba74f42f619671129f09028b9c174a1d">cf166a6</a></td><td><code>Generalise biseq_max_overlap() and rename as biseq_reverse_contains()</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6">8db9f65</a></td><td><code>Various improvements to BoundedIntegerSequence</code></td></tr></table>




---

archive/issue_comments_204207.json:
```json
{
    "body": "<a id='comment:8'></a>\nMy review of this is done now. I'll let you look at my commits.",
    "created_at": "2014-12-04T14:35:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204207",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
My review of this is done now. I'll let you look at my commits.



---

archive/issue_comments_204208.json:
```json
{
    "body": "<a id='comment:9'></a>\nI have made one important functional change: you should change `biseq_max_overlap(A, B)` to `biseq_reverse_contains(B, A, 1)` in the follow-up tickets.\n\nI also fixed a few bugs and changed some exceptions but there should be no other functional changes.",
    "created_at": "2014-12-04T14:39:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204208",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:9'></a>
I have made one important functional change: you should change `biseq_max_overlap(A, B)` to `biseq_reverse_contains(B, A, 1)` in the follow-up tickets.

I also fixed a few bugs and changed some exceptions but there should be no other functional changes.



---

archive/issue_events_143631.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-12-04T15:09:17Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143631"
}
```



---

archive/issue_events_143632.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-12-04T15:09:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143632"
}
```



---

archive/issue_comments_204209.json:
```json
{
    "body": "**Work_Issues:** interrupt handling",
    "created_at": "2014-12-04T15:09:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204209",
    "user": "https://github.com/jdemeyer"
}
```

**Work_Issues:** interrupt handling



---

archive/issue_comments_204210.json:
```json
{
    "body": "<a id='comment:0'></a>\nWe are still missing `sig_*` functions to allow interrupts. But I prefer for you to review my changes before adding those.",
    "created_at": "2014-12-04T15:09:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204210",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:0'></a>
We are still missing `sig_*` functions to allow interrupts. But I prefer for you to review my changes before adding those.



---

archive/issue_comments_204211.json:
```json
{
    "body": "<a id='comment:351'></a>\nDear Jeroen,\n\nthank you for reviewing!\n\nReplying to [jdemeyer](#comment%3A350):\n> We are still missing `sig_*` functions to allow interrupts. But I prefer for you to review my changes before adding those.\n\n\n- You changed the location of the (old) function `bitset_fix`. Why? Won't that increase the likelihood of a merge conflict?\n\n- When reading the function name `biseq_reverse_contains`, I'd expect that it either checks for containment of a reverse subsequence, or it checks for containment of a subsequence starting at the end of the supersequence. Both is not the case. What this function determines is an overlap of the end of first and the beginning of the second argument. That said, I don't think the new function name is worse than the old.\n\nThe other changes seem at least reasonable, some are needed. Thanks for spotting it.\n\nIn any case, there will be a merge conflict with the next follow-up ticket. But I guess it can hardly be avoided. I think we can now take care of signal handling.",
    "created_at": "2014-12-04T23:17:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204211",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:351'></a>
Dear Jeroen,

thank you for reviewing!

Replying to [jdemeyer](#comment%3A350):
> We are still missing `sig_*` functions to allow interrupts. But I prefer for you to review my changes before adding those.


- You changed the location of the (old) function `bitset_fix`. Why? Won't that increase the likelihood of a merge conflict?

- When reading the function name `biseq_reverse_contains`, I'd expect that it either checks for containment of a reverse subsequence, or it checks for containment of a subsequence starting at the end of the supersequence. Both is not the case. What this function determines is an overlap of the end of first and the beginning of the second argument. That said, I don't think the new function name is worse than the old.

The other changes seem at least reasonable, some are needed. Thanks for spotting it.

In any case, there will be a merge conflict with the next follow-up ticket. But I guess it can hardly be avoided. I think we can now take care of signal handling.



---

archive/issue_comments_204212.json:
```json
{
    "body": "<a id='comment:2'></a>\nAnd one thing is not correct in the description of `biseq_reverse_contains`:\n\n```\n  Return ``i`` such that the bounded integer sequence ``S1`` starts with\n  the sequence ``S2[i:]``, where ``start <= i < S2.length``, or return\n  ``-1`` if no such ``i`` exists.\n```\nIf you apply the function (whatever it is named) to `<2,3,2,3,1>` and `<1,2,3,2,3>` (I just notice that you also exchanged the r\u00f4les of `S1` and `S2`!), then I want it to yield the *maximal* overlap: It should return 1, not 3. That's not clear from the new description.",
    "created_at": "2014-12-04T23:28:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204212",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
And one thing is not correct in the description of `biseq_reverse_contains`:

```
  Return ``i`` such that the bounded integer sequence ``S1`` starts with
  the sequence ``S2[i:]``, where ``start <= i < S2.length``, or return
  ``-1`` if no such ``i`` exists.
```
If you apply the function (whatever it is named) to `<2,3,2,3,1>` and `<1,2,3,2,3>` (I just notice that you also exchanged the rôles of `S1` and `S2`!), then I want it to yield the *maximal* overlap: It should return 1, not 3. That's not clear from the new description.



---

archive/issue_comments_204213.json:
```json
{
    "body": "<a id='comment:3'></a>\nHmmmm. I am less and less happy about the \"contains\" in the name `biseq_reverse_contains`. Neither is the first argument contained in the second nor the second contained in the first. And even if it were: We are not interested in mere containment, but we want to know whether a terminal segment of one argument coincides with an initial segment of the other argument.",
    "created_at": "2014-12-04T23:39:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204213",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Hmmmm. I am less and less happy about the "contains" in the name `biseq_reverse_contains`. Neither is the first argument contained in the second nor the second contained in the first. And even if it were: We are not interested in mere containment, but we want to know whether a terminal segment of one argument coincides with an initial segment of the other argument.



---

archive/issue_comments_204214.json:
```json
{
    "body": "<a id='comment:4'></a>\nWhat do you think about the name `biseq_start_of_overlap`, and switching back to the old r\u00f4le of the arguments (i.e., we search for the smallest possible start index of a terminal segment of S1 that coincides with an initial segment of S2)?",
    "created_at": "2014-12-04T23:50:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204214",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
What do you think about the name `biseq_start_of_overlap`, and switching back to the old rôle of the arguments (i.e., we search for the smallest possible start index of a terminal segment of S1 that coincides with an initial segment of S2)?



---

archive/issue_comments_204215.json:
```json
{
    "body": "**Changing branch** from \"[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)\" to \"[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)\".",
    "created_at": "2014-12-05T00:00:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204215",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing branch** from "[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)" to "[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)".



---

archive/issue_comments_204216.json:
```json
{
    "body": "**Changing commit** from \"[8db9f6542a54ead67c1df3d069103b620e85eea6](https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6)\" to \"[63d2693eb4915632e3cb806730a4eb56dc26008e](https://github.com/sagemath/sagetrac-mirror/commit/63d2693eb4915632e3cb806730a4eb56dc26008e)\".",
    "created_at": "2014-12-05T06:46:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204216",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing commit** from "[8db9f6542a54ead67c1df3d069103b620e85eea6](https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6)" to "[63d2693eb4915632e3cb806730a4eb56dc26008e](https://github.com/sagemath/sagetrac-mirror/commit/63d2693eb4915632e3cb806730a4eb56dc26008e)".



---

archive/issue_comments_204217.json:
```json
{
    "body": "<a id='comment:6'></a>\nFor the record: With `git trac push 15820`, only the branch of this ticket was changed, but *not* the sha1. Hence, I have to change it manually.",
    "created_at": "2014-12-05T06:46:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204217",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
For the record: With `git trac push 15820`, only the branch of this ticket was changed, but *not* the sha1. Hence, I have to change it manually.



---

archive/issue_comments_204218.json:
```json
{
    "body": "<a id='comment:7'></a>\nBy the way: Note that I've formulated error messages such as `ValueError: BoundedIntegerSequence.index(x): x(=32) not in sequence` by taking tuples as good example:\n\n```\nsage: (1,2,3).index(4)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-2-e2928ab3b336> in <module>()\n----> 1 (Integer(1),Integer(2),Integer(3)).index(Integer(4))\n\nValueError: tuple.index(x): x not in tuple\n```\nYour error message is more similar to what is done for lists:\n\n```\nsage: [1,2,3].index(4)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-1-e163a1d1b274> in <module>()\n----> 1 [Integer(1),Integer(2),Integer(3)].index(Integer(4))\n\nValueError: 4 is not in list\n```\nBut that's not more than a side-note. I accept your change.",
    "created_at": "2014-12-05T08:11:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204218",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
By the way: Note that I've formulated error messages such as `ValueError: BoundedIntegerSequence.index(x): x(=32) not in sequence` by taking tuples as good example:

```
sage: (1,2,3).index(4)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-2-e2928ab3b336> in <module>()
----> 1 (Integer(1),Integer(2),Integer(3)).index(Integer(4))

ValueError: tuple.index(x): x not in tuple
```
Your error message is more similar to what is done for lists:

```
sage: [1,2,3].index(4)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-1-e163a1d1b274> in <module>()
----> 1 [Integer(1),Integer(2),Integer(3)].index(Integer(4))

ValueError: 4 is not in list
```
But that's not more than a side-note. I accept your change.



---

archive/issue_comments_204219.json:
```json
{
    "body": "<a id='comment:358'></a>\nReplying to [SimonKing](#comment%3A351):\n> - You changed the location of the (old) function `bitset_fix`. Why?\n \nBecause I think the new location is better than the old one, it seemed out of place in the list of functions to generate limb patterns.\n\n> Won't that increase the likelihood of a merge conflict?\n\nWell, every change increases the likelihood of a merge conflict...\nBut I don't know of any other tickets changing bitset code, so it won't be that bad.",
    "created_at": "2014-12-05T09:12:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204219",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:358'></a>
Replying to [SimonKing](#comment%3A351):
> - You changed the location of the (old) function `bitset_fix`. Why?
 
Because I think the new location is better than the old one, it seemed out of place in the list of functions to generate limb patterns.

> Won't that increase the likelihood of a merge conflict?

Well, every change increases the likelihood of a merge conflict...
But I don't know of any other tickets changing bitset code, so it won't be that bad.



---

archive/issue_comments_204220.json:
```json
{
    "body": "<a id='comment:359'></a>\nReplying to [SimonKing](#comment%3A354):\n> What do you think about the name `biseq_start_of_overlap`, and switching back to the old r\u00f4le of the arguments (i.e., we search for the smallest possible start index of a terminal segment of S1 that coincides with an initial segment of S2)?\n\n\nWell, the thing that bothered me most about the old `biseq_max_overlap` function was the implicit start index of 1, which is unexpected (why 1?) and couldn't be changed (unlike `biseq_contains`).\n\nI changed the names and ordering of the arguments to make it more clear that `biseq_contains` and `biseq_reverse_contains` are in fact very similar: the first finds `i` such that `S1[i:]` starts with `S2`, the second finds `i` such that `S1` starts with `S2[i:]`.\n\nI'm certainly open for changes, I just would like the functions to be as intuitive as possible for people *not knowing about your application of quiver algebras*. For example, the word \"overlap\" doesn't mean anything to me when you talk just about sequences of integers.",
    "created_at": "2014-12-05T09:28:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204220",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:359'></a>
Replying to [SimonKing](#comment%3A354):
> What do you think about the name `biseq_start_of_overlap`, and switching back to the old rôle of the arguments (i.e., we search for the smallest possible start index of a terminal segment of S1 that coincides with an initial segment of S2)?


Well, the thing that bothered me most about the old `biseq_max_overlap` function was the implicit start index of 1, which is unexpected (why 1?) and couldn't be changed (unlike `biseq_contains`).

I changed the names and ordering of the arguments to make it more clear that `biseq_contains` and `biseq_reverse_contains` are in fact very similar: the first finds `i` such that `S1[i:]` starts with `S2`, the second finds `i` such that `S1` starts with `S2[i:]`.

I'm certainly open for changes, I just would like the functions to be as intuitive as possible for people *not knowing about your application of quiver algebras*. For example, the word "overlap" doesn't mean anything to me when you talk just about sequences of integers.



---

archive/issue_comments_204221.json:
```json
{
    "body": "**Changing branch** from \"[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)\" to \"[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)\".",
    "created_at": "2014-12-05T10:22:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204221",
    "user": "https://github.com/jdemeyer"
}
```

**Changing branch** from "[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)" to "[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)".



---

archive/issue_comments_204222.json:
```json
{
    "body": "<a id='comment:1'></a>\nApparently the trac pages are not available, because of an internal error. So, I'm trying to comment using the sage-dev script.\n\nYou wrote:\n\n I'm certainly open for changes, I just would like the functions to be as\n intuitive as possible for people ''not knowing about your application of\n quiver algebras''. For example, the word \"overlap\" doesn't mean anything\n to me when you talk just about sequences of integers.\n\nHere I disagree. If I have two lists A and B, then the statement \"A overlaps with B\" makes immediate sense to me. The only open question is whether \"A overlaps with B\" means that the overlap of the two lists is supposed to be at the end of A or at the end of B.",
    "created_at": "2014-12-05T11:44:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204222",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Apparently the trac pages are not available, because of an internal error. So, I'm trying to comment using the sage-dev script.

You wrote:

 I'm certainly open for changes, I just would like the functions to be as
 intuitive as possible for people ''not knowing about your application of
 quiver algebras''. For example, the word "overlap" doesn't mean anything
 to me when you talk just about sequences of integers.

Here I disagree. If I have two lists A and B, then the statement "A overlaps with B" makes immediate sense to me. The only open question is whether "A overlaps with B" means that the overlap of the two lists is supposed to be at the end of A or at the end of B.



---

archive/issue_comments_204223.json:
```json
{
    "body": "<a id='comment:2'></a>\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718\">0a03d71</a></td><td><code>More descriptive function name for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-12-05T12:51:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204223",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:2'></a>
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718">0a03d71</a></td><td><code>More descriptive function name for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_204224.json:
```json
{
    "body": "**Changing commit** from \"[63d2693eb4915632e3cb806730a4eb56dc26008e](https://github.com/sagemath/sagetrac-mirror/commit/63d2693eb4915632e3cb806730a4eb56dc26008e)\" to \"[0a03d71d9df26c42cf91dab3df51ca549c434718](https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718)\".",
    "created_at": "2014-12-05T12:51:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204224",
    "user": "https://github.com/jdemeyer"
}
```

**Changing commit** from "[63d2693eb4915632e3cb806730a4eb56dc26008e](https://github.com/sagemath/sagetrac-mirror/commit/63d2693eb4915632e3cb806730a4eb56dc26008e)" to "[0a03d71d9df26c42cf91dab3df51ca549c434718](https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718)".



---

archive/issue_comments_204225.json:
```json
{
    "body": "<a id='comment:3'></a>\nTo reduce unneeded merges, I have cherry-picked your commit on top of my branch.",
    "created_at": "2014-12-05T12:52:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204225",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'></a>
To reduce unneeded merges, I have cherry-picked your commit on top of my branch.



---

archive/issue_comments_204226.json:
```json
{
    "body": "<a id='comment:364'></a>\nReplying to [SimonKing](#comment%3A354):\n> What do you think about switching back to the old r\u00f4le of the arguments\n\nI think it's a bad idea.\n\nLook at the following (now removed) code from you:\n\n```\nif other.startswith(self):\n    return self\ncdef mp_size_t i = biseq_max_overlap(self.data, other.data)\n```\nNote that the case `i == 0` of `biseq_max_overlap(B, A)` corresponds to `biseq_startswith(A, B)`. An unexpected reordering in my opinion.\n\nIn my proposal, the three functions `biseq_startswith`, `biseq_contains` and `biseq_reverse_contains` (whatever the name) all check whether some part of `S1` starts with some part of `S2`. The only thing that changes is which parts of `S1` and `S2` are considered.",
    "created_at": "2014-12-05T13:00:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204226",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:364'></a>
Replying to [SimonKing](#comment%3A354):
> What do you think about switching back to the old rôle of the arguments

I think it's a bad idea.

Look at the following (now removed) code from you:

```
if other.startswith(self):
    return self
cdef mp_size_t i = biseq_max_overlap(self.data, other.data)
```
Note that the case `i == 0` of `biseq_max_overlap(B, A)` corresponds to `biseq_startswith(A, B)`. An unexpected reordering in my opinion.

In my proposal, the three functions `biseq_startswith`, `biseq_contains` and `biseq_reverse_contains` (whatever the name) all check whether some part of `S1` starts with some part of `S2`. The only thing that changes is which parts of `S1` and `S2` are considered.



---

archive/issue_comments_204227.json:
```json
{
    "body": "<a id='comment:5'></a>\nBetter proposal: rename `biseq_reverse_contains` as `biseq_startswith_tail`. I think that's clear: check whether a sequence starts with the tail part of a sequence.",
    "created_at": "2014-12-05T14:37:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204227",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>
Better proposal: rename `biseq_reverse_contains` as `biseq_startswith_tail`. I think that's clear: check whether a sequence starts with the tail part of a sequence.



---

archive/issue_comments_204228.json:
```json
{
    "body": "**Changing commit** from \"[0a03d71d9df26c42cf91dab3df51ca549c434718](https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718)\" to \"[1560ce8dff16ed1fceabcc5656312f718d874211](https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211)\".",
    "created_at": "2014-12-05T15:00:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204228",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[0a03d71d9df26c42cf91dab3df51ca549c434718](https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718)" to "[1560ce8dff16ed1fceabcc5656312f718d874211](https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211)".



---

archive/issue_comments_204229.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211\">1560ce8</a></td><td><code>Rename biseq_reverse_contains as biseq_startswith_tail</code></td></tr></table>\n",
    "created_at": "2014-12-05T15:00:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204229",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211">1560ce8</a></td><td><code>Rename biseq_reverse_contains as biseq_startswith_tail</code></td></tr></table>




---

archive/issue_comments_204230.json:
```json
{
    "body": "<a id='comment:7'></a>\nOK, I am fine with that change.",
    "created_at": "2014-12-05T15:28:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204230",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
OK, I am fine with that change.



---

archive/issue_comments_204231.json:
```json
{
    "body": "<a id='comment:8'></a>\nThanks for the support!\n\nFor me, this ticket is positive_review except for the interrupt stuff.",
    "created_at": "2014-12-05T16:09:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204231",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:8'></a>
Thanks for the support!

For me, this ticket is positive_review except for the interrupt stuff.



---

archive/issue_comments_204232.json:
```json
{
    "body": "<a id='comment:9'></a>\nSince yesterday evening, I tried for about 20 times to push my changes (implementing interrupt stuff). But it doesn't work. Any idea why?\n\nAs usual, the error message is not very helpful:\n\n```\n> git trac push 15820\nPushing to Trac #15820...\nGuessed remote branch: u/SimonKing/ticket/15820\nEnter passphrase for key '/home/king/.ssh/id_rsa': \nTraceback (most recent call last):                                                                               \n  File \"/home/king/bin/git-trac\", line 18, in <module>                                                           \n    cmdline.launch()                                                                                             \n  File \"/home/king/Sage/git/git-trac-command/git_trac/cmdline.py\", line 210, in launch                           \n    app.push(ticket_number, remote=args.remote, force=args.force)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/app.py\", line 194, in push\n    self.repo.push(remote, force)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/git_repository.py\", line 181, in push\n    self.git.echo.push('trac', refspec)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/git_interface.py\", line 341, in meth\n    return self.execute(git_cmd, *args, **kwds)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/git_interface.py\", line 98, in execute\n    popen_stderr=subprocess.PIPE)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/git_interface.py\", line 263, in _run\n    raise GitError(result)\ngit_trac.git_error.GitError\n```\nIs that a problem on my side, or on trac?\n\nAnyway, the diff would be\n\n```diff\ndiff --git a/src/sage/data_structures/bounded_integer_sequences.pyx b/src/sage/data_structures/bounded_integer_sequences.pyx\nindex 7f5e632..ccda54c 100644\n--- a/src/sage/data_structures/bounded_integer_sequences.pyx\n+++ b/src/sage/data_structures/bounded_integer_sequences.pyx\n@@ -124,7 +124,9 @@ cdef bint biseq_init(biseq_t R, mp_size_t l, mp_bitcnt_t itemsize) except -1:\n         totalbitsize = l * itemsize\n     else:\n         totalbitsize = 1\n+    sig_on()\n     bitset_init(R.data, totalbitsize)\n+    sig_off()\n     R.length = l\n     R.itembitsize = itemsize\n     R.mask_item = limb_lower_bits_up(itemsize)\n@@ -140,7 +142,9 @@ cdef bint biseq_init_copy(biseq_t R, biseq_t S) except -1:\n     Initialize ``R`` as a copy of ``S``.\n     \"\"\"\n     biseq_init(R, S.length, S.itembitsize)\n+    sig_on()\n     bitset_copy(R.data, S.data)\n+    sig_off()\n \n #\n # Conversion\n@@ -162,6 +166,7 @@ cdef bint biseq_init_list(biseq_t R, list data, size_t bound) except -1:\n \n     biseq_init(R, len(data), BIT_COUNT(bound|<size_t>1))\n \n+    sig_check()\n     for item in data:\n         item_c = item\n         if item_c > bound:\n@@ -187,8 +192,10 @@ cdef bint biseq_init_concat(biseq_t R, biseq_t S1, biseq_t S2) except -1:\n     The result is written into ``R``, which must not be initialised\n     \"\"\"\n     biseq_init(R, S1.length + S2.length, S1.itembitsize)\n+    sig_on()\n     bitset_lshift(R.data, S2.data, S1.length * S1.itembitsize)\n     bitset_or(R.data, R.data, S1.data)\n+    sig_off()\n \n \n cdef inline bint biseq_startswith(biseq_t S1, biseq_t S2) except -1:\n@@ -207,6 +214,7 @@ cdef inline bint biseq_startswith(biseq_t S1, biseq_t S2) except -1:\n         return False\n     if S2.length == 0:\n         return True\n+    sig_check()\n     return mpn_equal_bits(S1.data.bits, S2.data.bits, S2.data.size)\n \n \n@@ -304,7 +312,9 @@ cdef bint biseq_init_slice(biseq_t R, biseq_t S, mp_size_t start, mp_size_t stop\n \n     if step == 1:\n         # Slicing essentially boils down to a shift operation.\n+        sig_on()\n         bitset_rshift(R.data, S.data, start*S.itembitsize)\n+        sig_off()\n         return 0\n \n     # In the general case, we move item by item.\n@@ -340,6 +350,7 @@ cdef mp_size_t biseq_contains(biseq_t S1, biseq_t S2, mp_size_t start) except -2\n     if S2.length == 0:\n         return start\n     cdef mp_size_t index\n+    sig_check()\n     for index from start <= index <= S1.length-S2.length:\n         if mpn_equal_bits_shifted(S2.data.bits, S1.data.bits,\n                 S2.length*S2.itembitsize, index*S2.itembitsize):\n@@ -373,6 +384,7 @@ cdef mp_size_t biseq_startswith_tail(biseq_t S1, biseq_t S2, mp_size_t start) ex\n     if S1.length < S2.length - start:\n         start = S2.length - S1.length\n     cdef mp_size_t index\n+    sig_check()\n     for index from start <= index < S2.length:\n         if mpn_equal_bits_shifted(S1.data.bits, S2.data.bits,\n                 (S2.length - index)*S2.itembitsize, index*S2.itembitsize):\n@@ -1335,7 +1347,9 @@ cpdef BoundedIntegerSequence NewBISEQ(tuple bitset_data, mp_bitcnt_t itembitsize\n     cdef BoundedIntegerSequence out = BoundedIntegerSequence.__new__(BoundedIntegerSequence)\n     # bitset_unpickle assumes that out.data.data is initialised.\n     biseq_init(out.data, length, itembitsize)\n+    sig_on()\n     bitset_unpickle(out.data.data, bitset_data)\n+    sig_off()\n     return out\n \n def _biseq_stresstest():\n```",
    "created_at": "2014-12-06T08:55:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204232",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Since yesterday evening, I tried for about 20 times to push my changes (implementing interrupt stuff). But it doesn't work. Any idea why?

As usual, the error message is not very helpful:

```
> git trac push 15820
Pushing to Trac #15820...
Guessed remote branch: u/SimonKing/ticket/15820
Enter passphrase for key '/home/king/.ssh/id_rsa': 
Traceback (most recent call last):                                                                               
  File "/home/king/bin/git-trac", line 18, in <module>                                                           
    cmdline.launch()                                                                                             
  File "/home/king/Sage/git/git-trac-command/git_trac/cmdline.py", line 210, in launch                           
    app.push(ticket_number, remote=args.remote, force=args.force)
  File "/home/king/Sage/git/git-trac-command/git_trac/app.py", line 194, in push
    self.repo.push(remote, force)
  File "/home/king/Sage/git/git-trac-command/git_trac/git_repository.py", line 181, in push
    self.git.echo.push('trac', refspec)
  File "/home/king/Sage/git/git-trac-command/git_trac/git_interface.py", line 341, in meth
    return self.execute(git_cmd, *args, **kwds)
  File "/home/king/Sage/git/git-trac-command/git_trac/git_interface.py", line 98, in execute
    popen_stderr=subprocess.PIPE)
  File "/home/king/Sage/git/git-trac-command/git_trac/git_interface.py", line 263, in _run
    raise GitError(result)
git_trac.git_error.GitError
```
Is that a problem on my side, or on trac?

Anyway, the diff would be

```diff
diff --git a/src/sage/data_structures/bounded_integer_sequences.pyx b/src/sage/data_structures/bounded_integer_sequences.pyx
index 7f5e632..ccda54c 100644
--- a/src/sage/data_structures/bounded_integer_sequences.pyx
+++ b/src/sage/data_structures/bounded_integer_sequences.pyx
@@ -124,7 +124,9 @@ cdef bint biseq_init(biseq_t R, mp_size_t l, mp_bitcnt_t itemsize) except -1:
         totalbitsize = l * itemsize
     else:
         totalbitsize = 1
+    sig_on()
     bitset_init(R.data, totalbitsize)
+    sig_off()
     R.length = l
     R.itembitsize = itemsize
     R.mask_item = limb_lower_bits_up(itemsize)
@@ -140,7 +142,9 @@ cdef bint biseq_init_copy(biseq_t R, biseq_t S) except -1:
     Initialize ``R`` as a copy of ``S``.
     """
     biseq_init(R, S.length, S.itembitsize)
+    sig_on()
     bitset_copy(R.data, S.data)
+    sig_off()
 
 #
 # Conversion
@@ -162,6 +166,7 @@ cdef bint biseq_init_list(biseq_t R, list data, size_t bound) except -1:
 
     biseq_init(R, len(data), BIT_COUNT(bound|<size_t>1))
 
+    sig_check()
     for item in data:
         item_c = item
         if item_c > bound:
@@ -187,8 +192,10 @@ cdef bint biseq_init_concat(biseq_t R, biseq_t S1, biseq_t S2) except -1:
     The result is written into ``R``, which must not be initialised
     """
     biseq_init(R, S1.length + S2.length, S1.itembitsize)
+    sig_on()
     bitset_lshift(R.data, S2.data, S1.length * S1.itembitsize)
     bitset_or(R.data, R.data, S1.data)
+    sig_off()
 
 
 cdef inline bint biseq_startswith(biseq_t S1, biseq_t S2) except -1:
@@ -207,6 +214,7 @@ cdef inline bint biseq_startswith(biseq_t S1, biseq_t S2) except -1:
         return False
     if S2.length == 0:
         return True
+    sig_check()
     return mpn_equal_bits(S1.data.bits, S2.data.bits, S2.data.size)
 
 
@@ -304,7 +312,9 @@ cdef bint biseq_init_slice(biseq_t R, biseq_t S, mp_size_t start, mp_size_t stop
 
     if step == 1:
         # Slicing essentially boils down to a shift operation.
+        sig_on()
         bitset_rshift(R.data, S.data, start*S.itembitsize)
+        sig_off()
         return 0
 
     # In the general case, we move item by item.
@@ -340,6 +350,7 @@ cdef mp_size_t biseq_contains(biseq_t S1, biseq_t S2, mp_size_t start) except -2
     if S2.length == 0:
         return start
     cdef mp_size_t index
+    sig_check()
     for index from start <= index <= S1.length-S2.length:
         if mpn_equal_bits_shifted(S2.data.bits, S1.data.bits,
                 S2.length*S2.itembitsize, index*S2.itembitsize):
@@ -373,6 +384,7 @@ cdef mp_size_t biseq_startswith_tail(biseq_t S1, biseq_t S2, mp_size_t start) ex
     if S1.length < S2.length - start:
         start = S2.length - S1.length
     cdef mp_size_t index
+    sig_check()
     for index from start <= index < S2.length:
         if mpn_equal_bits_shifted(S1.data.bits, S2.data.bits,
                 (S2.length - index)*S2.itembitsize, index*S2.itembitsize):
@@ -1335,7 +1347,9 @@ cpdef BoundedIntegerSequence NewBISEQ(tuple bitset_data, mp_bitcnt_t itembitsize
     cdef BoundedIntegerSequence out = BoundedIntegerSequence.__new__(BoundedIntegerSequence)
     # bitset_unpickle assumes that out.data.data is initialised.
     biseq_init(out.data, length, itembitsize)
+    sig_on()
     bitset_unpickle(out.data.data, bitset_data)
+    sig_off()
     return out
 
 def _biseq_stresstest():
```



---

archive/issue_comments_204233.json:
```json
{
    "body": "<a id='comment:0'></a>\nI can't help with git...",
    "created_at": "2014-12-06T09:58:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204233",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:0'></a>
I can't help with git...



---

archive/issue_comments_204234.json:
```json
{
    "body": "<a id='comment:1'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184\">4e9e1c5</a></td><td><code>Add interrupt handling to bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-12-06T11:54:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204234",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:1'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184">4e9e1c5</a></td><td><code>Add interrupt handling to bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_204235.json:
```json
{
    "body": "**Changing commit** from \"[1560ce8dff16ed1fceabcc5656312f718d874211](https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211)\" to \"[4e9e1c51f6524bfa2d2c55d197b82a983dd01184](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)\".",
    "created_at": "2014-12-06T11:54:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204235",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1560ce8dff16ed1fceabcc5656312f718d874211](https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211)" to "[4e9e1c51f6524bfa2d2c55d197b82a983dd01184](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)".



---

archive/issue_events_143633.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-12-06T11:54:56Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143633"
}
```



---

archive/issue_events_143634.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-12-06T11:54:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143634"
}
```



---

archive/issue_comments_204236.json:
```json
{
    "body": "**Changing work_issues** from \"interrupt handling\" to \"\".",
    "created_at": "2014-12-06T11:54:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204236",
    "user": "https://github.com/jdemeyer"
}
```

**Changing work_issues** from "interrupt handling" to "".



---

archive/issue_comments_204237.json:
```json
{
    "body": "<a id='comment:3'></a>\nQuestions:\n\n- Is the stresstest really running forever?? It is supposed to take few seconds. I will test in a few minutes.\n- When should one use `sig_check()` and when `sig_on()/sig_off()`? I thought it is `sig_check()` when it could happen that an error or a return may happen that is not caused by a keyboard interrupt. But perhaps I am mistaken.",
    "created_at": "2014-12-06T12:25:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204237",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Questions:

- Is the stresstest really running forever?? It is supposed to take few seconds. I will test in a few minutes.
- When should one use `sig_check()` and when `sig_on()/sig_off()`? I thought it is `sig_check()` when it could happen that an error or a return may happen that is not caused by a keyboard interrupt. But perhaps I am mistaken.



---

archive/issue_comments_204238.json:
```json
{
    "body": "<a id='comment:4'></a>\nAha, I see! You really changed the stress test so that it *would* run forever, but test that it can be interrupted. Good idea!",
    "created_at": "2014-12-06T12:27:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204238",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
Aha, I see! You really changed the stress test so that it *would* run forever, but test that it can be interrupted. Good idea!



---

archive/issue_comments_204239.json:
```json
{
    "body": "<a id='comment:375'></a>\nReplying to [SimonKing](#comment%3A374):\n> Aha, I see! You really changed the stress test so that it *would* run forever, but test that it can be interrupted. Good idea!\n\n\nUnfortunately it does NOT test that bounded integer sequence operations are interruptible. I tested a couple of times, and the exception always occurs in the randint function.",
    "created_at": "2014-12-06T12:29:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204239",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:375'></a>
Replying to [SimonKing](#comment%3A374):
> Aha, I see! You really changed the stress test so that it *would* run forever, but test that it can be interrupted. Good idea!


Unfortunately it does NOT test that bounded integer sequence operations are interruptible. I tested a couple of times, and the exception always occurs in the randint function.



---

archive/issue_comments_204240.json:
```json
{
    "body": "<a id='comment:6'></a>\nShould we address the interrupt test in a different way? If not, I think it is a positive review from my side. But I'd appreciate if you could answer my question on sig_on/sig_off vs. sig_check.",
    "created_at": "2014-12-06T12:31:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204240",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
Should we address the interrupt test in a different way? If not, I think it is a positive review from my side. But I'd appreciate if you could answer my question on sig_on/sig_off vs. sig_check.



---

archive/issue_comments_204241.json:
```json
{
    "body": "<a id='comment:377'></a>\nReplying to [SimonKing](#comment%3A375):\n> Unfortunately it does NOT test that bounded integer sequence operations are interruptible. I tested a couple of times, and the exception always occurs in the randint function.\n\nI also tested a bit more and the exception indeed happens most often in `randint()` but also sometimes in other places.",
    "created_at": "2014-12-06T12:52:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204241",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:377'></a>
Replying to [SimonKing](#comment%3A375):
> Unfortunately it does NOT test that bounded integer sequence operations are interruptible. I tested a couple of times, and the exception always occurs in the randint function.

I also tested a bit more and the exception indeed happens most often in `randint()` but also sometimes in other places.



---

archive/issue_comments_204242.json:
```json
{
    "body": "<a id='comment:378'></a>\nReplying to [SimonKing](#comment%3A373):\n> - When should one use `sig_check()` and when `sig_on()/sig_off()`?\n \nDoes [http://www.sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling](http://www.sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling) answer your question?",
    "created_at": "2014-12-06T12:54:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204242",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:378'></a>
Replying to [SimonKing](#comment%3A373):
> - When should one use `sig_check()` and when `sig_on()/sig_off()`?
 
Does [http://www.sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling](http://www.sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling) answer your question?



---

archive/issue_comments_204243.json:
```json
{
    "body": "<a id='comment:9'></a>\nShould we add tests in the spirit of this:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(4,[1,2,3,2,3,2,3])\nsage: while 1:\n....:     C = B+B\n....:     \n^C---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\n<ipython-input-3-dda173c83bbe> in <module>()\n----> 1 while Integer(1):\n      2     C = B+B\n      3 \n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sage_python_check_interrupt (build/cythonized/sage/ext/c_lib.c:1683)()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sig_raise_exception (build/cythonized/sage/ext/c_lib.c:769)()\n\nKeyboardInterrupt: \nsage: while 1:\n    C = B+B\n....:     \n^C---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\n<ipython-input-4-dda173c83bbe> in <module>()\n      1 while Integer(1):\n----> 2     C = B+B\n      3 \n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.BoundedIntegerSequence.__add__ (build/cythonized/sage/data_structures/bounded_integer_sequences.c:10964)()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.biseq_init_concat (build/cythonized/sage/data_structures/bounded_integer_sequences.c:7632)()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sig_raise_exception (build/cythonized/sage/ext/c_lib.c:769)()\n\nKeyboardInterrupt: \n```\nAs you can see, the interruption occurs in the correct place already in the second try.",
    "created_at": "2014-12-06T12:55:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204243",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Should we add tests in the spirit of this:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(4,[1,2,3,2,3,2,3])
sage: while 1:
....:     C = B+B
....:     
^C---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
<ipython-input-3-dda173c83bbe> in <module>()
----> 1 while Integer(1):
      2     C = B+B
      3 

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sage_python_check_interrupt (build/cythonized/sage/ext/c_lib.c:1683)()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sig_raise_exception (build/cythonized/sage/ext/c_lib.c:769)()

KeyboardInterrupt: 
sage: while 1:
    C = B+B
....:     
^C---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
<ipython-input-4-dda173c83bbe> in <module>()
      1 while Integer(1):
----> 2     C = B+B
      3 

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.BoundedIntegerSequence.__add__ (build/cythonized/sage/data_structures/bounded_integer_sequences.c:10964)()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.biseq_init_concat (build/cythonized/sage/data_structures/bounded_integer_sequences.c:7632)()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sig_raise_exception (build/cythonized/sage/ext/c_lib.c:769)()

KeyboardInterrupt: 
```
As you can see, the interruption occurs in the correct place already in the second try.



---

archive/issue_comments_204244.json:
```json
{
    "body": "<a id='comment:380'></a>\nReplying to [SimonKing](#comment%3A379):\n> Should we add tests in the spirit of this:\n\nWe could, but I'm not sure it is worth the trouble.",
    "created_at": "2014-12-06T13:10:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204244",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:380'></a>
Replying to [SimonKing](#comment%3A379):
> Should we add tests in the spirit of this:

We could, but I'm not sure it is worth the trouble.



---

archive/issue_events_143635.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-12-06T13:26:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143635"
}
```



---

archive/issue_events_143636.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-12-06T13:26:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143636"
}
```



---

archive/issue_comments_204245.json:
```json
{
    "body": "<a id='comment:381'></a>\nReplying to [jdemeyer](#comment%3A380):\n> Replying to [SimonKing](#comment%3A379):\n> > Should we add tests in the spirit of this:\n\n> We could, but I'm not sure it is worth the trouble.\n\nThen I guess I can set this to positive review, right?",
    "created_at": "2014-12-06T13:26:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204245",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:381'></a>
Replying to [jdemeyer](#comment%3A380):
> Replying to [SimonKing](#comment%3A379):
> > Should we add tests in the spirit of this:

> We could, but I'm not sure it is worth the trouble.

Then I guess I can set this to positive review, right?



---

archive/issue_comments_204246.json:
```json
{
    "body": "**Changing branch** from \"[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)\" to \"[4e9e1c51f6524bfa2d2c55d197b82a983dd01184](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)\".",
    "created_at": "2014-12-12T12:29:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204246",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)" to "[4e9e1c51f6524bfa2d2c55d197b82a983dd01184](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)".



---

archive/issue_events_143637.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-12-12T12:29:50Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143637"
}
```



---

archive/issue_events_143638.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-12-12T12:29:50Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15820#event-143638"
}
```



---

archive/issue_comments_204247.json:
```json
{
    "body": "<a id='comment:3'></a>\nI just saw this ticket on the trac timeline, i wonder whether two similar objects are being developed in parallel by disjoint sets of people, see #17013.",
    "created_at": "2014-12-13T17:07:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204247",
    "user": "https://trac.sagemath.org/admin/accounts/users/tmonteil"
}
```

<a id='comment:3'></a>
I just saw this ticket on the trac timeline, i wonder whether two similar objects are being developed in parallel by disjoint sets of people, see #17013.



---

archive/issue_comments_204248.json:
```json
{
    "body": "**Changing commit** from \"[4e9e1c51f6524bfa2d2c55d197b82a983dd01184](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)\" to \"\".",
    "created_at": "2014-12-13T17:07:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204248",
    "user": "https://trac.sagemath.org/admin/accounts/users/tmonteil"
}
```

**Changing commit** from "[4e9e1c51f6524bfa2d2c55d197b82a983dd01184](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)" to "".



---

archive/issue_comments_204249.json:
```json
{
    "body": "<a id='comment:384'></a>\nReplying to [tmonteil](#comment%3A383):\n> I just saw this ticket on the trac timeline, i wonder whether two similar objects are being developed in parallel by disjoint sets of people, see #17013.\n\n\nIndeed there is an obvious overlap. If I understand correctly, #17013 uses `char *` as underlying data structure, which means they are restricted to an alphabet of length at most 255. I have experimented with a similar implementation, too, but found that an implementation based on gmp gives better speed than what I was able to obtain with `char*`.",
    "created_at": "2014-12-13T23:21:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15820#issuecomment-204249",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:384'></a>
Replying to [tmonteil](#comment%3A383):
> I just saw this ticket on the trac timeline, i wonder whether two similar objects are being developed in parallel by disjoint sets of people, see #17013.


Indeed there is an obvious overlap. If I understand correctly, #17013 uses `char *` as underlying data structure, which means they are restricted to an alphabet of length at most 255. I have experimented with a similar implementation, too, but found that an implementation based on gmp gives better speed than what I was able to obtain with `char*`.
