# Issue 15820: Implement sequences of bounded integers

archive/issues_015583.json:
```json
{
    "assignees": [],
    "body": "#12630 has introduced tools to compute with quiver algebras and quiver representations. It is all Python code, paths being internally stored by lists of labelled edges of digraphs.\n\nThe aim of this ticket is to provide an efficient implementation of lists of bounded integers, with concatenation. This can be used to implement paths of a quiver more efficiently, but can also have different applications (say, elements of free groups, or other applications in sage-combinat).\n\n\nDepends on #17195\nDepends on #17196\n\nCC:  @sagetrac-JStarx @jhpalmieri @williamstein @stumpc5 @saliola @simon-king-jena @sagetrac-gmoose05 @nthiery @avirmaux @nathanncohen @hivert\n\nKeywords: **sequence bounded integer**\n\nBranch: **[`4e9e1c5`](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)**\n\nReviewer: **Jeroen Demeyer, Simon King**\n\nAuthor: **Simon King, Jeroen Demeyer**\n\nComponent: **algebra**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/15820_\n\n",
    "closed_at": "2014-12-12T12:29:50Z",
    "created_at": "2014-02-14T17:31:31Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20algebra",
        "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.4",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Implement sequences of bounded integers",
    "type": "issue",
    "updated_at": "2014-12-13T23:21:52Z",
    "url": "https://github.com/sagemath/sage/issues/15820",
    "user": "https://github.com/simon-king-jena"
}
```
#12630 has introduced tools to compute with quiver algebras and quiver representations. It is all Python code, paths being internally stored by lists of labelled edges of digraphs.

The aim of this ticket is to provide an efficient implementation of lists of bounded integers, with concatenation. This can be used to implement paths of a quiver more efficiently, but can also have different applications (say, elements of free groups, or other applications in sage-combinat).


Depends on #17195
Depends on #17196

CC:  @sagetrac-JStarx @jhpalmieri @williamstein @stumpc5 @saliola @simon-king-jena @sagetrac-gmoose05 @nthiery @avirmaux @nathanncohen @hivert

Keywords: **sequence bounded integer**

Branch: **[`4e9e1c5`](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)**

Reviewer: **Jeroen Demeyer, Simon King**

Author: **Simon King, Jeroen Demeyer**

Component: **algebra**

_Issue created by migration from https://trac.sagemath.org/ticket/15820_





---

archive/issue_events_225889.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-02-14T17:31:31Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "milestone_number": null,
    "milestone_title": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225889"
}
```



---

archive/issue_events_225890.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-02-14T17:31:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20algebra",
    "label_color": "0000ff",
    "label_name": "c: algebra",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225890"
}
```



---

archive/issue_events_225891.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-02-14T17:31:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p: 3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225891"
}
```



---

archive/issue_events_225892.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-02-14T17:31:31Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225892"
}
```



---

archive/issue_comments_199816.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nThere are various possible more or less obvious data formats:\n\n1. Store a path as `char*` or `unsigned int*`, hence, as a list of integers, each integer corresponding to one edge of the quiver. `char*` would bound the total number of edges of the quiver to 256 (which might be too small), whereas `unsigned int*` might consume to much memory.\n2. Store a path as `char*`, each integer corresponding to an outgoing edge of a vertex. Hence, the total number of edges may be arbitrary, we only have a local bound of 128 on the number of outgoing edges---this hopefully is enough (it certainly is enough for me).\n3. As in 1., but the representation is compressed: If we have less than 128 edges, then one byte can represent a pair of edges, and a single 32- or 64-bit int could store even longer sequences of edges.\n4. As in 2., but the representation is compressed: If each vertex has less than 8 outgoing edges, then a byte can represent a pair and a single 32-bit word can represent a 10-tuple of edges (if I did not miscalculate).\n\nIn 2. and 4. (and probably in 1. and 3. as well) we should explicitly store the start and end point of the path. The length should probably be stored as well.\n\nIn my applications, the following operations on paths are needed to be fast: Concatenation, hash/comparison, testing whether a path p starts with a path q, and less important whether a path p contains a path q.\n\nConcatenation is particularly easy in 1. and 2. (just concatenation of lists, which is achieved by memcopy). It is a bit more difficult in 3. and 4., where the bytes of the second factor need to be shifted to get the compressed data seamless.\n\nHash and comparison are easy in all four formats, but of course best speed would be obtained in 4., simply since the amount of data that needs to be processed is smaller than in 1.-3.\n\nIn all four proposed data formats, it is easy to test whether path p starts with path q. Again, having the data stored in as little memory as possible will speed things up.\n\nIt is easy in 1. to test whether path p *contains* path q (as a subpath that is not necessarily an initial segment), whereas this becomes a bit more difficult in 2.-4.\n\nWhat format would you suggest? Perhaps it makes sense to have some initial implementations of all four, and then compare directly.",
    "created_at": "2014-02-14T17:49:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199816",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

There are various possible more or less obvious data formats:

1. Store a path as `char*` or `unsigned int*`, hence, as a list of integers, each integer corresponding to one edge of the quiver. `char*` would bound the total number of edges of the quiver to 256 (which might be too small), whereas `unsigned int*` might consume to much memory.
2. Store a path as `char*`, each integer corresponding to an outgoing edge of a vertex. Hence, the total number of edges may be arbitrary, we only have a local bound of 128 on the number of outgoing edges---this hopefully is enough (it certainly is enough for me).
3. As in 1., but the representation is compressed: If we have less than 128 edges, then one byte can represent a pair of edges, and a single 32- or 64-bit int could store even longer sequences of edges.
4. As in 2., but the representation is compressed: If each vertex has less than 8 outgoing edges, then a byte can represent a pair and a single 32-bit word can represent a 10-tuple of edges (if I did not miscalculate).

In 2. and 4. (and probably in 1. and 3. as well) we should explicitly store the start and end point of the path. The length should probably be stored as well.

In my applications, the following operations on paths are needed to be fast: Concatenation, hash/comparison, testing whether a path p starts with a path q, and less important whether a path p contains a path q.

Concatenation is particularly easy in 1. and 2. (just concatenation of lists, which is achieved by memcopy). It is a bit more difficult in 3. and 4., where the bytes of the second factor need to be shifted to get the compressed data seamless.

Hash and comparison are easy in all four formats, but of course best speed would be obtained in 4., simply since the amount of data that needs to be processed is smaller than in 1.-3.

In all four proposed data formats, it is easy to test whether path p starts with path q. Again, having the data stored in as little memory as possible will speed things up.

It is easy in 1. to test whether path p *contains* path q (as a subpath that is not necessarily an initial segment), whereas this becomes a bit more difficult in 2.-4.

What format would you suggest? Perhaps it makes sense to have some initial implementations of all four, and then compare directly.



---

archive/issue_comments_199817.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nI'd say:\n- Some implementation without limitations (the one from the previous ticket I guess)\n- Whichever of 1-4 that covers your needs (256 edges for Gr\u00f6bner bases\n  calculations this should be already quite big, right?)\n- As much as possible of the code shared between all implementations to make it easy to add new ones if deemed useful.\n\nBut that's just my 2 cents ... I don't have specific experience!\n\nCheers,",
    "created_at": "2014-02-16T08:47:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199817",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:2" align="right">comment:2</div>

I'd say:
- Some implementation without limitations (the one from the previous ticket I guess)
- Whichever of 1-4 that covers your needs (256 edges for Gröbner bases
  calculations this should be already quite big, right?)
- As much as possible of the code shared between all implementations to make it easy to add new ones if deemed useful.

But that's just my 2 cents ... I don't have specific experience!

Cheers,



---

archive/issue_comments_199818.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nHi Nicolas,\n\nReplying to [@nthiery](#comment:2):\n> - Some implementation without limitations (the one from the previous ticket I guess)\n\nAn implementation which represents edges by `unsigned long long` can be considered \"unlimited\".\n\n> - Whichever of 1-4 that covers your needs (256 edges for Gr\u00f6bner bases\n>   calculations this should be already quite big, right?)\n\nYes, but I want a general code.\n\n> - As much as possible of the code shared between all implementations to make it easy to add new ones if deemed useful.\n\nActually, on the level of paths, the implementations come in pairs: The compressed representations differ from the non-compressed---at the end of the day, we just have different ways of representing sequences of integers. Only when it comes to interpreting a sequence of integers as a path in a quiver will we have further differences: Does \"[1,2]\" mean \"start with arrow 1 of the quiver and continue with arrow 2 of the quiver\", or does it mean \"travel along the outgoing arrow 1 of the vertex we are currently located at, and then continue with outgoing arrow 2 of the vertex we just arrived at\".\n\nCurrently, I prefer a compressed representation by `unsigned long long*`. Rationale:\n- This will work even for extremely large quivers---the only restriction is, that the number of edges can be represented as an `unsigned long long` (a larger quiver won't fit into computer's memory anyway).\n- For small quivers, even paths of length 10 will easily fit into a single `unsigned long long`. That's quite efficient, both memory- and speed-wise.\n\nA bit later I will post experimental code (not yet talking about quiver paths but about sequences of integers) giving some evidence on efficiency. And then we can still see how we interpret the integer sequences: Having a global or a local list of arrows?",
    "created_at": "2014-02-16T09:05:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199818",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Hi Nicolas,

Replying to [@nthiery](#comment:2):
> - Some implementation without limitations (the one from the previous ticket I guess)

An implementation which represents edges by `unsigned long long` can be considered "unlimited".

> - Whichever of 1-4 that covers your needs (256 edges for Gröbner bases
>   calculations this should be already quite big, right?)

Yes, but I want a general code.

> - As much as possible of the code shared between all implementations to make it easy to add new ones if deemed useful.

Actually, on the level of paths, the implementations come in pairs: The compressed representations differ from the non-compressed---at the end of the day, we just have different ways of representing sequences of integers. Only when it comes to interpreting a sequence of integers as a path in a quiver will we have further differences: Does "[1,2]" mean "start with arrow 1 of the quiver and continue with arrow 2 of the quiver", or does it mean "travel along the outgoing arrow 1 of the vertex we are currently located at, and then continue with outgoing arrow 2 of the vertex we just arrived at".

Currently, I prefer a compressed representation by `unsigned long long*`. Rationale:
- This will work even for extremely large quivers---the only restriction is, that the number of edges can be represented as an `unsigned long long` (a larger quiver won't fit into computer's memory anyway).
- For small quivers, even paths of length 10 will easily fit into a single `unsigned long long`. That's quite efficient, both memory- and speed-wise.

A bit later I will post experimental code (not yet talking about quiver paths but about sequences of integers) giving some evidence on efficiency. And then we can still see how we interpret the integer sequences: Having a global or a local list of arrows?



---

archive/issue_comments_199819.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nI have attached a toy (or proof-of-concept) implementation; see [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz). In a *real* implementation in\ncompressed representation, it would be the job of a `PathSemigroup` to find\nout how many edges fit into one word. And of course, in the toy implementation\nI am not trying to translate an integer sequence into the string\nrepresentation of an element of the path semigroup.\n\nWhat implementation would you suggest to use in \"reality\"? Is there another implementation of \"sequences of bounded integers\" that you would recommend? And would you enumerate the arrows of a quiver locally (i.e., only number the outgoing edges at each vertex) or globally? The former will result in better compression, but would make it more difficult to test for paths p,q whether there are paths r,s with `p==r*q*s`.\n\nNow for the timings, and sorry for the long post...\n\nHere, I am timing concatenation, hash, comparison, comparing initial\nsegments. In all examples, we use the following paths of various sizes.\n\n```\np5 = Path(ZZ, 5, range(5), 1, 1)\np25 = Path(ZZ, 25, range(25), 1, 1)\np50 = Path(ZZ, 50, range(50), 1, 1)\np100 = Path(ZZ, 100, range(100), 1, 1)\np1000 = Path(ZZ, 1000, range(1000), 1, 1)\nq5 = Path(ZZ, 5, range(1,6), 1, 1)\nq25 = Path(ZZ, 25, range(1,26), 1, 1)\nq50 = Path(ZZ, 50, range(1,51), 1, 1)\nq100 = Path(ZZ, 100, range(1,101), 1, 1)\nq1000 = Path(ZZ, 1000, range(1,1001), 1, 1)\nr5 = Path(ZZ, 5, range(1,5)+[0], 1, 1)\nr25 = Path(ZZ, 25, range(1,25)+[0], 1, 1)\nr50 = Path(ZZ, 50, range(1,50)+[0], 1, 1)\nr100 = Path(ZZ, 100, range(1,100)+[0], 1, 1)\nr1000 = Path(ZZ, 1000, range(1,1000)+[0], 1, 1)\ns5 = Path(ZZ, 5, range(5), 1, 1)\ns25 = Path(ZZ, 25, range(25), 1, 1)\ns50 = Path(ZZ, 50, range(50), 1, 1)\ns100 = Path(ZZ, 100, range(100), 1, 1)\ns1000 = Path(ZZ, 1000, range(1000), 1, 1)\n```\n\nWe are doing the following tests.\n\nConcatenation:\n\n```\n%timeit p5*q5\n%timeit p5*q25\n%timeit p25*q25\n%timeit p25*q50\n%timeit p50*q50\n%timeit p50*q100\n%timeit p100*q100\n%timeit p100*q1000\n%timeit p1000*q1000\n```\n\nHash:\n\n```\n%timeit hash(p5)\n%timeit hash(p25)\n%timeit hash(p50)\n%timeit hash(p100)\n%timeit hash(p1000)\n```\n\nComparison:\n1. equal\n\n```\n%timeit p5==s5\n%timeit p25==s25\n%timeit p50==s50\n%timeit p100==s100\n%timeit p1000==s1000\n```\n2. obviously different (first item differs)\n\n```\n%timeit p5==r5\n%timeit p25==r25\n%timeit p50==r50\n%timeit p100==r100\n%timeit p1000==r1000\n```\n3. less obviously different (only the last item differs)\n\n```\n%timeit q5==r5\n%timeit q25==r25\n%timeit q50==r50\n%timeit q100==r100\n%timeit q1000==r1000\n```\n\nStartswith:\n\n```\n%timeit q1000.startswith(q100)  # it does start with\n%timeit q1000.startswith(r100)  # it doesn't start with\n```\n\n**__Uncompressed integer lists__**\n\nHere, we define `Path=Path_v1` (see [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz)).\n\n__Using `ctypedef unsigned long block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 739 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 769 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 801 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 810 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 885 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 959 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 1.02 us per loop\nsage: %timeit p100*q1000\n100000 loops, best of 3: 1.99 us per loop\nsage: %timeit p1000*q1000\n100000 loops, best of 3: 3.06 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 135 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 166 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 214 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 333 ns per loop\nsage: %timeit hash(p1000)\n100000 loops, best of 3: 2.09 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 1.63 us per loop\nsage: %timeit p25==s25\n100000 loops, best of 3: 5.91 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 11 us per loop\nsage: %timeit p100==s100\n10000 loops, best of 3: 23 us per loop\nsage: %timeit p1000==s1000\n1000 loops, best of 3: 212 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 634 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 659 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 659 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 686 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 698 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 1.65 us per loop\nsage: %timeit q25==r25\n100000 loops, best of 3: 5.83 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 11.5 us per loop\nsage: %timeit q100==r100\n10000 loops, best of 3: 22 us per loop\nsage: %timeit q1000==r1000\n1000 loops, best of 3: 213 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 325 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 311 ns per loop\n```\n\n__Using `ctypedef unsigned short block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 700 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 738 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 820 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 769 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 808 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 877 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 909 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.49 us per loop\nsage: %timeit p1000*q1000\n100000 loops, best of 3: 2.13 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 138 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 179 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 236 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 383 ns per loop\nsage: %timeit hash(p1000)\n100000 loops, best of 3: 2.61 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 1.08 us per loop\nsage: %timeit p25==s25\n100000 loops, best of 3: 3.42 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 6.53 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 14.9 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 137 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 613 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 591 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 602 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 603 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 635 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 1.15 us per loop\nsage: %timeit q25==r25\n100000 loops, best of 3: 3.63 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 6.45 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 12.8 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 140 us per loop\nsage: q1000.startswith(q100)\nTrue\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 336 ns per loop\nsage: q1000.startswith(r100)\nFalse\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 325 ns per loop\n```\n\n__Using `ctypedef unsigned char block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 679 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 693 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 725 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 760 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 772 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 761 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 790 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.1 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.31 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 133 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 176 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 234 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 374 ns per loop\nsage: %timeit hash(p1000)\n100000 loops, best of 3: 2.53 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 1.08 us per loop\nsage: %timeit p25==s25\n100000 loops, best of 3: 3.36 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 6.3 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 12.5 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 121 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 581 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 589 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 599 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 599 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 636 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 1.06 us per loop\nsage: %timeit q25==r25\n100000 loops, best of 3: 3.46 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 6.51 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 12.7 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 121 us per loop\nsage: q1000.startswith(q100)\nTrue\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 324 ns per loop\nsage: %timeit q1000.startswith(r100) \n1000000 loops, best of 3: 315 ns per loop\n```\n\n**__Compressed integer lists__**\n\nHere, we define `Path=Path_v2` (see [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz)), and do\n\n```\nsage: SizeManager.set_edge_number(27)\n```\nso that there is a total of only 27 edges (resp. 27 is the maximal number of\noutgoing arrows on a vertex). In particular, all integers in the sequences\nbelow are taken \"mod 27\". Since 27 has length 5 bits, a compressed\nrepresentation using `unsigned char*` won't make sense. Hence, I am only\ntesting long and short.\n\n__Using `ctypedef unsigned long block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 676 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 671 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 683 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 725 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 759 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 787 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 811 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.44 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.61 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 132 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 134 ns per loop\nsage: %timeit hash(p50)\n10000000 loops, best of 3: 142 ns per loop\nsage: %timeit hash(p100)\n10000000 loops, best of 3: 155 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 466 ns per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 710 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 1.71 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 2.6 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 4.4 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 38 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 692 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 715 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 724 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 729 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 752 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 706 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 1.69 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 2.59 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 4.4 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 37.6 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 272 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 257 ns per loop\n```\n\n__Using `ctypedef unsigned short block`__\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 718 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 682 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 710 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 740 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 722 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 781 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 858 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.98 us per loop\nsage: %timeit p1000*q1000\n100000 loops, best of 3: 2.17 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 132 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 148 ns per loop\nsage: %timeit hash(p50)\n10000000 loops, best of 3: 168 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 206 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 951 ns per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 723 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 1.77 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 2.93 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 5.32 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 47.5 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 577 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 586 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 599 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 588 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 607 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 754 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 1.87 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 2.89 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 5.28 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 47.3 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 272 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 256 ns per loop\n```",
    "created_at": "2014-02-16T11:05:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199819",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

I have attached a toy (or proof-of-concept) implementation; see [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz). In a *real* implementation in
compressed representation, it would be the job of a `PathSemigroup` to find
out how many edges fit into one word. And of course, in the toy implementation
I am not trying to translate an integer sequence into the string
representation of an element of the path semigroup.

What implementation would you suggest to use in "reality"? Is there another implementation of "sequences of bounded integers" that you would recommend? And would you enumerate the arrows of a quiver locally (i.e., only number the outgoing edges at each vertex) or globally? The former will result in better compression, but would make it more difficult to test for paths p,q whether there are paths r,s with `p==r*q*s`.

Now for the timings, and sorry for the long post...

Here, I am timing concatenation, hash, comparison, comparing initial
segments. In all examples, we use the following paths of various sizes.

```
p5 = Path(ZZ, 5, range(5), 1, 1)
p25 = Path(ZZ, 25, range(25), 1, 1)
p50 = Path(ZZ, 50, range(50), 1, 1)
p100 = Path(ZZ, 100, range(100), 1, 1)
p1000 = Path(ZZ, 1000, range(1000), 1, 1)
q5 = Path(ZZ, 5, range(1,6), 1, 1)
q25 = Path(ZZ, 25, range(1,26), 1, 1)
q50 = Path(ZZ, 50, range(1,51), 1, 1)
q100 = Path(ZZ, 100, range(1,101), 1, 1)
q1000 = Path(ZZ, 1000, range(1,1001), 1, 1)
r5 = Path(ZZ, 5, range(1,5)+[0], 1, 1)
r25 = Path(ZZ, 25, range(1,25)+[0], 1, 1)
r50 = Path(ZZ, 50, range(1,50)+[0], 1, 1)
r100 = Path(ZZ, 100, range(1,100)+[0], 1, 1)
r1000 = Path(ZZ, 1000, range(1,1000)+[0], 1, 1)
s5 = Path(ZZ, 5, range(5), 1, 1)
s25 = Path(ZZ, 25, range(25), 1, 1)
s50 = Path(ZZ, 50, range(50), 1, 1)
s100 = Path(ZZ, 100, range(100), 1, 1)
s1000 = Path(ZZ, 1000, range(1000), 1, 1)
```

We are doing the following tests.

Concatenation:

```
%timeit p5*q5
%timeit p5*q25
%timeit p25*q25
%timeit p25*q50
%timeit p50*q50
%timeit p50*q100
%timeit p100*q100
%timeit p100*q1000
%timeit p1000*q1000
```

Hash:

```
%timeit hash(p5)
%timeit hash(p25)
%timeit hash(p50)
%timeit hash(p100)
%timeit hash(p1000)
```

Comparison:
1. equal

```
%timeit p5==s5
%timeit p25==s25
%timeit p50==s50
%timeit p100==s100
%timeit p1000==s1000
```
2. obviously different (first item differs)

```
%timeit p5==r5
%timeit p25==r25
%timeit p50==r50
%timeit p100==r100
%timeit p1000==r1000
```
3. less obviously different (only the last item differs)

```
%timeit q5==r5
%timeit q25==r25
%timeit q50==r50
%timeit q100==r100
%timeit q1000==r1000
```

Startswith:

```
%timeit q1000.startswith(q100)  # it does start with
%timeit q1000.startswith(r100)  # it doesn't start with
```

**__Uncompressed integer lists__**

Here, we define `Path=Path_v1` (see [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz)).

__Using `ctypedef unsigned long block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 739 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 769 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 801 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 810 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 885 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 959 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 1.02 us per loop
sage: %timeit p100*q1000
100000 loops, best of 3: 1.99 us per loop
sage: %timeit p1000*q1000
100000 loops, best of 3: 3.06 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 135 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 166 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 214 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 333 ns per loop
sage: %timeit hash(p1000)
100000 loops, best of 3: 2.09 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 1.63 us per loop
sage: %timeit p25==s25
100000 loops, best of 3: 5.91 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 11 us per loop
sage: %timeit p100==s100
10000 loops, best of 3: 23 us per loop
sage: %timeit p1000==s1000
1000 loops, best of 3: 212 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 634 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 659 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 659 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 686 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 698 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 1.65 us per loop
sage: %timeit q25==r25
100000 loops, best of 3: 5.83 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 11.5 us per loop
sage: %timeit q100==r100
10000 loops, best of 3: 22 us per loop
sage: %timeit q1000==r1000
1000 loops, best of 3: 213 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 325 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 311 ns per loop
```

__Using `ctypedef unsigned short block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 700 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 738 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 820 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 769 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 808 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 877 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 909 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.49 us per loop
sage: %timeit p1000*q1000
100000 loops, best of 3: 2.13 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 138 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 179 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 236 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 383 ns per loop
sage: %timeit hash(p1000)
100000 loops, best of 3: 2.61 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 1.08 us per loop
sage: %timeit p25==s25
100000 loops, best of 3: 3.42 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 6.53 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 14.9 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 137 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 613 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 591 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 602 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 603 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 635 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 1.15 us per loop
sage: %timeit q25==r25
100000 loops, best of 3: 3.63 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 6.45 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 12.8 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 140 us per loop
sage: q1000.startswith(q100)
True
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 336 ns per loop
sage: q1000.startswith(r100)
False
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 325 ns per loop
```

__Using `ctypedef unsigned char block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 679 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 693 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 725 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 760 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 772 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 761 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 790 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.1 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.31 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 133 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 176 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 234 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 374 ns per loop
sage: %timeit hash(p1000)
100000 loops, best of 3: 2.53 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 1.08 us per loop
sage: %timeit p25==s25
100000 loops, best of 3: 3.36 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 6.3 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 12.5 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 121 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 581 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 589 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 599 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 599 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 636 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 1.06 us per loop
sage: %timeit q25==r25
100000 loops, best of 3: 3.46 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 6.51 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 12.7 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 121 us per loop
sage: q1000.startswith(q100)
True
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 324 ns per loop
sage: %timeit q1000.startswith(r100) 
1000000 loops, best of 3: 315 ns per loop
```

**__Compressed integer lists__**

Here, we define `Path=Path_v2` (see [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz)), and do

```
sage: SizeManager.set_edge_number(27)
```
so that there is a total of only 27 edges (resp. 27 is the maximal number of
outgoing arrows on a vertex). In particular, all integers in the sequences
below are taken "mod 27". Since 27 has length 5 bits, a compressed
representation using `unsigned char*` won't make sense. Hence, I am only
testing long and short.

__Using `ctypedef unsigned long block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 676 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 671 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 683 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 725 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 759 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 787 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 811 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.44 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.61 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 132 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 134 ns per loop
sage: %timeit hash(p50)
10000000 loops, best of 3: 142 ns per loop
sage: %timeit hash(p100)
10000000 loops, best of 3: 155 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 466 ns per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 710 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 1.71 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 2.6 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 4.4 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 38 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 692 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 715 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 724 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 729 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 752 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 706 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 1.69 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 2.59 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 4.4 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 37.6 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 272 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 257 ns per loop
```

__Using `ctypedef unsigned short block`__

```
sage: %timeit p5*q5
1000000 loops, best of 3: 718 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 682 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 710 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 740 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 722 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 781 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 858 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.98 us per loop
sage: %timeit p1000*q1000
100000 loops, best of 3: 2.17 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 132 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 148 ns per loop
sage: %timeit hash(p50)
10000000 loops, best of 3: 168 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 206 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 951 ns per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 723 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 1.77 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 2.93 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 5.32 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 47.5 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 577 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 586 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 599 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 588 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 607 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 754 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 1.87 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 2.89 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 5.28 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 47.3 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 272 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 256 ns per loop
```



---

archive/issue_comments_199820.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nIt turns out that there are bugs in the toy code. But that's no surprise...",
    "created_at": "2014-02-16T13:24:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199820",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:5" align="right">comment:5</div>

It turns out that there are bugs in the toy code. But that's no surprise...



---

archive/issue_comments_199821.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nI have fixed the problems in [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz).\n\nIt was:\n1. bitshift by a wrong offset, and\n2. the bits that aren't used (e.g., the last 4 bits of an uint64_t when storing 12 arrows of size 5 bits) should be kept blank.\n\nThe latter involves an additional bitwise \"and\". So, probably the timings will slightly deteriorate.",
    "created_at": "2014-02-16T19:32:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199821",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

I have fixed the problems in [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz).

It was:
1. bitshift by a wrong offset, and
2. the bits that aren't used (e.g., the last 4 bits of an uint64_t when storing 12 arrows of size 5 bits) should be kept blank.

The latter involves an additional bitwise "and". So, probably the timings will slightly deteriorate.



---

archive/issue_comments_199822.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nThere is one other variation that I want to test.\n\nCurrently, if the number of edges fits into 5 bits, then a 64 bit word is filled with data of 12 edges, plus 4 bits of garbage. The garbage must always be zero bits, for otherwise the shift operations would pollute real data with the garbage bits. To keep the garbage zero involves additional operations.\n\nAlternatively, one could try to put fewer arrows into one word, so that there are *no* garbage bits. This could be done by encoding each arrow by a number of bits that is a power of 2. Hence, in the setting above, one would encode each edge by 8 rather than 5 bits, fitting 8 arrows into one 64 bit word. It is less dense, however the code gets simpler and should have less overhead.",
    "created_at": "2014-02-16T20:24:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199822",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

There is one other variation that I want to test.

Currently, if the number of edges fits into 5 bits, then a 64 bit word is filled with data of 12 edges, plus 4 bits of garbage. The garbage must always be zero bits, for otherwise the shift operations would pollute real data with the garbage bits. To keep the garbage zero involves additional operations.

Alternatively, one could try to put fewer arrows into one word, so that there are *no* garbage bits. This could be done by encoding each arrow by a number of bits that is a power of 2. Hence, in the setting above, one would encode each edge by 8 rather than 5 bits, fitting 8 arrows into one 64 bit word. It is less dense, however the code gets simpler and should have less overhead.



---

archive/issue_comments_199823.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nI have replaced [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz) again, adding two more implementations.\n\nDo you have further suggestions on storage of lists of bounded integers? If you haven't, then I'll try to assess the timings stated in the various comments, according to what I expect to be useful in my applications.\n\nHere are details on the two new implementations:\n\nIn `Path_v3`, I use Sage's `Integer` class as bit list. Sounds crazy, but it works rather well. I assume that bitshifts and comparison (and that's what we are using here) are internally written in assembler, and for us, the additional benefit is that we do not need to take care about the size of blocks (8 bit? 32 bit? 64 bit? 128 bit?) in which we store stuff---`Integer` does it for us. Perhaps the timings could be improved further by using the underlying c-library (GMP's `mpz_t`) directly.\n\nIn `Path_v4`, I provide a slightly simplified version of `Path_v2`: The data is compressed, but so that the chunks used to store one arrow fit seamlessly into a memory block. Hence, when we use 64-bit blocks, and have 27 arrows, then `Path_v2` would store the arrows in chunks of 5 bit (hence, it can store 12 arrows in one memory block, leaving 4 bit empty), whereas `Path_v4` would store the arrows in chunks of 8 bit (hence, it can only store 8 arrows in one memory block, but since this fits neatly into one memory block, the code can be simplified).\n\nThe timings for `Path_v3`:\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 645 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 631 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 635 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 1.23 us per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 1.82 us per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 1.83 us per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 1.37 us per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.82 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.78 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 164 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 197 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 210 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 274 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 1.94 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 667 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 638 ns per loop\nsage: %timeit p50==s50\n1000000 loops, best of 3: 693 ns per loop\nsage: %timeit p100==s100\n1000000 loops, best of 3: 658 ns per loop\nsage: %timeit p1000==s1000\n1000000 loops, best of 3: 817 ns per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 746 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 723 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 769 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 731 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 733 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 710 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 733 ns per loop\nsage: %timeit q50==r50\n1000000 loops, best of 3: 718 ns per loop\nsage: %timeit q100==r100\n1000000 loops, best of 3: 719 ns per loop\nsage: %timeit q1000==r1000\n1000000 loops, best of 3: 755 ns per loop\nsage: %timeit q1000.startswith(q100)\n100000 loops, best of 3: 2.46 us per loop\nsage: %timeit q1000.startswith(r100)\n100000 loops, best of 3: 2.45 us per loop\n```\n\nThe timings for `Path_v4`:\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 730 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 762 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 806 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 849 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 854 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 931 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 930 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.97 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.45 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 136 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 148 ns per loop\nsage: %timeit hash(p50)\n10000000 loops, best of 3: 159 ns per loop\nsage: %timeit hash(p100)\n10000000 loops, best of 3: 182 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 600 ns per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 700 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 1.65 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 2.48 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 4.21 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 36.4 us per loop\nsage: %timeit p5==r5\n100000 loops, best of 3: 706 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 764 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 740 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 742 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 822 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 693 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 1.6 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 2.54 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 4.27 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 37.1 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 255 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 243 ns per loop\n```",
    "created_at": "2014-02-18T12:21:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199823",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:8" align="right">comment:8</div>

I have replaced [attachment: path_test.pyx](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz) again, adding two more implementations.

Do you have further suggestions on storage of lists of bounded integers? If you haven't, then I'll try to assess the timings stated in the various comments, according to what I expect to be useful in my applications.

Here are details on the two new implementations:

In `Path_v3`, I use Sage's `Integer` class as bit list. Sounds crazy, but it works rather well. I assume that bitshifts and comparison (and that's what we are using here) are internally written in assembler, and for us, the additional benefit is that we do not need to take care about the size of blocks (8 bit? 32 bit? 64 bit? 128 bit?) in which we store stuff---`Integer` does it for us. Perhaps the timings could be improved further by using the underlying c-library (GMP's `mpz_t`) directly.

In `Path_v4`, I provide a slightly simplified version of `Path_v2`: The data is compressed, but so that the chunks used to store one arrow fit seamlessly into a memory block. Hence, when we use 64-bit blocks, and have 27 arrows, then `Path_v2` would store the arrows in chunks of 5 bit (hence, it can store 12 arrows in one memory block, leaving 4 bit empty), whereas `Path_v4` would store the arrows in chunks of 8 bit (hence, it can only store 8 arrows in one memory block, but since this fits neatly into one memory block, the code can be simplified).

The timings for `Path_v3`:

```
sage: %timeit p5*q5
1000000 loops, best of 3: 645 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 631 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 635 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 1.23 us per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 1.82 us per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 1.83 us per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 1.37 us per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.82 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.78 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 164 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 197 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 210 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 274 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 1.94 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 667 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 638 ns per loop
sage: %timeit p50==s50
1000000 loops, best of 3: 693 ns per loop
sage: %timeit p100==s100
1000000 loops, best of 3: 658 ns per loop
sage: %timeit p1000==s1000
1000000 loops, best of 3: 817 ns per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 746 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 723 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 769 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 731 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 733 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 710 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 733 ns per loop
sage: %timeit q50==r50
1000000 loops, best of 3: 718 ns per loop
sage: %timeit q100==r100
1000000 loops, best of 3: 719 ns per loop
sage: %timeit q1000==r1000
1000000 loops, best of 3: 755 ns per loop
sage: %timeit q1000.startswith(q100)
100000 loops, best of 3: 2.46 us per loop
sage: %timeit q1000.startswith(r100)
100000 loops, best of 3: 2.45 us per loop
```

The timings for `Path_v4`:

```
sage: %timeit p5*q5
1000000 loops, best of 3: 730 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 762 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 806 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 849 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 854 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 931 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 930 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.97 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.45 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 136 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 148 ns per loop
sage: %timeit hash(p50)
10000000 loops, best of 3: 159 ns per loop
sage: %timeit hash(p100)
10000000 loops, best of 3: 182 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 600 ns per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 700 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 1.65 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 2.48 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 4.21 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 36.4 us per loop
sage: %timeit p5==r5
100000 loops, best of 3: 706 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 764 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 740 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 742 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 822 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 693 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 1.6 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 2.54 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 4.27 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 37.1 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 255 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 243 ns per loop
```



---

archive/issue_comments_199824.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nHmmm. Perhaps I should have a look at `sage/misc/bitset.pxi`.",
    "created_at": "2014-02-18T12:28:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199824",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:9" align="right">comment:9</div>

Hmmm. Perhaps I should have a look at `sage/misc/bitset.pxi`.



---

archive/issue_comments_199825.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nI couldn't directly use `sage/misc/bitset`, but I could learn from it: I have improved the `Path_v4` implementation (here, the arrows will be encoded by chunks of memory whose size is a power of 2). This was possible by using `memcmp` in some place (not in the method `startswith()`, where a loop over the data is faster than memcmp) and, in particular, use bitshift operations to replace multiplications and integer divisions (this is only possible with `Path_v4`, since here the factors are powers of 2 and can thus correspond to shifts).\n\nNew timings with `Path=Path_v4` and `SizeManager.set_edge_number(27)`:\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 684 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 726 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 798 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 862 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 827 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 924 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 915 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.91 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.42 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 148 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 158 ns per loop\nsage: %timeit hash(p50)\n10000000 loops, best of 3: 171 ns per loop\nsage: %timeit hash(p100)\n10000000 loops, best of 3: 194 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 594 ns per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 498 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 547 ns per loop\nsage: %timeit p50==s50\n1000000 loops, best of 3: 631 ns per loop\nsage: %timeit p100==s100\n1000000 loops, best of 3: 712 ns per loop\nsage: %timeit p1000==s1000\n100000 loops, best of 3: 2.42 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 499 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 514 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 549 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 526 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 545 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 506 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 544 ns per loop\nsage: %timeit q50==r50\n1000000 loops, best of 3: 589 ns per loop\nsage: %timeit q100==r100\n1000000 loops, best of 3: 704 ns per loop\nsage: %timeit q1000==r1000\n100000 loops, best of 3: 2.48 us per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 263 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 232 ns per loop\n```",
    "created_at": "2014-02-18T17:23:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199825",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:10" align="right">comment:10</div>

I couldn't directly use `sage/misc/bitset`, but I could learn from it: I have improved the `Path_v4` implementation (here, the arrows will be encoded by chunks of memory whose size is a power of 2). This was possible by using `memcmp` in some place (not in the method `startswith()`, where a loop over the data is faster than memcmp) and, in particular, use bitshift operations to replace multiplications and integer divisions (this is only possible with `Path_v4`, since here the factors are powers of 2 and can thus correspond to shifts).

New timings with `Path=Path_v4` and `SizeManager.set_edge_number(27)`:

```
sage: %timeit p5*q5
1000000 loops, best of 3: 684 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 726 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 798 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 862 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 827 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 924 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 915 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.91 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.42 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 148 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 158 ns per loop
sage: %timeit hash(p50)
10000000 loops, best of 3: 171 ns per loop
sage: %timeit hash(p100)
10000000 loops, best of 3: 194 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 594 ns per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 498 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 547 ns per loop
sage: %timeit p50==s50
1000000 loops, best of 3: 631 ns per loop
sage: %timeit p100==s100
1000000 loops, best of 3: 712 ns per loop
sage: %timeit p1000==s1000
100000 loops, best of 3: 2.42 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 499 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 514 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 549 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 526 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 545 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 506 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 544 ns per loop
sage: %timeit q50==r50
1000000 loops, best of 3: 589 ns per loop
sage: %timeit q100==r100
1000000 loops, best of 3: 704 ns per loop
sage: %timeit q1000==r1000
100000 loops, best of 3: 2.48 us per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 263 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 232 ns per loop
```



---

archive/issue_comments_199826.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nPS: I chose 27 edges, since this should be particularly bad for `Path_v4`. Indeed, in `Path_v2`, 12 arrows can be put into one `uint64_t`, whereas in `Path_v4` only 8 arrows fit into one `uint64_t`. So, if `Path_v4` turns out to be faster than `Path_v2` with 27 edges, then it is likely to be *generally* faster, I think.",
    "created_at": "2014-02-18T17:27:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199826",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:11" align="right">comment:11</div>

PS: I chose 27 edges, since this should be particularly bad for `Path_v4`. Indeed, in `Path_v2`, 12 arrows can be put into one `uint64_t`, whereas in `Path_v4` only 8 arrows fit into one `uint64_t`. So, if `Path_v4` turns out to be faster than `Path_v2` with 27 edges, then it is likely to be *generally* faster, I think.



---

archive/issue_comments_199827.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nFrom my side, this is the last part of the proof-of-concept implementations, before assessing the benchmark tests and choosing an implementation for the elements of path semigroups...\n\nIn `Path_v5`, I am using the GMP library directly, thus avoiding some overhead compared with `Path_v3`. The timings I get (with `Path=Path_v5` and `SizeManager.set_edge_number(27)`):\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 720 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 814 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 823 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 808 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 828 ns per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 890 ns per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 866 ns per loop\nsage: %timeit p100*q1000\n1000000 loops, best of 3: 1.18 us per loop\nsage: %timeit p1000*q1000\n1000000 loops, best of 3: 1.38 us per loop\nsage: %timeit hash(p5)\n10000000 loops, best of 3: 159 ns per loop\nsage: %timeit hash(p25)\n10000000 loops, best of 3: 171 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 198 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 266 ns per loop\nsage: %timeit hash(p1000)\n1000000 loops, best of 3: 1.93 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 466 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 509 ns per loop\nsage: %timeit p50==s50\n1000000 loops, best of 3: 495 ns per loop\nsage: %timeit p100==s100\n1000000 loops, best of 3: 485 ns per loop\nsage: %timeit p1000==s1000\n1000000 loops, best of 3: 693 ns per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 451 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 468 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 463 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 468 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 482 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 448 ns per loop\nsage: %timeit q25==r25\n1000000 loops, best of 3: 462 ns per loop\nsage: %timeit q50==r50\n1000000 loops, best of 3: 448 ns per loop\nsage: %timeit q100==r100\n1000000 loops, best of 3: 457 ns per loop\nsage: %timeit q1000==r1000\n1000000 loops, best of 3: 470 ns per loop\nsage: %timeit q1000.startswith(q100)\n1000000 loops, best of 3: 673 ns per loop\nsage: %timeit q1000.startswith(r100)\n1000000 loops, best of 3: 657 ns per loop\n```",
    "created_at": "2014-02-18T23:02:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199827",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:12" align="right">comment:12</div>

From my side, this is the last part of the proof-of-concept implementations, before assessing the benchmark tests and choosing an implementation for the elements of path semigroups...

In `Path_v5`, I am using the GMP library directly, thus avoiding some overhead compared with `Path_v3`. The timings I get (with `Path=Path_v5` and `SizeManager.set_edge_number(27)`):

```
sage: %timeit p5*q5
1000000 loops, best of 3: 720 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 814 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 823 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 808 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 828 ns per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 890 ns per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 866 ns per loop
sage: %timeit p100*q1000
1000000 loops, best of 3: 1.18 us per loop
sage: %timeit p1000*q1000
1000000 loops, best of 3: 1.38 us per loop
sage: %timeit hash(p5)
10000000 loops, best of 3: 159 ns per loop
sage: %timeit hash(p25)
10000000 loops, best of 3: 171 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 198 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 266 ns per loop
sage: %timeit hash(p1000)
1000000 loops, best of 3: 1.93 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 466 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 509 ns per loop
sage: %timeit p50==s50
1000000 loops, best of 3: 495 ns per loop
sage: %timeit p100==s100
1000000 loops, best of 3: 485 ns per loop
sage: %timeit p1000==s1000
1000000 loops, best of 3: 693 ns per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 451 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 468 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 463 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 468 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 482 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 448 ns per loop
sage: %timeit q25==r25
1000000 loops, best of 3: 462 ns per loop
sage: %timeit q50==r50
1000000 loops, best of 3: 448 ns per loop
sage: %timeit q100==r100
1000000 loops, best of 3: 457 ns per loop
sage: %timeit q1000==r1000
1000000 loops, best of 3: 470 ns per loop
sage: %timeit q1000.startswith(q100)
1000000 loops, best of 3: 673 ns per loop
sage: %timeit q1000.startswith(r100)
1000000 loops, best of 3: 657 ns per loop
```



---

archive/issue_comments_199828.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nHmmmmmmm... Well, looks like the last one is the best, even though it is a bit slow for hashing. If the sizeof a block is a power of two it should be quite good, don't you think ?\n\nThis being said, perhaps  it should be implemented like the bitset stuff, in a algebraic-free file, to store sequences of integers as you said.\n\nHow do you define your hashing function and your comparison function, by the way ?\n\nNathann",
    "created_at": "2014-02-20T17:08:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199828",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:13" align="right">comment:13</div>

Hmmmmmmm... Well, looks like the last one is the best, even though it is a bit slow for hashing. If the sizeof a block is a power of two it should be quite good, don't you think ?

This being said, perhaps  it should be implemented like the bitset stuff, in a algebraic-free file, to store sequences of integers as you said.

How do you define your hashing function and your comparison function, by the way ?

Nathann



---

archive/issue_comments_199829.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nReplying to [@nathanncohen](#comment:13):\n> Hmmmmmmm... Well, looks like the last one is the best, even though it is a bit slow for hashing.\n\nWhat do you mean by \"the last one\"? Using GMP's `mpz_t`directly, which is `Path_v5` in the attachment? Or the improved \"semicompressed\" version of `uint64_t*` (storing chunks of size `2^n` rather then in the smallest possible chunk size), which is `Path_v4`?\n\n> If the sizeof a block is a power of two it should be quite good, don't you think ?\n\nShould be. My own summary of the timings above would be this. We have 6 benchmarks, and in the following list I am giving for each benchmark a small, a medium and a large example. In the end, `+` or `-` indicate whether the respective implementation did well/poorly in the three examples.\n\n1. Concatenation\n\n```\n                     5x5   50x50  1000x1000\nUncompressed long : 739 ns  885 ns 3.06 us  - -\nUncompressed short: 700 ns  808 ns 2.13 us\nUncompressed char : 679 ns  772 ns 1.31 us    +\nCompressed   long : 676 ns  759 ns 1.61 us\nCompressed   short: 718 ns  722 ns 1.98 us   +\nSemicompr.   long : 684 ns  827 ns 1.42 us\nInteger           : 645 ns 1.82 us 1.78 us  +-\nGMP          mpz_t: 723 ns  799 ns 1.41 us\n```\n\n2. Hash\n\n```\n                     5      100     1000\nUncompressed long : 135 ns 333 ns  2.09 us  +\nUncompressed short: 138 ns 383 ns  2.61 us  +--\nUncompressed char : 133 ns 374 ns  2.53 us  +\nCompressed   long : 132 ns 155 ns   466 ns  +++\nCompressed   short: 132 ns 206 ns   951 ns  +\nSemicompr.   long : 148 ns 194 ns   594 ns\nInteger           : 164 ns 274 ns  1.94 us  -\nGMP          mpz_t: 159 ns 266 ns  1.93 us\n```\n\n3. == for equal paths\n\n```\n                     5       100     1000\nUncompressed long : 1.63 us 23   us  212   us ---\nUncompressed short: 1.08 us 14.9 us  137   us\nUncompressed char : 1.08 us 12.5 us  121   us\nCompressed   long :  710 ns  4.4 us   38   us\nCompressed   short:  723 ns  5.3 us   47.5 us\nSemicompr.   long :  498 ns  712 ns    2.4 us\nInteger           :  667 ns  658 ns    817 ns\nGMP          mpz_t:  466 ns  485 ns    693 ns +++\n```\n\n4. == for \"easily\" unequal paths\n\n```\n                     5       100     1000\nUncompressed long : 634 ns   686 ns   698 ns\nUncompressed short: 613 ns   603 ns   635 ns\nUncompressed char : 581 ns   599 ns   636 ns\nCompressed   long : 692 ns   729 ns   752 ns  --\nCompressed   short: 577 ns   588 ns   607 ns\nSemicompr.   long : 499 ns   526 ns   545 ns\nInteger           : 746 ns   731 ns   733 ns --\nGMP          mpz_t: 451 ns   468 ns   482 ns +++\n```\n\n5. == for \"difficult\" unequal paths\n\n```\n                     5       100      1000\nUncompressed long : 1.65 us   22 us    213 us   ---\nUncompressed short: 1.15 us   12.8 us  140 us\nUncompressed char : 1.06 us   12.7 us  121 us\nCompressed   long :  706 ns    4.4 us   37.6 us\nCompressed   short:  754 ns    5.3 us   47.3 us\nSemicompr.   long :  506 ns    704 ns   2.5 us\nInteger           :  710 ns    719 ns   755 ns\nGMP          mpz_t:  448 ns    457 ns   470 ns  +++\n```\n\n6. startswith (here we only have one example size, one where the answer is True, and one where the answer is False)\n\n```\n                     yes      no\nUncompressed long :  325 ns  311 ns\nUncompressed short:  336 ns  325 ns\nUncompressed char :  324 ns  315 ns\nCompressed   long :  272 ns  257 ns  +\nCompressed   short:  272 ns  256 ns  +\nSemicompr.   long :  263 ns  232 ns  ++\nInteger           : 2.46 us 2.45 us  --\nGMP          mpz_t:  673 ns  657 ns\n```\n\nSo, I don't think there is a clear winner in the competition.\n\n> This being said, perhaps  it should be implemented like the bitset stuff, in a algebraic-free file, to store sequences of integers as you said.\n\nYes, it would make sense.\n\n> How do you define your hashing function and your comparison function, by the way ?\n\nDepends on the implementation. Of course, when I use `Integer` or `mpz_t`, I am using the hash function provided by GMP. When I implement a `block*`, where `block` is either `char`, `uint32_t` or `uint64_t`, I am using some hash function for lists that I found in the internet a while ago (I don't recall where). It is as follows:\n\n```python\n    def __hash__(self):\n        cdef block h\n        cdef block* ptr\n        h = <block>(self.start^(self.end<<16)^(self._len))\n        ptr = <block *>self.data\n        cdef size_t i\n        h ^= FNV_offset\n        for i from 0<=i<self._len:\n            h ^= ptr[i]\n            h *= FNV_prime\n        if h==-1:\n            return -2\n        return h\n```\nwhere `FNV_prime` and `FNV_offset` depend on the architecture. I am surprised that this is faster than GMP's hash function.",
    "created_at": "2014-02-21T12:12:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199829",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:14" align="right">comment:14</div>

Replying to [@nathanncohen](#comment:13):
> Hmmmmmmm... Well, looks like the last one is the best, even though it is a bit slow for hashing.

What do you mean by "the last one"? Using GMP's `mpz_t`directly, which is `Path_v5` in the attachment? Or the improved "semicompressed" version of `uint64_t*` (storing chunks of size `2^n` rather then in the smallest possible chunk size), which is `Path_v4`?

> If the sizeof a block is a power of two it should be quite good, don't you think ?

Should be. My own summary of the timings above would be this. We have 6 benchmarks, and in the following list I am giving for each benchmark a small, a medium and a large example. In the end, `+` or `-` indicate whether the respective implementation did well/poorly in the three examples.

1. Concatenation

```
                     5x5   50x50  1000x1000
Uncompressed long : 739 ns  885 ns 3.06 us  - -
Uncompressed short: 700 ns  808 ns 2.13 us
Uncompressed char : 679 ns  772 ns 1.31 us    +
Compressed   long : 676 ns  759 ns 1.61 us
Compressed   short: 718 ns  722 ns 1.98 us   +
Semicompr.   long : 684 ns  827 ns 1.42 us
Integer           : 645 ns 1.82 us 1.78 us  +-
GMP          mpz_t: 723 ns  799 ns 1.41 us
```

2. Hash

```
                     5      100     1000
Uncompressed long : 135 ns 333 ns  2.09 us  +
Uncompressed short: 138 ns 383 ns  2.61 us  +--
Uncompressed char : 133 ns 374 ns  2.53 us  +
Compressed   long : 132 ns 155 ns   466 ns  +++
Compressed   short: 132 ns 206 ns   951 ns  +
Semicompr.   long : 148 ns 194 ns   594 ns
Integer           : 164 ns 274 ns  1.94 us  -
GMP          mpz_t: 159 ns 266 ns  1.93 us
```

3. == for equal paths

```
                     5       100     1000
Uncompressed long : 1.63 us 23   us  212   us ---
Uncompressed short: 1.08 us 14.9 us  137   us
Uncompressed char : 1.08 us 12.5 us  121   us
Compressed   long :  710 ns  4.4 us   38   us
Compressed   short:  723 ns  5.3 us   47.5 us
Semicompr.   long :  498 ns  712 ns    2.4 us
Integer           :  667 ns  658 ns    817 ns
GMP          mpz_t:  466 ns  485 ns    693 ns +++
```

4. == for "easily" unequal paths

```
                     5       100     1000
Uncompressed long : 634 ns   686 ns   698 ns
Uncompressed short: 613 ns   603 ns   635 ns
Uncompressed char : 581 ns   599 ns   636 ns
Compressed   long : 692 ns   729 ns   752 ns  --
Compressed   short: 577 ns   588 ns   607 ns
Semicompr.   long : 499 ns   526 ns   545 ns
Integer           : 746 ns   731 ns   733 ns --
GMP          mpz_t: 451 ns   468 ns   482 ns +++
```

5. == for "difficult" unequal paths

```
                     5       100      1000
Uncompressed long : 1.65 us   22 us    213 us   ---
Uncompressed short: 1.15 us   12.8 us  140 us
Uncompressed char : 1.06 us   12.7 us  121 us
Compressed   long :  706 ns    4.4 us   37.6 us
Compressed   short:  754 ns    5.3 us   47.3 us
Semicompr.   long :  506 ns    704 ns   2.5 us
Integer           :  710 ns    719 ns   755 ns
GMP          mpz_t:  448 ns    457 ns   470 ns  +++
```

6. startswith (here we only have one example size, one where the answer is True, and one where the answer is False)

```
                     yes      no
Uncompressed long :  325 ns  311 ns
Uncompressed short:  336 ns  325 ns
Uncompressed char :  324 ns  315 ns
Compressed   long :  272 ns  257 ns  +
Compressed   short:  272 ns  256 ns  +
Semicompr.   long :  263 ns  232 ns  ++
Integer           : 2.46 us 2.45 us  --
GMP          mpz_t:  673 ns  657 ns
```

So, I don't think there is a clear winner in the competition.

> This being said, perhaps  it should be implemented like the bitset stuff, in a algebraic-free file, to store sequences of integers as you said.

Yes, it would make sense.

> How do you define your hashing function and your comparison function, by the way ?

Depends on the implementation. Of course, when I use `Integer` or `mpz_t`, I am using the hash function provided by GMP. When I implement a `block*`, where `block` is either `char`, `uint32_t` or `uint64_t`, I am using some hash function for lists that I found in the internet a while ago (I don't recall where). It is as follows:

```python
    def __hash__(self):
        cdef block h
        cdef block* ptr
        h = <block>(self.start^(self.end<<16)^(self._len))
        ptr = <block *>self.data
        cdef size_t i
        h ^= FNV_offset
        for i from 0<=i<self._len:
            h ^= ptr[i]
            h *= FNV_prime
        if h==-1:
            return -2
        return h
```
where `FNV_prime` and `FNV_offset` depend on the architecture. I am surprised that this is faster than GMP's hash function.



---

archive/issue_comments_199830.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n #12630 has introduced tools to compute with quiver algebras and quiver representations. It is all Python code, paths being internally stored by lists of labelled edges of digraphs.\n \n-The aim of this ticket is to provide a more efficient implementation of the (partial) semigroup that is formed by the paths of a quiver, multiplied by concatenation.\n+The aim of this ticket is to provide an efficient implementation of lists of bounded integers, with concatenation. This can be used to implement paths of a quiver more efficiently, but can also have different applications (say, elements of free groups, or other applications in sage-combinat).\n \n``````\n",
    "created_at": "2014-02-22T14:40:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199830",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
 #12630 has introduced tools to compute with quiver algebras and quiver representations. It is all Python code, paths being internally stored by lists of labelled edges of digraphs.
 
-The aim of this ticket is to provide a more efficient implementation of the (partial) semigroup that is formed by the paths of a quiver, multiplied by concatenation.
+The aim of this ticket is to provide an efficient implementation of lists of bounded integers, with concatenation. This can be used to implement paths of a quiver more efficiently, but can also have different applications (say, elements of free groups, or other applications in sage-combinat).
 
``````




---

archive/issue_events_225893.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-02-22T14:40:48Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "title_is": "Implement sequences of bounded integers",
    "title_was": "Improve efficiency of the path semigroup",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225893"
}
```



---

archive/issue_comments_199831.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nAs Nathann has mentioned, it would make sense to provide a general implementation of sequences of bounded integers (independent of quiver paths), and then quiver paths can inherit from it later. That's why I changed the ticket description.",
    "created_at": "2014-02-22T14:42:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199831",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:16" align="right">comment:16</div>

As Nathann has mentioned, it would make sense to provide a general implementation of sequences of bounded integers (independent of quiver paths), and then quiver paths can inherit from it later. That's why I changed the ticket description.



---

archive/issue_comments_199832.json:
```json
{
    "body": "Changed keywords from **quiver path algebra efficiency** to **sequence bounded integer**",
    "created_at": "2014-02-22T14:42:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199832",
    "user": "https://github.com/simon-king-jena"
}
```

Changed keywords from **quiver path algebra efficiency** to **sequence bounded integer**



---

archive/issue_comments_199833.json:
```json
{
    "body": "Changed dependencies from **#12630** to none",
    "created_at": "2014-02-24T13:21:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199833",
    "user": "https://github.com/simon-king-jena"
}
```

Changed dependencies from **#12630** to none



---

archive/issue_comments_199834.json:
```json
{
    "body": "Attachment: **[path_test.pyx.gz](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz)**\n\nA proof of concept",
    "created_at": "2014-02-24T14:37:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199834",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment: **[path_test.pyx.gz](https://github.com/sagemath/sage/files/ticket15820/path_test.pyx.gz)**

A proof of concept



---

archive/issue_comments_199835.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nFor completeness, I have added `Path_v6`, which uses Python's `tuple` under the hood (which is an obvious way to implement paths, too).\n\nResult:\n\n```\nsage: %timeit p5*q5\n1000000 loops, best of 3: 439 ns per loop\nsage: %timeit p5*q25\n1000000 loops, best of 3: 542 ns per loop\nsage: %timeit p25*q25\n1000000 loops, best of 3: 612 ns per loop\nsage: %timeit p25*q50\n1000000 loops, best of 3: 869 ns per loop\nsage: %timeit p50*q50\n1000000 loops, best of 3: 1.1 us per loop\nsage: %timeit p50*q100\n1000000 loops, best of 3: 1.39 us per loop\nsage: %timeit p100*q100\n1000000 loops, best of 3: 1.41 us per loop\nsage: %timeit p100*q1000\n100000 loops, best of 3: 5.04 us per loop\nsage: %timeit p1000*q1000\n100000 loops, best of 3: 11 us per loop\nsage: %timeit hash(p5)\n1000000 loops, best of 3: 245 ns per loop\nsage: %timeit hash(p25)\n1000000 loops, best of 3: 532 ns per loop\nsage: %timeit hash(p50)\n1000000 loops, best of 3: 884 ns per loop\nsage: %timeit hash(p100)\n1000000 loops, best of 3: 1.63 us per loop\nsage: %timeit hash(p1000)\n100000 loops, best of 3: 14.6 us per loop\nsage: %timeit p5==s5\n1000000 loops, best of 3: 885 ns per loop\nsage: %timeit p25==s25\n1000000 loops, best of 3: 1.71 us per loop\nsage: %timeit p50==s50\n100000 loops, best of 3: 2.63 us per loop\nsage: %timeit p100==s100\n100000 loops, best of 3: 4.53 us per loop\nsage: %timeit p1000==s1000\n10000 loops, best of 3: 39.3 us per loop\nsage: %timeit p5==r5\n1000000 loops, best of 3: 785 ns per loop\nsage: %timeit p25==r25\n1000000 loops, best of 3: 829 ns per loop\nsage: %timeit p50==r50\n1000000 loops, best of 3: 799 ns per loop\nsage: %timeit p100==r100\n1000000 loops, best of 3: 791 ns per loop\nsage: %timeit p1000==r1000\n1000000 loops, best of 3: 822 ns per loop\nsage: %timeit q5==r5\n1000000 loops, best of 3: 1.48 us per loop\nsage: %timeit q25==r25\n100000 loops, best of 3: 3.72 us per loop\nsage: %timeit q50==r50\n100000 loops, best of 3: 6.63 us per loop\nsage: %timeit q100==r100\n100000 loops, best of 3: 12.5 us per loop\nsage: %timeit q1000==r1000\n10000 loops, best of 3: 116 us per loop\nsage: %timeit q1000.startswith(q100)\n100000 loops, best of 3: 4.7 us per loop\nsage: %timeit q1000.startswith(r100)\n100000 loops, best of 3: 4.72 us per loop\n```\n\nThe comparison with the other implementations becomes this:\n\n1. Concatenation\n\n```\n                     5x5   50x50  1000x1000\nUncompressed long : 739 ns  885 ns 3.06 us  - -\nUncompressed short: 700 ns  808 ns 2.13 us\nUncompressed char : 679 ns  772 ns 1.31 us    +\nCompressed   long : 676 ns  759 ns 1.61 us\nCompressed   short: 718 ns  722 ns 1.98 us   +\nSemicompr.   long : 684 ns  827 ns 1.42 us\nInteger           : 645 ns 1.82 us 1.78 us   -\nGMP          mpz_t: 723 ns  799 ns 1.41 us\ntuple             : 439 ns  1.1 us 11   us  + -\n```\n\n2. Hash\n\n```\n                     5       100     1000\nUncompressed long : 135 ns  333 ns  2.09 us  +\nUncompressed short: 138 ns  383 ns  2.61 us  +--\nUncompressed char : 133 ns  374 ns  2.53 us  +\nCompressed   long : 132 ns  155 ns   466 ns  +++\nCompressed   short: 132 ns  206 ns   951 ns  +\nSemicompr.   long : 148 ns  194 ns   594 ns\nInteger           : 164 ns  274 ns  1.94 us  \nGMP          mpz_t: 159 ns  266 ns  1.93 us\ntuple             : 245 ns 1.63 us 14.6  us  ---\n```\n\n3. == for equal paths\n\n```\n                     5       100     1000\nUncompressed long : 1.63 us 23   us  212   us ---\nUncompressed short: 1.08 us 14.9 us  137   us\nUncompressed char : 1.08 us 12.5 us  121   us\nCompressed   long :  710 ns  4.4 us   38   us\nCompressed   short:  723 ns  5.3 us   47.5 us\nSemicompr.   long :  498 ns  712 ns    2.4 us\nInteger           :  667 ns  658 ns    817 ns\nGMP          mpz_t:  466 ns  485 ns    693 ns +++\ntuple             :  885 ns  4.5 us   39.3 us\n```\n\n4. == for \"easily\" unequal paths\n\n```\n                     5       100     1000\nUncompressed long : 634 ns   686 ns   698 ns\nUncompressed short: 613 ns   603 ns   635 ns\nUncompressed char : 581 ns   599 ns   636 ns\nCompressed   long : 692 ns   729 ns   752 ns \nCompressed   short: 577 ns   588 ns   607 ns\nSemicompr.   long : 499 ns   526 ns   545 ns\nInteger           : 746 ns   731 ns   733 ns \nGMP          mpz_t: 451 ns   468 ns   482 ns +++\ntuple             : 785 ns   791 ns   822 ns ---\n```\n\n5. == for \"difficult\" unequal paths\n\n```\n                     5       100      1000\nUncompressed long : 1.65 us   22   us  213 us   ---\nUncompressed short: 1.15 us   12.8 us  140 us\nUncompressed char : 1.06 us   12.7 us  121 us\nCompressed   long :  706 ns    4.4 us   37.6 us\nCompressed   short:  754 ns    5.3 us   47.3 us\nSemicompr.   long :  506 ns    704 ns   2.5 us\nInteger           :  710 ns    719 ns   755 ns\nGMP          mpz_t:  448 ns    457 ns   470 ns  +++\ntuple             : 1.48 us   12.5 us  116 us\n```\n\n6. startswith\n\n```\n                     yes      no\nUncompressed long :  325 ns  311 ns\nUncompressed short:  336 ns  325 ns\nUncompressed char :  324 ns  315 ns\nCompressed   long :  272 ns  257 ns  +\nCompressed   short:  272 ns  256 ns  +\nSemicompr.   long :  263 ns  232 ns  ++\nInteger           : 2.46 us 2.45 us  \nGMP          mpz_t:  673 ns  657 ns\ntuple             : 4.7  us 4.72 us  --\n```\n\nSo, using tuples is best for concatenation of short paths, but that's the only case where it is not too slow.",
    "created_at": "2014-02-24T14:42:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199835",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:18" align="right">comment:18</div>

For completeness, I have added `Path_v6`, which uses Python's `tuple` under the hood (which is an obvious way to implement paths, too).

Result:

```
sage: %timeit p5*q5
1000000 loops, best of 3: 439 ns per loop
sage: %timeit p5*q25
1000000 loops, best of 3: 542 ns per loop
sage: %timeit p25*q25
1000000 loops, best of 3: 612 ns per loop
sage: %timeit p25*q50
1000000 loops, best of 3: 869 ns per loop
sage: %timeit p50*q50
1000000 loops, best of 3: 1.1 us per loop
sage: %timeit p50*q100
1000000 loops, best of 3: 1.39 us per loop
sage: %timeit p100*q100
1000000 loops, best of 3: 1.41 us per loop
sage: %timeit p100*q1000
100000 loops, best of 3: 5.04 us per loop
sage: %timeit p1000*q1000
100000 loops, best of 3: 11 us per loop
sage: %timeit hash(p5)
1000000 loops, best of 3: 245 ns per loop
sage: %timeit hash(p25)
1000000 loops, best of 3: 532 ns per loop
sage: %timeit hash(p50)
1000000 loops, best of 3: 884 ns per loop
sage: %timeit hash(p100)
1000000 loops, best of 3: 1.63 us per loop
sage: %timeit hash(p1000)
100000 loops, best of 3: 14.6 us per loop
sage: %timeit p5==s5
1000000 loops, best of 3: 885 ns per loop
sage: %timeit p25==s25
1000000 loops, best of 3: 1.71 us per loop
sage: %timeit p50==s50
100000 loops, best of 3: 2.63 us per loop
sage: %timeit p100==s100
100000 loops, best of 3: 4.53 us per loop
sage: %timeit p1000==s1000
10000 loops, best of 3: 39.3 us per loop
sage: %timeit p5==r5
1000000 loops, best of 3: 785 ns per loop
sage: %timeit p25==r25
1000000 loops, best of 3: 829 ns per loop
sage: %timeit p50==r50
1000000 loops, best of 3: 799 ns per loop
sage: %timeit p100==r100
1000000 loops, best of 3: 791 ns per loop
sage: %timeit p1000==r1000
1000000 loops, best of 3: 822 ns per loop
sage: %timeit q5==r5
1000000 loops, best of 3: 1.48 us per loop
sage: %timeit q25==r25
100000 loops, best of 3: 3.72 us per loop
sage: %timeit q50==r50
100000 loops, best of 3: 6.63 us per loop
sage: %timeit q100==r100
100000 loops, best of 3: 12.5 us per loop
sage: %timeit q1000==r1000
10000 loops, best of 3: 116 us per loop
sage: %timeit q1000.startswith(q100)
100000 loops, best of 3: 4.7 us per loop
sage: %timeit q1000.startswith(r100)
100000 loops, best of 3: 4.72 us per loop
```

The comparison with the other implementations becomes this:

1. Concatenation

```
                     5x5   50x50  1000x1000
Uncompressed long : 739 ns  885 ns 3.06 us  - -
Uncompressed short: 700 ns  808 ns 2.13 us
Uncompressed char : 679 ns  772 ns 1.31 us    +
Compressed   long : 676 ns  759 ns 1.61 us
Compressed   short: 718 ns  722 ns 1.98 us   +
Semicompr.   long : 684 ns  827 ns 1.42 us
Integer           : 645 ns 1.82 us 1.78 us   -
GMP          mpz_t: 723 ns  799 ns 1.41 us
tuple             : 439 ns  1.1 us 11   us  + -
```

2. Hash

```
                     5       100     1000
Uncompressed long : 135 ns  333 ns  2.09 us  +
Uncompressed short: 138 ns  383 ns  2.61 us  +--
Uncompressed char : 133 ns  374 ns  2.53 us  +
Compressed   long : 132 ns  155 ns   466 ns  +++
Compressed   short: 132 ns  206 ns   951 ns  +
Semicompr.   long : 148 ns  194 ns   594 ns
Integer           : 164 ns  274 ns  1.94 us  
GMP          mpz_t: 159 ns  266 ns  1.93 us
tuple             : 245 ns 1.63 us 14.6  us  ---
```

3. == for equal paths

```
                     5       100     1000
Uncompressed long : 1.63 us 23   us  212   us ---
Uncompressed short: 1.08 us 14.9 us  137   us
Uncompressed char : 1.08 us 12.5 us  121   us
Compressed   long :  710 ns  4.4 us   38   us
Compressed   short:  723 ns  5.3 us   47.5 us
Semicompr.   long :  498 ns  712 ns    2.4 us
Integer           :  667 ns  658 ns    817 ns
GMP          mpz_t:  466 ns  485 ns    693 ns +++
tuple             :  885 ns  4.5 us   39.3 us
```

4. == for "easily" unequal paths

```
                     5       100     1000
Uncompressed long : 634 ns   686 ns   698 ns
Uncompressed short: 613 ns   603 ns   635 ns
Uncompressed char : 581 ns   599 ns   636 ns
Compressed   long : 692 ns   729 ns   752 ns 
Compressed   short: 577 ns   588 ns   607 ns
Semicompr.   long : 499 ns   526 ns   545 ns
Integer           : 746 ns   731 ns   733 ns 
GMP          mpz_t: 451 ns   468 ns   482 ns +++
tuple             : 785 ns   791 ns   822 ns ---
```

5. == for "difficult" unequal paths

```
                     5       100      1000
Uncompressed long : 1.65 us   22   us  213 us   ---
Uncompressed short: 1.15 us   12.8 us  140 us
Uncompressed char : 1.06 us   12.7 us  121 us
Compressed   long :  706 ns    4.4 us   37.6 us
Compressed   short:  754 ns    5.3 us   47.3 us
Semicompr.   long :  506 ns    704 ns   2.5 us
Integer           :  710 ns    719 ns   755 ns
GMP          mpz_t:  448 ns    457 ns   470 ns  +++
tuple             : 1.48 us   12.5 us  116 us
```

6. startswith

```
                     yes      no
Uncompressed long :  325 ns  311 ns
Uncompressed short:  336 ns  325 ns
Uncompressed char :  324 ns  315 ns
Compressed   long :  272 ns  257 ns  +
Compressed   short:  272 ns  256 ns  +
Semicompr.   long :  263 ns  232 ns  ++
Integer           : 2.46 us 2.45 us  
GMP          mpz_t:  673 ns  657 ns
tuple             : 4.7  us 4.72 us  --
```

So, using tuples is best for concatenation of short paths, but that's the only case where it is not too slow.



---

archive/issue_comments_199836.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nWell, given the outcomes I guess it mostly depends on your own practical applications ?... `:-)`\n\nI also wonder (because I hate them) how much time is spent dealing with parents. But all your implementations have to go through that at the moment so it does not change your comparisons.\n\nWell, I am back to work at long long last. With a computer AND a screen. And in Brussels, which counts for the good mood `:-P`\n\nHave fuuuuuuuuuuuuuun !\n\nNathann",
    "created_at": "2014-03-04T16:54:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199836",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:19" align="right">comment:19</div>

Well, given the outcomes I guess it mostly depends on your own practical applications ?... `:-)`

I also wonder (because I hate them) how much time is spent dealing with parents. But all your implementations have to go through that at the moment so it does not change your comparisons.

Well, I am back to work at long long last. With a computer AND a screen. And in Brussels, which counts for the good mood `:-P`

Have fuuuuuuuuuuuuuun !

Nathann



---

archive/issue_comments_199837.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nHi Nathann,\n\nReplying to [@nathanncohen](#comment:19):\n> I also wonder (because I hate them) how much time is spent dealing with parents.\n\nWell, at some point parents *have* to come into play, namely when I want to implement not just sequences of bounded integers, but elements of the path semigroup of a quiver.\n\nThe strategical question is: Should the data defining a path be stored in an attribute of that path (the attribute would be an instance of `BoundedIntegerSequence`), or should the path itself be an instance of `BoundedIntegerSequence`? In the former case, it would be perfectly fine to have sequences of bounded integers parent-less; but I worry about an overhead of accessing the attribute. In the latter case, `BoundedIntegerSequence` should already be a sub-class of `sage.structure.element.Element` (and have a parent), since Cython does not allow multiple inheritance.\n\nI tend to the latter solution also for a different reason: Instances of `BoundedIntegerSequence` have to know the bound for their elements, because the data storage depends on that bound. For efficiency (see attachment), several other constants are derived from that bound, and used in the algorithms.\n\nShould each instance of `BoundedIntegerSequence` know about all these bounds? Or should there be a common parent for all sequences of integers that are bounded by a number B?\n\nI tend to the latter. If you assign *several* ints (the afore-mentioned constants) to an instance of `BoundedIntegerSequence`, it will likely be more time consuming (during initialisation) than to store just a single data (namely the parent).\n\nThat said, looking up the constants via the parent would be more time-consuming than looking up constants that are stored directly in the element.\n\nDifficult....",
    "created_at": "2014-03-04T18:46:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199837",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:20" align="right">comment:20</div>

Hi Nathann,

Replying to [@nathanncohen](#comment:19):
> I also wonder (because I hate them) how much time is spent dealing with parents.

Well, at some point parents *have* to come into play, namely when I want to implement not just sequences of bounded integers, but elements of the path semigroup of a quiver.

The strategical question is: Should the data defining a path be stored in an attribute of that path (the attribute would be an instance of `BoundedIntegerSequence`), or should the path itself be an instance of `BoundedIntegerSequence`? In the former case, it would be perfectly fine to have sequences of bounded integers parent-less; but I worry about an overhead of accessing the attribute. In the latter case, `BoundedIntegerSequence` should already be a sub-class of `sage.structure.element.Element` (and have a parent), since Cython does not allow multiple inheritance.

I tend to the latter solution also for a different reason: Instances of `BoundedIntegerSequence` have to know the bound for their elements, because the data storage depends on that bound. For efficiency (see attachment), several other constants are derived from that bound, and used in the algorithms.

Should each instance of `BoundedIntegerSequence` know about all these bounds? Or should there be a common parent for all sequences of integers that are bounded by a number B?

I tend to the latter. If you assign *several* ints (the afore-mentioned constants) to an instance of `BoundedIntegerSequence`, it will likely be more time consuming (during initialisation) than to store just a single data (namely the parent).

That said, looking up the constants via the parent would be more time-consuming than looking up constants that are stored directly in the element.

Difficult....



---

archive/issue_comments_199838.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nHellooooo Simon !\n\nHmmmm... All this is important to settle before implementing those BoundedIntegerSequences objects somewhere indeed.\n\nWhat I thought you intended was to write a very low-level data structure somewhere in the misc/ folder. The kind of stuff that one does not use by mistake, the kind of stuff that ones does not use without reading the manual first. So I thought it would not exactly check its input, trusting blindly the developer and being as efficient as possible.\n\nThen, I thought you would have a higher-level algebraic stuff with parents colors and blinking lights that would check their input indeed, and be what we want a user-friendly object to be.\n\nBut I actually have only one question: I don't know how you intend to use all this in the end, but I got the impression that several functions may have to generate a LOT of paths in order to compute some small data, and throw all the paths away once the computations have ended. Do you want do create high-level objects in those functions or not ?\n\nIf you don't, then perhaps you would be better with only low-level objects that you know how to use, which would not have to waste time (if time is actually wasted) on high-level problems.\n\nAnd so I thought that you high-level objects would have a variable which would be this low-level object, etc, etc... \n\nWhat do you have in mind ?\n\nNathann",
    "created_at": "2014-03-04T20:03:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199838",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:21" align="right">comment:21</div>

Hellooooo Simon !

Hmmmm... All this is important to settle before implementing those BoundedIntegerSequences objects somewhere indeed.

What I thought you intended was to write a very low-level data structure somewhere in the misc/ folder. The kind of stuff that one does not use by mistake, the kind of stuff that ones does not use without reading the manual first. So I thought it would not exactly check its input, trusting blindly the developer and being as efficient as possible.

Then, I thought you would have a higher-level algebraic stuff with parents colors and blinking lights that would check their input indeed, and be what we want a user-friendly object to be.

But I actually have only one question: I don't know how you intend to use all this in the end, but I got the impression that several functions may have to generate a LOT of paths in order to compute some small data, and throw all the paths away once the computations have ended. Do you want do create high-level objects in those functions or not ?

If you don't, then perhaps you would be better with only low-level objects that you know how to use, which would not have to waste time (if time is actually wasted) on high-level problems.

And so I thought that you high-level objects would have a variable which would be this low-level object, etc, etc... 

What do you have in mind ?

Nathann



---

archive/issue_comments_199839.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nHi Nathann,\n\nReplying to [@nathanncohen](#comment:21):\n> What I thought you intended was to write a very low-level data structure somewhere in the misc/ folder.\n\nI somehow do.\n\n> The kind of stuff that one does not use by mistake,\n\nWhy? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).\n\n> Then, I thought you would have a higher-level algebraic stuff with parents colors and blinking lights that would check their input indeed, and be what we want a user-friendly object to be.\n\nAgain *ideally*: Blinking colours should only be added when one really implements paths in quivers.\n\n> But I actually have only one question: I don't know how you intend to use all this in the end, but I got the impression that several functions may have to generate a LOT of paths in order to compute some small data, and throw all the paths away once the computations have ended. Do you want do create high-level objects in those functions or not ?\n\nGood point. So, you mean that these functions should actually *not* create fully-fledged quiver paths, but should just operate on instances of `BoundedIntegerSequence`, and only in the end interpret them as paths, when the battle smoke has vanished.\n\n> And so I thought that you high-level objects would have a variable which would be this low-level object, etc, etc... \n\nYes, probably that's better.\n\nSo, perhaps I should really do `cdef class BoundedIntegerSequence(tuple)` rather than `cdef class BoundedIntegerSequence(MonoidElement)`.\n\nBut then, what to do with all these internally used constants that are needed even for the low-level functionality of `BoundedIntegerSequence`? Would you prefer to compute and store these constants 10000 times when creating 10000 sequences of integers bounded by `B`? Or would you prefer to compute and store these constants only once, namely in a parent that hosts all sequences of integers with a fixed bound?\n\nOr do you have a third solution for storing/accessing these constants efficiently?",
    "created_at": "2014-03-04T21:13:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199839",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:22" align="right">comment:22</div>

Hi Nathann,

Replying to [@nathanncohen](#comment:21):
> What I thought you intended was to write a very low-level data structure somewhere in the misc/ folder.

I somehow do.

> The kind of stuff that one does not use by mistake,

Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).

> Then, I thought you would have a higher-level algebraic stuff with parents colors and blinking lights that would check their input indeed, and be what we want a user-friendly object to be.

Again *ideally*: Blinking colours should only be added when one really implements paths in quivers.

> But I actually have only one question: I don't know how you intend to use all this in the end, but I got the impression that several functions may have to generate a LOT of paths in order to compute some small data, and throw all the paths away once the computations have ended. Do you want do create high-level objects in those functions or not ?

Good point. So, you mean that these functions should actually *not* create fully-fledged quiver paths, but should just operate on instances of `BoundedIntegerSequence`, and only in the end interpret them as paths, when the battle smoke has vanished.

> And so I thought that you high-level objects would have a variable which would be this low-level object, etc, etc... 

Yes, probably that's better.

So, perhaps I should really do `cdef class BoundedIntegerSequence(tuple)` rather than `cdef class BoundedIntegerSequence(MonoidElement)`.

But then, what to do with all these internally used constants that are needed even for the low-level functionality of `BoundedIntegerSequence`? Would you prefer to compute and store these constants 10000 times when creating 10000 sequences of integers bounded by `B`? Or would you prefer to compute and store these constants only once, namely in a parent that hosts all sequences of integers with a fixed bound?

Or do you have a third solution for storing/accessing these constants efficiently?



---

archive/issue_comments_199840.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nHelloooooo !!\n\n> Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).\n\nWhy do you want it to inherit from tuple ? I do not know the effect of such a thing, what it brings and what should be feared\n\n> Good point. So, you mean that these functions should actually *not* create fully-fledged quiver paths, but should just operate on instances of `BoundedIntegerSequence`, and only in the end interpret them as paths, when the battle smoke has vanished.\n\nWell, yep. Only create the  high-level stuff with possible  overhead when you need it. And you end up knowing exactly what your code does when you are writing the code of your time-critical function.\n\n> So, perhaps I should really do `cdef class BoundedIntegerSequence(tuple)` rather than `cdef class BoundedIntegerSequence(MonoidElement)`.\n\nHmmm.. I still don't get why you want it to inherit from  tuple. My natural move would be to implement this as a C structure, not even a object `:-P`\n\n> But then, what to do with all these internally used constants that are needed even for the low-level functionality of `BoundedIntegerSequence`? Would you prefer to compute and store these constants 10000 times when creating 10000 sequences of integers bounded by `B`? Or would you prefer to compute and store these constants only once, namely in a parent that hosts all sequences of integers with a fixed bound?\n\nWell, somehow that's already what we do with graph backends. We have a Generic Backend, extended twice in  Dense Graphs and Sparse Graphs. And all the constants needed by the data structures are stored in the corresponding files. You could have a `BoundedIntegerSequence` class implementing no function at all, extended by alld ifferent implementations of the data structures you want. Even in the same file.\n\n... And we don't need parents for that `:-PPPP`\n\nNathann",
    "created_at": "2014-03-05T10:09:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199840",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:23" align="right">comment:23</div>

Helloooooo !!

> Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).

Why do you want it to inherit from tuple ? I do not know the effect of such a thing, what it brings and what should be feared

> Good point. So, you mean that these functions should actually *not* create fully-fledged quiver paths, but should just operate on instances of `BoundedIntegerSequence`, and only in the end interpret them as paths, when the battle smoke has vanished.

Well, yep. Only create the  high-level stuff with possible  overhead when you need it. And you end up knowing exactly what your code does when you are writing the code of your time-critical function.

> So, perhaps I should really do `cdef class BoundedIntegerSequence(tuple)` rather than `cdef class BoundedIntegerSequence(MonoidElement)`.

Hmmm.. I still don't get why you want it to inherit from  tuple. My natural move would be to implement this as a C structure, not even a object `:-P`

> But then, what to do with all these internally used constants that are needed even for the low-level functionality of `BoundedIntegerSequence`? Would you prefer to compute and store these constants 10000 times when creating 10000 sequences of integers bounded by `B`? Or would you prefer to compute and store these constants only once, namely in a parent that hosts all sequences of integers with a fixed bound?

Well, somehow that's already what we do with graph backends. We have a Generic Backend, extended twice in  Dense Graphs and Sparse Graphs. And all the constants needed by the data structures are stored in the corresponding files. You could have a `BoundedIntegerSequence` class implementing no function at all, extended by alld ifferent implementations of the data structures you want. Even in the same file.

... And we don't need parents for that `:-PPPP`

Nathann



---

archive/issue_comments_199841.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nReplying to [@nathanncohen](#comment:23):\n> > Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).\n\n> \n> Why do you want it to inherit from tuple ?\n\nBy analogy to `Sequence_generic` (which inherits from `list`):\n\n```\nsage: S = Sequence([1,2,3])\nsage: type(S)\n<class 'sage.structure.sequence.Sequence_generic'>\nsage: type(S).mro()\n[sage.structure.sequence.Sequence_generic,\n sage.structure.sage_object.SageObject,\n list,\n object]\n```\n\n> Well, somehow that's already what we do with graph backends. We have a Generic Backend, extended twice in  Dense Graphs and Sparse Graphs. And all the constants needed by the data structures are stored in the corresponding files.\n\nNo, that's a different situation. If you have a sequence `S1` of integers bounded by `B1` and a sequence `S2` of integers bounded by `B2` then the constants for `S1` are different from the constants of `S2`. So, it is not really a \"global\" constant that is shared by all instances of a certain data structure (and could thus be put into a file), but when you do, for example, `for x in B1` then you'll need *different* constants than when you do `for x in B2`.\n\nSo, these constants are not shared by all sequences, but by all sequence that share the same bound. Thus, it seems natural (to me, at least) to have one object `O(B)` that is shared by all sequences of bound `B`, so that `O(B)` provides the constants that belong to `B`.\n\nSure, `O(B)` could be written in C as well. But why not making it a parent, when all what we do is letting each sequence have a pointer to `O(B)`?",
    "created_at": "2014-03-05T11:24:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199841",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:24" align="right">comment:24</div>

Replying to [@nathanncohen](#comment:23):
> > Why? It should be a replacement for tuples (thus, low-level), but it should *ideally* be (close to) a drop-in replacement (thus, it doesn't matter whether one uses it by mistake).

> 
> Why do you want it to inherit from tuple ?

By analogy to `Sequence_generic` (which inherits from `list`):

```
sage: S = Sequence([1,2,3])
sage: type(S)
<class 'sage.structure.sequence.Sequence_generic'>
sage: type(S).mro()
[sage.structure.sequence.Sequence_generic,
 sage.structure.sage_object.SageObject,
 list,
 object]
```

> Well, somehow that's already what we do with graph backends. We have a Generic Backend, extended twice in  Dense Graphs and Sparse Graphs. And all the constants needed by the data structures are stored in the corresponding files.

No, that's a different situation. If you have a sequence `S1` of integers bounded by `B1` and a sequence `S2` of integers bounded by `B2` then the constants for `S1` are different from the constants of `S2`. So, it is not really a "global" constant that is shared by all instances of a certain data structure (and could thus be put into a file), but when you do, for example, `for x in B1` then you'll need *different* constants than when you do `for x in B2`.

So, these constants are not shared by all sequences, but by all sequence that share the same bound. Thus, it seems natural (to me, at least) to have one object `O(B)` that is shared by all sequences of bound `B`, so that `O(B)` provides the constants that belong to `B`.

Sure, `O(B)` could be written in C as well. But why not making it a parent, when all what we do is letting each sequence have a pointer to `O(B)`?



---

archive/issue_comments_199842.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\n> By analogy to `Sequence_generic` (which inherits from `list`):\n\n?...\n\nWell. And why is that a good idea ? `:-P`\n\n> No, that's a different situation. If you have a sequence `S1` of integers bounded by `B1` and a sequence `S2` of integers bounded by `B2` then the constants for `S1` are different from the constants of `S2`. So, it is not really a \"global\" constant that is shared by all instances of a certain data structure (and could thus be put into a file), but when you do, for example, `for x in B1` then you'll need *different* constants than when you do `for x in B2`.\n\nHmmmm... I see. Well, isn't your only parameter the number of bits you need to store each entry ? If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?\n\nIf it is a power of 2, then perhaps templates are sufficient, i.e. \"one data structure per value of this parameter\". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`\n\nI'd say.... 4,8,16,32 ? `:-)`\n\n> So, these constants are not shared by all sequences, but by all sequence that share the same bound. Thus, it seems natural (to me, at least) to have one object `O(B)` that is shared by all sequences of bound `B`, so that `O(B)` provides the constants that belong to `B`.\n\nIf your data structure is not an object, you could also add this width parameter as an input of the functions you use ? I guess all Bounded Sequence Integer that you use in the same function would have the same bound.\n\nBut admittedly I love to split hairs. Tell me if you think that this is going too far `:-P`\n\n> Sure, `O(B)` could be written in C as well. But why not making it a parent, when all what we do is letting each sequence have a pointer to `O(B)`?\n\nAhahahah. That's up to you. I just hate Sage's parents/elements. I would live happy with a C pointer I can  control, but not witha framework that I do not understand. If you understand it, then you know what you are doing. I don't `:-P`\n\nNathann",
    "created_at": "2014-03-05T11:37:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199842",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:25" align="right">comment:25</div>

> By analogy to `Sequence_generic` (which inherits from `list`):

?...

Well. And why is that a good idea ? `:-P`

> No, that's a different situation. If you have a sequence `S1` of integers bounded by `B1` and a sequence `S2` of integers bounded by `B2` then the constants for `S1` are different from the constants of `S2`. So, it is not really a "global" constant that is shared by all instances of a certain data structure (and could thus be put into a file), but when you do, for example, `for x in B1` then you'll need *different* constants than when you do `for x in B2`.

Hmmmm... I see. Well, isn't your only parameter the number of bits you need to store each entry ? If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?

If it is a power of 2, then perhaps templates are sufficient, i.e. "one data structure per value of this parameter". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`

I'd say.... 4,8,16,32 ? `:-)`

> So, these constants are not shared by all sequences, but by all sequence that share the same bound. Thus, it seems natural (to me, at least) to have one object `O(B)` that is shared by all sequences of bound `B`, so that `O(B)` provides the constants that belong to `B`.

If your data structure is not an object, you could also add this width parameter as an input of the functions you use ? I guess all Bounded Sequence Integer that you use in the same function would have the same bound.

But admittedly I love to split hairs. Tell me if you think that this is going too far `:-P`

> Sure, `O(B)` could be written in C as well. But why not making it a parent, when all what we do is letting each sequence have a pointer to `O(B)`?

Ahahahah. That's up to you. I just hate Sage's parents/elements. I would live happy with a C pointer I can  control, but not witha framework that I do not understand. If you understand it, then you know what you are doing. I don't `:-P`

Nathann



---

archive/issue_comments_199843.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nReplying to [@nathanncohen](#comment:25):\n> Hmmmm... I see. Well, isn't your only parameter the number of bits you need to store each entry ?\n\nNo. We have\n\n```c\ncdef Integer NumberArrows\ncdef Integer IntegerMask\ncdef size_t ArrowBitSize, BigArrowBitSize\ncdef block* bitmask = NULL\ncdef block DataMask, BitMask\ncdef size_t ArrowsPerBlock, BigArrowsPerBlock\ncdef size_t ModBAPB, DivBAPB, TimesBABS, TimesBlockSize\n```\n\nFor example, `ModBAPB` is used to replace `n%BigArrowsPerBlock` by a bit-wise `and`, which is noticeably faster.\n\n> If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?\n\nDepending on the implementation...\n\n\n> If it is a power of 2, then perhaps templates are sufficient, i.e. \"one data structure per value of this parameter\". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`\n\nIsn't duplication of code supposed to smell?\n\n> If your data structure is not an object, you could also add this width parameter as an input of the functions you use ? I guess all Bounded Sequence Integer that you use in the same function would have the same bound.\n\nDo I understand correctly: You suggest that we should *not* provide a class `BoundedIntegerSequence` that can be used interactively in Sage, but you suggest that we should just provide a couple of functions that operate on C structures (say, `mpz_t` or `usigned long*`) and can only be used in Cython code?\n\nThen it would be better to revert this ticket to its original purpose: There would be...\n1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,\n2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,\n3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).\n\n> But admittedly I love to split hairs. Tell me if you think that this is going too far `:-P`\n\nNo problem. I just want to know if people see the need to have a Cython implementation of sequences of bounded integers, for use in Python.\n\n> Ahahahah. That's up to you. I just hate Sage's parents/elements. I would live happy with a C pointer I can  control, but not witha framework that I do not understand.\n\nMaking it something like a container rather than a fully fledged parent would be an option, from my perspective.",
    "created_at": "2014-03-05T20:03:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199843",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:26" align="right">comment:26</div>

Replying to [@nathanncohen](#comment:25):
> Hmmmm... I see. Well, isn't your only parameter the number of bits you need to store each entry ?

No. We have

```c
cdef Integer NumberArrows
cdef Integer IntegerMask
cdef size_t ArrowBitSize, BigArrowBitSize
cdef block* bitmask = NULL
cdef block DataMask, BitMask
cdef size_t ArrowsPerBlock, BigArrowsPerBlock
cdef size_t ModBAPB, DivBAPB, TimesBABS, TimesBlockSize
```

For example, `ModBAPB` is used to replace `n%BigArrowsPerBlock` by a bit-wise `and`, which is noticeably faster.

> If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?

Depending on the implementation...


> If it is a power of 2, then perhaps templates are sufficient, i.e. "one data structure per value of this parameter". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`

Isn't duplication of code supposed to smell?

> If your data structure is not an object, you could also add this width parameter as an input of the functions you use ? I guess all Bounded Sequence Integer that you use in the same function would have the same bound.

Do I understand correctly: You suggest that we should *not* provide a class `BoundedIntegerSequence` that can be used interactively in Sage, but you suggest that we should just provide a couple of functions that operate on C structures (say, `mpz_t` or `usigned long*`) and can only be used in Cython code?

Then it would be better to revert this ticket to its original purpose: There would be...
1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,
2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,
3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).

> But admittedly I love to split hairs. Tell me if you think that this is going too far `:-P`

No problem. I just want to know if people see the need to have a Cython implementation of sequences of bounded integers, for use in Python.

> Ahahahah. That's up to you. I just hate Sage's parents/elements. I would live happy with a C pointer I can  control, but not witha framework that I do not understand.

Making it something like a container rather than a fully fledged parent would be an option, from my perspective.



---

archive/issue_comments_199844.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nReplying to [@simon-king-jena](#comment:26):\n> Making it something like a container rather than a fully fledged parent would be an option, from my perspective.\n\n...  I mean, for `BoundedIntegerSequence`. Of course, `Path` must have a parent (the path semigroup of a quiver).",
    "created_at": "2014-03-05T20:04:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199844",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:27" align="right">comment:27</div>

Replying to [@simon-king-jena](#comment:26):
> Making it something like a container rather than a fully fledged parent would be an option, from my perspective.

...  I mean, for `BoundedIntegerSequence`. Of course, `Path` must have a parent (the path semigroup of a quiver).



---

archive/issue_comments_199845.json:
```json
{
    "body": "<div id=\"comment:28\" align=\"right\">comment:28</div>\n\nJust a random thought. Some issues here are of the same nature as what was discussed around ClonableElement and its subclasses. Maybe there is stuff to share with it, especially if one ends up inheriting from Element.",
    "created_at": "2014-03-07T08:56:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199845",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:28" align="right">comment:28</div>

Just a random thought. Some issues here are of the same nature as what was discussed around ClonableElement and its subclasses. Maybe there is stuff to share with it, especially if one ends up inheriting from Element.



---

archive/issue_comments_199846.json:
```json
{
    "body": "<div id=\"comment:29\" align=\"right\">comment:29</div>\n\nI just had a look at `ClonableElement`, and one immediate thought is: Why are C-pointers allocated in `__init__`? That's clearly the purpose of `__cinit__`, in particular if said C-pointers are freed in `__dealloc__`.\n\nDo we want to have sequences of bounded integers for use in Python? Then one possible way would be:\n\n- have some inline cdef functions that operate on certain (templated?) C data structures\n- use these in a sub-class of `ClonableElement` (so that we can have sequences of bounded integers used in python)\n- use these in a `Path` class, to be used in path semigroups.",
    "created_at": "2014-03-07T09:13:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199846",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:29" align="right">comment:29</div>

I just had a look at `ClonableElement`, and one immediate thought is: Why are C-pointers allocated in `__init__`? That's clearly the purpose of `__cinit__`, in particular if said C-pointers are freed in `__dealloc__`.

Do we want to have sequences of bounded integers for use in Python? Then one possible way would be:

- have some inline cdef functions that operate on certain (templated?) C data structures
- use these in a sub-class of `ClonableElement` (so that we can have sequences of bounded integers used in python)
- use these in a `Path` class, to be used in path semigroups.



---

archive/issue_comments_199847.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nYooooooo !!!\n\n> No. We have\n> \n> ```c\n> cdef Integer NumberArrows\n> cdef Integer IntegerMask\n> cdef size_t ArrowBitSize, BigArrowBitSize\n> cdef block* bitmask = NULL\n> cdef block DataMask, BitMask\n> cdef size_t ArrowsPerBlock, BigArrowsPerBlock\n> cdef size_t ModBAPB, DivBAPB, TimesBABS, TimesBlockSize\n> ```\n\nHmmmm.. Can't they all be deduced from the type of implementation (compressed long, for instance) and the number  of bits per entry then ?\n> \n> For example, `ModBAPB` is used to replace `n%BigArrowsPerBlock` by a bit-wise `and`, which is noticeably faster.\n\nYepyep of course.\n\n> > If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?\n\n> \n> Depending on the implementation...\n\nOkay....\n\n> > If it is a power of 2, then perhaps templates are sufficient, i.e. \"one data structure per value of this parameter\". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`\n\n> \n> Isn't duplication of code supposed to smell?\n\nWell, if it is a template the code is only implemented once. And it will generate several data structures at compile time indeed, but each of them will have a hardcoded constant, and  you only implement one.\n\n> Do I understand correctly: You suggest that we should *not* provide a class `BoundedIntegerSequence` that can be used interactively in Sage, but you suggest that we should just provide a couple of functions that operate on C structures (say, `mpz_t` or `usigned long*`) and can only be used in Cython code?\n\nThat's what I had in mind, but you make decisions here, pick what you like.\n\nIt's a bit how bitsets are implemented. A C data structure, and an object wrapper on top of it. Or C Graphs, with a data structure on top of it. It is how Permutations should be implemented, too `:-P`\n\nWell, you have a C object that you use when you want performance, and when you don't care you use the higher-level implementations.\n\n> Then it would be better to revert this ticket to its original purpose: There would be...\n> 1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,\n> 2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,\n> 3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).\n\nWell, I like this plan. What do you think ? Does it displease you in any way ?\n\n> No problem. I just want to know if people see the need to have a Cython implementation of sequences of bounded integers, for use in Python.\n\nI do not see how I could use it in my code at the moment, but I like the idea of having such a data structure somewhere, ready to be used. Most importantly, if you want speed, I think  that having it available at two different levels is a safe bet. You write more code, but you will know how computations are spent in your time-critical functions.\n\nNathann",
    "created_at": "2014-03-07T09:28:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199847",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:30" align="right">comment:30</div>

Yooooooo !!!

> No. We have
> 
> ```c
> cdef Integer NumberArrows
> cdef Integer IntegerMask
> cdef size_t ArrowBitSize, BigArrowBitSize
> cdef block* bitmask = NULL
> cdef block DataMask, BitMask
> cdef size_t ArrowsPerBlock, BigArrowsPerBlock
> cdef size_t ModBAPB, DivBAPB, TimesBABS, TimesBlockSize
> ```

Hmmmm.. Can't they all be deduced from the type of implementation (compressed long, for instance) and the number  of bits per entry then ?
> 
> For example, `ModBAPB` is used to replace `n%BigArrowsPerBlock` by a bit-wise `and`, which is noticeably faster.

Yepyep of course.

> > If it is, did you decided whether you want to allow it to be arbitrary, or if you want it to be a power of 2 ?

> 
> Depending on the implementation...

Okay....

> > If it is a power of 2, then perhaps templates are sufficient, i.e. "one data structure per value of this parameter". There are not so many powers of 2 between 1 and 64 that make sense to store something `:-)`

> 
> Isn't duplication of code supposed to smell?

Well, if it is a template the code is only implemented once. And it will generate several data structures at compile time indeed, but each of them will have a hardcoded constant, and  you only implement one.

> Do I understand correctly: You suggest that we should *not* provide a class `BoundedIntegerSequence` that can be used interactively in Sage, but you suggest that we should just provide a couple of functions that operate on C structures (say, `mpz_t` or `usigned long*`) and can only be used in Cython code?

That's what I had in mind, but you make decisions here, pick what you like.

It's a bit how bitsets are implemented. A C data structure, and an object wrapper on top of it. Or C Graphs, with a data structure on top of it. It is how Permutations should be implemented, too `:-P`

Well, you have a C object that you use when you want performance, and when you don't care you use the higher-level implementations.

> Then it would be better to revert this ticket to its original purpose: There would be...
> 1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,
> 2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,
> 3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).

Well, I like this plan. What do you think ? Does it displease you in any way ?

> No problem. I just want to know if people see the need to have a Cython implementation of sequences of bounded integers, for use in Python.

I do not see how I could use it in my code at the moment, but I like the idea of having such a data structure somewhere, ready to be used. Most importantly, if you want speed, I think  that having it available at two different levels is a safe bet. You write more code, but you will know how computations are spent in your time-critical functions.

Nathann



---

archive/issue_comments_199848.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">comment:31</div>\n\nHi Nathann,\n\nReplying to [@nathanncohen](#comment:30):\n> Hmmmm.. Can't they all be deduced from the type of implementation (compressed long, for instance) and the number  of bits per entry then ?\n\nSure. And you want to do this same computation `10^7` times?\n\n> > Isn't duplication of code supposed to smell?\n\n> \n> Well, if it is a template the code is only implemented once. And it will generate several data structures at compile time indeed, but each of them will have a hardcoded constant, and  you only implement one.\n\nYes. Probably my problem is that I don't think \"C++\", but I think \"Cython\". And there it is a bit clumsy (I think templating is mimicked in Cython by including .pxi files, isn't it?).\n \n> That's what I had in mind, but you make decisions here, pick what you like.\n> \n> It's a bit how bitsets are implemented.\n\nRight, that's what I have looked at, and think makes sense here. Up to the constants.\n\n> > Then it would be better to revert this ticket to its original purpose: There would be...\n> > 1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,\n> > 2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,\n> > 3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).\n\n> \n> Well, I like this plan. What do you think ? Does it displease you in any way ?\n\nNo, it is one possibility.",
    "created_at": "2014-03-07T09:48:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199848",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:31" align="right">comment:31</div>

Hi Nathann,

Replying to [@nathanncohen](#comment:30):
> Hmmmm.. Can't they all be deduced from the type of implementation (compressed long, for instance) and the number  of bits per entry then ?

Sure. And you want to do this same computation `10^7` times?

> > Isn't duplication of code supposed to smell?

> 
> Well, if it is a template the code is only implemented once. And it will generate several data structures at compile time indeed, but each of them will have a hardcoded constant, and  you only implement one.

Yes. Probably my problem is that I don't think "C++", but I think "Cython". And there it is a bit clumsy (I think templating is mimicked in Cython by including .pxi files, isn't it?).
 
> That's what I had in mind, but you make decisions here, pick what you like.
> 
> It's a bit how bitsets are implemented.

Right, that's what I have looked at, and think makes sense here. Up to the constants.

> > Then it would be better to revert this ticket to its original purpose: There would be...
> > 1. ... cdef functions operating on `mpz_t` resp. on `unsigned long*`,
> > 2. ... a Cython class `Path` using `mpz_t` resp. `unsigned long*` as a cdef attribute, using the afore mentioned functions to implement concatenation and iteration,
> > 3. ... a subsequent ticket, implementing an F5 style algorithm to compute standard bases, operating not with `Path` but with `mpz_t*` resp `unsigned long**` (which will be the case anyway).

> 
> Well, I like this plan. What do you think ? Does it displease you in any way ?

No, it is one possibility.



---

archive/issue_comments_199849.json:
```json
{
    "body": "<div id=\"comment:33\" align=\"right\">comment:33</div>\n\n> Sure. And you want to do this same computation `10^7` times?\n\nI don't get it. If the width is a power of two, then there are 6 possible values, i.e. 2^1, 2^2, 2^3, 2^4, 2^5, 2^6. Otherwise you have at most 64, but really who cares in the end ?\n\n> Yes. Probably my problem is that I don't think \"C++\", but I think \"Cython\". And there it is a bit clumsy (I think templating is mimicked in Cython by including .pxi files, isn't it?).\n\nI am thinking of this :\nhttp://stackoverflow.com/questions/4840819/c-template-specialization-with-constant-value\n\nThat's C++, and I don't see how to do it in Cython, though. The point is that you can parameter a data structure with a constant value, and the data structure will be compiled for each value of the constant *that appears in the code at compile-time* (not all possible values, or course). The point is that the code is optimized while knowing the value(which can lead to optimization) and also that  you can do things that would not be possible otherwise, like \"cdef int a[k]\" where k is a (templated) variable.\n\nNathann",
    "created_at": "2014-03-07T12:15:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199849",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:33" align="right">comment:33</div>

> Sure. And you want to do this same computation `10^7` times?

I don't get it. If the width is a power of two, then there are 6 possible values, i.e. 2^1, 2^2, 2^3, 2^4, 2^5, 2^6. Otherwise you have at most 64, but really who cares in the end ?

> Yes. Probably my problem is that I don't think "C++", but I think "Cython". And there it is a bit clumsy (I think templating is mimicked in Cython by including .pxi files, isn't it?).

I am thinking of this :
http://stackoverflow.com/questions/4840819/c-template-specialization-with-constant-value

That's C++, and I don't see how to do it in Cython, though. The point is that you can parameter a data structure with a constant value, and the data structure will be compiled for each value of the constant *that appears in the code at compile-time* (not all possible values, or course). The point is that the code is optimized while knowing the value(which can lead to optimization) and also that  you can do things that would not be possible otherwise, like "cdef int a[k]" where k is a (templated) variable.

Nathann



---

archive/issue_comments_199850.json:
```json
{
    "body": "<div id=\"comment:34\" align=\"right\">comment:34</div>\n\nReplying to [@nathanncohen](#comment:33):\n> > Sure. And you want to do this same computation `10^7` times?\n\n> \n> I don't get it. If the width is a power of two, then there are 6 possible values, i.e. 2^1, 2^2, 2^3, 2^4, 2^5, 2^6. Otherwise you have at most 64, but really who cares in the end ?\n\nApparently I am not used to templated code...\n\nI was somehow thinking that you suggested to keep the bitlength of the upper bound for the integers as the *only* parameter, which means that you would need to compute all the other things either for each operation or (when storing it as attribute of the sequences) for each sequence.\n\n> I am thinking of this :\n> http://stackoverflow.com/questions/4840819/c-template-specialization-with-constant-value\n> \n> That's C++, and I don't see how to do it in Cython, though.\n\nPart of the question is: Do we want to use gmp as backend? Or do we want to (re-)implement operations on densely packed `long*` by ourselves? Given the timings, gmp *is* an option.\n\nAnyway, I'll have a look at the stackoverflow discussion. Thank you for the pointer!\n\nThe next question then is how to access the code from Cython. I've done this with C, but not C++.",
    "created_at": "2014-03-07T13:20:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199850",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:34" align="right">comment:34</div>

Replying to [@nathanncohen](#comment:33):
> > Sure. And you want to do this same computation `10^7` times?

> 
> I don't get it. If the width is a power of two, then there are 6 possible values, i.e. 2^1, 2^2, 2^3, 2^4, 2^5, 2^6. Otherwise you have at most 64, but really who cares in the end ?

Apparently I am not used to templated code...

I was somehow thinking that you suggested to keep the bitlength of the upper bound for the integers as the *only* parameter, which means that you would need to compute all the other things either for each operation or (when storing it as attribute of the sequences) for each sequence.

> I am thinking of this :
> http://stackoverflow.com/questions/4840819/c-template-specialization-with-constant-value
> 
> That's C++, and I don't see how to do it in Cython, though.

Part of the question is: Do we want to use gmp as backend? Or do we want to (re-)implement operations on densely packed `long*` by ourselves? Given the timings, gmp *is* an option.

Anyway, I'll have a look at the stackoverflow discussion. Thank you for the pointer!

The next question then is how to access the code from Cython. I've done this with C, but not C++.



---

archive/issue_comments_199851.json:
```json
{
    "body": "<div id=\"comment:35\" align=\"right\">comment:35</div>\n\n> Apparently I am not used to templated code...\n> \n> I was somehow thinking that you suggested to keep the bitlength of the upper bound for the integers as the *only* parameter, which means that you would need to compute all the other things either for each operation or (when storing it as attribute of the sequences) for each sequence.\n\nNonono. Somehow, you can think of templates as a way to \"script\" the generation of code. You write some code with a constant k which is never defined anywhere, and then you say \"compile one  version of this code for each k in 1, 2, 3, 4, 5, 6. You end up with several data structures implemented, each with a hardcoded value. And then you can create an object `cdef LongCompressedPath<5> my_path` in which the hardcoded bound is `2^5`. You just have many additional types, each  with  its own constant.\n\n> Part of the question is: Do we want to use gmp as backend? Or do we want to (re-)implement operations on densely packed `long*` by ourselves? Given the timings, gmp *is* an option.\n\nYep, you are right. Depends on how you weight the operations that you will need: it looks okay for concatenations and bad for startwith, but I expect that the most time consuming operation will be concatenation ? You are the one who needs it `:-)`\n\n> Anyway, I'll have a look at the stackoverflow discussion. Thank you for the pointer!\n> \n> The next question then is how to access the code from Cython. I've done this with C, but not C++.\n\nHMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?\n\nNathann",
    "created_at": "2014-03-07T13:35:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199851",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:35" align="right">comment:35</div>

> Apparently I am not used to templated code...
> 
> I was somehow thinking that you suggested to keep the bitlength of the upper bound for the integers as the *only* parameter, which means that you would need to compute all the other things either for each operation or (when storing it as attribute of the sequences) for each sequence.

Nonono. Somehow, you can think of templates as a way to "script" the generation of code. You write some code with a constant k which is never defined anywhere, and then you say "compile one  version of this code for each k in 1, 2, 3, 4, 5, 6. You end up with several data structures implemented, each with a hardcoded value. And then you can create an object `cdef LongCompressedPath<5> my_path` in which the hardcoded bound is `2^5`. You just have many additional types, each  with  its own constant.

> Part of the question is: Do we want to use gmp as backend? Or do we want to (re-)implement operations on densely packed `long*` by ourselves? Given the timings, gmp *is* an option.

Yep, you are right. Depends on how you weight the operations that you will need: it looks okay for concatenations and bad for startwith, but I expect that the most time consuming operation will be concatenation ? You are the one who needs it `:-)`

> Anyway, I'll have a look at the stackoverflow discussion. Thank you for the pointer!
> 
> The next question then is how to access the code from Cython. I've done this with C, but not C++.

HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?

Nathann



---

archive/issue_events_225894.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "milestone_number": null,
    "milestone_title": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225894"
}
```



---

archive/issue_events_225895.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "milestone_number": null,
    "milestone_title": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225895"
}
```



---

archive/issue_comments_199852.json:
```json
{
    "body": "<div id=\"comment:37\" align=\"right\">comment:37</div>\n\nHi Nathann,\n\nsorry for the long silence!\n\nReplying to [@nathanncohen](#comment:35):\n> HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?\n\nDid you find out how templated code can be written in Cython? If you have asked on cython-devel (so far I have only posted on cython-users) or have another pointer, then please tell me. If not, tell me also...\n\nCheers,\nSimon",
    "created_at": "2014-05-11T16:05:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199852",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:37" align="right">comment:37</div>

Hi Nathann,

sorry for the long silence!

Replying to [@nathanncohen](#comment:35):
> HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?

Did you find out how templated code can be written in Cython? If you have asked on cython-devel (so far I have only posted on cython-users) or have another pointer, then please tell me. If not, tell me also...

Cheers,
Simon



---

archive/issue_comments_199853.json:
```json
{
    "body": "<div id=\"comment:38\" align=\"right\">comment:38</div>\n\nHi Nathann,\n\nwouldn't the following be close to templates?\n\nIn Cython:\n\n```\ncimport cython\n\nctypedef fused str_or_int:\n    str\n    int\n\ncpdef str_or_int times_two(str_or_int var):\n    return var+var\n\ndef show_me():\n    cdef str a = 'a'\n    cdef int b = 3\n    print 'str', times_two(a)\n    print 'int', times_two(b)\n```\nand this results in\n\n```\nsage: show_me()\nstr aa\nint 6\n```",
    "created_at": "2014-05-11T16:26:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199853",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:38" align="right">comment:38</div>

Hi Nathann,

wouldn't the following be close to templates?

In Cython:

```
cimport cython

ctypedef fused str_or_int:
    str
    int

cpdef str_or_int times_two(str_or_int var):
    return var+var

def show_me():
    cdef str a = 'a'
    cdef int b = 3
    print 'str', times_two(a)
    print 'int', times_two(b)
```
and this results in

```
sage: show_me()
str aa
int 6
```



---

archive/issue_comments_199854.json:
```json
{
    "body": "<div id=\"comment:39\" align=\"right\">comment:39</div>\n\nOr perhaps a better example, showing that the fused type is used to choose code at compile time: Put the following into a cell of the notebook\n\n```\n%cython\ncimport cython\n\nctypedef fused str_or_int:\n    str\n    int\ncpdef str_or_int times_two(str_or_int var):\n    if str_or_int is int:\n        return var*2\n    else:\n        return var+var\ndef test():\n    cdef int a = 3\n    cdef str b = 'b'\n    a = times_two(a)\n    b = times_two(b)\n```\nand look at the resulting code. The line `a = times_two(a)` becomes\n\n```\n __pyx_v_a = __pyx_fuse_1__pyx_f_68_home_king__sage_sage_notebook_sagenb_home_admin_2_code_sage4_spyx_0_times_two(__pyx_v_a, 0);\n```\nwhereas `b = times_two(b)` becomes\n\n```\n__pyx_t_1 = __pyx_fuse_0__pyx_f_68_home_king__sage_sage_notebook_sagenb_home_admin_2_code_sage4_spyx_0_times_two(__pyx_v_b, 0);\n```\nand one can check that Cython created two different C-functions `__pyx_fuse_0...` and `__pyx_fuse_1...` for the two possible (type-dependent!) versions of `times_two`.",
    "created_at": "2014-05-11T16:53:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199854",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:39" align="right">comment:39</div>

Or perhaps a better example, showing that the fused type is used to choose code at compile time: Put the following into a cell of the notebook

```
%cython
cimport cython

ctypedef fused str_or_int:
    str
    int
cpdef str_or_int times_two(str_or_int var):
    if str_or_int is int:
        return var*2
    else:
        return var+var
def test():
    cdef int a = 3
    cdef str b = 'b'
    a = times_two(a)
    b = times_two(b)
```
and look at the resulting code. The line `a = times_two(a)` becomes

```
 __pyx_v_a = __pyx_fuse_1__pyx_f_68_home_king__sage_sage_notebook_sagenb_home_admin_2_code_sage4_spyx_0_times_two(__pyx_v_a, 0);
```
whereas `b = times_two(b)` becomes

```
__pyx_t_1 = __pyx_fuse_0__pyx_f_68_home_king__sage_sage_notebook_sagenb_home_admin_2_code_sage4_spyx_0_times_two(__pyx_v_b, 0);
```
and one can check that Cython created two different C-functions `__pyx_fuse_0...` and `__pyx_fuse_1...` for the two possible (type-dependent!) versions of `times_two`.



---

archive/issue_comments_199855.json:
```json
{
    "body": "<div id=\"comment:40\" align=\"right\">comment:40</div>\n\nAnd here an example showing that it pays off, speed-wise:\n\nIn a .pyx file:\n\n```\ncimport cython\n\nctypedef fused str_or_int:\n    str\n    int\n\ncpdef str_or_int times_two(str_or_int var):\n    if str_or_int is int:\n        return var+var\n    else:\n        return var+var\n\ncpdef untyped_times_two(var):\n    return var+var\n\ncpdef int int_times_two(int var):\n    return var+var\n\ncpdef str str_times_two(str var):\n    return var+var\n\ndef test1():\n    cdef int a = 3\n    cdef str b = 'b'\n    a = times_two(a)\n    b = times_two(b)\n\ndef test2():\n    cdef int a = 3\n    cdef str b = 'b'\n    a = untyped_times_two(a)\n    b = untyped_times_two(b)\n\ndef test3():\n    cdef int a = 3\n    cdef str b = 'b'\n    a = int_times_two(a)\n    b = str_times_two(b)\n```\nAttach the .pyx file to Sage, and get this:\n\n```\nage: %attach /home/king/Sage/work/templates/test.pyx\nCompiling /home/king/Sage/work/templates/test.pyx...\nsage: %timeit test1()\n10000000 loops, best of 3: 159 ns per loop\nsage: %timeit test2()\n1000000 loops, best of 3: 199 ns per loop\nsage: %timeit test3()\n10000000 loops, best of 3: 168 ns per loop\n```\n\nEDIT: I have replaced the original example by something fairer, where it says `var+var` everywhere, but in the templated version Cython can choose the c-implementation of `var+var` at compile time, whereas it can't (and hence loses time when running the code) in the untemplated version.\n\nEDIT 2: The new example also shows that choosing a specialised implementation manually is not faster than Cython using templates.",
    "created_at": "2014-05-11T16:59:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199855",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:40" align="right">comment:40</div>

And here an example showing that it pays off, speed-wise:

In a .pyx file:

```
cimport cython

ctypedef fused str_or_int:
    str
    int

cpdef str_or_int times_two(str_or_int var):
    if str_or_int is int:
        return var+var
    else:
        return var+var

cpdef untyped_times_two(var):
    return var+var

cpdef int int_times_two(int var):
    return var+var

cpdef str str_times_two(str var):
    return var+var

def test1():
    cdef int a = 3
    cdef str b = 'b'
    a = times_two(a)
    b = times_two(b)

def test2():
    cdef int a = 3
    cdef str b = 'b'
    a = untyped_times_two(a)
    b = untyped_times_two(b)

def test3():
    cdef int a = 3
    cdef str b = 'b'
    a = int_times_two(a)
    b = str_times_two(b)
```
Attach the .pyx file to Sage, and get this:

```
age: %attach /home/king/Sage/work/templates/test.pyx
Compiling /home/king/Sage/work/templates/test.pyx...
sage: %timeit test1()
10000000 loops, best of 3: 159 ns per loop
sage: %timeit test2()
1000000 loops, best of 3: 199 ns per loop
sage: %timeit test3()
10000000 loops, best of 3: 168 ns per loop
```

EDIT: I have replaced the original example by something fairer, where it says `var+var` everywhere, but in the templated version Cython can choose the c-implementation of `var+var` at compile time, whereas it can't (and hence loses time when running the code) in the untemplated version.

EDIT 2: The new example also shows that choosing a specialised implementation manually is not faster than Cython using templates.



---

archive/issue_comments_199856.json:
```json
{
    "body": "<div id=\"comment:41\" align=\"right\">comment:41</div>\n\nHellooooooooooooooooo !!!\n\n> EDIT: I have replaced the original example by something fairer, where it says `var+var` everywhere, but in the templated version Cython can choose the c-implementation of `var+var` at compile time, whereas it can't (and hence loses time when running the code) in the untemplated version.\n\nHMmmmmm... Does it make any difference ? gcc should resolve those \"if\" at compile-time, so if Cython creates two version of the function with an \"if\" inside depending on the type, gcc should not include it in the final binary as the constants involved can be defined at compile-time.\n\nAnyway, that's a good news ! `:-D`\n\nNathann",
    "created_at": "2014-05-12T10:05:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199856",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:41" align="right">comment:41</div>

Hellooooooooooooooooo !!!

> EDIT: I have replaced the original example by something fairer, where it says `var+var` everywhere, but in the templated version Cython can choose the c-implementation of `var+var` at compile time, whereas it can't (and hence loses time when running the code) in the untemplated version.

HMmmmmm... Does it make any difference ? gcc should resolve those "if" at compile-time, so if Cython creates two version of the function with an "if" inside depending on the type, gcc should not include it in the final binary as the constants involved can be defined at compile-time.

Anyway, that's a good news ! `:-D`

Nathann



---

archive/issue_comments_199857.json:
```json
{
    "body": "<div id=\"comment:42\" align=\"right\">comment:42</div>\n\nYooooooooooo !!\n\n> > HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?\n\n> \n> Did you find out how templated code can be written in Cython? If you have asked on cython-devel (so far I have only posted on cython-users) or have another pointer, then please tell me. If not, tell me also...\n\nAhahah.. Well, no ... When I ask a question I do not do anything before I get an answer, soooooooooo I never did it `:-P`\n\nI ask a question, then forget everything about it. When I get the answer I do what should be done `:-P`\n\nNathann",
    "created_at": "2014-05-12T10:06:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199857",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:42" align="right">comment:42</div>

Yooooooooooo !!

> > HMmmmmmm.... There is a C++ interface in numerical/backends/coin_backend.pyx but it does not play with templates. I am interested in knowing if this kind of templates can be written in pure Cython, do you mind if I ask the question on cython-devel (did you want to send one yourself) ?

> 
> Did you find out how templated code can be written in Cython? If you have asked on cython-devel (so far I have only posted on cython-users) or have another pointer, then please tell me. If not, tell me also...

Ahahah.. Well, no ... When I ask a question I do not do anything before I get an answer, soooooooooo I never did it `:-P`

I ask a question, then forget everything about it. When I get the answer I do what should be done `:-P`

Nathann



---

archive/issue_comments_199858.json:
```json
{
    "body": "<div id=\"comment:43\" align=\"right\">comment:43</div>\n\nHi Nathann,\n\nReplying to [@nathanncohen](#comment:41):\n> HMmmmmm... Does it make any difference ? gcc should resolve those \"if\" at compile-time, so if Cython creates two version of the function with an \"if\" inside depending on the type, gcc should not include it in the final binary as the constants involved can be defined at compile-time.\n\nYes, it is indeed resolved at compile time. Two c-functions are created, and only the part of the code relevant for the respective code branch appears in the c-function.\n\nIn other words, I now plan to create cdef functions like this:\n\n```python\nctypedef seq_t:\n    first_implementation\n    second_implementation\n\ncdef seq_t concat(seq_t x, seq_t y):\n    if seq_t is first_implementation:\n        <do stuff for 1st implementation>\n    else:\n        <do stuff for 2nd implementation>\n```\nand then, in other modules (perhaps also in `src/sage/combinat/words/word_datatypes.pyx`?), one could uniformly call `concat(a,b)`, provided that the type of `a` and `b` are known at compile time (or write `concat[first_implementation](a,b)` explicitly).\n\nI think that such Cython code will be sufficiently nice to read, and the resulting C-code will be sufficiently fast.\n\n> Anyway, that's a good news ! `:-D`\n\nIndeed!\n\nSimon",
    "created_at": "2014-05-12T10:21:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199858",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:43" align="right">comment:43</div>

Hi Nathann,

Replying to [@nathanncohen](#comment:41):
> HMmmmmm... Does it make any difference ? gcc should resolve those "if" at compile-time, so if Cython creates two version of the function with an "if" inside depending on the type, gcc should not include it in the final binary as the constants involved can be defined at compile-time.

Yes, it is indeed resolved at compile time. Two c-functions are created, and only the part of the code relevant for the respective code branch appears in the c-function.

In other words, I now plan to create cdef functions like this:

```python
ctypedef seq_t:
    first_implementation
    second_implementation

cdef seq_t concat(seq_t x, seq_t y):
    if seq_t is first_implementation:
        <do stuff for 1st implementation>
    else:
        <do stuff for 2nd implementation>
```
and then, in other modules (perhaps also in `src/sage/combinat/words/word_datatypes.pyx`?), one could uniformly call `concat(a,b)`, provided that the type of `a` and `b` are known at compile time (or write `concat[first_implementation](a,b)` explicitly).

I think that such Cython code will be sufficiently nice to read, and the resulting C-code will be sufficiently fast.

> Anyway, that's a good news ! `:-D`

Indeed!

Simon



---

archive/issue_comments_199859.json:
```json
{
    "body": "<div id=\"comment:44\" align=\"right\">comment:44</div>\n\n> I think that such Cython code will be sufficiently nice to read, and the resulting C-code will be sufficiently fast.\n\n+1\n\nNathann",
    "created_at": "2014-05-12T10:23:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199859",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:44" align="right">comment:44</div>

> I think that such Cython code will be sufficiently nice to read, and the resulting C-code will be sufficiently fast.

+1

Nathann



---

archive/issue_comments_199860.json:
```json
{
    "body": "<div id=\"comment:45\" align=\"right\">comment:45</div>\n\nHmmm. Meanwhile I am a bit less positive about fused types. Let `seq_t` be a fused type for different implementations.\n\n- Fused types can not be used in iterators. I.e., the following is refused:\n\n  ```\n  def iter_seq(seq_t S):\n      for <bla>:\n          <do something>\n          yield x\n  ```\n- Fused types can not be used as attributes of cdef classes. I.e., the following is refused:\n\n  ```\n  cdef class BoundedIntSeq:\n      cdef seq_t seq\n      def __mul__(self, other):\n          <do type check>\n          cdef seq_t out = concat_seq(self.seq, other.seq)\n          <create and return new instance of BoundedIntSeq using \"out\">\n  ```\n\nHence, it seems that one needs to create two separate iterators, and it also seems that one needs code duplication. I.e., when `impl1` and `impl2` are two specialisations of the fused type `seq_t`, then one has to have\n\n```\ncdef class BoundedIntSeq_impl1:\n    cdef impl1 seq\n    def __mul__(self, other):\n        ...\n        cdef impl1 out = concat_seq(self.seq, other.seq)\ncdef class BoundedIntSeq_impl2:\n    cdef impl2 seq\n    def __mul__(self, other):\n        ...\n        cdef impl2 out = concat_seq(self.seq, other.seq)\n```\nThis mainly amounts to cut-and-paste, but is ugly!\n\nI think I'll ask on cython-users if there are known ideas to solve this more elegantly.",
    "created_at": "2014-05-12T14:41:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199860",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:45" align="right">comment:45</div>

Hmmm. Meanwhile I am a bit less positive about fused types. Let `seq_t` be a fused type for different implementations.

- Fused types can not be used in iterators. I.e., the following is refused:

  ```
  def iter_seq(seq_t S):
      for <bla>:
          <do something>
          yield x
  ```
- Fused types can not be used as attributes of cdef classes. I.e., the following is refused:

  ```
  cdef class BoundedIntSeq:
      cdef seq_t seq
      def __mul__(self, other):
          <do type check>
          cdef seq_t out = concat_seq(self.seq, other.seq)
          <create and return new instance of BoundedIntSeq using "out">
  ```

Hence, it seems that one needs to create two separate iterators, and it also seems that one needs code duplication. I.e., when `impl1` and `impl2` are two specialisations of the fused type `seq_t`, then one has to have

```
cdef class BoundedIntSeq_impl1:
    cdef impl1 seq
    def __mul__(self, other):
        ...
        cdef impl1 out = concat_seq(self.seq, other.seq)
cdef class BoundedIntSeq_impl2:
    cdef impl2 seq
    def __mul__(self, other):
        ...
        cdef impl2 out = concat_seq(self.seq, other.seq)
```
This mainly amounts to cut-and-paste, but is ugly!

I think I'll ask on cython-users if there are known ideas to solve this more elegantly.



---

archive/issue_comments_199861.json:
```json
{
    "body": "<div id=\"comment:46\" align=\"right\">comment:46</div>\n\nSome variation on the theme: One can create fused types from two cdef classes, and then one can work with specialisations of functions as follows:\n\n```python\n\nctypedef fused str_or_int:\n    str\n    int\n\n# make the function do different things on different types,\n# to better see the difference\ncpdef str_or_int times_two(str_or_int var):\n    if str_or_int is int:\n        return var+var\n    else:\n        return var+'+'+var\n\n# forward declaration of cdef classes and their fusion\ncdef class Bar_int\ncdef class Bar_str\ncdef fused Bar:\n    Bar_int\n    Bar_str\n\n# a function that can be specialised to either of the two extension classes\ndef twice(Bar self):\n    # and inside, we specialised a function depending\n    # on the type of an attribute --- at compile time!!\n    return type(self)(times_two(self.data))\n\ncdef class Bar_str:\n    cdef str data\n    def __init__(self, data):\n        self.data = data\n    def __repr__(self):\n        return self.data\n    # First possibility: Use the \"templated\" function as a method\n    twice_ = twice[Bar_str]\n    # second possibility: Wrap the \"templated\" function\n    cpdef Bar_str twice__(self):\n        return twice(self)\n\n# The same, with the other Specialisation of <Bar>\ncdef class Bar_int:\n    cdef int data\n    def __init__(self, data):\n        self.data = data\n    def __repr__(self):\n        return \"int(%d)\"%self.data\n    twice_ = twice[Bar_int]\n    cpdef Bar_int twice__(self):\n        return twice(self)\n```\nTime-wise, we see that wrapping the \"templated\" function is slower than using it as an attribute:\n\n```\nsage: b1 = Bar_str('abc')\nsage: b1.twice_()\nabc+abc\nsage: b1.twice__()\nabc+abc\nsage: %timeit b1.twice_()\n1000000 loops, best of 3: 759 ns per loop\nsage: %timeit b1.twice__()\n100000 loops, best of 3: 13.7 \u00b5s per loop\nsage: b2 = Bar_int(5)\nsage: b2.twice_()\nint(10)\nsage: b2.twice__()\nint(10)\nsage: %timeit b2.twice_()\n1000000 loops, best of 3: 539 ns per loop\nsage: %timeit b2.twice__()\n100000 loops, best of 3: 9.2 \u00b5s per loop\n```\n\n__Summary and further comments__\n\n- We can reduce the code duplication to something like this:\n\n  ```\n  <define templated function foo_ depending on a fused type Bar with specialisations Bar1, Bar2,...>\n  cdef class Bar1:\n      foo = foo_[Bar1]\n  cdef class Bar2:\n      foo = foo_[Bar2]\n  ...\n  ```\n  I hope this level of copy-and-paste can be afforded. At least, it gives good speed.\n- In my tests I found the following:\n  - It is impossible to make `foo_` a cpdef function. Otherwise, the assignment `foo = foo_` fails with the statement that `foo_` can not be turned into a Python type.\n  - It is impossible to chose the same name for the templated function and for the method it is turned into. Doing\n\n    ```\n    class Bar1:\n        foo_ = foo_\n    ```\n    results in an error saying that `Bar1` has not attribute `foo_`.\n  - With the syntax above, both `twice_` and `twice__` have been put into the class' `__dict__`. I did not succeed to turn it into the equivalent of a cdef method.",
    "created_at": "2014-05-12T17:27:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199861",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:46" align="right">comment:46</div>

Some variation on the theme: One can create fused types from two cdef classes, and then one can work with specialisations of functions as follows:

```python

ctypedef fused str_or_int:
    str
    int

# make the function do different things on different types,
# to better see the difference
cpdef str_or_int times_two(str_or_int var):
    if str_or_int is int:
        return var+var
    else:
        return var+'+'+var

# forward declaration of cdef classes and their fusion
cdef class Bar_int
cdef class Bar_str
cdef fused Bar:
    Bar_int
    Bar_str

# a function that can be specialised to either of the two extension classes
def twice(Bar self):
    # and inside, we specialised a function depending
    # on the type of an attribute --- at compile time!!
    return type(self)(times_two(self.data))

cdef class Bar_str:
    cdef str data
    def __init__(self, data):
        self.data = data
    def __repr__(self):
        return self.data
    # First possibility: Use the "templated" function as a method
    twice_ = twice[Bar_str]
    # second possibility: Wrap the "templated" function
    cpdef Bar_str twice__(self):
        return twice(self)

# The same, with the other Specialisation of <Bar>
cdef class Bar_int:
    cdef int data
    def __init__(self, data):
        self.data = data
    def __repr__(self):
        return "int(%d)"%self.data
    twice_ = twice[Bar_int]
    cpdef Bar_int twice__(self):
        return twice(self)
```
Time-wise, we see that wrapping the "templated" function is slower than using it as an attribute:

```
sage: b1 = Bar_str('abc')
sage: b1.twice_()
abc+abc
sage: b1.twice__()
abc+abc
sage: %timeit b1.twice_()
1000000 loops, best of 3: 759 ns per loop
sage: %timeit b1.twice__()
100000 loops, best of 3: 13.7 µs per loop
sage: b2 = Bar_int(5)
sage: b2.twice_()
int(10)
sage: b2.twice__()
int(10)
sage: %timeit b2.twice_()
1000000 loops, best of 3: 539 ns per loop
sage: %timeit b2.twice__()
100000 loops, best of 3: 9.2 µs per loop
```

__Summary and further comments__

- We can reduce the code duplication to something like this:

  ```
  <define templated function foo_ depending on a fused type Bar with specialisations Bar1, Bar2,...>
  cdef class Bar1:
      foo = foo_[Bar1]
  cdef class Bar2:
      foo = foo_[Bar2]
  ...
  ```
  I hope this level of copy-and-paste can be afforded. At least, it gives good speed.
- In my tests I found the following:
  - It is impossible to make `foo_` a cpdef function. Otherwise, the assignment `foo = foo_` fails with the statement that `foo_` can not be turned into a Python type.
  - It is impossible to chose the same name for the templated function and for the method it is turned into. Doing

    ```
    class Bar1:
        foo_ = foo_
    ```
    results in an error saying that `Bar1` has not attribute `foo_`.
  - With the syntax above, both `twice_` and `twice__` have been put into the class' `__dict__`. I did not succeed to turn it into the equivalent of a cdef method.



---

archive/issue_comments_199862.json:
```json
{
    "body": "<div id=\"comment:47\" align=\"right\">comment:47</div>\n\nI did a lot of benchmark tests for the different implementations (using `long*` or `char*` or `mpz_t` to store sequences of bounded integers, using cdef functions that operate on fused types) and eventually found that using GMP (i.e., `mpz_t`) is fastest in *all* tests, by a wide margin.\n\nWhy did I not find this result before? Well, part of the reason is that GMP sometimes provides different functions to do the same job, and in the past few days I considerably improved my usage of the various possibilities. For example, `mpz_t` can be initialised in different ways. If one uses `mpz_init`, then the assignment that will follow results in a re-allocation. Since the length of the concatenation of two tuples is known in advance, prescribing the number of to-be-allocated bits with `mpz_init2` resulted in a speed-up of concatenation, actually it became twice as fast.\n\nAnd this result is not surprising. After all, GMP has to implement the same bitshift and comparison operations for bit arrays that I was implementing in the \"`long*`\" approach, too. But GMP probably uses implementation techniques that I can not even dream of.\n\nNow, my plan is to\n- create some `ctypedef struct bounded_int_tuple` that is based on `mpz_t` and is the underlying C structure for tuples of bounded integers\n- provide a collection of cdef (inline) functions, operating on `bounded_int_tuple`, for concatenation, copying, comparison and so on\n- wrap it in a cdef class `BoundedIntegerTuple`. This will probably *not* derive from `Element`: I think it makes no difference from the point of view of memory efficiency whether each `BoundedIntegerTuple` stores a pointer to the parent of \"all tuples of integers bounded by `B`\" or directly stores `B` as an unsigned int.\n\nIn a subsequent ticket, I plan to use it for quiver paths, and if the combinat crowd cares, they can use it to make parts of sage.combinat.words a lot faster.\n\nComments? Requests? Suggestion of alternatives?",
    "created_at": "2014-05-25T11:43:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199862",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:47" align="right">comment:47</div>

I did a lot of benchmark tests for the different implementations (using `long*` or `char*` or `mpz_t` to store sequences of bounded integers, using cdef functions that operate on fused types) and eventually found that using GMP (i.e., `mpz_t`) is fastest in *all* tests, by a wide margin.

Why did I not find this result before? Well, part of the reason is that GMP sometimes provides different functions to do the same job, and in the past few days I considerably improved my usage of the various possibilities. For example, `mpz_t` can be initialised in different ways. If one uses `mpz_init`, then the assignment that will follow results in a re-allocation. Since the length of the concatenation of two tuples is known in advance, prescribing the number of to-be-allocated bits with `mpz_init2` resulted in a speed-up of concatenation, actually it became twice as fast.

And this result is not surprising. After all, GMP has to implement the same bitshift and comparison operations for bit arrays that I was implementing in the "`long*`" approach, too. But GMP probably uses implementation techniques that I can not even dream of.

Now, my plan is to
- create some `ctypedef struct bounded_int_tuple` that is based on `mpz_t` and is the underlying C structure for tuples of bounded integers
- provide a collection of cdef (inline) functions, operating on `bounded_int_tuple`, for concatenation, copying, comparison and so on
- wrap it in a cdef class `BoundedIntegerTuple`. This will probably *not* derive from `Element`: I think it makes no difference from the point of view of memory efficiency whether each `BoundedIntegerTuple` stores a pointer to the parent of "all tuples of integers bounded by `B`" or directly stores `B` as an unsigned int.

In a subsequent ticket, I plan to use it for quiver paths, and if the combinat crowd cares, they can use it to make parts of sage.combinat.words a lot faster.

Comments? Requests? Suggestion of alternatives?



---

archive/issue_comments_199863.json:
```json
{
    "body": "<div id=\"comment:48\" align=\"right\">comment:48</div>\n\nNone from me. I keep being impressed at how much testing/researching you put into this quiver features... I really wonder what you will do with it in the end `;-)`\n\nNathann",
    "created_at": "2014-05-25T15:39:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199863",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:48" align="right">comment:48</div>

None from me. I keep being impressed at how much testing/researching you put into this quiver features... I really wonder what you will do with it in the end `;-)`

Nathann



---

archive/issue_comments_199864.json:
```json
{
    "body": "Branch: **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)**",
    "created_at": "2014-05-27T15:54:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199864",
    "user": "https://github.com/simon-king-jena"
}
```

Branch: **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)**



---

archive/issue_comments_199865.json:
```json
{
    "body": "<div id=\"comment:50\" align=\"right\">comment:50</div>\n\nI have pushed a branch with an initial implementation of bounded integer sequences. I took care of error handling: I think you will find that those GMP commands that may result in a memory error are wrapped in sig_on()/sig_off(), and the cdef boilerplate functions do propagate errors. In fact, in some of my tests, I was hitting Ctrl-C, and it worked.\n\nThe rest of this post is about benchmarks. I compare against Python tuples---which is of course ambitious, and you will find that not in all situations tuples are slower than bounded integer sequences. However, one should see it positively: The bounded integer sequences implemented here have features very similar to tuples, and there *are* operations for which they are a lot faster than tuples. It all depends on the length and the bound of the sequence. That's why I think that it is a reasonable contribution. And to make it faster (without Python classes), one can still use the cdef boilerplate functions. Generally, it seems that long bounded integer sequences are faster than long tuples, but short tuples are faster than short sequences. For hash, bounded integer sequences are pretty good, but they suck in accessing items, or in slicing with step different from 1.\n\nIn contrast to tuples, bounded integer sequences also provide fairly quick tests for whether a sequences starts with a given sequence, or whether a sequence contains a certain sub-sequence. This is a feature I took from strings.\n\nHere are the tests, with different sizes and bounds. Variable names starting with \"T\" hold tuples, those starting with \"S\" hold bounded integer sequences.\n\n```\nsage: from sage.structure.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\n```\n\n__Iteration__\n\n```\nsage: timeit(\"x=[y for y in T0]\", number=1000000)\n1000000 loops, best of 3: 783 ns per loop\nsage: timeit(\"x=[y for y in T1]\", number=1000000)\n1000000 loops, best of 3: 1.48 \u00b5s per loop\nsage: timeit(\"x=[y for y in T2]\", number=100000)\n100000 loops, best of 3: 4.3 \u00b5s per loop\nsage: timeit(\"x=[y for y in T3]\", number=1000)\n1000 loops, best of 3: 245 \u00b5s per loop\nsage: timeit(\"x=[y for y in S0]\", number=1000000)\n1000000 loops, best of 3: 2.38 \u00b5s per loop\nsage: timeit(\"x=[y for y in S1]\", number=100000)\n100000 loops, best of 3: 4.1 \u00b5s per loop\nsage: timeit(\"x=[y for y in S2]\", number=100000)\n100000 loops, best of 3: 10.1 \u00b5s per loop\nsage: timeit(\"x=[y for y in S3]\", number=1000)\n1000 loops, best of 3: 1.79 ms per loop\n```\n\n__Slicing__\n\nBounded integer sequences are immutable and hence copied by identity. But let us do slicing, dropping the last item:\n\n```\nsage: timeit(\"x=T3[:-1]\", number=100000)\n100000 loops, best of 3: 19.5 \u00b5s per loop\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 3.48 \u00b5s per loop\n```\nSlicing with `step!=1` is much slower, though:\n\n```\nsage: timeit(\"x=T3[:-1:2]\", number=100000)\n100000 loops, best of 3: 11.7 \u00b5s per loop\nsage: timeit(\"x=S3[:-1:2]\", number=1000)\n1000 loops, best of 3: 2.23 ms per loop\n```\nPerhaps I should mark it \"TODO\"...\n\n__Accessing single items__\n\nShort sequences\n\n```\nsage: timeit(\"x=T0[1]\", number=1000000)\n1000000 loops, best of 3: 361 ns per loop\nsage: timeit(\"x=T0[4]\", number=1000000)\n1000000 loops, best of 3: 373 ns per loop\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 959 ns per loop\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 960 ns per loop\n```\nLarge sequences (time also depends on the bound for the integer sequence!)\n\n```\nsage: timeit(\"x=T3[1]\", number=1000000)\n1000000 loops, best of 3: 359 ns per loop\nsage: timeit(\"x=T3[4500]\", number=1000000)\n1000000 loops, best of 3: 382 ns per loop\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 1.97 \u00b5s per loop\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 1.49 \u00b5s per loop\n```\n\n__Comparison__\n\nNote that comparison of bounded integer sequences works different from comparison of tuples or lists, as detailed in the documentation.\n\nWe compare sequences that are equal but non-identical, that differ in early items, or that differ in late items.\n\n```\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: T0x = tuple(L0x); T1x = tuple(L1x); T2x = tuple(L2x); T3x = tuple(L3x)\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: T0y = tuple(L0); T1y = tuple(L1); T2y = tuple(L2); T3y = tuple(L3)\nsage: S1y = BoundedIntegerSequence(8, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S1y==S1!=S1x, S1y is not S1\n(True, True)\n```\nEarly differences:\n\n```\nsage: timeit(\"T0==T0x\", number=1000000)\n1000000 loops, best of 3: 143 ns per loop\nsage: timeit(\"T1==T1x\", number=1000000)\n1000000 loops, best of 3: 145 ns per loop\nsage: timeit(\"T2==T2x\", number=1000000)\n1000000 loops, best of 3: 143 ns per loop\nsage: timeit(\"T3==T3x\", number=1000000)\n1000000 loops, best of 3: 161 ns per loop\nsage: timeit(\"S0==S0x\", number=1000000)\n1000000 loops, best of 3: 538 ns per loop\nsage: timeit(\"S1==S1x\", number=1000000)\n1000000 loops, best of 3: 550 ns per loop\nsage: timeit(\"S2==S2x\", number=1000000)\n1000000 loops, best of 3: 490 ns per loop\nsage: timeit(\"S3==S3x\", number=1000000)\n1000000 loops, best of 3: 559 ns per loop\n```\nEqual sequences:\n\n```\nsage: timeit(\"T0==T0y\", number=1000000)\n1000000 loops, best of 3: 169 ns per loop\nsage: timeit(\"T1==T1y\", number=1000000)\n1000000 loops, best of 3: 255 ns per loop\nsage: timeit(\"T2==T2y\", number=1000000)\n1000000 loops, best of 3: 597 ns per loop\nsage: timeit(\"T3==T3y\", number=100000)\n100000 loops, best of 3: 47.8 \u00b5s per loop\nsage: timeit(\"S0==S0y\", number=1000000)\n1000000 loops, best of 3: 511 ns per loop\nsage: timeit(\"S1==S1y\", number=1000000)\n1000000 loops, best of 3: 493 ns per loop\nsage: timeit(\"S2==S2y\", number=1000000)\n1000000 loops, best of 3: 583 ns per loop\nsage: timeit(\"S3==S3y\", number=1000000)\n1000000 loops, best of 3: 1.41 \u00b5s per loop\n```\nLate differences:\n\n```\nsage: T0z1 = T0+T0\nsage: T0z2 = T0+T0x\nsage: T1z1 = T1+T1\nsage: T1z2 = T1+T1x\nsage: T2z1 = T2+T2\nsage: T2z2 = T2+T2x\nsage: T3z1 = T3+T3\nsage: T3z2 = T3+T3x\nsage: timeit(\"T0z1==T0z2\", number=100000)\n100000 loops, best of 3: 206 ns per loop\nsage: timeit(\"T1z1==T1z2\", number=100000)\n100000 loops, best of 3: 308 ns per loop\nsage: timeit(\"T2z1==T2z2\", number=100000)\n100000 loops, best of 3: 640 ns per loop\nsage: timeit(\"T3z1==T3z2\", number=100000)\n100000 loops, best of 3: 47.8 \u00b5s per loop\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0z1==S0z2\", number=100000)\n100000 loops, best of 3: 585 ns per loop\nsage: timeit(\"S1z1==S1z2\", number=100000)\n100000 loops, best of 3: 494 ns per loop\nsage: timeit(\"S2z1==S2z2\", number=100000)\n100000 loops, best of 3: 555 ns per loop\nsage: timeit(\"S3z1==S3z2\", number=100000)\n100000 loops, best of 3: 578 ns per loop\n```\n\n__Hash__\n\nThis is the only operation for which bounded integer sequences seem to be consistently faster than tuples:\n\n```\nsage: timeit(\"hash(T0)\", number=100000)\n100000 loops, best of 3: 179 ns per loop\nsage: timeit(\"hash(T0)\", number=1000000)\n1000000 loops, best of 3: 177 ns per loop\nsage: timeit(\"hash(T1)\", number=1000000)\n1000000 loops, best of 3: 267 ns per loop\nsage: timeit(\"hash(T2)\", number=1000000)\n1000000 loops, best of 3: 584 ns per loop\nsage: timeit(\"hash(T3)\", number=100000)\n100000 loops, best of 3: 45.3 \u00b5s per loop\nsage: timeit(\"hash(S0)\", number=1000000)\n1000000 loops, best of 3: 145 ns per loop\nsage: timeit(\"hash(S1)\", number=1000000)\n1000000 loops, best of 3: 153 ns per loop\nsage: timeit(\"hash(S2)\", number=1000000)\n1000000 loops, best of 3: 194 ns per loop\nsage: timeit(\"hash(S3)\", number=1000000)\n1000000 loops, best of 3: 8.97 \u00b5s per loop\n```\n\n__Concatenation__\n\n```\nsage: timeit(\"T0+T0\", number=1000000)\n1000000 loops, best of 3: 200 ns per loop\nsage: timeit(\"T1+T1\", number=1000000)\n1000000 loops, best of 3: 311 ns per loop\nsage: timeit(\"T2+T2\", number=1000000)\n1000000 loops, best of 3: 742 ns per loop\nsage: timeit(\"T3+T3\", number=10000)\n10000 loops, best of 3: 40.3 \u00b5s per loop\nsage: timeit(\"S0+S0\", number=1000000)\n1000000 loops, best of 3: 576 ns per loop\nsage: timeit(\"S1+S1\", number=1000000)\n1000000 loops, best of 3: 590 ns per loop\nsage: timeit(\"S2+S2\", number=1000000)\n1000000 loops, best of 3: 618 ns per loop\nsage: timeit(\"S3+S3\", number=1000000)\n1000000 loops, best of 3: 2.17 \u00b5s per loop\n```\n\n__Subsequences__\n\nRecall the definition of `S0z1` etc. We find:\n\n```\nsage: S0z2.startswith(S0)\nTrue\nsage: S0z2.startswith(S0x)\nFalse\nsage: S0x in S0z2\nTrue\nsage: timeit(\"S0z2.startswith(S0)\", number=1000000)\n1000000 loops, best of 3: 239 ns per loop\nsage: timeit(\"S0z2.startswith(S0x)\", number=1000000)\n1000000 loops, best of 3: 241 ns per loop\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 694 ns per loop\nsage: timeit(\"S1z2.startswith(S1)\", number=1000000)\n1000000 loops, best of 3: 227 ns per loop\nsage: timeit(\"S1z2.startswith(S1x)\", number=1000000)\n1000000 loops, best of 3: 223 ns per loop\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 1.08 \u00b5s per loop\nsage: timeit(\"S2z2.startswith(S2)\", number=1000000)\n1000000 loops, best of 3: 247 ns per loop\nsage: timeit(\"S2z2.startswith(S2x)\", number=1000000)\n1000000 loops, best of 3: 230 ns per loop\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 3.21 \u00b5s per loop\nsage: timeit(\"S3z2.startswith(S3)\", number=1000000)\n1000000 loops, best of 3: 989 ns per loop\nsage: timeit(\"S3z2.startswith(S3x)\", number=1000000)\n1000000 loops, best of 3: 218 ns per loop\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 3.57 ms per loop\n```\nI wonder if the latter could be improved. Another \"TODO\"...\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8\"><code>5dc78c5</code></a></td><td><code>Implement sequences of bounded integers</code></td></tr></table>\n",
    "created_at": "2014-05-27T16:02:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199865",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:50" align="right">comment:50</div>

I have pushed a branch with an initial implementation of bounded integer sequences. I took care of error handling: I think you will find that those GMP commands that may result in a memory error are wrapped in sig_on()/sig_off(), and the cdef boilerplate functions do propagate errors. In fact, in some of my tests, I was hitting Ctrl-C, and it worked.

The rest of this post is about benchmarks. I compare against Python tuples---which is of course ambitious, and you will find that not in all situations tuples are slower than bounded integer sequences. However, one should see it positively: The bounded integer sequences implemented here have features very similar to tuples, and there *are* operations for which they are a lot faster than tuples. It all depends on the length and the bound of the sequence. That's why I think that it is a reasonable contribution. And to make it faster (without Python classes), one can still use the cdef boilerplate functions. Generally, it seems that long bounded integer sequences are faster than long tuples, but short tuples are faster than short sequences. For hash, bounded integer sequences are pretty good, but they suck in accessing items, or in slicing with step different from 1.

In contrast to tuples, bounded integer sequences also provide fairly quick tests for whether a sequences starts with a given sequence, or whether a sequence contains a certain sub-sequence. This is a feature I took from strings.

Here are the tests, with different sizes and bounds. Variable names starting with "T" hold tuples, those starting with "S" hold bounded integer sequences.

```
sage: from sage.structure.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
```

__Iteration__

```
sage: timeit("x=[y for y in T0]", number=1000000)
1000000 loops, best of 3: 783 ns per loop
sage: timeit("x=[y for y in T1]", number=1000000)
1000000 loops, best of 3: 1.48 µs per loop
sage: timeit("x=[y for y in T2]", number=100000)
100000 loops, best of 3: 4.3 µs per loop
sage: timeit("x=[y for y in T3]", number=1000)
1000 loops, best of 3: 245 µs per loop
sage: timeit("x=[y for y in S0]", number=1000000)
1000000 loops, best of 3: 2.38 µs per loop
sage: timeit("x=[y for y in S1]", number=100000)
100000 loops, best of 3: 4.1 µs per loop
sage: timeit("x=[y for y in S2]", number=100000)
100000 loops, best of 3: 10.1 µs per loop
sage: timeit("x=[y for y in S3]", number=1000)
1000 loops, best of 3: 1.79 ms per loop
```

__Slicing__

Bounded integer sequences are immutable and hence copied by identity. But let us do slicing, dropping the last item:

```
sage: timeit("x=T3[:-1]", number=100000)
100000 loops, best of 3: 19.5 µs per loop
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 3.48 µs per loop
```
Slicing with `step!=1` is much slower, though:

```
sage: timeit("x=T3[:-1:2]", number=100000)
100000 loops, best of 3: 11.7 µs per loop
sage: timeit("x=S3[:-1:2]", number=1000)
1000 loops, best of 3: 2.23 ms per loop
```
Perhaps I should mark it "TODO"...

__Accessing single items__

Short sequences

```
sage: timeit("x=T0[1]", number=1000000)
1000000 loops, best of 3: 361 ns per loop
sage: timeit("x=T0[4]", number=1000000)
1000000 loops, best of 3: 373 ns per loop
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 959 ns per loop
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 960 ns per loop
```
Large sequences (time also depends on the bound for the integer sequence!)

```
sage: timeit("x=T3[1]", number=1000000)
1000000 loops, best of 3: 359 ns per loop
sage: timeit("x=T3[4500]", number=1000000)
1000000 loops, best of 3: 382 ns per loop
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 1.97 µs per loop
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 1.49 µs per loop
```

__Comparison__

Note that comparison of bounded integer sequences works different from comparison of tuples or lists, as detailed in the documentation.

We compare sequences that are equal but non-identical, that differ in early items, or that differ in late items.

```
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: T0x = tuple(L0x); T1x = tuple(L1x); T2x = tuple(L2x); T3x = tuple(L3x)
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: T0y = tuple(L0); T1y = tuple(L1); T2y = tuple(L2); T3y = tuple(L3)
sage: S1y = BoundedIntegerSequence(8, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S1y==S1!=S1x, S1y is not S1
(True, True)
```
Early differences:

```
sage: timeit("T0==T0x", number=1000000)
1000000 loops, best of 3: 143 ns per loop
sage: timeit("T1==T1x", number=1000000)
1000000 loops, best of 3: 145 ns per loop
sage: timeit("T2==T2x", number=1000000)
1000000 loops, best of 3: 143 ns per loop
sage: timeit("T3==T3x", number=1000000)
1000000 loops, best of 3: 161 ns per loop
sage: timeit("S0==S0x", number=1000000)
1000000 loops, best of 3: 538 ns per loop
sage: timeit("S1==S1x", number=1000000)
1000000 loops, best of 3: 550 ns per loop
sage: timeit("S2==S2x", number=1000000)
1000000 loops, best of 3: 490 ns per loop
sage: timeit("S3==S3x", number=1000000)
1000000 loops, best of 3: 559 ns per loop
```
Equal sequences:

```
sage: timeit("T0==T0y", number=1000000)
1000000 loops, best of 3: 169 ns per loop
sage: timeit("T1==T1y", number=1000000)
1000000 loops, best of 3: 255 ns per loop
sage: timeit("T2==T2y", number=1000000)
1000000 loops, best of 3: 597 ns per loop
sage: timeit("T3==T3y", number=100000)
100000 loops, best of 3: 47.8 µs per loop
sage: timeit("S0==S0y", number=1000000)
1000000 loops, best of 3: 511 ns per loop
sage: timeit("S1==S1y", number=1000000)
1000000 loops, best of 3: 493 ns per loop
sage: timeit("S2==S2y", number=1000000)
1000000 loops, best of 3: 583 ns per loop
sage: timeit("S3==S3y", number=1000000)
1000000 loops, best of 3: 1.41 µs per loop
```
Late differences:

```
sage: T0z1 = T0+T0
sage: T0z2 = T0+T0x
sage: T1z1 = T1+T1
sage: T1z2 = T1+T1x
sage: T2z1 = T2+T2
sage: T2z2 = T2+T2x
sage: T3z1 = T3+T3
sage: T3z2 = T3+T3x
sage: timeit("T0z1==T0z2", number=100000)
100000 loops, best of 3: 206 ns per loop
sage: timeit("T1z1==T1z2", number=100000)
100000 loops, best of 3: 308 ns per loop
sage: timeit("T2z1==T2z2", number=100000)
100000 loops, best of 3: 640 ns per loop
sage: timeit("T3z1==T3z2", number=100000)
100000 loops, best of 3: 47.8 µs per loop
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0z1==S0z2", number=100000)
100000 loops, best of 3: 585 ns per loop
sage: timeit("S1z1==S1z2", number=100000)
100000 loops, best of 3: 494 ns per loop
sage: timeit("S2z1==S2z2", number=100000)
100000 loops, best of 3: 555 ns per loop
sage: timeit("S3z1==S3z2", number=100000)
100000 loops, best of 3: 578 ns per loop
```

__Hash__

This is the only operation for which bounded integer sequences seem to be consistently faster than tuples:

```
sage: timeit("hash(T0)", number=100000)
100000 loops, best of 3: 179 ns per loop
sage: timeit("hash(T0)", number=1000000)
1000000 loops, best of 3: 177 ns per loop
sage: timeit("hash(T1)", number=1000000)
1000000 loops, best of 3: 267 ns per loop
sage: timeit("hash(T2)", number=1000000)
1000000 loops, best of 3: 584 ns per loop
sage: timeit("hash(T3)", number=100000)
100000 loops, best of 3: 45.3 µs per loop
sage: timeit("hash(S0)", number=1000000)
1000000 loops, best of 3: 145 ns per loop
sage: timeit("hash(S1)", number=1000000)
1000000 loops, best of 3: 153 ns per loop
sage: timeit("hash(S2)", number=1000000)
1000000 loops, best of 3: 194 ns per loop
sage: timeit("hash(S3)", number=1000000)
1000000 loops, best of 3: 8.97 µs per loop
```

__Concatenation__

```
sage: timeit("T0+T0", number=1000000)
1000000 loops, best of 3: 200 ns per loop
sage: timeit("T1+T1", number=1000000)
1000000 loops, best of 3: 311 ns per loop
sage: timeit("T2+T2", number=1000000)
1000000 loops, best of 3: 742 ns per loop
sage: timeit("T3+T3", number=10000)
10000 loops, best of 3: 40.3 µs per loop
sage: timeit("S0+S0", number=1000000)
1000000 loops, best of 3: 576 ns per loop
sage: timeit("S1+S1", number=1000000)
1000000 loops, best of 3: 590 ns per loop
sage: timeit("S2+S2", number=1000000)
1000000 loops, best of 3: 618 ns per loop
sage: timeit("S3+S3", number=1000000)
1000000 loops, best of 3: 2.17 µs per loop
```

__Subsequences__

Recall the definition of `S0z1` etc. We find:

```
sage: S0z2.startswith(S0)
True
sage: S0z2.startswith(S0x)
False
sage: S0x in S0z2
True
sage: timeit("S0z2.startswith(S0)", number=1000000)
1000000 loops, best of 3: 239 ns per loop
sage: timeit("S0z2.startswith(S0x)", number=1000000)
1000000 loops, best of 3: 241 ns per loop
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 694 ns per loop
sage: timeit("S1z2.startswith(S1)", number=1000000)
1000000 loops, best of 3: 227 ns per loop
sage: timeit("S1z2.startswith(S1x)", number=1000000)
1000000 loops, best of 3: 223 ns per loop
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 1.08 µs per loop
sage: timeit("S2z2.startswith(S2)", number=1000000)
1000000 loops, best of 3: 247 ns per loop
sage: timeit("S2z2.startswith(S2x)", number=1000000)
1000000 loops, best of 3: 230 ns per loop
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 3.21 µs per loop
sage: timeit("S3z2.startswith(S3)", number=1000000)
1000000 loops, best of 3: 989 ns per loop
sage: timeit("S3z2.startswith(S3x)", number=1000000)
1000000 loops, best of 3: 218 ns per loop
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 3.57 ms per loop
```
I wonder if the latter could be improved. Another "TODO"...

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8"><code>5dc78c5</code></a></td><td><code>Implement sequences of bounded integers</code></td></tr></table>




---

archive/issue_comments_199866.json:
```json
{
    "body": "Author: **Simon King**",
    "created_at": "2014-05-27T16:02:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199866",
    "user": "https://github.com/simon-king-jena"
}
```

Author: **Simon King**



---

archive/issue_events_225896.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-27T16:02:09Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225896"
}
```



---

archive/issue_comments_199867.json:
```json
{
    "body": "Commit: **[`5dc78c5`](https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8)**",
    "created_at": "2014-05-27T16:02:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199867",
    "user": "https://github.com/simon-king-jena"
}
```

Commit: **[`5dc78c5`](https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8)**



---

archive/issue_comments_199868.json:
```json
{
    "body": "<div id=\"comment:51\" align=\"right\">comment:51</div>\n\nReplying to [@nathanncohen](#comment:48):\n> None from me. I keep being impressed at how much testing/researching you put into this quiver features... I really wonder what you will do with it in the end `;-)`\n\n- Gr\u00f6bner bases for modules over path algebra quotients.\n- In particular, an implementation of the non-commutative version of Faug\u00e8re's F5 algorithm that I have described in my latest article.\n- Compute minimal generating sets for modules over so-called \"basic algebras\" (that's a special type of path algebra quotients), which is possible with the non-commutative F5, as shown in my latest article.\n- Use all this to compute minimal projective resolutions of basic algebras, but please be faster than what we currently do in our optional group cohomology spkg. Currently, we use a method of David Green for computing the minimal resolutions; but F5 should be more efficient---theoretically...\n\nThat said: I guess it would make sense to adopt bounded integer sequences in appropriate parts of sage.combinat.words, but I leave this to others.",
    "created_at": "2014-05-27T16:10:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199868",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:51" align="right">comment:51</div>

Replying to [@nathanncohen](#comment:48):
> None from me. I keep being impressed at how much testing/researching you put into this quiver features... I really wonder what you will do with it in the end `;-)`

- Gröbner bases for modules over path algebra quotients.
- In particular, an implementation of the non-commutative version of Faugère's F5 algorithm that I have described in my latest article.
- Compute minimal generating sets for modules over so-called "basic algebras" (that's a special type of path algebra quotients), which is possible with the non-commutative F5, as shown in my latest article.
- Use all this to compute minimal projective resolutions of basic algebras, but please be faster than what we currently do in our optional group cohomology spkg. Currently, we use a method of David Green for computing the minimal resolutions; but F5 should be more efficient---theoretically...

That said: I guess it would make sense to adopt bounded integer sequences in appropriate parts of sage.combinat.words, but I leave this to others.



---

archive/issue_comments_199869.json:
```json
{
    "body": "<div id=\"comment:52\" align=\"right\">comment:52</div>\n\nHellooooooo Simon !\n\nSorry but I only began to read your code and now I should really go get some\nsleep. I paste my current notes here in the meantime, but I am a long way from a\nproper review job.\n\n- bounded integer sequence, biseq. What about \"integer sequence\" ? All integers\n  are \"bounded\" on a computer. Why add this \"bounded\" everywhere ? biseq -> iseq\n  ?\n\n- `# Bitsize of \"data\"` --> bitsize of the whole sequence\n\n- itembitsize --> necessarily a power of 2 ?\n\n- `#cdef inline void dealloc_biseq(biseq_t S)` : why there if commented ?\n\n- `list2biseq` (and others) -> `list_to_biseq` ?\n\n- Comments on the function definitions --> Move it to the function's doc, even\n  if it is their only content ?\n\n- Could you write some doc, even if it is just one line, for cdef functions ? A\n  bit like what we have for bitsets ? Something like\n\n```\ncdef biseq_t* allocate_biseq(size_t l, unsigned long int itemsize):\n     \"\"\"\n     Allocates a sequences of l integers stored on itemsize bits each.\n     \"\"\"\n```\n\n- I just figured out that you may have wanted to keep this list of functions\n  above with short descriptions as an 'index' of what the file does. If so, it\n  would be cool to do it in the html doc instead ! It is nice to have\n  documentation for C functions even if you have to do it by hand.. An example\n  there :\n  http://www.sagemath.org/doc/reference/graphs/sage/graphs/base/static_sparse_graph.html\n\n- list2biseq --> I wondered why this function wouldn't return a new biseq buil\n  from a list instead of modifying an existing one.... Performance issue ? Is\n  that critical in some cases ?\n\nNathann",
    "created_at": "2014-05-27T22:22:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199869",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:52" align="right">comment:52</div>

Hellooooooo Simon !

Sorry but I only began to read your code and now I should really go get some
sleep. I paste my current notes here in the meantime, but I am a long way from a
proper review job.

- bounded integer sequence, biseq. What about "integer sequence" ? All integers
  are "bounded" on a computer. Why add this "bounded" everywhere ? biseq -> iseq
  ?

- `# Bitsize of "data"` --> bitsize of the whole sequence

- itembitsize --> necessarily a power of 2 ?

- `#cdef inline void dealloc_biseq(biseq_t S)` : why there if commented ?

- `list2biseq` (and others) -> `list_to_biseq` ?

- Comments on the function definitions --> Move it to the function's doc, even
  if it is their only content ?

- Could you write some doc, even if it is just one line, for cdef functions ? A
  bit like what we have for bitsets ? Something like

```
cdef biseq_t* allocate_biseq(size_t l, unsigned long int itemsize):
     """
     Allocates a sequences of l integers stored on itemsize bits each.
     """
```

- I just figured out that you may have wanted to keep this list of functions
  above with short descriptions as an 'index' of what the file does. If so, it
  would be cool to do it in the html doc instead ! It is nice to have
  documentation for C functions even if you have to do it by hand.. An example
  there :
  http://www.sagemath.org/doc/reference/graphs/sage/graphs/base/static_sparse_graph.html

- list2biseq --> I wondered why this function wouldn't return a new biseq buil
  from a list instead of modifying an existing one.... Performance issue ? Is
  that critical in some cases ?

Nathann



---

archive/issue_comments_199870.json:
```json
{
    "body": "<div id=\"comment:53\" align=\"right\">comment:53</div>\n\nReplying to [@nathanncohen](#comment:52):\n> - bounded integer sequence, biseq. What about \"integer sequence\" ?\n\nNot good, because...\n\n>  All integers are \"bounded\" on a computer. Why add this \"bounded\" everywhere ? biseq -> iseq\n\n... the computer's integer bound is chosen when you buy the machine, but not when you create the sequence.\n\nThe point is that each \"bounded integer sequence\" has a bound `B` that can be *chosen upon initialisation* so that any item of the sequence is smaller than `B`.\n\n> - `# Bitsize of \"data\"` --> bitsize of the whole sequence\n\nOK.\n \n> - itembitsize --> necessarily a power of 2 ?\n\nNo. Here, it is really \"bit\" size. So, the number tells how many bits will be reserved to store one item. Hence, the bound `B` above is a power of two, namely `2^itembitsize`.\n\n> - `#cdef inline void dealloc_biseq(biseq_t S)` : why there if commented ?\n\nBecause I forgot to remove it.\n\n> - `list2biseq` (and others) -> `list_to_biseq` ?\n\nAcceptable.\n\n> - Comments on the function definitions --> Move it to the function's doc, even\n>   if it is their only content ?\n> - Could you write some doc, even if it is just one line, for cdef functions ? \n\nI wouldn't remove the comments from the pxd file, but certainly some documentation should be added to the cdef functions in the pyx file. I wonder if this should be by comments in the code or by a doc string. After all, the doc string will not be visible (cdef functions won't appear in the docs, as they can not imported).\n\n> - I just figured out that you may have wanted to keep this list of functions\n>   above with short descriptions as an 'index' of what the file does. If so, it\n>   would be cool to do it in the html doc instead !\n\nYou mean: \"This file provides the following boilerplate functions, that you can cimport for usage in Cython code: ...\"?\n\n> - list2biseq --> I wondered why this function wouldn't return a new biseq buil\n>   from a list instead of modifying an existing one.... Performance issue ? Is\n>   that critical in some cases ?\n\nThis is motivated by my usage in the `BoundedIntegerSequence` wrapper. As usual, there is `__cinit__` which does memory allocations (as much as I know, it is recommended to not do this kind of things in `__init__`). Hence, when `__init__` is called (and I think filling data into the allocated memory is the job of `__init__`, not of `__cinit__`), then the integer sequence already is allocated, and just needs to be filled.",
    "created_at": "2014-05-28T10:14:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199870",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:53" align="right">comment:53</div>

Replying to [@nathanncohen](#comment:52):
> - bounded integer sequence, biseq. What about "integer sequence" ?

Not good, because...

>  All integers are "bounded" on a computer. Why add this "bounded" everywhere ? biseq -> iseq

... the computer's integer bound is chosen when you buy the machine, but not when you create the sequence.

The point is that each "bounded integer sequence" has a bound `B` that can be *chosen upon initialisation* so that any item of the sequence is smaller than `B`.

> - `# Bitsize of "data"` --> bitsize of the whole sequence

OK.
 
> - itembitsize --> necessarily a power of 2 ?

No. Here, it is really "bit" size. So, the number tells how many bits will be reserved to store one item. Hence, the bound `B` above is a power of two, namely `2^itembitsize`.

> - `#cdef inline void dealloc_biseq(biseq_t S)` : why there if commented ?

Because I forgot to remove it.

> - `list2biseq` (and others) -> `list_to_biseq` ?

Acceptable.

> - Comments on the function definitions --> Move it to the function's doc, even
>   if it is their only content ?
> - Could you write some doc, even if it is just one line, for cdef functions ? 

I wouldn't remove the comments from the pxd file, but certainly some documentation should be added to the cdef functions in the pyx file. I wonder if this should be by comments in the code or by a doc string. After all, the doc string will not be visible (cdef functions won't appear in the docs, as they can not imported).

> - I just figured out that you may have wanted to keep this list of functions
>   above with short descriptions as an 'index' of what the file does. If so, it
>   would be cool to do it in the html doc instead !

You mean: "This file provides the following boilerplate functions, that you can cimport for usage in Cython code: ..."?

> - list2biseq --> I wondered why this function wouldn't return a new biseq buil
>   from a list instead of modifying an existing one.... Performance issue ? Is
>   that critical in some cases ?

This is motivated by my usage in the `BoundedIntegerSequence` wrapper. As usual, there is `__cinit__` which does memory allocations (as much as I know, it is recommended to not do this kind of things in `__init__`). Hence, when `__init__` is called (and I think filling data into the allocated memory is the job of `__init__`, not of `__cinit__`), then the integer sequence already is allocated, and just needs to be filled.



---

archive/issue_comments_199871.json:
```json
{
    "body": "<div id=\"comment:54\" align=\"right\">comment:54</div>\n\nSorry it that's a stupid question (I only glanced through the code), but why are you using `mpz`'s and not `mpn`'s? It looks like you are already doing most if not all memory management by hand...",
    "created_at": "2014-05-28T12:41:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199871",
    "user": "https://github.com/mezzarobba"
}
```

<div id="comment:54" align="right">comment:54</div>

Sorry it that's a stupid question (I only glanced through the code), but why are you using `mpz`'s and not `mpn`'s? It looks like you are already doing most if not all memory management by hand...



---

archive/issue_comments_199872.json:
```json
{
    "body": "<div id=\"comment:55\" align=\"right\">comment:55</div>\n\nReplying to [@mezzarobba](#comment:54):\n> Sorry it that's a stupid question (I only glanced through the code), but why are you using `mpz`'s and not `mpn`'s?\n\nSimply because I did not succeed in finding what functions are available for `mpn_t`. So, if you can give me a pointer (similar to [the documentation for `mpz_t`](https://gmplib.org/manual/Integer-Functions.html#Integer-Functions)), I'd appreciate. Probably non-signed types will be a tad faster than signed types.\n\n> It looks like you are already doing most if not all memory management by hand...\n\nWhat would be the alternative to doing so? I mean, what I need is some tool to quickly operate on large bit arrays by shift operations, preferably also with a good and fast hash function, and without the need to think about the number of bits fitting into a byte or a long. I tried to implement this myself, using `char*` or `long*` (which would also mean to take care of allocating and freeing), but `mpz_t` turns out to be faster.\n\nSo, if you know another tool, that is perhaps more directly dedicated to bit arrays, then please tell!",
    "created_at": "2014-05-28T14:23:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199872",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:55" align="right">comment:55</div>

Replying to [@mezzarobba](#comment:54):
> Sorry it that's a stupid question (I only glanced through the code), but why are you using `mpz`'s and not `mpn`'s?

Simply because I did not succeed in finding what functions are available for `mpn_t`. So, if you can give me a pointer (similar to [the documentation for `mpz_t`](https://gmplib.org/manual/Integer-Functions.html#Integer-Functions)), I'd appreciate. Probably non-signed types will be a tad faster than signed types.

> It looks like you are already doing most if not all memory management by hand...

What would be the alternative to doing so? I mean, what I need is some tool to quickly operate on large bit arrays by shift operations, preferably also with a good and fast hash function, and without the need to think about the number of bits fitting into a byte or a long. I tried to implement this myself, using `char*` or `long*` (which would also mean to take care of allocating and freeing), but `mpz_t` turns out to be faster.

So, if you know another tool, that is perhaps more directly dedicated to bit arrays, then please tell!



---

archive/issue_comments_199873.json:
```json
{
    "body": "<div id=\"comment:56\" align=\"right\">comment:56</div>\n\nReplying to [@simon-king-jena](#comment:55):\n> Simply because I did not succeed in finding what functions are available for `mpn_t`. So, if you can give me a pointer (similar to [the documentation for `mpz_t`](https://gmplib.org/manual/Integer-Functions.html#Integer-Functions)), I'd appreciate.\n\nThe documentation for `mpn_*` is at https://gmplib.org/manual/Low_002dlevel-Functions.html\n\n> > It looks like you are already doing most if not all memory management by hand...\n\n> \n> What would be the alternative to doing so?\n\nI'm not saying I see one, only that, as far as I understand, automatic memory management is the main advantage of `mpz_t` over `mpn_*` when you are dealing with nonnegative integers (hence my first question).",
    "created_at": "2014-05-28T14:36:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199873",
    "user": "https://github.com/mezzarobba"
}
```

<div id="comment:56" align="right">comment:56</div>

Replying to [@simon-king-jena](#comment:55):
> Simply because I did not succeed in finding what functions are available for `mpn_t`. So, if you can give me a pointer (similar to [the documentation for `mpz_t`](https://gmplib.org/manual/Integer-Functions.html#Integer-Functions)), I'd appreciate.

The documentation for `mpn_*` is at https://gmplib.org/manual/Low_002dlevel-Functions.html

> > It looks like you are already doing most if not all memory management by hand...

> 
> What would be the alternative to doing so?

I'm not saying I see one, only that, as far as I understand, automatic memory management is the main advantage of `mpz_t` over `mpn_*` when you are dealing with nonnegative integers (hence my first question).



---

archive/issue_comments_199874.json:
```json
{
    "body": "<div id=\"comment:57\" align=\"right\">comment:57</div>\n\nReplying to [@mezzarobba](#comment:56):\n> The documentation for `mpn_*` is at https://gmplib.org/manual/Low_002dlevel-Functions.html\n\nThank you, I'll have a look and will try to compare.\n \n> > > It looks like you are already doing most if not all memory management by hand...\n\n> > \n> > What would be the alternative to doing so?\n\n> \n> I'm not saying I see one, only that, as far as I understand, automatic memory management is the main advantage of `mpz_t` over `mpn_*` when you are dealing with nonnegative integers (hence my first question).\n\nNow I understand what you mean by your statement that I did all memory management by hand: I am not using `mpz_init` but `mpz_init2`, telling exactly how many bits I will need. I found that it has a noticeable impact on performance, since otherwise re-allocations will happen internally.",
    "created_at": "2014-05-28T14:45:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199874",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:57" align="right">comment:57</div>

Replying to [@mezzarobba](#comment:56):
> The documentation for `mpn_*` is at https://gmplib.org/manual/Low_002dlevel-Functions.html

Thank you, I'll have a look and will try to compare.
 
> > > It looks like you are already doing most if not all memory management by hand...

> > 
> > What would be the alternative to doing so?

> 
> I'm not saying I see one, only that, as far as I understand, automatic memory management is the main advantage of `mpz_t` over `mpn_*` when you are dealing with nonnegative integers (hence my first question).

Now I understand what you mean by your statement that I did all memory management by hand: I am not using `mpz_init` but `mpz_init2`, telling exactly how many bits I will need. I found that it has a noticeable impact on performance, since otherwise re-allocations will happen internally.



---

archive/issue_comments_199875.json:
```json
{
    "body": "<div id=\"comment:58\" align=\"right\">comment:58</div>\n\nReplying to [@simon-king-jena](#comment:57):\n> Now I understand what you mean by your statement that I did all memory management by hand: I am not using `mpz_init` but `mpz_init2`\n\nYes, exactly. Sorry if I wasn't clear!",
    "created_at": "2014-05-28T14:51:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199875",
    "user": "https://github.com/mezzarobba"
}
```

<div id="comment:58" align="right">comment:58</div>

Replying to [@simon-king-jena](#comment:57):
> Now I understand what you mean by your statement that I did all memory management by hand: I am not using `mpz_init` but `mpz_init2`

Yes, exactly. Sorry if I wasn't clear!



---

archive/issue_comments_199876.json:
```json
{
    "body": "<div id=\"comment:59\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7ceac67e9c46343b83922d853f262f6b06635453\"><code>7ceac67</code></a></td><td><code>Merge branch 'develop' into ticket/15820</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301\"><code>efef80b</code></a></td><td><code>Relocate bounded integer sequences (sage.misc, not sage.structure)</code></td></tr></table>\n",
    "created_at": "2014-05-30T12:55:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199876",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:59"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7ceac67e9c46343b83922d853f262f6b06635453"><code>7ceac67</code></a></td><td><code>Merge branch 'develop' into ticket/15820</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301"><code>efef80b</code></a></td><td><code>Relocate bounded integer sequences (sage.misc, not sage.structure)</code></td></tr></table>




---

archive/issue_comments_199877.json:
```json
{
    "body": "Changed commit from **[`5dc78c5`](https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8)** to **[`efef80b`](https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301)**",
    "created_at": "2014-05-30T12:55:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199877",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`5dc78c5`](https://github.com/sagemath/sagetrac-mirror/commit/5dc78c5f5f647bf95b98da916d7086fae539ffb8)** to **[`efef80b`](https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301)**



---

archive/issue_comments_199878.json:
```json
{
    "body": "<div id=\"comment:60\" align=\"right\">comment:60</div>\n\nI have at some point merged the latest beta. Sorry, I keep forgetting that merging stuff prematurely is bad. Main point was to relocate the code from sage.structure to sage.misc.\n\nI don't think I will use `mpn_*`. It just seems too low-level. For example, I see `mpn_lshift` and `mpn_rshift` operations, but they operate on limbs, not on bit arrays. Hence, in order to implement a bitshift on bit arrays (which is what I need in concatenation and many other operations), I'd still need to invest a lot of work, essentially what I have done with the proof-of-concept using `long*` to store bit arrays. I doubt that in the end it would be any faster than using `mpz_mul_2exp` and friends.\n\nDocumentation of the cdef functions is still missing, this is what I intend to do next.",
    "created_at": "2014-05-30T13:03:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199878",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:60" align="right">comment:60</div>

I have at some point merged the latest beta. Sorry, I keep forgetting that merging stuff prematurely is bad. Main point was to relocate the code from sage.structure to sage.misc.

I don't think I will use `mpn_*`. It just seems too low-level. For example, I see `mpn_lshift` and `mpn_rshift` operations, but they operate on limbs, not on bit arrays. Hence, in order to implement a bitshift on bit arrays (which is what I need in concatenation and many other operations), I'd still need to invest a lot of work, essentially what I have done with the proof-of-concept using `long*` to store bit arrays. I doubt that in the end it would be any faster than using `mpz_mul_2exp` and friends.

Documentation of the cdef functions is still missing, this is what I intend to do next.



---

archive/issue_comments_199879.json:
```json
{
    "body": "Work Issues: **Document cdef functions**",
    "created_at": "2014-05-30T13:03:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199879",
    "user": "https://github.com/simon-king-jena"
}
```

Work Issues: **Document cdef functions**



---

archive/issue_events_225897.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-30T13:03:53Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225897"
}
```



---

archive/issue_events_225898.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-05-30T13:03:53Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225898"
}
```



---

archive/issue_comments_199880.json:
```json
{
    "body": "<div id=\"comment:61\" align=\"right\">comment:61</div>\n\nIf you use mpz functions, then getting/setting a single entry will be O(n) instead of O(1), and iterating over all entries or creating a sequence from a list of integers will be O(n<sup>2</sup>) instead of O(n). This makes the implementation rather useless for a lot of applications where a datatype like this would be useful (say if you want to store a million small integers in a memory-efficient way). With mpn functions, you can get the optimal complexity.",
    "created_at": "2014-05-30T16:10:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199880",
    "user": "https://github.com/fredrik-johansson"
}
```

<div id="comment:61" align="right">comment:61</div>

If you use mpz functions, then getting/setting a single entry will be O(n) instead of O(1), and iterating over all entries or creating a sequence from a list of integers will be O(n<sup>2</sup>) instead of O(n). This makes the implementation rather useless for a lot of applications where a datatype like this would be useful (say if you want to store a million small integers in a memory-efficient way). With mpn functions, you can get the optimal complexity.



---

archive/issue_comments_199881.json:
```json
{
    "body": "<div id=\"comment:62\" align=\"right\">comment:62</div>\n\nReplying to [@fredrik-johansson](#comment:61):\n> If you use mpz functions, then getting/setting a single entry will be O(n) instead of O(1), and iterating over all entries or creating a sequence from a list of integers will be O(n<sup>2</sup>) instead of O(n).\n\nRight, iteration, access to single items and creation from a list is not as fast as it could be. Can you point me to examples (in Sage? Elsewhere?) showeing how to use 'mpn_*`?\n\nPS: I also forgot to implement pickling.",
    "created_at": "2014-05-30T20:47:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199881",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:62" align="right">comment:62</div>

Replying to [@fredrik-johansson](#comment:61):
> If you use mpz functions, then getting/setting a single entry will be O(n) instead of O(1), and iterating over all entries or creating a sequence from a list of integers will be O(n<sup>2</sup>) instead of O(n).

Right, iteration, access to single items and creation from a list is not as fast as it could be. Can you point me to examples (in Sage? Elsewhere?) showeing how to use 'mpn_*`?

PS: I also forgot to implement pickling.



---

archive/issue_comments_199882.json:
```json
{
    "body": "Changed work issues from **Document cdef functions** to **Document cdef functions. Pickling**",
    "created_at": "2014-05-30T20:47:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199882",
    "user": "https://github.com/simon-king-jena"
}
```

Changed work issues from **Document cdef functions** to **Document cdef functions. Pickling**



---

archive/issue_comments_199883.json:
```json
{
    "body": "<div id=\"comment:63\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8\"><code>64ac7ba</code></a></td><td><code>Pickling of bounded integer sequence. Documentation of cdef functions</code></td></tr></table>\n",
    "created_at": "2014-05-30T21:43:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199883",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:63"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8"><code>64ac7ba</code></a></td><td><code>Pickling of bounded integer sequence. Documentation of cdef functions</code></td></tr></table>




---

archive/issue_comments_199884.json:
```json
{
    "body": "Changed commit from **[`efef80b`](https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301)** to **[`64ac7ba`](https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8)**",
    "created_at": "2014-05-30T21:43:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199884",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`efef80b`](https://github.com/sagemath/sagetrac-mirror/commit/efef80bea22840f618335b7dd6f5d3e9a64fa301)** to **[`64ac7ba`](https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8)**



---

archive/issue_comments_199885.json:
```json
{
    "body": "Changed work issues from **Document cdef functions. Pickling** to **Use mpn_* for speedup of iteration and item access**",
    "created_at": "2014-05-30T21:46:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199885",
    "user": "https://github.com/simon-king-jena"
}
```

Changed work issues from **Document cdef functions. Pickling** to **Use mpn_* for speedup of iteration and item access**



---

archive/issue_comments_199886.json:
```json
{
    "body": "<div id=\"comment:64\" align=\"right\">comment:64</div>\n\nI have documented the cdef functions, and I have implemented pickling. Again (at least for long sequence), this is faster than for ordinary tuples:\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: L = [randint(0,26) for i in range(5000)]\nsage: S = BoundedIntegerSequence(32, L)\nsage: %timeit loads(dumps(S))\n1000 loops, best of 3: 407 \u00b5s per loop\nsage: T = tuple(S)\nsage: %timeit loads(dumps(T))\n100 loops, best of 3: 2.02 ms per loop\n```\n\nI hope there is a nice example for `mpn_*` somewhere.",
    "created_at": "2014-05-30T21:46:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199886",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:64" align="right">comment:64</div>

I have documented the cdef functions, and I have implemented pickling. Again (at least for long sequence), this is faster than for ordinary tuples:

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: L = [randint(0,26) for i in range(5000)]
sage: S = BoundedIntegerSequence(32, L)
sage: %timeit loads(dumps(S))
1000 loops, best of 3: 407 µs per loop
sage: T = tuple(S)
sage: %timeit loads(dumps(T))
100 loops, best of 3: 2.02 ms per loop
```

I hope there is a nice example for `mpn_*` somewhere.



---

archive/issue_comments_199887.json:
```json
{
    "body": "<div id=\"comment:65\" align=\"right\">comment:65</div>\n\nHooray, using mpn_* improves the time to access item 2000 in an integer sequence of bound 32 from 1.49 \u00b5s to 545 ns. With tuples, the access time is 362 ns. So, that's almost competitive.",
    "created_at": "2014-05-31T19:25:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199887",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:65" align="right">comment:65</div>

Hooray, using mpn_* improves the time to access item 2000 in an integer sequence of bound 32 from 1.49 µs to 545 ns. With tuples, the access time is 362 ns. So, that's almost competitive.



---

archive/issue_comments_199888.json:
```json
{
    "body": "<div id=\"comment:66\" align=\"right\">comment:66</div>\n\nAnother hooray: Conversion of a list of 5000 integers to a bounded integer sequence of bound 32 improved from 3.25 ms to 75.3 \u00b5s. Conversion to a tuple only takes 19.6 \u00b5s, but I doubt that this will be possible to beat.",
    "created_at": "2014-06-01T01:57:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199888",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:66" align="right">comment:66</div>

Another hooray: Conversion of a list of 5000 integers to a bounded integer sequence of bound 32 improved from 3.25 ms to 75.3 µs. Conversion to a tuple only takes 19.6 µs, but I doubt that this will be possible to beat.



---

archive/issue_comments_199889.json:
```json
{
    "body": "<div id=\"comment:67\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/050b118c9ce92b3c640ad4ea66b5c02dce87a172\"><code>050b118</code></a></td><td><code>Improve access to items of bounded integer sequences</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c2e35470203398b1636175965cc8b1fdc89549b9\"><code>c2e3547</code></a></td><td><code>Improve conversion \"list->bounded integer sequence\"</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7\"><code>836f63f</code></a></td><td><code>Improve iteration and list/string conversion of bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-06-01T12:02:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199889",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:67"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/050b118c9ce92b3c640ad4ea66b5c02dce87a172"><code>050b118</code></a></td><td><code>Improve access to items of bounded integer sequences</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c2e35470203398b1636175965cc8b1fdc89549b9"><code>c2e3547</code></a></td><td><code>Improve conversion "list->bounded integer sequence"</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7"><code>836f63f</code></a></td><td><code>Improve iteration and list/string conversion of bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_199890.json:
```json
{
    "body": "Changed commit from **[`64ac7ba`](https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8)** to **[`836f63f`](https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7)**",
    "created_at": "2014-06-01T12:02:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199890",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`64ac7ba`](https://github.com/sagemath/sagetrac-mirror/commit/64ac7bab9d4c85136e9845878d69d82be7c300f8)** to **[`836f63f`](https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7)**



---

archive/issue_comments_199891.json:
```json
{
    "body": "<div id=\"comment:68\" align=\"right\">comment:68</div>\n\nThere remains to improve computation of the index of an item or of a sub-sequence, and slicing. When this is done, I'll provide updated benchmarks.",
    "created_at": "2014-06-01T12:03:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199891",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:68" align="right">comment:68</div>

There remains to improve computation of the index of an item or of a sub-sequence, and slicing. When this is done, I'll provide updated benchmarks.



---

archive/issue_comments_199892.json:
```json
{
    "body": "<div id=\"comment:69\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515\"><code>c8a299b</code></a></td><td><code>More documentation of bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-06-01T12:37:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199892",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:69"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515"><code>c8a299b</code></a></td><td><code>More documentation of bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_199893.json:
```json
{
    "body": "Changed commit from **[`836f63f`](https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7)** to **[`c8a299b`](https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515)**",
    "created_at": "2014-06-01T12:37:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199893",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`836f63f`](https://github.com/sagemath/sagetrac-mirror/commit/836f63fb96241033953e42d6d18becfaa4fe33b7)** to **[`c8a299b`](https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515)**



---

archive/issue_comments_199894.json:
```json
{
    "body": "<div id=\"comment:70\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/775d7955c67cb27af3ec8877491a3d7478fa8579\"><code>775d795</code></a></td><td><code>Improve index computation for bounded integer sequences</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/391a102f2b5623979c214a725092eeb3dbe180f6\"><code>391a102</code></a></td><td><code>Improve bounded integer subsequent containment test</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644\"><code>735939e</code></a></td><td><code>Improve slicing of bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-06-03T10:13:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199894",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:70"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/775d7955c67cb27af3ec8877491a3d7478fa8579"><code>775d795</code></a></td><td><code>Improve index computation for bounded integer sequences</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/391a102f2b5623979c214a725092eeb3dbe180f6"><code>391a102</code></a></td><td><code>Improve bounded integer subsequent containment test</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644"><code>735939e</code></a></td><td><code>Improve slicing of bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_199895.json:
```json
{
    "body": "Changed commit from **[`c8a299b`](https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515)** to **[`735939e`](https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644)**",
    "created_at": "2014-06-03T10:13:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199895",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`c8a299b`](https://github.com/sagemath/sagetrac-mirror/commit/c8a299ba54fa05d6851fd492019d9996e7e31515)** to **[`735939e`](https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644)**



---

archive/issue_comments_199896.json:
```json
{
    "body": "<div id=\"comment:71\" align=\"right\">comment:71</div>\n\nUsing the `mpn_*` function was a very good idea. Some basic operations are a lot faster now. Here I am repeating (and slightly extending) my earlier benchmarks for those operations that have changed in the recent commits:\n\n__The test bed__\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\n```\n\n__Conversion list -> tuple/sequence__\n\n```\nsage: %timeit x = tuple(L0)\n1000000 loops, best of 3: 307 ns per loop\nsage: %timeit x = tuple(L1)\n1000000 loops, best of 3: 369 ns per loop\nsage: %timeit x = tuple(L2)\n1000000 loops, best of 3: 534 ns per loop\nsage: %timeit x = tuple(L3)\n10000 loops, best of 3: 19.6 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.34 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n1000000 loops, best of 3: 1.57 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n100000 loops, best of 3: 2.06 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n10000 loops, best of 3: 76.7 \u00b5s per loop\n```\nConversion to a tuple seems to be roughly 4 times faster. But I don't think this will be critical (at least not in my own applications...)\n\n__Conversion tuple/sequence -> list__\n\n```\nsage: %timeit x = list(T0)\n1000000 loops, best of 3: 537 ns per loop\nsage: %timeit x = list(T1)\n1000000 loops, best of 3: 624 ns per loop\nsage: %timeit x = list(T2)\n1000000 loops, best of 3: 752 ns per loop\nsage: %timeit x = list(T3)\n100000 loops, best of 3: 22.6 \u00b5s per loop\nsage: %timeit x = list(S0)\n1000000 loops, best of 3: 1.58 \u00b5s per loop\nsage: %timeit x = list(S1)\n100000 loops, best of 3: 2.06 \u00b5s per loop\nsage: %timeit x = list(S2)\n100000 loops, best of 3: 4.19 \u00b5s per loop\nsage: %timeit x = list(S3)\n1000 loops, best of 3: 253 \u00b5s per loop\nsage: %timeit x = S0.list()\n1000000 loops, best of 3: 1.05 \u00b5s per loop\nsage: %timeit x = S1.list()\n1000000 loops, best of 3: 1.87 \u00b5s per loop\nsage: %timeit x = S2.list()\n100000 loops, best of 3: 4.95 \u00b5s per loop\nsage: %timeit x = S3.list()\n1000 loops, best of 3: 306 \u00b5s per loop\n```\nThe gap between lists and sequences strongly depends on the bound of the sequence, which is not much of a surprise. Anyway, it is faster than before.\n\n__Slicing__\n\nFor step 1, short tuples are faster than short sequences, but long sequences are faster than long tuples:\n\n```\nsage: timeit(\"x=T0[:-1]\", number=100000)\n100000 loops, best of 3: 479 ns per loop\nsage: timeit(\"x=T1[:-1]\", number=100000)\n100000 loops, best of 3: 548 ns per loop\nsage: timeit(\"x=T2[:-1]\", number=100000)\n100000 loops, best of 3: 773 ns per loop\nsage: timeit(\"x=T3[:-1]\", number=100000)\n100000 loops, best of 3: 19.6 \u00b5s per loop\nsage: timeit(\"x=S0[:-1]\", number=100000)\n100000 loops, best of 3: 1.75 \u00b5s per loop\nsage: timeit(\"x=S1[:-1]\", number=100000)\n100000 loops, best of 3: 1.8 \u00b5s per loop\nsage: timeit(\"x=S2[:-1]\", number=100000)\n100000 loops, best of 3: 1.77 \u00b5s per loop\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 2.4 \u00b5s per loop\n```\nAs before, a step different from 1 is bad for sequences. However, there is an improvement compared with the previous timings:\n\n```\nsage: timeit(\"x=T2[:-1:2]\", number=100000)\n100000 loops, best of 3: 944 ns per loop\nsage: timeit(\"x=T3[:-1:2]\", number=100000)\n100000 loops, best of 3: 11.8 \u00b5s per loop\nsage: timeit(\"x=S2[:-1:2]\", number=10000)\n10000 loops, best of 3: 2.7 \u00b5s per loop\nsage: timeit(\"x=S3[:-1:2]\", number=10000)\n10000 loops, best of 3: 52.2 \u00b5s per loop\n```\n\n__Accessing single items__\n\nBounded integer sequences can now compete with tuples, both short and long!\n\n```\nsage: timeit(\"x=T0[1]\", number=1000000)\n1000000 loops, best of 3: 349 ns per loop\nsage: timeit(\"x=T0[4]\", number=1000000)\n1000000 loops, best of 3: 351 ns per loop\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 354 ns per loop\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 355 ns per loop\nsage: timeit(\"x=T3[1]\", number=1000000)\n1000000 loops, best of 3: 346 ns per loop\nsage: timeit(\"x=T3[4500]\", number=1000000)\n1000000 loops, best of 3: 347 ns per loop\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 350 ns per loop\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 370 ns per loop\n```\n\n__Containment tests__\n\nHere we talk about operations that do not exist in this form for tuples (e.g., subsequence tests). They have been improved by the latest commits:\n\n```\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: S1y = BoundedIntegerSequence(16, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S1y==S1!=S1x, S1y is not S1\n(True, True)\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0z2.startswith(S0)\", number=1000000)\n1000000 loops, best of 3: 230 ns per loop\nsage: timeit(\"S0z2.startswith(S0x)\", number=1000000)\n1000000 loops, best of 3: 236 ns per loop\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 511 ns per loop\nsage: timeit(\"S1z2.startswith(S1)\", number=1000000)\n1000000 loops, best of 3: 215 ns per loop\nsage: timeit(\"S1z2.startswith(S1x)\", number=1000000)\n1000000 loops, best of 3: 219 ns per loop\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 692 ns per loop\nsage: timeit(\"S2z2.startswith(S2)\", number=1000000)\n1000000 loops, best of 3: 238 ns per loop\nsage: timeit(\"S2z2.startswith(S2x)\", number=1000000)\n1000000 loops, best of 3: 228 ns per loop\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 1.92 \u00b5s per loop\nsage: timeit(\"S3z2.startswith(S3)\", number=1000000)\n1000000 loops, best of 3: 981 ns per loop\nsage: timeit(\"S3z2.startswith(S3x)\", number=1000000)\n1000000 loops, best of 3: 213 ns per loop\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 2.41 ms per loop\n```\n\n__Conclusion__\n\n- Slicing and iteration are still a weak point of bounded integer sequences. However, there is an improvement by the latest commits.\n- Access to single items is now competitive. Some other operations have been competitive or superior before.\n- Probably iteration and slicing could be improved with more complicated code: Currently, I take a single item, do a bitshift (which is faster than before!) and then proceed with the next item. But since several items usually fit into one \"limb\" (this is how GMP stores the data), it would be possible to accumulate a group of items into one limb, then do a *single* bitshift for this group of items, and then proceed to the next group of items. I would consider to implement it if my own applications show the need for it...\n\nNeeds review, I think! Please check if I produced a memory leak (by not freeing allocated temporary data), a memory corruption (by messing up in the case of items that are stored exactly on the seam between two limbs), or functions in which a memory error or keyboard interrupt would not be propagated. I plan to do such tests, too, but I suppose 4 or 6 eyes see more than 2.",
    "created_at": "2014-06-03T11:17:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199896",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:71" align="right">comment:71</div>

Using the `mpn_*` function was a very good idea. Some basic operations are a lot faster now. Here I am repeating (and slightly extending) my earlier benchmarks for those operations that have changed in the recent commits:

__The test bed__

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
```

__Conversion list -> tuple/sequence__

```
sage: %timeit x = tuple(L0)
1000000 loops, best of 3: 307 ns per loop
sage: %timeit x = tuple(L1)
1000000 loops, best of 3: 369 ns per loop
sage: %timeit x = tuple(L2)
1000000 loops, best of 3: 534 ns per loop
sage: %timeit x = tuple(L3)
10000 loops, best of 3: 19.6 µs per loop
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.34 µs per loop
sage: %timeit x = BoundedIntegerSequence(16, L1)
1000000 loops, best of 3: 1.57 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L2)
100000 loops, best of 3: 2.06 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L3)
10000 loops, best of 3: 76.7 µs per loop
```
Conversion to a tuple seems to be roughly 4 times faster. But I don't think this will be critical (at least not in my own applications...)

__Conversion tuple/sequence -> list__

```
sage: %timeit x = list(T0)
1000000 loops, best of 3: 537 ns per loop
sage: %timeit x = list(T1)
1000000 loops, best of 3: 624 ns per loop
sage: %timeit x = list(T2)
1000000 loops, best of 3: 752 ns per loop
sage: %timeit x = list(T3)
100000 loops, best of 3: 22.6 µs per loop
sage: %timeit x = list(S0)
1000000 loops, best of 3: 1.58 µs per loop
sage: %timeit x = list(S1)
100000 loops, best of 3: 2.06 µs per loop
sage: %timeit x = list(S2)
100000 loops, best of 3: 4.19 µs per loop
sage: %timeit x = list(S3)
1000 loops, best of 3: 253 µs per loop
sage: %timeit x = S0.list()
1000000 loops, best of 3: 1.05 µs per loop
sage: %timeit x = S1.list()
1000000 loops, best of 3: 1.87 µs per loop
sage: %timeit x = S2.list()
100000 loops, best of 3: 4.95 µs per loop
sage: %timeit x = S3.list()
1000 loops, best of 3: 306 µs per loop
```
The gap between lists and sequences strongly depends on the bound of the sequence, which is not much of a surprise. Anyway, it is faster than before.

__Slicing__

For step 1, short tuples are faster than short sequences, but long sequences are faster than long tuples:

```
sage: timeit("x=T0[:-1]", number=100000)
100000 loops, best of 3: 479 ns per loop
sage: timeit("x=T1[:-1]", number=100000)
100000 loops, best of 3: 548 ns per loop
sage: timeit("x=T2[:-1]", number=100000)
100000 loops, best of 3: 773 ns per loop
sage: timeit("x=T3[:-1]", number=100000)
100000 loops, best of 3: 19.6 µs per loop
sage: timeit("x=S0[:-1]", number=100000)
100000 loops, best of 3: 1.75 µs per loop
sage: timeit("x=S1[:-1]", number=100000)
100000 loops, best of 3: 1.8 µs per loop
sage: timeit("x=S2[:-1]", number=100000)
100000 loops, best of 3: 1.77 µs per loop
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 2.4 µs per loop
```
As before, a step different from 1 is bad for sequences. However, there is an improvement compared with the previous timings:

```
sage: timeit("x=T2[:-1:2]", number=100000)
100000 loops, best of 3: 944 ns per loop
sage: timeit("x=T3[:-1:2]", number=100000)
100000 loops, best of 3: 11.8 µs per loop
sage: timeit("x=S2[:-1:2]", number=10000)
10000 loops, best of 3: 2.7 µs per loop
sage: timeit("x=S3[:-1:2]", number=10000)
10000 loops, best of 3: 52.2 µs per loop
```

__Accessing single items__

Bounded integer sequences can now compete with tuples, both short and long!

```
sage: timeit("x=T0[1]", number=1000000)
1000000 loops, best of 3: 349 ns per loop
sage: timeit("x=T0[4]", number=1000000)
1000000 loops, best of 3: 351 ns per loop
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 354 ns per loop
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 355 ns per loop
sage: timeit("x=T3[1]", number=1000000)
1000000 loops, best of 3: 346 ns per loop
sage: timeit("x=T3[4500]", number=1000000)
1000000 loops, best of 3: 347 ns per loop
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 350 ns per loop
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 370 ns per loop
```

__Containment tests__

Here we talk about operations that do not exist in this form for tuples (e.g., subsequence tests). They have been improved by the latest commits:

```
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: S1y = BoundedIntegerSequence(16, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S1y==S1!=S1x, S1y is not S1
(True, True)
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0z2.startswith(S0)", number=1000000)
1000000 loops, best of 3: 230 ns per loop
sage: timeit("S0z2.startswith(S0x)", number=1000000)
1000000 loops, best of 3: 236 ns per loop
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 511 ns per loop
sage: timeit("S1z2.startswith(S1)", number=1000000)
1000000 loops, best of 3: 215 ns per loop
sage: timeit("S1z2.startswith(S1x)", number=1000000)
1000000 loops, best of 3: 219 ns per loop
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 692 ns per loop
sage: timeit("S2z2.startswith(S2)", number=1000000)
1000000 loops, best of 3: 238 ns per loop
sage: timeit("S2z2.startswith(S2x)", number=1000000)
1000000 loops, best of 3: 228 ns per loop
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 1.92 µs per loop
sage: timeit("S3z2.startswith(S3)", number=1000000)
1000000 loops, best of 3: 981 ns per loop
sage: timeit("S3z2.startswith(S3x)", number=1000000)
1000000 loops, best of 3: 213 ns per loop
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 2.41 ms per loop
```

__Conclusion__

- Slicing and iteration are still a weak point of bounded integer sequences. However, there is an improvement by the latest commits.
- Access to single items is now competitive. Some other operations have been competitive or superior before.
- Probably iteration and slicing could be improved with more complicated code: Currently, I take a single item, do a bitshift (which is faster than before!) and then proceed with the next item. But since several items usually fit into one "limb" (this is how GMP stores the data), it would be possible to accumulate a group of items into one limb, then do a *single* bitshift for this group of items, and then proceed to the next group of items. I would consider to implement it if my own applications show the need for it...

Needs review, I think! Please check if I produced a memory leak (by not freeing allocated temporary data), a memory corruption (by messing up in the case of items that are stored exactly on the seam between two limbs), or functions in which a memory error or keyboard interrupt would not be propagated. I plan to do such tests, too, but I suppose 4 or 6 eyes see more than 2.



---

archive/issue_events_225899.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-03T11:17:38Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225899"
}
```



---

archive/issue_events_225900.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-03T11:17:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225900"
}
```



---

archive/issue_comments_199897.json:
```json
{
    "body": "<div id=\"comment:72\" align=\"right\">comment:72</div>\n\nI found failures in *some* runs:\n\n```\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-10-7f6bcfa0.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n**********************************************************************\nFile \"src/sage/misc/bounded_integer_sequences.pyx\", line 1059, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__\nFailed example:\n    S+T\nExpected:\n    <4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 15>\nGot:\n    <4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 31>\n**********************************************************************\n1 item had failures:\n   1 of  10 in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__\n    [178 tests, 1 failure, 0.79 s]\n----------------------------------------------------------------------\nsage -t src/sage/misc/bounded_integer_sequences.pyx  # 1 doctest failed\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-15-6cf37501.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.78 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-20-d43d6691.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n**********************************************************************\nFile \"src/sage/misc/bounded_integer_sequences.pyx\", line 1061, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__\nFailed example:\n    T+S\nExpected:\n    <4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 9>\nGot:\n    <4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 25>\n**********************************************************************\n1 item had failures:\n   1 of  10 in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__\n    [178 tests, 1 failure, 0.78 s]\n----------------------------------------------------------------------\nsage -t src/sage/misc/bounded_integer_sequences.pyx  # 1 doctest failed\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-25-04f71350.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.78 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-29-a2a81517.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.79 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-33-e89cc5fe.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.81 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\nking@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx \nRunning doctests with ID 2014-06-03-13-33-38-83426cf0.\nDoctesting 1 file.\nsage -t src/sage/misc/bounded_integer_sequences.pyx\n    [178 tests, 0.79 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 0.9 seconds\n    cpu time: 0.8 seconds\n    cumulative wall time: 0.8 seconds\n```\n\nMy first guess is that this comes from using `sage_malloc` in some places, i.e., I should zero the memory first.",
    "created_at": "2014-06-03T11:35:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199897",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:72" align="right">comment:72</div>

I found failures in *some* runs:

```
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-10-7f6bcfa0.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
**********************************************************************
File "src/sage/misc/bounded_integer_sequences.pyx", line 1059, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__
Failed example:
    S+T
Expected:
    <4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 15>
Got:
    <4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 31>
**********************************************************************
1 item had failures:
   1 of  10 in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__
    [178 tests, 1 failure, 0.79 s]
----------------------------------------------------------------------
sage -t src/sage/misc/bounded_integer_sequences.pyx  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-15-6cf37501.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.78 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-20-d43d6691.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
**********************************************************************
File "src/sage/misc/bounded_integer_sequences.pyx", line 1061, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__
Failed example:
    T+S
Expected:
    <4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 9>
Got:
    <4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 25>
**********************************************************************
1 item had failures:
   1 of  10 in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__add__
    [178 tests, 1 failure, 0.78 s]
----------------------------------------------------------------------
sage -t src/sage/misc/bounded_integer_sequences.pyx  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-25-04f71350.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.78 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-29-a2a81517.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.79 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-33-e89cc5fe.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.81 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
king@linux-etl7:~/Sage/git/sage> ./sage -t src/sage/misc/bounded_integer_sequences.pyx 
Running doctests with ID 2014-06-03-13-33-38-83426cf0.
Doctesting 1 file.
sage -t src/sage/misc/bounded_integer_sequences.pyx
    [178 tests, 0.79 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 0.9 seconds
    cpu time: 0.8 seconds
    cumulative wall time: 0.8 seconds
```

My first guess is that this comes from using `sage_malloc` in some places, i.e., I should zero the memory first.



---

archive/issue_comments_199898.json:
```json
{
    "body": "Changed work issues from **Use mpn_* for speedup of iteration and item access** to **Fix flakyness in adding sequences**",
    "created_at": "2014-06-03T11:35:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199898",
    "user": "https://github.com/simon-king-jena"
}
```

Changed work issues from **Use mpn_* for speedup of iteration and item access** to **Fix flakyness in adding sequences**



---

archive/issue_events_225901.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-03T11:35:54Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225901"
}
```



---

archive/issue_events_225902.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-03T11:35:54Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225902"
}
```



---

archive/issue_comments_199899.json:
```json
{
    "body": "<div id=\"comment:73\" align=\"right\">comment:73</div>\n\nThere is something seriously broken, and apparently in the last limb of stuff:\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])\nsage: T = BoundedIntegerSequence(21, [4,1,6,2,8,15])\nsage: S+T\n<4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 15>\nsage: T+S\n<4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 9>\nsage: S+T\n<4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 31>\n```\nMy current guess is that in some place I get the number of limbs wrong when I manually assign it to the underlying `mpz_t`.",
    "created_at": "2014-06-03T13:36:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199899",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:73" align="right">comment:73</div>

There is something seriously broken, and apparently in the last limb of stuff:

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])
sage: T = BoundedIntegerSequence(21, [4,1,6,2,8,15])
sage: S+T
<4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 15>
sage: T+S
<4, 1, 6, 2, 8, 15, 4, 1, 6, 2, 7, 20, 9>
sage: S+T
<4, 1, 6, 2, 7, 20, 9, 4, 1, 6, 2, 8, 31>
```
My current guess is that in some place I get the number of limbs wrong when I manually assign it to the underlying `mpz_t`.



---

archive/issue_comments_199900.json:
```json
{
    "body": "<div id=\"comment:74\" align=\"right\">comment:74</div>\n\nNow I can explain what goes wrong in above example.\n\nGMP has its limbs, and I have my sequence items. In the example, each item consumes 5 bit, but each limb comprises 32 bit. As it happens, the last bit of my last item is 0, and the last limb *only* stores this single zero bit. Hence, when I ask GMP to do high-level operations (which makes sense for concatenation, I wouldn't like to do it low-level), GMP tries to be clever and drops the last limb, since it is zero. But when I transform the result to a list, I want to access the last bit. But since the last bit is not in a limb any longer, it belongs to non-allocated memory. Hence, randomly, the last bit can be 0 or 1, which explains why in the example above the difference between the correct and the wrong last item is 16.\n\nSo, what I should do: When transforming a sequence to a string or list (or when iterating), I should check whether I am running outside of GMP's limbs. Alternatively, I should provide a bit 1 right behind of my last item, so that GMP will not drop the last limb (as I forced it to be non-zero).",
    "created_at": "2014-06-03T14:30:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199900",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:74" align="right">comment:74</div>

Now I can explain what goes wrong in above example.

GMP has its limbs, and I have my sequence items. In the example, each item consumes 5 bit, but each limb comprises 32 bit. As it happens, the last bit of my last item is 0, and the last limb *only* stores this single zero bit. Hence, when I ask GMP to do high-level operations (which makes sense for concatenation, I wouldn't like to do it low-level), GMP tries to be clever and drops the last limb, since it is zero. But when I transform the result to a list, I want to access the last bit. But since the last bit is not in a limb any longer, it belongs to non-allocated memory. Hence, randomly, the last bit can be 0 or 1, which explains why in the example above the difference between the correct and the wrong last item is 16.

So, what I should do: When transforming a sequence to a string or list (or when iterating), I should check whether I am running outside of GMP's limbs. Alternatively, I should provide a bit 1 right behind of my last item, so that GMP will not drop the last limb (as I forced it to be non-zero).



---

archive/issue_comments_199901.json:
```json
{
    "body": "<div id=\"comment:75\" align=\"right\">comment:75</div>\n\nAlternatively, I could replace all `mpz_*` by `mpn_*`. But that would be boring.",
    "created_at": "2014-06-03T14:35:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199901",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:75" align="right">comment:75</div>

Alternatively, I could replace all `mpz_*` by `mpn_*`. But that would be boring.



---

archive/issue_comments_199902.json:
```json
{
    "body": "<div id=\"comment:76\" align=\"right\">comment:76</div>\n\nPS: Adding sequences that are constant zero exhibits the same problem.",
    "created_at": "2014-06-03T14:52:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199902",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:76" align="right">comment:76</div>

PS: Adding sequences that are constant zero exhibits the same problem.



---

archive/issue_comments_199903.json:
```json
{
    "body": "<div id=\"comment:77\" align=\"right\">comment:77</div>\n\nI found examples that used to trigger the above-mentioned problems reliably. So, they will be added to the docs. I fixed the iteration problem, but I am still struggling with pickling.",
    "created_at": "2014-06-04T15:15:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199903",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:77" align="right">comment:77</div>

I found examples that used to trigger the above-mentioned problems reliably. So, they will be added to the docs. I fixed the iteration problem, but I am still struggling with pickling.



---

archive/issue_comments_199904.json:
```json
{
    "body": "<div id=\"comment:78\" align=\"right\">comment:78</div>\n\nVery odd. Could it be that I hit a bug in GMP in the conversion of an integer to a string representation at base `2^n`? Namely, in my examples, the 32-adic string representation used to pickle a bounded integer sequence is not representing the stored bit array, but the 31-adic or 10-adic string representation works fine (but probably is slower).\n\nThis seems to happen when the last limb used to store a GMP integer is in fact zero.",
    "created_at": "2014-06-04T15:36:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199904",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:78" align="right">comment:78</div>

Very odd. Could it be that I hit a bug in GMP in the conversion of an integer to a string representation at base `2^n`? Namely, in my examples, the 32-adic string representation used to pickle a bounded integer sequence is not representing the stored bit array, but the 31-adic or 10-adic string representation works fine (but probably is slower).

This seems to happen when the last limb used to store a GMP integer is in fact zero.



---

archive/issue_comments_199905.json:
```json
{
    "body": "<div id=\"comment:79\" align=\"right\">comment:79</div>\n\nYes, setting the `_mp_size` field of `__mpz_struct` in such a way that the limb `_mp_d[_mp_size-1]` is non-zero solves the problem. I thought GMP would cope with \"superfluous\" zeroes, but in string representation it does not.\n\nSo, I have to check where I have been lazy with the `_mp_size` field when using `mpn_*` functions.",
    "created_at": "2014-06-04T15:56:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199905",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:79" align="right">comment:79</div>

Yes, setting the `_mp_size` field of `__mpz_struct` in such a way that the limb `_mp_d[_mp_size-1]` is non-zero solves the problem. I thought GMP would cope with "superfluous" zeroes, but in string representation it does not.

So, I have to check where I have been lazy with the `_mp_size` field when using `mpn_*` functions.



---

archive/issue_comments_199906.json:
```json
{
    "body": "<div id=\"comment:80\" align=\"right\">comment:80</div>\n\nCurrent status is a struggle with sub-sequence recognition in the presence of trailing zeroes.\n\nHere is the type of examples that I propose:\n- Use a sequence of length 7 with a bound of 32. Then, we need 35 bit to store the sequence.\n- At least on my machine, a GMP limb comprises 32 bit. Hence, the above sequence fits into two limbs, we only use three bit of the second limb.\n- Choose the last item of the sequence such that it fits into 2 bit. Then, the three bit stored in the second limb are zero.\n- Now, do an operation that involves a `mpz_*` function to create a new bounded integer sequence, *only* adding trailing zeroes. This currently is in concatenation and slicing. This may result in GMP cutting off the trailing zeroes.\n\nWhen we then do operations involving `mpn_*` functions, it is needed to take care of the cut off bits (and treat them as zero). My current private branch (not pushed yet) involves several tests that are failing with the branch currently attached here, but succeed in my current branch.\n\nStill failing is this:\n\n```\n            sage: X = BoundedIntegerSequence(21, [4,1,6,2,7,2,3])\n            sage: S = BoundedIntegerSequence(21, [0,0,0,0,0,0,0])\n            sage: loads(dumps(X+S))\n            <4, 1, 6, 2, 7, 2, 3, 0, 0, 0, 0, 0, 0, 0>\n            sage: loads(dumps(X+S)) == X+S\n            True\n            sage: T = BoundedIntegerSequence(21, [0,4,0,1,0,6,0,2,0,7,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0])\n            sage: T[3::2]==(X+S)[1:]\n            True\n            sage: T[3::2] in X+S\n            False     # should return True!\n```\n\nEDIT: Recall that providing bound 21 will internally changed into the next power of two, hence, 32.",
    "created_at": "2014-06-05T15:01:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199906",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:80" align="right">comment:80</div>

Current status is a struggle with sub-sequence recognition in the presence of trailing zeroes.

Here is the type of examples that I propose:
- Use a sequence of length 7 with a bound of 32. Then, we need 35 bit to store the sequence.
- At least on my machine, a GMP limb comprises 32 bit. Hence, the above sequence fits into two limbs, we only use three bit of the second limb.
- Choose the last item of the sequence such that it fits into 2 bit. Then, the three bit stored in the second limb are zero.
- Now, do an operation that involves a `mpz_*` function to create a new bounded integer sequence, *only* adding trailing zeroes. This currently is in concatenation and slicing. This may result in GMP cutting off the trailing zeroes.

When we then do operations involving `mpn_*` functions, it is needed to take care of the cut off bits (and treat them as zero). My current private branch (not pushed yet) involves several tests that are failing with the branch currently attached here, but succeed in my current branch.

Still failing is this:

```
            sage: X = BoundedIntegerSequence(21, [4,1,6,2,7,2,3])
            sage: S = BoundedIntegerSequence(21, [0,0,0,0,0,0,0])
            sage: loads(dumps(X+S))
            <4, 1, 6, 2, 7, 2, 3, 0, 0, 0, 0, 0, 0, 0>
            sage: loads(dumps(X+S)) == X+S
            True
            sage: T = BoundedIntegerSequence(21, [0,4,0,1,0,6,0,2,0,7,0,2,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0])
            sage: T[3::2]==(X+S)[1:]
            True
            sage: T[3::2] in X+S
            False     # should return True!
```

EDIT: Recall that providing bound 21 will internally changed into the next power of two, hence, 32.



---

archive/issue_comments_199907.json:
```json
{
    "body": "Changed commit from **[`735939e`](https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644)** to **[`c900a2c`](https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958)**",
    "created_at": "2014-06-05T21:10:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199907",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`735939e`](https://github.com/sagemath/sagetrac-mirror/commit/735939e593c9c302ff42c4973cbfe2e48eb22644)** to **[`c900a2c`](https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958)**



---

archive/issue_comments_199908.json:
```json
{
    "body": "<div id=\"comment:81\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958\"><code>c900a2c</code></a></td><td><code>Take care of GMP's removal of trailing zeroes</code></td></tr></table>\n",
    "created_at": "2014-06-05T21:10:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199908",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:81"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958"><code>c900a2c</code></a></td><td><code>Take care of GMP's removal of trailing zeroes</code></td></tr></table>




---

archive/issue_events_225903.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-05T21:14:02Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225903"
}
```



---

archive/issue_events_225904.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-05T21:14:02Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225904"
}
```



---

archive/issue_comments_199909.json:
```json
{
    "body": "Changed work issues from **Fix flakyness in adding sequences** to none",
    "created_at": "2014-06-05T21:14:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199909",
    "user": "https://github.com/simon-king-jena"
}
```

Changed work issues from **Fix flakyness in adding sequences** to none



---

archive/issue_comments_199910.json:
```json
{
    "body": "<div id=\"comment:82\" align=\"right\">comment:82</div>\n\nI solved the problems with wrong sizes / trailing zeroes. I added all tests that used to fail with previous versions as doc tests. All tests are passing now. Hence: Needs review again. Tomorrow, I'll provide new timings, as the new sanity checks may result in a small slow-down. We will see...",
    "created_at": "2014-06-05T21:14:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199910",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:82" align="right">comment:82</div>

I solved the problems with wrong sizes / trailing zeroes. I added all tests that used to fail with previous versions as doc tests. All tests are passing now. Hence: Needs review again. Tomorrow, I'll provide new timings, as the new sanity checks may result in a small slow-down. We will see...



---

archive/issue_comments_199911.json:
```json
{
    "body": "<div id=\"comment:83\" align=\"right\">comment:83</div>\n\nRepeating the tests, in each case (even when the underlying function has not changed) stating the timing of the old code:\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.4 \u00b5s per loop  # was 1.34 \u00b5s\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n1000000 loops, best of 3: 1.59 \u00b5s per loop # was 1.57 \u00b5s\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n100000 loops, best of 3: 2.13 \u00b5s per loop  # was 2.06 \u00b5s\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n10000 loops, best of 3: 76.3 \u00b5s per loop   # was 76.7 \u00b5s\n```\nIt surprises me that some of the following became faster:\n\n```\nsage: %timeit x = list(S0)\n1000000 loops, best of 3: 1.55 \u00b5s per loop # was 1.58 \u00b5s\nsage: %timeit x = list(S1)\n100000 loops, best of 3: 2.14 \u00b5s per loop  # was 2.06 \u00b5s\nsage: %timeit x = list(S2)\n100000 loops, best of 3: 4.31 \u00b5s per loop  # was 4.19 \u00b5s\nsage: %timeit x = list(S3)\n1000 loops, best of 3: 274 \u00b5s per loop     # was 253 \u00b5s\nsage: %timeit x = S0.list()\n1000000 loops, best of 3: 810 ns per loop  # was 1.05 \u00b5s\nsage: %timeit x = S1.list()\n1000000 loops, best of 3: 1.22 \u00b5s per loop # was 1.87 \u00b5s\nsage: %timeit x = S2.list()\n100000 loops, best of 3: 2.9 \u00b5s per loop   # was 4.95 \u00b5s\nsage: %timeit x = S3.list()\n10000 loops, best of 3: 105 \u00b5s per loop    # was 306 \u00b5s\n```\n\n```\nsage: timeit(\"x=S0[:-1]\", number=100000)\n100000 loops, best of 3: 1.76 \u00b5s per loop  # was 1.75 \u00b5s\nsage: timeit(\"x=S1[:-1]\", number=100000)\n100000 loops, best of 3: 1.76 \u00b5s per loop  # was 1.8 \u00b5s\nsage: timeit(\"x=S2[:-1]\", number=100000)\n100000 loops, best of 3: 1.78 \u00b5s per loop  # was 1.77 \u00b5s\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 2.46 \u00b5s per loop  # was 2.4 \u00b5s\n```\n\n```\nsage: timeit(\"x=S2[:-1:2]\", number=10000)\n10000 loops, best of 3: 2.68 \u00b5s per loop   # was 2.7 \u00b5s\nsage: timeit(\"x=S3[:-1:2]\", number=10000)\n10000 loops, best of 3: 52.2 \u00b5s per loop   # was 52.2 \u00b5s\n```\nThe following apparently became slower:\n\n```\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 370 ns per loop  # was 354 ns\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 375 ns per loop  # was 355 ns\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 371 ns per loop  # was 350 ns\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 391 ns per loop  # was 370 ns\n```\n\n```\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: S1y = BoundedIntegerSequence(16, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S1y==S1!=S1x, S1y is not S1\n(True, True)\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0z2.startswith(S0)\", number=1000000)\n1000000 loops, best of 3: 233 ns per loop  # was 230 ns\nsage: timeit(\"S0z2.startswith(S0x)\", number=1000000)\n1000000 loops, best of 3: 238 ns per loop  # was 236 ns\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 457 ns per loop  # was 511 ns\nsage: timeit(\"S1z2.startswith(S1)\", number=1000000)\n1000000 loops, best of 3: 219 ns per loop  # was 215 ns\nsage: timeit(\"S1z2.startswith(S1x)\", number=1000000)\n1000000 loops, best of 3: 223 ns per loop  # was 219 ns\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 813 ns per loop  # was 692 ns\nsage: timeit(\"S2z2.startswith(S2)\", number=1000000)\n1000000 loops, best of 3: 244 ns per loop  # was 238 ns\nsage: timeit(\"S2z2.startswith(S2x)\", number=1000000)\n1000000 loops, best of 3: 223 ns per loop  # was 228 ns\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 5.59 \u00b5s per loop # was 1.92 \u00b5s\nsage: timeit(\"S3z2.startswith(S3)\", number=1000000)\n1000000 loops, best of 3: 990 ns per loop  # was 981 ns\nsage: timeit(\"S3z2.startswith(S3x)\", number=1000000)\n1000000 loops, best of 3: 216 ns per loop  # was 213 ns\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 2.33 ms per loop    # was 2.41 ms\n```\n\nSo, overall, I think that the timings are still decent and it makes sense to use bounded integer sequences as replacement of tuples in some applications.",
    "created_at": "2014-06-06T11:36:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199911",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:83" align="right">comment:83</div>

Repeating the tests, in each case (even when the underlying function has not changed) stating the timing of the old code:

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.4 µs per loop  # was 1.34 µs
sage: %timeit x = BoundedIntegerSequence(16, L1)
1000000 loops, best of 3: 1.59 µs per loop # was 1.57 µs
sage: %timeit x = BoundedIntegerSequence(32, L2)
100000 loops, best of 3: 2.13 µs per loop  # was 2.06 µs
sage: %timeit x = BoundedIntegerSequence(32, L3)
10000 loops, best of 3: 76.3 µs per loop   # was 76.7 µs
```
It surprises me that some of the following became faster:

```
sage: %timeit x = list(S0)
1000000 loops, best of 3: 1.55 µs per loop # was 1.58 µs
sage: %timeit x = list(S1)
100000 loops, best of 3: 2.14 µs per loop  # was 2.06 µs
sage: %timeit x = list(S2)
100000 loops, best of 3: 4.31 µs per loop  # was 4.19 µs
sage: %timeit x = list(S3)
1000 loops, best of 3: 274 µs per loop     # was 253 µs
sage: %timeit x = S0.list()
1000000 loops, best of 3: 810 ns per loop  # was 1.05 µs
sage: %timeit x = S1.list()
1000000 loops, best of 3: 1.22 µs per loop # was 1.87 µs
sage: %timeit x = S2.list()
100000 loops, best of 3: 2.9 µs per loop   # was 4.95 µs
sage: %timeit x = S3.list()
10000 loops, best of 3: 105 µs per loop    # was 306 µs
```

```
sage: timeit("x=S0[:-1]", number=100000)
100000 loops, best of 3: 1.76 µs per loop  # was 1.75 µs
sage: timeit("x=S1[:-1]", number=100000)
100000 loops, best of 3: 1.76 µs per loop  # was 1.8 µs
sage: timeit("x=S2[:-1]", number=100000)
100000 loops, best of 3: 1.78 µs per loop  # was 1.77 µs
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 2.46 µs per loop  # was 2.4 µs
```

```
sage: timeit("x=S2[:-1:2]", number=10000)
10000 loops, best of 3: 2.68 µs per loop   # was 2.7 µs
sage: timeit("x=S3[:-1:2]", number=10000)
10000 loops, best of 3: 52.2 µs per loop   # was 52.2 µs
```
The following apparently became slower:

```
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 370 ns per loop  # was 354 ns
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 375 ns per loop  # was 355 ns
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 371 ns per loop  # was 350 ns
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 391 ns per loop  # was 370 ns
```

```
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: S1y = BoundedIntegerSequence(16, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S1y==S1!=S1x, S1y is not S1
(True, True)
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0z2.startswith(S0)", number=1000000)
1000000 loops, best of 3: 233 ns per loop  # was 230 ns
sage: timeit("S0z2.startswith(S0x)", number=1000000)
1000000 loops, best of 3: 238 ns per loop  # was 236 ns
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 457 ns per loop  # was 511 ns
sage: timeit("S1z2.startswith(S1)", number=1000000)
1000000 loops, best of 3: 219 ns per loop  # was 215 ns
sage: timeit("S1z2.startswith(S1x)", number=1000000)
1000000 loops, best of 3: 223 ns per loop  # was 219 ns
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 813 ns per loop  # was 692 ns
sage: timeit("S2z2.startswith(S2)", number=1000000)
1000000 loops, best of 3: 244 ns per loop  # was 238 ns
sage: timeit("S2z2.startswith(S2x)", number=1000000)
1000000 loops, best of 3: 223 ns per loop  # was 228 ns
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 5.59 µs per loop # was 1.92 µs
sage: timeit("S3z2.startswith(S3)", number=1000000)
1000000 loops, best of 3: 990 ns per loop  # was 981 ns
sage: timeit("S3z2.startswith(S3x)", number=1000000)
1000000 loops, best of 3: 216 ns per loop  # was 213 ns
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 2.33 ms per loop    # was 2.41 ms
```

So, overall, I think that the timings are still decent and it makes sense to use bounded integer sequences as replacement of tuples in some applications.



---

archive/issue_comments_199912.json:
```json
{
    "body": "<div id=\"comment:84\" align=\"right\">comment:84</div>\n\n> So, overall, I think that the timings are still decent and it makes sense to use bounded integer sequences as replacement of tuples in some applications.\n\nEspecially since they are probably MUCH more compact in memory.\n\nNathann",
    "created_at": "2014-06-07T09:05:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199912",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:84" align="right">comment:84</div>

> So, overall, I think that the timings are still decent and it makes sense to use bounded integer sequences as replacement of tuples in some applications.

Especially since they are probably MUCH more compact in memory.

Nathann



---

archive/issue_comments_199913.json:
```json
{
    "body": "Changed commit from **[`c900a2c`](https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958)** to **[`1192c21`](https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e)**",
    "created_at": "2014-06-09T07:28:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199913",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`c900a2c`](https://github.com/sagemath/sagetrac-mirror/commit/c900a2cd4045aa3463be31d76c9f047b05571958)** to **[`1192c21`](https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e)**



---

archive/issue_comments_199914.json:
```json
{
    "body": "<div id=\"comment:85\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e\"><code>1192c21</code></a></td><td><code>Allow empty slices; bounded integer sequence -> bool</code></td></tr></table>\n",
    "created_at": "2014-06-09T07:28:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199914",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:85"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e"><code>1192c21</code></a></td><td><code>Allow empty slices; bounded integer sequence -> bool</code></td></tr></table>




---

archive/issue_comments_199915.json:
```json
{
    "body": "<div id=\"comment:86\" align=\"right\">comment:86</div>\n\nI just fixed a segfault that has occurred for empty slices, and I implemented conversion sequence to bool (in the usual way: A sequence is nonzero if and only if it has a positive length). Still needs review...",
    "created_at": "2014-06-09T07:30:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199915",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:86" align="right">comment:86</div>

I just fixed a segfault that has occurred for empty slices, and I implemented conversion sequence to bool (in the usual way: A sequence is nonzero if and only if it has a positive length). Still needs review...



---

archive/issue_comments_199916.json:
```json
{
    "body": "<div id=\"comment:87\" align=\"right\">comment:87</div>\n\nSigh. I hate trailing zeroes.\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: (BoundedIntegerSequence(21, [0,0]) + BoundedIntegerSequence(21, [0,0]))\n<16, 0, 30, 30>\n```",
    "created_at": "2014-06-11T14:52:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199916",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:87" align="right">comment:87</div>

Sigh. I hate trailing zeroes.

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: (BoundedIntegerSequence(21, [0,0]) + BoundedIntegerSequence(21, [0,0]))
<16, 0, 30, 30>
```



---

archive/issue_comments_199917.json:
```json
{
    "body": "Work Issues: **Fix other out of bound errors**",
    "created_at": "2014-06-11T14:52:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199917",
    "user": "https://github.com/simon-king-jena"
}
```

Work Issues: **Fix other out of bound errors**



---

archive/issue_events_225905.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-11T14:52:23Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225905"
}
```



---

archive/issue_events_225906.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-11T14:52:23Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225906"
}
```



---

archive/issue_comments_199918.json:
```json
{
    "body": "<div id=\"comment:88\" align=\"right\">comment:88</div>\n\nMy original plan was to provide a function to compute the maximal overlap of sequences in the follow-up ticket #16453. However, while I am at fixing bugs, I'll move this new function to here.",
    "created_at": "2014-06-11T14:56:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199918",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:88" align="right">comment:88</div>

My original plan was to provide a function to compute the maximal overlap of sequences in the follow-up ticket #16453. However, while I am at fixing bugs, I'll move this new function to here.



---

archive/issue_comments_199919.json:
```json
{
    "body": "<div id=\"comment:89\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410\"><code>ff4477a</code></a></td><td><code>Remove biseq_to_str. Add max_overlap. Fix boundary violations</code></td></tr></table>\n",
    "created_at": "2014-06-11T15:13:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199919",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:89"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410"><code>ff4477a</code></a></td><td><code>Remove biseq_to_str. Add max_overlap. Fix boundary violations</code></td></tr></table>




---

archive/issue_comments_199920.json:
```json
{
    "body": "Changed commit from **[`1192c21`](https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e)** to **[`ff4477a`](https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410)**",
    "created_at": "2014-06-11T15:13:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199920",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`1192c21`](https://github.com/sagemath/sagetrac-mirror/commit/1192c211965ea1dcf1fdbaeaec7e68bf61ba265e)** to **[`ff4477a`](https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410)**



---

archive/issue_comments_199921.json:
```json
{
    "body": "<div id=\"comment:90\" align=\"right\">comment:90</div>\n\nDone!\n\nNathann, while I was at it, I have removed the `biseq_to_str` function, as we have discussed off-trac.",
    "created_at": "2014-06-11T15:14:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199921",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:90" align="right">comment:90</div>

Done!

Nathann, while I was at it, I have removed the `biseq_to_str` function, as we have discussed off-trac.



---

archive/issue_events_225907.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-11T15:14:54Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225907"
}
```



---

archive/issue_events_225908.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-06-11T15:14:54Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225908"
}
```



---

archive/issue_comments_199922.json:
```json
{
    "body": "Changed work issues from **Fix other out of bound errors** to **Fix containement test**",
    "created_at": "2014-07-15T13:06:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199922",
    "user": "https://github.com/simon-king-jena"
}
```

Changed work issues from **Fix other out of bound errors** to **Fix containement test**



---

archive/issue_comments_199923.json:
```json
{
    "body": "<div id=\"comment:91\" align=\"right\">comment:91</div>\n\nAgain, there is trouble with zeroes. The sequence `<0>` is currently considered a subsequence of the sequence  `<1,2,3>`:\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: S1 = BoundedIntegerSequence(3,[1,3])\nsage: S2 = BoundedIntegerSequence(3,[0])\nsage: S2 in S1    # very wrong\nTrue\nsage: S1.startswith(S2) # correct\nFalse\n```",
    "created_at": "2014-07-15T13:06:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199923",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:91" align="right">comment:91</div>

Again, there is trouble with zeroes. The sequence `<0>` is currently considered a subsequence of the sequence  `<1,2,3>`:

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: S1 = BoundedIntegerSequence(3,[1,3])
sage: S2 = BoundedIntegerSequence(3,[0])
sage: S2 in S1    # very wrong
True
sage: S1.startswith(S2) # correct
False
```



---

archive/issue_events_225909.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-07-15T13:06:06Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225909"
}
```



---

archive/issue_events_225910.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-07-15T13:06:06Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225910"
}
```



---

archive/issue_comments_199924.json:
```json
{
    "body": "<div id=\"comment:92\" align=\"right\">comment:92</div>\n\nIt seems that the problem lies in `mpz_congruent_2exp_p(A, B, nbits)`: In the problematic situation, `A==0`, `B==13` and `nbits==2`. It should be the case that the function returns \"False\", since 13 is not congruent to 0 modulo 4 (i.e. modulo two bits). But it doesn't. And that's totally weird. I'll try to reproduce it independent of the bounded integer sequences, i.e., I will see if it is a horribly GMP bug. Probably it isn't.",
    "created_at": "2014-07-15T14:42:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199924",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:92" align="right">comment:92</div>

It seems that the problem lies in `mpz_congruent_2exp_p(A, B, nbits)`: In the problematic situation, `A==0`, `B==13` and `nbits==2`. It should be the case that the function returns "False", since 13 is not congruent to 0 modulo 4 (i.e. modulo two bits). But it doesn't. And that's totally weird. I'll try to reproduce it independent of the bounded integer sequences, i.e., I will see if it is a horribly GMP bug. Probably it isn't.



---

archive/issue_comments_199925.json:
```json
{
    "body": "<div id=\"comment:93\" align=\"right\">comment:93</div>\n\nYes, it isn't:\n\n```\nsage: cython(\"\"\"\n....: include \"sage/libs/ntl/decl.pxi\"\n....: def test(x,y):\n....:     cdef mpz_t a,b\n....:     mpz_init_set_ui(a, x)\n....:     mpz_init_set_ui(b, y)\n....:     print mpz_congruent_2exp_p(a,b,2)\n....:     print mpz_get_ui(a), \"vs\", mpz_get_ui(b)\n....:     print (<__mpz_struct*>a)._mp_size\n....:     print (<__mpz_struct*>b)._mp_size\n....:     mpz_clear(a)\n....:     mpz_clear(b)\n....: \"\"\")\nsage: test(0,13)\nFalse\n0 vs 13\n0\n1\n```\nMy current impression is that in *the same* situation as above, `mpz_congruent_2exp_p` gives the wrong result (`True`) in the bounded integer sequence code. Strange.",
    "created_at": "2014-07-15T14:49:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199925",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:93" align="right">comment:93</div>

Yes, it isn't:

```
sage: cython("""
....: include "sage/libs/ntl/decl.pxi"
....: def test(x,y):
....:     cdef mpz_t a,b
....:     mpz_init_set_ui(a, x)
....:     mpz_init_set_ui(b, y)
....:     print mpz_congruent_2exp_p(a,b,2)
....:     print mpz_get_ui(a), "vs", mpz_get_ui(b)
....:     print (<__mpz_struct*>a)._mp_size
....:     print (<__mpz_struct*>b)._mp_size
....:     mpz_clear(a)
....:     mpz_clear(b)
....: """)
sage: test(0,13)
False
0 vs 13
0
1
```
My current impression is that in *the same* situation as above, `mpz_congruent_2exp_p` gives the wrong result (`True`) in the bounded integer sequence code. Strange.



---

archive/issue_comments_199926.json:
```json
{
    "body": "<div id=\"comment:94\" align=\"right\">comment:94</div>\n\nArgh, now I see the difference: By a bug, I somehow managed to give the number 13 the size zero. mpz_congruent_2exp_p thus believes that 13==0 and correctly concludes that 0 is congruent 13 modulo 4.",
    "created_at": "2014-07-15T15:00:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199926",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:94" align="right">comment:94</div>

Argh, now I see the difference: By a bug, I somehow managed to give the number 13 the size zero. mpz_congruent_2exp_p thus believes that 13==0 and correctly concludes that 0 is congruent 13 modulo 4.



---

archive/issue_comments_199927.json:
```json
{
    "body": "Changed commit from **[`ff4477a`](https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410)** to **[`93546db`](https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d)**",
    "created_at": "2014-07-22T11:37:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199927",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`ff4477a`](https://github.com/sagemath/sagetrac-mirror/commit/ff4477a1600b44031c2fb962ff3c5ab24c110410)** to **[`93546db`](https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d)**



---

archive/issue_comments_199928.json:
```json
{
    "body": "<div id=\"comment:95\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fd1675d01a5d5ef78f6bbd204ecc4a6b08fb46b4\"><code>fd1675d</code></a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d\"><code>93546db</code></a></td><td><code>Fix subsequence containment test.</code></td></tr></table>\n",
    "created_at": "2014-07-22T11:37:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199928",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:95"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fd1675d01a5d5ef78f6bbd204ecc4a6b08fb46b4"><code>fd1675d</code></a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d"><code>93546db</code></a></td><td><code>Fix subsequence containment test.</code></td></tr></table>




---

archive/issue_comments_199929.json:
```json
{
    "body": "Changed work issues from **Fix containement test** to none",
    "created_at": "2014-07-22T11:39:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199929",
    "user": "https://github.com/simon-king-jena"
}
```

Changed work issues from **Fix containement test** to none



---

archive/issue_events_225911.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-07-22T11:39:51Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225911"
}
```



---

archive/issue_events_225912.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-07-22T11:39:51Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225912"
}
```



---

archive/issue_comments_199930.json:
```json
{
    "body": "<div id=\"comment:96\" align=\"right\">comment:96</div>\n\nThe problem is fixed. I inserted comments into the code that hopefully explain what happens in the subsequence containment test.\n\nDoctests pass (including a new test that has previously failed), hence, it needs review again!",
    "created_at": "2014-07-22T11:39:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199930",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:96" align="right">comment:96</div>

The problem is fixed. I inserted comments into the code that hopefully explain what happens in the subsequence containment test.

Doctests pass (including a new test that has previously failed), hence, it needs review again!



---

archive/issue_events_225913.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "milestone_number": null,
    "milestone_title": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225913"
}
```



---

archive/issue_events_225914.json:
```json
{
    "actor": "https://github.com/sagetrac-vbraun-spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "milestone_number": null,
    "milestone_title": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225914"
}
```



---

archive/issue_comments_199931.json:
```json
{
    "body": "<div id=\"comment:98\" align=\"right\">comment:98</div>\n\nstill two failing doctests, see patchbot report",
    "created_at": "2014-08-24T20:27:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199931",
    "user": "https://github.com/fchapoton"
}
```

<div id="comment:98" align="right">comment:98</div>

still two failing doctests, see patchbot report



---

archive/issue_events_225915.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2014-08-24T20:27:59Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225915"
}
```



---

archive/issue_events_225916.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2014-08-24T20:27:59Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225916"
}
```



---

archive/issue_comments_199932.json:
```json
{
    "body": "<div id=\"comment:99\" align=\"right\">comment:99</div>\n\nReplying to [@fchapoton](#comment:98):\n> still two failing doctests, see patchbot report\n\nThis is all very odd. All pathchbots report the same error, but I don't see it on my own machine. So far, I don't know where I could start debugging.",
    "created_at": "2014-08-25T11:06:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199932",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:99" align="right">comment:99</div>

Replying to [@fchapoton](#comment:98):
> still two failing doctests, see patchbot report

This is all very odd. All pathchbots report the same error, but I don't see it on my own machine. So far, I don't know where I could start debugging.



---

archive/issue_comments_199933.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nIs it perhaps the case that something relevant (GMP) was upgraded after sage-6.3.beta5? That's the version that I use on my laptop.",
    "created_at": "2014-08-25T11:10:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199933",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:0" align="right">comment:0</div>

Is it perhaps the case that something relevant (GMP) was upgraded after sage-6.3.beta5? That's the version that I use on my laptop.



---

archive/issue_comments_199934.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nCurrently I won't upgrade to sage-6.4, as I am rather busy with another project. Could one of you please test if the error appears in sage-6.4 but not in sage-6.3?",
    "created_at": "2014-08-25T12:50:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199934",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

Currently I won't upgrade to sage-6.4, as I am rather busy with another project. Could one of you please test if the error appears in sage-6.4 but not in sage-6.3?



---

archive/issue_comments_199935.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nI will test on 6.4.beta1. Building right now.",
    "created_at": "2014-08-25T13:00:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199935",
    "user": "https://github.com/fchapoton"
}
```

<div id="comment:2" align="right">comment:2</div>

I will test on 6.4.beta1. Building right now.



---

archive/issue_comments_199936.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI confirm the doctest failures on 6.4.beta1:\n\n```\n\nsage -t --long src/sage/misc/bounded_integer_sequences.pyx\n**********************************************************************\nFile \"src/sage/misc/bounded_integer_sequences.pyx\", line 1086, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__getitem__\nFailed example:\n    S[1::2]\nExpected:\n    <1, 2, 20>\nGot:\n    <1, 6, 23>\n**********************************************************************\nFile \"src/sage/misc/bounded_integer_sequences.pyx\", line 1088, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__getitem__\nFailed example:\n    S[-1::-2]\nExpected:\n    <9, 7, 6, 4>\nGot:\n    <9, 7, 22, 15>\n\n\n```",
    "created_at": "2014-08-25T13:46:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199936",
    "user": "https://github.com/fchapoton"
}
```

<div id="comment:3" align="right">comment:3</div>

I confirm the doctest failures on 6.4.beta1:

```

sage -t --long src/sage/misc/bounded_integer_sequences.pyx
**********************************************************************
File "src/sage/misc/bounded_integer_sequences.pyx", line 1086, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__getitem__
Failed example:
    S[1::2]
Expected:
    <1, 2, 20>
Got:
    <1, 6, 23>
**********************************************************************
File "src/sage/misc/bounded_integer_sequences.pyx", line 1088, in sage.misc.bounded_integer_sequences.BoundedIntegerSequence.__getitem__
Failed example:
    S[-1::-2]
Expected:
    <9, 7, 6, 4>
Got:
    <9, 7, 22, 15>


```



---

archive/issue_comments_199937.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nInteresting!\n\nSo, what has changed between sage-6.3.b5 and sage-6.4.b1? Specifically, has something happened with GMP?",
    "created_at": "2014-08-25T14:06:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199937",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

Interesting!

So, what has changed between sage-6.3.b5 and sage-6.4.b1? Specifically, has something happened with GMP?



---

archive/issue_comments_199938.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nPS: Can you reproduce it on the command line?\n\nAt some point I should upgrade, to fix the issue...",
    "created_at": "2014-08-25T14:12:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199938",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:5" align="right">comment:5</div>

PS: Can you reproduce it on the command line?

At some point I should upgrade, to fix the issue...



---

archive/issue_comments_199939.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nYes, same behaviour in the command line.",
    "created_at": "2014-08-25T14:17:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199939",
    "user": "https://github.com/fchapoton"
}
```

<div id="comment:6" align="right">comment:6</div>

Yes, same behaviour in the command line.



---

archive/issue_comments_199940.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nI have upgraded now, and I do *not* see the error.\n\nSo, what could we do to trace the problem down?",
    "created_at": "2014-08-26T11:24:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199940",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

I have upgraded now, and I do *not* see the error.

So, what could we do to trace the problem down?



---

archive/issue_comments_199941.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nSince I cannot reproduce the problem myself, could you please help me by providing some internal data? Perhaps there are different architectures (32bit or 64bit, big or little endian) at work?\n\nPlease add the following as a method of `BoundedIntegerSequence`:\n\n```python\n    def inspect(self):\n        cdef __mpz_struct seq\n        seq = deref(<__mpz_struct*>self.data.data)\n        print \"bitsize\",self.data.bitsize\n        print \"itembitsize\",self.data.itembitsize\n        print \"mask_item\", Integer(self.data.mask_item).binary()\n        print \"length\", self.data.length\n        print \"GMP size\", seq._mp_size\n        print \"GMP alloc\", seq._mp_alloc\n        print '.'.join([Integer(seq._mp_d[limb]).binary().rjust(mp_bits_per_limb,'0') for limb in range(seq._mp_size-1,-1,-1)])\n```\nWith this, I get\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])\nsage: S.inspect()\nbitsize 35\nitembitsize 5\nmask_item 11111\nlength 7\nGMP size 2\nGMP alloc 3\n00000000000000000000000000000010.01101000011100010001100000100100\nsage: S[1::2]\n<1, 2, 20>\nsage: (S[1::2]).inspect()\nbitsize 15\nitembitsize 5\nmask_item 11111\nlength 3\nGMP size 1\nGMP alloc 2\n00000000000000000101000001000001\nsage: S[-1::-2]\n<9, 7, 6, 4>\nsage: (S[-1::-2]).inspect()\nbitsize 20\nitembitsize 5\nmask_item 11111\nlength 4\nGMP size 1\nGMP alloc 2\n00000000000000100001100011101001\n```\nWhat do you get instead?",
    "created_at": "2014-08-26T13:16:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199941",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:8" align="right">comment:8</div>

Since I cannot reproduce the problem myself, could you please help me by providing some internal data? Perhaps there are different architectures (32bit or 64bit, big or little endian) at work?

Please add the following as a method of `BoundedIntegerSequence`:

```python
    def inspect(self):
        cdef __mpz_struct seq
        seq = deref(<__mpz_struct*>self.data.data)
        print "bitsize",self.data.bitsize
        print "itembitsize",self.data.itembitsize
        print "mask_item", Integer(self.data.mask_item).binary()
        print "length", self.data.length
        print "GMP size", seq._mp_size
        print "GMP alloc", seq._mp_alloc
        print '.'.join([Integer(seq._mp_d[limb]).binary().rjust(mp_bits_per_limb,'0') for limb in range(seq._mp_size-1,-1,-1)])
```
With this, I get

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])
sage: S.inspect()
bitsize 35
itembitsize 5
mask_item 11111
length 7
GMP size 2
GMP alloc 3
00000000000000000000000000000010.01101000011100010001100000100100
sage: S[1::2]
<1, 2, 20>
sage: (S[1::2]).inspect()
bitsize 15
itembitsize 5
mask_item 11111
length 3
GMP size 1
GMP alloc 2
00000000000000000101000001000001
sage: S[-1::-2]
<9, 7, 6, 4>
sage: (S[-1::-2]).inspect()
bitsize 20
itembitsize 5
mask_item 11111
length 4
GMP size 1
GMP alloc 2
00000000000000100001100011101001
```
What do you get instead?



---

archive/issue_comments_199942.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\ngot that :\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])\nsage: S.inspect()\nbitsize 35\nitembitsize 5\nmask_item 11111\nlength 7\nGMP size 1\nGMP alloc 2\n0000000000000000000000000000001001101000011100010001100000100100\nsage: S[1::2]\n<1, 6, 23>\nsage: (S[1::2]).inspect()\nbitsize 15\nitembitsize 5\nmask_item 11111\nlength 3\nGMP size 1\nGMP alloc 2\n0000000000000000000000000000000000010011110111111101110011000001\nsage: S[-1::-2]\n<9, 7, 22, 15>\nsage: (S[-1::-2]).inspect()\nbitsize 20\nitembitsize 5\nmask_item 11111\nlength 4\nGMP size 1\nGMP alloc 2\n0000000000000001001101000011101011101100011101111101100011101001\n```",
    "created_at": "2014-08-26T13:31:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199942",
    "user": "https://github.com/fchapoton"
}
```

<div id="comment:9" align="right">comment:9</div>

got that :

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: S = BoundedIntegerSequence(21, [4,1,6,2,7,20,9])
sage: S.inspect()
bitsize 35
itembitsize 5
mask_item 11111
length 7
GMP size 1
GMP alloc 2
0000000000000000000000000000001001101000011100010001100000100100
sage: S[1::2]
<1, 6, 23>
sage: (S[1::2]).inspect()
bitsize 15
itembitsize 5
mask_item 11111
length 3
GMP size 1
GMP alloc 2
0000000000000000000000000000000000010011110111111101110011000001
sage: S[-1::-2]
<9, 7, 22, 15>
sage: (S[-1::-2]).inspect()
bitsize 20
itembitsize 5
mask_item 11111
length 4
GMP size 1
GMP alloc 2
0000000000000001001101000011101011101100011101111101100011101001
```



---

archive/issue_comments_199943.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nThank you! So, one obvious difference is that on your computer, GMP uses chunks of 64 bit to store long integers, whereas it is only 32 bit on my machine (even though it is a 64 bit CPU). I'll see if I can make sense of the error.",
    "created_at": "2014-08-26T13:40:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199943",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:0" align="right">comment:0</div>

Thank you! So, one obvious difference is that on your computer, GMP uses chunks of 64 bit to store long integers, whereas it is only 32 bit on my machine (even though it is a 64 bit CPU). I'll see if I can make sense of the error.



---

archive/issue_comments_199944.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nAnother interesting point is that the single limb used to store `S[1::2]` resp. `S[-1::-2]` on your machine is full of junk bits.\n\nAnyway, what surprises me is the following: Up to know, all problems arose because of a misfit where two limbs meet. But here, for the first time, we have errors occurring in a *single* limb.",
    "created_at": "2014-08-26T13:47:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199944",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

Another interesting point is that the single limb used to store `S[1::2]` resp. `S[-1::-2]` on your machine is full of junk bits.

Anyway, what surprises me is the following: Up to know, all problems arose because of a misfit where two limbs meet. But here, for the first time, we have errors occurring in a *single* limb.



---

archive/issue_comments_199945.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nHooray, I can reproduce the problem on my machine, with a different example!\n\nThe key is (as on your machine) to create a sequence that fits inside a single limb, an then slice:\n\n```\nsage: S = BoundedIntegerSequence(8, [4,1,6,2,7,2,5,5,2])\nsage: S\n<4, 1, 6, 2, 7, 2, 5, 5, 2>\nsage: S[1::2]\n<1, 6, 7, 7>\nsage: S[-1::-2]\n<2, 5, 7, 6, 7>\n```\nThe sequence above is of length 9, with items fitting into 3 bit. Hence, 27 bit are used, whereas one limb comprises 32 bits.\n\nSo, stuff for debugging!",
    "created_at": "2014-08-26T14:07:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199945",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

Hooray, I can reproduce the problem on my machine, with a different example!

The key is (as on your machine) to create a sequence that fits inside a single limb, an then slice:

```
sage: S = BoundedIntegerSequence(8, [4,1,6,2,7,2,5,5,2])
sage: S
<4, 1, 6, 2, 7, 2, 5, 5, 2>
sage: S[1::2]
<1, 6, 7, 7>
sage: S[-1::-2]
<2, 5, 7, 6, 7>
```
The sequence above is of length 9, with items fitting into 3 bit. Hence, 27 bit are used, whereas one limb comprises 32 bits.

So, stuff for debugging!



---

archive/issue_comments_199946.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nGot it!\n\nIn some branches of the `slice_biseq` function, I forgot to restrict the to-be-copied data down to the bitsize of items (i.e., I forgot `...&S.mask_item`). This oversight only happened in branches dealing with the case that everything fits within a single limb. Hence, no error in the old doctest for me (because it comprises two limbs on my machine), but an error for you (because it comprises a single limb on your machine).",
    "created_at": "2014-08-26T20:24:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199946",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Got it!

In some branches of the `slice_biseq` function, I forgot to restrict the to-be-copied data down to the bitsize of items (i.e., I forgot `...&S.mask_item`). This oversight only happened in branches dealing with the case that everything fits within a single limb. Hence, no error in the old doctest for me (because it comprises two limbs on my machine), but an error for you (because it comprises a single limb on your machine).



---

archive/issue_comments_199947.json:
```json
{
    "body": "<div id=\"comment:4\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3b2f7138142f6672beb43ee77d187393e5405a21\"><code>3b2f713</code></a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9\"><code>c69c67c</code></a></td><td><code>Use a bitmask when slicing bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-08-26T20:28:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199947",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:4"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3b2f7138142f6672beb43ee77d187393e5405a21"><code>3b2f713</code></a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9"><code>c69c67c</code></a></td><td><code>Use a bitmask when slicing bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_199948.json:
```json
{
    "body": "Changed commit from **[`93546db`](https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d)** to **[`c69c67c`](https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9)**",
    "created_at": "2014-08-26T20:28:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199948",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`93546db`](https://github.com/sagemath/sagetrac-mirror/commit/93546db866564a80d80df30de48934697e2b0d1d)** to **[`c69c67c`](https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9)**



---

archive/issue_events_225917.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-08-26T20:31:51Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225917"
}
```



---

archive/issue_events_225918.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-08-26T20:31:51Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225918"
}
```



---

archive/issue_comments_199949.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nThe fix is pushed, and of course the example that was failing on my machine has become a new doctest.",
    "created_at": "2014-08-26T20:31:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199949",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:5" align="right">comment:5</div>

The fix is pushed, and of course the example that was failing on my machine has become a new doctest.



---

archive/issue_comments_199950.json:
```json
{
    "body": "Changed commit from **[`c69c67c`](https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9)** to **[`b331dc4`](https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd)**",
    "created_at": "2014-09-02T12:50:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199950",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`c69c67c`](https://github.com/sagemath/sagetrac-mirror/commit/c69c67ccf3093a3c947ebbe83d5224daf695c3f9)** to **[`b331dc4`](https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd)**



---

archive/issue_comments_199951.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd\"><code>b331dc4</code></a></td><td><code>Fix mem leak converting zero-valued biseq_t to list</code></td></tr></table>\n",
    "created_at": "2014-09-02T12:50:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199951",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:6"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd"><code>b331dc4</code></a></td><td><code>Fix mem leak converting zero-valued biseq_t to list</code></td></tr></table>




---

archive/issue_comments_199952.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nI have fixed a memory leak: In the function `biseq_to_list`, some temporary buffer was allocated, but in the case that the sequence is zero valued, the function returns without freeing the buffer. Solution: Only allocate the buffer *after* checking that the sequence is not zero valued.\n\nStill needing review (hint-hint)...",
    "created_at": "2014-09-02T12:52:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199952",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

I have fixed a memory leak: In the function `biseq_to_list`, some temporary buffer was allocated, but in the case that the sequence is zero valued, the function returns without freeing the buffer. Solution: Only allocate the buffer *after* checking that the sequence is not zero valued.

Still needing review (hint-hint)...



---

archive/issue_events_225919.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-09-03T09:12:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225919"
}
```



---

archive/issue_events_225920.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-09-03T09:12:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225920"
}
```



---

archive/issue_comments_199953.json:
```json
{
    "body": "Work Issues: **memory corruption**",
    "created_at": "2014-09-03T09:12:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199953",
    "user": "https://github.com/simon-king-jena"
}
```

Work Issues: **memory corruption**



---

archive/issue_comments_199954.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nI found that the following function (written into `bouned_integer_sequences.pyx`) achieves to crash sage:\n\n```python\ndef _biseq_stresstest():\n    cdef int i\n    from sage.misc.prandom import randint\n    cdef list L = [BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))]) for y in range(100)]\n    cdef int branch\n    cdef BoundedIntegerSequence S, T\n    for i from 0<=i<10000:\n        if (i%1000) == 0:\n            print i\n        branch = randint(0,4)\n        if branch == 0:\n            L[randint(0,99)] = L[randint(0,99)]+L[randint(0,99)]\n        elif branch == 1:\n            x = randint(0,99)\n            if len(L[x]):\n                y = randint(0,len(L[x])-1)\n                z = randint(y,len(L[x])-1)\n                L[randint(0,99)] = L[x][y:z]\n            else:\n                L[x] = BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))])\n        elif branch == 2:\n            t = list(L[randint(0,99)])\n            t = repr(L[randint(0,99)])\n            t = L[randint(0,99)].list()\n        elif branch == 3:\n            x = randint(0,99)\n            if len(L[x]):\n                t = L[x][randint(0,len(L[x])-1)]\n                try:\n                    t = L[x].index(t)\n                except ValueError:\n                    print L[x]\n                    print t\n                    raise\n            else:\n                L[x] = BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))])\n        elif branch == 4:\n            S = L[randint(0,99)]\n            T = L[randint(0,99)]\n            startswith_biseq(S.data,T.data)\n            contains_biseq(S.data, T.data, 0)\n            max_overlap_biseq(S.data, T.data)\n```\n\nCan someone please see what happens on other machines? On mine (with the above function, but also with something that was supposed to be the corner stone in my current project), crashes occur in `sage_free` or `mpz_clear`. Surprisingly, the variables-to-be-freed/cleared should be just fine, in some cases they haven't even been touched after allocation.\n\nMy wild guess is that using `sage_malloc` (in `bounded_integer_sequences.pyx`) somehow interferes with gmp's (mpir's?) memory management. Even if the reason is different, I suppose it would make sense to get rid of `sage_malloc` and `sage_free` in my code. After all, I use it for buffers whose length is known at compile time. Hence, I should better use arrays.\n\nSo, my plan is: Use arrays instead of `sage_malloc`, and hope that this is enough to let above function pass, which would then become a doctest.",
    "created_at": "2014-09-03T09:12:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199954",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:8" align="right">comment:8</div>

I found that the following function (written into `bouned_integer_sequences.pyx`) achieves to crash sage:

```python
def _biseq_stresstest():
    cdef int i
    from sage.misc.prandom import randint
    cdef list L = [BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))]) for y in range(100)]
    cdef int branch
    cdef BoundedIntegerSequence S, T
    for i from 0<=i<10000:
        if (i%1000) == 0:
            print i
        branch = randint(0,4)
        if branch == 0:
            L[randint(0,99)] = L[randint(0,99)]+L[randint(0,99)]
        elif branch == 1:
            x = randint(0,99)
            if len(L[x]):
                y = randint(0,len(L[x])-1)
                z = randint(y,len(L[x])-1)
                L[randint(0,99)] = L[x][y:z]
            else:
                L[x] = BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))])
        elif branch == 2:
            t = list(L[randint(0,99)])
            t = repr(L[randint(0,99)])
            t = L[randint(0,99)].list()
        elif branch == 3:
            x = randint(0,99)
            if len(L[x]):
                t = L[x][randint(0,len(L[x])-1)]
                try:
                    t = L[x].index(t)
                except ValueError:
                    print L[x]
                    print t
                    raise
            else:
                L[x] = BoundedIntegerSequence(6, [randint(0,5) for x in range(randint(4,10))])
        elif branch == 4:
            S = L[randint(0,99)]
            T = L[randint(0,99)]
            startswith_biseq(S.data,T.data)
            contains_biseq(S.data, T.data, 0)
            max_overlap_biseq(S.data, T.data)
```

Can someone please see what happens on other machines? On mine (with the above function, but also with something that was supposed to be the corner stone in my current project), crashes occur in `sage_free` or `mpz_clear`. Surprisingly, the variables-to-be-freed/cleared should be just fine, in some cases they haven't even been touched after allocation.

My wild guess is that using `sage_malloc` (in `bounded_integer_sequences.pyx`) somehow interferes with gmp's (mpir's?) memory management. Even if the reason is different, I suppose it would make sense to get rid of `sage_malloc` and `sage_free` in my code. After all, I use it for buffers whose length is known at compile time. Hence, I should better use arrays.

So, my plan is: Use arrays instead of `sage_malloc`, and hope that this is enough to let above function pass, which would then become a doctest.



---

archive/issue_comments_199955.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nHmm. Using, for example,\n\n```python\n    cdef mp_limb_t tmp_limb[1]\n```\ninstead of\n\n```python\n    cdef mp_limb_t *tmp_limb\n    tmp_limb = <mp_limb_t*>sage_malloc(sizeof(mp_limb_t))\n```\ncompiles, but then it seems that the `mpn_*` functions do not correctly put values into the arrays, when I give them `tmp_limb` as argument.\n\nQuestion to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?",
    "created_at": "2014-09-03T10:13:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199955",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:9" align="right">comment:9</div>

Hmm. Using, for example,

```python
    cdef mp_limb_t tmp_limb[1]
```
instead of

```python
    cdef mp_limb_t *tmp_limb
    tmp_limb = <mp_limb_t*>sage_malloc(sizeof(mp_limb_t))
```
compiles, but then it seems that the `mpn_*` functions do not correctly put values into the arrays, when I give them `tmp_limb` as argument.

Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?



---

archive/issue_comments_199956.json:
```json
{
    "body": "<div id=\"comment:120\" align=\"right\">comment:120</div>\n\nReplying to [@simon-king-jena](#comment:119):\n> Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?\n\nForget the question. The problem was somewhere else. Now I think I can make arrays works as replacement for the current usage of `sage_malloc`.",
    "created_at": "2014-09-03T10:35:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199956",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:120" align="right">comment:120</div>

Replying to [@simon-king-jena](#comment:119):
> Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?

Forget the question. The problem was somewhere else. Now I think I can make arrays works as replacement for the current usage of `sage_malloc`.



---

archive/issue_comments_199957.json:
```json
{
    "body": "<div id=\"comment:121\" align=\"right\">comment:121</div>\n\nReplying to [@simon-king-jena](#comment:120):\n> Replying to [@simon-king-jena](#comment:119):\n> > Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?\n\n> \n> Forget the question. The problem was somewhere else. Now I think I can make arrays works as replacement for the current usage of `sage_malloc`.\n\nDo *not* forget the question. There is something extremely strange going on. When I insert a print statement after assigning the size of an `__mpz_struct*`, then things work. **Without the print statement**, the assignment of the size is ignored and the value incorrectly left zero.\n\nSo, how can a print statement influence whether or not some value of a variable in GMP is assigned?",
    "created_at": "2014-09-03T10:48:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199957",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:121" align="right">comment:121</div>

Replying to [@simon-king-jena](#comment:120):
> Replying to [@simon-king-jena](#comment:119):
> > Question to C/Cython experts: Is `tmp_limb` not just of type `<mp_limb_t*>` when I define `cdef mp_limb_t tmp_limb[1]`?

> 
> Forget the question. The problem was somewhere else. Now I think I can make arrays works as replacement for the current usage of `sage_malloc`.

Do *not* forget the question. There is something extremely strange going on. When I insert a print statement after assigning the size of an `__mpz_struct*`, then things work. **Without the print statement**, the assignment of the size is ignored and the value incorrectly left zero.

So, how can a print statement influence whether or not some value of a variable in GMP is assigned?



---

archive/issue_comments_199958.json:
```json
{
    "body": "Changed commit from **[`b331dc4`](https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd)** to **[`7b53dc8`](https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b)**",
    "created_at": "2014-09-03T13:44:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199958",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`b331dc4`](https://github.com/sagemath/sagetrac-mirror/commit/b331dc4f12e7291e9537f607ed155085cabc3fcd)** to **[`7b53dc8`](https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b)**



---

archive/issue_comments_199959.json:
```json
{
    "body": "<div id=\"comment:2\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b\"><code>7b53dc8</code></a></td><td><code>Try to improve memory management for biseq_t, and add a stress test</code></td></tr></table>\n",
    "created_at": "2014-09-03T13:44:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199959",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:2"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b"><code>7b53dc8</code></a></td><td><code>Try to improve memory management for biseq_t, and add a stress test</code></td></tr></table>




---

archive/issue_comments_199960.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI have replaced `sage_malloc` by arrays, since the array size is known at compile time. I think this is a good idea anyway, and the doctests pass.\n\nBut not all is good, and here I need help: `_biseq_stresstest()` either crashes with `free(): invalid next size (fast)`, or it raises a value error stating that some element is not in a bounded integer sequence, even though by construction it is contained. So, memory management still goes havoc.\n\nAny clues or pointers?",
    "created_at": "2014-09-03T13:54:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199960",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

I have replaced `sage_malloc` by arrays, since the array size is known at compile time. I think this is a good idea anyway, and the doctests pass.

But not all is good, and here I need help: `_biseq_stresstest()` either crashes with `free(): invalid next size (fast)`, or it raises a value error stating that some element is not in a bounded integer sequence, even though by construction it is contained. So, memory management still goes havoc.

Any clues or pointers?



---

archive/issue_comments_199961.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nI was running it under valgrind---and as a result, I did not see a crash! However, the other problem (a value error when a sequence is supposed to return the index of one of its elements) still persists under valgrind.\n\nConcerning the crash: What can one do to further debug if a crash can not be reproduced with valgrind?",
    "created_at": "2014-09-03T14:37:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199961",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

I was running it under valgrind---and as a result, I did not see a crash! However, the other problem (a value error when a sequence is supposed to return the index of one of its elements) still persists under valgrind.

Concerning the crash: What can one do to further debug if a crash can not be reproduced with valgrind?



---

archive/issue_comments_199962.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nPS: I can not quit sage when I run it under valgrind---\"quit\" has no effect!",
    "created_at": "2014-09-03T14:38:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199962",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:5" align="right">comment:5</div>

PS: I can not quit sage when I run it under valgrind---"quit" has no effect!



---

archive/issue_comments_199963.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nEven \"pkill python\" did not achieve to finish the valgrinded Sage session. Boy, am I fed up now. Time to call it a day.",
    "created_at": "2014-09-03T14:40:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199963",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

Even "pkill python" did not achieve to finish the valgrinded Sage session. Boy, am I fed up now. Time to call it a day.



---

archive/issue_comments_199964.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nActually I realise that I made a severe mistake all the time. `concat_biseq` returns a pointer to a local variable, and I did so in order to make it possible to propagate errors (by saying `... except NULL`). But returning a pointer to a local variable can not possibly work.\n\nSince I want to propagate errors, I suppose it will be better to consistently work with pointers. I'll rewrite the module accordingly...",
    "created_at": "2014-09-03T16:37:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199964",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

Actually I realise that I made a severe mistake all the time. `concat_biseq` returns a pointer to a local variable, and I did so in order to make it possible to propagate errors (by saying `... except NULL`). But returning a pointer to a local variable can not possibly work.

Since I want to propagate errors, I suppose it will be better to consistently work with pointers. I'll rewrite the module accordingly...



---

archive/issue_comments_199965.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nIt seems that that was the reason indeed! After rewriting everything so that\n`biseq_t` becomes a pointer to a struct (before, `biseq_t` *was* the\nstruct), all doctests pass, and the stresstest doesn't crash.\n\nBut not all is good: The stresstest doesn't crash, but sporadically it finds\ncan not find the index of an element of a sequence. So, needs work and I will not push yet, but it is\nalmost done.",
    "created_at": "2014-09-03T17:15:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199965",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:8" align="right">comment:8</div>

It seems that that was the reason indeed! After rewriting everything so that
`biseq_t` becomes a pointer to a struct (before, `biseq_t` *was* the
struct), all doctests pass, and the stresstest doesn't crash.

But not all is good: The stresstest doesn't crash, but sporadically it finds
can not find the index of an element of a sequence. So, needs work and I will not push yet, but it is
almost done.



---

archive/issue_comments_199966.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nThe stresstest found that the following fails:\n\n```\n            sage: S = BoundedIntegerSequence(6, [3, 5, 3, 1, 5, 2, 2, 5, 3, 3, 4])\n            sage: S[-1]\n            4\n```\nCurrently it returns 0.",
    "created_at": "2014-09-03T17:19:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199966",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:9" align="right">comment:9</div>

The stresstest found that the following fails:

```
            sage: S = BoundedIntegerSequence(6, [3, 5, 3, 1, 5, 2, 2, 5, 3, 3, 4])
            sage: S[-1]
            4
```
Currently it returns 0.



---

archive/issue_comments_199967.json:
```json
{
    "body": "<div id=\"comment:0\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7c9f0f28529af66a5c0a00a8c0116ed02ac58f5a\"><code>7c9f0f2</code></a></td><td><code>Biseq refactored, so that only pointers are passed around.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2\"><code>0aa3cbc</code></a></td><td><code>Fix corner cases in item access for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-09-03T20:18:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199967",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:0"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7c9f0f28529af66a5c0a00a8c0116ed02ac58f5a"><code>7c9f0f2</code></a></td><td><code>Biseq refactored, so that only pointers are passed around.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2"><code>0aa3cbc</code></a></td><td><code>Fix corner cases in item access for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_199968.json:
```json
{
    "body": "Changed commit from **[`7b53dc8`](https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b)** to **[`0aa3cbc`](https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2)**",
    "created_at": "2014-09-03T20:18:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199968",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`7b53dc8`](https://github.com/sagemath/sagetrac-mirror/commit/7b53dc82d032d5a787e10731938f9048b620031b)** to **[`0aa3cbc`](https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2)**



---

archive/issue_comments_199969.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nThe stress test is really valuable. I found several small problems concerning corner cases. And, as I have announced, I have reworked the code so that only \"proper\" pointers rather than stupid references to local variables are passed around.\n\nThere remain problems, though. In the doctests, I have commented out the stresstest, because there are STILL crashes. This time, `mpz_clear` sometimes doesn't work. My wild guess is that at some point I write out of bounds when using `mpn_*`-functions.\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7c9f0f28529af66a5c0a00a8c0116ed02ac58f5a\"><code>7c9f0f2</code></a></td><td><code>Biseq refactored, so that only pointers are passed around.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2\"><code>0aa3cbc</code></a></td><td><code>Fix corner cases in item access for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-09-03T20:23:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199969",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

The stress test is really valuable. I found several small problems concerning corner cases. And, as I have announced, I have reworked the code so that only "proper" pointers rather than stupid references to local variables are passed around.

There remain problems, though. In the doctests, I have commented out the stresstest, because there are STILL crashes. This time, `mpz_clear` sometimes doesn't work. My wild guess is that at some point I write out of bounds when using `mpn_*`-functions.

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7c9f0f28529af66a5c0a00a8c0116ed02ac58f5a"><code>7c9f0f2</code></a></td><td><code>Biseq refactored, so that only pointers are passed around.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2"><code>0aa3cbc</code></a></td><td><code>Fix corner cases in item access for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_199970.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nHooray, by inserting explicit range checks, I found that I am indeed writing out of allocated area in `slice_biseq`. That (and similar errors?) will hopefully explain the crashes...",
    "created_at": "2014-09-04T12:37:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199970",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

Hooray, by inserting explicit range checks, I found that I am indeed writing out of allocated area in `slice_biseq`. That (and similar errors?) will hopefully explain the crashes...



---

archive/issue_comments_199971.json:
```json
{
    "body": "Changed commit from **[`0aa3cbc`](https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2)** to **[`f20dc09`](https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac)**",
    "created_at": "2014-09-04T15:20:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199971",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`0aa3cbc`](https://github.com/sagemath/sagetrac-mirror/commit/0aa3cbcfb1be64154ad32a419f250a9c6e52dcf2)** to **[`f20dc09`](https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac)**



---

archive/issue_comments_199972.json:
```json
{
    "body": "<div id=\"comment:3\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac\"><code>f20dc09</code></a></td><td><code>Fix writing out of bounds, and assert that the bounds are respected</code></td></tr></table>\n",
    "created_at": "2014-09-04T15:20:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199972",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:3"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac"><code>f20dc09</code></a></td><td><code>Fix writing out of bounds, and assert that the bounds are respected</code></td></tr></table>




---

archive/issue_events_225921.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-09-04T15:26:46Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225921"
}
```



---

archive/issue_events_225922.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-09-04T15:26:46Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225922"
}
```



---

archive/issue_comments_199973.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nIn the new commit, I added assertions to make sure that I am not writing into non-allocated memory. So, the code should now be water proof in that regard.\n\nAll tests pass, including the \"stress test\". So, it can be reviewed now!\n\nQuestion to the reviewer: Can the assertions be removed? After all, what is being asserted is just that some variables are correctly computed, but this can in principle be checked by reading the code. Or are assertions (even in relatively tight loops) cheap enough?",
    "created_at": "2014-09-04T15:26:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199973",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

In the new commit, I added assertions to make sure that I am not writing into non-allocated memory. So, the code should now be water proof in that regard.

All tests pass, including the "stress test". So, it can be reviewed now!

Question to the reviewer: Can the assertions be removed? After all, what is being asserted is just that some variables are correctly computed, but this can in principle be checked by reading the code. Or are assertions (even in relatively tight loops) cheap enough?



---

archive/issue_comments_199974.json:
```json
{
    "body": "<div id=\"comment:135\" align=\"right\">comment:135</div>\n\nReplying to [@simon-king-jena](#comment:134):\n> Question to the reviewer: Can the assertions be removed? After all, what is being asserted is just that some variables are correctly computed, but this can in principle be checked by reading the code. Or are assertions (even in relatively tight loops) cheap enough?\n\nIf you run `Python` with the option `-O`, all the assert calls are ignored. \nSomething similar should be doable, at compile time of course, for Cython.\n\nMost programming languages support this to encourage developpers to never remove asserts. We really should have this feature in Sage. A good starting point would be to have `sage -O` call `Python -O`.\n\nCheers,\n                                     Nicolas",
    "created_at": "2014-09-04T15:37:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199974",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:135" align="right">comment:135</div>

Replying to [@simon-king-jena](#comment:134):
> Question to the reviewer: Can the assertions be removed? After all, what is being asserted is just that some variables are correctly computed, but this can in principle be checked by reading the code. Or are assertions (even in relatively tight loops) cheap enough?

If you run `Python` with the option `-O`, all the assert calls are ignored. 
Something similar should be doable, at compile time of course, for Cython.

Most programming languages support this to encourage developpers to never remove asserts. We really should have this feature in Sage. A good starting point would be to have `sage -O` call `Python -O`.

Cheers,
                                     Nicolas



---

archive/issue_comments_199975.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652\"><code>cea38bb</code></a></td><td><code>Change doc according to the changed functionality of list_to_biseq</code></td></tr></table>\n",
    "created_at": "2014-09-04T16:06:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199975",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:6"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652"><code>cea38bb</code></a></td><td><code>Change doc according to the changed functionality of list_to_biseq</code></td></tr></table>




---

archive/issue_comments_199976.json:
```json
{
    "body": "Changed commit from **[`f20dc09`](https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac)** to **[`cea38bb`](https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652)**",
    "created_at": "2014-09-04T16:06:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199976",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`f20dc09`](https://github.com/sagemath/sagetrac-mirror/commit/f20dc096832f260edee2f28b3007bf42263f54ac)** to **[`cea38bb`](https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652)**



---

archive/issue_comments_199977.json:
```json
{
    "body": "Changed work issues from **memory corruption** to none",
    "created_at": "2014-09-04T22:18:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199977",
    "user": "https://github.com/simon-king-jena"
}
```

Changed work issues from **memory corruption** to none



---

archive/issue_comments_199978.json:
```json
{
    "body": "Changed commit from **[`cea38bb`](https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652)** to **[`4611f8a`](https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318)**",
    "created_at": "2014-09-04T22:39:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199978",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`cea38bb`](https://github.com/sagemath/sagetrac-mirror/commit/cea38bb0a7d6f748cfc1feef357df5e22eb7b652)** to **[`4611f8a`](https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318)**



---

archive/issue_comments_199979.json:
```json
{
    "body": "<div id=\"comment:8\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318\"><code>4611f8a</code></a></td><td><code>Minor changes in the docs</code></td></tr></table>\n",
    "created_at": "2014-09-04T22:39:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199979",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:8"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318"><code>4611f8a</code></a></td><td><code>Minor changes in the docs</code></td></tr></table>




---

archive/issue_comments_199980.json:
```json
{
    "body": "Changed commit from **[`4611f8a`](https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318)** to **[`815d77c`](https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f)**",
    "created_at": "2014-09-05T10:58:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199980",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`4611f8a`](https://github.com/sagemath/sagetrac-mirror/commit/4611f8aa591616f118b50ebc2d2516c635e40318)** to **[`815d77c`](https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f)**



---

archive/issue_comments_199981.json:
```json
{
    "body": "<div id=\"comment:9\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f\"><code>815d77c</code></a></td><td><code>mpn_r/lshift should only be used with strictly positive shift</code></td></tr></table>\n",
    "created_at": "2014-09-05T10:58:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199981",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:9"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f"><code>815d77c</code></a></td><td><code>mpn_r/lshift should only be used with strictly positive shift</code></td></tr></table>




---

archive/issue_comments_199982.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nThis is to explain the most recent commit: By doing some non-commutative Gr\u00f6bner basis computations relying on \"biseq_t\", I obtained crashes apparently caused by the `slice_biseq` function. It is using `mpn_rshift`, and it did so even when the shift was zero. However, I found in the docs that the shift is supposed to be at least 1. Hence, when there is no shift, I am now using `mpn_copyi` instead. Hope it helps to prevent the crash...",
    "created_at": "2014-09-05T12:25:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199982",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:0" align="right">comment:0</div>

This is to explain the most recent commit: By doing some non-commutative Gröbner basis computations relying on "biseq_t", I obtained crashes apparently caused by the `slice_biseq` function. It is using `mpn_rshift`, and it did so even when the shift was zero. However, I found in the docs that the shift is supposed to be at least 1. Hence, when there is no shift, I am now using `mpn_copyi` instead. Hope it helps to prevent the crash...



---

archive/issue_comments_199983.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nArgh. No, it did not fix the crash in my Gr\u00f6bner basis application. Anyway, I still think the commit makes sense.",
    "created_at": "2014-09-05T12:26:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199983",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

Argh. No, it did not fix the crash in my Gröbner basis application. Anyway, I still think the commit makes sense.



---

archive/issue_comments_199984.json:
```json
{
    "body": "<div id=\"comment:2\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a\"><code>6dfb1cb</code></a></td><td><code>Make contains_biseq interruptible and add to its doc</code></td></tr></table>\n",
    "created_at": "2014-10-04T18:41:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199984",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:2"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a"><code>6dfb1cb</code></a></td><td><code>Make contains_biseq interruptible and add to its doc</code></td></tr></table>




---

archive/issue_comments_199985.json:
```json
{
    "body": "Changed commit from **[`815d77c`](https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f)** to **[`6dfb1cb`](https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a)**",
    "created_at": "2014-10-04T18:41:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199985",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`815d77c`](https://github.com/sagemath/sagetrac-mirror/commit/815d77c77f48605ea33b87a88120aaabadfb5f7f)** to **[`6dfb1cb`](https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a)**



---

archive/issue_comments_199986.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI'm getting three valgrind warnings (#15586):\n\n```\nsage: sage: from sage.misc.bounded_integer_sequences import _biseq_stresstest\nsage: _biseq_stresstest()\n==3937== Invalid read of size 8\n==3937==    at 0x30A524B0: __gmpn_rshift (rshift.c:55)\n==3937==    by 0x48CCB50B: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2611)\n==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)\n==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n[...]\n==3937==  Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd\n==3937==    at 0x4C29BCF: malloc (vg_replace_malloc.c:296)\n==3937==    by 0x142EC8FD: sage_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)\n==3937==    by 0x142EC9E4: sage_gmp_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)\n==3937==    by 0x30A439EE: __gmpz_init2 (init2.c:33)\n==3937==    by 0x48CCE302: __pyx_f_4sage_4misc_25bounded_integer_sequences_concat_biseq (bounded_integer_sequences.c:2256)\n==3937==    by 0x48CD6806: __pyx_pf_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_31__add__ (bounded_integer_sequences.c:7201)\n==3937==    by 0x48CD6806: __pyx_pw_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_32__add__ (bounded_integer_sequences.c:7078)\n==3937==    by 0x4E80BC8: binary_op1 (abstract.c:945)\n==3937==    by 0x4E80BC8: PyNumber_Add (abstract.c:1185)\n==3937==    by 0x48CD39AD: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8281)\n==3937==    by 0x48CD39AD: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n[...]\n==3937== Conditional jump or move depends on uninitialised value(s)\n==3937==    at 0x48CCB5C3: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2828)\n==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)\n==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n==3937==    by 0x4F3F24F: PyEval_EvalCodeEx (ceval.c:3265)\n==3937==    by 0x4F3F378: PyEval_EvalCode (ceval.c:673)\n```\nThe middle one is almost certainly an error, the other two don't look too good either.",
    "created_at": "2014-10-12T12:24:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199986",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:3" align="right">comment:3</div>

I'm getting three valgrind warnings (#15586):

```
sage: sage: from sage.misc.bounded_integer_sequences import _biseq_stresstest
sage: _biseq_stresstest()
==3937== Invalid read of size 8
==3937==    at 0x30A524B0: __gmpn_rshift (rshift.c:55)
==3937==    by 0x48CCB50B: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2611)
==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)
==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
==3937==    by 0x4F3E768: call_function (ceval.c:4017)
==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
[...]
==3937==  Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd
==3937==    at 0x4C29BCF: malloc (vg_replace_malloc.c:296)
==3937==    by 0x142EC8FD: sage_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)
==3937==    by 0x142EC9E4: sage_gmp_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)
==3937==    by 0x30A439EE: __gmpz_init2 (init2.c:33)
==3937==    by 0x48CCE302: __pyx_f_4sage_4misc_25bounded_integer_sequences_concat_biseq (bounded_integer_sequences.c:2256)
==3937==    by 0x48CD6806: __pyx_pf_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_31__add__ (bounded_integer_sequences.c:7201)
==3937==    by 0x48CD6806: __pyx_pw_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_32__add__ (bounded_integer_sequences.c:7078)
==3937==    by 0x4E80BC8: binary_op1 (abstract.c:945)
==3937==    by 0x4E80BC8: PyNumber_Add (abstract.c:1185)
==3937==    by 0x48CD39AD: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8281)
==3937==    by 0x48CD39AD: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
==3937==    by 0x4F3E768: call_function (ceval.c:4017)
==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
[...]
==3937== Conditional jump or move depends on uninitialised value(s)
==3937==    at 0x48CCB5C3: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2828)
==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)
==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
==3937==    by 0x4F3E768: call_function (ceval.c:4017)
==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
==3937==    by 0x4F3F24F: PyEval_EvalCodeEx (ceval.c:3265)
==3937==    by 0x4F3F378: PyEval_EvalCode (ceval.c:673)
```
The middle one is almost certainly an error, the other two don't look too good either.



---

archive/issue_comments_199987.json:
```json
{
    "body": "<div id=\"comment:144\" align=\"right\">comment:144</div>\n\nGood that I added the stress test!\n\nReplying to [@vbraun](#comment:143):\n> I'm getting three valgrind warnings (#15586):\n> \n> ```\n> sage: sage: from sage.misc.bounded_integer_sequences import _biseq_stresstest\n> sage: _biseq_stresstest()\n> ==3937== Invalid read of size 8\n> ==3937==    at 0x30A524B0: __gmpn_rshift (rshift.c:55)\n> ==3937==    by 0x48CCB50B: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2611)\n> ==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)\n> ==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n> [...]\n> ==3937==  Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd\n> ==3937==    at 0x4C29BCF: malloc (vg_replace_malloc.c:296)\n> ==3937==    by 0x142EC8FD: sage_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)\n> ==3937==    by 0x142EC9E4: sage_gmp_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)\n> ==3937==    by 0x30A439EE: __gmpz_init2 (init2.c:33)\n> ==3937==    by 0x48CCE302: __pyx_f_4sage_4misc_25bounded_integer_sequences_concat_biseq (bounded_integer_sequences.c:2256)\n> ==3937==    by 0x48CD6806: __pyx_pf_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_31__add__ (bounded_integer_sequences.c:7201)\n> ==3937==    by 0x48CD6806: __pyx_pw_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_32__add__ (bounded_integer_sequences.c:7078)\n> ==3937==    by 0x4E80BC8: binary_op1 (abstract.c:945)\n> ==3937==    by 0x4E80BC8: PyNumber_Add (abstract.c:1185)\n> ==3937==    by 0x48CD39AD: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8281)\n> ==3937==    by 0x48CD39AD: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n> [...]\n> ```\n\nDo I understand correctly: It means that `contains_biseq` could read and `concat_biseq` could write stuff in non-allocated memory?\n\n> ```\n> ==3937== Conditional jump or move depends on uninitialised value(s)\n> ==3937==    at 0x48CCB5C3: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2828)\n> ==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)\n> ==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)\n> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)\n> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)\n> ==3937==    by 0x4F3F24F: PyEval_EvalCodeEx (ceval.c:3265)\n> ==3937==    by 0x4F3F378: PyEval_EvalCode (ceval.c:673)\n> ```\n> The middle one is almost certainly an error, the other two don't look too good either.\n\nWill the given line numbers (2611, 2256, 2828) be the same on my machine?",
    "created_at": "2014-10-12T20:09:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199987",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:144" align="right">comment:144</div>

Good that I added the stress test!

Replying to [@vbraun](#comment:143):
> I'm getting three valgrind warnings (#15586):
> 
> ```
> sage: sage: from sage.misc.bounded_integer_sequences import _biseq_stresstest
> sage: _biseq_stresstest()
> ==3937== Invalid read of size 8
> ==3937==    at 0x30A524B0: __gmpn_rshift (rshift.c:55)
> ==3937==    by 0x48CCB50B: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2611)
> ==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)
> ==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)
> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
> [...]
> ==3937==  Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd
> ==3937==    at 0x4C29BCF: malloc (vg_replace_malloc.c:296)
> ==3937==    by 0x142EC8FD: sage_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)
> ==3937==    by 0x142EC9E4: sage_gmp_malloc (in /home/vbraun/Sage/git-develop/local/lib/libcsage.so)
> ==3937==    by 0x30A439EE: __gmpz_init2 (init2.c:33)
> ==3937==    by 0x48CCE302: __pyx_f_4sage_4misc_25bounded_integer_sequences_concat_biseq (bounded_integer_sequences.c:2256)
> ==3937==    by 0x48CD6806: __pyx_pf_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_31__add__ (bounded_integer_sequences.c:7201)
> ==3937==    by 0x48CD6806: __pyx_pw_4sage_4misc_25bounded_integer_sequences_22BoundedIntegerSequence_32__add__ (bounded_integer_sequences.c:7078)
> ==3937==    by 0x4E80BC8: binary_op1 (abstract.c:945)
> ==3937==    by 0x4E80BC8: PyNumber_Add (abstract.c:1185)
> ==3937==    by 0x48CD39AD: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8281)
> ==3937==    by 0x48CD39AD: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)
> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
> [...]
> ```

Do I understand correctly: It means that `contains_biseq` could read and `concat_biseq` could write stuff in non-allocated memory?

> ```
> ==3937== Conditional jump or move depends on uninitialised value(s)
> ==3937==    at 0x48CCB5C3: __pyx_f_4sage_4misc_25bounded_integer_sequences_contains_biseq (bounded_integer_sequences.c:2828)
> ==3937==    by 0x48CD388A: __pyx_pf_4sage_4misc_25bounded_integer_sequences_2_biseq_stresstest (bounded_integer_sequences.c:8902)
> ==3937==    by 0x48CD388A: __pyx_pw_4sage_4misc_25bounded_integer_sequences_3_biseq_stresstest (bounded_integer_sequences.c:8038)
> ==3937==    by 0x4F3E768: call_function (ceval.c:4017)
> ==3937==    by 0x4F3E768: PyEval_EvalFrameEx (ceval.c:2679)
> ==3937==    by 0x4F3F24F: PyEval_EvalCodeEx (ceval.c:3265)
> ==3937==    by 0x4F3F378: PyEval_EvalCode (ceval.c:673)
> ```
> The middle one is almost certainly an error, the other two don't look too good either.

Will the given line numbers (2611, 2256, 2828) be the same on my machine?



---

archive/issue_comments_199988.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nI think they are, but I wouldn't bet anything on it ;-)",
    "created_at": "2014-10-12T20:28:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199988",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:5" align="right">comment:5</div>

I think they are, but I wouldn't bet anything on it ;-)



---

archive/issue_comments_199989.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\n1) is `contains_biseq` reading into unallocated memory, and 2) says that the invalid read is just beyond what `concat_biseq` allocated.",
    "created_at": "2014-10-12T20:35:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199989",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:6" align="right">comment:6</div>

1) is `contains_biseq` reading into unallocated memory, and 2) says that the invalid read is just beyond what `concat_biseq` allocated.



---

archive/issue_comments_199990.json:
```json
{
    "body": "<div id=\"comment:147\" align=\"right\">comment:147</div>\n\nReplying to [@vbraun](#comment:146):\n> 1) is `contains_biseq` reading into unallocated memory, and 2) says that the invalid read is just beyond what `concat_biseq` allocated.\n\nSigh. Could be that I even don't see where 1), 2) and 3) are in the valgrind log...\n\nConcerning the invalid read of size 8 by `__gmpn_rshift`: I think I recall that at some point I wanted to avoid considering cases and thus allowed to rshift memory that partially is uninitialised, since after the shift I would only access the bytes that were allocated. Probably this is improper and should be fixed.\n\nConcerning `Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd`: I thought this means I am writing into non-allocated memory. But by your new comment, I understand that this just indicates where the memory accessed by the previous item (`__gmpn_rshift`) was allocated. I guess I need an explanation.\n\nConcerning `Conditional jump or move depends on uninitialised value(s)`: Is this independent of the two previous points? Or does it concern the same example and the same memory location?",
    "created_at": "2014-10-13T08:23:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199990",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:147" align="right">comment:147</div>

Replying to [@vbraun](#comment:146):
> 1) is `contains_biseq` reading into unallocated memory, and 2) says that the invalid read is just beyond what `concat_biseq` allocated.

Sigh. Could be that I even don't see where 1), 2) and 3) are in the valgrind log...

Concerning the invalid read of size 8 by `__gmpn_rshift`: I think I recall that at some point I wanted to avoid considering cases and thus allowed to rshift memory that partially is uninitialised, since after the shift I would only access the bytes that were allocated. Probably this is improper and should be fixed.

Concerning `Address 0xecfe560 is 0 bytes after a block of size 16 alloc'd`: I thought this means I am writing into non-allocated memory. But by your new comment, I understand that this just indicates where the memory accessed by the previous item (`__gmpn_rshift`) was allocated. I guess I need an explanation.

Concerning `Conditional jump or move depends on uninitialised value(s)`: Is this independent of the two previous points? Or does it concern the same example and the same memory location?



---

archive/issue_comments_199991.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nWith the updated valgrind they are the only errors while running the testsuite(!). Trivial to spot. Its possible that they are false positives if you use only certain bit positions, but zeroing out the memory doesn't cost much in terms of runtime and can save us a lot of work if your calculations about bit patterns are off by one ;-)",
    "created_at": "2014-10-13T08:27:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199991",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:8" align="right">comment:8</div>

With the updated valgrind they are the only errors while running the testsuite(!). Trivial to spot. Its possible that they are false positives if you use only certain bit positions, but zeroing out the memory doesn't cost much in terms of runtime and can save us a lot of work if your calculations about bit patterns are off by one ;-)



---

archive/issue_comments_199992.json:
```json
{
    "body": "<div id=\"comment:149\" align=\"right\">comment:149</div>\n\nReplying to [@vbraun](#comment:148):\n> With the updated valgrind they are the only errors while running the testsuite(!).\n\nWow, that's excellent news (except for my code `:-/`)!\n\n> Trivial to spot. Its possible that they are false positives if you use only certain bit positions, but zeroing out the memory doesn't cost much in terms of runtime and can save us a lot of work if your calculations about bit patterns are off by one ;-)\n\nTrue. Anyway, to fix it I probably need answers to my questions from [comment:147](#comment:147) in order to know exactly what to do.",
    "created_at": "2014-10-13T09:38:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199992",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:149" align="right">comment:149</div>

Replying to [@vbraun](#comment:148):
> With the updated valgrind they are the only errors while running the testsuite(!).

Wow, that's excellent news (except for my code `:-/`)!

> Trivial to spot. Its possible that they are false positives if you use only certain bit positions, but zeroing out the memory doesn't cost much in terms of runtime and can save us a lot of work if your calculations about bit patterns are off by one ;-)

True. Anyway, to fix it I probably need answers to my questions from [comment:147](#comment:147) in order to know exactly what to do.



---

archive/issue_comments_199993.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nIn the first one you are reading past the end of the buffer from unallocated memory. Either you need to allocate enough (round up) or also handle the cases where you have less than a full 8 bytes. Even though its highly unlikely, reading past the end could even result in a segfault if the process space happens to end there.",
    "created_at": "2014-10-13T12:16:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199993",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:0" align="right">comment:0</div>

In the first one you are reading past the end of the buffer from unallocated memory. Either you need to allocate enough (round up) or also handle the cases where you have less than a full 8 bytes. Even though its highly unlikely, reading past the end could even result in a segfault if the process space happens to end there.



---

archive/issue_comments_199994.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nIf it's an \"invalid read of size 8\" and \"0 bytes after a block\" in mpn_copyi, chances are it's not a bug. GMP/MPIR will sometimes read 16 aligned bytes at a time when there are just 8 bytes left to copy, on certain architectures where this is safe. This might be the case in mpn_rshift too.\n\nIf you're absolutely sure that your code should be correct there, you could try compiling MPIR with assembly optimizations disabled and see if the error goes away. Or easier, temporarily replace the mpn_rshift in your code with a plain C implementation (e.g. the one in mpn/generic/rshift.c in MPIR).\n\nThe \"Conditional jump or move depends on uninitialised value\" is absolutely a bug.",
    "created_at": "2014-10-13T12:47:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199994",
    "user": "https://github.com/fredrik-johansson"
}
```

<div id="comment:1" align="right">comment:1</div>

If it's an "invalid read of size 8" and "0 bytes after a block" in mpn_copyi, chances are it's not a bug. GMP/MPIR will sometimes read 16 aligned bytes at a time when there are just 8 bytes left to copy, on certain architectures where this is safe. This might be the case in mpn_rshift too.

If you're absolutely sure that your code should be correct there, you could try compiling MPIR with assembly optimizations disabled and see if the error goes away. Or easier, temporarily replace the mpn_rshift in your code with a plain C implementation (e.g. the one in mpn/generic/rshift.c in MPIR).

The "Conditional jump or move depends on uninitialised value" is absolutely a bug.



---

archive/issue_comments_199995.json:
```json
{
    "body": "<div id=\"comment:152\" align=\"right\">comment:152</div>\n\nReplying to [@vbraun](#comment:145):\n> I think they (the line numbers, SK) are (the same on different machines, SK), but I wouldn't bet anything on it ;-)\n\nHmm. The conditional jump occurs in line 2828 of the c-file, but this is:\n\n```\n  /* \"sage/misc/bounded_integer_sequences.pyx\":398\n *             n += S1.itembitsize\n *     mpz_clear(tmp)\n *     return -1             # <<<<<<<<<<<<<<\n * \n * cdef int index_biseq(biseq_t S, int item, size_t start) except -2:\n */   #### Here is 2828\n  __pyx_r = -1;\n  goto __pyx_L0;\n```\nHm. Volker, could you provide the location of the conditional jump that is giving you the warning?",
    "created_at": "2014-10-13T15:32:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199995",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:152" align="right">comment:152</div>

Replying to [@vbraun](#comment:145):
> I think they (the line numbers, SK) are (the same on different machines, SK), but I wouldn't bet anything on it ;-)

Hmm. The conditional jump occurs in line 2828 of the c-file, but this is:

```
  /* "sage/misc/bounded_integer_sequences.pyx":398
 *             n += S1.itembitsize
 *     mpz_clear(tmp)
 *     return -1             # <<<<<<<<<<<<<<
 * 
 * cdef int index_biseq(biseq_t S, int item, size_t start) except -2:
 */   #### Here is 2828
  __pyx_r = -1;
  goto __pyx_L0;
```
Hm. Volker, could you provide the location of the conditional jump that is giving you the warning?



---

archive/issue_comments_199996.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI had a chat with Nathann today. He asked me about the data structure used by GMP, which is mainly `long*` (aka \"limb\"), plus some information on the number of limbs used and the number of limbs allocated. `long*` is also used by `sage.misc.bitset`.\n\nWhat I am implementing here is in fact quite similar to bitsets (one item of a bounded integer sequence corresponds to a chunk of bits, but otherwise it is the same). So, he suggested to not duplicate code, but make mutual use.\n\nI have looked at the bitset code in the past, but apparently it was long before I implemented bounded integer sequences: Now I realize that much of what I do here is actually done in `sage.misc.bitset`! So, definitely I should reuse the code. Hence, marking it as \"needs work\" for now, as the code will totally change.\n\nSuggestion: I'll add to `sage.misc.bitset` what is not already there, and then `sage.misc.bounded_integer_sequence` will not provide all the boilerplate code, but only provide the Python layer to comfortably use bounded integer sequences.",
    "created_at": "2014-10-15T11:57:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199996",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

I had a chat with Nathann today. He asked me about the data structure used by GMP, which is mainly `long*` (aka "limb"), plus some information on the number of limbs used and the number of limbs allocated. `long*` is also used by `sage.misc.bitset`.

What I am implementing here is in fact quite similar to bitsets (one item of a bounded integer sequence corresponds to a chunk of bits, but otherwise it is the same). So, he suggested to not duplicate code, but make mutual use.

I have looked at the bitset code in the past, but apparently it was long before I implemented bounded integer sequences: Now I realize that much of what I do here is actually done in `sage.misc.bitset`! So, definitely I should reuse the code. Hence, marking it as "needs work" for now, as the code will totally change.

Suggestion: I'll add to `sage.misc.bitset` what is not already there, and then `sage.misc.bounded_integer_sequence` will not provide all the boilerplate code, but only provide the Python layer to comfortably use bounded integer sequences.



---

archive/issue_comments_199997.json:
```json
{
    "body": "Work Issues: **Rework by using Sage's existing bitset code**",
    "created_at": "2014-10-15T11:57:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199997",
    "user": "https://github.com/simon-king-jena"
}
```

Work Issues: **Rework by using Sage's existing bitset code**



---

archive/issue_events_225923.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-15T11:57:13Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225923"
}
```



---

archive/issue_events_225924.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-15T11:57:13Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225924"
}
```



---

archive/issue_comments_199998.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nI do need a bit more for `biseq_t` than what is provided by `bitset_t`. For example, I need to store the information how many bits are required to store one item on the list. But anyway, I will now try to rewrite my code.",
    "created_at": "2014-10-15T13:53:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199998",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

I do need a bit more for `biseq_t` than what is provided by `bitset_t`. For example, I need to store the information how many bits are required to store one item on the list. But anyway, I will now try to rewrite my code.



---

archive/issue_comments_199999.json:
```json
{
    "body": "Changed commit from **[`6dfb1cb`](https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a)** to **[`47c639d`](https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce)**",
    "created_at": "2014-10-18T13:38:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-199999",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`6dfb1cb`](https://github.com/sagemath/sagetrac-mirror/commit/6dfb1cb1c6dc5704e2a8918cf2aeabdd8dbef69a)** to **[`47c639d`](https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce)**



---

archive/issue_comments_200000.json:
```json
{
    "body": "<div id=\"comment:5\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bfd7898a1f883c931026f46a526a0ec88bd73db6\"><code>bfd7898</code></a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820, since apparently the bitset code changed</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce\"><code>47c639d</code></a></td><td><code>Rewrite bounded integer sequences using sage.misc.bitset</code></td></tr></table>\n",
    "created_at": "2014-10-18T13:38:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200000",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:5"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bfd7898a1f883c931026f46a526a0ec88bd73db6"><code>bfd7898</code></a></td><td><code>Merge branch 'develop' into t/15820/ticket/15820, since apparently the bitset code changed</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce"><code>47c639d</code></a></td><td><code>Rewrite bounded integer sequences using sage.misc.bitset</code></td></tr></table>




---

archive/issue_events_225925.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-18T13:45:20Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225925"
}
```



---

archive/issue_events_225926.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-18T13:45:20Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225926"
}
```



---

archive/issue_comments_200001.json:
```json
{
    "body": "Changed work issues from **Rework by using Sage's existing bitset code** to none",
    "created_at": "2014-10-18T13:45:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200001",
    "user": "https://github.com/simon-king-jena"
}
```

Changed work issues from **Rework by using Sage's existing bitset code** to none



---

archive/issue_comments_200002.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nBy suggestion of Nathann, I am now reusing part of the existing code from `sage.misc.bitset`. Main advantage is the fact that (in contrast to the `mpz_*` functions) leading zeros will not be silently removed, which means that I could avoid many special cases.\n\nHopefully Nathann will find the new version of the code a lot less frightening than the old version...\n\nNeeds review again, and soonish I will update the timings that have occasionally been mentioned in comments above.",
    "created_at": "2014-10-18T13:45:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200002",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

By suggestion of Nathann, I am now reusing part of the existing code from `sage.misc.bitset`. Main advantage is the fact that (in contrast to the `mpz_*` functions) leading zeros will not be silently removed, which means that I could avoid many special cases.

Hopefully Nathann will find the new version of the code a lot less frightening than the old version...

Needs review again, and soonish I will update the timings that have occasionally been mentioned in comments above.



---

archive/issue_comments_200003.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nLet us compare the performance tests from [comment:83](#comment:83) (also adding tests for\npickling) with the new code version (I am testing on the same laptop, thus,\nhopefully a comparison makes sense):\n\n```\nsage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.15 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n1000000 loops, best of 3: 1.35 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n1000000 loops, best of 3: 1.88 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n10000 loops, best of 3: 70.5 \u00b5s per loop\n```\n--> Became all faster\n\n```\nsage: %timeit x = list(S0)\n1000000 loops, best of 3: 1.43 \u00b5s per loop\nsage: %timeit x = list(S1)\n100000 loops, best of 3: 1.84 \u00b5s per loop\nsage: %timeit x = list(S2)\n100000 loops, best of 3: 4.41 \u00b5s per loop\nsage: %timeit x = list(S3)\n1000 loops, best of 3: 304 \u00b5s per loop\nsage: %timeit x = S0.list()\n1000000 loops, best of 3: 666 ns per loop\nsage: %timeit x = S1.list()\n1000000 loops, best of 3: 1.2 \u00b5s per loop\nsage: %timeit x = S2.list()\n100000 loops, best of 3: 2.77 \u00b5s per loop\nsage: %timeit x = S3.list()\n10000 loops, best of 3: 112 \u00b5s per loop\n```\n--> Became faster at least for short sequences, which is the case I am mainly\ninterested in\n\n```\nsage: timeit(\"x=S0[:-1]\", number=100000)\n100000 loops, best of 3: 1.49 \u00b5s per loop\nsage: timeit(\"x=S1[:-1]\", number=100000)\n100000 loops, best of 3: 1.52 \u00b5s per loop\nsage: timeit(\"x=S2[:-1]\", number=100000)\n100000 loops, best of 3: 1.52 \u00b5s per loop\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 2.29 \u00b5s per loop\n```\n--> Became all faster\n\n```\nsage: timeit(\"x=S2[:-1:2]\", number=10000)\n10000 loops, best of 3: 2.5 \u00b5s per loop\nsage: timeit(\"x=S3[:-1:2]\", number=10000)\n10000 loops, best of 3: 62.2 \u00b5s per loop\n```\n--> Became faster for the shorter sequence\n\n```\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 340 ns per loop\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 339 ns per loop\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 339 ns per loop\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 345 ns per loop\n```\n--> Became all faster\n\n```\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: S1y = BoundedIntegerSequence(16, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S1y==S1!=S1x, S1y is not S1\n(True, True)\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0z2.startswith(S0)\", number=1000000)\n1000000 loops, best of 3: 210 ns per loop\nsage: timeit(\"S0z2.startswith(S0x)\", number=1000000)\n1000000 loops, best of 3: 211 ns per loop\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 368 ns per loop\nsage: timeit(\"S1z2.startswith(S1)\", number=1000000)\n1000000 loops, best of 3: 200 ns per loop\nsage: timeit(\"S1z2.startswith(S1x)\", number=1000000)\n1000000 loops, best of 3: 199 ns per loop\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 542 ns per loop\nsage: timeit(\"S2z2.startswith(S2)\", number=1000000)\n1000000 loops, best of 3: 219 ns per loop\nsage: timeit(\"S2z2.startswith(S2x)\", number=1000000)\n1000000 loops, best of 3: 205 ns per loop\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 2.33 \u00b5s per loop\nsage: timeit(\"S3z2.startswith(S3)\", number=1000000)\n1000000 loops, best of 3: 963 ns per loop\nsage: timeit(\"S3z2.startswith(S3x)\", number=1000000)\n1000000 loops, best of 3: 201 ns per loop\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 2.36 ms per loop\n```\n--> All but the last became faster, which is excellent for my applications, as\nI am using subsequence containment tests fairly often.\n\nAdditional timings for pickling, comparing Python lists with bounded integer\nsequences:\n\n```\nsage: %timeit loads(dumps(L0))\n10000 loops, best of 3: 39.5 \u00b5s per loop\nsage: %timeit loads(dumps(L1))\n10000 loops, best of 3: 43.9 \u00b5s per loop\nsage: %timeit loads(dumps(L2))\n10000 loops, best of 3: 65.5 \u00b5s per loop\nsage: %timeit loads(dumps(L3))\n100 loops, best of 3: 2.13 ms per loop\nsage: %timeit loads(dumps(S0))\n10000 loops, best of 3: 68.7 \u00b5s per loop\nsage: %timeit loads(dumps(S1))\n10000 loops, best of 3: 72.1 \u00b5s per loop\nsage: %timeit loads(dumps(S2))\n10000 loops, best of 3: 87 \u00b5s per loop\nsage: %timeit loads(dumps(S3))\n1000 loops, best of 3: 1.06 ms per loop\n```\n--> Pickling of short bounded integer sequences has an overhead, but longer\nsequences are pickled faster, due to the more compact representation.\n\nI think that one can say that the new code version results in an overall performance gain,\nand I suppose it is less frightening now.",
    "created_at": "2014-10-18T14:11:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200003",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

Let us compare the performance tests from [comment:83](#comment:83) (also adding tests for
pickling) with the new code version (I am testing on the same laptop, thus,
hopefully a comparison makes sense):

```
sage: from sage.misc.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.15 µs per loop
sage: %timeit x = BoundedIntegerSequence(16, L1)
1000000 loops, best of 3: 1.35 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L2)
1000000 loops, best of 3: 1.88 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L3)
10000 loops, best of 3: 70.5 µs per loop
```
--> Became all faster

```
sage: %timeit x = list(S0)
1000000 loops, best of 3: 1.43 µs per loop
sage: %timeit x = list(S1)
100000 loops, best of 3: 1.84 µs per loop
sage: %timeit x = list(S2)
100000 loops, best of 3: 4.41 µs per loop
sage: %timeit x = list(S3)
1000 loops, best of 3: 304 µs per loop
sage: %timeit x = S0.list()
1000000 loops, best of 3: 666 ns per loop
sage: %timeit x = S1.list()
1000000 loops, best of 3: 1.2 µs per loop
sage: %timeit x = S2.list()
100000 loops, best of 3: 2.77 µs per loop
sage: %timeit x = S3.list()
10000 loops, best of 3: 112 µs per loop
```
--> Became faster at least for short sequences, which is the case I am mainly
interested in

```
sage: timeit("x=S0[:-1]", number=100000)
100000 loops, best of 3: 1.49 µs per loop
sage: timeit("x=S1[:-1]", number=100000)
100000 loops, best of 3: 1.52 µs per loop
sage: timeit("x=S2[:-1]", number=100000)
100000 loops, best of 3: 1.52 µs per loop
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 2.29 µs per loop
```
--> Became all faster

```
sage: timeit("x=S2[:-1:2]", number=10000)
10000 loops, best of 3: 2.5 µs per loop
sage: timeit("x=S3[:-1:2]", number=10000)
10000 loops, best of 3: 62.2 µs per loop
```
--> Became faster for the shorter sequence

```
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 340 ns per loop
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 339 ns per loop
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 339 ns per loop
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 345 ns per loop
```
--> Became all faster

```
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: S1y = BoundedIntegerSequence(16, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S1y==S1!=S1x, S1y is not S1
(True, True)
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0z2.startswith(S0)", number=1000000)
1000000 loops, best of 3: 210 ns per loop
sage: timeit("S0z2.startswith(S0x)", number=1000000)
1000000 loops, best of 3: 211 ns per loop
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 368 ns per loop
sage: timeit("S1z2.startswith(S1)", number=1000000)
1000000 loops, best of 3: 200 ns per loop
sage: timeit("S1z2.startswith(S1x)", number=1000000)
1000000 loops, best of 3: 199 ns per loop
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 542 ns per loop
sage: timeit("S2z2.startswith(S2)", number=1000000)
1000000 loops, best of 3: 219 ns per loop
sage: timeit("S2z2.startswith(S2x)", number=1000000)
1000000 loops, best of 3: 205 ns per loop
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 2.33 µs per loop
sage: timeit("S3z2.startswith(S3)", number=1000000)
1000000 loops, best of 3: 963 ns per loop
sage: timeit("S3z2.startswith(S3x)", number=1000000)
1000000 loops, best of 3: 201 ns per loop
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 2.36 ms per loop
```
--> All but the last became faster, which is excellent for my applications, as
I am using subsequence containment tests fairly often.

Additional timings for pickling, comparing Python lists with bounded integer
sequences:

```
sage: %timeit loads(dumps(L0))
10000 loops, best of 3: 39.5 µs per loop
sage: %timeit loads(dumps(L1))
10000 loops, best of 3: 43.9 µs per loop
sage: %timeit loads(dumps(L2))
10000 loops, best of 3: 65.5 µs per loop
sage: %timeit loads(dumps(L3))
100 loops, best of 3: 2.13 ms per loop
sage: %timeit loads(dumps(S0))
10000 loops, best of 3: 68.7 µs per loop
sage: %timeit loads(dumps(S1))
10000 loops, best of 3: 72.1 µs per loop
sage: %timeit loads(dumps(S2))
10000 loops, best of 3: 87 µs per loop
sage: %timeit loads(dumps(S3))
1000 loops, best of 3: 1.06 ms per loop
```
--> Pickling of short bounded integer sequences has an overhead, but longer
sequences are pickled faster, due to the more compact representation.

I think that one can say that the new code version results in an overall performance gain,
and I suppose it is less frightening now.



---

archive/issue_comments_200004.json:
```json
{
    "body": "Changed commit from **[`47c639d`](https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce)** to **[`e3260e2`](https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310)**",
    "created_at": "2014-10-18T15:28:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200004",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`47c639d`](https://github.com/sagemath/sagetrac-mirror/commit/47c639d55d3c07670b8b52a629f7cf86a8beb7ce)** to **[`e3260e2`](https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310)**



---

archive/issue_comments_200005.json:
```json
{
    "body": "<div id=\"comment:8\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310\"><code>e3260e2</code></a></td><td><code>Typographical improvements</code></td></tr></table>\n",
    "created_at": "2014-10-18T15:28:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200005",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:8"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310"><code>e3260e2</code></a></td><td><code>Typographical improvements</code></td></tr></table>




---

archive/issue_comments_200006.json:
```json
{
    "body": "<div id=\"comment:9\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1\"><code>aac3a04</code></a></td><td><code>Fix cornercase in unpickling</code></td></tr></table>\n",
    "created_at": "2014-10-18T22:13:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200006",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:9"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1"><code>aac3a04</code></a></td><td><code>Fix cornercase in unpickling</code></td></tr></table>




---

archive/issue_comments_200007.json:
```json
{
    "body": "Changed commit from **[`e3260e2`](https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310)** to **[`aac3a04`](https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1)**",
    "created_at": "2014-10-18T22:13:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200007",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`e3260e2`](https://github.com/sagemath/sagetrac-mirror/commit/e3260e2d9f5bf0483770cc5235c00cd24c4eb310)** to **[`aac3a04`](https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1)**



---

archive/issue_comments_200008.json:
```json
{
    "body": "Changed commit from **[`aac3a04`](https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1)** to **[`b182ba2`](https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89)**",
    "created_at": "2014-10-19T09:00:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200008",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`aac3a04`](https://github.com/sagemath/sagetrac-mirror/commit/aac3a049805ab29aea8a0d3439c1eadf6605eab1)** to **[`b182ba2`](https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89)**



---

archive/issue_comments_200009.json:
```json
{
    "body": "<div id=\"comment:0\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89\"><code>b182ba2</code></a></td><td><code>Use mpn_l/rshift only with nonzero shift</code></td></tr></table>\n",
    "created_at": "2014-10-19T09:00:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200009",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:0"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89"><code>b182ba2</code></a></td><td><code>Use mpn_l/rshift only with nonzero shift</code></td></tr></table>




---

archive/issue_comments_200010.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nJust randomly looking through this patch...\n\nI don't like to put this in `src/sage/misc`. There is already too much stuff there. I think we need an additional top-level directory for basic data structures like this (bitset also should be in there). What do you think of `src/sage/data_structures`?",
    "created_at": "2014-10-21T13:44:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200010",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:1" align="right">comment:1</div>

Just randomly looking through this patch...

I don't like to put this in `src/sage/misc`. There is already too much stuff there. I think we need an additional top-level directory for basic data structures like this (bitset also should be in there). What do you think of `src/sage/data_structures`?



---

archive/issue_comments_200011.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nAlso, instead of `allocate_biseq()`, I would use `biseq_init()` to be more analogous to `mpz_init()` and `bitset_init()`. More generally, replace `foo_biseq()` by `biseq_foo()`.",
    "created_at": "2014-10-21T13:47:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200011",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:2" align="right">comment:2</div>

Also, instead of `allocate_biseq()`, I would use `biseq_init()` to be more analogous to `mpz_init()` and `bitset_init()`. More generally, replace `foo_biseq()` by `biseq_foo()`.



---

archive/issue_comments_200012.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nPlease don't `cdef extern from \"gmp.h\"`, use `from sage.libs.gmp.mpn cimport *` or something.",
    "created_at": "2014-10-21T13:48:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200012",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:3" align="right">comment:3</div>

Please don't `cdef extern from "gmp.h"`, use `from sage.libs.gmp.mpn cimport *` or something.



---

archive/issue_comments_200013.json:
```json
{
    "body": "<div id=\"comment:164\" align=\"right\">comment:164</div>\n\nReplying to [@jdemeyer](#comment:161):\n> Just randomly looking through this patch...\n> \n> I don't like to put this in `src/sage/misc`. There is already too much stuff there. I think we need an additional top-level directory for basic data structures like this (bitset also should be in there). What do you think of `src/sage/data_structures`?\n\nI think this question has been discussed on another ticket that I authored. My impression from the discussion was that \"structural\" stuff should either go to `sage/structure` or `sage/misc`. It should be the former, if it is about structures that only make sense in Sage (Parents, elements, ...), whereas `sage/misc` is for structure that would also make sense without Sage. I thought that bounded integer sequences belong to the latter, and I would also think that `TripleDict` and `MonoDict` should better be in `sage/misc` (the only reason for them being in `sage/structure` is the fact that they were introduced for coercion, which is Sage specific).\n\nSo, I think `sage/misc` is a good place. But I wouldn't mind to introduce a third structural module, `sage/data_structures`. On a different ticket?",
    "created_at": "2014-10-21T13:58:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200013",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:164" align="right">comment:164</div>

Replying to [@jdemeyer](#comment:161):
> Just randomly looking through this patch...
> 
> I don't like to put this in `src/sage/misc`. There is already too much stuff there. I think we need an additional top-level directory for basic data structures like this (bitset also should be in there). What do you think of `src/sage/data_structures`?

I think this question has been discussed on another ticket that I authored. My impression from the discussion was that "structural" stuff should either go to `sage/structure` or `sage/misc`. It should be the former, if it is about structures that only make sense in Sage (Parents, elements, ...), whereas `sage/misc` is for structure that would also make sense without Sage. I thought that bounded integer sequences belong to the latter, and I would also think that `TripleDict` and `MonoDict` should better be in `sage/misc` (the only reason for them being in `sage/structure` is the fact that they were introduced for coercion, which is Sage specific).

So, I think `sage/misc` is a good place. But I wouldn't mind to introduce a third structural module, `sage/data_structures`. On a different ticket?



---

archive/issue_comments_200014.json:
```json
{
    "body": "<div id=\"comment:165\" align=\"right\">comment:165</div>\n\nReplying to [@jdemeyer](#comment:162):\n> Also, instead of `allocate_biseq()`, I would use `biseq_init()` to be more analogous to `mpz_init()` and `bitset_init()`.\n> More generally, replace `foo_biseq()` by `biseq_foo()`.\n\nOk, makes sense.",
    "created_at": "2014-10-21T14:00:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200014",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:165" align="right">comment:165</div>

Replying to [@jdemeyer](#comment:162):
> Also, instead of `allocate_biseq()`, I would use `biseq_init()` to be more analogous to `mpz_init()` and `bitset_init()`.
> More generally, replace `foo_biseq()` by `biseq_foo()`.

Ok, makes sense.



---

archive/issue_comments_200015.json:
```json
{
    "body": "<div id=\"comment:166\" align=\"right\">comment:166</div>\n\nReplying to [@jdemeyer](#comment:163):\n> Please don't `cdef extern from \"gmp.h\"`, use `from sage.libs.gmp.mpn cimport *` or something.\n\nIs it available from there? If it is, then I should certainly do it in that way.",
    "created_at": "2014-10-21T14:03:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200015",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:166" align="right">comment:166</div>

Replying to [@jdemeyer](#comment:163):
> Please don't `cdef extern from "gmp.h"`, use `from sage.libs.gmp.mpn cimport *` or something.

Is it available from there? If it is, then I should certainly do it in that way.



---

archive/issue_comments_200016.json:
```json
{
    "body": "<div id=\"comment:167\" align=\"right\">comment:167</div>\n\nReplying to [@simon-king-jena](#comment:166):\n> Replying to [@jdemeyer](#comment:163):\n> > Please don't `cdef extern from \"gmp.h\"`, use `from sage.libs.gmp.mpn cimport *` or something.\n\n> \n> Is it available from there? If it is, then I should certainly do it in that way.\n\n`mp_bits_per_limb` is not available from there, hence, I still import it from gmp.h.\n\nFor now I will not introduce a new `sage.data_structures`.\n\nAfter running tests, I will push a commit that address your other comments.",
    "created_at": "2014-10-21T14:34:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200016",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:167" align="right">comment:167</div>

Replying to [@simon-king-jena](#comment:166):
> Replying to [@jdemeyer](#comment:163):
> > Please don't `cdef extern from "gmp.h"`, use `from sage.libs.gmp.mpn cimport *` or something.

> 
> Is it available from there? If it is, then I should certainly do it in that way.

`mp_bits_per_limb` is not available from there, hence, I still import it from gmp.h.

For now I will not introduce a new `sage.data_structures`.

After running tests, I will push a commit that address your other comments.



---

archive/issue_comments_200017.json:
```json
{
    "body": "Changed commit from **[`b182ba2`](https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89)** to **[`1f5a53e`](https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655)**",
    "created_at": "2014-10-21T14:36:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200017",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`b182ba2`](https://github.com/sagemath/sagetrac-mirror/commit/b182ba27bdaeb0f066daf1b575db3588b3195f89)** to **[`1f5a53e`](https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655)**



---

archive/issue_comments_200018.json:
```json
{
    "body": "<div id=\"comment:8\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655\"><code>1f5a53e</code></a></td><td><code>Change the naming schemes of functions according to conventions in gmp and bitset</code></td></tr></table>\n",
    "created_at": "2014-10-21T14:36:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200018",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:8"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655"><code>1f5a53e</code></a></td><td><code>Change the naming schemes of functions according to conventions in gmp and bitset</code></td></tr></table>




---

archive/issue_comments_200019.json:
```json
{
    "body": "<div id=\"comment:169\" align=\"right\">comment:169</div>\n\nReplying to [@simon-king-jena](#comment:164):\n> On a different ticket?\n\nIt makes no sense to first introduce a new module on this ticket and then make a new ticket to immediately move that new module somewhere else (requiring changing import statements and everything). If it were an existing module, things would be different.\n\nThe problem with `src/sage/misc` is that it contains a lot of various things. Usually \"misc\" is used when something doesn't belong to any other category. But it's clear that there are a lot of modules defining data structures in `misc` (but also other stuff like `temporary_file`). I think it makes sense to group these in `src/sage/data_structures` (or another name, whatever) instead of dumping everything in `misc`.",
    "created_at": "2014-10-21T15:34:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200019",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:169" align="right">comment:169</div>

Replying to [@simon-king-jena](#comment:164):
> On a different ticket?

It makes no sense to first introduce a new module on this ticket and then make a new ticket to immediately move that new module somewhere else (requiring changing import statements and everything). If it were an existing module, things would be different.

The problem with `src/sage/misc` is that it contains a lot of various things. Usually "misc" is used when something doesn't belong to any other category. But it's clear that there are a lot of modules defining data structures in `misc` (but also other stuff like `temporary_file`). I think it makes sense to group these in `src/sage/data_structures` (or another name, whatever) instead of dumping everything in `misc`.



---

archive/issue_comments_200020.json:
```json
{
    "body": "<div id=\"comment:170\" align=\"right\">comment:170</div>\n\nReplying to [@simon-king-jena](#comment:167):\n> `mp_bits_per_limb` is not available from there, hence, I still import it from gmp.h.\n\nNo, *do* cimport it from `sage.libs.gmp.types` and add the declaration there.",
    "created_at": "2014-10-21T15:42:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200020",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:170" align="right">comment:170</div>

Replying to [@simon-king-jena](#comment:167):
> `mp_bits_per_limb` is not available from there, hence, I still import it from gmp.h.

No, *do* cimport it from `sage.libs.gmp.types` and add the declaration there.



---

archive/issue_comments_200021.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nThis documentation of `ctypedef struct biseq` should be expanded. When reading it, it is really not clear to me what the various fields mean (especially `\"bla&mask_item\" greps onethe item bla starts with` makes no sense) and how the data structure works. If you're trying too hard to get everything one line, use\n\n```\nctypedef struct biseq:\n    # comment about data\n    bitset_t data\n\n    # comment about itembitsize\n    # comment about itembitsize\n    # comment about itembitsize\n    mp_bitcnt_t itembitsize\n...\n```",
    "created_at": "2014-10-21T15:48:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200021",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:1" align="right">comment:1</div>

This documentation of `ctypedef struct biseq` should be expanded. When reading it, it is really not clear to me what the various fields mean (especially `"bla&mask_item" greps onethe item bla starts with` makes no sense) and how the data structure works. If you're trying too hard to get everything one line, use

```
ctypedef struct biseq:
    # comment about data
    bitset_t data

    # comment about itembitsize
    # comment about itembitsize
    # comment about itembitsize
    mp_bitcnt_t itembitsize
...
```



---

archive/issue_events_225927.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-21T15:48:44Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225927"
}
```



---

archive/issue_events_225928.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-21T15:48:44Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225928"
}
```



---

archive/issue_comments_200022.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\n`first_bits_equal` -> `biseq_first_bits_equal`",
    "created_at": "2014-10-21T15:49:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200022",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:3" align="right">comment:3</div>

`first_bits_equal` -> `biseq_first_bits_equal`



---

archive/issue_comments_200023.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nAlso: I think you use `int` in a lot of places where you really want a `long` or `mp_limb_t` or `mp_size_t` or `Py_ssize_t`.",
    "created_at": "2014-10-21T15:53:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200023",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:4" align="right">comment:4</div>

Also: I think you use `int` in a lot of places where you really want a `long` or `mp_limb_t` or `mp_size_t` or `Py_ssize_t`.



---

archive/issue_comments_200024.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\n`list_to_biseq` seems to leak memory if the `biseq_t` was already initialized. I don't mind, but it should be documented, since it's not obvious without reading the code.\n\nAlso in `list_to_biseq`, the branch `if ln>mp_bits_per_limb:` leaks `tmp`.",
    "created_at": "2014-10-21T16:00:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200024",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:5" align="right">comment:5</div>

`list_to_biseq` seems to leak memory if the `biseq_t` was already initialized. I don't mind, but it should be documented, since it's not obvious without reading the code.

Also in `list_to_biseq`, the branch `if ln>mp_bits_per_limb:` leaks `tmp`.



---

archive/issue_comments_200025.json:
```json
{
    "body": "<div id=\"comment:176\" align=\"right\">comment:176</div>\n\nReplying to [@jdemeyer](#comment:169):\n> Replying to [@simon-king-jena](#comment:164):\n> > On a different ticket?\n\n> It makes no sense to first introduce a new module on this ticket and then make a new ticket to immediately move that new module somewhere else\n\nExcept that the new ticket is not just about moving `sage.misc.bounded_integer_sequences` to `sage.data_structures.bounded_integer_sequences`, but moves a whole lot more.\n\nOn THIS ticket, it does not make sense to dooe the big move from `sage.misc` to `sage.data_structures`, since this ticket is about introducing bounded integer sequences",
    "created_at": "2014-10-21T16:03:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200025",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:176" align="right">comment:176</div>

Replying to [@jdemeyer](#comment:169):
> Replying to [@simon-king-jena](#comment:164):
> > On a different ticket?

> It makes no sense to first introduce a new module on this ticket and then make a new ticket to immediately move that new module somewhere else

Except that the new ticket is not just about moving `sage.misc.bounded_integer_sequences` to `sage.data_structures.bounded_integer_sequences`, but moves a whole lot more.

On THIS ticket, it does not make sense to dooe the big move from `sage.misc` to `sage.data_structures`, since this ticket is about introducing bounded integer sequences



---

archive/issue_comments_200026.json:
```json
{
    "body": "<div id=\"comment:177\" align=\"right\">comment:177</div>\n\nReplying to [@jdemeyer](#comment:169):\n> The problem with `src/sage/misc` is that it contains a lot of various things. Usually \"misc\" is used when something doesn't belong to any other category.\n\nYeah, and most of the time this is stuff that does not really belong to Sage in the first place, and should eventually be moved to upstream libraries. In some sense, it can be seen as a feature that it looks wrong there: it gives an incent for developpers to finally take on the task of actually moving the stuff upstream.",
    "created_at": "2014-10-21T16:10:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200026",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:177" align="right">comment:177</div>

Replying to [@jdemeyer](#comment:169):
> The problem with `src/sage/misc` is that it contains a lot of various things. Usually "misc" is used when something doesn't belong to any other category.

Yeah, and most of the time this is stuff that does not really belong to Sage in the first place, and should eventually be moved to upstream libraries. In some sense, it can be seen as a feature that it looks wrong there: it gives an incent for developpers to finally take on the task of actually moving the stuff upstream.



---

archive/issue_comments_200027.json:
```json
{
    "body": "<div id=\"comment:178\" align=\"right\">comment:178</div>\n\nReplying to [@jdemeyer](#comment:174):\n> Also: I think you use `int` in a lot of places where you really want a `long` or `mp_limb_t` or `mp_size_t` or `Py_ssize_t`.\n\nI tried to be consistent. However, I do not find documentation: What is the purpose of `mp_size_t` versus `mp_bitcnt_t`?",
    "created_at": "2014-10-21T16:11:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200027",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:178" align="right">comment:178</div>

Replying to [@jdemeyer](#comment:174):
> Also: I think you use `int` in a lot of places where you really want a `long` or `mp_limb_t` or `mp_size_t` or `Py_ssize_t`.

I tried to be consistent. However, I do not find documentation: What is the purpose of `mp_size_t` versus `mp_bitcnt_t`?



---

archive/issue_comments_200028.json:
```json
{
    "body": "<div id=\"comment:179\" align=\"right\">comment:179</div>\n\nReplying to [@simon-king-jena](#comment:176):\n> On THIS ticket, it does not make sense to do the big move from `sage.misc` to `sage.data_structures`\n\nOf course not. But I meant to add the new module `bounded_integer_sequences` to `sage.data_structures` (the result being that this would be the only module inside `sage.data_structures`). Putting it in the correct place immediately is better than first putting it somewhere else and then moving it.",
    "created_at": "2014-10-21T16:11:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200028",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:179" align="right">comment:179</div>

Replying to [@simon-king-jena](#comment:176):
> On THIS ticket, it does not make sense to do the big move from `sage.misc` to `sage.data_structures`

Of course not. But I meant to add the new module `bounded_integer_sequences` to `sage.data_structures` (the result being that this would be the only module inside `sage.data_structures`). Putting it in the correct place immediately is better than first putting it somewhere else and then moving it.



---

archive/issue_comments_200029.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nStrangely, in gmp.h, I see that `mp_size_t` is `long long int`, hence, it is a *signed* type, in contrast to Python's `size_t`.",
    "created_at": "2014-10-21T16:14:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200029",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:0" align="right">comment:0</div>

Strangely, in gmp.h, I see that `mp_size_t` is `long long int`, hence, it is a *signed* type, in contrast to Python's `size_t`.



---

archive/issue_comments_200030.json:
```json
{
    "body": "<div id=\"comment:181\" align=\"right\">comment:181</div>\n\nReplying to [@jdemeyer](#comment:179):\n> Replying to [@simon-king-jena](#comment:176):\n> > On THIS ticket, it does not make sense to do the big move from `sage.misc` to `sage.data_structures`\n\n> Of course not. But I meant to add the new module `bounded_integer_sequences` to `sage.data_structures` (the result being that this would be the only module inside `sage.data_structures`).\n\nOK. This I could do.",
    "created_at": "2014-10-21T16:15:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200030",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:181" align="right">comment:181</div>

Replying to [@jdemeyer](#comment:179):
> Replying to [@simon-king-jena](#comment:176):
> > On THIS ticket, it does not make sense to do the big move from `sage.misc` to `sage.data_structures`

> Of course not. But I meant to add the new module `bounded_integer_sequences` to `sage.data_structures` (the result being that this would be the only module inside `sage.data_structures`).

OK. This I could do.



---

archive/issue_comments_200031.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nReplying to [@jdemeyer](#comment:174):\n> I tried to be consistent.\n\nThe problem is that `mp_bits_per_limb` is about the number of bits in `mp_limb_t`, not the number of bits in `int`. And using `int` for indices is inconsistent with Python which uses `Py_ssize_t` (which should be the same as `mp_size_t`).",
    "created_at": "2014-10-21T16:16:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200031",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:2" align="right">comment:2</div>

Replying to [@jdemeyer](#comment:174):
> I tried to be consistent.

The problem is that `mp_bits_per_limb` is about the number of bits in `mp_limb_t`, not the number of bits in `int`. And using `int` for indices is inconsistent with Python which uses `Py_ssize_t` (which should be the same as `mp_size_t`).



---

archive/issue_comments_200032.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI would say: use `mp_size_t` for indices, `mp_limb_t` for the actual integers inside your sequences.",
    "created_at": "2014-10-21T16:19:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200032",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:3" align="right">comment:3</div>

I would say: use `mp_size_t` for indices, `mp_limb_t` for the actual integers inside your sequences.



---

archive/issue_comments_200033.json:
```json
{
    "body": "<div id=\"comment:184\" align=\"right\">comment:184</div>\n\nReplying to [@jdemeyer](#comment:182):\n> Replying to [@jdemeyer](#comment:174):\n> > I tried to be consistent.\n\n> The problem is that `mp_bits_per_limb` is about the number of bits in `mp_limb_t`, not the number of bits in `int`. And using `int` for indices is inconsistent with Python which uses `Py_ssize_t` (which should be the same as `mp_size_t`).\n\nOK. So, I should use `mp_size_t` for indices. But what should I use `mp_bitcnt_t` for?",
    "created_at": "2014-10-21T16:21:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200033",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:184" align="right">comment:184</div>

Replying to [@jdemeyer](#comment:182):
> Replying to [@jdemeyer](#comment:174):
> > I tried to be consistent.

> The problem is that `mp_bits_per_limb` is about the number of bits in `mp_limb_t`, not the number of bits in `int`. And using `int` for indices is inconsistent with Python which uses `Py_ssize_t` (which should be the same as `mp_size_t`).

OK. So, I should use `mp_size_t` for indices. But what should I use `mp_bitcnt_t` for?



---

archive/issue_comments_200034.json:
```json
{
    "body": "<div id=\"comment:185\" align=\"right\">comment:185</div>\n\nReplying to [@jdemeyer](#comment:183):\n> I would say: use `mp_size_t` for indices, `mp_limb_t` for the actual integers inside your sequences.\n\nIf I am not mistaken, I always use `mp_limb_t` for the limbs. If you find a spot where this is not the case, please tell me.",
    "created_at": "2014-10-21T16:23:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200034",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:185" align="right">comment:185</div>

Replying to [@jdemeyer](#comment:183):
> I would say: use `mp_size_t` for indices, `mp_limb_t` for the actual integers inside your sequences.

If I am not mistaken, I always use `mp_limb_t` for the limbs. If you find a spot where this is not the case, please tell me.



---

archive/issue_comments_200035.json:
```json
{
    "body": "<div id=\"comment:186\" align=\"right\">comment:186</div>\n\nReplying to [@simon-king-jena](#comment:184):\n> But what should I use `mp_bitcnt_t` for?\n\nAny time you need a count of bits (which is always positive!)...",
    "created_at": "2014-10-21T16:24:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200035",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:186" align="right">comment:186</div>

Replying to [@simon-king-jena](#comment:184):
> But what should I use `mp_bitcnt_t` for?

Any time you need a count of bits (which is always positive!)...



---

archive/issue_comments_200036.json:
```json
{
    "body": "<div id=\"comment:187\" align=\"right\">comment:187</div>\n\nReplying to [@simon-king-jena](#comment:185):\n> If you find a spot where this is not the case, please tell me.\n\n\n```\ncdef int biseq_getitem(biseq_t S, mp_size_t index) except -1\n     ^^^\n```",
    "created_at": "2014-10-21T16:25:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200036",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:187" align="right">comment:187</div>

Replying to [@simon-king-jena](#comment:185):
> If you find a spot where this is not the case, please tell me.


```
cdef int biseq_getitem(biseq_t S, mp_size_t index) except -1
     ^^^
```



---

archive/issue_comments_200037.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nI would say: when in doubt between `mp_size_t` and `mp_bitcnt_t`, use `mp_size_t`.\n\nWhen in doubt between `int` and anything else: use the anything else.",
    "created_at": "2014-10-21T16:27:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200037",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:8" align="right">comment:8</div>

I would say: when in doubt between `mp_size_t` and `mp_bitcnt_t`, use `mp_size_t`.

When in doubt between `int` and anything else: use the anything else.



---

archive/issue_comments_200038.json:
```json
{
    "body": "<div id=\"comment:189\" align=\"right\">comment:189</div>\n\nReplying to [@jdemeyer](#comment:186):\n> Replying to [@simon-king-jena](#comment:184):\n> > But what should I use `mp_bitcnt_t` for?\n\n> Any time you need a count of bits (which is always positive!)...\n\nYou mean, in particular, that I should *not* use it for an index? Hence, if I want to refer to bit number `b` in limb number `l`, then both `b` and `l` should be `mp_size_t`? Currently, I try to consistently use `mp_bitcnt_t` for `b` and `mp_size_t` for `l`.",
    "created_at": "2014-10-21T16:33:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200038",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:189" align="right">comment:189</div>

Replying to [@jdemeyer](#comment:186):
> Replying to [@simon-king-jena](#comment:184):
> > But what should I use `mp_bitcnt_t` for?

> Any time you need a count of bits (which is always positive!)...

You mean, in particular, that I should *not* use it for an index? Hence, if I want to refer to bit number `b` in limb number `l`, then both `b` and `l` should be `mp_size_t`? Currently, I try to consistently use `mp_bitcnt_t` for `b` and `mp_size_t` for `l`.



---

archive/issue_comments_200039.json:
```json
{
    "body": "<div id=\"comment:190\" align=\"right\">comment:190</div>\n\nReplying to [@jdemeyer](#comment:187):\n> Replying to [@simon-king-jena](#comment:185):\n> > If you find a spot where this is not the case, please tell me.\n\n> \n> ```\n> cdef int biseq_getitem(biseq_t S, mp_size_t index) except -1\n>      ^^^\n> ```\n\nRationale: This function does not return a limb, but only one item (and a limb may comprise many items). To keep them apart, I chose a different type. Moreover, I consider `mp_limb_t` as a type that belongs to gmp. But the return type of that function should belong to the \"Python world\".",
    "created_at": "2014-10-21T16:36:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200039",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:190" align="right">comment:190</div>

Replying to [@jdemeyer](#comment:187):
> Replying to [@simon-king-jena](#comment:185):
> > If you find a spot where this is not the case, please tell me.

> 
> ```
> cdef int biseq_getitem(biseq_t S, mp_size_t index) except -1
>      ^^^
> ```

Rationale: This function does not return a limb, but only one item (and a limb may comprise many items). To keep them apart, I chose a different type. Moreover, I consider `mp_limb_t` as a type that belongs to gmp. But the return type of that function should belong to the "Python world".



---

archive/issue_comments_200040.json:
```json
{
    "body": "<div id=\"comment:192\" align=\"right\">comment:192</div>\n\nReplying to [@simon-king-jena](#comment:190):\n> I consider `mp_limb_t` as a type that belongs to gmp. But the return type of that function should belong to the \"Python world\".\n\n`int` doesn't belong to the Python world either (don't confuse Cython `int` with Python `int`!)",
    "created_at": "2014-10-21T17:18:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200040",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:192" align="right">comment:192</div>

Replying to [@simon-king-jena](#comment:190):
> I consider `mp_limb_t` as a type that belongs to gmp. But the return type of that function should belong to the "Python world".

`int` doesn't belong to the Python world either (don't confuse Cython `int` with Python `int`!)



---

archive/issue_comments_200041.json:
```json
{
    "body": "<div id=\"comment:193\" align=\"right\">comment:193</div>\n\nReplying to [@simon-king-jena](#comment:189):\n> Replying to [@jdemeyer](#comment:186):\n> > Replying to [@simon-king-jena](#comment:184):\n> > > But what should I use `mp_bitcnt_t` for?\n\n> > Any time you need a count of bits (which is always positive!)...\n\n> \n> You mean, in particular, that I should *not* use it for an index? Hence, if I want to refer to bit number `b` in limb number `l`, then both `b` and `l` should be `mp_size_t`? Currently, I try to consistently use `mp_bitcnt_t` for `b` and `mp_size_t` for `l`.\n\nUsing `mp_bitcnt_t` for this is fine, when I said \"index\" I meant index like for Python `__getitem__`",
    "created_at": "2014-10-21T17:20:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200041",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:193" align="right">comment:193</div>

Replying to [@simon-king-jena](#comment:189):
> Replying to [@jdemeyer](#comment:186):
> > Replying to [@simon-king-jena](#comment:184):
> > > But what should I use `mp_bitcnt_t` for?

> > Any time you need a count of bits (which is always positive!)...

> 
> You mean, in particular, that I should *not* use it for an index? Hence, if I want to refer to bit number `b` in limb number `l`, then both `b` and `l` should be `mp_size_t`? Currently, I try to consistently use `mp_bitcnt_t` for `b` and `mp_size_t` for `l`.

Using `mp_bitcnt_t` for this is fine, when I said "index" I meant index like for Python `__getitem__`



---

archive/issue_comments_200042.json:
```json
{
    "body": "<div id=\"comment:194\" align=\"right\">comment:194</div>\n\nReplying to [@simon-king-jena](#comment:190):\n> To keep them apart, I chose a different type.\n\nIf that's the main motivation, define a new type:\n\n```\nctypedef mp_limb_t biseq_item_t\n```",
    "created_at": "2014-10-21T17:22:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200042",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:194" align="right">comment:194</div>

Replying to [@simon-king-jena](#comment:190):
> To keep them apart, I chose a different type.

If that's the main motivation, define a new type:

```
ctypedef mp_limb_t biseq_item_t
```



---

archive/issue_comments_200043.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nAlso, if `bound` is of type `mp_limb_t`, then the following check is not needed at all:\n\n```\nmpz_init_set_ui(tmp, bound-1)\nln = mpz_sizeinbase(tmp, 2)\nif ln>mp_bits_per_limb:\n    raise ValueError(\"The integer bound {} does not fit into {}\".format(bound, mp_bits_per_limb))\n```",
    "created_at": "2014-10-21T17:26:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200043",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:5" align="right">comment:5</div>

Also, if `bound` is of type `mp_limb_t`, then the following check is not needed at all:

```
mpz_init_set_ui(tmp, bound-1)
ln = mpz_sizeinbase(tmp, 2)
if ln>mp_bits_per_limb:
    raise ValueError("The integer bound {} does not fit into {}".format(bound, mp_bits_per_limb))
```



---

archive/issue_comments_200044.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nOne more reason for using \"int\" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.",
    "created_at": "2014-10-21T18:25:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200044",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

One more reason for using "int" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.



---

archive/issue_comments_200045.json:
```json
{
    "body": "<div id=\"comment:197\" align=\"right\">comment:197</div>\n\nReplying to [@simon-king-jena](#comment:196):\n> One more reason for using \"int\" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.\n\nThat's not one more reason to use `int`, it's one less reason to use `mp_limb_t`. With `mp_limb_signed_t` (which isn't declared but should be in `src/sage/libs/gmp/types.pxd`), you shouldn't have this problem.",
    "created_at": "2014-10-21T18:33:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200045",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:197" align="right">comment:197</div>

Replying to [@simon-king-jena](#comment:196):
> One more reason for using "int" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.

That's not one more reason to use `int`, it's one less reason to use `mp_limb_t`. With `mp_limb_signed_t` (which isn't declared but should be in `src/sage/libs/gmp/types.pxd`), you shouldn't have this problem.



---

archive/issue_comments_200046.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nBut with a better specification of the `biseq` struct (see [comment:171]) I might give a better recommendation about which types to use.",
    "created_at": "2014-10-21T18:39:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200046",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:8" align="right">comment:8</div>

But with a better specification of the `biseq` struct (see [comment:171]) I might give a better recommendation about which types to use.



---

archive/issue_comments_200047.json:
```json
{
    "body": "<div id=\"comment:199\" align=\"right\">comment:199</div>\n\nReplying to [@jdemeyer](#comment:197):\n> Replying to [@simon-king-jena](#comment:196):\n> > One more reason for using \"int\" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.\n\n> That's not one more reason to use `int`, it's one less reason to use `mp_limb_t`. With `mp_limb_signed_t` (which isn't declared but should be in `src/sage/libs/gmp/types.pxd`), you shouldn't have this problem.\n\nThere may be a problem with either `int` or `mp_limb_signed_t`: If the bound for the integer sequence is very large, then a single item would fill a whole `mp_limb_t`. However, this would not fit into a *signed* int/limb.\n\nSo, at the moment, it seems to me that `ctypedef mp_limb_t biseq_item_t` is preferred. Since the `__repr__` method is not time-critical, I suggest to do the transformation from `mp_limb_t` to a nicely printed type there. I would accept that `__getitem__` returns something that is not so nicely printed.",
    "created_at": "2014-10-21T19:39:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200047",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:199" align="right">comment:199</div>

Replying to [@jdemeyer](#comment:197):
> Replying to [@simon-king-jena](#comment:196):
> > One more reason for using "int" as return type: If I use `mp_limb_t`, then `6` is printed as `6L`.

> That's not one more reason to use `int`, it's one less reason to use `mp_limb_t`. With `mp_limb_signed_t` (which isn't declared but should be in `src/sage/libs/gmp/types.pxd`), you shouldn't have this problem.

There may be a problem with either `int` or `mp_limb_signed_t`: If the bound for the integer sequence is very large, then a single item would fill a whole `mp_limb_t`. However, this would not fit into a *signed* int/limb.

So, at the moment, it seems to me that `ctypedef mp_limb_t biseq_item_t` is preferred. Since the `__repr__` method is not time-critical, I suggest to do the transformation from `mp_limb_t` to a nicely printed type there. I would accept that `__getitem__` returns something that is not so nicely printed.



---

archive/issue_comments_200048.json:
```json
{
    "body": "Changed commit from **[`1f5a53e`](https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655)** to **[`ef69d1e`](https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86)**",
    "created_at": "2014-10-21T21:46:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200048",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`1f5a53e`](https://github.com/sagemath/sagetrac-mirror/commit/1f5a53e7b23e406c553d789f83604cd4a7f90655)** to **[`ef69d1e`](https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86)**



---

archive/issue_comments_200049.json:
```json
{
    "body": "<div id=\"comment:0\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86\"><code>ef69d1e</code></a></td><td><code>Create sage.data_structures, move biseq into it, and amend types in biseq</code></td></tr></table>\n",
    "created_at": "2014-10-21T21:46:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200049",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:0"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86"><code>ef69d1e</code></a></td><td><code>Create sage.data_structures, move biseq into it, and amend types in biseq</code></td></tr></table>




---

archive/issue_comments_200050.json:
```json
{
    "body": "<div id=\"comment:1\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5\"><code>83be138</code></a></td><td><code>Reword documentation of biseq_s</code></td></tr></table>\n",
    "created_at": "2014-10-21T21:51:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200050",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:1"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5"><code>83be138</code></a></td><td><code>Reword documentation of biseq_s</code></td></tr></table>




---

archive/issue_comments_200051.json:
```json
{
    "body": "Changed commit from **[`ef69d1e`](https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86)** to **[`83be138`](https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5)**",
    "created_at": "2014-10-21T21:51:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200051",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`ef69d1e`](https://github.com/sagemath/sagetrac-mirror/commit/ef69d1e6eb30a9551bb45d1e91f6180454d78b86)** to **[`83be138`](https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5)**



---

archive/issue_events_225929.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-21T22:17:21Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225929"
}
```



---

archive/issue_events_225930.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-21T22:17:21Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225930"
}
```



---

archive/issue_comments_200052.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nI hope my preceding comments do address your concerns, Jeroen. One more thing: Bitset has `cdef struct bitset_s` and `ctypedef bitset_s bitset_t[1]`. To be consistent with it, I changed `biseq` into `biseq_s`, so that I now have `cdef struct biseq_s` and `ctypedef biseq_s biseq_t[1]`.",
    "created_at": "2014-10-21T22:17:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200052",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

I hope my preceding comments do address your concerns, Jeroen. One more thing: Bitset has `cdef struct bitset_s` and `ctypedef bitset_s bitset_t[1]`. To be consistent with it, I changed `biseq` into `biseq_s`, so that I now have `cdef struct biseq_s` and `ctypedef biseq_s biseq_t[1]`.



---

archive/issue_comments_200053.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nIn the \"documentation\" of `biseq_s`, this sentence is still way too vague to be useful: `Use bitsets to store the data, which in turn is based on GMP integers`. Like: what is \"the data\" and how is it stored in the bitset?\n\nAnd it's not really true that bitset is based on GMP integers. It's just an array of limbs but we use GMP/MPIR `mpn_` functions for some manipulations.",
    "created_at": "2014-10-22T06:30:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200053",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:3" align="right">comment:3</div>

In the "documentation" of `biseq_s`, this sentence is still way too vague to be useful: `Use bitsets to store the data, which in turn is based on GMP integers`. Like: what is "the data" and how is it stored in the bitset?

And it's not really true that bitset is based on GMP integers. It's just an array of limbs but we use GMP/MPIR `mpn_` functions for some manipulations.



---

archive/issue_events_225931.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-22T06:30:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225931"
}
```



---

archive/issue_events_225932.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-22T06:30:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225932"
}
```



---

archive/issue_comments_200054.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nAre you using anything from NTL? If not, why the\n\n```\ninclude \"sage/libs/ntl/decl.pxi\"\n```",
    "created_at": "2014-10-22T06:41:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200054",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:5" align="right">comment:5</div>

Are you using anything from NTL? If not, why the

```
include "sage/libs/ntl/decl.pxi"
```



---

archive/issue_comments_200055.json:
```json
{
    "body": "Changed commit from **[`83be138`](https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5)** to **[`1fb819c`](https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21)**",
    "created_at": "2014-10-22T09:37:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200055",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`83be138`](https://github.com/sagemath/sagetrac-mirror/commit/83be138062f619a237e86650807c44b38eec94e5)** to **[`1fb819c`](https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21)**



---

archive/issue_comments_200056.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21\"><code>1fb819c</code></a></td><td><code>Remove a needless cimport, clarify documentation of biseq_s</code></td></tr></table>\n",
    "created_at": "2014-10-22T09:37:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200056",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:6"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21"><code>1fb819c</code></a></td><td><code>Remove a needless cimport, clarify documentation of biseq_s</code></td></tr></table>




---

archive/issue_events_225933.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-22T09:47:47Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225933"
}
```



---

archive/issue_events_225934.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-22T09:47:47Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225934"
}
```



---

archive/issue_comments_200057.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nThe import from ntl has indeed been useless.\n\nIs the description of `biseq_s` clear enough now?",
    "created_at": "2014-10-22T09:47:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200057",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

The import from ntl has indeed been useless.

Is the description of `biseq_s` clear enough now?



---

archive/issue_comments_200058.json:
```json
{
    "body": "<div id=\"comment:208\" align=\"right\">comment:208</div>\n\nReplying to [@simon-king-jena](#comment:207):\n> Is the description of `biseq_s` clear enough now?\n\nAdd that the items in the sequence are non-negative integers and that `itembitsize` is in `[1 .. GMP_LIMB_BITS]` (assuming both these statements are true).\n\nAnd I guess that `mask_item` equals `limb_lower_bits_up(itembitsize)`, where `limb_lower_bits_up` is the function defined in `src/sage/misc/bitset.pxi`.",
    "created_at": "2014-10-22T10:45:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200058",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:208" align="right">comment:208</div>

Replying to [@simon-king-jena](#comment:207):
> Is the description of `biseq_s` clear enough now?

Add that the items in the sequence are non-negative integers and that `itembitsize` is in `[1 .. GMP_LIMB_BITS]` (assuming both these statements are true).

And I guess that `mask_item` equals `limb_lower_bits_up(itembitsize)`, where `limb_lower_bits_up` is the function defined in `src/sage/misc/bitset.pxi`.



---

archive/issue_comments_200059.json:
```json
{
    "body": "<div id=\"comment:9\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827\"><code>e166d38</code></a></td><td><code>Further clarification of biseq_s doc.</code></td></tr></table>\n",
    "created_at": "2014-10-22T11:28:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200059",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:9"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827"><code>e166d38</code></a></td><td><code>Further clarification of biseq_s doc.</code></td></tr></table>




---

archive/issue_comments_200060.json:
```json
{
    "body": "Changed commit from **[`1fb819c`](https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21)** to **[`e166d38`](https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827)**",
    "created_at": "2014-10-22T11:28:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200060",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`1fb819c`](https://github.com/sagemath/sagetrac-mirror/commit/1fb819cb133e2b94bfc9222585b8762ee5efad21)** to **[`e166d38`](https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827)**



---

archive/issue_comments_200061.json:
```json
{
    "body": "<div id=\"comment:210\" align=\"right\">comment:210</div>\n\nReplying to [@jdemeyer](#comment:208):\n> Replying to [@simon-king-jena](#comment:207):\n> > Is the description of `biseq_s` clear enough now?\n\n> Add that the items in the sequence are non-negative integers and that `itembitsize` is in `[1 .. GMP_LIMB_BITS]` (assuming both these statements are true).\n\nDone.\n\n> And I guess that `mask_item` equals `limb_lower_bits_up(itembitsize)`, where `limb_lower_bits_up` is the function defined in `src/sage/misc/bitset.pxi`.\n\nIt could be that you just spotted a bug (corner case). I define it as `((<mp_limb_t>1)<<itembitsize)-1`, which is `limb_lower_bits_down`. And that's to say: If the itembitsize is mp_bits_per_limb (which should be allowed), then the mask is 0, but it should be all bits 1.\n\nTrying to construct a test to see if it really is a bug...\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827\"><code>e166d38</code></a></td><td><code>Further clarification of biseq_s doc.</code></td></tr></table>\n",
    "created_at": "2014-10-22T11:38:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200061",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:210" align="right">comment:210</div>

Replying to [@jdemeyer](#comment:208):
> Replying to [@simon-king-jena](#comment:207):
> > Is the description of `biseq_s` clear enough now?

> Add that the items in the sequence are non-negative integers and that `itembitsize` is in `[1 .. GMP_LIMB_BITS]` (assuming both these statements are true).

Done.

> And I guess that `mask_item` equals `limb_lower_bits_up(itembitsize)`, where `limb_lower_bits_up` is the function defined in `src/sage/misc/bitset.pxi`.

It could be that you just spotted a bug (corner case). I define it as `((<mp_limb_t>1)<<itembitsize)-1`, which is `limb_lower_bits_down`. And that's to say: If the itembitsize is mp_bits_per_limb (which should be allowed), then the mask is 0, but it should be all bits 1.

Trying to construct a test to see if it really is a bug...

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827"><code>e166d38</code></a></td><td><code>Further clarification of biseq_s doc.</code></td></tr></table>




---

archive/issue_comments_200062.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nYes, it is a bug:\n\n```\nsage: B = BoundedIntegerSequence(2^32-1, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])\nsage: B\n<0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0>\n```\nThank you for spotting it!",
    "created_at": "2014-10-22T11:40:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200062",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

Yes, it is a bug:

```
sage: B = BoundedIntegerSequence(2^32-1, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])
sage: B
<0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0>
```
Thank you for spotting it!



---

archive/issue_comments_200063.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nHang on, I'm working on a reviewer patch.",
    "created_at": "2014-10-22T11:43:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200063",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:2" align="right">comment:2</div>

Hang on, I'm working on a reviewer patch.



---

archive/issue_comments_200064.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nQuestion: what is the reason that you allow a length of `0`, requiring lots of special cases in the code?\nI.e. why not replace\n\n```\n    if S.length:\n        if R.length:\n            bitset_realloc(R.data, S.data.size)\n        else:\n            bitset_init(R.data, S.data.size)\n        mpn_copyi(R.data.bits, S.data.bits, S.data.limbs)\n    elif R.length:\n        bitset_free(R.data)\n```\nby\n\n```\n    bitset_realloc(R.data, S.data.size)\n    mpn_copyi(R.data.bits, S.data.bits, S.data.limbs)\n```",
    "created_at": "2014-10-22T11:45:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200064",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:3" align="right">comment:3</div>

Question: what is the reason that you allow a length of `0`, requiring lots of special cases in the code?
I.e. why not replace

```
    if S.length:
        if R.length:
            bitset_realloc(R.data, S.data.size)
        else:
            bitset_init(R.data, S.data.size)
        mpn_copyi(R.data.bits, S.data.bits, S.data.limbs)
    elif R.length:
        bitset_free(R.data)
```
by

```
    bitset_realloc(R.data, S.data.size)
    mpn_copyi(R.data.bits, S.data.bits, S.data.limbs)
```



---

archive/issue_comments_200065.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nI see, bitset doesn't allow a length of 0. Perhaps this (artificial?) limitation on bitsets should be removed first...",
    "created_at": "2014-10-22T11:49:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200065",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:4" align="right">comment:4</div>

I see, bitset doesn't allow a length of 0. Perhaps this (artificial?) limitation on bitsets should be removed first...



---

archive/issue_comments_200066.json:
```json
{
    "body": "Changed commit from **[`e166d38`](https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827)** to **[`3d293b9`](https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797)**",
    "created_at": "2014-10-22T11:50:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200066",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`e166d38`](https://github.com/sagemath/sagetrac-mirror/commit/e166d38d8be72453d42325c5f6a73592ddeb3827)** to **[`3d293b9`](https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797)**



---

archive/issue_comments_200067.json:
```json
{
    "body": "<div id=\"comment:5\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797\"><code>3d293b9</code></a></td><td><code>Fixing a corner case</code></td></tr></table>\n",
    "created_at": "2014-10-22T11:50:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200067",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:5"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797"><code>3d293b9</code></a></td><td><code>Fixing a corner case</code></td></tr></table>




---

archive/issue_comments_200068.json:
```json
{
    "body": "<div id=\"comment:216\" align=\"right\">comment:216</div>\n\nReplying to [@jdemeyer](#comment:212):\n> Hang on, I'm working on a reviewer patch.\n\nSorry, I pushed already.",
    "created_at": "2014-10-22T11:50:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200068",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:216" align="right">comment:216</div>

Replying to [@jdemeyer](#comment:212):
> Hang on, I'm working on a reviewer patch.

Sorry, I pushed already.



---

archive/issue_comments_200069.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\n...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.",
    "created_at": "2014-10-22T11:51:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200069",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:7" align="right">comment:7</div>

...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.



---

archive/issue_comments_200070.json:
```json
{
    "body": "<div id=\"comment:218\" align=\"right\">comment:218</div>\n\nReplying to [@jdemeyer](#comment:214):\n> I see, bitset doesn't allow a length of 0.\n\nExactly. I do need bounded integer sequences of length zero, but then I can not initialise the corresponding bitset (since it is required to have positive length). Therefore the special cases.",
    "created_at": "2014-10-22T11:52:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200070",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:218" align="right">comment:218</div>

Replying to [@jdemeyer](#comment:214):
> I see, bitset doesn't allow a length of 0.

Exactly. I do need bounded integer sequences of length zero, but then I can not initialise the corresponding bitset (since it is required to have positive length). Therefore the special cases.



---

archive/issue_comments_200071.json:
```json
{
    "body": "<div id=\"comment:219\" align=\"right\">comment:219</div>\n\nReplying to [@simon-king-jena](#comment:216):\n> Sorry, I pushed already.\n\nNo problem, it's just a small fix. Can you leave the branch alone for a while now?",
    "created_at": "2014-10-22T11:52:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200071",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:219" align="right">comment:219</div>

Replying to [@simon-king-jena](#comment:216):
> Sorry, I pushed already.

No problem, it's just a small fix. Can you leave the branch alone for a while now?



---

archive/issue_events_225935.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-22T11:52:32Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225935"
}
```



---

archive/issue_events_225936.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-22T11:52:32Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225936"
}
```



---

archive/issue_comments_200072.json:
```json
{
    "body": "<div id=\"comment:220\" align=\"right\">comment:220</div>\n\nReplying to [@jdemeyer](#comment:217):\n> ...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.\n\nI am not sure if I want this, since in some cases (at least in my applications) I ask `self.data.size` for the bitlength of the sequence, and thus I would need other special cases there.",
    "created_at": "2014-10-22T11:53:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200072",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:220" align="right">comment:220</div>

Replying to [@jdemeyer](#comment:217):
> ...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.

I am not sure if I want this, since in some cases (at least in my applications) I ask `self.data.size` for the bitlength of the sequence, and thus I would need other special cases there.



---

archive/issue_comments_200073.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nOTOH, I just see that in theses cases (e.g., concatenation of biseq) I already have special cases for length 0. So, it would not be a loss to re-organise the special casing...",
    "created_at": "2014-10-22T11:57:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200073",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

OTOH, I just see that in theses cases (e.g., concatenation of biseq) I already have special cases for length 0. So, it would not be a loss to re-organise the special casing...



---

archive/issue_comments_200074.json:
```json
{
    "body": "<div id=\"comment:222\" align=\"right\">comment:222</div>\n\nReplying to [@simon-king-jena](#comment:220):\n> Replying to [@jdemeyer](#comment:217):\n> > ...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.\n\n> \n> I am not sure if I want this, since in some cases (at least in my applications) I ask `self.data.size` for the bitlength of the sequence, and thus I would need other special cases there.\n\nI would prefer not to assume that `data.size == length * itembitsize`. For example, it might turn out to be more efficient to store some extra bits (1 extra limb for example).",
    "created_at": "2014-10-22T12:07:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200074",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:222" align="right">comment:222</div>

Replying to [@simon-king-jena](#comment:220):
> Replying to [@jdemeyer](#comment:217):
> > ...or perhaps easier: when given a length of zero, just make the bitset have length 1 as special case.

> 
> I am not sure if I want this, since in some cases (at least in my applications) I ask `self.data.size` for the bitlength of the sequence, and thus I would need other special cases there.

I would prefer not to assume that `data.size == length * itembitsize`. For example, it might turn out to be more efficient to store some extra bits (1 extra limb for example).



---

archive/issue_comments_200075.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI will rename `list_to_biseq` -> `biseq_init_list` if you don't mind.",
    "created_at": "2014-10-22T12:10:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200075",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:3" align="right">comment:3</div>

I will rename `list_to_biseq` -> `biseq_init_list` if you don't mind.



---

archive/issue_comments_200076.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nI would also prefer to remove `biseq_copy` since it's a dangerous function: it assumes that the `biseq` has been allocated but it throws away the current contents.\n\nBetter to split this operation in two: changing `biseq_copy` to `biseq_init_copy` assuming it was not allocated. If you really want something like `biseq_copy`, just use `biseq_dealloc` and `biseq_init_copy`.",
    "created_at": "2014-10-22T12:13:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200076",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:4" align="right">comment:4</div>

I would also prefer to remove `biseq_copy` since it's a dangerous function: it assumes that the `biseq` has been allocated but it throws away the current contents.

Better to split this operation in two: changing `biseq_copy` to `biseq_init_copy` assuming it was not allocated. If you really want something like `biseq_copy`, just use `biseq_dealloc` and `biseq_init_copy`.



---

archive/issue_comments_200077.json:
```json
{
    "body": "Dependencies: **#17195**",
    "created_at": "2014-10-22T12:21:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200077",
    "user": "https://github.com/jdemeyer"
}
```

Dependencies: **#17195**



---

archive/issue_comments_200078.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nWhy should there be a dependency on cython upgrade?",
    "created_at": "2014-10-22T12:34:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200078",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

Why should there be a dependency on cython upgrade?



---

archive/issue_comments_200079.json:
```json
{
    "body": "Changed dependencies from **#17195** to **#17195, #17196**",
    "created_at": "2014-10-22T13:14:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200079",
    "user": "https://github.com/jdemeyer"
}
```

Changed dependencies from **#17195** to **#17195, #17196**



---

archive/issue_comments_200080.json:
```json
{
    "body": "<div id=\"comment:228\" align=\"right\">comment:228</div>\n\nReplying to [@simon-king-jena](#comment:226):\n> Why should there be a dependency on cython upgrade?\n\nOnly the newest Cython has declarations for the `PySlice` API, so you can use `PySlice_GetIndicesEx()` easily.",
    "created_at": "2014-10-22T13:16:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200080",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:228" align="right">comment:228</div>

Replying to [@simon-king-jena](#comment:226):
> Why should there be a dependency on cython upgrade?

Only the newest Cython has declarations for the `PySlice` API, so you can use `PySlice_GetIndicesEx()` easily.



---

archive/issue_comments_200081.json:
```json
{
    "body": "Changed dependencies from **#17195, #17196** to **#17195**",
    "created_at": "2014-10-22T13:18:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200081",
    "user": "https://github.com/simon-king-jena"
}
```

Changed dependencies from **#17195, #17196** to **#17195**



---

archive/issue_comments_200082.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nAs much as I know, I don't use the bitset functions for which there is a requirement of equality of size. Hence, I don't think #17196 is a dependency.",
    "created_at": "2014-10-22T13:18:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200082",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:9" align="right">comment:9</div>

As much as I know, I don't use the bitset functions for which there is a requirement of equality of size. Hence, I don't think #17196 is a dependency.



---

archive/issue_comments_200083.json:
```json
{
    "body": "<div id=\"comment:230\" align=\"right\">comment:230</div>\n\nReplying to [@simon-king-jena](#comment:229):\n> As much as I know, I don't use the bitset functions for which there is a requirement of equality of size.\n\nYes, you don't use them but you *should* use those functions. It will simplify a lot of things.",
    "created_at": "2014-10-22T13:21:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200083",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:230" align="right">comment:230</div>

Replying to [@simon-king-jena](#comment:229):
> As much as I know, I don't use the bitset functions for which there is a requirement of equality of size.

Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.



---

archive/issue_comments_200084.json:
```json
{
    "body": "<div id=\"comment:231\" align=\"right\">comment:231</div>\n\nReplying to [@jdemeyer](#comment:230):\n> Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.\n\nFor example, `biseq_concat` is broken in the case where `(S1.data.size)%mp_bits_per_limb + (S2.data.size)%mp_bits_per_limb > mp_bits_per_limb`.",
    "created_at": "2014-10-22T13:59:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200084",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:231" align="right">comment:231</div>

Replying to [@jdemeyer](#comment:230):
> Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.

For example, `biseq_concat` is broken in the case where `(S1.data.size)%mp_bits_per_limb + (S2.data.size)%mp_bits_per_limb > mp_bits_per_limb`.



---

archive/issue_comments_200085.json:
```json
{
    "body": "<div id=\"comment:232\" align=\"right\">comment:232</div>\n\nReplying to [@jdemeyer](#comment:231):\n> Replying to [@jdemeyer](#comment:230):\n> > Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.\n\n> For example, `biseq_concat` is broken in the case where `(S1.data.size)%mp_bits_per_limb + (S2.data.size)%mp_bits_per_limb > mp_bits_per_limb`.\n\nReally? OK, I'll try to find an example that exposes the problem.",
    "created_at": "2014-10-22T14:02:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200085",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:232" align="right">comment:232</div>

Replying to [@jdemeyer](#comment:231):
> Replying to [@jdemeyer](#comment:230):
> > Yes, you don't use them but you *should* use those functions. It will simplify a lot of things.

> For example, `biseq_concat` is broken in the case where `(S1.data.size)%mp_bits_per_limb + (S2.data.size)%mp_bits_per_limb > mp_bits_per_limb`.

Really? OK, I'll try to find an example that exposes the problem.



---

archive/issue_comments_200086.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\n\n```\nsage: B = BoundedIntegerSequence(2^30-1, [1])\nsage: B\n<1>\nsage: B+B\n<1, 1>\n```\nWhere's the problem?",
    "created_at": "2014-10-22T14:04:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200086",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>


```
sage: B = BoundedIntegerSequence(2^30-1, [1])
sage: B
<1>
sage: B+B
<1, 1>
```
Where's the problem?



---

archive/issue_comments_200087.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nCould you try again with a larger value of `1`?",
    "created_at": "2014-10-22T14:06:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200087",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:4" align="right">comment:4</div>

Could you try again with a larger value of `1`?



---

archive/issue_comments_200088.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nHere it is:\n\n```\nsage: B = BoundedIntegerSequence(2^30-1, [2^30-1])\nsage: B\n<1073741823>\nsage: B+B\n<1073741823, 3>\n```\nOK, this requires a fix.",
    "created_at": "2014-10-22T14:08:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200088",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:5" align="right">comment:5</div>

Here it is:

```
sage: B = BoundedIntegerSequence(2^30-1, [2^30-1])
sage: B
<1073741823>
sage: B+B
<1073741823, 3>
```
OK, this requires a fix.



---

archive/issue_comments_200089.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nDo I understand correctly: At #17196, shift and comparison operations should be introduced that behave well wrt bitsizes, and then these operations should replace the mpn_... that I am using here.",
    "created_at": "2014-10-22T14:13:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200089",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

Do I understand correctly: At #17196, shift and comparison operations should be introduced that behave well wrt bitsizes, and then these operations should replace the mpn_... that I am using here.



---

archive/issue_comments_200090.json:
```json
{
    "body": "<div id=\"comment:237\" align=\"right\">comment:237</div>\n\nReplying to [@simon-king-jena](#comment:236):\n> Do I understand correctly: At #17196, shift and comparison operations should be introduced that behave well wrt bitsizes, and then these operations should replace the mpn_... that I am using here.\n\nYes.",
    "created_at": "2014-10-22T14:14:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200090",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:237" align="right">comment:237</div>

Replying to [@simon-king-jena](#comment:236):
> Do I understand correctly: At #17196, shift and comparison operations should be introduced that behave well wrt bitsizes, and then these operations should replace the mpn_... that I am using here.

Yes.



---

archive/issue_comments_200091.json:
```json
{
    "body": "Changed dependencies from **#17195** to **#17195, #17196**",
    "created_at": "2014-10-22T14:14:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200091",
    "user": "https://github.com/jdemeyer"
}
```

Changed dependencies from **#17195** to **#17195, #17196**



---

archive/issue_comments_200092.json:
```json
{
    "body": "Changed branch from **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)** to **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)**",
    "created_at": "2014-10-22T15:07:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200092",
    "user": "https://github.com/jdemeyer"
}
```

Changed branch from **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)** to **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)**



---

archive/issue_comments_200093.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nIn `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be a feature?\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8c69daf5a4cdbb08f39ca577c9c02bfe483969b9\"><code>8c69daf</code></a></td><td><code>Upgrade Cython to 0.21.1</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8\"><code>88e5eca</code></a></td><td><code>Merge branch 'ticket/17195' into ticket/15820</code></td></tr></table>\n",
    "created_at": "2014-10-22T16:07:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200093",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:9" align="right">comment:9</div>

In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be a feature?

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8c69daf5a4cdbb08f39ca577c9c02bfe483969b9"><code>8c69daf</code></a></td><td><code>Upgrade Cython to 0.21.1</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8"><code>88e5eca</code></a></td><td><code>Merge branch 'ticket/17195' into ticket/15820</code></td></tr></table>




---

archive/issue_comments_200094.json:
```json
{
    "body": "Changed commit from **[`3d293b9`](https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797)** to **[`88e5eca`](https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8)**",
    "created_at": "2014-10-22T16:07:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200094",
    "user": "https://github.com/jdemeyer"
}
```

Changed commit from **[`3d293b9`](https://github.com/sagemath/sagetrac-mirror/commit/3d293b96fa5a584684efbaae8fe667b885618797)** to **[`88e5eca`](https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8)**



---

archive/issue_comments_200095.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nLast commit is totally work in progress.",
    "created_at": "2014-10-22T16:09:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200095",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:0" align="right">comment:0</div>

Last commit is totally work in progress.



---

archive/issue_comments_200096.json:
```json
{
    "body": "Changed commit from **[`88e5eca`](https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8)** to **[`ab2f0c2`](https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625)**",
    "created_at": "2014-10-22T16:10:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200096",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`88e5eca`](https://github.com/sagemath/sagetrac-mirror/commit/88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8)** to **[`ab2f0c2`](https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625)**



---

archive/issue_comments_200097.json:
```json
{
    "body": "<div id=\"comment:1\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625\"><code>ab2f0c2</code></a></td><td><code>Various reviewer fixes</code></td></tr></table>\n",
    "created_at": "2014-10-22T16:10:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200097",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:1"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625"><code>ab2f0c2</code></a></td><td><code>Various reviewer fixes</code></td></tr></table>




---

archive/issue_comments_200098.json:
```json
{
    "body": "<div id=\"comment:2\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625\"><code>ab2f0c2</code></a></td><td><code>Various reviewer fixes</code></td></tr></table>\n",
    "created_at": "2014-10-22T16:10:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200098",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:2"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625"><code>ab2f0c2</code></a></td><td><code>Various reviewer fixes</code></td></tr></table>




---

archive/issue_comments_200099.json:
```json
{
    "body": "<div id=\"comment:3\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/83f8a5648815d7c25eb0c9f9b4bdaf04dd90335e\"><code>83f8a56</code></a></td><td><code>Relax assumptions for bitset functions</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3ae75a1f8fcfee0f78faf9bb4bb006149b535c45\"><code>3ae75a1</code></a></td><td><code>Move bitset to sage.data_structures</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7a955118f13e91ca6829b9da06172873f13f5b0b\"><code>7a95511</code></a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a\"><code>815a40d</code></a></td><td><code>Various reviewer fixes</code></td></tr></table>\n",
    "created_at": "2014-10-23T07:23:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200099",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:3"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/83f8a5648815d7c25eb0c9f9b4bdaf04dd90335e"><code>83f8a56</code></a></td><td><code>Relax assumptions for bitset functions</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3ae75a1f8fcfee0f78faf9bb4bb006149b535c45"><code>3ae75a1</code></a></td><td><code>Move bitset to sage.data_structures</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7a955118f13e91ca6829b9da06172873f13f5b0b"><code>7a95511</code></a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a"><code>815a40d</code></a></td><td><code>Various reviewer fixes</code></td></tr></table>




---

archive/issue_comments_200100.json:
```json
{
    "body": "Changed commit from **[`ab2f0c2`](https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625)** to **[`815a40d`](https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a)**",
    "created_at": "2014-10-23T07:23:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200100",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`ab2f0c2`](https://github.com/sagemath/sagetrac-mirror/commit/ab2f0c2bf3b68e4e979650f5554d529e5b7ea625)** to **[`815a40d`](https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a)**



---

archive/issue_comments_200101.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nWhat exactly does cython.overflowcheck do? Check whether the given arguments fit into the prescribed data types without truncation?",
    "created_at": "2014-10-23T08:01:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200101",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

What exactly does cython.overflowcheck do? Check whether the given arguments fit into the prescribed data types without truncation?



---

archive/issue_comments_200102.json:
```json
{
    "body": "<div id=\"comment:245\" align=\"right\">comment:245</div>\n\nReplying to [@simon-king-jena](#comment:244):\n> What exactly does cython.overflowcheck do?\n\nSee [http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html): for this application, it checks that the multiplication `totalbitsize = l * itemsize` doesn't overflow.",
    "created_at": "2014-10-23T08:10:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200102",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:245" align="right">comment:245</div>

Replying to [@simon-king-jena](#comment:244):
> What exactly does cython.overflowcheck do?

See [http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html): for this application, it checks that the multiplication `totalbitsize = l * itemsize` doesn't overflow.



---

archive/issue_comments_200103.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d\"><code>8d16a61</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-10-23T08:18:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200103",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:6"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d"><code>8d16a61</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_200104.json:
```json
{
    "body": "Changed commit from **[`815a40d`](https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a)** to **[`8d16a61`](https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d)**",
    "created_at": "2014-10-23T08:18:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200104",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`815a40d`](https://github.com/sagemath/sagetrac-mirror/commit/815a40d9a2939ebe6e3e127847c04a8c5d7eaf9a)** to **[`8d16a61`](https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d)**



---

archive/issue_comments_200105.json:
```json
{
    "body": "Changed commit from **[`8d16a61`](https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d)** to **[`8d59d14`](https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b)**",
    "created_at": "2014-10-23T08:51:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200105",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`8d16a61`](https://github.com/sagemath/sagetrac-mirror/commit/8d16a61d2874a38e10233cdf434db3854bd5ee0d)** to **[`8d59d14`](https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b)**



---

archive/issue_comments_200106.json:
```json
{
    "body": "<div id=\"comment:7\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b\"><code>8d59d14</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-10-23T08:51:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200106",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:7"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b"><code>8d59d14</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_200107.json:
```json
{
    "body": "Changed author from **Simon King** to **Simon King, Jeroen Demeyer**",
    "created_at": "2014-10-23T09:24:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200107",
    "user": "https://github.com/jdemeyer"
}
```

Changed author from **Simon King** to **Simon King, Jeroen Demeyer**



---

archive/issue_comments_200108.json:
```json
{
    "body": "<div id=\"comment:249\" align=\"right\">comment:249</div>\n\nReplying to [@jdemeyer](#comment:245):\n> Replying to [@simon-king-jena](#comment:244):\n> > What exactly does cython.overflowcheck do?\n\n> See [http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html): for this application, it checks that the multiplication `totalbitsize = l * itemsize` doesn't overflow.\n\nAha! So, it does not just check an overflow of the arguments, but it checks overflows happening in the innards of the function. Cool!",
    "created_at": "2014-10-23T10:01:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200108",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:249" align="right">comment:249</div>

Replying to [@jdemeyer](#comment:245):
> Replying to [@simon-king-jena](#comment:244):
> > What exactly does cython.overflowcheck do?

> See [http://docs.cython.org/src/reference/compilation.html](http://docs.cython.org/src/reference/compilation.html): for this application, it checks that the multiplication `totalbitsize = l * itemsize` doesn't overflow.

Aha! So, it does not just check an overflow of the arguments, but it checks overflows happening in the innards of the function. Cool!



---

archive/issue_comments_200109.json:
```json
{
    "body": "Changed commit from **[`8d59d14`](https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b)** to **[`d22c1ca`](https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1)**",
    "created_at": "2014-10-23T10:10:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200109",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`8d59d14`](https://github.com/sagemath/sagetrac-mirror/commit/8d59d141b7090fb6e5f6529b968e224ec0e5f73b)** to **[`d22c1ca`](https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1)**



---

archive/issue_comments_200110.json:
```json
{
    "body": "<div id=\"comment:0\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d\"><code>23762a3</code></a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610\"><code>4aafd2f</code></a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1\"><code>d22c1ca</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-10-23T10:10:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200110",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:0"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d"><code>23762a3</code></a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610"><code>4aafd2f</code></a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1"><code>d22c1ca</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_200111.json:
```json
{
    "body": "<div id=\"comment:251\" align=\"right\">comment:251</div>\n\nReplying to [@simon-king-jena](#comment:249):\n> So, it does not just check an overflow of the arguments\n\nIn fact, it does not check overflow of the arguments.\n\nOverflow checking of the arguments should happen in *calling* the function, not in the function itself.\n\nAlso note that Cython always does overflow checking when converting from Python types to C types, but not by default between C types.",
    "created_at": "2014-10-23T10:15:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200111",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:251" align="right">comment:251</div>

Replying to [@simon-king-jena](#comment:249):
> So, it does not just check an overflow of the arguments

In fact, it does not check overflow of the arguments.

Overflow checking of the arguments should happen in *calling* the function, not in the function itself.

Also note that Cython always does overflow checking when converting from Python types to C types, but not by default between C types.



---

archive/issue_comments_200112.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nIs sagemath.org down? I can not build your branch, since downloading the new cython package fails.\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d\"><code>23762a3</code></a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610\"><code>4aafd2f</code></a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1\"><code>d22c1ca</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d\"><code>23762a3</code></a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610\"><code>4aafd2f</code></a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1\"><code>d22c1ca</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-10-23T10:19:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200112",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

Is sagemath.org down? I can not build your branch, since downloading the new cython package fails.

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d"><code>23762a3</code></a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610"><code>4aafd2f</code></a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1"><code>d22c1ca</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/23762a31e383d765cbfe6d5bf958d5d592e1513d"><code>23762a3</code></a></td><td><code>Import data_structures into global namespace</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4aafd2f8ad2e86693b46735429bc7eb079e0e610"><code>4aafd2f</code></a></td><td><code>Merge branch 'ticket/17196' into HEAD</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1"><code>d22c1ca</code></a></td><td><code>Lots of fixes for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_200113.json:
```json
{
    "body": "<div id=\"comment:253\" align=\"right\">comment:253</div>\n\nReplying to [@simon-king-jena](#comment:252):\n> Is sagemath.org down? I can not build your branch, since downloading the new cython package fails.\n\nThe new Cython package isn't yet merged, so you have to manually follow the instructions at #17195 (don't forget the renaming!)",
    "created_at": "2014-10-23T10:22:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200113",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:253" align="right">comment:253</div>

Replying to [@simon-king-jena](#comment:252):
> Is sagemath.org down? I can not build your branch, since downloading the new cython package fails.

The new Cython package isn't yet merged, so you have to manually follow the instructions at #17195 (don't forget the renaming!)



---

archive/issue_comments_200114.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nMy intention for this ticket is to implement an additional function `biseq_setitem()` to set one item and then implement the `biseq` functions using either `biseq_getitem()/biseq_setitem()` or `bitset` functions. In cases where this cannot be done, add the required primitives and use those. The end result will hopefully be a lot less code without loss of efficiency.",
    "created_at": "2014-10-23T10:27:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200114",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:4" align="right">comment:4</div>

My intention for this ticket is to implement an additional function `biseq_setitem()` to set one item and then implement the `biseq` functions using either `biseq_getitem()/biseq_setitem()` or `bitset` functions. In cases where this cannot be done, add the required primitives and use those. The end result will hopefully be a lot less code without loss of efficiency.



---

archive/issue_comments_200115.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nIn case that you missed it, I am copying this question I asked before:\n\nIn `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?",
    "created_at": "2014-10-23T10:28:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200115",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:5" align="right">comment:5</div>

In case that you missed it, I am copying this question I asked before:

In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?



---

archive/issue_comments_200116.json:
```json
{
    "body": "<div id=\"comment:256\" align=\"right\">comment:256</div>\n\nReplying to [@jdemeyer](#comment:254):\n> My intention for this ticket is to implement an additional function `biseq_setitem()` to set one item and then implement the `biseq` functions using either `biseq_getitem()/biseq_setitem()` or `bitset` functions. In cases where this cannot be done, add the required primitives and use those. The end result will hopefully be a lot less code without loss of efficiency.\n\nAre you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?",
    "created_at": "2014-10-23T10:31:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200116",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:256" align="right">comment:256</div>

Replying to [@jdemeyer](#comment:254):
> My intention for this ticket is to implement an additional function `biseq_setitem()` to set one item and then implement the `biseq` functions using either `biseq_getitem()/biseq_setitem()` or `bitset` functions. In cases where this cannot be done, add the required primitives and use those. The end result will hopefully be a lot less code without loss of efficiency.

Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?



---

archive/issue_comments_200117.json:
```json
{
    "body": "<div id=\"comment:257\" align=\"right\">comment:257</div>\n\nReplying to [@simon-king-jena](#comment:256):\n> Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?\n\nI don't quite understand what you refer to. Which function do you think would become slower?",
    "created_at": "2014-10-23T10:35:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200117",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:257" align="right">comment:257</div>

Replying to [@simon-king-jena](#comment:256):
> Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?

I don't quite understand what you refer to. Which function do you think would become slower?



---

archive/issue_comments_200118.json:
```json
{
    "body": "<div id=\"comment:258\" align=\"right\">comment:258</div>\n\nReplying to [@jdemeyer](#comment:255):\n> In case that you missed it, I am copying this question I asked before:\n> \n> In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?\n\nWhat do you mean by \"randomly truncated\"? The given integers are replaced by their remainder modulo the \"mangled\" bound (i.e., the smallest power of two that is greater or equal the given bound). It is documented, and it isn't random.",
    "created_at": "2014-10-23T10:38:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200118",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:258" align="right">comment:258</div>

Replying to [@jdemeyer](#comment:255):
> In case that you missed it, I am copying this question I asked before:
> 
> In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?

What do you mean by "randomly truncated"? The given integers are replaced by their remainder modulo the "mangled" bound (i.e., the smallest power of two that is greater or equal the given bound). It is documented, and it isn't random.



---

archive/issue_comments_200119.json:
```json
{
    "body": "<div id=\"comment:259\" align=\"right\">comment:259</div>\n\nReplying to [@simon-king-jena](#comment:258):\n> Replying to [@jdemeyer](#comment:255):\n> > In case that you missed it, I am copying this question I asked before:\n> > \n> > In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?\n\n> \n> What do you mean by \"randomly truncated\"? The given integers are replaced by their remainder modulo the \"mangled\" bound (i.e., the smallest power of two that is greater or equal the given bound). It is documented, and it isn't random.\n\nOK, I didn't literally mean \"random\", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?",
    "created_at": "2014-10-23T10:42:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200119",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:259" align="right">comment:259</div>

Replying to [@simon-king-jena](#comment:258):
> Replying to [@jdemeyer](#comment:255):
> > In case that you missed it, I am copying this question I asked before:
> > 
> > In `biseq_init_list()`, the fact that the integers are randomly truncated seems like a bug to me. Is that supposed to be an intentional feature?

> 
> What do you mean by "randomly truncated"? The given integers are replaced by their remainder modulo the "mangled" bound (i.e., the smallest power of two that is greater or equal the given bound). It is documented, and it isn't random.

OK, I didn't literally mean "random", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?



---

archive/issue_comments_200120.json:
```json
{
    "body": "<div id=\"comment:260\" align=\"right\">comment:260</div>\n\nReplying to [@jdemeyer](#comment:257):\n> Replying to [@simon-king-jena](#comment:256):\n> > Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?\n\n> \n> I don't quite understand what you refer to. Which function do you think would become slower?\n\n`BoundedIntegerSequence.__iter__` and `biseq_to_list` would probably become\nslower. Currently, one limb is shifted with mpn_rshift, and then all items in\nthis limb are extracted by `>>` in this single limb, before mpn_rshifting the\nnext limb. If I understand correctly, you are planning to replace this by\n`biseq_getitem`, which means that you mpn_rshift a limb and extract the first\nitem of it, then mpn_rshift the same limb again for the second item.\n\nI suppose repeated use of mpn_rshift is slower than a single mpn_rshift\nfollowed by repeated single-limb-`>>`.",
    "created_at": "2014-10-23T10:43:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200120",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:260" align="right">comment:260</div>

Replying to [@jdemeyer](#comment:257):
> Replying to [@simon-king-jena](#comment:256):
> > Are you sure that, e.g., iteration will not be a lot slower when doing almost the same shift operation repeatedly for all items contained in a single limb?

> 
> I don't quite understand what you refer to. Which function do you think would become slower?

`BoundedIntegerSequence.__iter__` and `biseq_to_list` would probably become
slower. Currently, one limb is shifted with mpn_rshift, and then all items in
this limb are extracted by `>>` in this single limb, before mpn_rshifting the
next limb. If I understand correctly, you are planning to replace this by
`biseq_getitem`, which means that you mpn_rshift a limb and extract the first
item of it, then mpn_rshift the same limb again for the second item.

I suppose repeated use of mpn_rshift is slower than a single mpn_rshift
followed by repeated single-limb-`>>`.



---

archive/issue_comments_200121.json:
```json
{
    "body": "<div id=\"comment:261\" align=\"right\">comment:261</div>\n\nReplying to [@jdemeyer](#comment:259):\n> OK, I didn't literally mean \"random\", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?\n\nYou mean one should just raise an error? OK, that's another possibility.",
    "created_at": "2014-10-23T10:43:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200121",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:261" align="right">comment:261</div>

Replying to [@jdemeyer](#comment:259):
> OK, I didn't literally mean "random", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?

You mean one should just raise an error? OK, that's another possibility.



---

archive/issue_comments_200122.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nWhy did you introduce\n\n```\nassert S1.itembitsize == S2.itembitsize\n```\n?\n\nI think that generally it is not the job of boilerplate functions to do bound checking. If you want to do bound checking, then do so on the level of `BoundedIntegerSequence`, but not on the level of `biseq_t`.",
    "created_at": "2014-10-23T11:44:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200122",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

Why did you introduce

```
assert S1.itembitsize == S2.itembitsize
```
?

I think that generally it is not the job of boilerplate functions to do bound checking. If you want to do bound checking, then do so on the level of `BoundedIntegerSequence`, but not on the level of `biseq_t`.



---

archive/issue_comments_200123.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nPerhaps we should consider to change the hash function for bitsets (see the comments for the hash of bounded integer sequences that you removed). But I suppose this should not be done on this ticket.\n\nMy summary:\n- We have different functions that assume that the given sequences have equivalent bounds. In most cases, the assumption is not checked, with exception of the one assert that you introduced. I vote for removing the assert.\n- I don't think iteration should use `biseq_getitem` to extract items one by one. Instead, the current idea (\"shift enough data so that one limb is full and extract items from this single limb\") should be preserved.\n- I like your change to `biseq_getitem`, where you avoid using `mpn_rshift` for just one/two limbs. I think the same change could be done in `biseq_slice` in the case `step!=1`, and also in iteration.\n\nOther than that, your changes seem fine to me. I suggest to do the \"replacement of one/two limb shifts\", unless you beat me to it.",
    "created_at": "2014-10-23T12:05:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200123",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Perhaps we should consider to change the hash function for bitsets (see the comments for the hash of bounded integer sequences that you removed). But I suppose this should not be done on this ticket.

My summary:
- We have different functions that assume that the given sequences have equivalent bounds. In most cases, the assumption is not checked, with exception of the one assert that you introduced. I vote for removing the assert.
- I don't think iteration should use `biseq_getitem` to extract items one by one. Instead, the current idea ("shift enough data so that one limb is full and extract items from this single limb") should be preserved.
- I like your change to `biseq_getitem`, where you avoid using `mpn_rshift` for just one/two limbs. I think the same change could be done in `biseq_slice` in the case `step!=1`, and also in iteration.

Other than that, your changes seem fine to me. I suggest to do the "replacement of one/two limb shifts", unless you beat me to it.



---

archive/issue_comments_200124.json:
```json
{
    "body": "Reviewer: **Simon King**",
    "created_at": "2014-10-23T12:06:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200124",
    "user": "https://github.com/simon-king-jena"
}
```

Reviewer: **Simon King**



---

archive/issue_comments_200125.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nConcerning the assert: The only place in which `biseq_init_concat` is used does in fact check compatibility of bounds, and raises a `ValueError` if they are not compatible. Hence, the assert statement is redundant.",
    "created_at": "2014-10-23T12:09:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200125",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:5" align="right">comment:5</div>

Concerning the assert: The only place in which `biseq_init_concat` is used does in fact check compatibility of bounds, and raises a `ValueError` if they are not compatible. Hence, the assert statement is redundant.



---

archive/issue_comments_200126.json:
```json
{
    "body": "Changed branch from **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)** to **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)**",
    "created_at": "2014-10-23T12:50:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200126",
    "user": "https://github.com/simon-king-jena"
}
```

Changed branch from **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)** to **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)**



---

archive/issue_comments_200127.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nFrom my perspective, it is good to go...\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e\"><code>41c40cf</code></a></td><td><code>Don't use mpn_rshift for shifting two limbs</code></td></tr></table>\n",
    "created_at": "2014-10-23T12:51:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200127",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

From my perspective, it is good to go...

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e"><code>41c40cf</code></a></td><td><code>Don't use mpn_rshift for shifting two limbs</code></td></tr></table>




---

archive/issue_comments_200128.json:
```json
{
    "body": "Changed commit from **[`d22c1ca`](https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1)** to **[`41c40cf`](https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e)**",
    "created_at": "2014-10-23T12:51:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200128",
    "user": "https://github.com/simon-king-jena"
}
```

Changed commit from **[`d22c1ca`](https://github.com/sagemath/sagetrac-mirror/commit/d22c1ca23727402e376c7f772c2f51b8ed6af1f1)** to **[`41c40cf`](https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e)**



---

archive/issue_events_225937.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-23T12:51:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225937"
}
```



---

archive/issue_events_225938.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-23T12:51:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225938"
}
```



---

archive/issue_comments_200129.json:
```json
{
    "body": "<div id=\"comment:268\" align=\"right\">comment:268</div>\n\nReplying to [@simon-king-jena](#comment:263):\n> - We have different functions that assume that the given sequences have equivalent bounds. In most cases, the assumption is not checked, with exception of the one assert that you introduced. I vote for removing the assert.\n\nOK then, no problem.",
    "created_at": "2014-10-23T13:11:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200129",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:268" align="right">comment:268</div>

Replying to [@simon-king-jena](#comment:263):
> - We have different functions that assume that the given sequences have equivalent bounds. In most cases, the assumption is not checked, with exception of the one assert that you introduced. I vote for removing the assert.

OK then, no problem.



---

archive/issue_comments_200130.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nLet's do some benchmarks:\n\n1. With the latest commit:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(2, [1]*100000)\nsage: timeit('B.list()')\n625 loops, best of 3: 965 \u00b5s per loop\nsage: timeit('list(B)')\n125 loops, best of 3: 1.73 ms per loop\nsage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)\nsage: timeit('B.list()')\n625 loops, best of 3: 1.1 ms per loop\nsage: timeit('list(B)')\n125 loops, best of 3: 1.91 ms per loop\n```\n\n2. With 88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(2, [1]*100000)\nsage: timeit('B.list()')\n125 loops, best of 3: 3 ms per loop\nsage: timeit('list(B)')\n125 loops, best of 3: 3.87 ms per loop\nsage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)\nsage: timeit('B.list()')\n125 loops, best of 3: 3.68 ms per loop\nsage: timeit('list(B)')\n125 loops, best of 3: 4.47 ms per loop\n```",
    "created_at": "2014-10-23T13:25:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200130",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:9" align="right">comment:9</div>

Let's do some benchmarks:

1. With the latest commit:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(2, [1]*100000)
sage: timeit('B.list()')
625 loops, best of 3: 965 µs per loop
sage: timeit('list(B)')
125 loops, best of 3: 1.73 ms per loop
sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)
sage: timeit('B.list()')
625 loops, best of 3: 1.1 ms per loop
sage: timeit('list(B)')
125 loops, best of 3: 1.91 ms per loop
```

2. With 88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(2, [1]*100000)
sage: timeit('B.list()')
125 loops, best of 3: 3 ms per loop
sage: timeit('list(B)')
125 loops, best of 3: 3.87 ms per loop
sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)
sage: timeit('B.list()')
125 loops, best of 3: 3.68 ms per loop
sage: timeit('list(B)')
125 loops, best of 3: 4.47 ms per loop
```



---

archive/issue_comments_200131.json:
```json
{
    "body": "<div id=\"comment:270\" align=\"right\">comment:270</div>\n\nReplying to [@simon-king-jena](#comment:260):\n> `BoundedIntegerSequence.__iter__` and `biseq_to_list` would probably become\n> slower. Currently, one limb is shifted with mpn_rshift, and then all items in\n> this limb are extracted by `>>` in this single limb, before mpn_rshifting the\n> next limb. If I understand correctly, you are planning to replace this by\n> `biseq_getitem`, which means that you mpn_rshift a limb and extract the first\n> item of it, then mpn_rshift the same limb again for the second item.\n> \n> I suppose repeated use of mpn_rshift is slower than a single mpn_rshift\n> followed by repeated single-limb-`>>`.\n\nAs you can see, I implemented `biseq_getitem()` much faster than that, so I doubt there is still a slowdown for using repeated calls to `biseq_getitem()`.",
    "created_at": "2014-10-23T13:27:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200131",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:270" align="right">comment:270</div>

Replying to [@simon-king-jena](#comment:260):
> `BoundedIntegerSequence.__iter__` and `biseq_to_list` would probably become
> slower. Currently, one limb is shifted with mpn_rshift, and then all items in
> this limb are extracted by `>>` in this single limb, before mpn_rshifting the
> next limb. If I understand correctly, you are planning to replace this by
> `biseq_getitem`, which means that you mpn_rshift a limb and extract the first
> item of it, then mpn_rshift the same limb again for the second item.
> 
> I suppose repeated use of mpn_rshift is slower than a single mpn_rshift
> followed by repeated single-limb-`>>`.

As you can see, I implemented `biseq_getitem()` much faster than that, so I doubt there is still a slowdown for using repeated calls to `biseq_getitem()`.



---

archive/issue_comments_200132.json:
```json
{
    "body": "<div id=\"comment:271\" align=\"right\">comment:271</div>\n\nReplying to [@simon-king-jena](#comment:261):\n> Replying to [@jdemeyer](#comment:259):\n> > OK, I didn't literally mean \"random\", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?\n\n> \n> You mean one should just raise an error? OK, that's another possibility.\n\nYes, that is what I mean.",
    "created_at": "2014-10-23T13:28:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200132",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:271" align="right">comment:271</div>

Replying to [@simon-king-jena](#comment:261):
> Replying to [@jdemeyer](#comment:259):
> > OK, I didn't literally mean "random", maybe I meant strange and therefore unlikely to be useful. Do you have an application in mind?

> 
> You mean one should just raise an error? OK, that's another possibility.

Yes, that is what I mean.



---

archive/issue_comments_200133.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nI just notice that you removed `biseq_to_list`. Why? Is there no speed penalty for using iterator instead?",
    "created_at": "2014-10-23T13:34:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200133",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

I just notice that you removed `biseq_to_list`. Why? Is there no speed penalty for using iterator instead?



---

archive/issue_comments_200134.json:
```json
{
    "body": "<div id=\"comment:273\" align=\"right\">comment:273</div>\n\nReplying to [@simon-king-jena](#comment:272):\n> I just notice that you removed `biseq_to_list`.\n\nJust use `[biseq_getitem_py(self.data, i) for i in range(self.data.length)]`",
    "created_at": "2014-10-23T13:37:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200134",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:273" align="right">comment:273</div>

Replying to [@simon-king-jena](#comment:272):
> I just notice that you removed `biseq_to_list`.

Just use `[biseq_getitem_py(self.data, i) for i in range(self.data.length)]`



---

archive/issue_comments_200135.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nAlso, I think that `biseq_to_list` is something which belongs in the Python interface, not the C interface.",
    "created_at": "2014-10-23T13:37:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200135",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:4" align="right">comment:4</div>

Also, I think that `biseq_to_list` is something which belongs in the Python interface, not the C interface.



---

archive/issue_comments_200136.json:
```json
{
    "body": "<div id=\"comment:275\" align=\"right\">comment:275</div>\n\nI only see this comment after posting my previous comment.\n\nReplying to [@jdemeyer](#comment:269):\n> Let's do some benchmarks:\n> \n> 1. With the latest commit:\n> \n> ```\n> sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\n> sage: B = BoundedIntegerSequence(2, [1]*100000)\n> sage: timeit('B.list()')\n> 625 loops, best of 3: 965 \u00b5s per loop\n> sage: timeit('list(B)')\n> 125 loops, best of 3: 1.73 ms per loop\n> sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)\n> sage: timeit('B.list()')\n> 625 loops, best of 3: 1.1 ms per loop\n> sage: timeit('list(B)')\n> 125 loops, best of 3: 1.91 ms per loop\n> ```\n> \n> 2. With 88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8:\n> \n> ```\n> sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\n> sage: B = BoundedIntegerSequence(2, [1]*100000)\n> sage: timeit('B.list()')\n> 125 loops, best of 3: 3 ms per loop\n> sage: timeit('list(B)')\n> 125 loops, best of 3: 3.87 ms per loop\n> sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)\n> sage: timeit('B.list()')\n> 125 loops, best of 3: 3.68 ms per loop\n> sage: timeit('list(B)')\n> 125 loops, best of 3: 4.47 ms per loop\n> ```\n\nOK, excellent, then I think it is ok to drop biseq_to_list.",
    "created_at": "2014-10-23T13:48:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200136",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:275" align="right">comment:275</div>

I only see this comment after posting my previous comment.

Replying to [@jdemeyer](#comment:269):
> Let's do some benchmarks:
> 
> 1. With the latest commit:
> 
> ```
> sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
> sage: B = BoundedIntegerSequence(2, [1]*100000)
> sage: timeit('B.list()')
> 625 loops, best of 3: 965 µs per loop
> sage: timeit('list(B)')
> 125 loops, best of 3: 1.73 ms per loop
> sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)
> sage: timeit('B.list()')
> 625 loops, best of 3: 1.1 ms per loop
> sage: timeit('list(B)')
> 125 loops, best of 3: 1.91 ms per loop
> ```
> 
> 2. With 88e5ecaa30a54cfadbfe4fc1c0ee6d1840041ee8:
> 
> ```
> sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
> sage: B = BoundedIntegerSequence(2, [1]*100000)
> sage: timeit('B.list()')
> 125 loops, best of 3: 3 ms per loop
> sage: timeit('list(B)')
> 125 loops, best of 3: 3.87 ms per loop
> sage: B = BoundedIntegerSequence(sys.maxint, [1]*100000)
> sage: timeit('B.list()')
> 125 loops, best of 3: 3.68 ms per loop
> sage: timeit('list(B)')
> 125 loops, best of 3: 4.47 ms per loop
> ```

OK, excellent, then I think it is ok to drop biseq_to_list.



---

archive/issue_comments_200137.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nIf I understand correctly, the only remaining issue is whether we silently truncate the input, or raise an error if the given items are too large. I have no preference here, so, you may make it a reviewer patch.",
    "created_at": "2014-10-23T13:52:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200137",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

If I understand correctly, the only remaining issue is whether we silently truncate the input, or raise an error if the given items are too large. I have no preference here, so, you may make it a reviewer patch.



---

archive/issue_comments_200138.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nSigh. After merging this into #16453, I get several segmentation faults.",
    "created_at": "2014-10-23T13:58:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200138",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

Sigh. After merging this into #16453, I get several segmentation faults.



---

archive/issue_comments_200139.json:
```json
{
    "body": "<div id=\"comment:278\" align=\"right\">comment:278</div>\n\nReplying to [@simon-king-jena](#comment:277):\n> Sigh. After merging this into #16453, I get several segmentation faults.\n\nBut fortunately this ticket is not to blame for it `:-)`",
    "created_at": "2014-10-23T14:08:33Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200139",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:278" align="right">comment:278</div>

Replying to [@simon-king-jena](#comment:277):
> Sigh. After merging this into #16453, I get several segmentation faults.

But fortunately this ticket is not to blame for it `:-)`



---

archive/issue_comments_200140.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nI am going to leave this ticket alone for at least a few days.\n\nI do think there is still a lot of improvement, mainly simplification:\n1. Implement `biseq_setitem()` and use that in a lot of places.\n2. Implement `mpn_equal_bits_shifted()` to compare bit patterns efficiently for equality and use this for `biseq_max_overlap` and `biseq_contains`.",
    "created_at": "2014-10-23T14:20:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200140",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:9" align="right">comment:9</div>

I am going to leave this ticket alone for at least a few days.

I do think there is still a lot of improvement, mainly simplification:
1. Implement `biseq_setitem()` and use that in a lot of places.
2. Implement `mpn_equal_bits_shifted()` to compare bit patterns efficiently for equality and use this for `biseq_max_overlap` and `biseq_contains`.



---

archive/issue_comments_200141.json:
```json
{
    "body": "Changed branch from **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)** to **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)**",
    "created_at": "2014-10-23T14:22:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200141",
    "user": "https://github.com/jdemeyer"
}
```

Changed branch from **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)** to **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)**



---

archive/issue_comments_200142.json:
```json
{
    "body": "<div id=\"comment:1\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3\"><code>9056cf6</code></a></td><td><code>Fix handling of bound in biseq_init_list</code></td></tr></table>\n",
    "created_at": "2014-10-23T14:22:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200142",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:1"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3"><code>9056cf6</code></a></td><td><code>Fix handling of bound in biseq_init_list</code></td></tr></table>




---

archive/issue_comments_200143.json:
```json
{
    "body": "Changed commit from **[`41c40cf`](https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e)** to **[`9056cf6`](https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3)**",
    "created_at": "2014-10-23T14:22:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200143",
    "user": "https://github.com/jdemeyer"
}
```

Changed commit from **[`41c40cf`](https://github.com/sagemath/sagetrac-mirror/commit/41c40cf2c59734e7e665ba9c2350da2930c9cc8e)** to **[`9056cf6`](https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3)**



---

archive/issue_comments_200144.json:
```json
{
    "body": "<div id=\"comment:282\" align=\"right\">comment:282</div>\n\nReplying to [@jdemeyer](#comment:279):\n> 1. Implement `biseq_setitem()` and use that in a lot of places.\n\n`BoundedIntegerSequence` was (originally) thought of as being immutable (it is hashable). Hence, so far, I only see application in `biseq_init_list` and `biseq_slice`. OK, that's something...\n\n> 2. Implement `mpn_equal_bits_shifted()` to compare bit patterns efficiently for equality and use this for `biseq_max_overlap` and `biseq_contains`.\n\n+1.",
    "created_at": "2014-10-23T14:46:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200144",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:282" align="right">comment:282</div>

Replying to [@jdemeyer](#comment:279):
> 1. Implement `biseq_setitem()` and use that in a lot of places.

`BoundedIntegerSequence` was (originally) thought of as being immutable (it is hashable). Hence, so far, I only see application in `biseq_init_list` and `biseq_slice`. OK, that's something...

> 2. Implement `mpn_equal_bits_shifted()` to compare bit patterns efficiently for equality and use this for `biseq_max_overlap` and `biseq_contains`.

+1.



---

archive/issue_comments_200145.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nWould it be acceptable that `biseq_setitem(S,index,item)` assumes that `S[item]` is zero before the assignment? This condition holds in the two applications I can think of.\n\nOf course, I could additionally provide a function that sets a previously existing item to zero.",
    "created_at": "2014-10-23T15:14:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200145",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Would it be acceptable that `biseq_setitem(S,index,item)` assumes that `S[item]` is zero before the assignment? This condition holds in the two applications I can think of.

Of course, I could additionally provide a function that sets a previously existing item to zero.



---

archive/issue_comments_200146.json:
```json
{
    "body": "<div id=\"comment:284\" align=\"right\">comment:284</div>\n\nReplying to [@simon-king-jena](#comment:283):\n> Would it be acceptable that `biseq_setitem(S,index,item)` assumes that `S[item]` is zero before the assignment?\n\nThen I would call it `biseq_inititem(S, index, item)`.",
    "created_at": "2014-10-23T15:45:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200146",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:284" align="right">comment:284</div>

Replying to [@simon-king-jena](#comment:283):
> Would it be acceptable that `biseq_setitem(S,index,item)` assumes that `S[item]` is zero before the assignment?

Then I would call it `biseq_inititem(S, index, item)`.



---

archive/issue_comments_200147.json:
```json
{
    "body": "Changed branch from **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)** to **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)**",
    "created_at": "2014-10-23T17:47:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200147",
    "user": "https://github.com/simon-king-jena"
}
```

Changed branch from **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)** to **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)**



---

archive/issue_comments_200148.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nIt will be more efficient to declare `biseq_inititem` as `cdef inline void`.\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051\"><code>e9c779a</code></a></td><td><code>Simplify code by using biseq_getitem/biseq_inititem</code></td></tr></table>\n",
    "created_at": "2014-10-23T17:53:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200148",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:6" align="right">comment:6</div>

It will be more efficient to declare `biseq_inititem` as `cdef inline void`.

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051"><code>e9c779a</code></a></td><td><code>Simplify code by using biseq_getitem/biseq_inititem</code></td></tr></table>




---

archive/issue_comments_200149.json:
```json
{
    "body": "Changed commit from **[`9056cf6`](https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3)** to **[`e9c779a`](https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051)**",
    "created_at": "2014-10-23T17:53:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200149",
    "user": "https://github.com/jdemeyer"
}
```

Changed commit from **[`9056cf6`](https://github.com/sagemath/sagetrac-mirror/commit/9056cf636b65d30c5c89bc151c7740c1ea1143d3)** to **[`e9c779a`](https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051)**



---

archive/issue_comments_200150.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nConcerning `enumerate()`: I have no idea if Cython optimizes this. If not, you better just manually keep track of `index`.",
    "created_at": "2014-10-23T17:55:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200150",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:7" align="right">comment:7</div>

Concerning `enumerate()`: I have no idea if Cython optimizes this. If not, you better just manually keep track of `index`.



---

archive/issue_comments_200151.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nWhy did you change `if item_limb > bound` to `if item > bound`? The former is a C comparison, therefore faster.",
    "created_at": "2014-10-23T17:57:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200151",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:8" align="right">comment:8</div>

Why did you change `if item_limb > bound` to `if item > bound`? The former is a C comparison, therefore faster.



---

archive/issue_comments_200152.json:
```json
{
    "body": "<div id=\"comment:289\" align=\"right\">comment:289</div>\n\nReplying to [@jdemeyer](#comment:286):\n> It will be more efficient to declare `biseq_inititem` as `cdef inline void`.\n\nMore generally: if you have `cdef` or `cpdef` functions returning nothing and you don't require exception handling, then using `void` as return type is more efficient (without it, the functions return the Python value `None`).",
    "created_at": "2014-10-23T18:00:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200152",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:289" align="right">comment:289</div>

Replying to [@jdemeyer](#comment:286):
> It will be more efficient to declare `biseq_inititem` as `cdef inline void`.

More generally: if you have `cdef` or `cpdef` functions returning nothing and you don't require exception handling, then using `void` as return type is more efficient (without it, the functions return the Python value `None`).



---

archive/issue_comments_200153.json:
```json
{
    "body": "<div id=\"comment:290\" align=\"right\">comment:290</div>\n\nReplying to [@jdemeyer](#comment:288):\n> Why did you change `if item_limb > bound` to `if item > bound`? The former is a C comparison, therefore faster.\n\nSure. But you did `item_limb = item` without testing whether `item > bound`, which means that item_limb could end up *below* the bound. Hence, you'd have the random truncation that you wanted to avoid.",
    "created_at": "2014-10-23T18:00:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200153",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:290" align="right">comment:290</div>

Replying to [@jdemeyer](#comment:288):
> Why did you change `if item_limb > bound` to `if item > bound`? The former is a C comparison, therefore faster.

Sure. But you did `item_limb = item` without testing whether `item > bound`, which means that item_limb could end up *below* the bound. Hence, you'd have the random truncation that you wanted to avoid.



---

archive/issue_comments_200154.json:
```json
{
    "body": "<div id=\"comment:291\" align=\"right\">comment:291</div>\n\nReplying to [@simon-king-jena](#comment:290):\n> But you did `item_limb = item` without testing whether `item > bound`, which means that item_limb could end up *below* the bound.\n\nNot true because the assignment `item_limb = item` is a Python -> C conversion which is always checked:\n\n```\nsage: BoundedIntegerSequence(100, [2^256])\n---------------------------------------------------------------------------\nOverflowError                             Traceback (most recent call last)\n<ipython-input-6-ba7f864a5712> in <module>()\n----> 1 BoundedIntegerSequence(Integer(100), [Integer(2)**Integer(256)])\n\n/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.BoundedIntegerSequence.__init__ (build/cythonized/sage/data_structures/bounded_integer_sequences.c:7798)()\n\n/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.biseq_init_list (build/cythonized/sage/data_structures/bounded_integer_sequences.c:5706)()\n\nOverflowError: long int too large to convert\n```\n(perhaps add this as doctest)",
    "created_at": "2014-10-23T18:19:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200154",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:291" align="right">comment:291</div>

Replying to [@simon-king-jena](#comment:290):
> But you did `item_limb = item` without testing whether `item > bound`, which means that item_limb could end up *below* the bound.

Not true because the assignment `item_limb = item` is a Python -> C conversion which is always checked:

```
sage: BoundedIntegerSequence(100, [2^256])
---------------------------------------------------------------------------
OverflowError                             Traceback (most recent call last)
<ipython-input-6-ba7f864a5712> in <module>()
----> 1 BoundedIntegerSequence(Integer(100), [Integer(2)**Integer(256)])

/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.BoundedIntegerSequence.__init__ (build/cythonized/sage/data_structures/bounded_integer_sequences.c:7798)()

/usr/local/src/sage-config/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.biseq_init_list (build/cythonized/sage/data_structures/bounded_integer_sequences.c:5706)()

OverflowError: long int too large to convert
```
(perhaps add this as doctest)



---

archive/issue_comments_200155.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nI repeated the timings from commit:157, but still with the `item<=bound` test (so, initialisation time might improve).\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\n```\n\n```\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.45 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n100000 loops, best of 3: 2.1 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n100000 loops, best of 3: 4.28 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n1000 loops, best of 3: 300 \u00b5s per loop\n```\n--> Became much slower\n\n```\nsage: %timeit x = list(S0)\n1000000 loops, best of 3: 1.44 \u00b5s per loop\nsage: %timeit x = list(S1)\n100000 loops, best of 3: 2.18 \u00b5s per loop\nsage: %timeit x = list(S2)\n100000 loops, best of 3: 4.29 \u00b5s per loop\nsage: %timeit x = list(S3)\n1000 loops, best of 3: 286 \u00b5s per loop\nsage: %timeit x = S0.list()\n1000000 loops, best of 3: 697 ns per loop\nsage: %timeit x = S1.list()\n1000000 loops, best of 3: 1.2 \u00b5s per loop\nsage: %timeit x = S2.list()\n100000 loops, best of 3: 2.78 \u00b5s per loop\nsage: %timeit x = S3.list()\n10000 loops, best of 3: 135 \u00b5s per loop\n```\n--> not much conclusive\n\n```\nsage: timeit(\"x=S0[:-1]\", number=100000)\n100000 loops, best of 3: 815 ns per loop\nsage: timeit(\"x=S1[:-1]\", number=100000)\n100000 loops, best of 3: 846 ns per loop\nsage: timeit(\"x=S2[:-1]\", number=100000)\n100000 loops, best of 3: 845 ns per loop\nsage: timeit(\"x=S3[:-1]\", number=100000)\n100000 loops, best of 3: 1.62 \u00b5s per loop\nsage: timeit(\"x=S2[:-1:2]\", number=10000)\n10000 loops, best of 3: 1.55 \u00b5s per loop\nsage: timeit(\"x=S3[:-1:2]\", number=10000)\n10000 loops, best of 3: 49.8 \u00b5s per loop\n```\n--> Became *much* faster\n\n```\nsage: timeit(\"x=S0[1]\", number=1000000)\n1000000 loops, best of 3: 354 ns per loop\nsage: timeit(\"x=S0[4]\", number=1000000)\n1000000 loops, best of 3: 355 ns per loop\nsage: timeit(\"x=S3[1]\", number=1000000)\n1000000 loops, best of 3: 339 ns per loop\nsage: timeit(\"x=S3[4500]\", number=1000000)\n1000000 loops, best of 3: 346 ns per loop\n```\n--> Became perhaps slower.\n\nWhat does that all mean?\n\nFor my applications not very much, actually, because what I care about is not\ninitialisation from lists and direct item access and not slices with step\ndifferent from one, but I do care about:\n- Testing for subsequence containment, comparison and hash\n- Slicing with step one\n- Concatenation.\n\nSo, I leave it up to you whether clarity of code is more important than the\nabove slow-down...",
    "created_at": "2014-10-23T18:24:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200155",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

I repeated the timings from commit:157, but still with the `item<=bound` test (so, initialisation time might improve).

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
```

```
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.45 µs per loop
sage: %timeit x = BoundedIntegerSequence(16, L1)
100000 loops, best of 3: 2.1 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L2)
100000 loops, best of 3: 4.28 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L3)
1000 loops, best of 3: 300 µs per loop
```
--> Became much slower

```
sage: %timeit x = list(S0)
1000000 loops, best of 3: 1.44 µs per loop
sage: %timeit x = list(S1)
100000 loops, best of 3: 2.18 µs per loop
sage: %timeit x = list(S2)
100000 loops, best of 3: 4.29 µs per loop
sage: %timeit x = list(S3)
1000 loops, best of 3: 286 µs per loop
sage: %timeit x = S0.list()
1000000 loops, best of 3: 697 ns per loop
sage: %timeit x = S1.list()
1000000 loops, best of 3: 1.2 µs per loop
sage: %timeit x = S2.list()
100000 loops, best of 3: 2.78 µs per loop
sage: %timeit x = S3.list()
10000 loops, best of 3: 135 µs per loop
```
--> not much conclusive

```
sage: timeit("x=S0[:-1]", number=100000)
100000 loops, best of 3: 815 ns per loop
sage: timeit("x=S1[:-1]", number=100000)
100000 loops, best of 3: 846 ns per loop
sage: timeit("x=S2[:-1]", number=100000)
100000 loops, best of 3: 845 ns per loop
sage: timeit("x=S3[:-1]", number=100000)
100000 loops, best of 3: 1.62 µs per loop
sage: timeit("x=S2[:-1:2]", number=10000)
10000 loops, best of 3: 1.55 µs per loop
sage: timeit("x=S3[:-1:2]", number=10000)
10000 loops, best of 3: 49.8 µs per loop
```
--> Became *much* faster

```
sage: timeit("x=S0[1]", number=1000000)
1000000 loops, best of 3: 354 ns per loop
sage: timeit("x=S0[4]", number=1000000)
1000000 loops, best of 3: 355 ns per loop
sage: timeit("x=S3[1]", number=1000000)
1000000 loops, best of 3: 339 ns per loop
sage: timeit("x=S3[4500]", number=1000000)
1000000 loops, best of 3: 346 ns per loop
```
--> Became perhaps slower.

What does that all mean?

For my applications not very much, actually, because what I care about is not
initialisation from lists and direct item access and not slices with step
different from one, but I do care about:
- Testing for subsequence containment, comparison and hash
- Slicing with step one
- Concatenation.

So, I leave it up to you whether clarity of code is more important than the
above slow-down...



---

archive/issue_comments_200156.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nIf you do timings, please keep in mind [comment:286].",
    "created_at": "2014-10-23T18:31:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200156",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:3" align="right">comment:3</div>

If you do timings, please keep in mind [comment:286].



---

archive/issue_comments_200157.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nRight. When using `item_limb`, the timings for initialisation from lists become good:\n\n```\nsage: %timeit x = BoundedIntegerSequence(8, L0)\n1000000 loops, best of 3: 1.27 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(16, L1)\n1000000 loops, best of 3: 1.51 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L2)\n1000000 loops, best of 3: 1.88 \u00b5s per loop\nsage: %timeit x = BoundedIntegerSequence(32, L3)\n10000 loops, best of 3: 65.5 \u00b5s per loop\n```",
    "created_at": "2014-10-23T18:41:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200157",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

Right. When using `item_limb`, the timings for initialisation from lists become good:

```
sage: %timeit x = BoundedIntegerSequence(8, L0)
1000000 loops, best of 3: 1.27 µs per loop
sage: %timeit x = BoundedIntegerSequence(16, L1)
1000000 loops, best of 3: 1.51 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L2)
1000000 loops, best of 3: 1.88 µs per loop
sage: %timeit x = BoundedIntegerSequence(32, L3)
10000 loops, best of 3: 65.5 µs per loop
```



---

archive/issue_comments_200158.json:
```json
{
    "body": "<div id=\"comment:295\" align=\"right\">comment:295</div>\n\nReplying to [@jdemeyer](#comment:293):\n> If you do timings, please keep in mind [comment:286].\n\nThe timings are after using `inline void`.",
    "created_at": "2014-10-23T18:42:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200158",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:295" align="right">comment:295</div>

Replying to [@jdemeyer](#comment:293):
> If you do timings, please keep in mind [comment:286].

The timings are after using `inline void`.



---

archive/issue_comments_200159.json:
```json
{
    "body": "Changed commit from **[`e9c779a`](https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051)** to **[`7d25859`](https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c)**",
    "created_at": "2014-10-23T18:45:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200159",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`e9c779a`](https://github.com/sagemath/sagetrac-mirror/commit/e9c779ae629dbec356bb8546e3974e2a67050051)** to **[`7d25859`](https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c)**



---

archive/issue_comments_200160.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/acf2a7552bb19d3a9692c8f23a487c50f9e5b4d8\"><code>acf2a75</code></a></td><td><code>Declare some functions as 'cdef inline void'</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c\"><code>7d25859</code></a></td><td><code>Speed-up for testing bounds</code></td></tr></table>\n",
    "created_at": "2014-10-23T18:45:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200160",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:6"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/acf2a7552bb19d3a9692c8f23a487c50f9e5b4d8"><code>acf2a75</code></a></td><td><code>Declare some functions as 'cdef inline void'</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c"><code>7d25859</code></a></td><td><code>Speed-up for testing bounds</code></td></tr></table>




---

archive/issue_comments_200161.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nI know it's really a detail, but I intentionally used `repr(item)` to display the error message\n\n```\nraise ValueError(\"list item %r larger than %s\"%(item, bound) )\n```\n\nThis way, the error message refers to the list item as given by the user, which might be some strange Python type which prints differently.",
    "created_at": "2014-10-23T19:39:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200161",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:7" align="right">comment:7</div>

I know it's really a detail, but I intentionally used `repr(item)` to display the error message

```
raise ValueError("list item %r larger than %s"%(item, bound) )
```

This way, the error message refers to the list item as given by the user, which might be some strange Python type which prints differently.



---

archive/issue_comments_200162.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nSomething else: the implementation of `biseq_getitem_py` using `PyInt_FromSize_t` gives a good reason to have `biseq_item_t == size_t`. Because of this, I would propose to remove the `biseq_item_t` type again and replace it by an explicit `size_t`.",
    "created_at": "2014-10-23T19:41:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200162",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:8" align="right">comment:8</div>

Something else: the implementation of `biseq_getitem_py` using `PyInt_FromSize_t` gives a good reason to have `biseq_item_t == size_t`. Because of this, I would propose to remove the `biseq_item_t` type again and replace it by an explicit `size_t`.



---

archive/issue_comments_200163.json:
```json
{
    "body": "<div id=\"comment:9\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e\"><code>8a10b73</code></a></td><td><code>Use plain size_t, not biseq_item_t</code></td></tr></table>\n",
    "created_at": "2014-10-24T05:32:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200163",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:9"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e"><code>8a10b73</code></a></td><td><code>Use plain size_t, not biseq_item_t</code></td></tr></table>




---

archive/issue_comments_200164.json:
```json
{
    "body": "Changed commit from **[`7d25859`](https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c)** to **[`8a10b73`](https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e)**",
    "created_at": "2014-10-24T05:32:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200164",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`7d25859`](https://github.com/sagemath/sagetrac-mirror/commit/7d258591bab37466eb6392443ed2e84cf699102c)** to **[`8a10b73`](https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e)**



---

archive/issue_comments_200165.json:
```json
{
    "body": "Changed commit from **[`8a10b73`](https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e)** to **[`fa7cde0`](https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08)**",
    "created_at": "2014-10-24T06:08:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200165",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`8a10b73`](https://github.com/sagemath/sagetrac-mirror/commit/8a10b734c7f81e44bb401c1fec2dc82bd0e98d5e)** to **[`fa7cde0`](https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08)**



---

archive/issue_comments_200166.json:
```json
{
    "body": "<div id=\"comment:0\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08\"><code>fa7cde0</code></a></td><td><code>Use original data in error message</code></td></tr></table>\n",
    "created_at": "2014-10-24T06:08:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200166",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:0"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08"><code>fa7cde0</code></a></td><td><code>Use original data in error message</code></td></tr></table>




---

archive/issue_comments_200167.json:
```json
{
    "body": "Changed commit from **[`fa7cde0`](https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08)** to **[`6e03f19`](https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb)**",
    "created_at": "2014-10-24T11:14:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200167",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`fa7cde0`](https://github.com/sagemath/sagetrac-mirror/commit/fa7cde09b93359371f236ce6da13bb8f5a947a08)** to **[`6e03f19`](https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb)**



---

archive/issue_comments_200168.json:
```json
{
    "body": "<div id=\"comment:1\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb\"><code>6e03f19</code></a></td><td><code>Code and speed improvement for biseq containment test</code></td></tr></table>\n",
    "created_at": "2014-10-24T11:14:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200168",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:1"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb"><code>6e03f19</code></a></td><td><code>Code and speed improvement for biseq containment test</code></td></tr></table>




---

archive/issue_comments_200169.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nI have implemented `mpn_equal_bits_shifted`. I do *not* use `mpn_rshift`\nfollowed be `mpn_cmp`, since this would mean to touch each limb twice (once\nfor shifting, once for comparison), even if the difference occurs early in the\nsequence. Of course, using such function simplifies the code of\n`biseq_contains` and `biseq_max_overlap` considerably.\n\nHere I redo the containment tests from [comment:157](#comment:157), giving timings with the new\ncode and (in brackets) with the previous code (I would not directly compare\nwith [comment:157](#comment:157), since the previous code differs too much from the code back\nat [comment:157](#comment:157)).\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: L0 = [randint(0,7) for i in range(5)]\nsage: L1 = [randint(0,15) for i in range(15)]\nsage: L2 = [randint(0,31) for i in range(50)]\nsage: L3 = [randint(0,31) for i in range(5000)]\nsage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)\nsage: S0 = BoundedIntegerSequence(8, L0)\nsage: S1 = BoundedIntegerSequence(16, L1)\nsage: S2 = BoundedIntegerSequence(32, L2)\nsage: S3 = BoundedIntegerSequence(32, L3)\nsage: L0x = [randint(0,7) for i in range(5)]\nsage: L1x = [randint(0,15) for i in range(15)]\nsage: L2x = [randint(0,31) for i in range(50)]\nsage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3\nsage: S0x = BoundedIntegerSequence(8, L0x)\nsage: S1x = BoundedIntegerSequence(16, L1x)\nsage: S2x = BoundedIntegerSequence(32, L2x)\nsage: S3x = BoundedIntegerSequence(32, L3x)\nsage: S1y = BoundedIntegerSequence(16, L1)\nsage: S2y = BoundedIntegerSequence(32, L2)\nsage: S3y = BoundedIntegerSequence(32, L3)\nsage: S0z1 = S0+S0\nsage: S0z2 = S0+S0x\nsage: S1z1 = S1+S1\nsage: S1z2 = S1+S1x\nsage: S2z1 = S2+S2\nsage: S2z2 = S2+S2x\nsage: S3z1 = S3+S3\nsage: S3z2 = S3+S3x\nsage: timeit(\"S0x in S0z2\", number=1000000)\n1000000 loops, best of 3: 190 ns per loop  (384 ns per loop)\nsage: timeit(\"S1x in S1z2\", number=1000000)\n1000000 loops, best of 3: 282 ns per loop  (519 ns per loop)\nsage: timeit(\"S2x in S2z2\", number=1000000)\n1000000 loops, best of 3: 644 ns per loop  (2.1 \u00b5s per loop)\nsage: timeit(\"S3x in S3z2\", number=1000)\n1000 loops, best of 3: 50.2 \u00b5s per loop    (2.36 ms per loop)\n```\n\nSo, there is a very clear improvement, and this time it concerns a function\nthat I use very extensively in my applications.\n\nJeroen, I think that with the new commit I addressed all of your concerns,\nhence, for now I will move on to the follow-up tickets (i.e., cythoned quiver\npaths and the non-commutative F5 algorithm that is not on trac yet).",
    "created_at": "2014-10-24T11:17:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200169",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

I have implemented `mpn_equal_bits_shifted`. I do *not* use `mpn_rshift`
followed be `mpn_cmp`, since this would mean to touch each limb twice (once
for shifting, once for comparison), even if the difference occurs early in the
sequence. Of course, using such function simplifies the code of
`biseq_contains` and `biseq_max_overlap` considerably.

Here I redo the containment tests from [comment:157](#comment:157), giving timings with the new
code and (in brackets) with the previous code (I would not directly compare
with [comment:157](#comment:157), since the previous code differs too much from the code back
at [comment:157](#comment:157)).

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: L0 = [randint(0,7) for i in range(5)]
sage: L1 = [randint(0,15) for i in range(15)]
sage: L2 = [randint(0,31) for i in range(50)]
sage: L3 = [randint(0,31) for i in range(5000)]
sage: T0 = tuple(L0); T1 = tuple(L1); T2 = tuple(L2); T3 = tuple(L3)
sage: S0 = BoundedIntegerSequence(8, L0)
sage: S1 = BoundedIntegerSequence(16, L1)
sage: S2 = BoundedIntegerSequence(32, L2)
sage: S3 = BoundedIntegerSequence(32, L3)
sage: L0x = [randint(0,7) for i in range(5)]
sage: L1x = [randint(0,15) for i in range(15)]
sage: L2x = [randint(0,31) for i in range(50)]
sage: L3x = [randint(0,31) for i in range(5000)]  # verified that they differ from L0,L1,L2,L3
sage: S0x = BoundedIntegerSequence(8, L0x)
sage: S1x = BoundedIntegerSequence(16, L1x)
sage: S2x = BoundedIntegerSequence(32, L2x)
sage: S3x = BoundedIntegerSequence(32, L3x)
sage: S1y = BoundedIntegerSequence(16, L1)
sage: S2y = BoundedIntegerSequence(32, L2)
sage: S3y = BoundedIntegerSequence(32, L3)
sage: S0z1 = S0+S0
sage: S0z2 = S0+S0x
sage: S1z1 = S1+S1
sage: S1z2 = S1+S1x
sage: S2z1 = S2+S2
sage: S2z2 = S2+S2x
sage: S3z1 = S3+S3
sage: S3z2 = S3+S3x
sage: timeit("S0x in S0z2", number=1000000)
1000000 loops, best of 3: 190 ns per loop  (384 ns per loop)
sage: timeit("S1x in S1z2", number=1000000)
1000000 loops, best of 3: 282 ns per loop  (519 ns per loop)
sage: timeit("S2x in S2z2", number=1000000)
1000000 loops, best of 3: 644 ns per loop  (2.1 µs per loop)
sage: timeit("S3x in S3z2", number=1000)
1000 loops, best of 3: 50.2 µs per loop    (2.36 ms per loop)
```

So, there is a very clear improvement, and this time it concerns a function
that I use very extensively in my applications.

Jeroen, I think that with the new commit I addressed all of your concerns,
hence, for now I will move on to the follow-up tickets (i.e., cythoned quiver
paths and the non-commutative F5 algorithm that is not on trac yet).



---

archive/issue_events_225939.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T08:01:05Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225939"
}
```



---

archive/issue_events_225940.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T08:01:05Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225940"
}
```



---

archive/issue_comments_200170.json:
```json
{
    "body": "<div id=\"comment:303\" align=\"right\">comment:303</div>\n\n(never mind)",
    "created_at": "2014-10-27T08:01:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200170",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:303" align="right">comment:303</div>

(never mind)



---

archive/issue_events_225941.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T08:06:33Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225941"
}
```



---

archive/issue_events_225942.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T08:06:33Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225942"
}
```



---

archive/issue_comments_200171.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\n`__iter__` and `biseq_index` should be implemented in terms of `biseq_getitem()` (or a good reason given why this is a bad idea).",
    "created_at": "2014-10-27T17:23:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200171",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:5" align="right">comment:5</div>

`__iter__` and `biseq_index` should be implemented in terms of `biseq_getitem()` (or a good reason given why this is a bad idea).



---

archive/issue_events_225943.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T17:23:10Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225943"
}
```



---

archive/issue_events_225944.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-10-27T17:23:10Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225944"
}
```



---

archive/issue_comments_200172.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nIn `biseq_init_list`, iteration is about 10% faster the following way:\n\n```\nfor item in data:\n    item_limb = item\n    index += 1\n```\ninstead of\n\n```\nfor index from 0<=index<R.length:\n    item_limb = data[index]\n```",
    "created_at": "2014-10-27T18:08:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200172",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:7" align="right">comment:7</div>

In `biseq_init_list`, iteration is about 10% faster the following way:

```
for item in data:
    item_limb = item
    index += 1
```
instead of

```
for index from 0<=index<R.length:
    item_limb = data[index]
```



---

archive/issue_comments_200173.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\n`biseq_clearitem` must be added to the `.pxd` file",
    "created_at": "2014-10-27T18:12:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200173",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:8" align="right">comment:8</div>

`biseq_clearitem` must be added to the `.pxd` file



---

archive/issue_comments_200174.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nIn `biseq_slice`, the case `step == 1` should also be implemented using bitset primitives.",
    "created_at": "2014-10-27T18:16:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200174",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:9" align="right">comment:9</div>

In `biseq_slice`, the case `step == 1` should also be implemented using bitset primitives.



---

archive/issue_comments_200175.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nShould I make these changes or will you? I'm just asking to avoid duplicate work.",
    "created_at": "2014-10-27T21:32:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200175",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:0" align="right">comment:0</div>

Should I make these changes or will you? I'm just asking to avoid duplicate work.



---

archive/issue_comments_200176.json:
```json
{
    "body": "<div id=\"comment:311\" align=\"right\">comment:311</div>\n\nReplying to [@jdemeyer](#comment:310):\n> Should I make these changes or will you? I'm just asking to avoid duplicate work.\n\nI will try today.",
    "created_at": "2014-10-28T07:12:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200176",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:311" align="right">comment:311</div>

Replying to [@jdemeyer](#comment:310):
> Should I make these changes or will you? I'm just asking to avoid duplicate work.

I will try today.



---

archive/issue_comments_200177.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nWhile I am at it, I will also make `biseq_max_overlap`, `biseq_index` and `biseq_contains` return `mp_size_t`, not `int`. After all, they return an index in a bounded integer sequence (or -1 if not found, or -2 on error), and I think we have agreed that indices should be `mp_size_t`.",
    "created_at": "2014-10-28T09:46:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200177",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

While I am at it, I will also make `biseq_max_overlap`, `biseq_index` and `biseq_contains` return `mp_size_t`, not `int`. After all, they return an index in a bounded integer sequence (or -1 if not found, or -2 on error), and I think we have agreed that indices should be `mp_size_t`.



---

archive/issue_comments_200178.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nCurrently, when calling `B.index(i)`, `i` is compared modulo the `B.bound()` with the items of `B`. Taking `i` modulo the bound is currently done in `biseq_index`. I suggest to move this to `B.index`, since generally I want to avoid bound checking etc. in the boilerplate functions.",
    "created_at": "2014-10-28T09:55:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200178",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Currently, when calling `B.index(i)`, `i` is compared modulo the `B.bound()` with the items of `B`. Taking `i` modulo the bound is currently done in `biseq_index`. I suggest to move this to `B.index`, since generally I want to avoid bound checking etc. in the boilerplate functions.



---

archive/issue_comments_200179.json:
```json
{
    "body": "<div id=\"comment:314\" align=\"right\">comment:314</div>\n\nReplying to [@simon-king-jena](#comment:312):\n> While I am at it, I will also make `biseq_max_overlap`, `biseq_index` and `biseq_contains` return `mp_size_t`, not `int`. After all, they return an index in a bounded integer sequence (or -1 if not found, or -2 on error), and I think we have agreed that indices should be `mp_size_t`.\n\nI hadn't noticed, but yes: that should certainly be changed.",
    "created_at": "2014-10-28T09:55:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200179",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:314" align="right">comment:314</div>

Replying to [@simon-king-jena](#comment:312):
> While I am at it, I will also make `biseq_max_overlap`, `biseq_index` and `biseq_contains` return `mp_size_t`, not `int`. After all, they return an index in a bounded integer sequence (or -1 if not found, or -2 on error), and I think we have agreed that indices should be `mp_size_t`.

I hadn't noticed, but yes: that should certainly be changed.



---

archive/issue_comments_200180.json:
```json
{
    "body": "<div id=\"comment:315\" align=\"right\">comment:315</div>\n\nReplying to [@simon-king-jena](#comment:313):\n> Currently, when calling `B.index(i)`, `i` is compared modulo the `B.bound()` with the items of `B`. Taking `i` modulo the bound is currently done in `biseq_index`. I suggest to move this to `B.index`\n\nI would remove this modulo operation completely. If the item is too large or too small, treat it as not found.",
    "created_at": "2014-10-28T09:58:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200180",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:315" align="right">comment:315</div>

Replying to [@simon-king-jena](#comment:313):
> Currently, when calling `B.index(i)`, `i` is compared modulo the `B.bound()` with the items of `B`. Taking `i` modulo the bound is currently done in `biseq_index`. I suggest to move this to `B.index`

I would remove this modulo operation completely. If the item is too large or too small, treat it as not found.



---

archive/issue_comments_200181.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nIn `biseq_index`, use `size_t` for `item`.",
    "created_at": "2014-10-28T10:02:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200181",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:6" align="right">comment:6</div>

In `biseq_index`, use `size_t` for `item`.



---

archive/issue_comments_200182.json:
```json
{
    "body": "<div id=\"comment:317\" align=\"right\">comment:317</div>\n\nReplying to [@jdemeyer](#comment:316):\n> In `biseq_index`, use `size_t` for `item`.\n\nSince `biseq_getitem` returns a `size_t`, or is there another reason?",
    "created_at": "2014-10-28T10:28:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200182",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:317" align="right">comment:317</div>

Replying to [@jdemeyer](#comment:316):
> In `biseq_index`, use `size_t` for `item`.

Since `biseq_getitem` returns a `size_t`, or is there another reason?



---

archive/issue_comments_200183.json:
```json
{
    "body": "<div id=\"comment:318\" align=\"right\">comment:318</div>\n\nReplying to [@jdemeyer](#comment:315):\n> I would remove this modulo operation completely. If the item is too large or too small, treat it as not found.\n\nOK, but I'll do this test in `BoundedIntegerSequence.index`, not in `biseq_index`.",
    "created_at": "2014-10-28T10:29:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200183",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:318" align="right">comment:318</div>

Replying to [@jdemeyer](#comment:315):
> I would remove this modulo operation completely. If the item is too large or too small, treat it as not found.

OK, but I'll do this test in `BoundedIntegerSequence.index`, not in `biseq_index`.



---

archive/issue_comments_200184.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nShould I use `biseq_getitem_py` both in `BoundedIntegerSequence.__iter__` and `BoundedIntegerSequence.list`? Or should one of them use `biseq_getitem` for efficiency?",
    "created_at": "2014-10-28T10:33:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200184",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:9" align="right">comment:9</div>

Should I use `biseq_getitem_py` both in `BoundedIntegerSequence.__iter__` and `BoundedIntegerSequence.list`? Or should one of them use `biseq_getitem` for efficiency?



---

archive/issue_comments_200185.json:
```json
{
    "body": "<div id=\"comment:320\" align=\"right\">comment:320</div>\n\nReplying to [@jdemeyer](#comment:309):\n> In `biseq_slice`, the case `step == 1` should also be implemented using bitset primitives.\n\nProblem: We would need a bitset primitive that shifts a *part* of a bitset S. Currently, `bitset_rshift` shifts all of S, not just a part of S.\n\nI see four ways to proceed:\n- Write a new primitive `bitset_rshift_subset`, which means code duplication\n- Add an optional argument to `bitset_rshift`, which means that all places using this function must be changed.\n- Change `bitset_rshift` so that no assumption on the size of source and target are needed: We just shift the minimum of the number of limbs that is available in the source and of the number of limbs that fits into the target.\n- Do not use bitset primitives in `biseq_slice`.",
    "created_at": "2014-10-28T10:55:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200185",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:320" align="right">comment:320</div>

Replying to [@jdemeyer](#comment:309):
> In `biseq_slice`, the case `step == 1` should also be implemented using bitset primitives.

Problem: We would need a bitset primitive that shifts a *part* of a bitset S. Currently, `bitset_rshift` shifts all of S, not just a part of S.

I see four ways to proceed:
- Write a new primitive `bitset_rshift_subset`, which means code duplication
- Add an optional argument to `bitset_rshift`, which means that all places using this function must be changed.
- Change `bitset_rshift` so that no assumption on the size of source and target are needed: We just shift the minimum of the number of limbs that is available in the source and of the number of limbs that fits into the target.
- Do not use bitset primitives in `biseq_slice`.



---

archive/issue_comments_200186.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nPS: My favourite would be to modify `bitset_rshift` (and `bitset_lshift`) to make it robust against reading/writing out of bound, in the sense that `bitset_rshift(R,S,n)` moves a subset of S that fits into R.",
    "created_at": "2014-10-28T11:00:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200186",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

PS: My favourite would be to modify `bitset_rshift` (and `bitset_lshift`) to make it robust against reading/writing out of bound, in the sense that `bitset_rshift(R,S,n)` moves a subset of S that fits into R.



---

archive/issue_comments_200187.json:
```json
{
    "body": "Changed commit from **[`6e03f19`](https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb)** to **[`b5b066d`](https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057)**",
    "created_at": "2014-10-28T15:34:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200187",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`6e03f19`](https://github.com/sagemath/sagetrac-mirror/commit/6e03f19d4bc2379e44e0b8adc32c13ac6e0bcabb)** to **[`b5b066d`](https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057)**



---

archive/issue_comments_200188.json:
```json
{
    "body": "<div id=\"comment:2\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057\"><code>b5b066d</code></a></td><td><code>Code simplification for biseq_*, bound check for bitset shifts</code></td></tr></table>\n",
    "created_at": "2014-10-28T15:34:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200188",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:2"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057"><code>b5b066d</code></a></td><td><code>Code simplification for biseq_*, bound check for bitset shifts</code></td></tr></table>




---

archive/issue_comments_200189.json:
```json
{
    "body": "<div id=\"comment:3\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b\"><code>43f78ad</code></a></td><td><code>Adding a reference to trac</code></td></tr></table>\n",
    "created_at": "2014-10-28T15:35:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200189",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:3"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b"><code>43f78ad</code></a></td><td><code>Adding a reference to trac</code></td></tr></table>




---

archive/issue_comments_200190.json:
```json
{
    "body": "Changed commit from **[`b5b066d`](https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057)** to **[`43f78ad`](https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b)**",
    "created_at": "2014-10-28T15:35:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200190",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`b5b066d`](https://github.com/sagemath/sagetrac-mirror/commit/b5b066dc218d7fb6e5e13eb19cce4720d4a2d057)** to **[`43f78ad`](https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b)**



---

archive/issue_comments_200191.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nIn the new commits I addressed (I hope) all issues that we discussed yesterday\nand today.\n\nTimings without the new commits:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(27, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])\nsage: %timeit B.list()\n1000000 loops, best of 3: 1.64 \u00b5s per loop\nsage: %timeit list(B)\n100000 loops, best of 3: 2.57 \u00b5s per loop\nsage: %timeit B[2:-2]\n1000000 loops, best of 3: 1.13 \u00b5s per loop\nsage: L = [randint(0,7) for _ in range(1000)]\nsage: %timeit B = BoundedIntegerSequence(8, L)\n100000 loops, best of 3: 13 \u00b5s per loop\nsage: B = BoundedIntegerSequence(8, L)\nsage: %timeit B.list()\n10000 loops, best of 3: 31.5 \u00b5s per loop\nsage: %timeit list(B)\n10000 loops, best of 3: 55 \u00b5s per loop\nsage: %timeit B[3:800]\n1000000 loops, best of 3: 1.26 \u00b5s per loop\n```\n\nAnd with the new commit:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(27, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])\nsage: %timeit B.list()\n1000000 loops, best of 3: 1.6 \u00b5s per loop\nsage: %timeit list(B)\n100000 loops, best of 3: 2.62 \u00b5s per loop\nsage: %timeit B[2:-2]\n1000000 loops, best of 3: 1.12 \u00b5s per loop\nsage: L = [randint(0,7) for _ in range(1000)]\nsage: %timeit B = BoundedIntegerSequence(8, L)\n100000 loops, best of 3: 11.5 \u00b5s per loop\nsage: B = BoundedIntegerSequence(8, L)\nsage: %timeit B.list()\n10000 loops, best of 3: 30.8 \u00b5s per loop\nsage: %timeit list(B)\n10000 loops, best of 3: 64.9 \u00b5s per loop\nsage: %timeit B[3:800]\n1000000 loops, best of 3: 1.27 \u00b5s per loop\n```\n\nApparently, creation from a list became faster, iteration over a long\nlist became 10% slower (but in my appliations, I do not iterate over the items\nof a bounded integer sequence, hence, I don't care about the slow-down), and\neverything else did not change significantly.\n\nAnd the code became clearer, which is a plus. I hope you'll find that my\nchanges to `bitset_rshift` and `bitset_lshift` make sense.",
    "created_at": "2014-10-28T15:41:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200191",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

In the new commits I addressed (I hope) all issues that we discussed yesterday
and today.

Timings without the new commits:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(27, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])
sage: %timeit B.list()
1000000 loops, best of 3: 1.64 µs per loop
sage: %timeit list(B)
100000 loops, best of 3: 2.57 µs per loop
sage: %timeit B[2:-2]
1000000 loops, best of 3: 1.13 µs per loop
sage: L = [randint(0,7) for _ in range(1000)]
sage: %timeit B = BoundedIntegerSequence(8, L)
100000 loops, best of 3: 13 µs per loop
sage: B = BoundedIntegerSequence(8, L)
sage: %timeit B.list()
10000 loops, best of 3: 31.5 µs per loop
sage: %timeit list(B)
10000 loops, best of 3: 55 µs per loop
sage: %timeit B[3:800]
1000000 loops, best of 3: 1.26 µs per loop
```

And with the new commit:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(27, [8, 8, 26, 18, 18, 8, 22, 4, 17, 22, 22, 7, 12, 4, 1, 7, 21, 7, 10, 10])
sage: %timeit B.list()
1000000 loops, best of 3: 1.6 µs per loop
sage: %timeit list(B)
100000 loops, best of 3: 2.62 µs per loop
sage: %timeit B[2:-2]
1000000 loops, best of 3: 1.12 µs per loop
sage: L = [randint(0,7) for _ in range(1000)]
sage: %timeit B = BoundedIntegerSequence(8, L)
100000 loops, best of 3: 11.5 µs per loop
sage: B = BoundedIntegerSequence(8, L)
sage: %timeit B.list()
10000 loops, best of 3: 30.8 µs per loop
sage: %timeit list(B)
10000 loops, best of 3: 64.9 µs per loop
sage: %timeit B[3:800]
1000000 loops, best of 3: 1.27 µs per loop
```

Apparently, creation from a list became faster, iteration over a long
list became 10% slower (but in my appliations, I do not iterate over the items
of a bounded integer sequence, hence, I don't care about the slow-down), and
everything else did not change significantly.

And the code became clearer, which is a plus. I hope you'll find that my
changes to `bitset_rshift` and `bitset_lshift` make sense.



---

archive/issue_events_225945.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-28T15:41:18Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225945"
}
```



---

archive/issue_events_225946.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-28T15:41:18Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225946"
}
```



---

archive/issue_comments_200192.json:
```json
{
    "body": "<div id=\"comment:326\" align=\"right\">comment:326</div>\n\nGiven the new code, the comment\n\n```\nItems will not just be compared by congruence modulo the bound of the\nsequence, but by equality.\n```\nno longer makes sense.",
    "created_at": "2014-10-28T15:54:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200192",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:326" align="right">comment:326</div>

Given the new code, the comment

```
Items will not just be compared by congruence modulo the bound of the
sequence, but by equality.
```
no longer makes sense.



---

archive/issue_comments_200193.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nI would replace the doc\n\n```\nIf the result of the shift would exceed the size of ``r``, then it\nwill be cut.\n```\nby something like\n\n```\nThere are no assumptions on the sizes of ``a`` and ``r``.\nBits which are shifted outside of the resulting bitset are discarded.\n```",
    "created_at": "2014-10-28T15:58:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200193",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:7" align="right">comment:7</div>

I would replace the doc

```
If the result of the shift would exceed the size of ``r``, then it
will be cut.
```
by something like

```
There are no assumptions on the sizes of ``a`` and ``r``.
Bits which are shifted outside of the resulting bitset are discarded.
```



---

archive/issue_comments_200194.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nIn\n\n```\nraise ValueError(\"list item {} larger than {}\".format(data[index], bound) )\n```\nreplace `data[index]` by `item`.",
    "created_at": "2014-10-28T15:59:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200194",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:8" align="right">comment:8</div>

In

```
raise ValueError("list item {} larger than {}".format(data[index], bound) )
```
replace `data[index]` by `item`.



---

archive/issue_comments_200195.json:
```json
{
    "body": "Changed commit from **[`43f78ad`](https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b)** to **[`7a0dd46`](https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1)**",
    "created_at": "2014-10-28T16:43:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200195",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`43f78ad`](https://github.com/sagemath/sagetrac-mirror/commit/43f78ad50eee7259ab06d5eec1d4cdb03a43f50b)** to **[`7a0dd46`](https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1)**



---

archive/issue_comments_200196.json:
```json
{
    "body": "<div id=\"comment:9\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1\"><code>7a0dd46</code></a></td><td><code>Some improvements of the doc</code></td></tr></table>\n",
    "created_at": "2014-10-28T16:43:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200196",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:9"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1"><code>7a0dd46</code></a></td><td><code>Some improvements of the doc</code></td></tr></table>




---

archive/issue_comments_200197.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nDone!\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1\"><code>7a0dd46</code></a></td><td><code>Some improvements of the doc</code></td></tr></table>\n",
    "created_at": "2014-10-28T16:43:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200197",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:0" align="right">comment:0</div>

Done!

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1"><code>7a0dd46</code></a></td><td><code>Some improvements of the doc</code></td></tr></table>




---

archive/issue_events_225947.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-29T00:04:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225947"
}
```



---

archive/issue_events_225948.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-29T00:04:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225948"
}
```



---

archive/issue_comments_200198.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nI found a bug (probably in slicing):\n\n```\nsage: B1 = BoundedIntegerSequence(8, [0,7])\nsage: B2 = BoundedIntegerSequence(8, [2,1,4])\nsage: B1[0:1]+B2\n<0, 7, 1, 4>\nsage: B1[0:1]\n<0>\n```\n\nMy diagnose is that the top bits of the slice (those exceeding the size) have not been cleared. This doesn't show when printing it, but concatenation does rely on the top bits being cleared.",
    "created_at": "2014-10-29T00:04:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200198",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

I found a bug (probably in slicing):

```
sage: B1 = BoundedIntegerSequence(8, [0,7])
sage: B2 = BoundedIntegerSequence(8, [2,1,4])
sage: B1[0:1]+B2
<0, 7, 1, 4>
sage: B1[0:1]
<0>
```

My diagnose is that the top bits of the slice (those exceeding the size) have not been cleared. This doesn't show when printing it, but concatenation does rely on the top bits being cleared.



---

archive/issue_comments_200199.json:
```json
{
    "body": "Changed commit from **[`7a0dd46`](https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1)** to **[`6723c7e`](https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9)**",
    "created_at": "2014-10-29T00:45:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200199",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`7a0dd46`](https://github.com/sagemath/sagetrac-mirror/commit/7a0dd469527c8a4f39d8d891703fcf5feecda9a1)** to **[`6723c7e`](https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9)**



---

archive/issue_comments_200200.json:
```json
{
    "body": "<div id=\"comment:2\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9\"><code>6723c7e</code></a></td><td><code>Fix highest bits of bitsets after fixing</code></td></tr></table>\n",
    "created_at": "2014-10-29T00:45:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200200",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:2"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9"><code>6723c7e</code></a></td><td><code>Fix highest bits of bitsets after fixing</code></td></tr></table>




---

archive/issue_events_225949.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-29T00:45:35Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225949"
}
```



---

archive/issue_events_225950.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-10-29T00:45:35Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225950"
}
```



---

archive/issue_comments_200201.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nFixed and tested...\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9\"><code>6723c7e</code></a></td><td><code>Fix highest bits of bitsets after fixing</code></td></tr></table>\n",
    "created_at": "2014-10-29T00:45:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200201",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Fixed and tested...

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9"><code>6723c7e</code></a></td><td><code>Fix highest bits of bitsets after fixing</code></td></tr></table>




---

archive/issue_comments_200202.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nFor consistency, `biseq_slice` should be renamed `biseq_init_slice`.",
    "created_at": "2014-10-29T09:55:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200202",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:4" align="right">comment:4</div>

For consistency, `biseq_slice` should be renamed `biseq_init_slice`.



---

archive/issue_comments_200203.json:
```json
{
    "body": "Changed reviewer from **Simon King** to **Jeroen Demeyer, Simon King**",
    "created_at": "2014-10-29T09:58:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200203",
    "user": "https://github.com/jdemeyer"
}
```

Changed reviewer from **Simon King** to **Jeroen Demeyer, Simon King**



---

archive/issue_comments_200204.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nModulo this comment about `biseq_init_slice`, I think the public biseq interface looks good.\n\nI have not looked at all the changes of the last few days and I don't feel like doing that now. I do plan to review this ticket in some time with a fresh look (of course, other reviewers are always welcome). In any case, I think the current branch works well enough that you can use it for your other tickets.",
    "created_at": "2014-10-29T09:58:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200204",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:5" align="right">comment:5</div>

Modulo this comment about `biseq_init_slice`, I think the public biseq interface looks good.

I have not looked at all the changes of the last few days and I don't feel like doing that now. I do plan to review this ticket in some time with a fresh look (of course, other reviewers are always welcome). In any case, I think the current branch works well enough that you can use it for your other tickets.



---

archive/issue_comments_200205.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0\"><code>b6ef6d5</code></a></td><td><code>Rename biseq_slice -> biseq_init_slice</code></td></tr></table>\n",
    "created_at": "2014-10-29T14:06:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200205",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:6"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0"><code>b6ef6d5</code></a></td><td><code>Rename biseq_slice -> biseq_init_slice</code></td></tr></table>




---

archive/issue_comments_200206.json:
```json
{
    "body": "Changed commit from **[`6723c7e`](https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9)** to **[`b6ef6d5`](https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0)**",
    "created_at": "2014-10-29T14:06:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200206",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`6723c7e`](https://github.com/sagemath/sagetrac-mirror/commit/6723c7e44dbae3118e3dff259fd0e633915b53c9)** to **[`b6ef6d5`](https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0)**



---

archive/issue_comments_200207.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nIn `biseq_init_slice(biseq_t R, biseq_t S, mp_size_t start, mp_size_t stop, int step)`, the `step` argument should also be `mp_size_t`.",
    "created_at": "2014-10-30T10:05:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200207",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:7" align="right">comment:7</div>

In `biseq_init_slice(biseq_t R, biseq_t S, mp_size_t start, mp_size_t stop, int step)`, the `step` argument should also be `mp_size_t`.



---

archive/issue_comments_200208.json:
```json
{
    "body": "<div id=\"comment:8\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d\"><code>0e51c4a</code></a></td><td><code>Change the type of an argument</code></td></tr></table>\n",
    "created_at": "2014-10-30T10:55:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200208",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:8"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d"><code>0e51c4a</code></a></td><td><code>Change the type of an argument</code></td></tr></table>




---

archive/issue_comments_200209.json:
```json
{
    "body": "Changed commit from **[`b6ef6d5`](https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0)** to **[`0e51c4a`](https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d)**",
    "created_at": "2014-10-30T10:55:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200209",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`b6ef6d5`](https://github.com/sagemath/sagetrac-mirror/commit/b6ef6d5c5faffe4059b1539f00e25dd98b9481c0)** to **[`0e51c4a`](https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d)**



---

archive/issue_comments_200210.json:
```json
{
    "body": "Changed branch from **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)** to **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)**",
    "created_at": "2014-10-30T16:34:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200210",
    "user": "https://github.com/jdemeyer"
}
```

Changed branch from **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)** to **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)**



---

archive/issue_comments_200211.json:
```json
{
    "body": "Changed commit from **[`0e51c4a`](https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d)** to **[`d46a22d`](https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3)**",
    "created_at": "2014-10-30T16:34:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200211",
    "user": "https://github.com/jdemeyer"
}
```

Changed commit from **[`0e51c4a`](https://github.com/sagemath/sagetrac-mirror/commit/0e51c4a8ae1720e301b4d57ee51289de475bf51d)** to **[`d46a22d`](https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3)**



---

archive/issue_comments_200212.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nResolved easy merge conflict.\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3\"><code>d46a22d</code></a></td><td><code>Merge remote-tracking branch 'origin/develop' into ticket/15820</code></td></tr></table>\n",
    "created_at": "2014-10-30T16:34:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200212",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:0" align="right">comment:0</div>

Resolved easy merge conflict.

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3"><code>d46a22d</code></a></td><td><code>Merge remote-tracking branch 'origin/develop' into ticket/15820</code></td></tr></table>




---

archive/issue_comments_200213.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nCan the review be finished? #16453 and #17435 depend on it.",
    "created_at": "2014-12-03T14:36:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200213",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

Can the review be finished? #16453 and #17435 depend on it.



---

archive/issue_comments_200214.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nPS: The errors that *some* patchbots report seem unrelated. And I don't see what the coverage script is complaining about. Coverage of the new stuff is 100%.",
    "created_at": "2014-12-03T14:40:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200214",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

PS: The errors that *some* patchbots report seem unrelated. And I don't see what the coverage script is complaining about. Coverage of the new stuff is 100%.



---

archive/issue_comments_200215.json:
```json
{
    "body": "Changed commit from **[`d46a22d`](https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3)** to **[`7e5f217`](https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6)**",
    "created_at": "2014-12-03T21:28:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200215",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`d46a22d`](https://github.com/sagemath/sagetrac-mirror/commit/d46a22d394c0c3556bd297427614bbc43140efb3)** to **[`7e5f217`](https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6)**



---

archive/issue_comments_200216.json:
```json
{
    "body": "<div id=\"comment:3\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6\"><code>7e5f217</code></a></td><td><code>Reorganize logic of bitset shifts</code></td></tr></table>\n",
    "created_at": "2014-12-03T21:28:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200216",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:3"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6"><code>7e5f217</code></a></td><td><code>Reorganize logic of bitset shifts</code></td></tr></table>




---

archive/issue_comments_200217.json:
```json
{
    "body": "Changed commit from **[`7e5f217`](https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6)** to **[`0c64618`](https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664)**",
    "created_at": "2014-12-04T09:42:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200217",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`7e5f217`](https://github.com/sagemath/sagetrac-mirror/commit/7e5f21754e6c056d71609830729c093ba09b56a6)** to **[`0c64618`](https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664)**



---

archive/issue_comments_200218.json:
```json
{
    "body": "<div id=\"comment:4\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d0a5c78fc58c86fa830c6223d735a1507b3c434c\"><code>d0a5c78</code></a></td><td><code>Move bitset_fix() function</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664\"><code>0c64618</code></a></td><td><code>Documentation fixes</code></td></tr></table>\n",
    "created_at": "2014-12-04T09:42:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200218",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:4"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d0a5c78fc58c86fa830c6223d735a1507b3c434c"><code>d0a5c78</code></a></td><td><code>Move bitset_fix() function</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664"><code>0c64618</code></a></td><td><code>Documentation fixes</code></td></tr></table>




---

archive/issue_comments_200219.json:
```json
{
    "body": "Changed commit from **[`0c64618`](https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664)** to **[`58f5f57`](https://github.com/sagemath/sagetrac-mirror/commit/58f5f57bd3d620b571ce2c8d1e8da372f5171fdf)**",
    "created_at": "2014-12-04T12:36:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200219",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`0c64618`](https://github.com/sagemath/sagetrac-mirror/commit/0c646186f3522ab9bf3210ddc9bd3baf7b1b4664)** to **[`58f5f57`](https://github.com/sagemath/sagetrac-mirror/commit/58f5f57bd3d620b571ce2c8d1e8da372f5171fdf)**



---

archive/issue_comments_200220.json:
```json
{
    "body": "<div id=\"comment:5\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/93e64fd518f9088da631e6b4126c740f7722af77\"><code>93e64fd</code></a></td><td><code>Always raise OverflowError if list item is out of bounds</code></td></tr></table>\n",
    "created_at": "2014-12-04T12:36:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200220",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:5"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/93e64fd518f9088da631e6b4126c740f7722af77"><code>93e64fd</code></a></td><td><code>Always raise OverflowError if list item is out of bounds</code></td></tr></table>




---

archive/issue_comments_200221.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8\"><code>411fe4e</code></a></td><td><code>Simplify/fix the logic of some biseq functions</code></td></tr></table>\n",
    "created_at": "2014-12-04T12:38:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200221",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:6"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8"><code>411fe4e</code></a></td><td><code>Simplify/fix the logic of some biseq functions</code></td></tr></table>




---

archive/issue_comments_200222.json:
```json
{
    "body": "Changed commit from **[`58f5f57`](https://github.com/sagemath/sagetrac-mirror/commit/58f5f57bd3d620b571ce2c8d1e8da372f5171fdf)** to **[`411fe4e`](https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8)**",
    "created_at": "2014-12-04T12:38:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200222",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`58f5f57`](https://github.com/sagemath/sagetrac-mirror/commit/58f5f57bd3d620b571ce2c8d1e8da372f5171fdf)** to **[`411fe4e`](https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8)**



---

archive/issue_comments_200223.json:
```json
{
    "body": "Changed commit from **[`411fe4e`](https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8)** to **[`8db9f65`](https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6)**",
    "created_at": "2014-12-04T14:31:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200223",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`411fe4e`](https://github.com/sagemath/sagetrac-mirror/commit/411fe4e04b87e5fdf87e4c3f4052e6747e09eca8)** to **[`8db9f65`](https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6)**



---

archive/issue_comments_200224.json:
```json
{
    "body": "<div id=\"comment:7\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cf166a67ba74f42f619671129f09028b9c174a1d\"><code>cf166a6</code></a></td><td><code>Generalise biseq_max_overlap() and rename as biseq_reverse_contains()</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6\"><code>8db9f65</code></a></td><td><code>Various improvements to BoundedIntegerSequence</code></td></tr></table>\n",
    "created_at": "2014-12-04T14:31:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200224",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:7"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cf166a67ba74f42f619671129f09028b9c174a1d"><code>cf166a6</code></a></td><td><code>Generalise biseq_max_overlap() and rename as biseq_reverse_contains()</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6"><code>8db9f65</code></a></td><td><code>Various improvements to BoundedIntegerSequence</code></td></tr></table>




---

archive/issue_comments_200225.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nMy review of this is done now. I'll let you look at my commits.",
    "created_at": "2014-12-04T14:35:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200225",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:8" align="right">comment:8</div>

My review of this is done now. I'll let you look at my commits.



---

archive/issue_comments_200226.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nI have made one important functional change: you should change `biseq_max_overlap(A, B)` to `biseq_reverse_contains(B, A, 1)` in the follow-up tickets.\n\nI also fixed a few bugs and changed some exceptions but there should be no other functional changes.",
    "created_at": "2014-12-04T14:39:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200226",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:9" align="right">comment:9</div>

I have made one important functional change: you should change `biseq_max_overlap(A, B)` to `biseq_reverse_contains(B, A, 1)` in the follow-up tickets.

I also fixed a few bugs and changed some exceptions but there should be no other functional changes.



---

archive/issue_events_225951.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-12-04T15:09:17Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225951"
}
```



---

archive/issue_events_225952.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-12-04T15:09:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225952"
}
```



---

archive/issue_comments_200227.json:
```json
{
    "body": "Work Issues: **interrupt handling**",
    "created_at": "2014-12-04T15:09:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200227",
    "user": "https://github.com/jdemeyer"
}
```

Work Issues: **interrupt handling**



---

archive/issue_comments_200228.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nWe are still missing `sig_*` functions to allow interrupts. But I prefer for you to review my changes before adding those.",
    "created_at": "2014-12-04T15:09:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200228",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:0" align="right">comment:0</div>

We are still missing `sig_*` functions to allow interrupts. But I prefer for you to review my changes before adding those.



---

archive/issue_comments_200229.json:
```json
{
    "body": "<div id=\"comment:351\" align=\"right\">comment:351</div>\n\nDear Jeroen,\n\nthank you for reviewing!\n\nReplying to [@jdemeyer](#comment:350):\n> We are still missing `sig_*` functions to allow interrupts. But I prefer for you to review my changes before adding those.\n\n- You changed the location of the (old) function `bitset_fix`. Why? Won't that increase the likelihood of a merge conflict?\n\n- When reading the function name `biseq_reverse_contains`, I'd expect that it either checks for containment of a reverse subsequence, or it checks for containment of a subsequence starting at the end of the supersequence. Both is not the case. What this function determines is an overlap of the end of first and the beginning of the second argument. That said, I don't think the new function name is worse than the old.\n\nThe other changes seem at least reasonable, some are needed. Thanks for spotting it.\n\nIn any case, there will be a merge conflict with the next follow-up ticket. But I guess it can hardly be avoided. I think we can now take care of signal handling.",
    "created_at": "2014-12-04T23:17:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200229",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:351" align="right">comment:351</div>

Dear Jeroen,

thank you for reviewing!

Replying to [@jdemeyer](#comment:350):
> We are still missing `sig_*` functions to allow interrupts. But I prefer for you to review my changes before adding those.

- You changed the location of the (old) function `bitset_fix`. Why? Won't that increase the likelihood of a merge conflict?

- When reading the function name `biseq_reverse_contains`, I'd expect that it either checks for containment of a reverse subsequence, or it checks for containment of a subsequence starting at the end of the supersequence. Both is not the case. What this function determines is an overlap of the end of first and the beginning of the second argument. That said, I don't think the new function name is worse than the old.

The other changes seem at least reasonable, some are needed. Thanks for spotting it.

In any case, there will be a merge conflict with the next follow-up ticket. But I guess it can hardly be avoided. I think we can now take care of signal handling.



---

archive/issue_comments_200230.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nAnd one thing is not correct in the description of `biseq_reverse_contains`:\n\n```\n  Return ``i`` such that the bounded integer sequence ``S1`` starts with\n  the sequence ``S2[i:]``, where ``start <= i < S2.length``, or return\n  ``-1`` if no such ``i`` exists.\n```\nIf you apply the function (whatever it is named) to `<2,3,2,3,1>` and `<1,2,3,2,3>` (I just notice that you also exchanged the r\u00f4les of `S1` and `S2`!), then I want it to yield the *maximal* overlap: It should return 1, not 3. That's not clear from the new description.",
    "created_at": "2014-12-04T23:28:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200230",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:2" align="right">comment:2</div>

And one thing is not correct in the description of `biseq_reverse_contains`:

```
  Return ``i`` such that the bounded integer sequence ``S1`` starts with
  the sequence ``S2[i:]``, where ``start <= i < S2.length``, or return
  ``-1`` if no such ``i`` exists.
```
If you apply the function (whatever it is named) to `<2,3,2,3,1>` and `<1,2,3,2,3>` (I just notice that you also exchanged the rôles of `S1` and `S2`!), then I want it to yield the *maximal* overlap: It should return 1, not 3. That's not clear from the new description.



---

archive/issue_comments_200231.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nHmmmm. I am less and less happy about the \"contains\" in the name `biseq_reverse_contains`. Neither is the first argument contained in the second nor the second contained in the first. And even if it were: We are not interested in mere containment, but we want to know whether a terminal segment of one argument coincides with an initial segment of the other argument.",
    "created_at": "2014-12-04T23:39:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200231",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Hmmmm. I am less and less happy about the "contains" in the name `biseq_reverse_contains`. Neither is the first argument contained in the second nor the second contained in the first. And even if it were: We are not interested in mere containment, but we want to know whether a terminal segment of one argument coincides with an initial segment of the other argument.



---

archive/issue_comments_200232.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nWhat do you think about the name `biseq_start_of_overlap`, and switching back to the old r\u00f4le of the arguments (i.e., we search for the smallest possible start index of a terminal segment of S1 that coincides with an initial segment of S2)?",
    "created_at": "2014-12-04T23:50:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200232",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

What do you think about the name `biseq_start_of_overlap`, and switching back to the old rôle of the arguments (i.e., we search for the smallest possible start index of a terminal segment of S1 that coincides with an initial segment of S2)?



---

archive/issue_comments_200233.json:
```json
{
    "body": "Changed branch from **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)** to **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)**",
    "created_at": "2014-12-05T00:00:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200233",
    "user": "https://github.com/simon-king-jena"
}
```

Changed branch from **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)** to **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)**



---

archive/issue_comments_200234.json:
```json
{
    "body": "Changed commit from **[`8db9f65`](https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6)** to **[`63d2693`](https://github.com/sagemath/sagetrac-mirror/commit/63d2693eb4915632e3cb806730a4eb56dc26008e)**",
    "created_at": "2014-12-05T06:46:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200234",
    "user": "https://github.com/simon-king-jena"
}
```

Changed commit from **[`8db9f65`](https://github.com/sagemath/sagetrac-mirror/commit/8db9f6542a54ead67c1df3d069103b620e85eea6)** to **[`63d2693`](https://github.com/sagemath/sagetrac-mirror/commit/63d2693eb4915632e3cb806730a4eb56dc26008e)**



---

archive/issue_comments_200235.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nFor the record: With `git trac push 15820`, only the branch of this ticket was changed, but *not* the sha1. Hence, I have to change it manually.",
    "created_at": "2014-12-05T06:46:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200235",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

For the record: With `git trac push 15820`, only the branch of this ticket was changed, but *not* the sha1. Hence, I have to change it manually.



---

archive/issue_comments_200236.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nBy the way: Note that I've formulated error messages such as `ValueError: BoundedIntegerSequence.index(x): x(=32) not in sequence` by taking tuples as good example:\n\n```\nsage: (1,2,3).index(4)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-2-e2928ab3b336> in <module>()\n----> 1 (Integer(1),Integer(2),Integer(3)).index(Integer(4))\n\nValueError: tuple.index(x): x not in tuple\n```\nYour error message is more similar to what is done for lists:\n\n```\nsage: [1,2,3].index(4)\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-1-e163a1d1b274> in <module>()\n----> 1 [Integer(1),Integer(2),Integer(3)].index(Integer(4))\n\nValueError: 4 is not in list\n```\nBut that's not more than a side-note. I accept your change.",
    "created_at": "2014-12-05T08:11:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200236",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

By the way: Note that I've formulated error messages such as `ValueError: BoundedIntegerSequence.index(x): x(=32) not in sequence` by taking tuples as good example:

```
sage: (1,2,3).index(4)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-2-e2928ab3b336> in <module>()
----> 1 (Integer(1),Integer(2),Integer(3)).index(Integer(4))

ValueError: tuple.index(x): x not in tuple
```
Your error message is more similar to what is done for lists:

```
sage: [1,2,3].index(4)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-1-e163a1d1b274> in <module>()
----> 1 [Integer(1),Integer(2),Integer(3)].index(Integer(4))

ValueError: 4 is not in list
```
But that's not more than a side-note. I accept your change.



---

archive/issue_comments_200237.json:
```json
{
    "body": "<div id=\"comment:358\" align=\"right\">comment:358</div>\n\nReplying to [@simon-king-jena](#comment:351):\n> - You changed the location of the (old) function `bitset_fix`. Why?\n\nBecause I think the new location is better than the old one, it seemed out of place in the list of functions to generate limb patterns.\n\n> Won't that increase the likelihood of a merge conflict?\n\nWell, every change increases the likelihood of a merge conflict...\nBut I don't know of any other tickets changing bitset code, so it won't be that bad.",
    "created_at": "2014-12-05T09:12:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200237",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:358" align="right">comment:358</div>

Replying to [@simon-king-jena](#comment:351):
> - You changed the location of the (old) function `bitset_fix`. Why?

Because I think the new location is better than the old one, it seemed out of place in the list of functions to generate limb patterns.

> Won't that increase the likelihood of a merge conflict?

Well, every change increases the likelihood of a merge conflict...
But I don't know of any other tickets changing bitset code, so it won't be that bad.



---

archive/issue_comments_200238.json:
```json
{
    "body": "<div id=\"comment:359\" align=\"right\">comment:359</div>\n\nReplying to [@simon-king-jena](#comment:354):\n> What do you think about the name `biseq_start_of_overlap`, and switching back to the old r\u00f4le of the arguments (i.e., we search for the smallest possible start index of a terminal segment of S1 that coincides with an initial segment of S2)?\n\nWell, the thing that bothered me most about the old `biseq_max_overlap` function was the implicit start index of 1, which is unexpected (why 1?) and couldn't be changed (unlike `biseq_contains`).\n\nI changed the names and ordering of the arguments to make it more clear that `biseq_contains` and `biseq_reverse_contains` are in fact very similar: the first finds `i` such that `S1[i:]` starts with `S2`, the second finds `i` such that `S1` starts with `S2[i:]`.\n\nI'm certainly open for changes, I just would like the functions to be as intuitive as possible for people *not knowing about your application of quiver algebras*. For example, the word \"overlap\" doesn't mean anything to me when you talk just about sequences of integers.",
    "created_at": "2014-12-05T09:28:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200238",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:359" align="right">comment:359</div>

Replying to [@simon-king-jena](#comment:354):
> What do you think about the name `biseq_start_of_overlap`, and switching back to the old rôle of the arguments (i.e., we search for the smallest possible start index of a terminal segment of S1 that coincides with an initial segment of S2)?

Well, the thing that bothered me most about the old `biseq_max_overlap` function was the implicit start index of 1, which is unexpected (why 1?) and couldn't be changed (unlike `biseq_contains`).

I changed the names and ordering of the arguments to make it more clear that `biseq_contains` and `biseq_reverse_contains` are in fact very similar: the first finds `i` such that `S1[i:]` starts with `S2`, the second finds `i` such that `S1` starts with `S2[i:]`.

I'm certainly open for changes, I just would like the functions to be as intuitive as possible for people *not knowing about your application of quiver algebras*. For example, the word "overlap" doesn't mean anything to me when you talk just about sequences of integers.



---

archive/issue_comments_200239.json:
```json
{
    "body": "Changed branch from **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)** to **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)**",
    "created_at": "2014-12-05T10:22:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200239",
    "user": "https://github.com/jdemeyer"
}
```

Changed branch from **[u/SimonKing/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/15820)** to **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)**



---

archive/issue_comments_200240.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nApparently the trac pages are not available, because of an internal error. So, I'm trying to comment using the sage-dev script.\n\nYou wrote:\n\n I'm certainly open for changes, I just would like the functions to be as\n intuitive as possible for people ''not knowing about your application of\n quiver algebras''. For example, the word \"overlap\" doesn't mean anything\n to me when you talk just about sequences of integers.\n\nHere I disagree. If I have two lists A and B, then the statement \"A overlaps with B\" makes immediate sense to me. The only open question is whether \"A overlaps with B\" means that the overlap of the two lists is supposed to be at the end of A or at the end of B.",
    "created_at": "2014-12-05T11:44:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200240",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:1" align="right">comment:1</div>

Apparently the trac pages are not available, because of an internal error. So, I'm trying to comment using the sage-dev script.

You wrote:

 I'm certainly open for changes, I just would like the functions to be as
 intuitive as possible for people ''not knowing about your application of
 quiver algebras''. For example, the word "overlap" doesn't mean anything
 to me when you talk just about sequences of integers.

Here I disagree. If I have two lists A and B, then the statement "A overlaps with B" makes immediate sense to me. The only open question is whether "A overlaps with B" means that the overlap of the two lists is supposed to be at the end of A or at the end of B.



---

archive/issue_comments_200241.json:
```json
{
    "body": "<div id=\"comment:2\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718\"><code>0a03d71</code></a></td><td><code>More descriptive function name for bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-12-05T12:51:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200241",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:2"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718"><code>0a03d71</code></a></td><td><code>More descriptive function name for bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_200242.json:
```json
{
    "body": "Changed commit from **[`63d2693`](https://github.com/sagemath/sagetrac-mirror/commit/63d2693eb4915632e3cb806730a4eb56dc26008e)** to **[`0a03d71`](https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718)**",
    "created_at": "2014-12-05T12:51:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200242",
    "user": "https://github.com/jdemeyer"
}
```

Changed commit from **[`63d2693`](https://github.com/sagemath/sagetrac-mirror/commit/63d2693eb4915632e3cb806730a4eb56dc26008e)** to **[`0a03d71`](https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718)**



---

archive/issue_comments_200243.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nTo reduce unneeded merges, I have cherry-picked your commit on top of my branch.",
    "created_at": "2014-12-05T12:52:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200243",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:3" align="right">comment:3</div>

To reduce unneeded merges, I have cherry-picked your commit on top of my branch.



---

archive/issue_comments_200244.json:
```json
{
    "body": "<div id=\"comment:364\" align=\"right\">comment:364</div>\n\nReplying to [@simon-king-jena](#comment:354):\n> What do you think about switching back to the old r\u00f4le of the arguments\n\nI think it's a bad idea.\n\nLook at the following (now removed) code from you:\n\n```\nif other.startswith(self):\n    return self\ncdef mp_size_t i = biseq_max_overlap(self.data, other.data)\n```\nNote that the case `i == 0` of `biseq_max_overlap(B, A)` corresponds to `biseq_startswith(A, B)`. An unexpected reordering in my opinion.\n\nIn my proposal, the three functions `biseq_startswith`, `biseq_contains` and `biseq_reverse_contains` (whatever the name) all check whether some part of `S1` starts with some part of `S2`. The only thing that changes is which parts of `S1` and `S2` are considered.",
    "created_at": "2014-12-05T13:00:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200244",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:364" align="right">comment:364</div>

Replying to [@simon-king-jena](#comment:354):
> What do you think about switching back to the old rôle of the arguments

I think it's a bad idea.

Look at the following (now removed) code from you:

```
if other.startswith(self):
    return self
cdef mp_size_t i = biseq_max_overlap(self.data, other.data)
```
Note that the case `i == 0` of `biseq_max_overlap(B, A)` corresponds to `biseq_startswith(A, B)`. An unexpected reordering in my opinion.

In my proposal, the three functions `biseq_startswith`, `biseq_contains` and `biseq_reverse_contains` (whatever the name) all check whether some part of `S1` starts with some part of `S2`. The only thing that changes is which parts of `S1` and `S2` are considered.



---

archive/issue_comments_200245.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nBetter proposal: rename `biseq_reverse_contains` as `biseq_startswith_tail`. I think that's clear: check whether a sequence starts with the tail part of a sequence.",
    "created_at": "2014-12-05T14:37:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200245",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:5" align="right">comment:5</div>

Better proposal: rename `biseq_reverse_contains` as `biseq_startswith_tail`. I think that's clear: check whether a sequence starts with the tail part of a sequence.



---

archive/issue_comments_200246.json:
```json
{
    "body": "Changed commit from **[`0a03d71`](https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718)** to **[`1560ce8`](https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211)**",
    "created_at": "2014-12-05T15:00:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200246",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`0a03d71`](https://github.com/sagemath/sagetrac-mirror/commit/0a03d71d9df26c42cf91dab3df51ca549c434718)** to **[`1560ce8`](https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211)**



---

archive/issue_comments_200247.json:
```json
{
    "body": "<div id=\"comment:6\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211\"><code>1560ce8</code></a></td><td><code>Rename biseq_reverse_contains as biseq_startswith_tail</code></td></tr></table>\n",
    "created_at": "2014-12-05T15:00:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200247",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:6"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211"><code>1560ce8</code></a></td><td><code>Rename biseq_reverse_contains as biseq_startswith_tail</code></td></tr></table>




---

archive/issue_comments_200248.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nOK, I am fine with that change.",
    "created_at": "2014-12-05T15:28:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200248",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:7" align="right">comment:7</div>

OK, I am fine with that change.



---

archive/issue_comments_200249.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nThanks for the support!\n\nFor me, this ticket is positive_review except for the interrupt stuff.",
    "created_at": "2014-12-05T16:09:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200249",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:8" align="right">comment:8</div>

Thanks for the support!

For me, this ticket is positive_review except for the interrupt stuff.



---

archive/issue_comments_200250.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nSince yesterday evening, I tried for about 20 times to push my changes (implementing interrupt stuff). But it doesn't work. Any idea why?\n\nAs usual, the error message is not very helpful:\n\n```\n> git trac push 15820\nPushing to Trac #15820...\nGuessed remote branch: u/SimonKing/ticket/15820\nEnter passphrase for key '/home/king/.ssh/id_rsa': \nTraceback (most recent call last):                                                                               \n  File \"/home/king/bin/git-trac\", line 18, in <module>                                                           \n    cmdline.launch()                                                                                             \n  File \"/home/king/Sage/git/git-trac-command/git_trac/cmdline.py\", line 210, in launch                           \n    app.push(ticket_number, remote=args.remote, force=args.force)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/app.py\", line 194, in push\n    self.repo.push(remote, force)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/git_repository.py\", line 181, in push\n    self.git.echo.push('trac', refspec)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/git_interface.py\", line 341, in meth\n    return self.execute(git_cmd, *args, **kwds)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/git_interface.py\", line 98, in execute\n    popen_stderr=subprocess.PIPE)\n  File \"/home/king/Sage/git/git-trac-command/git_trac/git_interface.py\", line 263, in _run\n    raise GitError(result)\ngit_trac.git_error.GitError\n```\nIs that a problem on my side, or on trac?\n\nAnyway, the diff would be\n\n```diff\ndiff --git a/src/sage/data_structures/bounded_integer_sequences.pyx b/src/sage/data_structures/bounded_integer_sequences.pyx\nindex 7f5e632..ccda54c 100644\n--- a/src/sage/data_structures/bounded_integer_sequences.pyx\n+++ b/src/sage/data_structures/bounded_integer_sequences.pyx\n@@ -124,7 +124,9 @@ cdef bint biseq_init(biseq_t R, mp_size_t l, mp_bitcnt_t itemsize) except -1:\n         totalbitsize = l * itemsize\n     else:\n         totalbitsize = 1\n+    sig_on()\n     bitset_init(R.data, totalbitsize)\n+    sig_off()\n     R.length = l\n     R.itembitsize = itemsize\n     R.mask_item = limb_lower_bits_up(itemsize)\n@@ -140,7 +142,9 @@ cdef bint biseq_init_copy(biseq_t R, biseq_t S) except -1:\n     Initialize ``R`` as a copy of ``S``.\n     \"\"\"\n     biseq_init(R, S.length, S.itembitsize)\n+    sig_on()\n     bitset_copy(R.data, S.data)\n+    sig_off()\n \n #\n # Conversion\n@@ -162,6 +166,7 @@ cdef bint biseq_init_list(biseq_t R, list data, size_t bound) except -1:\n \n     biseq_init(R, len(data), BIT_COUNT(bound|<size_t>1))\n \n+    sig_check()\n     for item in data:\n         item_c = item\n         if item_c > bound:\n@@ -187,8 +192,10 @@ cdef bint biseq_init_concat(biseq_t R, biseq_t S1, biseq_t S2) except -1:\n     The result is written into ``R``, which must not be initialised\n     \"\"\"\n     biseq_init(R, S1.length + S2.length, S1.itembitsize)\n+    sig_on()\n     bitset_lshift(R.data, S2.data, S1.length * S1.itembitsize)\n     bitset_or(R.data, R.data, S1.data)\n+    sig_off()\n \n \n cdef inline bint biseq_startswith(biseq_t S1, biseq_t S2) except -1:\n@@ -207,6 +214,7 @@ cdef inline bint biseq_startswith(biseq_t S1, biseq_t S2) except -1:\n         return False\n     if S2.length == 0:\n         return True\n+    sig_check()\n     return mpn_equal_bits(S1.data.bits, S2.data.bits, S2.data.size)\n \n \n@@ -304,7 +312,9 @@ cdef bint biseq_init_slice(biseq_t R, biseq_t S, mp_size_t start, mp_size_t stop\n \n     if step == 1:\n         # Slicing essentially boils down to a shift operation.\n+        sig_on()\n         bitset_rshift(R.data, S.data, start*S.itembitsize)\n+        sig_off()\n         return 0\n \n     # In the general case, we move item by item.\n@@ -340,6 +350,7 @@ cdef mp_size_t biseq_contains(biseq_t S1, biseq_t S2, mp_size_t start) except -2\n     if S2.length == 0:\n         return start\n     cdef mp_size_t index\n+    sig_check()\n     for index from start <= index <= S1.length-S2.length:\n         if mpn_equal_bits_shifted(S2.data.bits, S1.data.bits,\n                 S2.length*S2.itembitsize, index*S2.itembitsize):\n@@ -373,6 +384,7 @@ cdef mp_size_t biseq_startswith_tail(biseq_t S1, biseq_t S2, mp_size_t start) ex\n     if S1.length < S2.length - start:\n         start = S2.length - S1.length\n     cdef mp_size_t index\n+    sig_check()\n     for index from start <= index < S2.length:\n         if mpn_equal_bits_shifted(S1.data.bits, S2.data.bits,\n                 (S2.length - index)*S2.itembitsize, index*S2.itembitsize):\n@@ -1335,7 +1347,9 @@ cpdef BoundedIntegerSequence NewBISEQ(tuple bitset_data, mp_bitcnt_t itembitsize\n     cdef BoundedIntegerSequence out = BoundedIntegerSequence.__new__(BoundedIntegerSequence)\n     # bitset_unpickle assumes that out.data.data is initialised.\n     biseq_init(out.data, length, itembitsize)\n+    sig_on()\n     bitset_unpickle(out.data.data, bitset_data)\n+    sig_off()\n     return out\n \n def _biseq_stresstest():\n```",
    "created_at": "2014-12-06T08:55:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200250",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:9" align="right">comment:9</div>

Since yesterday evening, I tried for about 20 times to push my changes (implementing interrupt stuff). But it doesn't work. Any idea why?

As usual, the error message is not very helpful:

```
> git trac push 15820
Pushing to Trac #15820...
Guessed remote branch: u/SimonKing/ticket/15820
Enter passphrase for key '/home/king/.ssh/id_rsa': 
Traceback (most recent call last):                                                                               
  File "/home/king/bin/git-trac", line 18, in <module>                                                           
    cmdline.launch()                                                                                             
  File "/home/king/Sage/git/git-trac-command/git_trac/cmdline.py", line 210, in launch                           
    app.push(ticket_number, remote=args.remote, force=args.force)
  File "/home/king/Sage/git/git-trac-command/git_trac/app.py", line 194, in push
    self.repo.push(remote, force)
  File "/home/king/Sage/git/git-trac-command/git_trac/git_repository.py", line 181, in push
    self.git.echo.push('trac', refspec)
  File "/home/king/Sage/git/git-trac-command/git_trac/git_interface.py", line 341, in meth
    return self.execute(git_cmd, *args, **kwds)
  File "/home/king/Sage/git/git-trac-command/git_trac/git_interface.py", line 98, in execute
    popen_stderr=subprocess.PIPE)
  File "/home/king/Sage/git/git-trac-command/git_trac/git_interface.py", line 263, in _run
    raise GitError(result)
git_trac.git_error.GitError
```
Is that a problem on my side, or on trac?

Anyway, the diff would be

```diff
diff --git a/src/sage/data_structures/bounded_integer_sequences.pyx b/src/sage/data_structures/bounded_integer_sequences.pyx
index 7f5e632..ccda54c 100644
--- a/src/sage/data_structures/bounded_integer_sequences.pyx
+++ b/src/sage/data_structures/bounded_integer_sequences.pyx
@@ -124,7 +124,9 @@ cdef bint biseq_init(biseq_t R, mp_size_t l, mp_bitcnt_t itemsize) except -1:
         totalbitsize = l * itemsize
     else:
         totalbitsize = 1
+    sig_on()
     bitset_init(R.data, totalbitsize)
+    sig_off()
     R.length = l
     R.itembitsize = itemsize
     R.mask_item = limb_lower_bits_up(itemsize)
@@ -140,7 +142,9 @@ cdef bint biseq_init_copy(biseq_t R, biseq_t S) except -1:
     Initialize ``R`` as a copy of ``S``.
     """
     biseq_init(R, S.length, S.itembitsize)
+    sig_on()
     bitset_copy(R.data, S.data)
+    sig_off()
 
 #
 # Conversion
@@ -162,6 +166,7 @@ cdef bint biseq_init_list(biseq_t R, list data, size_t bound) except -1:
 
     biseq_init(R, len(data), BIT_COUNT(bound|<size_t>1))
 
+    sig_check()
     for item in data:
         item_c = item
         if item_c > bound:
@@ -187,8 +192,10 @@ cdef bint biseq_init_concat(biseq_t R, biseq_t S1, biseq_t S2) except -1:
     The result is written into ``R``, which must not be initialised
     """
     biseq_init(R, S1.length + S2.length, S1.itembitsize)
+    sig_on()
     bitset_lshift(R.data, S2.data, S1.length * S1.itembitsize)
     bitset_or(R.data, R.data, S1.data)
+    sig_off()
 
 
 cdef inline bint biseq_startswith(biseq_t S1, biseq_t S2) except -1:
@@ -207,6 +214,7 @@ cdef inline bint biseq_startswith(biseq_t S1, biseq_t S2) except -1:
         return False
     if S2.length == 0:
         return True
+    sig_check()
     return mpn_equal_bits(S1.data.bits, S2.data.bits, S2.data.size)
 
 
@@ -304,7 +312,9 @@ cdef bint biseq_init_slice(biseq_t R, biseq_t S, mp_size_t start, mp_size_t stop
 
     if step == 1:
         # Slicing essentially boils down to a shift operation.
+        sig_on()
         bitset_rshift(R.data, S.data, start*S.itembitsize)
+        sig_off()
         return 0
 
     # In the general case, we move item by item.
@@ -340,6 +350,7 @@ cdef mp_size_t biseq_contains(biseq_t S1, biseq_t S2, mp_size_t start) except -2
     if S2.length == 0:
         return start
     cdef mp_size_t index
+    sig_check()
     for index from start <= index <= S1.length-S2.length:
         if mpn_equal_bits_shifted(S2.data.bits, S1.data.bits,
                 S2.length*S2.itembitsize, index*S2.itembitsize):
@@ -373,6 +384,7 @@ cdef mp_size_t biseq_startswith_tail(biseq_t S1, biseq_t S2, mp_size_t start) ex
     if S1.length < S2.length - start:
         start = S2.length - S1.length
     cdef mp_size_t index
+    sig_check()
     for index from start <= index < S2.length:
         if mpn_equal_bits_shifted(S1.data.bits, S2.data.bits,
                 (S2.length - index)*S2.itembitsize, index*S2.itembitsize):
@@ -1335,7 +1347,9 @@ cpdef BoundedIntegerSequence NewBISEQ(tuple bitset_data, mp_bitcnt_t itembitsize
     cdef BoundedIntegerSequence out = BoundedIntegerSequence.__new__(BoundedIntegerSequence)
     # bitset_unpickle assumes that out.data.data is initialised.
     biseq_init(out.data, length, itembitsize)
+    sig_on()
     bitset_unpickle(out.data.data, bitset_data)
+    sig_off()
     return out
 
 def _biseq_stresstest():
```



---

archive/issue_comments_200251.json:
```json
{
    "body": "<div id=\"comment:0\" align=\"right\">comment:0</div>\n\nI can't help with git...",
    "created_at": "2014-12-06T09:58:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200251",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:0" align="right">comment:0</div>

I can't help with git...



---

archive/issue_comments_200252.json:
```json
{
    "body": "<div id=\"comment:1\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184\"><code>4e9e1c5</code></a></td><td><code>Add interrupt handling to bounded integer sequences</code></td></tr></table>\n",
    "created_at": "2014-12-06T11:54:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200252",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:1"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184"><code>4e9e1c5</code></a></td><td><code>Add interrupt handling to bounded integer sequences</code></td></tr></table>




---

archive/issue_comments_200253.json:
```json
{
    "body": "Changed commit from **[`1560ce8`](https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211)** to **[`4e9e1c5`](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)**",
    "created_at": "2014-12-06T11:54:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200253",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`1560ce8`](https://github.com/sagemath/sagetrac-mirror/commit/1560ce8dff16ed1fceabcc5656312f718d874211)** to **[`4e9e1c5`](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)**



---

archive/issue_events_225953.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-12-06T11:54:56Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225953"
}
```



---

archive/issue_events_225954.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-12-06T11:54:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225954"
}
```



---

archive/issue_comments_200254.json:
```json
{
    "body": "Changed work issues from **interrupt handling** to none",
    "created_at": "2014-12-06T11:54:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200254",
    "user": "https://github.com/jdemeyer"
}
```

Changed work issues from **interrupt handling** to none



---

archive/issue_comments_200255.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nQuestions:\n\n- Is the stresstest really running forever?? It is supposed to take few seconds. I will test in a few minutes.\n- When should one use `sig_check()` and when `sig_on()/sig_off()`? I thought it is `sig_check()` when it could happen that an error or a return may happen that is not caused by a keyboard interrupt. But perhaps I am mistaken.",
    "created_at": "2014-12-06T12:25:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200255",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:3" align="right">comment:3</div>

Questions:

- Is the stresstest really running forever?? It is supposed to take few seconds. I will test in a few minutes.
- When should one use `sig_check()` and when `sig_on()/sig_off()`? I thought it is `sig_check()` when it could happen that an error or a return may happen that is not caused by a keyboard interrupt. But perhaps I am mistaken.



---

archive/issue_comments_200256.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nAha, I see! You really changed the stress test so that it *would* run forever, but test that it can be interrupted. Good idea!",
    "created_at": "2014-12-06T12:27:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200256",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:4" align="right">comment:4</div>

Aha, I see! You really changed the stress test so that it *would* run forever, but test that it can be interrupted. Good idea!



---

archive/issue_comments_200257.json:
```json
{
    "body": "<div id=\"comment:375\" align=\"right\">comment:375</div>\n\nReplying to [@simon-king-jena](#comment:374):\n> Aha, I see! You really changed the stress test so that it *would* run forever, but test that it can be interrupted. Good idea!\n\nUnfortunately it does NOT test that bounded integer sequence operations are interruptible. I tested a couple of times, and the exception always occurs in the randint function.",
    "created_at": "2014-12-06T12:29:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200257",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:375" align="right">comment:375</div>

Replying to [@simon-king-jena](#comment:374):
> Aha, I see! You really changed the stress test so that it *would* run forever, but test that it can be interrupted. Good idea!

Unfortunately it does NOT test that bounded integer sequence operations are interruptible. I tested a couple of times, and the exception always occurs in the randint function.



---

archive/issue_comments_200258.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nShould we address the interrupt test in a different way? If not, I think it is a positive review from my side. But I'd appreciate if you could answer my question on sig_on/sig_off vs. sig_check.",
    "created_at": "2014-12-06T12:31:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200258",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:6" align="right">comment:6</div>

Should we address the interrupt test in a different way? If not, I think it is a positive review from my side. But I'd appreciate if you could answer my question on sig_on/sig_off vs. sig_check.



---

archive/issue_comments_200259.json:
```json
{
    "body": "<div id=\"comment:377\" align=\"right\">comment:377</div>\n\nReplying to [@simon-king-jena](#comment:375):\n> Unfortunately it does NOT test that bounded integer sequence operations are interruptible. I tested a couple of times, and the exception always occurs in the randint function.\n\nI also tested a bit more and the exception indeed happens most often in `randint()` but also sometimes in other places.",
    "created_at": "2014-12-06T12:52:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200259",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:377" align="right">comment:377</div>

Replying to [@simon-king-jena](#comment:375):
> Unfortunately it does NOT test that bounded integer sequence operations are interruptible. I tested a couple of times, and the exception always occurs in the randint function.

I also tested a bit more and the exception indeed happens most often in `randint()` but also sometimes in other places.



---

archive/issue_comments_200260.json:
```json
{
    "body": "<div id=\"comment:378\" align=\"right\">comment:378</div>\n\nReplying to [@simon-king-jena](#comment:373):\n> - When should one use `sig_check()` and when `sig_on()/sig_off()`?\n\nDoes [http://www.sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling](http://www.sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling) answer your question?",
    "created_at": "2014-12-06T12:54:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200260",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:378" align="right">comment:378</div>

Replying to [@simon-king-jena](#comment:373):
> - When should one use `sig_check()` and when `sig_on()/sig_off()`?

Does [http://www.sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling](http://www.sagemath.org/doc/developer/coding_in_cython.html#interrupt-and-signal-handling) answer your question?



---

archive/issue_comments_200261.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nShould we add tests in the spirit of this:\n\n```\nsage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence\nsage: B = BoundedIntegerSequence(4,[1,2,3,2,3,2,3])\nsage: while 1:\n....:     C = B+B\n....:     \n^C---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\n<ipython-input-3-dda173c83bbe> in <module>()\n----> 1 while Integer(1):\n      2     C = B+B\n      3 \n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sage_python_check_interrupt (build/cythonized/sage/ext/c_lib.c:1683)()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sig_raise_exception (build/cythonized/sage/ext/c_lib.c:769)()\n\nKeyboardInterrupt: \nsage: while 1:\n    C = B+B\n....:     \n^C---------------------------------------------------------------------------\nKeyboardInterrupt                         Traceback (most recent call last)\n<ipython-input-4-dda173c83bbe> in <module>()\n      1 while Integer(1):\n----> 2     C = B+B\n      3 \n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.BoundedIntegerSequence.__add__ (build/cythonized/sage/data_structures/bounded_integer_sequences.c:10964)()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.biseq_init_concat (build/cythonized/sage/data_structures/bounded_integer_sequences.c:7632)()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sig_raise_exception (build/cythonized/sage/ext/c_lib.c:769)()\n\nKeyboardInterrupt: \n```\nAs you can see, the interruption occurs in the correct place already in the second try.",
    "created_at": "2014-12-06T12:55:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200261",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:9" align="right">comment:9</div>

Should we add tests in the spirit of this:

```
sage: from sage.data_structures.bounded_integer_sequences import BoundedIntegerSequence
sage: B = BoundedIntegerSequence(4,[1,2,3,2,3,2,3])
sage: while 1:
....:     C = B+B
....:     
^C---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
<ipython-input-3-dda173c83bbe> in <module>()
----> 1 while Integer(1):
      2     C = B+B
      3 

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sage_python_check_interrupt (build/cythonized/sage/ext/c_lib.c:1683)()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sig_raise_exception (build/cythonized/sage/ext/c_lib.c:769)()

KeyboardInterrupt: 
sage: while 1:
    C = B+B
....:     
^C---------------------------------------------------------------------------
KeyboardInterrupt                         Traceback (most recent call last)
<ipython-input-4-dda173c83bbe> in <module>()
      1 while Integer(1):
----> 2     C = B+B
      3 

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.BoundedIntegerSequence.__add__ (build/cythonized/sage/data_structures/bounded_integer_sequences.c:10964)()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/data_structures/bounded_integer_sequences.so in sage.data_structures.bounded_integer_sequences.biseq_init_concat (build/cythonized/sage/data_structures/bounded_integer_sequences.c:7632)()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/ext/c_lib.so in sage.ext.c_lib.sig_raise_exception (build/cythonized/sage/ext/c_lib.c:769)()

KeyboardInterrupt: 
```
As you can see, the interruption occurs in the correct place already in the second try.



---

archive/issue_comments_200262.json:
```json
{
    "body": "<div id=\"comment:380\" align=\"right\">comment:380</div>\n\nReplying to [@simon-king-jena](#comment:379):\n> Should we add tests in the spirit of this:\n\nWe could, but I'm not sure it is worth the trouble.",
    "created_at": "2014-12-06T13:10:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200262",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:380" align="right">comment:380</div>

Replying to [@simon-king-jena](#comment:379):
> Should we add tests in the spirit of this:

We could, but I'm not sure it is worth the trouble.



---

archive/issue_events_225955.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-12-06T13:26:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225955"
}
```



---

archive/issue_events_225956.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2014-12-06T13:26:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225956"
}
```



---

archive/issue_comments_200263.json:
```json
{
    "body": "<div id=\"comment:381\" align=\"right\">comment:381</div>\n\nReplying to [@jdemeyer](#comment:380):\n> Replying to [@simon-king-jena](#comment:379):\n> > Should we add tests in the spirit of this:\n\n> We could, but I'm not sure it is worth the trouble.\n\nThen I guess I can set this to positive review, right?",
    "created_at": "2014-12-06T13:26:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200263",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:381" align="right">comment:381</div>

Replying to [@jdemeyer](#comment:380):
> Replying to [@simon-king-jena](#comment:379):
> > Should we add tests in the spirit of this:

> We could, but I'm not sure it is worth the trouble.

Then I guess I can set this to positive review, right?



---

archive/issue_comments_200264.json:
```json
{
    "body": "Changed branch from **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)** to **[`4e9e1c5`](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)**",
    "created_at": "2014-12-12T12:29:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200264",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[u/jdemeyer/ticket/15820](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/ticket/15820)** to **[`4e9e1c5`](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)**



---

archive/issue_events_225957.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-12-12T12:29:50Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225957"
}
```



---

archive/issue_events_225958.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "bd0df0ed904d3f5fe77dfdec15064ab06cb06b2f",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2014-12-12T12:29:50Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15820#event-225958"
}
```



---

archive/issue_comments_200265.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nI just saw this ticket on the trac timeline, i wonder whether two similar objects are being developed in parallel by disjoint sets of people, see #17013.",
    "created_at": "2014-12-13T17:07:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200265",
    "user": "https://github.com/sagetrac-tmonteil"
}
```

<div id="comment:3" align="right">comment:3</div>

I just saw this ticket on the trac timeline, i wonder whether two similar objects are being developed in parallel by disjoint sets of people, see #17013.



---

archive/issue_comments_200266.json:
```json
{
    "body": "Changed commit from **[`4e9e1c5`](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)** to none",
    "created_at": "2014-12-13T17:07:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200266",
    "user": "https://github.com/sagetrac-tmonteil"
}
```

Changed commit from **[`4e9e1c5`](https://github.com/sagemath/sagetrac-mirror/commit/4e9e1c51f6524bfa2d2c55d197b82a983dd01184)** to none



---

archive/issue_comments_200267.json:
```json
{
    "body": "<div id=\"comment:384\" align=\"right\">comment:384</div>\n\nReplying to [@sagetrac-tmonteil](#comment:383):\n> I just saw this ticket on the trac timeline, i wonder whether two similar objects are being developed in parallel by disjoint sets of people, see #17013.\n\nIndeed there is an obvious overlap. If I understand correctly, #17013 uses `char *` as underlying data structure, which means they are restricted to an alphabet of length at most 255. I have experimented with a similar implementation, too, but found that an implementation based on gmp gives better speed than what I was able to obtain with `char*`.",
    "created_at": "2014-12-13T23:21:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15820",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15820#issuecomment-200267",
    "user": "https://github.com/simon-king-jena"
}
```

<div id="comment:384" align="right">comment:384</div>

Replying to [@sagetrac-tmonteil](#comment:383):
> I just saw this ticket on the trac timeline, i wonder whether two similar objects are being developed in parallel by disjoint sets of people, see #17013.

Indeed there is an obvious overlap. If I understand correctly, #17013 uses `char *` as underlying data structure, which means they are restricted to an alphabet of length at most 255. I have experimented with a similar implementation, too, but found that an implementation based on gmp gives better speed than what I was able to obtain with `char*`.
