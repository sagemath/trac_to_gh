# Issue 15998: Restore some documentation and doctests and a function removed with #15466

archive/issues_015761.json:
```json
{
    "assignees": [],
    "body": "There isn't much of it (the function in question is a GAP wrapper), but I prefer it if functionality wouldn't disappear.\n\nCC:  @tscrim @AndrewAtLarge @nathanncohen @sagetrac-sage-combinat\n\nBranch/Commit: **[`da4bf10`](https://github.com/sagemath/sagetrac-mirror/commit/da4bf10359d8a23746de8647904ba2c389f61d59)**\n\nReviewer: **Nathann Cohen, Travis Scrimshaw**\n\nAuthor: **Darij Grinberg**\n\nComponent: **combinatorics**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/15998_\n\n",
    "closed_at": "2014-04-01T16:54:12Z",
    "created_at": "2014-03-21T05:44:42Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20combinatorics",
        "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.2",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Restore some documentation and doctests and a function removed with #15466",
    "type": "issue",
    "updated_at": "2014-04-01T16:54:12Z",
    "url": "https://github.com/sagemath/sage/issues/15998",
    "user": "https://github.com/darijgr"
}
```
There isn't much of it (the function in question is a GAP wrapper), but I prefer it if functionality wouldn't disappear.

CC:  @tscrim @AndrewAtLarge @nathanncohen @sagetrac-sage-combinat

Branch/Commit: **[`da4bf10`](https://github.com/sagemath/sagetrac-mirror/commit/da4bf10359d8a23746de8647904ba2c389f61d59)**

Reviewer: **Nathann Cohen, Travis Scrimshaw**

Author: **Darij Grinberg**

Component: **combinatorics**

_Issue created by migration from https://trac.sagemath.org/ticket/15998_





---

archive/issue_events_228345.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-03-21T05:44:42Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "milestone_number": null,
    "milestone_title": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228345"
}
```



---

archive/issue_events_228346.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-03-21T05:44:42Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20combinatorics",
    "label_color": "0000ff",
    "label_name": "c: combinatorics",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228346"
}
```



---

archive/issue_events_228347.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-03-21T05:44:42Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p: 3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228347"
}
```



---

archive/issue_events_228348.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-03-21T05:44:42Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228348"
}
```



---

archive/issue_comments_203084.json:
```json
{
    "body": "Changed commit from **[`4af1db4`](https://github.com/sagemath/sagetrac-mirror/commit/4af1db4127a19fcc3dda99010ac962905ebecb9e)** to **[`3cda807`](https://github.com/sagemath/sagetrac-mirror/commit/3cda807d8227c794f798a5432289b27200b870cb)**",
    "created_at": "2014-03-21T05:52:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203084",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`4af1db4`](https://github.com/sagemath/sagetrac-mirror/commit/4af1db4127a19fcc3dda99010ac962905ebecb9e)** to **[`3cda807`](https://github.com/sagemath/sagetrac-mirror/commit/3cda807d8227c794f798a5432289b27200b870cb)**



---

archive/issue_comments_203085.json:
```json
{
    "body": "<div id=\"comment:1\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3cda807d8227c794f798a5432289b27200b870cb\">3cda807</a></td><td><code>fix own blunders</code></td></tr></table>\n",
    "created_at": "2014-03-21T05:52:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203085",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:1"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3cda807d8227c794f798a5432289b27200b870cb">3cda807</a></td><td><code>fix own blunders</code></td></tr></table>




---

archive/issue_events_228349.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-03-21T05:53:07Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228349"
}
```



---

archive/issue_comments_203086.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nHmmmmm.... The deprecated code from #15466 said to use something different from GAP :\n\n```\ndeprecation(13072,'sage.combinat.number_of_partitions(size, level) is deprecated. Use PartitionTuples(level, size).cardinality() instead.')\nans=gap.eval(\"NrPartitions(%s,%s)\"%(ZZ(n),ZZ(k)))\n```\n\nNathann",
    "created_at": "2014-03-21T06:43:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203086",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:3" align="right">comment:3</div>

Hmmmmm.... The deprecated code from #15466 said to use something different from GAP :

```
deprecation(13072,'sage.combinat.number_of_partitions(size, level) is deprecated. Use PartitionTuples(level, size).cardinality() instead.')
ans=gap.eval("NrPartitions(%s,%s)"%(ZZ(n),ZZ(k)))
```

Nathann



---

archive/issue_comments_203087.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nAlso for the number of partitions of a particular length:\n\n```\nsage: P = Partitions(20, length=3); P\nPartitions of the integer 20 satisfying constraints length=3\nsage: P.cardinality()\n33\n```\nwhich could potentially be optimized. I haven't run timings, so IDK if there would even be such a need to.",
    "created_at": "2014-03-21T14:20:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203087",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:4" align="right">comment:4</div>

Also for the number of partitions of a particular length:

```
sage: P = Partitions(20, length=3); P
Partitions of the integer 20 satisfying constraints length=3
sage: P.cardinality()
33
```
which could potentially be optimized. I haven't run timings, so IDK if there would even be such a need to.



---

archive/issue_comments_203088.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\n@nathanncohen: Wasn't it you who pointed out on the mailing list a while ago that the deprecation message was wrong? This has nothing to do with `PartitionTuples` and, as far as I know, the functionality isn't anywhere in Sage. The other deprecation messages aren't any more reliable (there was a method whose deprecation message pointed to itself).\n\n@tscrim: What you're doing currently computes the cardinality by iterating through all of these partitions. This doesn't scale *at all*. I've thought about overshadowing `cardinality`, but then I would need to make a new class for partitions of given size and given length; is that worth the hassle? (Also, I feel that module-level functions can sometimes be better than class methods: imagine having to build tons of classes to compute several values of the partition function...)",
    "created_at": "2014-03-21T15:40:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203088",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:5" align="right">comment:5</div>

@nathanncohen: Wasn't it you who pointed out on the mailing list a while ago that the deprecation message was wrong? This has nothing to do with `PartitionTuples` and, as far as I know, the functionality isn't anywhere in Sage. The other deprecation messages aren't any more reliable (there was a method whose deprecation message pointed to itself).

@tscrim: What you're doing currently computes the cardinality by iterating through all of these partitions. This doesn't scale *at all*. I've thought about overshadowing `cardinality`, but then I would need to make a new class for partitions of given size and given length; is that worth the hassle? (Also, I feel that module-level functions can sometimes be better than class methods: imagine having to build tons of classes to compute several values of the partition function...)



---

archive/issue_comments_203089.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nWell, it depends on how fast GAP is. Do you know if GAP has some special algorithm for computing the number of partitions of (at most) a given length or any such algorithm/paper? I'll also think about ways to do this today too.",
    "created_at": "2014-03-21T17:58:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203089",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:6" align="right">comment:6</div>

Well, it depends on how fast GAP is. Do you know if GAP has some special algorithm for computing the number of partitions of (at most) a given length or any such algorithm/paper? I'll also think about ways to do this today too.



---

archive/issue_comments_203090.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nGAP is faster than counting by the iterator; try n=500 and k=3 or likewise. I don't know how it would compare to a native Python implementation, though. Thanks for thinking about this!",
    "created_at": "2014-03-21T18:01:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203090",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:7" align="right">comment:7</div>

GAP is faster than counting by the iterator; try n=500 and k=3 or likewise. I don't know how it would compare to a native Python implementation, though. Thanks for thinking about this!



---

archive/issue_comments_203091.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\n> @nathanncohen: Wasn't it you who pointed out on the mailing list a while ago that the deprecation message was wrong?\n\nOh ? It's possible, sorry. I totally forgot about this `^^;`\n\nNathann",
    "created_at": "2014-03-21T21:20:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203091",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:8" align="right">comment:8</div>

> @nathanncohen: Wasn't it you who pointed out on the mailing list a while ago that the deprecation message was wrong?

Oh ? It's possible, sorry. I totally forgot about this `^^;`

Nathann



---

archive/issue_comments_203092.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nReplying to [@darijgr](#comment:5):\n> @nathanncohen: Wasn't it you who pointed out on the mailing list a while ago that the deprecation message was wrong? This has nothing to do with `PartitionTuples` and, as far as I know, the functionality isn't anywhere in Sage. The other deprecation messages aren't any more reliable (there was a method whose deprecation message pointed to itself).\n\n\nSorry, this was my fault: I misunderstood what these functions were returning/computing.\n\nA.",
    "created_at": "2014-03-25T00:19:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203092",
    "user": "https://github.com/AndrewAtLarge"
}
```

<div id="comment:9" align="right">comment:9</div>

Replying to [@darijgr](#comment:5):
> @nathanncohen: Wasn't it you who pointed out on the mailing list a while ago that the deprecation message was wrong? This has nothing to do with `PartitionTuples` and, as far as I know, the functionality isn't anywhere in Sage. The other deprecation messages aren't any more reliable (there was a method whose deprecation message pointed to itself).


Sorry, this was my fault: I misunderstood what these functions were returning/computing.

A.



---

archive/issue_events_228350.json:
```json
{
    "actor": "https://github.com/nathanncohen",
    "created_at": "2014-03-26T09:27:40Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228350"
}
```



---

archive/issue_events_228351.json:
```json
{
    "actor": "https://github.com/nathanncohen",
    "created_at": "2014-03-26T09:27:40Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228351"
}
```



---

archive/issue_comments_203093.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nHellooooooo Darij ! I agree with what I see in your patch, but like Travis I would have tried to obtain this result through `Partitions(n, length=k).cardinality()`.\n\nI personally hate objects, so I perfectly understand that you may not want to create all these things if you do not need it, but if you implement it like that there will be two ways to obtain the same thing, one of which you would not use yourself because it is too slow.\n\nWhat would you think of creating this very short class whose cardinality method would be the function you add ?\n\nOr even better: couldn't you create a cardinality method in the current \"partitions\" object, which would either check that \"length\" is the only argument and call your function in that case, and otherwise call the  inherited version of \"cardinality\" (which takes a lifetime anyway ?).\n\nThis way, no class to create.\n\nBy the way, it seems that this file contains code deprecated by 13072, which is more than 1 year old.\n\nHave fuuuuuuuuun !\n\nNathann",
    "created_at": "2014-03-26T09:27:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203093",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:10" align="right">comment:10</div>

Hellooooooo Darij ! I agree with what I see in your patch, but like Travis I would have tried to obtain this result through `Partitions(n, length=k).cardinality()`.

I personally hate objects, so I perfectly understand that you may not want to create all these things if you do not need it, but if you implement it like that there will be two ways to obtain the same thing, one of which you would not use yourself because it is too slow.

What would you think of creating this very short class whose cardinality method would be the function you add ?

Or even better: couldn't you create a cardinality method in the current "partitions" object, which would either check that "length" is the only argument and call your function in that case, and otherwise call the  inherited version of "cardinality" (which takes a lifetime anyway ?).

This way, no class to create.

By the way, it seems that this file contains code deprecated by 13072, which is more than 1 year old.

Have fuuuuuuuuun !

Nathann



---

archive/issue_comments_203094.json:
```json
{
    "body": "Changed commit from **[`3cda807`](https://github.com/sagemath/sagetrac-mirror/commit/3cda807d8227c794f798a5432289b27200b870cb)** to **[`1c4454f`](https://github.com/sagemath/sagetrac-mirror/commit/1c4454fad5d281acb2f5d51e57182cef16829e2d)**",
    "created_at": "2014-03-27T01:53:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203094",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`3cda807`](https://github.com/sagemath/sagetrac-mirror/commit/3cda807d8227c794f798a5432289b27200b870cb)** to **[`1c4454f`](https://github.com/sagemath/sagetrac-mirror/commit/1c4454fad5d281acb2f5d51e57182cef16829e2d)**



---

archive/issue_comments_203095.json:
```json
{
    "body": "<div id=\"comment:11\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/55fcbff2dc3ff1e4f9958dbf0f8b9a01b07da0c8\">55fcbff</a></td><td><code>Merge branch 'public/combinat/re-15466' of git://trac.sagemath.org/sage into re-dep</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1c4454fad5d281acb2f5d51e57182cef16829e2d\">1c4454f</a></td><td><code>New class for partitions with given length, with a faster iterator and calling GAP for cardinality.</code></td></tr></table>\n",
    "created_at": "2014-03-27T01:53:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203095",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:11"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/55fcbff2dc3ff1e4f9958dbf0f8b9a01b07da0c8">55fcbff</a></td><td><code>Merge branch 'public/combinat/re-15466' of git://trac.sagemath.org/sage into re-dep</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1c4454fad5d281acb2f5d51e57182cef16829e2d">1c4454f</a></td><td><code>New class for partitions with given length, with a faster iterator and calling GAP for cardinality.</code></td></tr></table>




---

archive/issue_events_228352.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-03-27T01:54:04Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228352"
}
```



---

archive/issue_events_228353.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-03-27T01:54:04Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228353"
}
```



---

archive/issue_comments_203096.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nDone!\n\nLittle bonus:\n\nbefore:\n\n```\nsage: %timeit Partitions(2, length=1).list()\n1000 loops, best of 3: 187 \u00b5s per loop\nsage: %timeit Partitions(5, length=1).list()\n1000 loops, best of 3: 200 \u00b5s per loop\nsage: %timeit Partitions(5, length=2).list()\n1000 loops, best of 3: 340 \u00b5s per loop\nsage: %timeit Partitions(7, length=2).list()\n1000 loops, best of 3: 472 \u00b5s per loop\nsage: %timeit Partitions(7, length=4).list()\n1000 loops, best of 3: 623 \u00b5s per loop\nsage: %timeit Partitions(7, length=6).list()\n1000 loops, best of 3: 336 \u00b5s per loop\nsage: %timeit Partitions(14, length=1).list()\n1000 loops, best of 3: 187 \u00b5s per loop\nsage: %timeit Partitions(14, length=4).list()\n100 loops, best of 3: 3.36 ms per loop\nsage: %timeit Partitions(14, length=8).list()\n100 loops, best of 3: 2.46 ms per loop\nsage: %timeit Partitions(14, length=12).list()\n1000 loops, best of 3: 621 \u00b5s per loop\nsage: %timeit Partitions(30, length=2).list()\n1000 loops, best of 3: 1.57 ms per loop\nsage: %timeit Partitions(30, length=5).list()\n10 loops, best of 3: 54.6 ms per loop\nsage: %timeit Partitions(30, length=10).list()\n10 loops, best of 3: 131 ms per loop\nsage: %timeit Partitions(30, length=20).list()\n10 loops, best of 3: 15.9 ms per loop\nsage: %timeit Partitions(60, length=2).list()\n100 loops, best of 3: 2.89 ms per loop\nsage: %timeit Partitions(60, length=5).list()\n1 loops, best of 3: 682 ms per loop\nsage: %timeit Partitions(60, length=40).list()\n1 loops, best of 3: 413 ms per loop\nsage: %timeit Partitions(100, length=2).list()\n100 loops, best of 3: 5.31 ms per loop\nsage: %timeit Partitions(200, length=2).list()\n100 loops, best of 3: 9.97 ms per loop\nsage: %timeit Partitions(300, length=3).list()\n1 loops, best of 3: 821 ms per loop\nsage: %timeit Partitions(300, length=280).list()\n1 loops, best of 3: 2.47 s per loop\n```\n\nafter:\n\n```\nsage: %timeit Partitions(2, length=1).list()\n10000 loops, best of 3: 19.5 \u00b5s per loop\nsage: %timeit Partitions(5, length=1).list()\n100000 loops, best of 3: 16 \u00b5s per loop\nsage: %timeit Partitions(5, length=2).list()\n10000 loops, best of 3: 19.4 \u00b5s per loop\nsage: %timeit Partitions(7, length=2).list()\n10000 loops, best of 3: 16.2 \u00b5s per loop\nsage: %timeit Partitions(7, length=4).list()\n100000 loops, best of 3: 16 \u00b5s per loop\nsage: %timeit Partitions(7, length=6).list()\n10000 loops, best of 3: 19.5 \u00b5s per loop\nsage: %timeit Partitions(14, length=1).list()\n10000 loops, best of 3: 16.1 \u00b5s per loop\nsage: %timeit Partitions(14, length=4).list()\n100000 loops, best of 3: 16.3 \u00b5s per loop\nsage: %timeit Partitions(14, length=8).list()\n100000 loops, best of 3: 17.6 \u00b5s per loop\nsage: %timeit Partitions(14, length=12).list()\n100000 loops, best of 3: 16.1 \u00b5s per loop\nsage: %timeit Partitions(30, length=2).list()\n10000 loops, best of 3: 19.3 \u00b5s per loop\nsage: %timeit Partitions(30, length=5).list()\n10000 loops, best of 3: 20.8 \u00b5s per loop\nsage: %timeit Partitions(30, length=10).list()\n10000 loops, best of 3: 20 \u00b5s per loop\nsage: %timeit Partitions(30, length=20).list()\n100000 loops, best of 3: 18 \u00b5s per loop\nsage: %timeit Partitions(60, length=2).list()\n100000 loops, best of 3: 16.2 \u00b5s per loop\nsage: %timeit Partitions(60, length=5).list()\n10000 loops, best of 3: 58 \u00b5s per loop\nsage: %timeit Partitions(60, length=40).list()\n10000 loops, best of 3: 23.5 \u00b5s per loop\nsage: %timeit Partitions(100, length=2).list()\n100000 loops, best of 3: 16.6 \u00b5s per loop\nsage: %timeit Partitions(200, length=2).list()\n10000 loops, best of 3: 20.3 \u00b5s per loop\nsage: %timeit Partitions(300, length=3).list()\n10000 loops, best of 3: 77.2 \u00b5s per loop\nsage: %timeit Partitions(300, length=280).list()\n1 loops, best of 3: 283 ms per loop\n```",
    "created_at": "2014-03-27T01:54:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203096",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:12" align="right">comment:12</div>

Done!

Little bonus:

before:

```
sage: %timeit Partitions(2, length=1).list()
1000 loops, best of 3: 187 µs per loop
sage: %timeit Partitions(5, length=1).list()
1000 loops, best of 3: 200 µs per loop
sage: %timeit Partitions(5, length=2).list()
1000 loops, best of 3: 340 µs per loop
sage: %timeit Partitions(7, length=2).list()
1000 loops, best of 3: 472 µs per loop
sage: %timeit Partitions(7, length=4).list()
1000 loops, best of 3: 623 µs per loop
sage: %timeit Partitions(7, length=6).list()
1000 loops, best of 3: 336 µs per loop
sage: %timeit Partitions(14, length=1).list()
1000 loops, best of 3: 187 µs per loop
sage: %timeit Partitions(14, length=4).list()
100 loops, best of 3: 3.36 ms per loop
sage: %timeit Partitions(14, length=8).list()
100 loops, best of 3: 2.46 ms per loop
sage: %timeit Partitions(14, length=12).list()
1000 loops, best of 3: 621 µs per loop
sage: %timeit Partitions(30, length=2).list()
1000 loops, best of 3: 1.57 ms per loop
sage: %timeit Partitions(30, length=5).list()
10 loops, best of 3: 54.6 ms per loop
sage: %timeit Partitions(30, length=10).list()
10 loops, best of 3: 131 ms per loop
sage: %timeit Partitions(30, length=20).list()
10 loops, best of 3: 15.9 ms per loop
sage: %timeit Partitions(60, length=2).list()
100 loops, best of 3: 2.89 ms per loop
sage: %timeit Partitions(60, length=5).list()
1 loops, best of 3: 682 ms per loop
sage: %timeit Partitions(60, length=40).list()
1 loops, best of 3: 413 ms per loop
sage: %timeit Partitions(100, length=2).list()
100 loops, best of 3: 5.31 ms per loop
sage: %timeit Partitions(200, length=2).list()
100 loops, best of 3: 9.97 ms per loop
sage: %timeit Partitions(300, length=3).list()
1 loops, best of 3: 821 ms per loop
sage: %timeit Partitions(300, length=280).list()
1 loops, best of 3: 2.47 s per loop
```

after:

```
sage: %timeit Partitions(2, length=1).list()
10000 loops, best of 3: 19.5 µs per loop
sage: %timeit Partitions(5, length=1).list()
100000 loops, best of 3: 16 µs per loop
sage: %timeit Partitions(5, length=2).list()
10000 loops, best of 3: 19.4 µs per loop
sage: %timeit Partitions(7, length=2).list()
10000 loops, best of 3: 16.2 µs per loop
sage: %timeit Partitions(7, length=4).list()
100000 loops, best of 3: 16 µs per loop
sage: %timeit Partitions(7, length=6).list()
10000 loops, best of 3: 19.5 µs per loop
sage: %timeit Partitions(14, length=1).list()
10000 loops, best of 3: 16.1 µs per loop
sage: %timeit Partitions(14, length=4).list()
100000 loops, best of 3: 16.3 µs per loop
sage: %timeit Partitions(14, length=8).list()
100000 loops, best of 3: 17.6 µs per loop
sage: %timeit Partitions(14, length=12).list()
100000 loops, best of 3: 16.1 µs per loop
sage: %timeit Partitions(30, length=2).list()
10000 loops, best of 3: 19.3 µs per loop
sage: %timeit Partitions(30, length=5).list()
10000 loops, best of 3: 20.8 µs per loop
sage: %timeit Partitions(30, length=10).list()
10000 loops, best of 3: 20 µs per loop
sage: %timeit Partitions(30, length=20).list()
100000 loops, best of 3: 18 µs per loop
sage: %timeit Partitions(60, length=2).list()
100000 loops, best of 3: 16.2 µs per loop
sage: %timeit Partitions(60, length=5).list()
10000 loops, best of 3: 58 µs per loop
sage: %timeit Partitions(60, length=40).list()
10000 loops, best of 3: 23.5 µs per loop
sage: %timeit Partitions(100, length=2).list()
100000 loops, best of 3: 16.6 µs per loop
sage: %timeit Partitions(200, length=2).list()
10000 loops, best of 3: 20.3 µs per loop
sage: %timeit Partitions(300, length=3).list()
10000 loops, best of 3: 77.2 µs per loop
sage: %timeit Partitions(300, length=280).list()
1 loops, best of 3: 283 ms per loop
```



---

archive/issue_events_228354.json:
```json
{
    "actor": "https://github.com/nathanncohen",
    "created_at": "2014-03-27T10:29:43Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228354"
}
```



---

archive/issue_events_228355.json:
```json
{
    "actor": "https://github.com/nathanncohen",
    "created_at": "2014-03-27T10:29:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228355"
}
```



---

archive/issue_comments_203097.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nHelloooooooooooooooooooooooooooo !!\n\nToo bad. I was getting into your ZS1 algorithm which I had never read, and I ended up wondering if you really needed to re-implement it, i.e. if you could not remove this part of your patch `:-P`\n\nYou are writing an iterator over the partitions of n of length exactly k.\n\nDo you agree with me if I say that it is equivalent to iterating over the partitions of n-k of length *at most* k ?\n\nBecause you already have a way to get all partitions of length at most k : ZS1 as it is currently implemented does it, doesn't it ? You just have to stop iterating when the partition has length >k.\n\nSo well, tell me what you think of it.\n\nI have other comments :\n- \"Fast Algorithms for Generating Integer Partitons\" should be in a REFERENCE block, and cited as we usually cite references (see sage: `Graph.modular_decomposition??`)\n- You define Fubini numbers and link to their OEIS page. Could you link to this page too ? http://en.wikipedia.org/wiki/Ordered_Bell_number\n- In the doc of ZS1 there is a \"partition type\" : was \"partition tuples\" intended ?\n\nNathann",
    "created_at": "2014-03-27T10:29:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203097",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:13" align="right">comment:13</div>

Helloooooooooooooooooooooooooooo !!

Too bad. I was getting into your ZS1 algorithm which I had never read, and I ended up wondering if you really needed to re-implement it, i.e. if you could not remove this part of your patch `:-P`

You are writing an iterator over the partitions of n of length exactly k.

Do you agree with me if I say that it is equivalent to iterating over the partitions of n-k of length *at most* k ?

Because you already have a way to get all partitions of length at most k : ZS1 as it is currently implemented does it, doesn't it ? You just have to stop iterating when the partition has length >k.

So well, tell me what you think of it.

I have other comments :
- "Fast Algorithms for Generating Integer Partitons" should be in a REFERENCE block, and cited as we usually cite references (see sage: `Graph.modular_decomposition??`)
- You define Fubini numbers and link to their OEIS page. Could you link to this page too ? http://en.wikipedia.org/wiki/Ordered_Bell_number
- In the doc of ZS1 there is a "partition type" : was "partition tuples" intended ?

Nathann



---

archive/issue_comments_203098.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nOh, and you can do this change too, sorry I forgot\n\n```\n-            lst = [self.n - self.k + 1] + [1 for _ in range(self.k-1)]\n+            lst = [self.n - self.k + 1] + [1]*(self.k-1)\n```\n\nI was about to do it myself in a reviewer's patch, but this question over ZS1 spoiled everything.\n\nI have to read this ZS1 algorithm though, it looks nice.\n\nNathann",
    "created_at": "2014-03-27T10:31:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203098",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:14" align="right">comment:14</div>

Oh, and you can do this change too, sorry I forgot

```
-            lst = [self.n - self.k + 1] + [1 for _ in range(self.k-1)]
+            lst = [self.n - self.k + 1] + [1]*(self.k-1)
```

I was about to do it myself in a reviewer's patch, but this question over ZS1 spoiled everything.

I have to read this ZS1 algorithm though, it looks nice.

Nathann



---

archive/issue_comments_203099.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nZS1 does NOT yield partitions in increasing length, even if it looks like that in small degrees. See the doc: it gives them antilexicographically. I'll do the other changes shortly.",
    "created_at": "2014-03-27T16:42:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203099",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:15" align="right">comment:15</div>

ZS1 does NOT yield partitions in increasing length, even if it looks like that in small degrees. See the doc: it gives them antilexicographically. I'll do the other changes shortly.



---

archive/issue_comments_203100.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nOh I see. Then I can go back to reading this code, cool `;-)`\n\nNathann",
    "created_at": "2014-03-27T16:44:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203100",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:16" align="right">comment:16</div>

Oh I see. Then I can go back to reading this code, cool `;-)`

Nathann



---

archive/issue_comments_203101.json:
```json
{
    "body": "<div id=\"comment:17\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/75ef295edc710baa645c92647002e6d0e0c5eb5f\">75ef295</a></td><td><code>changes suggested by Nathann</code></td></tr></table>\n",
    "created_at": "2014-03-27T17:18:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203101",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:17"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/75ef295edc710baa645c92647002e6d0e0c5eb5f">75ef295</a></td><td><code>changes suggested by Nathann</code></td></tr></table>




---

archive/issue_comments_203102.json:
```json
{
    "body": "Changed commit from **[`1c4454f`](https://github.com/sagemath/sagetrac-mirror/commit/1c4454fad5d281acb2f5d51e57182cef16829e2d)** to **[`75ef295`](https://github.com/sagemath/sagetrac-mirror/commit/75ef295edc710baa645c92647002e6d0e0c5eb5f)**",
    "created_at": "2014-03-27T17:18:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203102",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`1c4454f`](https://github.com/sagemath/sagetrac-mirror/commit/1c4454fad5d281acb2f5d51e57182cef16829e2d)** to **[`75ef295`](https://github.com/sagemath/sagetrac-mirror/commit/75ef295edc710baa645c92647002e6d0e0c5eb5f)**



---

archive/issue_events_228356.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-03-27T17:19:17Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228356"
}
```



---

archive/issue_events_228357.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2014-03-27T17:19:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228357"
}
```



---

archive/issue_comments_203103.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nThanks !\n\nI am reading your code at the moment. I understood ZS1 and it is a nice algorithm ! Going through your modified version now, and I will probably add some comments I need.\n\nWould you have anything against changing \"the opposite of the lexicographic order\" with \"decreasing lexicographic order\" ? At first I thought you were talking of the \"co-lexicographic order\". I know it was my fault, but \"decreasing lexicographic order\" would have saved me. What do you think ? Meanwhile I will be reading the code. I will send you a commit before leaving the lab this evening. Have fun `:-)`\n\nNathann",
    "created_at": "2014-03-27T17:22:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203103",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:19" align="right">comment:19</div>

Thanks !

I am reading your code at the moment. I understood ZS1 and it is a nice algorithm ! Going through your modified version now, and I will probably add some comments I need.

Would you have anything against changing "the opposite of the lexicographic order" with "decreasing lexicographic order" ? At first I thought you were talking of the "co-lexicographic order". I know it was my fault, but "decreasing lexicographic order" would have saved me. What do you think ? Meanwhile I will be reading the code. I will send you a commit before leaving the lab this evening. Have fun `:-)`

Nathann



---

archive/issue_comments_203104.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nFeel free to make this change (in both docstrings then) -- I don't know of any standard notation for this order.",
    "created_at": "2014-03-27T17:26:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203104",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:20" align="right">comment:20</div>

Feel free to make this change (in both docstrings then) -- I don't know of any standard notation for this order.



---

archive/issue_comments_203105.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nAhahahahaahah. Okay, thanks to trac I know how old my latest comment is, and I can claim that I spent the last 82 minutes looking at this very line :\n\n```\nwhile t > (k-h-1) * r:\n```\n\nI was totally sure that the `>` should be a `>=` or that there should be a +1 somewhere, but NO WAY, I made tests and it was right. AAaaaaaaand that's all because of this cursed line \n\n```\nt = m - h + 1\n```\nWhich I expected to be the sum of the elements to the right of `x[h]`, and which contained this cursed `+1`. Ahahaha. And of course because clearly in my head `m` was the length of the partition.... And not `m+1`.\n\nAHAHahahahahahahaha. Crazy. I'm late now.\n\nAnyway, your code is good, I added a couple of comments, I removed the one which wrongly claims that the function is recursive, and if you agree with my last commit you can set this ticket to `positive_review`.\n\nGosh.\n\nOh, and thanks again for taking the time to do a good job. At first we had a hidden (fast) function to replace a slow exposed function, and now not only everything is fast but you implemented a faster enumeration algorithm. Ahahahah.\n\nOh, and by the way : you say in the docstring that you don't know if this is the best possible ? Well, I believe that I can remove the multiplication in `t > (k-h-1) * r` at the cost of another \"if\", but given that you output Python lists I would say that it is negligible. Good job, and thank for this code `:-)`\n\nNathann",
    "created_at": "2014-03-27T18:46:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203105",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:21" align="right">comment:21</div>

Ahahahahaahah. Okay, thanks to trac I know how old my latest comment is, and I can claim that I spent the last 82 minutes looking at this very line :

```
while t > (k-h-1) * r:
```

I was totally sure that the `>` should be a `>=` or that there should be a +1 somewhere, but NO WAY, I made tests and it was right. AAaaaaaaand that's all because of this cursed line 

```
t = m - h + 1
```
Which I expected to be the sum of the elements to the right of `x[h]`, and which contained this cursed `+1`. Ahahaha. And of course because clearly in my head `m` was the length of the partition.... And not `m+1`.

AHAHahahahahahahaha. Crazy. I'm late now.

Anyway, your code is good, I added a couple of comments, I removed the one which wrongly claims that the function is recursive, and if you agree with my last commit you can set this ticket to `positive_review`.

Gosh.

Oh, and thanks again for taking the time to do a good job. At first we had a hidden (fast) function to replace a slow exposed function, and now not only everything is fast but you implemented a faster enumeration algorithm. Ahahahah.

Oh, and by the way : you say in the docstring that you don't know if this is the best possible ? Well, I believe that I can remove the multiplication in `t > (k-h-1) * r` at the cost of another "if", but given that you output Python lists I would say that it is negligible. Good job, and thank for this code `:-)`

Nathann



---

archive/issue_comments_203106.json:
```json
{
    "body": "<div id=\"comment:22\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7ac66efc4e651db7431f5658e422de7e325d32fa\">7ac66ef</a></td><td><code>trac #15998: Reviewer's patch</code></td></tr></table>\n",
    "created_at": "2014-03-27T18:46:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203106",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:22"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7ac66efc4e651db7431f5658e422de7e325d32fa">7ac66ef</a></td><td><code>trac #15998: Reviewer's patch</code></td></tr></table>




---

archive/issue_comments_203107.json:
```json
{
    "body": "Changed commit from **[`75ef295`](https://github.com/sagemath/sagetrac-mirror/commit/75ef295edc710baa645c92647002e6d0e0c5eb5f)** to **[`7ac66ef`](https://github.com/sagemath/sagetrac-mirror/commit/7ac66efc4e651db7431f5658e422de7e325d32fa)**",
    "created_at": "2014-03-27T18:46:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203107",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`75ef295`](https://github.com/sagemath/sagetrac-mirror/commit/75ef295edc710baa645c92647002e6d0e0c5eb5f)** to **[`7ac66ef`](https://github.com/sagemath/sagetrac-mirror/commit/7ac66efc4e651db7431f5658e422de7e325d32fa)**



---

archive/issue_comments_203108.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nThanks a lot! It also took me some considerable tweaking to get that while-condition right. If my new commit looks fine to you, can you set it to pos_rev?\n\nBut now I'm curious: How could I have replaced the multiplication by an if?",
    "created_at": "2014-03-27T18:53:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203108",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:23" align="right">comment:23</div>

Thanks a lot! It also took me some considerable tweaking to get that while-condition right. If my new commit looks fine to you, can you set it to pos_rev?

But now I'm curious: How could I have replaced the multiplication by an if?



---

archive/issue_comments_203109.json:
```json
{
    "body": "<div id=\"comment:24\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5f67fa2245dec9fbf1670c75cd0a41a6da18959f\">5f67fa2</a></td><td><code>comment edits</code></td></tr></table>\n",
    "created_at": "2014-03-27T18:53:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203109",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:24"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5f67fa2245dec9fbf1670c75cd0a41a6da18959f">5f67fa2</a></td><td><code>comment edits</code></td></tr></table>




---

archive/issue_comments_203110.json:
```json
{
    "body": "Changed commit from **[`7ac66ef`](https://github.com/sagemath/sagetrac-mirror/commit/7ac66efc4e651db7431f5658e422de7e325d32fa)** to **[`5f67fa2`](https://github.com/sagemath/sagetrac-mirror/commit/5f67fa2245dec9fbf1670c75cd0a41a6da18959f)**",
    "created_at": "2014-03-27T18:53:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203110",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`7ac66ef`](https://github.com/sagemath/sagetrac-mirror/commit/7ac66efc4e651db7431f5658e422de7e325d32fa)** to **[`5f67fa2`](https://github.com/sagemath/sagetrac-mirror/commit/5f67fa2245dec9fbf1670c75cd0a41a6da18959f)**



---

archive/issue_events_228358.json:
```json
{
    "actor": "https://github.com/nathanncohen",
    "created_at": "2014-03-27T19:40:39Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228358"
}
```



---

archive/issue_events_228359.json:
```json
{
    "actor": "https://github.com/nathanncohen",
    "created_at": "2014-03-27T19:40:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228359"
}
```



---

archive/issue_comments_203111.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nWell. You know that x[h] is at least 3, and that everything to its right is a 1.\n\nFirst, if the current partition is not of length k then you know that you can add a new entry, so for sure you can decrease the current value and move a +1 somewhere to the right\n\nSo the current partition has length exactly k.\n\nIf there IS some 1 to the right of x[h], then for sure you can decrease your current value and increase a value somewhere to the right, for they are not all equal to x[h]-1\n\nSo your current partition has length exactly k, and there is no 1 to the right of x[h].\n\nThus, you must decrease h until you see an element x[h'] which is at least x[h]+2\n\nAhahahah. Except if I made a mistake somewhere. But I DID look at this line for more than an hour :-P\n\nBy the way, it is totally impossible to type [] on a mac keyboard. I wonder how can anybody write code with their cursed keyboard.\n\nYour changes are okay, so this patch goes in ! ;-)\n\nNathann",
    "created_at": "2014-03-27T19:40:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203111",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:25" align="right">comment:25</div>

Well. You know that x[h] is at least 3, and that everything to its right is a 1.

First, if the current partition is not of length k then you know that you can add a new entry, so for sure you can decrease the current value and move a +1 somewhere to the right

So the current partition has length exactly k.

If there IS some 1 to the right of x[h], then for sure you can decrease your current value and increase a value somewhere to the right, for they are not all equal to x[h]-1

So your current partition has length exactly k, and there is no 1 to the right of x[h].

Thus, you must decrease h until you see an element x[h'] which is at least x[h]+2

Ahahahah. Except if I made a mistake somewhere. But I DID look at this line for more than an hour :-P

By the way, it is totally impossible to type [] on a mac keyboard. I wonder how can anybody write code with their cursed keyboard.

Your changes are okay, so this patch goes in ! ;-)

Nathann



---

archive/issue_comments_203112.json:
```json
{
    "body": "Reviewer: **Nathann Cohen**",
    "created_at": "2014-03-27T19:41:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203112",
    "user": "https://github.com/nathanncohen"
}
```

Reviewer: **Nathann Cohen**



---

archive/issue_comments_203113.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nReplying to [@nathanncohen](#comment:25):\n> Well. You know that x[h] is at least 3, and that everything to its right is a 1.\n> \n> First, if the current partition is not of length k then you know that you can add a new entry, so for sure you can decrease the current value and move a +1 somewhere to the right\n\nBut this might not be what I want to do!\n\nFor instance, say, we have the partition [7,5,1] and the max length is 4. We can subtract 1 from the 5 and make it [7,4,1,1], but this is not the next partition in the reverse lexicographic order (that would be [7,4,2]).\n\nI fear this breaks your simplification; it would indeed work for length k but not when the length is smaller.\n\n> By the way, it is totally impossible to type [] on a mac keyboard. I wonder how can anybody write code with their cursed keyboard.\n\nI'm wondering how anyone can ever do something reasonable on these things. But well, it looks like all major OSes are losing usability in the last few years...\n\nThanks again for all the help and the positive review!",
    "created_at": "2014-03-27T19:47:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203113",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:27" align="right">comment:27</div>

Replying to [@nathanncohen](#comment:25):
> Well. You know that x[h] is at least 3, and that everything to its right is a 1.
> 
> First, if the current partition is not of length k then you know that you can add a new entry, so for sure you can decrease the current value and move a +1 somewhere to the right

But this might not be what I want to do!

For instance, say, we have the partition [7,5,1] and the max length is 4. We can subtract 1 from the 5 and make it [7,4,1,1], but this is not the next partition in the reverse lexicographic order (that would be [7,4,2]).

I fear this breaks your simplification; it would indeed work for length k but not when the length is smaller.

> By the way, it is totally impossible to type [] on a mac keyboard. I wonder how can anybody write code with their cursed keyboard.

I'm wondering how anyone can ever do something reasonable on these things. But well, it looks like all major OSes are losing usability in the last few years...

Thanks again for all the help and the positive review!



---

archive/issue_comments_203114.json:
```json
{
    "body": "<div id=\"comment:28\" align=\"right\">comment:28</div>\n\n> But this might not be what I want to do!\n\nSorry. My point was not that you should move this +1 somewhere, but that you KNOW that some entry on the right (which may not be counted in the current partition, i.e. may be equal to 0) is not equal to x[h]-1. Thus you know that your multiplicative equation is satisfied, even though you do not have to run it.\n\nMy point is to say that you can determine the right h' without having to multiply everything.\n\nNathann",
    "created_at": "2014-03-27T20:10:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203114",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:28" align="right">comment:28</div>

> But this might not be what I want to do!

Sorry. My point was not that you should move this +1 somewhere, but that you KNOW that some entry on the right (which may not be counted in the current partition, i.e. may be equal to 0) is not equal to x[h]-1. Thus you know that your multiplicative equation is satisfied, even though you do not have to run it.

My point is to say that you can determine the right h' without having to multiply everything.

Nathann



---

archive/issue_comments_203115.json:
```json
{
    "body": "<div id=\"comment:29\" align=\"right\">comment:29</div>\n\nOh -- but it's only sufficient, not necessary, so I'd have to check the multiplicative equation in one branch nevertheless. So it's a tradeoff, which I don't really feel like analyzing (I hope multiplication of C++ ints is fast enough). But thanks for pointing it out; it's a nice idea.",
    "created_at": "2014-03-27T20:57:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203115",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:29" align="right">comment:29</div>

Oh -- but it's only sufficient, not necessary, so I'd have to check the multiplicative equation in one branch nevertheless. So it's a tradeoff, which I don't really feel like analyzing (I hope multiplication of C++ ints is fast enough). But thanks for pointing it out; it's a nice idea.



---

archive/issue_comments_203116.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nI've implemented a hybrid algorithm which mostly does a bunch of special casing before passing it off to GAP. The one case where it definitively does something different is when `2k >= n`, where it is just equal to the number of partitions of size `n - k`. Also for `k = 2` where it's equal to `n // 2`.\n\nSome timings:\n\n```\nsage: N = [20, 500, 156234]\nsage: K = [5, 10, 15, 20, 250, 499, 500, 501, 80000]\nsage: for n in N:\n....:     for k in K:\n....:         P = Partitions(n, length=k)\n....:         print n,k\n....:         %timeit P.cardinality()\n....:         %timeit P.cardinality('gap')\n....:         \n20 5\n1 loops, best of 3: 7.91 ms per loop\n100 loops, best of 3: 8 ms per loop\n20 10\n100000 loops, best of 3: 10.2 \u00b5s per loop\n100 loops, best of 3: 8 ms per loop\n20 15\n100000 loops, best of 3: 10.5 \u00b5s per loop\n100 loops, best of 3: 8 ms per loop\n20 20\n100000 loops, best of 3: 1.64 \u00b5s per loop\n100 loops, best of 3: 8 ms per loop\n20 250\n100000 loops, best of 3: 1.74 \u00b5s per loop\n100 loops, best of 3: 7.99 ms per loop\n20 499\n100000 loops, best of 3: 1.41 \u00b5s per loop\n100 loops, best of 3: 8 ms per loop\n20 500\n1000000 loops, best of 3: 1.45 \u00b5s per loop\n100 loops, best of 3: 8 ms per loop\n20 501\n1000000 loops, best of 3: 1.42 \u00b5s per loop\n100 loops, best of 3: 7.99 ms per loop\n20 80000\n1000000 loops, best of 3: 1.44 \u00b5s per loop\n100 loops, best of 3: 8 ms per loop\n500 5\n100 loops, best of 3: 8 ms per loop\n100 loops, best of 3: 8 ms per loop\n500 10\n100 loops, best of 3: 7.99 ms per loop\n100 loops, best of 3: 8 ms per loop\n500 15\n100 loops, best of 3: 8 ms per loop\n100 loops, best of 3: 8 ms per loop\n500 20\n100 loops, best of 3: 8.04 ms per loop\n100 loops, best of 3: 8 ms per loop\n500 250\n100000 loops, best of 3: 10.3 \u00b5s per loop\n100 loops, best of 3: 23 ms per loop\n500 499\n100000 loops, best of 3: 10.2 \u00b5s per loop\n10 loops, best of 3: 18.5 ms per loop\n500 500\n100000 loops, best of 3: 1.55 \u00b5s per loop\n100 loops, best of 3: 8 ms per loop\n500 501\n100000 loops, best of 3: 1.41 \u00b5s per loop\n100 loops, best of 3: 8 ms per loop\n500 80000\n100000 loops, best of 3: 1.41 \u00b5s per loop\n100 loops, best of 3: 8 ms per loop\n156234 5\n10 loops, best of 3: 132 ms per loop\n10 loops, best of 3: 134 ms per loop\n156234 10\n1 loops, best of 3: 280 ms per loop\n1 loops, best of 3: 264 ms per loop\n156234 15\n1 loops, best of 3: 424 ms per loop\n1 loops, best of 3: 420 ms per loop\n156234 20\n1 loops, best of 3: 656 ms per loop\n1 loops, best of 3: 664 ms per loop\n156234 250\n1 loops, best of 3: 23.6 s per loop\n1 loops, best of 3: 23.2 s per loop\n156234 499\n1 loops, best of 3: 1min 6s per loop\n1 loops, best of 3: 1min 7s per loop\n\n[Killed because it redirected to gap at this point]\n\nsage: P = Partitions(4562, length=2800)\nsage: %timeit P.cardinality('gap')\n1 loops, best of 3: 980 ms per loop\nsage: %timeit P.cardinality()\n100000 loops, best of 3: 10.5 \u00b5s per loop\n\nsage: P = Partitions(15623, length=8000)\nsage: %timeit P.cardinality()\n10000 loops, best of 3: 10.1 \u00b5s per loop\nsage: %timeit P.cardinality('gap')\n1 loops, best of 3: 15.4 s per loop\n\nsage: P = Partitions(156234, length=80000)\nsage: %timeit P.cardinality()\n100000 loops, best of 3: 10.3 \u00b5s per loop\nsage: %timeit P.cardinality('gap')\n[Took too long, so killed as well]\n```\nThe hybrid approach could probably be improved further for the special case of `3k >= n > 2k`, or up to a small multiple of `k`.\n\nI also added another special case to the ZS1 algorithm for `k == 1`.",
    "created_at": "2014-03-27T22:40:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203116",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:30" align="right">comment:30</div>

I've implemented a hybrid algorithm which mostly does a bunch of special casing before passing it off to GAP. The one case where it definitively does something different is when `2k >= n`, where it is just equal to the number of partitions of size `n - k`. Also for `k = 2` where it's equal to `n // 2`.

Some timings:

```
sage: N = [20, 500, 156234]
sage: K = [5, 10, 15, 20, 250, 499, 500, 501, 80000]
sage: for n in N:
....:     for k in K:
....:         P = Partitions(n, length=k)
....:         print n,k
....:         %timeit P.cardinality()
....:         %timeit P.cardinality('gap')
....:         
20 5
1 loops, best of 3: 7.91 ms per loop
100 loops, best of 3: 8 ms per loop
20 10
100000 loops, best of 3: 10.2 µs per loop
100 loops, best of 3: 8 ms per loop
20 15
100000 loops, best of 3: 10.5 µs per loop
100 loops, best of 3: 8 ms per loop
20 20
100000 loops, best of 3: 1.64 µs per loop
100 loops, best of 3: 8 ms per loop
20 250
100000 loops, best of 3: 1.74 µs per loop
100 loops, best of 3: 7.99 ms per loop
20 499
100000 loops, best of 3: 1.41 µs per loop
100 loops, best of 3: 8 ms per loop
20 500
1000000 loops, best of 3: 1.45 µs per loop
100 loops, best of 3: 8 ms per loop
20 501
1000000 loops, best of 3: 1.42 µs per loop
100 loops, best of 3: 7.99 ms per loop
20 80000
1000000 loops, best of 3: 1.44 µs per loop
100 loops, best of 3: 8 ms per loop
500 5
100 loops, best of 3: 8 ms per loop
100 loops, best of 3: 8 ms per loop
500 10
100 loops, best of 3: 7.99 ms per loop
100 loops, best of 3: 8 ms per loop
500 15
100 loops, best of 3: 8 ms per loop
100 loops, best of 3: 8 ms per loop
500 20
100 loops, best of 3: 8.04 ms per loop
100 loops, best of 3: 8 ms per loop
500 250
100000 loops, best of 3: 10.3 µs per loop
100 loops, best of 3: 23 ms per loop
500 499
100000 loops, best of 3: 10.2 µs per loop
10 loops, best of 3: 18.5 ms per loop
500 500
100000 loops, best of 3: 1.55 µs per loop
100 loops, best of 3: 8 ms per loop
500 501
100000 loops, best of 3: 1.41 µs per loop
100 loops, best of 3: 8 ms per loop
500 80000
100000 loops, best of 3: 1.41 µs per loop
100 loops, best of 3: 8 ms per loop
156234 5
10 loops, best of 3: 132 ms per loop
10 loops, best of 3: 134 ms per loop
156234 10
1 loops, best of 3: 280 ms per loop
1 loops, best of 3: 264 ms per loop
156234 15
1 loops, best of 3: 424 ms per loop
1 loops, best of 3: 420 ms per loop
156234 20
1 loops, best of 3: 656 ms per loop
1 loops, best of 3: 664 ms per loop
156234 250
1 loops, best of 3: 23.6 s per loop
1 loops, best of 3: 23.2 s per loop
156234 499
1 loops, best of 3: 1min 6s per loop
1 loops, best of 3: 1min 7s per loop

[Killed because it redirected to gap at this point]

sage: P = Partitions(4562, length=2800)
sage: %timeit P.cardinality('gap')
1 loops, best of 3: 980 ms per loop
sage: %timeit P.cardinality()
100000 loops, best of 3: 10.5 µs per loop

sage: P = Partitions(15623, length=8000)
sage: %timeit P.cardinality()
10000 loops, best of 3: 10.1 µs per loop
sage: %timeit P.cardinality('gap')
1 loops, best of 3: 15.4 s per loop

sage: P = Partitions(156234, length=80000)
sage: %timeit P.cardinality()
100000 loops, best of 3: 10.3 µs per loop
sage: %timeit P.cardinality('gap')
[Took too long, so killed as well]
```
The hybrid approach could probably be improved further for the special case of `3k >= n > 2k`, or up to a small multiple of `k`.

I also added another special case to the ZS1 algorithm for `k == 1`.



---

archive/issue_events_228360.json:
```json
{
    "actor": "https://github.com/sagetrac-git",
    "created_at": "2014-03-27T22:40:41Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228360"
}
```



---

archive/issue_events_228361.json:
```json
{
    "actor": "https://github.com/sagetrac-git",
    "created_at": "2014-03-27T22:40:41Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228361"
}
```



---

archive/issue_comments_203117.json:
```json
{
    "body": "Changed commit from **[`5f67fa2`](https://github.com/sagemath/sagetrac-mirror/commit/5f67fa2245dec9fbf1670c75cd0a41a6da18959f)** to **[`1fac970`](https://github.com/sagemath/sagetrac-mirror/commit/1fac9704ff7836f120955dcdac314e5639c63356)**",
    "created_at": "2014-03-27T22:40:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203117",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`5f67fa2`](https://github.com/sagemath/sagetrac-mirror/commit/5f67fa2245dec9fbf1670c75cd0a41a6da18959f)** to **[`1fac970`](https://github.com/sagemath/sagetrac-mirror/commit/1fac9704ff7836f120955dcdac314e5639c63356)**



---

archive/issue_comments_203118.json:
```json
{
    "body": "<div id=\"comment:31\"></div>\n\nBranch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1fac9704ff7836f120955dcdac314e5639c63356\">1fac970</a></td><td><code>Added a hybrid algorithm to computing partitions of n of length k.</code></td></tr></table>\n",
    "created_at": "2014-03-27T22:40:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203118",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:31"></div>

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1fac9704ff7836f120955dcdac314e5639c63356">1fac970</a></td><td><code>Added a hybrid algorithm to computing partitions of n of length k.</code></td></tr></table>




---

archive/issue_comments_203119.json:
```json
{
    "body": "Changed commit from **[`1fac970`](https://github.com/sagemath/sagetrac-mirror/commit/1fac9704ff7836f120955dcdac314e5639c63356)** to **[`da4bf10`](https://github.com/sagemath/sagetrac-mirror/commit/da4bf10359d8a23746de8647904ba2c389f61d59)**",
    "created_at": "2014-03-27T22:54:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203119",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`1fac970`](https://github.com/sagemath/sagetrac-mirror/commit/1fac9704ff7836f120955dcdac314e5639c63356)** to **[`da4bf10`](https://github.com/sagemath/sagetrac-mirror/commit/da4bf10359d8a23746de8647904ba2c389f61d59)**



---

archive/issue_comments_203120.json:
```json
{
    "body": "<div id=\"comment:32\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/da4bf10359d8a23746de8647904ba2c389f61d59\">da4bf10</a></td><td><code>slight improvements?</code></td></tr></table>\n",
    "created_at": "2014-03-27T22:54:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203120",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:32"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/da4bf10359d8a23746de8647904ba2c389f61d59">da4bf10</a></td><td><code>slight improvements?</code></td></tr></table>




---

archive/issue_comments_203121.json:
```json
{
    "body": "<div id=\"comment:33\" align=\"right\">comment:33</div>\n\nThanks for simplifying half of the cases of the cardinality method! Any objections to my commit? Otherwise, pos_rev?",
    "created_at": "2014-03-27T23:01:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203121",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:33" align="right">comment:33</div>

Thanks for simplifying half of the cases of the cardinality method! Any objections to my commit? Otherwise, pos_rev?



---

archive/issue_comments_203122.json:
```json
{
    "body": "Changed reviewer from **Nathann Cohen** to **Nathann Cohen, Travis Scrimshaw**",
    "created_at": "2014-03-27T23:15:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203122",
    "user": "https://github.com/tscrim"
}
```

Changed reviewer from **Nathann Cohen** to **Nathann Cohen, Travis Scrimshaw**



---

archive/issue_comments_203123.json:
```json
{
    "body": "<div id=\"comment:34\" align=\"right\">comment:34</div>\n\nNope. pos_rev.",
    "created_at": "2014-03-27T23:15:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203123",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:34" align="right">comment:34</div>

Nope. pos_rev.



---

archive/issue_events_228362.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2014-03-27T23:15:17Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228362"
}
```



---

archive/issue_events_228363.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2014-03-27T23:15:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228363"
}
```



---

archive/issue_comments_203124.json:
```json
{
    "body": "<div id=\"comment:35\" align=\"right\">comment:35</div>\n\n> Oh -- but it's only sufficient, not necessary, so I'd have to check the multiplicative equation in one branch nevertheless. \n\nAhahahaahah.\n\nOkay, last attempt to convince you that it is not only a sufficient condition. Let me rewrite better what I said above. We are looking for the largest value h sur that all elements to the right of x[h] can be replaced with things below x[h].\n\n\n1) If the current partition is not of length k, then you know for sure that your multiplicative equation is satisfied, so the current value of h is the value you want.\n\nProof: x[h] is at least 3, and all elements to the right of x[h] are at most one. Let us say that you have exactly L ones, and we know that you have at least one unused cell : thus L+1 <= (L+1)(x[h]-1), which is the opposite of your multiplicative equation, i.e. your code does not enter the loop in this situation.\n\n(We can now assume that the current partition has length exactly k)\n\n2) If there IS some 1 to the right of x[h] (note that this can be tested without multiplicative equation too), then the current value of h is the value you want\n\nProof: let us say that you have L ones to the right of x[h]. In this case those ones are a partition of L into integers <= 1, and it is of course possible to express a partition of t=L+1 into (less) integers <= 2 <= x[h]-1\n\n( We can now assume that your current partition has length exactly k, and there is no 1 to the right of x[h])\n\nIn this case, the least admissible value for h is the largest value h' such that x[h'] is at least x[h]+2\n\nNathann",
    "created_at": "2014-03-28T06:44:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203124",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:35" align="right">comment:35</div>

> Oh -- but it's only sufficient, not necessary, so I'd have to check the multiplicative equation in one branch nevertheless. 

Ahahahaahah.

Okay, last attempt to convince you that it is not only a sufficient condition. Let me rewrite better what I said above. We are looking for the largest value h sur that all elements to the right of x[h] can be replaced with things below x[h].


1) If the current partition is not of length k, then you know for sure that your multiplicative equation is satisfied, so the current value of h is the value you want.

Proof: x[h] is at least 3, and all elements to the right of x[h] are at most one. Let us say that you have exactly L ones, and we know that you have at least one unused cell : thus L+1 <= (L+1)(x[h]-1), which is the opposite of your multiplicative equation, i.e. your code does not enter the loop in this situation.

(We can now assume that the current partition has length exactly k)

2) If there IS some 1 to the right of x[h] (note that this can be tested without multiplicative equation too), then the current value of h is the value you want

Proof: let us say that you have L ones to the right of x[h]. In this case those ones are a partition of L into integers <= 1, and it is of course possible to express a partition of t=L+1 into (less) integers <= 2 <= x[h]-1

( We can now assume that your current partition has length exactly k, and there is no 1 to the right of x[h])

In this case, the least admissible value for h is the largest value h' such that x[h'] is at least x[h]+2

Nathann



---

archive/issue_comments_203125.json:
```json
{
    "body": "<div id=\"comment:36\" align=\"right\">comment:36</div>\n\n\" 2) If there IS some 1 to the right of x[h] (note that this can be tested without multiplicative equation too), then the current value of h is the value you want \"\n\nWhy? I cannot get any lower from a partition of the form [2,2,...,2,1,1,...,1] if the length is full.",
    "created_at": "2014-03-29T18:20:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203125",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:36" align="right">comment:36</div>

" 2) If there IS some 1 to the right of x[h] (note that this can be tested without multiplicative equation too), then the current value of h is the value you want "

Why? I cannot get any lower from a partition of the form [2,2,...,2,1,1,...,1] if the length is full.



---

archive/issue_comments_203126.json:
```json
{
    "body": "<div id=\"comment:37\" align=\"right\">comment:37</div>\n\nNononono. By assumption you know that x[h] is at least equal to three (remember that the case x[h]=2 is the one you tested just before). So if x[h] is equal to 3, and what follows is 2,2,2,2,....,1,1,1,1,.... then you can just gather the 1s into 2s.\n\nNathann",
    "created_at": "2014-03-29T21:46:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203126",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:37" align="right">comment:37</div>

Nononono. By assumption you know that x[h] is at least equal to three (remember that the case x[h]=2 is the one you tested just before). So if x[h] is equal to 3, and what follows is 2,2,2,2,....,1,1,1,1,.... then you can just gather the 1s into 2s.

Nathann



---

archive/issue_comments_203127.json:
```json
{
    "body": "<div id=\"comment:38\" align=\"right\">comment:38</div>\n\nOK, I see... to be honest, that's too many cases for me to code. (First we branch on whether there is space left for the partition to grow, then on whether x[h] is 2, then on whether there is a 1 in the partition; am I seeing that right?) But it's a nice argument!",
    "created_at": "2014-03-30T03:39:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203127",
    "user": "https://github.com/darijgr"
}
```

<div id="comment:38" align="right">comment:38</div>

OK, I see... to be honest, that's too many cases for me to code. (First we branch on whether there is space left for the partition to grow, then on whether x[h] is 2, then on whether there is a 1 in the partition; am I seeing that right?) But it's a nice argument!



---

archive/issue_comments_203128.json:
```json
{
    "body": "<div id=\"comment:39\" align=\"right\">comment:39</div>\n\n> OK, I see... to be honest, that's too many cases for me to code. (First we branch on whether there is space left for the partition to grow, then on whether x[h] is 2, then on whether there is a 1 in the partition; am I seeing that right?) But it's a nice argument!\n\nHmmmm... Well, you already tested that x[h] was larger than two, it is the test that you have just before the loop in your code.\n\nAnd you can test at the same time if there is space left for the partition to grow and  if there is a one to the right of x[h] : that's testing if h is equal to m `:-)`\n\nIf it is,you can skip the loop.\n\nIf it isn't,then you have  to decrease h in order to find this element larger than x[h]+2.\n\nI  do not know which kind of speed difference this could make, but really given that you return Python lists I would say that it does not change much.\n\nOh, actually Marc Mezzarobba taught me a nice profiling trick that I would like to use right here to see if the most time consuming operation is this multiplication, let me check !!!\n\nOkay, first most of the time is spent over-wrapping the result and not computing stuff. I love combinat code.\n\n```\nsage: sage: %time _=list(Partitions(100,length=8))\nCPU times: user 20 s, sys: 56 ms, total: 20.1 s\nWall time: 19.9 s\nsage: sage: %time _=list(ZS1_iterator_nk(100-8,8))\nCPU times: user 796 ms, sys: 0 ns, total: 796 ms\nWall time: 797 ms\n```\n\nAhem. Anyway `:-P`\n\nAnd it seems to still be the case when you call `ZS1_iterator`, i.e. mostof the time is Python time.\n\nReplacing all of the \"yield the partition\" with \"yield x[h-1]\" (so that it does not create lists all the time) gives...\n\nOh. I am not very sure of what I  read in the profiling, but it looks like having a Python list x instead of a C one has a cost : each time you read one of its elements, this element is a \"python object\" and not a C integer. So whatever you do with it is a python operation. \n\nI now use the C code which replaces this python list x with a C array... Okay, now the bottle neck seems the moments when the iterator yields a value, which has to be converted to a Python integer before being returned.\n\nAhahaha. And no multiplication has appeared yet unless I misread something.\n\nNice. \n\nIt's funny to profile code `:-)`\n\nSoooooooooooo there are two things to remember, I believe :\n\n1) The optimization above would change nothing to the current code's speed\n\n2) This code is combinat code, all its effort is made toward ONE objective : generating new objects, creating new classes, making use of metaclasscall\n\n3) If you want MUCH better performances, call ZS1 directly\n\n4) It seems that you can go very very far with this code if you do everything at C level. I mean, if someday you want to run serious computations this code is good, but what you should do is work on the Cython code directly and don't wait for it to return its data at Python level.\n\nWow.\n\nCool `:-)`\n\nWell, I think I should go eat something now. Thank you very much for this code, and have a nice day ! `:-)`\n\nNathann",
    "created_at": "2014-03-30T08:18:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203128",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:39" align="right">comment:39</div>

> OK, I see... to be honest, that's too many cases for me to code. (First we branch on whether there is space left for the partition to grow, then on whether x[h] is 2, then on whether there is a 1 in the partition; am I seeing that right?) But it's a nice argument!

Hmmmm... Well, you already tested that x[h] was larger than two, it is the test that you have just before the loop in your code.

And you can test at the same time if there is space left for the partition to grow and  if there is a one to the right of x[h] : that's testing if h is equal to m `:-)`

If it is,you can skip the loop.

If it isn't,then you have  to decrease h in order to find this element larger than x[h]+2.

I  do not know which kind of speed difference this could make, but really given that you return Python lists I would say that it does not change much.

Oh, actually Marc Mezzarobba taught me a nice profiling trick that I would like to use right here to see if the most time consuming operation is this multiplication, let me check !!!

Okay, first most of the time is spent over-wrapping the result and not computing stuff. I love combinat code.

```
sage: sage: %time _=list(Partitions(100,length=8))
CPU times: user 20 s, sys: 56 ms, total: 20.1 s
Wall time: 19.9 s
sage: sage: %time _=list(ZS1_iterator_nk(100-8,8))
CPU times: user 796 ms, sys: 0 ns, total: 796 ms
Wall time: 797 ms
```

Ahem. Anyway `:-P`

And it seems to still be the case when you call `ZS1_iterator`, i.e. mostof the time is Python time.

Replacing all of the "yield the partition" with "yield x[h-1]" (so that it does not create lists all the time) gives...

Oh. I am not very sure of what I  read in the profiling, but it looks like having a Python list x instead of a C one has a cost : each time you read one of its elements, this element is a "python object" and not a C integer. So whatever you do with it is a python operation. 

I now use the C code which replaces this python list x with a C array... Okay, now the bottle neck seems the moments when the iterator yields a value, which has to be converted to a Python integer before being returned.

Ahahaha. And no multiplication has appeared yet unless I misread something.

Nice. 

It's funny to profile code `:-)`

Soooooooooooo there are two things to remember, I believe :

1) The optimization above would change nothing to the current code's speed

2) This code is combinat code, all its effort is made toward ONE objective : generating new objects, creating new classes, making use of metaclasscall

3) If you want MUCH better performances, call ZS1 directly

4) It seems that you can go very very far with this code if you do everything at C level. I mean, if someday you want to run serious computations this code is good, but what you should do is work on the Cython code directly and don't wait for it to return its data at Python level.

Wow.

Cool `:-)`

Well, I think I should go eat something now. Thank you very much for this code, and have a nice day ! `:-)`

Nathann



---

archive/issue_comments_203129.json:
```json
{
    "body": "<div id=\"comment:40\" align=\"right\">comment:40</div>\n\nThere are two things that slow it down:\n\n- checking to make sure it is a valid partition (something which I'd think you'd advocate), and\n- striping trailing 0's (i.e. standardizing the data, which again I'd think you'd advocate).\n\nAs I recall, there's code out there that assumes that initialization of a partition always does these (one of these) two operations (both of which need to loop over each partition), so we can't refactor this away completely. I also don't like passing these (IMO stupid) 'check' arguments.\n\nHere's my data:\n\n```\nsage: P = Partitions(80, length=8)\nsage: %prun L = list(P)\n         11256609 function calls in 87.175 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n  3602112   24.280    0.000   36.376    0.000 partition.py:697(<genexpr>)\n   450264   16.763    0.000   75.347    0.000 partition.py:673(__init__)\n  3602112   14.055    0.000   14.055    0.000 non_negative_integers.py:94(__contains__)\n   450264   11.744    0.000   48.120    0.000 {all}\n   450266    9.136    0.000   85.687    0.000 partition.py:5643(__iter__)\n  1350792    3.582    0.000    3.582    0.000 {len}\n   450264    3.194    0.000    4.499    0.000 combinat.py:780(__init__)\n   900528    2.933    0.000    2.933    0.000 {isinstance}\n        1    0.742    0.742   43.490   43.490 finite_enumerated_sets.py:171(_list_from_iterator)\n        1    0.740    0.740   87.175   87.175 <string>:1(<module>)\n        1    0.007    0.007   43.496   43.496 finite_enumerated_sets.py:254(list)\n        1    0.000    0.000    0.000    0.000 dynamic_class.py:122(dynamic_class)\n        2    0.000    0.000    0.000    0.000 {sage.combinat.partitions.ZS1_iterator_nk}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n```\nThe check of containment in `NN` is actually pretty good:\n\n```\nsage: f = int(5)\nsage: %timeit f in ZZ\n100000 loops, best of 3: 5.33 \u00b5s per loop\nsage: %timeit f in NN\n1000000 loops, best of 3: 1.95 \u00b5s per loop\n```\nRemember that Sage's preparser wraps a number as an `Integer`, so the following is unfair:\n\n```\nsage: %timeit 5 in ZZ # quick parent check\n1000000 loops, best of 3: 476 ns per loop\nsage: %timeit 5 in NN\n100000 loops, best of 3: 2.04 \u00b5s per loop\n```\nI also tried my usual optimizing of using enumerate and `if not mu` for `len(mu) == 0` and it didn't seem to result in a noticeable speedup.\n\nAlso your test is unfair because we have to do extra processing on the result from iterator to get the actual partition we wanted.\n\nSo in the end, we'll have to sit down on a separate ticket and optimize partition creation someday, but not today.\n\nHowever I'm not surprised you see the slowdown in using a list in python as opposed to C. Python is slow compared to C because of it's interpreted/weakly-typed/higher-level nature.\n\nPS - Nathann, that's 4 things `:P`",
    "created_at": "2014-03-30T15:25:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203129",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:40" align="right">comment:40</div>

There are two things that slow it down:

- checking to make sure it is a valid partition (something which I'd think you'd advocate), and
- striping trailing 0's (i.e. standardizing the data, which again I'd think you'd advocate).

As I recall, there's code out there that assumes that initialization of a partition always does these (one of these) two operations (both of which need to loop over each partition), so we can't refactor this away completely. I also don't like passing these (IMO stupid) 'check' arguments.

Here's my data:

```
sage: P = Partitions(80, length=8)
sage: %prun L = list(P)
         11256609 function calls in 87.175 seconds

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
  3602112   24.280    0.000   36.376    0.000 partition.py:697(<genexpr>)
   450264   16.763    0.000   75.347    0.000 partition.py:673(__init__)
  3602112   14.055    0.000   14.055    0.000 non_negative_integers.py:94(__contains__)
   450264   11.744    0.000   48.120    0.000 {all}
   450266    9.136    0.000   85.687    0.000 partition.py:5643(__iter__)
  1350792    3.582    0.000    3.582    0.000 {len}
   450264    3.194    0.000    4.499    0.000 combinat.py:780(__init__)
   900528    2.933    0.000    2.933    0.000 {isinstance}
        1    0.742    0.742   43.490   43.490 finite_enumerated_sets.py:171(_list_from_iterator)
        1    0.740    0.740   87.175   87.175 <string>:1(<module>)
        1    0.007    0.007   43.496   43.496 finite_enumerated_sets.py:254(list)
        1    0.000    0.000    0.000    0.000 dynamic_class.py:122(dynamic_class)
        2    0.000    0.000    0.000    0.000 {sage.combinat.partitions.ZS1_iterator_nk}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}
```
The check of containment in `NN` is actually pretty good:

```
sage: f = int(5)
sage: %timeit f in ZZ
100000 loops, best of 3: 5.33 µs per loop
sage: %timeit f in NN
1000000 loops, best of 3: 1.95 µs per loop
```
Remember that Sage's preparser wraps a number as an `Integer`, so the following is unfair:

```
sage: %timeit 5 in ZZ # quick parent check
1000000 loops, best of 3: 476 ns per loop
sage: %timeit 5 in NN
100000 loops, best of 3: 2.04 µs per loop
```
I also tried my usual optimizing of using enumerate and `if not mu` for `len(mu) == 0` and it didn't seem to result in a noticeable speedup.

Also your test is unfair because we have to do extra processing on the result from iterator to get the actual partition we wanted.

So in the end, we'll have to sit down on a separate ticket and optimize partition creation someday, but not today.

However I'm not surprised you see the slowdown in using a list in python as opposed to C. Python is slow compared to C because of it's interpreted/weakly-typed/higher-level nature.

PS - Nathann, that's 4 things `:P`



---

archive/issue_comments_203130.json:
```json
{
    "body": "<div id=\"comment:41\" align=\"right\">comment:41</div>\n\nYoooooooooooooo !\n\n> There are two things that slow it down:\n> \n> - checking to make sure it is a valid partition (something which I'd think you'd advocate), and\n> - striping trailing 0's (i.e. standardizing the data, which again I'd think you'd advocate).\n\n?\n\nWell, I advocate a great many things. In this case I would advocate to make those test optional, so that they can be disabled when needed, i.e. here.\n\n> As I recall, there's code out there that assumes that initialization of a partition always does these (one of these) two operations (both of which need to loop over each partition), so we can't refactor this away completely. I also don't like passing these (IMO stupid) 'check' arguments.\n\n?\n\nWhat do you have against those `check` parameters ? Their point is precisely to avoid useless tests. How can they do any harm ? `O_o`\n\n> The check of containment in `NN` is actually pretty good:\n\nHey, I have nothing against how you test stuff. Perhaps it is well written and everything, I am just saying that consistency check and creation of object requires more computations than actually compute what you want, that's all. Soooooooooo in this case it is a bit ridiculous to do these enumerations at Python level, that's all. Eventhough it's a bit less ridiculous at Python level than Sage-level `:-PPP`\n\n> Also your test is unfair because we have to do extra processing on the result from iterator to get the actual partition we wanted.\n\n....\nYou mean add a +1 ? and a few extra cells ?\nI can do that in C if you prefer. Do you bet that the time does not change ? `:-P`\n\nWe could just replace the \"yield x[:m+1]\" with a yield `[x[i]+1 for i in range(k)]` and we would be done `:-P`\n\n> So in the end, we'll have to sit down on a separate ticket and optimize partition creation someday, but not today.\n\nhey man, once more I am not saying that it is badly written or anything. You just want to make everything too general, too abstract, and well, you pay it. Can't do without it. That's why I will always feel better playing with a `int * partition` than with a Sage object.\n\nIt's just funny that we were wondering how to avoid a multiplication while anything we can  save is lost 99999 times by the code above it.\n\n> However I'm not surprised you see the slowdown in using a list in python as opposed to C. Python is slow compared to C because of it's interpreted/weakly-typed/higher-level nature.\n\nAhahahah. Yeah, you are right.... But I did not expect it at this moment. Must be why it's nice to actually profile code instead of think about it and optimize multiplications.\n\n> PS - Nathann, that's 4 things `:P`\n\nThe problem with lists is that I write them top-to-bottom and that the numbers change from time to time while I write stuff `:-P`\n\nNathann",
    "created_at": "2014-03-30T15:45:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203130",
    "user": "https://github.com/nathanncohen"
}
```

<div id="comment:41" align="right">comment:41</div>

Yoooooooooooooo !

> There are two things that slow it down:
> 
> - checking to make sure it is a valid partition (something which I'd think you'd advocate), and
> - striping trailing 0's (i.e. standardizing the data, which again I'd think you'd advocate).

?

Well, I advocate a great many things. In this case I would advocate to make those test optional, so that they can be disabled when needed, i.e. here.

> As I recall, there's code out there that assumes that initialization of a partition always does these (one of these) two operations (both of which need to loop over each partition), so we can't refactor this away completely. I also don't like passing these (IMO stupid) 'check' arguments.

?

What do you have against those `check` parameters ? Their point is precisely to avoid useless tests. How can they do any harm ? `O_o`

> The check of containment in `NN` is actually pretty good:

Hey, I have nothing against how you test stuff. Perhaps it is well written and everything, I am just saying that consistency check and creation of object requires more computations than actually compute what you want, that's all. Soooooooooo in this case it is a bit ridiculous to do these enumerations at Python level, that's all. Eventhough it's a bit less ridiculous at Python level than Sage-level `:-PPP`

> Also your test is unfair because we have to do extra processing on the result from iterator to get the actual partition we wanted.

....
You mean add a +1 ? and a few extra cells ?
I can do that in C if you prefer. Do you bet that the time does not change ? `:-P`

We could just replace the "yield x[:m+1]" with a yield `[x[i]+1 for i in range(k)]` and we would be done `:-P`

> So in the end, we'll have to sit down on a separate ticket and optimize partition creation someday, but not today.

hey man, once more I am not saying that it is badly written or anything. You just want to make everything too general, too abstract, and well, you pay it. Can't do without it. That's why I will always feel better playing with a `int * partition` than with a Sage object.

It's just funny that we were wondering how to avoid a multiplication while anything we can  save is lost 99999 times by the code above it.

> However I'm not surprised you see the slowdown in using a list in python as opposed to C. Python is slow compared to C because of it's interpreted/weakly-typed/higher-level nature.

Ahahahah. Yeah, you are right.... But I did not expect it at this moment. Must be why it's nice to actually profile code instead of think about it and optimize multiplications.

> PS - Nathann, that's 4 things `:P`

The problem with lists is that I write them top-to-bottom and that the numbers change from time to time while I write stuff `:-P`

Nathann



---

archive/issue_events_228364.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-04-01T16:54:12Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228364"
}
```



---

archive/issue_events_228365.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "a113723b4a9d4868880d5855674f4fc1959a677f",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2014-04-01T16:54:12Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15998#event-228365"
}
```



---

archive/issue_comments_203131.json:
```json
{
    "body": "Changed branch from **[public/combinat/re-15466](https://github.com/sagemath/sagetrac-mirror/tree/public/combinat/re-15466)** to **[`da4bf10`](https://github.com/sagemath/sagetrac-mirror/commit/da4bf10359d8a23746de8647904ba2c389f61d59)**",
    "created_at": "2014-04-01T16:54:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15998",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15998#issuecomment-203131",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[public/combinat/re-15466](https://github.com/sagemath/sagetrac-mirror/tree/public/combinat/re-15466)** to **[`da4bf10`](https://github.com/sagemath/sagetrac-mirror/commit/da4bf10359d8a23746de8647904ba2c389f61d59)**
