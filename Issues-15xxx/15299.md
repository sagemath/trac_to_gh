# Issue 15299: Incorrect results for analytic Sha due to low precision

archive/issues_015062.json:
```json
{
    "assignees": [],
    "body": "See [https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4](https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4)\n\n```\nsage: E = EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()\n(0, 1.00000000000000)\nsage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound\n(1.94655218772191e-15, 1.82478252135394e-270)\n```\n\nThis seems to be due to inappropriate use of Python floats instead of more precise real numbers. After the patch:\n\n```\nsage: E = EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()\n(1.00000000000000, 1.00000000000000)\nsage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound\n(-4.32787398660869448751904675450772492666840247314688171540527473331725818170217268435223462033366791557160872926179439894639315476270837428785657638252738603056742447337636326343956370276624493916496382120766160023620812331280787034239648552009947468067829864968026720015203778821069593806584e-277,\n 1.82478252137476307223140369768561190028055347258560054363485475966241792307587640145132294203994875344783110100551912347495775160520204557245032474939095251969168953786545612090565728262067746413119194690260652692254781091147749697957445424152473292233020112755190503925812425294821095313979e-270)\n```\n\nWhile working on this, we found an upstream PARI bug: the precision for `exponential_integal_1()` was not as good as it could be.\n\nApply: [[attachment: 15299_reviewer.patch.gz](https://github.com/sagemath/sage/files/ticket15299/15299_reviewer.patch.gz)(https://github.com/sagemath/sage/files/ticket15299/6d3f7c7f40d82637b455a01f92caa998.gz)\n\n\nDepends on #15337\nDepends on #15402\n\nCC:  @JohnCremona @williamstein\n\nUpstream: **Fixed upstream, but not in a stable release.**\n\nReviewer: **Peter Bruin**\n\nAuthor: **Jeroen Demeyer**\n\nMerged: **sage-5.13.beta4**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/15299_\n\n",
    "closed_at": "2013-11-24T17:26:13Z",
    "created_at": "2013-10-16T21:05:51Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/component%3A%20elliptic%20curves",
        "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-5.13",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Incorrect results for analytic Sha due to low precision",
    "type": "issue",
    "updated_at": "2013-11-24T17:26:13Z",
    "url": "https://github.com/sagemath/sage/issues/15299",
    "user": "https://github.com/jdemeyer"
}
```
See [https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4](https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4)

```
sage: E = EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()
(0, 1.00000000000000)
sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound
(1.94655218772191e-15, 1.82478252135394e-270)
```

This seems to be due to inappropriate use of Python floats instead of more precise real numbers. After the patch:

```
sage: E = EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()
(1.00000000000000, 1.00000000000000)
sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound
(-4.32787398660869448751904675450772492666840247314688171540527473331725818170217268435223462033366791557160872926179439894639315476270837428785657638252738603056742447337636326343956370276624493916496382120766160023620812331280787034239648552009947468067829864968026720015203778821069593806584e-277,
 1.82478252137476307223140369768561190028055347258560054363485475966241792307587640145132294203994875344783110100551912347495775160520204557245032474939095251969168953786545612090565728262067746413119194690260652692254781091147749697957445424152473292233020112755190503925812425294821095313979e-270)
```

While working on this, we found an upstream PARI bug: the precision for `exponential_integal_1()` was not as good as it could be.

Apply: [[attachment: 15299_reviewer.patch.gz](https://github.com/sagemath/sage/files/ticket15299/15299_reviewer.patch.gz)(https://github.com/sagemath/sage/files/ticket15299/6d3f7c7f40d82637b455a01f92caa998.gz)


Depends on #15337
Depends on #15402

CC:  @JohnCremona @williamstein

Upstream: **Fixed upstream, but not in a stable release.**

Reviewer: **Peter Bruin**

Author: **Jeroen Demeyer**

Merged: **sage-5.13.beta4**

_Issue created by migration from https://trac.sagemath.org/ticket/15299_





---

archive/issue_events_200138.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-10-16T21:05:51Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "milestone_number": null,
    "milestone_title": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200138"
}
```



---

archive/issue_events_200139.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-10-16T21:05:51Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20elliptic%20curves",
    "label_color": "0000ff",
    "label_name": "component: elliptic curves",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200139"
}
```



---

archive/issue_events_200140.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-10-16T21:05:51Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200140"
}
```



---

archive/issue_events_200141.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-10-16T21:05:51Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200141"
}
```



---

archive/issue_comments_191478.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1 +1,9 @@\n See [https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4](https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4)\n+\n+```\n+sage: E=EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()\n+(0, 1.00000000000000)\n+sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound\n+```\n+\n+This seems to be due to inappropriate use of Python floats instead of more precise objects.\n``````\n",
    "created_at": "2013-10-16T21:07:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191478",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1 +1,9 @@
 See [https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4](https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4)
+
+```
+sage: E=EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()
+(0, 1.00000000000000)
+sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound
+```
+
+This seems to be due to inappropriate use of Python floats instead of more precise objects.
``````




---

archive/issue_comments_191479.json:
```json
{
    "body": "<a id='comment:2'>Comment 2:</a>\nIt gets worse!\n\n```\nsage: E = EllipticCurve('11a')\nsage: E.lseries().deriv_at1()\n0\nsage: E.lseries().dokchitser().derivative(1)\n0.308708533963172\n```\n\nI.e., it is wrong for all curves of rank 0 too...  (This isn't what we wrote the code for.  Ugh.)",
    "created_at": "2013-10-16T21:11:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191479",
    "user": "https://github.com/williamstein"
}
```

<a id='comment:2'>Comment 2:</a>
It gets worse!

```
sage: E = EllipticCurve('11a')
sage: E.lseries().deriv_at1()
0
sage: E.lseries().dokchitser().derivative(1)
0.308708533963172
```

I.e., it is wrong for all curves of rank 0 too...  (This isn't what we wrote the code for.  Ugh.)



---

archive/issue_comments_191480.json:
```json
{
    "body": "<a id='comment:3'>Comment 3:</a>\nSo this is plain wrong then (I don't know enough mathematics to judge this):\n\n```\n        if self.__E.root_number() == 1:\n            return 0\n```",
    "created_at": "2013-10-16T22:20:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191480",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:3'>Comment 3:</a>
So this is plain wrong then (I don't know enough mathematics to judge this):

```
        if self.__E.root_number() == 1:
            return 0
```



---

archive/issue_comments_191481.json:
```json
{
    "body": "<a id='comment:4'>Comment 4:</a>\nI don't know about `11a1`, but this at least fixes the original problem.",
    "created_at": "2013-10-16T22:32:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191481",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:4'>Comment 4:</a>
I don't know about `11a1`, but this at least fixes the original problem.



---

archive/issue_comments_191482.json:
```json
{
    "body": "<a id='comment:5'>Comment 5:</a>\nReplying to [@jdemeyer](#comment%3A3):\n> So this is plain wrong then (I don't know enough mathematics to judge this):\n> \n> ```\n>         if self.__E.root_number() == 1:\n>             return 0\n> ```\n\nThe root number is the sign of the functional equation so is +1 for even analytic rank and -1 for odd.  This function computes the first derivative.  *In practice* this is something one would only want to do if the 0'th derivative was already known to be 0, in which case the code you quote would be OK since if the value is 0 and the order is even then the order is at least 2 so the first derivative is exactly 0.  But of course this function then lies in wait for the user who decides they want the first derivative's value even when the value is nonzero (as for 11a1).  The trouble is that (1) Formulas for the r'th derivative which are implemented are *only* valid under the assumption that all previous derivatives are 0;  and of course (2) proving the earlier derivatives are exactly 0 is usually impossible with current theory.\n\nWhere does that leave this deriv_at1 function?  At the very least it should come with a huge warning about all this.  And it really should return 0 when the root number is +1 unless the user has made an explicit assumption (assume_order_of_vanishing_is_positive=True, say) and otherwise raise a NotImplemented error (or attempt to prove that L(1)=0).",
    "created_at": "2013-10-17T08:52:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191482",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:5'>Comment 5:</a>
Replying to [@jdemeyer](#comment%3A3):
> So this is plain wrong then (I don't know enough mathematics to judge this):
> 
> ```
>         if self.__E.root_number() == 1:
>             return 0
> ```

The root number is the sign of the functional equation so is +1 for even analytic rank and -1 for odd.  This function computes the first derivative.  *In practice* this is something one would only want to do if the 0'th derivative was already known to be 0, in which case the code you quote would be OK since if the value is 0 and the order is even then the order is at least 2 so the first derivative is exactly 0.  But of course this function then lies in wait for the user who decides they want the first derivative's value even when the value is nonzero (as for 11a1).  The trouble is that (1) Formulas for the r'th derivative which are implemented are *only* valid under the assumption that all previous derivatives are 0;  and of course (2) proving the earlier derivatives are exactly 0 is usually impossible with current theory.

Where does that leave this deriv_at1 function?  At the very least it should come with a huge warning about all this.  And it really should return 0 when the root number is +1 unless the user has made an explicit assumption (assume_order_of_vanishing_is_positive=True, say) and otherwise raise a NotImplemented error (or attempt to prove that L(1)=0).



---

archive/issue_events_200142.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-10-17T19:16:34Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200142"
}
```



---

archive/issue_comments_191483.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -4,6 +4,7 @@\n sage: E=EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()\n (0, 1.00000000000000)\n sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound\n+(1.94655218772191e-15, 1.82478252135394e-270)\n ```\n \n-This seems to be due to inappropriate use of Python floats instead of more precise objects.\n+This seems to be due to inappropriate use of Python floats instead of more precise real numbers.\n``````\n",
    "created_at": "2013-10-17T20:23:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191483",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -4,6 +4,7 @@
 sage: E=EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()
 (0, 1.00000000000000)
 sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound
+(1.94655218772191e-15, 1.82478252135394e-270)
 ```
 
-This seems to be due to inappropriate use of Python floats instead of more precise objects.
+This seems to be due to inappropriate use of Python floats instead of more precise real numbers.
``````




---

archive/issue_comments_191484.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,10 +1,18 @@\n See [https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4](https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4)\n \n ```\n-sage: E=EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()\n+sage: E = EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()\n (0, 1.00000000000000)\n sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound\n (1.94655218772191e-15, 1.82478252135394e-270)\n ```\n \n-This seems to be due to inappropriate use of Python floats instead of more precise real numbers.\n+This seems to be due to inappropriate use of Python floats instead of more precise real numbers. After the patch:\n+\n+```\n+sage: E = EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()\n+(1.00000000000000, 1.00000000000000)\n+sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound\n+(-4.32787398660869448751904675450772492666840247314688171540527473331725818170217268435223462033366791557160872926179439894639315476270837428785657638252738603056742447337636326343956370276624493916496382120766160023620812331280787034239648552009947468067829864968026720015203778821069593806584e-277,\n+ 1.82478252137476307223140369768561190028055347258560054363485475966241792307587640145132294203994875344783110100551912347495775160520204557245032474939095251969168953786545612090565728262067746413119194690260652692254781091147749697957445424152473292233020112755190503925812425294821095313979e-270)\n+```\n``````\n",
    "created_at": "2013-10-17T21:39:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191484",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,10 +1,18 @@
 See [https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4](https://groups.google.com/forum/#!topic/sage-support/rYQ4rWyncG4)
 
 ```
-sage: E=EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()
+sage: E = EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()
 (0, 1.00000000000000)
 sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound
 (1.94655218772191e-15, 1.82478252135394e-270)
 ```
 
-This seems to be due to inappropriate use of Python floats instead of more precise real numbers.
+This seems to be due to inappropriate use of Python floats instead of more precise real numbers. After the patch:
+
+```
+sage: E = EllipticCurve(QQ,[0, 0, 1, -79, 342]); E.sha().an(),E.sha().an_numerical()
+(1.00000000000000, 1.00000000000000)
+sage: E.lseries().deriv_at1(100*sqrt(E.conductor()) + 10)  # L1, error_bound
+(-4.32787398660869448751904675450772492666840247314688171540527473331725818170217268435223462033366791557160872926179439894639315476270837428785657638252738603056742447337636326343956370276624493916496382120766160023620812331280787034239648552009947468067829864968026720015203778821069593806584e-277,
+ 1.82478252137476307223140369768561190028055347258560054363485475966241792307587640145132294203994875344783110100551912347495775160520204557245032474939095251969168953786545612090565728262067746413119194690260652692254781091147749697957445424152473292233020112755190503925812425294821095313979e-270)
+```
``````




---

archive/issue_comments_191485.json:
```json
{
    "body": "<a id='comment:9'>Comment 9:</a>\n...review in progress...and all works fine, including docbuilding.  the changes look good to the human eye (this one at least).  Oops, forgot the --long when testing..... and it's still all good.  Thanks, Jeroen!",
    "created_at": "2013-10-18T14:06:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191485",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:9'>Comment 9:</a>
...review in progress...and all works fine, including docbuilding.  the changes look good to the human eye (this one at least).  Oops, forgot the --long when testing..... and it's still all good.  Thanks, Jeroen!



---

archive/issue_comments_191486.json:
```json
{
    "body": "<a id='comment:10'>Comment 10:</a>\nCorrected the error computation for `at1()`. I believe this is rigorous now:\n\n```\n        for n in xrange(1,k+1):\n            term = (zpow * an[n])/n\n            zpow *= z\n            L += term\n            # 8n+1 is the relative error in half-ulps to compute term.\n            # For addition, multiplication, division, sqrt, this is\n            # bounded by the number of operations. exp(x) multiplies the\n            # relative error by abs(x) and adds 1 half-ulp. The relative\n            # error for -2*pi/sqrtN is 3 half-ulps. Assuming that\n            # 2*pi/sqrtN <= 2, the relative error for z is 7 half-ulps.\n            # This implies a relative error of 8n-1 half-ulps for zpow.\n            # Adding 2 for the computation of term gives:\n            error += term.ulp()*(8*n+1) + L.ulp()\n```",
    "created_at": "2013-10-20T21:48:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191486",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:10'>Comment 10:</a>
Corrected the error computation for `at1()`. I believe this is rigorous now:

```
        for n in xrange(1,k+1):
            term = (zpow * an[n])/n
            zpow *= z
            L += term
            # 8n+1 is the relative error in half-ulps to compute term.
            # For addition, multiplication, division, sqrt, this is
            # bounded by the number of operations. exp(x) multiplies the
            # relative error by abs(x) and adds 1 half-ulp. The relative
            # error for -2*pi/sqrtN is 3 half-ulps. Assuming that
            # 2*pi/sqrtN <= 2, the relative error for z is 7 half-ulps.
            # This implies a relative error of 8n-1 half-ulps for zpow.
            # Adding 2 for the computation of term gives:
            error += term.ulp()*(8*n+1) + L.ulp()
```



---

archive/issue_comments_191487.json:
```json
{
    "body": "<a id='comment:11'>Comment 11:</a>\nReplying to [@jdemeyer](#comment%3A10):\n> Corrected the error computation for `at1()`. I believe this is rigorous now:\n> \n> ```\n>         for n in xrange(1,k+1):\n>             term = (zpow * an[n])/n\n>             zpow *= z\n>             L += term\n>             # 8n+1 is the relative error in half-ulps to compute term.\n>             # For addition, multiplication, division, sqrt, this is\n>             # bounded by the number of operations. exp(x) multiplies the\n>             # relative error by abs(x) and adds 1 half-ulp. The relative\n>             # error for -2*pi/sqrtN is 3 half-ulps. Assuming that\n>             # 2*pi/sqrtN <= 2, the relative error for z is 7 half-ulps.\n>             # This implies a relative error of 8n-1 half-ulps for zpow.\n>             # Adding 2 for the computation of term gives:\n>             error += term.ulp()*(8*n+1) + L.ulp()\n> ```\n\nI can see where this is in the code -- can you say how it affects any doctest outputs?  I am not a numerical analyst...",
    "created_at": "2013-10-21T08:43:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191487",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:11'>Comment 11:</a>
Replying to [@jdemeyer](#comment%3A10):
> Corrected the error computation for `at1()`. I believe this is rigorous now:
> 
> ```
>         for n in xrange(1,k+1):
>             term = (zpow * an[n])/n
>             zpow *= z
>             L += term
>             # 8n+1 is the relative error in half-ulps to compute term.
>             # For addition, multiplication, division, sqrt, this is
>             # bounded by the number of operations. exp(x) multiplies the
>             # relative error by abs(x) and adds 1 half-ulp. The relative
>             # error for -2*pi/sqrtN is 3 half-ulps. Assuming that
>             # 2*pi/sqrtN <= 2, the relative error for z is 7 half-ulps.
>             # This implies a relative error of 8n-1 half-ulps for zpow.
>             # Adding 2 for the computation of term gives:
>             error += term.ulp()*(8*n+1) + L.ulp()
> ```

I can see where this is in the code -- can you say how it affects any doctest outputs?  I am not a numerical analyst...



---

archive/issue_comments_191488.json:
```json
{
    "body": "<a id='comment:12'>Comment 12:</a>\nReplying to [@JohnCremona](#comment%3A11):\n> can you say how it affects any doctest outputs?\n\nI would only make the `error` results slightly larger than before. Perhaps more importantly, I believe the error computation is now rigorous, in the sense that one could *prove* that the actual error is bound by the `error` result.",
    "created_at": "2013-10-21T09:52:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191488",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:12'>Comment 12:</a>
Replying to [@JohnCremona](#comment%3A11):
> can you say how it affects any doctest outputs?

I would only make the `error` results slightly larger than before. Perhaps more importantly, I believe the error computation is now rigorous, in the sense that one could *prove* that the actual error is bound by the `error` result.



---

archive/issue_comments_191489.json:
```json
{
    "body": "<a id='comment:13'>Comment 13:</a>\nIf you care less about speed, I could also write a version using interval arithmetic, which will be simpler but slower.",
    "created_at": "2013-10-28T12:06:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191489",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:13'>Comment 13:</a>
If you care less about speed, I could also write a version using interval arithmetic, which will be simpler but slower.



---

archive/issue_comments_191490.json:
```json
{
    "body": "<a id='comment:14'>Comment 14:</a>\nAdded tolerance to `E.lseries().twist_values(1, -12, -4)` doctest to account for doctest failure on ia64.",
    "created_at": "2013-10-31T08:14:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191490",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:14'>Comment 14:</a>
Added tolerance to `E.lseries().twist_values(1, -12, -4)` doctest to account for doctest failure on ia64.



---

archive/issue_comments_191491.json:
```json
{
    "body": "<a id='comment:15'>Comment 15:</a>\nPasses tests on the buildbots now.",
    "created_at": "2013-11-04T07:24:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191491",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:15'>Comment 15:</a>
Passes tests on the buildbots now.



---

archive/issue_comments_191492.json:
```json
{
    "body": "<a id='comment:16'>Comment 16:</a>\nReplying to [@JohnCremona](#comment%3A5):\n> Where does that leave this deriv_at1 function?  At the very least it should come with a huge warning about all this.  And it really should return 0 when the root number is +1 unless the user has made an explicit assumption (assume_order_of_vanishing_is_positive=True, say) and otherwise raise a NotImplemented error (or attempt to prove that L(1)=0).\n\nThe `Lseries_ell` class has a method `L1_vanishes()`, written by William Stein.  According to the documentation, it is provably correct if the Manin constant is <= 2 for the optimal quotient in the isogeny class.  This method is used in some places, but not currently in `deriv_at1()`, where we might use it to check the assumption *L*(*E*, 1) = 0.  If that is too slow, a `check=False` flag could be added.",
    "created_at": "2013-11-04T17:30:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191492",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:16'>Comment 16:</a>
Replying to [@JohnCremona](#comment%3A5):
> Where does that leave this deriv_at1 function?  At the very least it should come with a huge warning about all this.  And it really should return 0 when the root number is +1 unless the user has made an explicit assumption (assume_order_of_vanishing_is_positive=True, say) and otherwise raise a NotImplemented error (or attempt to prove that L(1)=0).

The `Lseries_ell` class has a method `L1_vanishes()`, written by William Stein.  According to the documentation, it is provably correct if the Manin constant is <= 2 for the optimal quotient in the isogeny class.  This method is used in some places, but not currently in `deriv_at1()`, where we might use it to check the assumption *L*(*E*, 1) = 0.  If that is too slow, a `check=False` flag could be added.



---

archive/issue_comments_191493.json:
```json
{
    "body": "<a id='comment:17'>Comment 17:</a>\nJeroen, do you have a particular reason for writing `QQ()` and `R()` instead of `QQ(0)` and `R(0)`?  It saves one character, but is less readable.",
    "created_at": "2013-11-04T17:32:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191493",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:17'>Comment 17:</a>
Jeroen, do you have a particular reason for writing `QQ()` and `R()` instead of `QQ(0)` and `R(0)`?  It saves one character, but is less readable.



---

archive/issue_comments_191494.json:
```json
{
    "body": "<a id='comment:18'>Comment 18:</a>\nReplying to [@pjbruin](#comment%3A17):\n> Jeroen, do you have a particular reason for writing `QQ()` and `R()` instead of `QQ(0)` and `R(0)`?  It saves one character, but is less readable.\n\nNo reason, it's just a habit to think in term of default constructors (I guess this is my C++ background). I just benchmarked `QQ()`, `QQ(0)` and `QQ.zero()` and the latter is the fastest, so perhaps we should use that.",
    "created_at": "2013-11-04T19:34:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191494",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:18'>Comment 18:</a>
Replying to [@pjbruin](#comment%3A17):
> Jeroen, do you have a particular reason for writing `QQ()` and `R()` instead of `QQ(0)` and `R(0)`?  It saves one character, but is less readable.

No reason, it's just a habit to think in term of default constructors (I guess this is my C++ background). I just benchmarked `QQ()`, `QQ(0)` and `QQ.zero()` and the latter is the fastest, so perhaps we should use that.



---

archive/issue_comments_191495.json:
```json
{
    "body": "<a id='comment:19'>Comment 19:</a>\nReplying to [@pjbruin](#comment%3A16):\n> The `Lseries_ell` class has a method `L1_vanishes()`, written by William Stein.  According to the documentation, it is provably correct if the Manin constant is <= 2 for the optimal quotient in the isogeny class.  This method is used in some places, but not currently in `deriv_at1()`, where we might use it to check the assumption *L*(*E*, 1) = 0.  If that is too slow, a `check=False` flag could be added.\n\nDo you propose that this change should be made, or is it just an observation? Given that the function `deriv_at1()` is in practice only called when we know that `L(E,1) = 0`, I personally think the warning suffices.",
    "created_at": "2013-11-04T20:23:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191495",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:19'>Comment 19:</a>
Replying to [@pjbruin](#comment%3A16):
> The `Lseries_ell` class has a method `L1_vanishes()`, written by William Stein.  According to the documentation, it is provably correct if the Manin constant is <= 2 for the optimal quotient in the isogeny class.  This method is used in some places, but not currently in `deriv_at1()`, where we might use it to check the assumption *L*(*E*, 1) = 0.  If that is too slow, a `check=False` flag could be added.

Do you propose that this change should be made, or is it just an observation? Given that the function `deriv_at1()` is in practice only called when we know that `L(E,1) = 0`, I personally think the warning suffices.



---

archive/issue_comments_191496.json:
```json
{
    "body": "<a id='comment:20'>Comment 20:</a>\nReplying to [@jdemeyer](#comment%3A19):\n> Do you propose that this change should be made, or is it just an observation? Given that the function `deriv_at1()` is in practice only called when we know that `L(E,1) = 0`, I personally think the warning suffices.\n\nI agree, it was more an observation that we could in principle use `L1_vanishes()` here than a proposal to actually do it.\n\nThere is a formula for the *r*-th derivative which is valid when all lower derivatives vanish.  As far as I know, only for the 0-th derivative is there a known way to prove that it vanishes by a numerical computation.  For parity reasons (the root number), this means that if the order of vanishing is 0, 1 or 2, then we can prove this.  If the order of vanishing is 3, then in general we don't know how to prove that it is not 1.\n\nThis means that if and when the formula mentioned above is implemented, we won't be able to verify the condition \"all lower derivatives are 0\" when *r* is at least 3.  Hence we should probably not insist on verifying it when *r* = 1.",
    "created_at": "2013-11-04T21:12:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191496",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:20'>Comment 20:</a>
Replying to [@jdemeyer](#comment%3A19):
> Do you propose that this change should be made, or is it just an observation? Given that the function `deriv_at1()` is in practice only called when we know that `L(E,1) = 0`, I personally think the warning suffices.

I agree, it was more an observation that we could in principle use `L1_vanishes()` here than a proposal to actually do it.

There is a formula for the *r*-th derivative which is valid when all lower derivatives vanish.  As far as I know, only for the 0-th derivative is there a known way to prove that it vanishes by a numerical computation.  For parity reasons (the root number), this means that if the order of vanishing is 0, 1 or 2, then we can prove this.  If the order of vanishing is 3, then in general we don't know how to prove that it is not 1.

This means that if and when the formula mentioned above is implemented, we won't be able to verify the condition "all lower derivatives are 0" when *r* is at least 3.  Hence we should probably not insist on verifying it when *r* = 1.



---

archive/issue_comments_191497.json:
```json
{
    "body": "<a id='comment:21'>Comment 21:</a>\nAnother question: is it necessary to compute the error bound to the same precision as the result, i.e. in `RealField(prec)`?  It seems sufficient, and more efficient, to compute it in a lower-precision `RealField` or even just using Python floats.",
    "created_at": "2013-11-04T22:34:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191497",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:21'>Comment 21:</a>
Another question: is it necessary to compute the error bound to the same precision as the result, i.e. in `RealField(prec)`?  It seems sufficient, and more efficient, to compute it in a lower-precision `RealField` or even just using Python floats.



---

archive/issue_comments_191498.json:
```json
{
    "body": "<a id='comment:22'>Comment 22:</a>\nReplying to [@pjbruin](#comment%3A20):\n> Replying to [@jdemeyer](#comment%3A19):\n> > Do you propose that this change should be made, or is it just an observation? Given that the function `deriv_at1()` is in practice only called when we know that `L(E,1) = 0`, I personally think the warning suffices.\n\n> I agree, it was more an observation that we could in principle use `L1_vanishes()` here than a proposal to actually do it.\n> \n> There is a formula for the *r*-th derivative which is valid when all lower derivatives vanish.  As far as I know, only for the 0-th derivative is there a known way to prove that it vanishes by a numerical computation.  For parity reasons (the root number), this means that if the order of vanishing is 0, 1 or 2, then we can prove this.  If the order of vanishing is 3, then in general we don't know how to prove that it is not 1.\n\nYou can go one step further thanks to Gross-Zagier:  if the parity is odd and L'(1) looks zero then you can prove it, since if in fact L'(1)!=0 then the curve would have rank 1, but you can disprove that by finding three (or oeven only 2) independent points. See by talk http://homepages.warwick.ac.uk/staff/J.E.Cremona/papers/bsd50.pdf if you want to read more!\n\n> \n> This means that if and when the formula mentioned above is implemented, we won't be able to verify the condition \"all lower derivatives are 0\" when *r* is at least 3.  Hence we should probably not insist on verifying it when *r* = 1.",
    "created_at": "2013-11-05T09:31:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191498",
    "user": "https://github.com/JohnCremona"
}
```

<a id='comment:22'>Comment 22:</a>
Replying to [@pjbruin](#comment%3A20):
> Replying to [@jdemeyer](#comment%3A19):
> > Do you propose that this change should be made, or is it just an observation? Given that the function `deriv_at1()` is in practice only called when we know that `L(E,1) = 0`, I personally think the warning suffices.

> I agree, it was more an observation that we could in principle use `L1_vanishes()` here than a proposal to actually do it.
> 
> There is a formula for the *r*-th derivative which is valid when all lower derivatives vanish.  As far as I know, only for the 0-th derivative is there a known way to prove that it vanishes by a numerical computation.  For parity reasons (the root number), this means that if the order of vanishing is 0, 1 or 2, then we can prove this.  If the order of vanishing is 3, then in general we don't know how to prove that it is not 1.

You can go one step further thanks to Gross-Zagier:  if the parity is odd and L'(1) looks zero then you can prove it, since if in fact L'(1)!=0 then the curve would have rank 1, but you can disprove that by finding three (or oeven only 2) independent points. See by talk http://homepages.warwick.ac.uk/staff/J.E.Cremona/papers/bsd50.pdf if you want to read more!

> 
> This means that if and when the formula mentioned above is implemented, we won't be able to verify the condition "all lower derivatives are 0" when *r* is at least 3.  Hence we should probably not insist on verifying it when *r* = 1.



---

archive/issue_comments_191499.json:
```json
{
    "body": "<a id='comment:23'>Comment 23:</a>\nReplying to [@JohnCremona](#comment%3A22):\n> You can go one step further thanks to Gross-Zagier:  if the parity is odd and L'(1) looks zero then you can prove it, since if in fact L'(1)!=0 then the curve would have rank 1, but you can disprove that by finding three (or oeven only 2) independent points.\n\nThat is true (in fact I seem to remember learning this from the talk you linked to).  However, it does require you to search for points; there seems to be no \"analytic\" way of proving that L'(1) = 0 by computing it to finite precision, like the `L1_vanishes()` function.",
    "created_at": "2013-11-06T12:18:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191499",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:23'>Comment 23:</a>
Replying to [@JohnCremona](#comment%3A22):
> You can go one step further thanks to Gross-Zagier:  if the parity is odd and L'(1) looks zero then you can prove it, since if in fact L'(1)!=0 then the curve would have rank 1, but you can disprove that by finding three (or oeven only 2) independent points.

That is true (in fact I seem to remember learning this from the talk you linked to).  However, it does require you to search for points; there seems to be no "analytic" way of proving that L'(1) = 0 by computing it to finite precision, like the `L1_vanishes()` function.



---

archive/issue_comments_191500.json:
```json
{
    "body": "<a id='comment:24'>Comment 24:</a>\nReplying to [@pjbruin](#comment%3A21):\n> Another question: is it necessary to compute the error bound to the same precision as the result, i.e. in `RealField(prec)`?  It seems sufficient, and more efficient, to compute it in a lower-precision `RealField`\n\nDone. Needs #15337.\n\n> or even just using Python floats.\n\nNot a good idea, as these have limited range and it's a lot harder (maybe even impossible) to control the rounding. One doctest has an error of 2.74997188336901e-449, which would be rounded to 0.0 as Python `float`.",
    "created_at": "2013-11-08T16:06:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191500",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:24'>Comment 24:</a>
Replying to [@pjbruin](#comment%3A21):
> Another question: is it necessary to compute the error bound to the same precision as the result, i.e. in `RealField(prec)`?  It seems sufficient, and more efficient, to compute it in a lower-precision `RealField`

Done. Needs #15337.

> or even just using Python floats.

Not a good idea, as these have limited range and it's a lot harder (maybe even impossible) to control the rounding. One doctest has an error of 2.74997188336901e-449, which would be rounded to 0.0 as Python `float`.



---

archive/issue_comments_191501.json:
```json
{
    "body": "Reviewer: **Peter Bruin**",
    "created_at": "2013-11-08T23:46:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191501",
    "user": "https://github.com/pjbruin"
}
```

Reviewer: **Peter Bruin**



---

archive/issue_comments_191502.json:
```json
{
    "body": "Dependencies: **#15337**",
    "created_at": "2013-11-08T23:46:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191502",
    "user": "https://github.com/pjbruin"
}
```

Dependencies: **#15337**



---

archive/issue_events_200143.json:
```json
{
    "actor": "https://github.com/pjbruin",
    "created_at": "2013-11-08T23:46:41Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200143"
}
```



---

archive/issue_events_200144.json:
```json
{
    "actor": "https://github.com/pjbruin",
    "created_at": "2013-11-08T23:46:41Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200144"
}
```



---

archive/issue_comments_191503.json:
```json
{
    "body": "<a id='comment:25'>Comment 25:</a>\nThis looks very good now.  The error analysis appears to be completely rigorous for `at1()` and almost completely rigorous for `deriv_at1()`, the only source of non-rigorousness being due to the unknown error in the exponential integral function `eint1()` from PARI.  This ticket is not the place to try to fix this, though.\n\nAre the PARI developers aware of this precision issue?  Should it be regarded it as a bug, or does PARI not strive for proven error bounds for functions such as `eint1()`?",
    "created_at": "2013-11-08T23:46:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191503",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:25'>Comment 25:</a>
This looks very good now.  The error analysis appears to be completely rigorous for `at1()` and almost completely rigorous for `deriv_at1()`, the only source of non-rigorousness being due to the unknown error in the exponential integral function `eint1()` from PARI.  This ticket is not the place to try to fix this, though.

Are the PARI developers aware of this precision issue?  Should it be regarded it as a bug, or does PARI not strive for proven error bounds for functions such as `eint1()`?



---

archive/issue_comments_191504.json:
```json
{
    "body": "<a id='comment:26'>Comment 26:</a>\nReplying to [@pjbruin](#comment%3A25):\n> Are the PARI developers aware of this precision issue?\n\nNo idea. I might report it.\n\n> does PARI not strive for proven error bounds for functions such as `eint1()`?\n\nI don't think PARI does. However, the errors are quite large (over 30 bits can be wrong), so perhaps that's a bug indeed.",
    "created_at": "2013-11-09T14:26:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191504",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:26'>Comment 26:</a>
Replying to [@pjbruin](#comment%3A25):
> Are the PARI developers aware of this precision issue?

No idea. I might report it.

> does PARI not strive for proven error bounds for functions such as `eint1()`?

I don't think PARI does. However, the errors are quite large (over 30 bits can be wrong), so perhaps that's a bug indeed.



---

archive/issue_events_200145.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-09T14:26:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "milestone_number": null,
    "milestone_title": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200145"
}
```



---

archive/issue_events_200146.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-09T14:26:56Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/pending",
    "label_color": "008080",
    "label_name": "pending",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200146"
}
```



---

archive/issue_comments_191505.json:
```json
{
    "body": "Upstream: **Fixed upstream, but not in a stable release.**",
    "created_at": "2013-11-09T23:09:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191505",
    "user": "https://github.com/jdemeyer"
}
```

Upstream: **Fixed upstream, but not in a stable release.**



---

archive/issue_comments_191506.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -16,3 +16,5 @@\n (-4.32787398660869448751904675450772492666840247314688171540527473331725818170217268435223462033366791557160872926179439894639315476270837428785657638252738603056742447337636326343956370276624493916496382120766160023620812331280787034239648552009947468067829864968026720015203778821069593806584e-277,\n  1.82478252137476307223140369768561190028055347258560054363485475966241792307587640145132294203994875344783110100551912347495775160520204557245032474939095251969168953786545612090565728262067746413119194690260652692254781091147749697957445424152473292233020112755190503925812425294821095313979e-270)\n ```\n+\n+While working on this, we found an upstream PARI bug: the precision for `exponential_integal_1()` was not as good as it could be.\n``````\n",
    "created_at": "2013-11-09T23:09:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191506",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -16,3 +16,5 @@
 (-4.32787398660869448751904675450772492666840247314688171540527473331725818170217268435223462033366791557160872926179439894639315476270837428785657638252738603056742447337636326343956370276624493916496382120766160023620812331280787034239648552009947468067829864968026720015203778821069593806584e-277,
  1.82478252137476307223140369768561190028055347258560054363485475966241792307587640145132294203994875344783110100551912347495775160520204557245032474939095251969168953786545612090565728262067746413119194690260652692254781091147749697957445424152473292233020112755190503925812425294821095313979e-270)
 ```
+
+While working on this, we found an upstream PARI bug: the precision for `exponential_integal_1()` was not as good as it could be.
``````




---

archive/issue_comments_191507.json:
```json
{
    "body": "<a id='comment:27'>Comment 27:</a>\nReported the precision issue, they fixed it. There is supposed to be an absolute error bound (not relative), but I don't know what the bound is...",
    "created_at": "2013-11-09T23:09:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191507",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:27'>Comment 27:</a>
Reported the precision issue, they fixed it. There is supposed to be an absolute error bound (not relative), but I don't know what the bound is...



---

archive/issue_comments_191508.json:
```json
{
    "body": "Changed dependencies from **#15337** to **#15337, #15402**",
    "created_at": "2013-11-12T23:47:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191508",
    "user": "https://github.com/jdemeyer"
}
```

Changed dependencies from **#15337** to **#15337, #15402**



---

archive/issue_comments_191509.json:
```json
{
    "body": "<a id='comment:28'>Comment 28:</a>\nMoved part of the patch to #15402.",
    "created_at": "2013-11-12T23:47:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191509",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:28'>Comment 28:</a>
Moved part of the patch to #15402.



---

archive/issue_comments_191510.json:
```json
{
    "body": "<a id='comment:29'>Comment 29:</a>\nAttachment: **[15299_lseries_prec.patch.gz](https://github.com/sagemath/sage/files/ticket15299/15299_lseries_prec.patch.gz)**\n\nChanged error bounds because of #15402, needs review.",
    "created_at": "2013-11-13T16:44:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191510",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:29'>Comment 29:</a>
Attachment: **[15299_lseries_prec.patch.gz](https://github.com/sagemath/sage/files/ticket15299/15299_lseries_prec.patch.gz)**

Changed error bounds because of #15402, needs review.



---

archive/issue_events_200147.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-13T16:44:43Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200147"
}
```



---

archive/issue_events_200148.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-13T16:44:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200148"
}
```



---

archive/issue_events_200149.json:
```json
{
    "actor": "https://github.com/pjbruin",
    "created_at": "2013-11-19T18:20:04Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200149"
}
```



---

archive/issue_events_200150.json:
```json
{
    "actor": "https://github.com/pjbruin",
    "created_at": "2013-11-19T18:20:04Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200150"
}
```



---

archive/issue_comments_191511.json:
```json
{
    "body": "<a id='comment:30'>Comment 30:</a>\nLooks even better than before, the precision is now much better under control thanks to #15402, and the remaining \"arbitrary\" precision increase is clearly motivated.\n\nAs in #15402, just a trivial review patch to refer to a section instead of a page number in Cohen's book.",
    "created_at": "2013-11-19T18:20:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191511",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:30'>Comment 30:</a>
Looks even better than before, the precision is now much better under control thanks to #15402, and the remaining "arbitrary" precision increase is clearly motivated.

As in #15402, just a trivial review patch to refer to a section instead of a page number in Cohen's book.



---

archive/issue_comments_191512.json:
```json
{
    "body": "Attachment: **[15299_reviewer.patch.gz](https://github.com/sagemath/sage/files/ticket15299/15299_reviewer.patch.gz)**\n\nreplace page number by section number in Cohen reference",
    "created_at": "2013-11-19T18:21:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191512",
    "user": "https://github.com/pjbruin"
}
```

Attachment: **[15299_reviewer.patch.gz](https://github.com/sagemath/sage/files/ticket15299/15299_reviewer.patch.gz)**

replace page number by section number in Cohen reference



---

archive/issue_comments_191513.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -18,3 +18,6 @@\n ```\n \n While working on this, we found an upstream PARI bug: the precision for `exponential_integal_1()` was not as good as it could be.\n+\n+Apply: [[attachment: 15299_reviewer.patch.gz](https://github.com/sagemath/sage/files/ticket15299/15299_reviewer.patch.gz)(https://github.com/sagemath/sage/files/ticket15299/6d3f7c7f40d82637b455a01f92caa998.gz)\n+\n``````\n",
    "created_at": "2013-11-19T18:22:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191513",
    "user": "https://github.com/pjbruin"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -18,3 +18,6 @@
 ```
 
 While working on this, we found an upstream PARI bug: the precision for `exponential_integal_1()` was not as good as it could be.
+
+Apply: [[attachment: 15299_reviewer.patch.gz](https://github.com/sagemath/sage/files/ticket15299/15299_reviewer.patch.gz)(https://github.com/sagemath/sage/files/ticket15299/6d3f7c7f40d82637b455a01f92caa998.gz)
+
``````




---

archive/issue_events_200151.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-22T15:50:22Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "milestone_number": null,
    "milestone_title": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200151"
}
```



---

archive/issue_events_200152.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-22T15:50:22Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/pending",
    "label_color": "008080",
    "label_name": "pending",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200152"
}
```



---

archive/issue_comments_191514.json:
```json
{
    "body": "Merged: **sage-5.13.beta4**",
    "created_at": "2013-11-24T17:26:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/15299#issuecomment-191514",
    "user": "https://github.com/jdemeyer"
}
```

Merged: **sage-5.13.beta4**



---

archive/issue_events_200153.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-24T17:26:13Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200153"
}
```



---

archive/issue_events_200154.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-24T17:26:13Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/15299",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/15299#event-200154"
}
```
