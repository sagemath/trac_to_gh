# Issue 15703: Refactor Coxeter groups as matrix groups and non crystallographic root systems

archive/issues_015466.json:
```json
{
    "body": "This is a follow up to #9290.\n\n* Experiment with the infrastructure scales and benchmark \n\n* CoxeterGraph, see #16126\n  - Create a class similar to DynkinDiagram\n    Starter: an edge-labeled graph.\n  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n    Starter: just make this a function\n\n* Update DynkinDiagram to support non crystallographic case:\n  - Add an argument base_ring to the constructor\n  - Add a method base_ring\n  - Make add_edge honor this method when automatically adding edges\n  - Update cartan_matrix() to use the base_ring\n  - Add a method _test_base_ring that checks that all edge labels are\n    indeed in this base ring\n  - Implement is_crystallographic testing if the base ring is ZZ\n  - Add an argument symmetric=False to the constructor, and make\n    add_edge and symmetrizer use it.\n  - Add a method _test_dynkin_diagram that tests that the Dynkin\n    diagram indeed defines a proper root system. See in particular\n    cartan_matrix.is_generalized_cartan_matrix.\n  - adapt column() and row() method to give the labels in the base ring\n\n  * Update CartanMatrix, see #17798\n  - Add a base ring argument to the constructor\n  - Update is_crystallographic\n  - Update is_affine\n  - Update is_finite\n  - Update is_generalized_cartan_matrix\n\n* CartanType\n  - Possibly update to accept appropriate data to build a CoxeterGraph (e.g. a matrix)\n  - Add a base_ring method?\n  - Decide on the semantic of is_crystallographic (symmetrizable or\n    not?), and if possibly add an is_... method to decide whether the\n    entries are integral or not.\n  - Provide a dynkin_diagram method that builds the Dynkin diagram\n    from the Coxeter diagram when available\n  - Test: H_3 and friends should have a working dynkin_diagram method\n\n* RootSystem\n  - Decide on the meaning of root_lattice: either disable it in the\n    non integral case, or have it be the span of the roots over the\n    smallest available ring.\n\n* RootLatticeRealizations:\n  - Feed this to RootSystem, and check that the root space and weight\n    space are built properly.\n  - Rename the weyl_group method to reflection_group, with an alias\n    from weyl_group; update the setting of the category.\n  - Define a new projection \"transversal\" to visualise root systems (and find a right name for it)\n  - Long run: stuff specific to the crystallographic case, starting\n    with this weyl_group method, should go in\n    RootLatticeRealizations.Crystallographic. That's for a follow up\n    ticket on using axioms for root systems; but let's not depend on\n    #10963 right now.\n\n* RootSpace (for this ticket or some follow up):\n  - Define the inner product\n  - adapt the is_positive_root to make it work for any base ring\n  - Signature of the bilinear form\n\n* CoxeterMatrixGroup and WeylGroup:\n  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n    and lift as many features as possible from WeylGroup to\n    CoxeterMatrixGroup.\n  - Check that, with a proper Dynkin diagram, the conversion to GAP\n    issue does not appear\n  - Now or later: we probably want the Weyl group elements to be\n    represented by Sage matrices, but keep a handle to the\n    corresponding Gap group. Currently one has to make a choice\n    between MatrixGroup_generic and MatrixGroup_gap.\n\n* Plotting:\n  - add a family_of_points method in the projections to be used by the \"transversal projection\"\n\n* Update WeylGroups:\n  - inversions: use the \"root_lattice\" by default?\n\n\nTests:\n\n```\n  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n  sage: L = RootSystem(C).root_space()\n  sage: W = L.reflection_group()\n  sage: W = CoxeterGroup(['H',3])\n  sage: W.domain()\n```\nSage Days 57 in Cernay will be a good occasion to work on this.\n\nFollow ups: #16087\n\n[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n\n\nCC:  sage-combinat @tscrim @jplab vripoll @mathzeta\n\nKeywords: coxeter groups, days57\n\nReviewer: Nicolas M. Thi\u00e9ry\n\nAuthor: Jean-Philippe Labb\u00e9, Vivien Ripoll\n\nBranch: u/jipilab/refactor_coxeter_groups_as_matrix_groups_and_non_crystallographic_root_systems\n\nStatus: new\n\nDependencies: #16120, #16126, #16130, #17798, #18152\n\nCommit: 09a1ff9ae3fe50ab4b1d4c31f0afe682ed5173e1\n\nIssue created by migration from https://trac.sagemath.org/ticket/15703\n\n",
    "created_at": "2014-01-21T10:08:53Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Refactor Coxeter groups as matrix groups and non crystallographic root systems",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15703",
    "user": "https://github.com/nthiery"
}
```
This is a follow up to #9290.

* Experiment with the infrastructure scales and benchmark 

* CoxeterGraph, see #16126
  - Create a class similar to DynkinDiagram
    Starter: an edge-labeled graph.
  - Edge labels: m_{i,j}, possibly with number <-1 for oo
  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
    Starter: just make this a function

* Update DynkinDiagram to support non crystallographic case:
  - Add an argument base_ring to the constructor
  - Add a method base_ring
  - Make add_edge honor this method when automatically adding edges
  - Update cartan_matrix() to use the base_ring
  - Add a method _test_base_ring that checks that all edge labels are
    indeed in this base ring
  - Implement is_crystallographic testing if the base ring is ZZ
  - Add an argument symmetric=False to the constructor, and make
    add_edge and symmetrizer use it.
  - Add a method _test_dynkin_diagram that tests that the Dynkin
    diagram indeed defines a proper root system. See in particular
    cartan_matrix.is_generalized_cartan_matrix.
  - adapt column() and row() method to give the labels in the base ring

  * Update CartanMatrix, see #17798
  - Add a base ring argument to the constructor
  - Update is_crystallographic
  - Update is_affine
  - Update is_finite
  - Update is_generalized_cartan_matrix

* CartanType
  - Possibly update to accept appropriate data to build a CoxeterGraph (e.g. a matrix)
  - Add a base_ring method?
  - Decide on the semantic of is_crystallographic (symmetrizable or
    not?), and if possibly add an is_... method to decide whether the
    entries are integral or not.
  - Provide a dynkin_diagram method that builds the Dynkin diagram
    from the Coxeter diagram when available
  - Test: H_3 and friends should have a working dynkin_diagram method

* RootSystem
  - Decide on the meaning of root_lattice: either disable it in the
    non integral case, or have it be the span of the roots over the
    smallest available ring.

* RootLatticeRealizations:
  - Feed this to RootSystem, and check that the root space and weight
    space are built properly.
  - Rename the weyl_group method to reflection_group, with an alias
    from weyl_group; update the setting of the category.
  - Define a new projection "transversal" to visualise root systems (and find a right name for it)
  - Long run: stuff specific to the crystallographic case, starting
    with this weyl_group method, should go in
    RootLatticeRealizations.Crystallographic. That's for a follow up
    ticket on using axioms for root systems; but let's not depend on
    #10963 right now.

* RootSpace (for this ticket or some follow up):
  - Define the inner product
  - adapt the is_positive_root to make it work for any base ring
  - Signature of the bilinear form

* CoxeterMatrixGroup and WeylGroup:
  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
    and lift as many features as possible from WeylGroup to
    CoxeterMatrixGroup.
  - Check that, with a proper Dynkin diagram, the conversion to GAP
    issue does not appear
  - Now or later: we probably want the Weyl group elements to be
    represented by Sage matrices, but keep a handle to the
    corresponding Gap group. Currently one has to make a choice
    between MatrixGroup_generic and MatrixGroup_gap.

* Plotting:
  - add a family_of_points method in the projections to be used by the "transversal projection"

* Update WeylGroups:
  - inversions: use the "root_lattice" by default?


Tests:

```
  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
  sage: L = RootSystem(C).root_space()
  sage: W = L.reflection_group()
  sage: W = CoxeterGroup(['H',3])
  sage: W.domain()
```
Sage Days 57 in Cernay will be a good occasion to work on this.

Follow ups: #16087

[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.


CC:  sage-combinat @tscrim @jplab vripoll @mathzeta

Keywords: coxeter groups, days57

Reviewer: Nicolas M. Thiéry

Author: Jean-Philippe Labbé, Vivien Ripoll

Branch: u/jipilab/refactor_coxeter_groups_as_matrix_groups_and_non_crystallographic_root_systems

Status: new

Dependencies: #16120, #16126, #16130, #17798, #18152

Commit: 09a1ff9ae3fe50ab4b1d4c31f0afe682ed5173e1

Issue created by migration from https://trac.sagemath.org/ticket/15703





---

archive/issue_events_046085.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15703#event-46085"
}
```



---

archive/issue_comments_212968.json:
```json
{
    "body": "Changing keywords from \"\" to \"coxeter\".",
    "created_at": "2014-02-17T10:53:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212968",
    "user": "https://github.com/fchapoton"
}
```

Changing keywords from "" to "coxeter".



---

archive/issue_comments_212969.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -10,7 +10,7 @@\n \n As a prerequisite, implement root spaces and weight spaces for non-crystallographic Coxeter groups.\n \n-Sage Days 47 in Cernay will be a good occasion to work on this.\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n \n Comment: 1\n \n```\n",
    "created_at": "2014-04-07T15:32:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212969",
    "user": "https://github.com/nthiery"
}
```

Description changed:
```diff
--- 
+++ 
@@ -10,7 +10,7 @@
 
 As a prerequisite, implement root spaces and weight spaces for non-crystallographic Coxeter groups.
 
-Sage Days 47 in Cernay will be a good occasion to work on this.
+Sage Days 57 in Cernay will be a good occasion to work on this.
 
 Comment: 1
 
```




---

archive/issue_comments_212970.json:
```json
{
    "body": "Changing keywords from \"coxeter\" to \"coxeter groups, days57\".",
    "created_at": "2014-04-08T06:09:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212970",
    "user": "https://github.com/nthiery"
}
```

Changing keywords from "coxeter" to "coxeter groups, days57".



---

archive/issue_comments_212971.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,44 @@\n+This is a follow up to: #9290.\n+\n+- Create a class CoxeterDiagram (similar to DynkinDiagram)\n+  Edge labels: m_{i,j}, possibly with number <-1 for oo\n+\n+  Starter: just use a plain digraph.\n+\n+- Implement the method dynkin_diagram() which builds the cartan matrix\n+  for the geometric representation\n+\n+  Starter: just make this a function\n+\n+- Feed this to RootSystem, and check that the root space and weight\n+  space are built properly. Rename the weyl_group method to\n+  reflection_group, with an alias from weyl_group.\n+\n+- Long run: stuff specific to the crystallographic case, starting with\n+  this weyl_group method, should go in\n+  RootLatticeRealizations.Crystallographic. That's for a follow up\n+  ticket on using axioms for root systems; but let's not depend on\n+  #10963 right now.\n+\n+- Refactor CoxeterMatrixGroup and WeylGroup to make the later a\n+  subclass of the former, and lift as many features as possible from\n+  WeylGroup to CoxeterMatrixGroup.\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2014-04-08T06:09:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212971",
    "user": "https://github.com/nthiery"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,44 @@
+This is a follow up to: #9290.
+
+- Create a class CoxeterDiagram (similar to DynkinDiagram)
+  Edge labels: m_{i,j}, possibly with number <-1 for oo
+
+  Starter: just use a plain digraph.
+
+- Implement the method dynkin_diagram() which builds the cartan matrix
+  for the geometric representation
+
+  Starter: just make this a function
+
+- Feed this to RootSystem, and check that the root space and weight
+  space are built properly. Rename the weyl_group method to
+  reflection_group, with an alias from weyl_group.
+
+- Long run: stuff specific to the crystallographic case, starting with
+  this weyl_group method, should go in
+  RootLatticeRealizations.Crystallographic. That's for a follow up
+  ticket on using axioms for root systems; but let's not depend on
+  #10963 right now.
+
+- Refactor CoxeterMatrixGroup and WeylGroup to make the later a
+  subclass of the former, and lift as many features as possible from
+  WeylGroup to CoxeterMatrixGroup.
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```




---

archive/issue_comments_212972.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,4 +1,33 @@\n+This is a follow up to: #9290.\n \n+* Create a class CoxeterGraph (similar to DynkinDiagram) Edge labels: m_{i,j}, possibly with number <-1 for oo\n+\n+  Starter: a edge-labeled graph.\n+\n+* Implement the method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+\n+  Starter: just make this a function\n+\n+* Feed this to RootSystem, and check that the root space and weight space are built properly. Rename the weyl_group method to reflection_group, with an alias from weyl_group.\n+\n+* Long run: stuff specific to the crystallographic case, starting with this weyl_group method, should go in RootLatticeRealizations.Crystallographic. That's for a follow up ticket on using axioms for root systems; but let's not depend on #10963 right now.\n+\n+* Refactor CoxeterMatrixGroup and WeylGroup to make the latter a subclass of the former, and lift as many features as possible from WeylGroup to CoxeterMatrixGroup.\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n Comment: 1\n \n```\n",
    "created_at": "2014-04-08T09:00:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212972",
    "user": "https://github.com/jplab"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,4 +1,33 @@
+This is a follow up to: #9290.
 
+* Create a class CoxeterGraph (similar to DynkinDiagram) Edge labels: m_{i,j}, possibly with number <-1 for oo
+
+  Starter: a edge-labeled graph.
+
+* Implement the method dynkin_diagram() which builds the cartan matrix for the geometric representation
+
+  Starter: just make this a function
+
+* Feed this to RootSystem, and check that the root space and weight space are built properly. Rename the weyl_group method to reflection_group, with an alias from weyl_group.
+
+* Long run: stuff specific to the crystallographic case, starting with this weyl_group method, should go in RootLatticeRealizations.Crystallographic. That's for a follow up ticket on using axioms for root systems; but let's not depend on #10963 right now.
+
+* Refactor CoxeterMatrixGroup and WeylGroup to make the latter a subclass of the former, and lift as many features as possible from WeylGroup to CoxeterMatrixGroup.
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 Comment: 1
 
```




---

archive/issue_comments_212973.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,116 @@\n+This is a follow up to #9290.\n+\n+* Experiment with the infrastructure scales and benchmark\n+\n+  - Build by hand an interesting dynkin diagram.\n+  - Shoot straight at producing a nice plot with a bunch of limit roots.\n+  - Post the picture here.\n+  - Benchmark the calculation.\n+  - Every hack along the way is fair.\n+  - Update the TODO list below with what would need to be done for a\n+    proper implementation.\n+  - Discard the experiment.\n+\n+* CoxegerGraph\n+\n+  - Create a class similar to DynkinDiagram\n+    Starter: an edge-labeled graph.\n+  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+    Starter: just make this a function\n+\n+* Update DynkinDiagram to support non crystallographic case:\n+\n+  - Add an argument base_ring to the constructor\n+  - Add a method base_ring\n+  - Make add_edge honor this method when automatically adding edges\n+  - Update cartan_matrix() to use the base_ring\n+  - Add a method _test_base_ring that checks that all edge labels are\n+    indeed in this base ring\n+  - Implement is_crystallographic testing if the base ring is ZZ\n+  - Add an argument symmetric=False to the constructor, and make\n+    add_edge and symmetrizer use it.\n+  - Add a method _test_dynkin_diagram that tests that the Dynkin\n+    diagram indeed defines a proper root system. See in particular\n+    cartan_matrix.is_generalized_cartan_matrix.\n+\n+  * Update CartanMatrix\n+  - Add a base ring argument to the constructor\n+  - Update is_crystallographic\n+  - Decide on the semantic of crystallographic (symmetrizable or\n+    not?), and if possibly add an is_... method to decide whether the\n+    entries are integral or not.\n+  - Update is_affine\n+  - Update is_finite\n+  - Update is_generalized_cartan_matrix\n+\n+* CartanType\n+  - Possibly update to accept appropriate data to build a\n+    CoxeterDiagram\n+\n+* RootSystem\n+\n+  - Decide on the meaning of root_lattice: either disable it in the\n+    non integral case, or have it be the span of the roots over the\n+    smallest available ring.\n+\n+* RootLatticeRealizations:\n+\n+  - Feed this to RootSystem, and check that the root space and weight\n+    space are built properly.\n+  - Rename the weyl_group method to reflection_group, with an alias\n+    from weyl_group; update the setting of the category.\n+  - Long run: stuff specific to the crystallographic case, starting\n+    with this weyl_group method, should go in\n+    RootLatticeRealizations.Crystallographic. That's for a follow up\n+    ticket on using axioms for root systems; but let's not depend on\n+    #10963 right now.\n+\n+* RootSpace (for this ticket or some follow up):\n+\n+  - Define the inner product\n+  - Signature of the bilinear form\n+\n+* CoxeterMatrixGroup and WeylGroup:\n+\n+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n+    and lift as many features as possible from WeylGroup to\n+    CoxeterMatrixGroup.\n+  - Check that, with a proper Dynkin diagram, the conversion to GAP\n+    issue does not appear\n+  - Now or later: we probably want the Weyl group elements to be\n+    represented by Sage matrices, but keep a handle to the\n+    corresponding Gap group. Currently one has to make a choice\n+    between MatrixGroup_generic and MatrixGroup_gap.\n+\n+* Update WeylGroups:\n+\n+  - inversions: use the \"root_lattice\" by default?\n+\n+* Cartan types\n+\n+  - provide a dynkin_diagram method that builds the Dynkin diagram\n+    from the Coxeter diagram when available?\n+  - Test: H_3 and friends should have a working dynkin_diagram method\n+\n+* Prerequisites:\n+\n+  - Add a _float_ method to UCF\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2014-04-09T06:44:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212973",
    "user": "https://github.com/nthiery"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,116 @@
+This is a follow up to #9290.
+
+* Experiment with the infrastructure scales and benchmark
+
+  - Build by hand an interesting dynkin diagram.
+  - Shoot straight at producing a nice plot with a bunch of limit roots.
+  - Post the picture here.
+  - Benchmark the calculation.
+  - Every hack along the way is fair.
+  - Update the TODO list below with what would need to be done for a
+    proper implementation.
+  - Discard the experiment.
+
+* CoxegerGraph
+
+  - Create a class similar to DynkinDiagram
+    Starter: an edge-labeled graph.
+  - Edge labels: m_{i,j}, possibly with number <-1 for oo
+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
+    Starter: just make this a function
+
+* Update DynkinDiagram to support non crystallographic case:
+
+  - Add an argument base_ring to the constructor
+  - Add a method base_ring
+  - Make add_edge honor this method when automatically adding edges
+  - Update cartan_matrix() to use the base_ring
+  - Add a method _test_base_ring that checks that all edge labels are
+    indeed in this base ring
+  - Implement is_crystallographic testing if the base ring is ZZ
+  - Add an argument symmetric=False to the constructor, and make
+    add_edge and symmetrizer use it.
+  - Add a method _test_dynkin_diagram that tests that the Dynkin
+    diagram indeed defines a proper root system. See in particular
+    cartan_matrix.is_generalized_cartan_matrix.
+
+  * Update CartanMatrix
+  - Add a base ring argument to the constructor
+  - Update is_crystallographic
+  - Decide on the semantic of crystallographic (symmetrizable or
+    not?), and if possibly add an is_... method to decide whether the
+    entries are integral or not.
+  - Update is_affine
+  - Update is_finite
+  - Update is_generalized_cartan_matrix
+
+* CartanType
+  - Possibly update to accept appropriate data to build a
+    CoxeterDiagram
+
+* RootSystem
+
+  - Decide on the meaning of root_lattice: either disable it in the
+    non integral case, or have it be the span of the roots over the
+    smallest available ring.
+
+* RootLatticeRealizations:
+
+  - Feed this to RootSystem, and check that the root space and weight
+    space are built properly.
+  - Rename the weyl_group method to reflection_group, with an alias
+    from weyl_group; update the setting of the category.
+  - Long run: stuff specific to the crystallographic case, starting
+    with this weyl_group method, should go in
+    RootLatticeRealizations.Crystallographic. That's for a follow up
+    ticket on using axioms for root systems; but let's not depend on
+    #10963 right now.
+
+* RootSpace (for this ticket or some follow up):
+
+  - Define the inner product
+  - Signature of the bilinear form
+
+* CoxeterMatrixGroup and WeylGroup:
+
+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
+    and lift as many features as possible from WeylGroup to
+    CoxeterMatrixGroup.
+  - Check that, with a proper Dynkin diagram, the conversion to GAP
+    issue does not appear
+  - Now or later: we probably want the Weyl group elements to be
+    represented by Sage matrices, but keep a handle to the
+    corresponding Gap group. Currently one has to make a choice
+    between MatrixGroup_generic and MatrixGroup_gap.
+
+* Update WeylGroups:
+
+  - inversions: use the "root_lattice" by default?
+
+* Cartan types
+
+  - provide a dynkin_diagram method that builds the Dynkin diagram
+    from the Coxeter diagram when available?
+  - Test: H_3 and friends should have a working dynkin_diagram method
+
+* Prerequisites:
+
+  - Add a _float_ method to UCF
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```




---

archive/issue_comments_212974.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,104 @@\n+This is a follow up to #9290.\n+\n+* Experiment with the infrastructure scales and benchmark\n+  - Build by hand an interesting dynkin diagram.\n+  - Shoot straight at producing a nice plot with a bunch of limit roots.\n+  - Post the picture here.\n+  - Benchmark the calculation.\n+  - Every hack along the way is fair.\n+  - Update the TODO list below with what would need to be done for a\n+    proper implementation.\n+  - Discard the experiment.\n+\n+* CoxegerGraph\n+  - Create a class similar to DynkinDiagram\n+    Starter: an edge-labeled graph.\n+  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+    Starter: just make this a function\n+\n+* Update DynkinDiagram to support non crystallographic case:\n+  - Add an argument base_ring to the constructor\n+  - Add a method base_ring\n+  - Make add_edge honor this method when automatically adding edges\n+  - Update cartan_matrix() to use the base_ring\n+  - Add a method _test_base_ring that checks that all edge labels are\n+    indeed in this base ring\n+  - Implement is_crystallographic testing if the base ring is ZZ\n+  - Add an argument symmetric=False to the constructor, and make\n+    add_edge and symmetrizer use it.\n+  - Add a method _test_dynkin_diagram that tests that the Dynkin\n+    diagram indeed defines a proper root system. See in particular\n+    cartan_matrix.is_generalized_cartan_matrix.\n+\n+  * Update CartanMatrix\n+  - Add a base ring argument to the constructor\n+  - Update is_crystallographic\n+  - Update is_affine\n+  - Update is_finite\n+  - Update is_generalized_cartan_matrix\n+\n+* CartanType\n+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)\n+  - Add a base_ring method?\n+  - Decide on the semantic of is_crystallographic (symmetrizable or\n+    not?), and if possibly add an is_... method to decide whether the\n+    entries are integral or not.\n+  - Provide a dynkin_diagram method that builds the Dynkin diagram\n+    from the Coxeter diagram when available\n+  - Test: H_3 and friends should have a working dynkin_diagram method\n+\n+* RootSystem\n+  - Decide on the meaning of root_lattice: either disable it in the\n+    non integral case, or have it be the span of the roots over the\n+    smallest available ring.\n+\n+* RootLatticeRealizations:\n+  - Feed this to RootSystem, and check that the root space and weight\n+    space are built properly.\n+  - Rename the weyl_group method to reflection_group, with an alias\n+    from weyl_group; update the setting of the category.\n+  - Long run: stuff specific to the crystallographic case, starting\n+    with this weyl_group method, should go in\n+    RootLatticeRealizations.Crystallographic. That's for a follow up\n+    ticket on using axioms for root systems; but let's not depend on\n+    #10963 right now.\n+\n+* RootSpace (for this ticket or some follow up):\n+  - Define the inner product\n+  - Signature of the bilinear form\n+\n+* CoxeterMatrixGroup and WeylGroup:\n+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n+    and lift as many features as possible from WeylGroup to\n+    CoxeterMatrixGroup.\n+  - Check that, with a proper Dynkin diagram, the conversion to GAP\n+    issue does not appear\n+  - Now or later: we probably want the Weyl group elements to be\n+    represented by Sage matrices, but keep a handle to the\n+    corresponding Gap group. Currently one has to make a choice\n+    between MatrixGroup_generic and MatrixGroup_gap.\n+\n+* Update WeylGroups:\n+  - inversions: use the \"root_lattice\" by default?\n+\n+* Prerequisites:\n+  - Add a _float_ method to UCF\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2014-04-09T06:47:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212974",
    "user": "https://github.com/nthiery"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,104 @@
+This is a follow up to #9290.
+
+* Experiment with the infrastructure scales and benchmark
+  - Build by hand an interesting dynkin diagram.
+  - Shoot straight at producing a nice plot with a bunch of limit roots.
+  - Post the picture here.
+  - Benchmark the calculation.
+  - Every hack along the way is fair.
+  - Update the TODO list below with what would need to be done for a
+    proper implementation.
+  - Discard the experiment.
+
+* CoxegerGraph
+  - Create a class similar to DynkinDiagram
+    Starter: an edge-labeled graph.
+  - Edge labels: m_{i,j}, possibly with number <-1 for oo
+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
+    Starter: just make this a function
+
+* Update DynkinDiagram to support non crystallographic case:
+  - Add an argument base_ring to the constructor
+  - Add a method base_ring
+  - Make add_edge honor this method when automatically adding edges
+  - Update cartan_matrix() to use the base_ring
+  - Add a method _test_base_ring that checks that all edge labels are
+    indeed in this base ring
+  - Implement is_crystallographic testing if the base ring is ZZ
+  - Add an argument symmetric=False to the constructor, and make
+    add_edge and symmetrizer use it.
+  - Add a method _test_dynkin_diagram that tests that the Dynkin
+    diagram indeed defines a proper root system. See in particular
+    cartan_matrix.is_generalized_cartan_matrix.
+
+  * Update CartanMatrix
+  - Add a base ring argument to the constructor
+  - Update is_crystallographic
+  - Update is_affine
+  - Update is_finite
+  - Update is_generalized_cartan_matrix
+
+* CartanType
+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)
+  - Add a base_ring method?
+  - Decide on the semantic of is_crystallographic (symmetrizable or
+    not?), and if possibly add an is_... method to decide whether the
+    entries are integral or not.
+  - Provide a dynkin_diagram method that builds the Dynkin diagram
+    from the Coxeter diagram when available
+  - Test: H_3 and friends should have a working dynkin_diagram method
+
+* RootSystem
+  - Decide on the meaning of root_lattice: either disable it in the
+    non integral case, or have it be the span of the roots over the
+    smallest available ring.
+
+* RootLatticeRealizations:
+  - Feed this to RootSystem, and check that the root space and weight
+    space are built properly.
+  - Rename the weyl_group method to reflection_group, with an alias
+    from weyl_group; update the setting of the category.
+  - Long run: stuff specific to the crystallographic case, starting
+    with this weyl_group method, should go in
+    RootLatticeRealizations.Crystallographic. That's for a follow up
+    ticket on using axioms for root systems; but let's not depend on
+    #10963 right now.
+
+* RootSpace (for this ticket or some follow up):
+  - Define the inner product
+  - Signature of the bilinear form
+
+* CoxeterMatrixGroup and WeylGroup:
+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
+    and lift as many features as possible from WeylGroup to
+    CoxeterMatrixGroup.
+  - Check that, with a proper Dynkin diagram, the conversion to GAP
+    issue does not appear
+  - Now or later: we probably want the Weyl group elements to be
+    represented by Sage matrices, but keep a handle to the
+    corresponding Gap group. Currently one has to make a choice
+    between MatrixGroup_generic and MatrixGroup_gap.
+
+* Update WeylGroups:
+  - inversions: use the "root_lattice" by default?
+
+* Prerequisites:
+  - Add a _float_ method to UCF
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```




---

archive/issue_comments_212975.json:
```json
{
    "body": "<a id='comment:11'></a>I believe I'm taking care of the inner product on the root space in #15384 (which I  called `symmetric_form()`). Also for a followup ticket, we should implement/refactor things for symmetrizable and the non-symmetrizable types (for when we get the hyperbolic types done).",
    "created_at": "2014-04-09T14:28:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212975",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:11'></a>I believe I'm taking care of the inner product on the root space in #15384 (which I  called `symmetric_form()`). Also for a followup ticket, we should implement/refactor things for symmetrizable and the non-symmetrizable types (for when we get the hyperbolic types done).



---

archive/issue_comments_212976.json:
```json
{
    "body": "<a id='comment:12'></a>Very good!\n\nJust a small suggestion: I would call the function \"bilinear_form\". Although it is true that we deal with symmetric forms so far...",
    "created_at": "2014-04-09T14:48:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212976",
    "user": "https://github.com/jplab"
}
```

<a id='comment:12'></a>Very good!

Just a small suggestion: I would call the function "bilinear_form". Although it is true that we deal with symmetric forms so far...



---

archive/issue_comments_212977.json:
```json
{
    "body": "Attachment [benchmark.png](tarball://root/attachments/some-uuid/ticket15703/benchmark.png) by @jplab created at 2014-04-10 12:27:41",
    "created_at": "2014-04-10T12:27:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212977",
    "user": "https://github.com/jplab"
}
```

Attachment [benchmark.png](tarball://root/attachments/some-uuid/ticket15703/benchmark.png) by @jplab created at 2014-04-10 12:27:41



---

archive/issue_comments_212978.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,106 @@\n+This is a follow up to #9290.\n+\n+* Experiment with the infrastructure scales and benchmark \n+\n+  Here is a goal picture (benchmark.png) given by the Coxeter matrix [[1,oo,2,5],[oo,1,6,2],[2,6,1,-1.1],[5,2,-1.1,1]]. It represents the limit roots of the elements of infinite order of length 3 and 4, and their orbits under the actions of elements of length smaller or equal to 5. There are 12212 drawn limits. (Not showing 66 limit roots that created approximation errors coming from a \"to be looked at\" usage of solve in my code). With a homemade implementation, it took 42 seconds to do the computations of everything from scratch and also the computation of the tetrahedron and the light cone.\n+\n+  - Shoot straight at producing a nice plot with a bunch of limit roots.\n+  - Post the picture here.\n+  - Benchmark the calculation.\n+  - Every hack along the way is fair.\n+  - Update the TODO list below with what would need to be done for a\n+    proper implementation.\n+  - Discard the experiment.\n+\n+* CoxegerGraph\n+  - Create a class similar to DynkinDiagram\n+    Starter: an edge-labeled graph.\n+  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+    Starter: just make this a function\n+\n+* Update DynkinDiagram to support non crystallographic case:\n+  - Add an argument base_ring to the constructor\n+  - Add a method base_ring\n+  - Make add_edge honor this method when automatically adding edges\n+  - Update cartan_matrix() to use the base_ring\n+  - Add a method _test_base_ring that checks that all edge labels are\n+    indeed in this base ring\n+  - Implement is_crystallographic testing if the base ring is ZZ\n+  - Add an argument symmetric=False to the constructor, and make\n+    add_edge and symmetrizer use it.\n+  - Add a method _test_dynkin_diagram that tests that the Dynkin\n+    diagram indeed defines a proper root system. See in particular\n+    cartan_matrix.is_generalized_cartan_matrix.\n+\n+  * Update CartanMatrix\n+  - Add a base ring argument to the constructor\n+  - Update is_crystallographic\n+  - Update is_affine\n+  - Update is_finite\n+  - Update is_generalized_cartan_matrix\n+\n+* CartanType\n+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)\n+  - Add a base_ring method?\n+  - Decide on the semantic of is_crystallographic (symmetrizable or\n+    not?), and if possibly add an is_... method to decide whether the\n+    entries are integral or not.\n+  - Provide a dynkin_diagram method that builds the Dynkin diagram\n+    from the Coxeter diagram when available\n+  - Test: H_3 and friends should have a working dynkin_diagram method\n+\n+* RootSystem\n+  - Decide on the meaning of root_lattice: either disable it in the\n+    non integral case, or have it be the span of the roots over the\n+    smallest available ring.\n+\n+* RootLatticeRealizations:\n+  - Feed this to RootSystem, and check that the root space and weight\n+    space are built properly.\n+  - Rename the weyl_group method to reflection_group, with an alias\n+    from weyl_group; update the setting of the category.\n+  - Long run: stuff specific to the crystallographic case, starting\n+    with this weyl_group method, should go in\n+    RootLatticeRealizations.Crystallographic. That's for a follow up\n+    ticket on using axioms for root systems; but let's not depend on\n+    #10963 right now.\n+\n+* RootSpace (for this ticket or some follow up):\n+  - Define the inner product\n+  - Signature of the bilinear form\n+\n+* CoxeterMatrixGroup and WeylGroup:\n+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n+    and lift as many features as possible from WeylGroup to\n+    CoxeterMatrixGroup.\n+  - Check that, with a proper Dynkin diagram, the conversion to GAP\n+    issue does not appear\n+  - Now or later: we probably want the Weyl group elements to be\n+    represented by Sage matrices, but keep a handle to the\n+    corresponding Gap group. Currently one has to make a choice\n+    between MatrixGroup_generic and MatrixGroup_gap.\n+\n+* Update WeylGroups:\n+  - inversions: use the \"root_lattice\" by default?\n+\n+* Prerequisites:\n+  - Add a __float__ method to UCF, see #16120\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2014-04-10T12:30:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212978",
    "user": "https://github.com/jplab"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,106 @@
+This is a follow up to #9290.
+
+* Experiment with the infrastructure scales and benchmark 
+
+  Here is a goal picture (benchmark.png) given by the Coxeter matrix [[1,oo,2,5],[oo,1,6,2],[2,6,1,-1.1],[5,2,-1.1,1]]. It represents the limit roots of the elements of infinite order of length 3 and 4, and their orbits under the actions of elements of length smaller or equal to 5. There are 12212 drawn limits. (Not showing 66 limit roots that created approximation errors coming from a "to be looked at" usage of solve in my code). With a homemade implementation, it took 42 seconds to do the computations of everything from scratch and also the computation of the tetrahedron and the light cone.
+
+  - Shoot straight at producing a nice plot with a bunch of limit roots.
+  - Post the picture here.
+  - Benchmark the calculation.
+  - Every hack along the way is fair.
+  - Update the TODO list below with what would need to be done for a
+    proper implementation.
+  - Discard the experiment.
+
+* CoxegerGraph
+  - Create a class similar to DynkinDiagram
+    Starter: an edge-labeled graph.
+  - Edge labels: m_{i,j}, possibly with number <-1 for oo
+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
+    Starter: just make this a function
+
+* Update DynkinDiagram to support non crystallographic case:
+  - Add an argument base_ring to the constructor
+  - Add a method base_ring
+  - Make add_edge honor this method when automatically adding edges
+  - Update cartan_matrix() to use the base_ring
+  - Add a method _test_base_ring that checks that all edge labels are
+    indeed in this base ring
+  - Implement is_crystallographic testing if the base ring is ZZ
+  - Add an argument symmetric=False to the constructor, and make
+    add_edge and symmetrizer use it.
+  - Add a method _test_dynkin_diagram that tests that the Dynkin
+    diagram indeed defines a proper root system. See in particular
+    cartan_matrix.is_generalized_cartan_matrix.
+
+  * Update CartanMatrix
+  - Add a base ring argument to the constructor
+  - Update is_crystallographic
+  - Update is_affine
+  - Update is_finite
+  - Update is_generalized_cartan_matrix
+
+* CartanType
+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)
+  - Add a base_ring method?
+  - Decide on the semantic of is_crystallographic (symmetrizable or
+    not?), and if possibly add an is_... method to decide whether the
+    entries are integral or not.
+  - Provide a dynkin_diagram method that builds the Dynkin diagram
+    from the Coxeter diagram when available
+  - Test: H_3 and friends should have a working dynkin_diagram method
+
+* RootSystem
+  - Decide on the meaning of root_lattice: either disable it in the
+    non integral case, or have it be the span of the roots over the
+    smallest available ring.
+
+* RootLatticeRealizations:
+  - Feed this to RootSystem, and check that the root space and weight
+    space are built properly.
+  - Rename the weyl_group method to reflection_group, with an alias
+    from weyl_group; update the setting of the category.
+  - Long run: stuff specific to the crystallographic case, starting
+    with this weyl_group method, should go in
+    RootLatticeRealizations.Crystallographic. That's for a follow up
+    ticket on using axioms for root systems; but let's not depend on
+    #10963 right now.
+
+* RootSpace (for this ticket or some follow up):
+  - Define the inner product
+  - Signature of the bilinear form
+
+* CoxeterMatrixGroup and WeylGroup:
+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
+    and lift as many features as possible from WeylGroup to
+    CoxeterMatrixGroup.
+  - Check that, with a proper Dynkin diagram, the conversion to GAP
+    issue does not appear
+  - Now or later: we probably want the Weyl group elements to be
+    represented by Sage matrices, but keep a handle to the
+    corresponding Gap group. Currently one has to make a choice
+    between MatrixGroup_generic and MatrixGroup_gap.
+
+* Update WeylGroups:
+  - inversions: use the "root_lattice" by default?
+
+* Prerequisites:
+  - Add a __float__ method to UCF, see #16120
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```




---

archive/issue_comments_212979.json:
```json
{
    "body": "<a id='comment:16'></a>New commits:",
    "created_at": "2014-04-10T17:47:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212979",
    "user": "https://github.com/jplab"
}
```

<a id='comment:16'></a>New commits:



---

archive/issue_comments_212980.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,106 @@\n+This is a follow up to #9290.\n+\n+* Experiment with the infrastructure scales and benchmark \n+\n+  Here is a goal picture (benchmark.png) given by the Coxeter matrix [[1,oo,2,5],[oo,1,6,2],[2,6,1,-1.1],[5,2,-1.1,1]]. It represents the limit roots of the elements of infinite order of length 3 and 4, and their orbits under the actions of elements of length smaller or equal to 5. There are 12212 drawn limits. (Not showing 66 limit roots that created approximation errors coming from a \"to be looked at\" usage of solve in my code). With a homemade implementation, it took 42 seconds to do the computations of everything from scratch and also the computation of the tetrahedron and the light cone.\n+\n+  - Shoot straight at producing a nice plot with a bunch of limit roots.\n+  - Post the picture here.\n+  - Benchmark the calculation.\n+  - Every hack along the way is fair.\n+  - Update the TODO list below with what would need to be done for a\n+    proper implementation.\n+  - Discard the experiment.\n+\n+* CoxegerGraph, see #16126\n+  - Create a class similar to DynkinDiagram\n+    Starter: an edge-labeled graph.\n+  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+    Starter: just make this a function\n+\n+* Update DynkinDiagram to support non crystallographic case:\n+  - Add an argument base_ring to the constructor\n+  - Add a method base_ring\n+  - Make add_edge honor this method when automatically adding edges\n+  - Update cartan_matrix() to use the base_ring\n+  - Add a method _test_base_ring that checks that all edge labels are\n+    indeed in this base ring\n+  - Implement is_crystallographic testing if the base ring is ZZ\n+  - Add an argument symmetric=False to the constructor, and make\n+    add_edge and symmetrizer use it.\n+  - Add a method _test_dynkin_diagram that tests that the Dynkin\n+    diagram indeed defines a proper root system. See in particular\n+    cartan_matrix.is_generalized_cartan_matrix.\n+\n+  * Update CartanMatrix\n+  - Add a base ring argument to the constructor\n+  - Update is_crystallographic\n+  - Update is_affine\n+  - Update is_finite\n+  - Update is_generalized_cartan_matrix\n+\n+* CartanType\n+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)\n+  - Add a base_ring method?\n+  - Decide on the semantic of is_crystallographic (symmetrizable or\n+    not?), and if possibly add an is_... method to decide whether the\n+    entries are integral or not.\n+  - Provide a dynkin_diagram method that builds the Dynkin diagram\n+    from the Coxeter diagram when available\n+  - Test: H_3 and friends should have a working dynkin_diagram method\n+\n+* RootSystem\n+  - Decide on the meaning of root_lattice: either disable it in the\n+    non integral case, or have it be the span of the roots over the\n+    smallest available ring.\n+\n+* RootLatticeRealizations:\n+  - Feed this to RootSystem, and check that the root space and weight\n+    space are built properly.\n+  - Rename the weyl_group method to reflection_group, with an alias\n+    from weyl_group; update the setting of the category.\n+  - Long run: stuff specific to the crystallographic case, starting\n+    with this weyl_group method, should go in\n+    RootLatticeRealizations.Crystallographic. That's for a follow up\n+    ticket on using axioms for root systems; but let's not depend on\n+    #10963 right now.\n+\n+* RootSpace (for this ticket or some follow up):\n+  - Define the inner product\n+  - Signature of the bilinear form\n+\n+* CoxeterMatrixGroup and WeylGroup:\n+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n+    and lift as many features as possible from WeylGroup to\n+    CoxeterMatrixGroup.\n+  - Check that, with a proper Dynkin diagram, the conversion to GAP\n+    issue does not appear\n+  - Now or later: we probably want the Weyl group elements to be\n+    represented by Sage matrices, but keep a handle to the\n+    corresponding Gap group. Currently one has to make a choice\n+    between MatrixGroup_generic and MatrixGroup_gap.\n+\n+* Update WeylGroups:\n+  - inversions: use the \"root_lattice\" by default?\n+\n+* Prerequisites:\n+  - Add a __float__ method to UCF, see #16120\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2014-04-10T17:47:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212980",
    "user": "https://github.com/jplab"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,106 @@
+This is a follow up to #9290.
+
+* Experiment with the infrastructure scales and benchmark 
+
+  Here is a goal picture (benchmark.png) given by the Coxeter matrix [[1,oo,2,5],[oo,1,6,2],[2,6,1,-1.1],[5,2,-1.1,1]]. It represents the limit roots of the elements of infinite order of length 3 and 4, and their orbits under the actions of elements of length smaller or equal to 5. There are 12212 drawn limits. (Not showing 66 limit roots that created approximation errors coming from a "to be looked at" usage of solve in my code). With a homemade implementation, it took 42 seconds to do the computations of everything from scratch and also the computation of the tetrahedron and the light cone.
+
+  - Shoot straight at producing a nice plot with a bunch of limit roots.
+  - Post the picture here.
+  - Benchmark the calculation.
+  - Every hack along the way is fair.
+  - Update the TODO list below with what would need to be done for a
+    proper implementation.
+  - Discard the experiment.
+
+* CoxegerGraph, see #16126
+  - Create a class similar to DynkinDiagram
+    Starter: an edge-labeled graph.
+  - Edge labels: m_{i,j}, possibly with number <-1 for oo
+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
+    Starter: just make this a function
+
+* Update DynkinDiagram to support non crystallographic case:
+  - Add an argument base_ring to the constructor
+  - Add a method base_ring
+  - Make add_edge honor this method when automatically adding edges
+  - Update cartan_matrix() to use the base_ring
+  - Add a method _test_base_ring that checks that all edge labels are
+    indeed in this base ring
+  - Implement is_crystallographic testing if the base ring is ZZ
+  - Add an argument symmetric=False to the constructor, and make
+    add_edge and symmetrizer use it.
+  - Add a method _test_dynkin_diagram that tests that the Dynkin
+    diagram indeed defines a proper root system. See in particular
+    cartan_matrix.is_generalized_cartan_matrix.
+
+  * Update CartanMatrix
+  - Add a base ring argument to the constructor
+  - Update is_crystallographic
+  - Update is_affine
+  - Update is_finite
+  - Update is_generalized_cartan_matrix
+
+* CartanType
+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)
+  - Add a base_ring method?
+  - Decide on the semantic of is_crystallographic (symmetrizable or
+    not?), and if possibly add an is_... method to decide whether the
+    entries are integral or not.
+  - Provide a dynkin_diagram method that builds the Dynkin diagram
+    from the Coxeter diagram when available
+  - Test: H_3 and friends should have a working dynkin_diagram method
+
+* RootSystem
+  - Decide on the meaning of root_lattice: either disable it in the
+    non integral case, or have it be the span of the roots over the
+    smallest available ring.
+
+* RootLatticeRealizations:
+  - Feed this to RootSystem, and check that the root space and weight
+    space are built properly.
+  - Rename the weyl_group method to reflection_group, with an alias
+    from weyl_group; update the setting of the category.
+  - Long run: stuff specific to the crystallographic case, starting
+    with this weyl_group method, should go in
+    RootLatticeRealizations.Crystallographic. That's for a follow up
+    ticket on using axioms for root systems; but let's not depend on
+    #10963 right now.
+
+* RootSpace (for this ticket or some follow up):
+  - Define the inner product
+  - Signature of the bilinear form
+
+* CoxeterMatrixGroup and WeylGroup:
+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
+    and lift as many features as possible from WeylGroup to
+    CoxeterMatrixGroup.
+  - Check that, with a proper Dynkin diagram, the conversion to GAP
+    issue does not appear
+  - Now or later: we probably want the Weyl group elements to be
+    represented by Sage matrices, but keep a handle to the
+    corresponding Gap group. Currently one has to make a choice
+    between MatrixGroup_generic and MatrixGroup_gap.
+
+* Update WeylGroups:
+  - inversions: use the "root_lattice" by default?
+
+* Prerequisites:
+  - Add a __float__ method to UCF, see #16120
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```




---

archive/issue_comments_212981.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,100 @@\n+This is a follow up to #9290.\n+\n+* Experiment with the infrastructure scales and benchmark \n+\n+  Here is a goal picture (benchmark.png) given by the Coxeter matrix [[1,oo,2,5],[oo,1,6,2],[2,6,1,-1.1],[5,2,-1.1,1]]. It represents the limit roots of the elements of infinite order of length 3 and 4, and their orbits under the actions of elements of length smaller or equal to 5. There are 12212 drawn limits. (Not showing 66 limit roots that created approximation errors coming from a \"to be looked at\" usage of solve in my code). With a homemade implementation, it took 42 seconds to do the computations of everything from scratch and also the computation of the tetrahedron and the light cone.\n+\n+  The picture named benchmark2.png shows an image produced with sage with hacks and tweaks. It took around 10 minutes to compute. There are 2347 roots shown. (There was a problem in the production of the roots located at (0,0,0)) These roots is formed as the union of the inversion sets of the elements of length at most 8 obtained via the weak order poset.\n+\n+* CoxegerGraph, see #16126\n+  - Create a class similar to DynkinDiagram\n+    Starter: an edge-labeled graph.\n+  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+    Starter: just make this a function\n+\n+* Update DynkinDiagram to support non crystallographic case:\n+  - Add an argument base_ring to the constructor\n+  - Add a method base_ring\n+  - Make add_edge honor this method when automatically adding edges\n+  - Update cartan_matrix() to use the base_ring\n+  - Add a method _test_base_ring that checks that all edge labels are\n+    indeed in this base ring\n+  - Implement is_crystallographic testing if the base ring is ZZ\n+  - Add an argument symmetric=False to the constructor, and make\n+    add_edge and symmetrizer use it.\n+  - Add a method _test_dynkin_diagram that tests that the Dynkin\n+    diagram indeed defines a proper root system. See in particular\n+    cartan_matrix.is_generalized_cartan_matrix.\n+\n+  * Update CartanMatrix\n+  - Add a base ring argument to the constructor\n+  - Update is_crystallographic\n+  - Update is_affine\n+  - Update is_finite\n+  - Update is_generalized_cartan_matrix\n+\n+* CartanType\n+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)\n+  - Add a base_ring method?\n+  - Decide on the semantic of is_crystallographic (symmetrizable or\n+    not?), and if possibly add an is_... method to decide whether the\n+    entries are integral or not.\n+  - Provide a dynkin_diagram method that builds the Dynkin diagram\n+    from the Coxeter diagram when available\n+  - Test: H_3 and friends should have a working dynkin_diagram method\n+\n+* RootSystem\n+  - Decide on the meaning of root_lattice: either disable it in the\n+    non integral case, or have it be the span of the roots over the\n+    smallest available ring.\n+\n+* RootLatticeRealizations:\n+  - Feed this to RootSystem, and check that the root space and weight\n+    space are built properly.\n+  - Rename the weyl_group method to reflection_group, with an alias\n+    from weyl_group; update the setting of the category.\n+  - Long run: stuff specific to the crystallographic case, starting\n+    with this weyl_group method, should go in\n+    RootLatticeRealizations.Crystallographic. That's for a follow up\n+    ticket on using axioms for root systems; but let's not depend on\n+    #10963 right now.\n+\n+* RootSpace (for this ticket or some follow up):\n+  - Define the inner product\n+  - Signature of the bilinear form\n+\n+* CoxeterMatrixGroup and WeylGroup:\n+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n+    and lift as many features as possible from WeylGroup to\n+    CoxeterMatrixGroup.\n+  - Check that, with a proper Dynkin diagram, the conversion to GAP\n+    issue does not appear\n+  - Now or later: we probably want the Weyl group elements to be\n+    represented by Sage matrices, but keep a handle to the\n+    corresponding Gap group. Currently one has to make a choice\n+    between MatrixGroup_generic and MatrixGroup_gap.\n+\n+* Update WeylGroups:\n+  - inversions: use the \"root_lattice\" by default?\n+\n+* Prerequisites:\n+  - Add a __float__ method to UCF, see #16120\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2014-04-13T15:38:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212981",
    "user": "https://github.com/jplab"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,100 @@
+This is a follow up to #9290.
+
+* Experiment with the infrastructure scales and benchmark 
+
+  Here is a goal picture (benchmark.png) given by the Coxeter matrix [[1,oo,2,5],[oo,1,6,2],[2,6,1,-1.1],[5,2,-1.1,1]]. It represents the limit roots of the elements of infinite order of length 3 and 4, and their orbits under the actions of elements of length smaller or equal to 5. There are 12212 drawn limits. (Not showing 66 limit roots that created approximation errors coming from a "to be looked at" usage of solve in my code). With a homemade implementation, it took 42 seconds to do the computations of everything from scratch and also the computation of the tetrahedron and the light cone.
+
+  The picture named benchmark2.png shows an image produced with sage with hacks and tweaks. It took around 10 minutes to compute. There are 2347 roots shown. (There was a problem in the production of the roots located at (0,0,0)) These roots is formed as the union of the inversion sets of the elements of length at most 8 obtained via the weak order poset.
+
+* CoxegerGraph, see #16126
+  - Create a class similar to DynkinDiagram
+    Starter: an edge-labeled graph.
+  - Edge labels: m_{i,j}, possibly with number <-1 for oo
+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
+    Starter: just make this a function
+
+* Update DynkinDiagram to support non crystallographic case:
+  - Add an argument base_ring to the constructor
+  - Add a method base_ring
+  - Make add_edge honor this method when automatically adding edges
+  - Update cartan_matrix() to use the base_ring
+  - Add a method _test_base_ring that checks that all edge labels are
+    indeed in this base ring
+  - Implement is_crystallographic testing if the base ring is ZZ
+  - Add an argument symmetric=False to the constructor, and make
+    add_edge and symmetrizer use it.
+  - Add a method _test_dynkin_diagram that tests that the Dynkin
+    diagram indeed defines a proper root system. See in particular
+    cartan_matrix.is_generalized_cartan_matrix.
+
+  * Update CartanMatrix
+  - Add a base ring argument to the constructor
+  - Update is_crystallographic
+  - Update is_affine
+  - Update is_finite
+  - Update is_generalized_cartan_matrix
+
+* CartanType
+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)
+  - Add a base_ring method?
+  - Decide on the semantic of is_crystallographic (symmetrizable or
+    not?), and if possibly add an is_... method to decide whether the
+    entries are integral or not.
+  - Provide a dynkin_diagram method that builds the Dynkin diagram
+    from the Coxeter diagram when available
+  - Test: H_3 and friends should have a working dynkin_diagram method
+
+* RootSystem
+  - Decide on the meaning of root_lattice: either disable it in the
+    non integral case, or have it be the span of the roots over the
+    smallest available ring.
+
+* RootLatticeRealizations:
+  - Feed this to RootSystem, and check that the root space and weight
+    space are built properly.
+  - Rename the weyl_group method to reflection_group, with an alias
+    from weyl_group; update the setting of the category.
+  - Long run: stuff specific to the crystallographic case, starting
+    with this weyl_group method, should go in
+    RootLatticeRealizations.Crystallographic. That's for a follow up
+    ticket on using axioms for root systems; but let's not depend on
+    #10963 right now.
+
+* RootSpace (for this ticket or some follow up):
+  - Define the inner product
+  - Signature of the bilinear form
+
+* CoxeterMatrixGroup and WeylGroup:
+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
+    and lift as many features as possible from WeylGroup to
+    CoxeterMatrixGroup.
+  - Check that, with a proper Dynkin diagram, the conversion to GAP
+    issue does not appear
+  - Now or later: we probably want the Weyl group elements to be
+    represented by Sage matrices, but keep a handle to the
+    corresponding Gap group. Currently one has to make a choice
+    between MatrixGroup_generic and MatrixGroup_gap.
+
+* Update WeylGroups:
+  - inversions: use the "root_lattice" by default?
+
+* Prerequisites:
+  - Add a __float__ method to UCF, see #16120
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```




---

archive/issue_comments_212982.json:
```json
{
    "body": "Attachment [benchmark2.png](tarball://root/attachments/some-uuid/ticket15703/benchmark2.png) by @jplab created at 2014-04-13 15:39:16",
    "created_at": "2014-04-13T15:39:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212982",
    "user": "https://github.com/jplab"
}
```

Attachment [benchmark2.png](tarball://root/attachments/some-uuid/ticket15703/benchmark2.png) by @jplab created at 2014-04-13 15:39:16



---

archive/issue_comments_212983.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,106 @@\n+This is a follow up to #9290.\n+\n+* Experiment with the infrastructure scales and benchmark \n+\n+  Here is a goal picture (benchmark.png) given by the Coxeter matrix [[1,oo,2,5],[oo,1,6,2],[2,6,1,-1.1],[5,2,-1.1,1]]. It represents the limit roots of the elements of infinite order of length 3 and 4, and their orbits under the actions of elements of length smaller or equal to 5. There are 12212 drawn limits. (Not showing 66 limit roots that created approximation errors coming from a \"to be looked at\" usage of solve in my code). With a homemade implementation, it took 42 seconds to do the computations of everything from scratch and also the computation of the tetrahedron and the light cone.\n+\n+  The picture named benchmark2.png shows an image produced with sage with hacks and tweaks. It took around 10 minutes to compute. There are 2347 roots shown. (There was a problem in the production of the roots located at (0,0,0)) These roots is formed as the union of the inversion sets of the elements of length at most 8 obtained via the weak order poset.\n+\n+* CoxegerGraph, see #16126\n+  - Create a class similar to DynkinDiagram\n+    Starter: an edge-labeled graph.\n+  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+    Starter: just make this a function\n+\n+* Update DynkinDiagram to support non crystallographic case:\n+  - Add an argument base_ring to the constructor\n+  - Add a method base_ring\n+  - Make add_edge honor this method when automatically adding edges\n+  - Update cartan_matrix() to use the base_ring\n+  - Add a method _test_base_ring that checks that all edge labels are\n+    indeed in this base ring\n+  - Implement is_crystallographic testing if the base ring is ZZ\n+  - Add an argument symmetric=False to the constructor, and make\n+    add_edge and symmetrizer use it.\n+  - Add a method _test_dynkin_diagram that tests that the Dynkin\n+    diagram indeed defines a proper root system. See in particular\n+    cartan_matrix.is_generalized_cartan_matrix.\n+  - adapt column() and row() method to give the labels in the base ring\n+\n+  * Update CartanMatrix\n+  - Add a base ring argument to the constructor\n+  - Update is_crystallographic\n+  - Update is_affine\n+  - Update is_finite\n+  - Update is_generalized_cartan_matrix\n+\n+* CartanType\n+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)\n+  - Add a base_ring method?\n+  - Decide on the semantic of is_crystallographic (symmetrizable or\n+    not?), and if possibly add an is_... method to decide whether the\n+    entries are integral or not.\n+  - Provide a dynkin_diagram method that builds the Dynkin diagram\n+    from the Coxeter diagram when available\n+  - Test: H_3 and friends should have a working dynkin_diagram method\n+\n+* RootSystem\n+  - Decide on the meaning of root_lattice: either disable it in the\n+    non integral case, or have it be the span of the roots over the\n+    smallest available ring.\n+\n+* RootLatticeRealizations:\n+  - Feed this to RootSystem, and check that the root space and weight\n+    space are built properly.\n+  - Rename the weyl_group method to reflection_group, with an alias\n+    from weyl_group; update the setting of the category.\n+  - Define a new projection \"transversal\" to visualise root systems (and find a right name for it)\n+  - Long run: stuff specific to the crystallographic case, starting\n+    with this weyl_group method, should go in\n+    RootLatticeRealizations.Crystallographic. That's for a follow up\n+    ticket on using axioms for root systems; but let's not depend on\n+    #10963 right now.\n+\n+* RootSpace (for this ticket or some follow up):\n+  - Define the inner product\n+  - adapt the is_positive_root to make it work for any base ring\n+  - Signature of the bilinear form\n+\n+* CoxeterMatrixGroup and WeylGroup:\n+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n+    and lift as many features as possible from WeylGroup to\n+    CoxeterMatrixGroup.\n+  - Check that, with a proper Dynkin diagram, the conversion to GAP\n+    issue does not appear\n+  - Now or later: we probably want the Weyl group elements to be\n+    represented by Sage matrices, but keep a handle to the\n+    corresponding Gap group. Currently one has to make a choice\n+    between MatrixGroup_generic and MatrixGroup_gap.\n+\n+* Plotting:\n+  - add a family_of_points method in the projections to be used by the \"transversal projection\"\n+\n+* Update WeylGroups:\n+  - inversions: use the \"root_lattice\" by default?\n+\n+* Prerequisites:\n+  - Add a __float__ method to UCF, see #16120\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2014-04-13T15:56:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212983",
    "user": "https://github.com/jplab"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,106 @@
+This is a follow up to #9290.
+
+* Experiment with the infrastructure scales and benchmark 
+
+  Here is a goal picture (benchmark.png) given by the Coxeter matrix [[1,oo,2,5],[oo,1,6,2],[2,6,1,-1.1],[5,2,-1.1,1]]. It represents the limit roots of the elements of infinite order of length 3 and 4, and their orbits under the actions of elements of length smaller or equal to 5. There are 12212 drawn limits. (Not showing 66 limit roots that created approximation errors coming from a "to be looked at" usage of solve in my code). With a homemade implementation, it took 42 seconds to do the computations of everything from scratch and also the computation of the tetrahedron and the light cone.
+
+  The picture named benchmark2.png shows an image produced with sage with hacks and tweaks. It took around 10 minutes to compute. There are 2347 roots shown. (There was a problem in the production of the roots located at (0,0,0)) These roots is formed as the union of the inversion sets of the elements of length at most 8 obtained via the weak order poset.
+
+* CoxegerGraph, see #16126
+  - Create a class similar to DynkinDiagram
+    Starter: an edge-labeled graph.
+  - Edge labels: m_{i,j}, possibly with number <-1 for oo
+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
+    Starter: just make this a function
+
+* Update DynkinDiagram to support non crystallographic case:
+  - Add an argument base_ring to the constructor
+  - Add a method base_ring
+  - Make add_edge honor this method when automatically adding edges
+  - Update cartan_matrix() to use the base_ring
+  - Add a method _test_base_ring that checks that all edge labels are
+    indeed in this base ring
+  - Implement is_crystallographic testing if the base ring is ZZ
+  - Add an argument symmetric=False to the constructor, and make
+    add_edge and symmetrizer use it.
+  - Add a method _test_dynkin_diagram that tests that the Dynkin
+    diagram indeed defines a proper root system. See in particular
+    cartan_matrix.is_generalized_cartan_matrix.
+  - adapt column() and row() method to give the labels in the base ring
+
+  * Update CartanMatrix
+  - Add a base ring argument to the constructor
+  - Update is_crystallographic
+  - Update is_affine
+  - Update is_finite
+  - Update is_generalized_cartan_matrix
+
+* CartanType
+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)
+  - Add a base_ring method?
+  - Decide on the semantic of is_crystallographic (symmetrizable or
+    not?), and if possibly add an is_... method to decide whether the
+    entries are integral or not.
+  - Provide a dynkin_diagram method that builds the Dynkin diagram
+    from the Coxeter diagram when available
+  - Test: H_3 and friends should have a working dynkin_diagram method
+
+* RootSystem
+  - Decide on the meaning of root_lattice: either disable it in the
+    non integral case, or have it be the span of the roots over the
+    smallest available ring.
+
+* RootLatticeRealizations:
+  - Feed this to RootSystem, and check that the root space and weight
+    space are built properly.
+  - Rename the weyl_group method to reflection_group, with an alias
+    from weyl_group; update the setting of the category.
+  - Define a new projection "transversal" to visualise root systems (and find a right name for it)
+  - Long run: stuff specific to the crystallographic case, starting
+    with this weyl_group method, should go in
+    RootLatticeRealizations.Crystallographic. That's for a follow up
+    ticket on using axioms for root systems; but let's not depend on
+    #10963 right now.
+
+* RootSpace (for this ticket or some follow up):
+  - Define the inner product
+  - adapt the is_positive_root to make it work for any base ring
+  - Signature of the bilinear form
+
+* CoxeterMatrixGroup and WeylGroup:
+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
+    and lift as many features as possible from WeylGroup to
+    CoxeterMatrixGroup.
+  - Check that, with a proper Dynkin diagram, the conversion to GAP
+    issue does not appear
+  - Now or later: we probably want the Weyl group elements to be
+    represented by Sage matrices, but keep a handle to the
+    corresponding Gap group. Currently one has to make a choice
+    between MatrixGroup_generic and MatrixGroup_gap.
+
+* Plotting:
+  - add a family_of_points method in the projections to be used by the "transversal projection"
+
+* Update WeylGroups:
+  - inversions: use the "root_lattice" by default?
+
+* Prerequisites:
+  - Add a __float__ method to UCF, see #16120
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```




---

archive/issue_comments_212984.json:
```json
{
    "body": "<a id='comment:21'></a>I adapted the TODO list in relation with the latest changes I just pushed. The script joined allows you to create the pictures and do some tests...\n\nNow we have to work!!\n\n---\nNew commits:",
    "created_at": "2014-04-13T15:59:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212984",
    "user": "https://github.com/jplab"
}
```

<a id='comment:21'></a>I adapted the TODO list in relation with the latest changes I just pushed. The script joined allows you to create the pictures and do some tests...

Now we have to work!!

---
New commits:



---

archive/issue_comments_212985.json:
```json
{
    "body": "<a id='comment:22'></a>Attachment [test_rootsystems.sage](tarball://root/attachments/some-uuid/ticket15703/test_rootsystems.sage) by vbraun_spam created at 2014-05-06 15:20:58",
    "created_at": "2014-05-06T15:20:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212985",
    "user": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam"
}
```

<a id='comment:22'></a>Attachment [test_rootsystems.sage](tarball://root/attachments/some-uuid/ticket15703/test_rootsystems.sage) by vbraun_spam created at 2014-05-06 15:20:58



---

archive/issue_events_046086.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15703#event-46086"
}
```



---

archive/issue_events_046087.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15703#event-46087"
}
```



---

archive/issue_events_046088.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15703#event-46088"
}
```



---

archive/issue_events_046089.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15703#event-46089"
}
```



---

archive/issue_comments_212986.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,102 @@\n+This is a follow up to #9290.\n+\n+* Experiment with the infrastructure scales and benchmark \n+\n+* CoxegerGraph, see #16126\n+  - Create a class similar to DynkinDiagram\n+    Starter: an edge-labeled graph.\n+  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+    Starter: just make this a function\n+\n+* Update DynkinDiagram to support non crystallographic case:\n+  - Add an argument base_ring to the constructor\n+  - Add a method base_ring\n+  - Make add_edge honor this method when automatically adding edges\n+  - Update cartan_matrix() to use the base_ring\n+  - Add a method _test_base_ring that checks that all edge labels are\n+    indeed in this base ring\n+  - Implement is_crystallographic testing if the base ring is ZZ\n+  - Add an argument symmetric=False to the constructor, and make\n+    add_edge and symmetrizer use it.\n+  - Add a method _test_dynkin_diagram that tests that the Dynkin\n+    diagram indeed defines a proper root system. See in particular\n+    cartan_matrix.is_generalized_cartan_matrix.\n+  - adapt column() and row() method to give the labels in the base ring\n+\n+  * Update CartanMatrix\n+  - Add a base ring argument to the constructor\n+  - Update is_crystallographic\n+  - Update is_affine\n+  - Update is_finite\n+  - Update is_generalized_cartan_matrix\n+\n+* CartanType\n+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)\n+  - Add a base_ring method?\n+  - Decide on the semantic of is_crystallographic (symmetrizable or\n+    not?), and if possibly add an is_... method to decide whether the\n+    entries are integral or not.\n+  - Provide a dynkin_diagram method that builds the Dynkin diagram\n+    from the Coxeter diagram when available\n+  - Test: H_3 and friends should have a working dynkin_diagram method\n+\n+* RootSystem\n+  - Decide on the meaning of root_lattice: either disable it in the\n+    non integral case, or have it be the span of the roots over the\n+    smallest available ring.\n+\n+* RootLatticeRealizations:\n+  - Feed this to RootSystem, and check that the root space and weight\n+    space are built properly.\n+  - Rename the weyl_group method to reflection_group, with an alias\n+    from weyl_group; update the setting of the category.\n+  - Define a new projection \"transversal\" to visualise root systems (and find a right name for it)\n+  - Long run: stuff specific to the crystallographic case, starting\n+    with this weyl_group method, should go in\n+    RootLatticeRealizations.Crystallographic. That's for a follow up\n+    ticket on using axioms for root systems; but let's not depend on\n+    #10963 right now.\n+\n+* RootSpace (for this ticket or some follow up):\n+  - Define the inner product\n+  - adapt the is_positive_root to make it work for any base ring\n+  - Signature of the bilinear form\n+\n+* CoxeterMatrixGroup and WeylGroup:\n+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n+    and lift as many features as possible from WeylGroup to\n+    CoxeterMatrixGroup.\n+  - Check that, with a proper Dynkin diagram, the conversion to GAP\n+    issue does not appear\n+  - Now or later: we probably want the Weyl group elements to be\n+    represented by Sage matrices, but keep a handle to the\n+    corresponding Gap group. Currently one has to make a choice\n+    between MatrixGroup_generic and MatrixGroup_gap.\n+\n+* Plotting:\n+  - add a family_of_points method in the projections to be used by the \"transversal projection\"\n+\n+* Update WeylGroups:\n+  - inversions: use the \"root_lattice\" by default?\n+\n+* Prerequisites:\n+  - Add a __float__ method to UCF, see #16120\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2015-03-17T23:14:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212986",
    "user": "https://github.com/jplab"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,102 @@
+This is a follow up to #9290.
+
+* Experiment with the infrastructure scales and benchmark 
+
+* CoxegerGraph, see #16126
+  - Create a class similar to DynkinDiagram
+    Starter: an edge-labeled graph.
+  - Edge labels: m_{i,j}, possibly with number <-1 for oo
+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
+    Starter: just make this a function
+
+* Update DynkinDiagram to support non crystallographic case:
+  - Add an argument base_ring to the constructor
+  - Add a method base_ring
+  - Make add_edge honor this method when automatically adding edges
+  - Update cartan_matrix() to use the base_ring
+  - Add a method _test_base_ring that checks that all edge labels are
+    indeed in this base ring
+  - Implement is_crystallographic testing if the base ring is ZZ
+  - Add an argument symmetric=False to the constructor, and make
+    add_edge and symmetrizer use it.
+  - Add a method _test_dynkin_diagram that tests that the Dynkin
+    diagram indeed defines a proper root system. See in particular
+    cartan_matrix.is_generalized_cartan_matrix.
+  - adapt column() and row() method to give the labels in the base ring
+
+  * Update CartanMatrix
+  - Add a base ring argument to the constructor
+  - Update is_crystallographic
+  - Update is_affine
+  - Update is_finite
+  - Update is_generalized_cartan_matrix
+
+* CartanType
+  - Possibly update to accept appropriate data to build a CoxeterDiagram (e.g. a matrix)
+  - Add a base_ring method?
+  - Decide on the semantic of is_crystallographic (symmetrizable or
+    not?), and if possibly add an is_... method to decide whether the
+    entries are integral or not.
+  - Provide a dynkin_diagram method that builds the Dynkin diagram
+    from the Coxeter diagram when available
+  - Test: H_3 and friends should have a working dynkin_diagram method
+
+* RootSystem
+  - Decide on the meaning of root_lattice: either disable it in the
+    non integral case, or have it be the span of the roots over the
+    smallest available ring.
+
+* RootLatticeRealizations:
+  - Feed this to RootSystem, and check that the root space and weight
+    space are built properly.
+  - Rename the weyl_group method to reflection_group, with an alias
+    from weyl_group; update the setting of the category.
+  - Define a new projection "transversal" to visualise root systems (and find a right name for it)
+  - Long run: stuff specific to the crystallographic case, starting
+    with this weyl_group method, should go in
+    RootLatticeRealizations.Crystallographic. That's for a follow up
+    ticket on using axioms for root systems; but let's not depend on
+    #10963 right now.
+
+* RootSpace (for this ticket or some follow up):
+  - Define the inner product
+  - adapt the is_positive_root to make it work for any base ring
+  - Signature of the bilinear form
+
+* CoxeterMatrixGroup and WeylGroup:
+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
+    and lift as many features as possible from WeylGroup to
+    CoxeterMatrixGroup.
+  - Check that, with a proper Dynkin diagram, the conversion to GAP
+    issue does not appear
+  - Now or later: we probably want the Weyl group elements to be
+    represented by Sage matrices, but keep a handle to the
+    corresponding Gap group. Currently one has to make a choice
+    between MatrixGroup_generic and MatrixGroup_gap.
+
+* Plotting:
+  - add a family_of_points method in the projections to be used by the "transversal projection"
+
+* Update WeylGroups:
+  - inversions: use the "root_lattice" by default?
+
+* Prerequisites:
+  - Add a __float__ method to UCF, see #16120
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```




---

archive/issue_comments_212987.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,100 @@\n+This is a follow up to #9290.\n+\n+* Experiment with the infrastructure scales and benchmark \n+\n+* CoxeterGraph, see #16126\n+  - Create a class similar to DynkinDiagram\n+    Starter: an edge-labeled graph.\n+  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+    Starter: just make this a function\n+\n+* Update DynkinDiagram to support non crystallographic case:\n+  - Add an argument base_ring to the constructor\n+  - Add a method base_ring\n+  - Make add_edge honor this method when automatically adding edges\n+  - Update cartan_matrix() to use the base_ring\n+  - Add a method _test_base_ring that checks that all edge labels are\n+    indeed in this base ring\n+  - Implement is_crystallographic testing if the base ring is ZZ\n+  - Add an argument symmetric=False to the constructor, and make\n+    add_edge and symmetrizer use it.\n+  - Add a method _test_dynkin_diagram that tests that the Dynkin\n+    diagram indeed defines a proper root system. See in particular\n+    cartan_matrix.is_generalized_cartan_matrix.\n+  - adapt column() and row() method to give the labels in the base ring\n+\n+  * Update CartanMatrix\n+  - Add a base ring argument to the constructor\n+  - Update is_crystallographic\n+  - Update is_affine\n+  - Update is_finite\n+  - Update is_generalized_cartan_matrix\n+\n+* CartanType\n+  - Possibly update to accept appropriate data to build a CoxeterGraph (e.g. a matrix)\n+  - Add a base_ring method?\n+  - Decide on the semantic of is_crystallographic (symmetrizable or\n+    not?), and if possibly add an is_... method to decide whether the\n+    entries are integral or not.\n+  - Provide a dynkin_diagram method that builds the Dynkin diagram\n+    from the Coxeter diagram when available\n+  - Test: H_3 and friends should have a working dynkin_diagram method\n+\n+* RootSystem\n+  - Decide on the meaning of root_lattice: either disable it in the\n+    non integral case, or have it be the span of the roots over the\n+    smallest available ring.\n+\n+* RootLatticeRealizations:\n+  - Feed this to RootSystem, and check that the root space and weight\n+    space are built properly.\n+  - Rename the weyl_group method to reflection_group, with an alias\n+    from weyl_group; update the setting of the category.\n+  - Define a new projection \"transversal\" to visualise root systems (and find a right name for it)\n+  - Long run: stuff specific to the crystallographic case, starting\n+    with this weyl_group method, should go in\n+    RootLatticeRealizations.Crystallographic. That's for a follow up\n+    ticket on using axioms for root systems; but let's not depend on\n+    #10963 right now.\n+\n+* RootSpace (for this ticket or some follow up):\n+  - Define the inner product\n+  - adapt the is_positive_root to make it work for any base ring\n+  - Signature of the bilinear form\n+\n+* CoxeterMatrixGroup and WeylGroup:\n+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n+    and lift as many features as possible from WeylGroup to\n+    CoxeterMatrixGroup.\n+  - Check that, with a proper Dynkin diagram, the conversion to GAP\n+    issue does not appear\n+  - Now or later: we probably want the Weyl group elements to be\n+    represented by Sage matrices, but keep a handle to the\n+    corresponding Gap group. Currently one has to make a choice\n+    between MatrixGroup_generic and MatrixGroup_gap.\n+\n+* Plotting:\n+  - add a family_of_points method in the projections to be used by the \"transversal projection\"\n+\n+* Update WeylGroups:\n+  - inversions: use the \"root_lattice\" by default?\n+\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2015-03-21T08:23:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212987",
    "user": "https://trac.sagemath.org/admin/accounts/users/vripoll"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,100 @@
+This is a follow up to #9290.
+
+* Experiment with the infrastructure scales and benchmark 
+
+* CoxeterGraph, see #16126
+  - Create a class similar to DynkinDiagram
+    Starter: an edge-labeled graph.
+  - Edge labels: m_{i,j}, possibly with number <-1 for oo
+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
+    Starter: just make this a function
+
+* Update DynkinDiagram to support non crystallographic case:
+  - Add an argument base_ring to the constructor
+  - Add a method base_ring
+  - Make add_edge honor this method when automatically adding edges
+  - Update cartan_matrix() to use the base_ring
+  - Add a method _test_base_ring that checks that all edge labels are
+    indeed in this base ring
+  - Implement is_crystallographic testing if the base ring is ZZ
+  - Add an argument symmetric=False to the constructor, and make
+    add_edge and symmetrizer use it.
+  - Add a method _test_dynkin_diagram that tests that the Dynkin
+    diagram indeed defines a proper root system. See in particular
+    cartan_matrix.is_generalized_cartan_matrix.
+  - adapt column() and row() method to give the labels in the base ring
+
+  * Update CartanMatrix
+  - Add a base ring argument to the constructor
+  - Update is_crystallographic
+  - Update is_affine
+  - Update is_finite
+  - Update is_generalized_cartan_matrix
+
+* CartanType
+  - Possibly update to accept appropriate data to build a CoxeterGraph (e.g. a matrix)
+  - Add a base_ring method?
+  - Decide on the semantic of is_crystallographic (symmetrizable or
+    not?), and if possibly add an is_... method to decide whether the
+    entries are integral or not.
+  - Provide a dynkin_diagram method that builds the Dynkin diagram
+    from the Coxeter diagram when available
+  - Test: H_3 and friends should have a working dynkin_diagram method
+
+* RootSystem
+  - Decide on the meaning of root_lattice: either disable it in the
+    non integral case, or have it be the span of the roots over the
+    smallest available ring.
+
+* RootLatticeRealizations:
+  - Feed this to RootSystem, and check that the root space and weight
+    space are built properly.
+  - Rename the weyl_group method to reflection_group, with an alias
+    from weyl_group; update the setting of the category.
+  - Define a new projection "transversal" to visualise root systems (and find a right name for it)
+  - Long run: stuff specific to the crystallographic case, starting
+    with this weyl_group method, should go in
+    RootLatticeRealizations.Crystallographic. That's for a follow up
+    ticket on using axioms for root systems; but let's not depend on
+    #10963 right now.
+
+* RootSpace (for this ticket or some follow up):
+  - Define the inner product
+  - adapt the is_positive_root to make it work for any base ring
+  - Signature of the bilinear form
+
+* CoxeterMatrixGroup and WeylGroup:
+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
+    and lift as many features as possible from WeylGroup to
+    CoxeterMatrixGroup.
+  - Check that, with a proper Dynkin diagram, the conversion to GAP
+    issue does not appear
+  - Now or later: we probably want the Weyl group elements to be
+    represented by Sage matrices, but keep a handle to the
+    corresponding Gap group. Currently one has to make a choice
+    between MatrixGroup_generic and MatrixGroup_gap.
+
+* Plotting:
+  - add a family_of_points method in the projections to be used by the "transversal projection"
+
+* Update WeylGroups:
+  - inversions: use the "root_lattice" by default?
+
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```




---

archive/issue_comments_212988.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,100 @@\n+This is a follow up to #9290.\n+\n+* Experiment with the infrastructure scales and benchmark \n+\n+* CoxeterGraph, see #16126\n+  - Create a class similar to DynkinDiagram\n+    Starter: an edge-labeled graph.\n+  - Edge labels: m_{i,j}, possibly with number <-1 for oo\n+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation\n+    Starter: just make this a function\n+\n+* Update DynkinDiagram to support non crystallographic case:\n+  - Add an argument base_ring to the constructor\n+  - Add a method base_ring\n+  - Make add_edge honor this method when automatically adding edges\n+  - Update cartan_matrix() to use the base_ring\n+  - Add a method _test_base_ring that checks that all edge labels are\n+    indeed in this base ring\n+  - Implement is_crystallographic testing if the base ring is ZZ\n+  - Add an argument symmetric=False to the constructor, and make\n+    add_edge and symmetrizer use it.\n+  - Add a method _test_dynkin_diagram that tests that the Dynkin\n+    diagram indeed defines a proper root system. See in particular\n+    cartan_matrix.is_generalized_cartan_matrix.\n+  - adapt column() and row() method to give the labels in the base ring\n+\n+  * Update CartanMatrix, see #17798\n+  - Add a base ring argument to the constructor\n+  - Update is_crystallographic\n+  - Update is_affine\n+  - Update is_finite\n+  - Update is_generalized_cartan_matrix\n+\n+* CartanType\n+  - Possibly update to accept appropriate data to build a CoxeterGraph (e.g. a matrix)\n+  - Add a base_ring method?\n+  - Decide on the semantic of is_crystallographic (symmetrizable or\n+    not?), and if possibly add an is_... method to decide whether the\n+    entries are integral or not.\n+  - Provide a dynkin_diagram method that builds the Dynkin diagram\n+    from the Coxeter diagram when available\n+  - Test: H_3 and friends should have a working dynkin_diagram method\n+\n+* RootSystem\n+  - Decide on the meaning of root_lattice: either disable it in the\n+    non integral case, or have it be the span of the roots over the\n+    smallest available ring.\n+\n+* RootLatticeRealizations:\n+  - Feed this to RootSystem, and check that the root space and weight\n+    space are built properly.\n+  - Rename the weyl_group method to reflection_group, with an alias\n+    from weyl_group; update the setting of the category.\n+  - Define a new projection \"transversal\" to visualise root systems (and find a right name for it)\n+  - Long run: stuff specific to the crystallographic case, starting\n+    with this weyl_group method, should go in\n+    RootLatticeRealizations.Crystallographic. That's for a follow up\n+    ticket on using axioms for root systems; but let's not depend on\n+    #10963 right now.\n+\n+* RootSpace (for this ticket or some follow up):\n+  - Define the inner product\n+  - adapt the is_positive_root to make it work for any base ring\n+  - Signature of the bilinear form\n+\n+* CoxeterMatrixGroup and WeylGroup:\n+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,\n+    and lift as many features as possible from WeylGroup to\n+    CoxeterMatrixGroup.\n+  - Check that, with a proper Dynkin diagram, the conversion to GAP\n+    issue does not appear\n+  - Now or later: we probably want the Weyl group elements to be\n+    represented by Sage matrices, but keep a handle to the\n+    corresponding Gap group. Currently one has to make a choice\n+    between MatrixGroup_generic and MatrixGroup_gap.\n+\n+* Plotting:\n+  - add a family_of_points method in the projections to be used by the \"transversal projection\"\n+\n+* Update WeylGroups:\n+  - inversions: use the \"root_lattice\" by default?\n+\n+\n+Tests:\n+\n+```\n+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?\n+  sage: L = RootSystem(C).root_space()\n+  sage: W = L.reflection_group()\n+  sage: W = CoxeterGroup(['H',3])\n+  sage: W.domain()\n+```\n+Sage Days 57 in Cernay will be a good occasion to work on this.\n+\n+Follow ups: #16087\n+\n+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.\n \n \n Comment: 1\n```\n",
    "created_at": "2015-04-29T09:44:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15703",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15703#issuecomment-212988",
    "user": "https://github.com/jplab"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,100 @@
+This is a follow up to #9290.
+
+* Experiment with the infrastructure scales and benchmark 
+
+* CoxeterGraph, see #16126
+  - Create a class similar to DynkinDiagram
+    Starter: an edge-labeled graph.
+  - Edge labels: m_{i,j}, possibly with number <-1 for oo
+  - method dynkin_diagram() which builds the cartan matrix for the geometric representation
+    Starter: just make this a function
+
+* Update DynkinDiagram to support non crystallographic case:
+  - Add an argument base_ring to the constructor
+  - Add a method base_ring
+  - Make add_edge honor this method when automatically adding edges
+  - Update cartan_matrix() to use the base_ring
+  - Add a method _test_base_ring that checks that all edge labels are
+    indeed in this base ring
+  - Implement is_crystallographic testing if the base ring is ZZ
+  - Add an argument symmetric=False to the constructor, and make
+    add_edge and symmetrizer use it.
+  - Add a method _test_dynkin_diagram that tests that the Dynkin
+    diagram indeed defines a proper root system. See in particular
+    cartan_matrix.is_generalized_cartan_matrix.
+  - adapt column() and row() method to give the labels in the base ring
+
+  * Update CartanMatrix, see #17798
+  - Add a base ring argument to the constructor
+  - Update is_crystallographic
+  - Update is_affine
+  - Update is_finite
+  - Update is_generalized_cartan_matrix
+
+* CartanType
+  - Possibly update to accept appropriate data to build a CoxeterGraph (e.g. a matrix)
+  - Add a base_ring method?
+  - Decide on the semantic of is_crystallographic (symmetrizable or
+    not?), and if possibly add an is_... method to decide whether the
+    entries are integral or not.
+  - Provide a dynkin_diagram method that builds the Dynkin diagram
+    from the Coxeter diagram when available
+  - Test: H_3 and friends should have a working dynkin_diagram method
+
+* RootSystem
+  - Decide on the meaning of root_lattice: either disable it in the
+    non integral case, or have it be the span of the roots over the
+    smallest available ring.
+
+* RootLatticeRealizations:
+  - Feed this to RootSystem, and check that the root space and weight
+    space are built properly.
+  - Rename the weyl_group method to reflection_group, with an alias
+    from weyl_group; update the setting of the category.
+  - Define a new projection "transversal" to visualise root systems (and find a right name for it)
+  - Long run: stuff specific to the crystallographic case, starting
+    with this weyl_group method, should go in
+    RootLatticeRealizations.Crystallographic. That's for a follow up
+    ticket on using axioms for root systems; but let's not depend on
+    #10963 right now.
+
+* RootSpace (for this ticket or some follow up):
+  - Define the inner product
+  - adapt the is_positive_root to make it work for any base ring
+  - Signature of the bilinear form
+
+* CoxeterMatrixGroup and WeylGroup:
+  - Refactor WeylGroup to make it a subclass of CoxeterMatrixGroup,
+    and lift as many features as possible from WeylGroup to
+    CoxeterMatrixGroup.
+  - Check that, with a proper Dynkin diagram, the conversion to GAP
+    issue does not appear
+  - Now or later: we probably want the Weyl group elements to be
+    represented by Sage matrices, but keep a handle to the
+    corresponding Gap group. Currently one has to make a choice
+    between MatrixGroup_generic and MatrixGroup_gap.
+
+* Plotting:
+  - add a family_of_points method in the projections to be used by the "transversal projection"
+
+* Update WeylGroups:
+  - inversions: use the "root_lattice" by default?
+
+
+Tests:
+
+```
+  sage: C = CoxeterDiagram(...)           # good name? or CartanDatum(coxeter_matrix=...) [1] ? or?
+  sage: L = RootSystem(C).root_space()
+  sage: W = L.reflection_group()
+  sage: W = CoxeterGroup(['H',3])
+  sage: W.domain()
+```
+Sage Days 57 in Cernay will be a good occasion to work on this.
+
+Follow ups: #16087
+
+[1]: Generally speaking, it's planned to rename CartanType to CartanDatum.
 
 
 Comment: 1
```

