# Issue 15425: Meta-ticket: Cleanup cartesian products

archive/issues_015188.json:
```json
{
    "body": "Currently we have: `cartesian_product`, `CartesianProduct` and\n`cartesian_product_iterator` for constructing cartesian products.\n\n- `CartesianProduct` is an old simple parent that focuses on the\n  \"enumerated sets\" aspect: providing counting and enumeration over\n  cartesian products of enumerated sets. It accepts any iterables as\n  input.\n\n- `cartesian_product` is a \"functorial construction\". This means\n  that it uses the categories to endow the resulting parent with as\n  much structure as it can lift from the input. E.g. the cartesian\n  product of two monoids is a monoid.\n\n- `cartesian_product_iterator` is just a function that provides an\n  iterator\n\nTo be done:\n\n1. #18411: Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n    - Accepting any iterable as input. This probably requires turning\n      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n      is probably negligible in most cases, but one would need to double\n      check that we don't have spots where `CartesianProduct` is used\n      intensively for very small calculations. #14224 can be closed once this is fixed.\n    - Some features of `CartesianProduct` still need to be lifted to\n      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The\n      `cardinality` and `is_finite` methods are taken care in #18290. Some other\n      are in #18411.\n    - #19195: Fix the use of `CartesianProduct` in `CombinatorialFreeModule`\n\n2.  #34337: Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n\n3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n    {{{\n    sage: C = cartesian_product([ZZ,ZZ])\n    ...\n    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n    }}}\n\n    This is a regression that is caused by a small change introduced by\n    #12959 in `Sets.ParentMethods.CartesianProduct`:\n    {{{\n        return parents[0].__class__ -> return parents[0].__class__\n    }}}\n\n    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n    and did not notice this chunk (or don't remember why it was\n    introduced), and I had not written an appropriate test in the first\n    place. So this needs to be fixed too.\n\n4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n    list to an element of a cartesian product:\n    {{{\n    sage: Z3 = IntegerModRing(3)\n    sage: C = cartesian_product([Z3,Z3])\n    sage: C([Z3(2),Z3(2)])^2\n    (1, 1)\n    sage: C([2,2])^2   # Ooops\n    (4, 4)\n    }}}\n\n    The fix would be convert the operands of the list into the respective\n    parents in\n    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n\n5.  Fix mixed cartesian products with modules and non modules:\n    {{{\n    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n    sage: cartesian_product([A, ZZ])\n    ...\n    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n    }}}\n    This should instead detect that not all factors are modules, and\n    just use a plain cartesian product.\n\n    Also between modules on different ring, in particular #18309.\n\n6.  Fix cartesian products involving `NN`:\n    {{{\n    sage: cartesian_product([NN,NN])\n    170         from sage.structure.parent import Parent\n    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n    172         # Should we pass a set of categories to reduce the cache size?\n    173         # But then this would impose that, for any constructor, the\n    AssertionError: \n    }}}\n    This is in fact a bug in the way `NN` is lazy imported in the global\n    name space:\n    {{{\n        sage: type(NN)\n    <type 'sage.misc.lazy_import.LazyImport'>\n    sage: isinstance(NN, Parent)\n        False\n    }}}\n    Things works if one forces the import of `NN`:\n    {{{\n    sage: NN = NonNegativeIntegers()\n    sage: cartesian_product([NN,NN])\n    The cartesian product of (Non negative integers, Non negative integers)\n    }}}\n\n7.  Make `_cartesian_product_of_elements` a public method?\n\n8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`\n    describing the general scheme, possibly starting from the blurb there:\n    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ\n\n9.  Tidy up the documentation of sage.sets.cartesian_products:\n    Return(s), the links to `Sets....` don't need to be prefixed with\n    the python module (Sets is found from the global name space), ...\n\n10. #16269 and follow up #16405 (depended on #10963): make the\n    cartesian product of an additive magma into an additive magma, and\n    so on; implement `Distributive.CartesianProducts` so that a\n    cartesian product of rings is a ring.\n\n\nCC:  sage-combinat @nathanncohen @videlec @tscrim\n\nStatus: new\n\nIssue created by migration from https://trac.sagemath.org/ticket/15425\n\n",
    "created_at": "2013-11-15T17:58:36Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Meta-ticket: Cleanup cartesian products",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15425",
    "user": "https://github.com/nthiery"
}
```
Currently we have: `cartesian_product`, `CartesianProduct` and
`cartesian_product_iterator` for constructing cartesian products.

- `CartesianProduct` is an old simple parent that focuses on the
  "enumerated sets" aspect: providing counting and enumeration over
  cartesian products of enumerated sets. It accepts any iterables as
  input.

- `cartesian_product` is a "functorial construction". This means
  that it uses the categories to endow the resulting parent with as
  much structure as it can lift from the input. E.g. the cartesian
  product of two monoids is a monoid.

- `cartesian_product_iterator` is just a function that provides an
  iterator

To be done:

1. #18411: Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
    - Accepting any iterable as input. This probably requires turning
      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
      is probably negligible in most cases, but one would need to double
      check that we don't have spots where `CartesianProduct` is used
      intensively for very small calculations. #14224 can be closed once this is fixed.
    - Some features of `CartesianProduct` still need to be lifted to
      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The
      `cardinality` and `is_finite` methods are taken care in #18290. Some other
      are in #18411.
    - #19195: Fix the use of `CartesianProduct` in `CombinatorialFreeModule`

2.  #34337: Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.

3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
    {{{
    sage: C = cartesian_product([ZZ,ZZ])
    ...
    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
    }}}

    This is a regression that is caused by a small change introduced by
    #12959 in `Sets.ParentMethods.CartesianProduct`:
    {{{
        return parents[0].__class__ -> return parents[0].__class__
    }}}

    I (Nicolas) take a double blame for it: I was reviewer of this ticket
    and did not notice this chunk (or don't remember why it was
    introduced), and I had not written an appropriate test in the first
    place. So this needs to be fixed too.

4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
    list to an element of a cartesian product:
    {{{
    sage: Z3 = IntegerModRing(3)
    sage: C = cartesian_product([Z3,Z3])
    sage: C([Z3(2),Z3(2)])^2
    (1, 1)
    sage: C([2,2])^2   # Ooops
    (4, 4)
    }}}

    The fix would be convert the operands of the list into the respective
    parents in
    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.

5.  Fix mixed cartesian products with modules and non modules:
    {{{
    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
    sage: cartesian_product([A, ZZ])
    ...
    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
    }}}
    This should instead detect that not all factors are modules, and
    just use a plain cartesian product.

    Also between modules on different ring, in particular #18309.

6.  Fix cartesian products involving `NN`:
    {{{
    sage: cartesian_product([NN,NN])
    170         from sage.structure.parent import Parent
    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
    172         # Should we pass a set of categories to reduce the cache size?
    173         # But then this would impose that, for any constructor, the
    AssertionError: 
    }}}
    This is in fact a bug in the way `NN` is lazy imported in the global
    name space:
    {{{
        sage: type(NN)
    <type 'sage.misc.lazy_import.LazyImport'>
    sage: isinstance(NN, Parent)
        False
    }}}
    Things works if one forces the import of `NN`:
    {{{
    sage: NN = NonNegativeIntegers()
    sage: cartesian_product([NN,NN])
    The cartesian product of (Non negative integers, Non negative integers)
    }}}

7.  Make `_cartesian_product_of_elements` a public method?

8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`
    describing the general scheme, possibly starting from the blurb there:
    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ

9.  Tidy up the documentation of sage.sets.cartesian_products:
    Return(s), the links to `Sets....` don't need to be prefixed with
    the python module (Sets is found from the global name space), ...

10. #16269 and follow up #16405 (depended on #10963): make the
    cartesian product of an additive magma into an additive magma, and
    so on; implement `Distributive.CartesianProducts` so that a
    cartesian product of rings is a ring.


CC:  sage-combinat @nathanncohen @videlec @tscrim

Status: new

Issue created by migration from https://trac.sagemath.org/ticket/15425





---

archive/issue_events_044913.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44913"
}
```



---

archive/issue_comments_207945.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -14,76 +14,80 @@\n - `cartesian_product_iterator` is just a function that provides an\n   iterator\n \n-`cartesian_product` is meant to subdue `CartesianProduct`. The\n-missing features at this point are:\n+To be done:\n \n-- Accepting any iterable as input. This probably requires turning them\n-  into parents (e.g. with FiniteEnumeratedSet). The overhead is\n-  probably negligible in most cases, but one would need to double\n-  check that we don't have spots where CartesianProduct is used\n-  intensively for very small calculations.\n+#.  Make `CartesianProduct` an alias for `cartesian_product`,\n+    and possibly deprecated it.\n \n-  #14224 which can be closed once this is fixed.\n+    The missing features at this point are:\n \n-- Some features of CartesianProduct still need to be lifted to\n-  Sets.Finite.CartesianProducts or EnumeratedSets.CartesianProducts.\n-  For example, cardinality is currently calculated from the iterator (gasp):\n-  {{{\n-      sage: F = Permutations(10)\n-      sage: C = cartesian_product([F,F])\n-      sage: C.cardinality()\n-      *hangs forever*\n-  }}}\n+    - Accepting any iterable as input. This probably requires turning them\n+      into parents (e.g. with FiniteEnumeratedSet). The overhead is\n+      probably negligible in most cases, but one would need to double\n+      check that we don't have spots where CartesianProduct is used\n+      intensively for very small calculations.\n \n-Once this is done, we can make CartesianProduct an alias for\n-cartesian_product, and maybe deprecate it in the long run.\n+      #14224 can be closed once this is fixed.\n \n-My 2 cents for cartesian_product_iterator: it should be removed from\n-the global name space, and deprecated altogether if after checking it\n-turns out to be really just a duplicated of itertools.product.\n+    - Some features of CartesianProduct still need to be lifted to\n+      Sets.Finite.CartesianProducts or EnumeratedSets.CartesianProducts.\n+      For example, cardinality is currently calculated from the iterator (gasp):\n+      {{{\n+\t  sage: F = Permutations(10)\n+\t  sage: C = cartesian_product([F,F])\n+\t  sage: C.cardinality()\n+\t  *hangs forever*\n+      }}}\n \n-Another bug in cartesian_product (reported by Vincent Delecroix [1]):\n+      Done by #16269/#10963 for cardinality and `__iter__`. Needs\n+      double checking for the infinite cases.\n \n-```\n-sage: C = cartesian_product([ZZ,ZZ])\n-...\n-AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n-```\n+#.  Remove cartesian_product_iterator from the global name space, and\n+    deprecate it altogether if, after checking, it turns out to be\n+    really just a duplicated of itertools.product.\n \n-This is a regression that is caused by a small change introduced by\n-#12959 in Sets.ParentMethods.CartesianProduct:\n+#.  Fix bug in cartesian_product (reported by Vincent Delecroix [1]):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n \n-```\n-            return parents[0].__class__ -> return parents[0].__class__\n-```\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in Sets.ParentMethods.CartesianProduct:\n+    {{{\n+ \t\treturn parents[0].__class__ -> return parents[0].__class__\n+    }}}\n \n-I (Nicolas) take a double blame for it: I was reviewer of this ticket\n-and did not notice this chunk (or don't remember why it was\n-introduced), and I had not written an appropriate test in the first\n-place. So this needs to be fixed too.\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n \n-Yet another bug reported by Nathann Cohen [2]: when converting a list\n-to an element of a cartesian product:\n+#.  #16269: Fix bug reported by Nathann Cohen [2]: when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n \n-```\n-sage: Z3 = IntegerModRing(3)\n-sage: C = cartesian_product([Z3,Z3])\n-sage: C([Z3(2),Z3(2)])^2\n-(1, 1)\n-sage: C([2,2])^2   # Ooops\n-(4, 4)\n-```\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n \n-The fix would be convert the operands of the list into the respective\n-parents in\n-`sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n-\n-Many features could be further added, like for example making the\n-cartesian product of an additive magma into an additive magma and so\n-on. This can go in this ticket or in later tickets.\n+#.  Many features could be further added, like for example making the\n+    cartesian product of an additive magma into an additive magma and\n+    so on. A good step was done with #16269. Another step needs to be\n+    done after #10963 to ventilate the features in the appropriate\n+    axiom categories.\n \n [1] https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M\n [2] https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J\n+\n \n Comment: 1\n \n``````\n",
    "created_at": "2014-05-04T23:15:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207945",
    "user": "https://github.com/nthiery"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -14,76 +14,80 @@
 - `cartesian_product_iterator` is just a function that provides an
   iterator
 
-`cartesian_product` is meant to subdue `CartesianProduct`. The
-missing features at this point are:
+To be done:
 
-- Accepting any iterable as input. This probably requires turning them
-  into parents (e.g. with FiniteEnumeratedSet). The overhead is
-  probably negligible in most cases, but one would need to double
-  check that we don't have spots where CartesianProduct is used
-  intensively for very small calculations.
+#.  Make `CartesianProduct` an alias for `cartesian_product`,
+    and possibly deprecated it.
 
-  #14224 which can be closed once this is fixed.
+    The missing features at this point are:
 
-- Some features of CartesianProduct still need to be lifted to
-  Sets.Finite.CartesianProducts or EnumeratedSets.CartesianProducts.
-  For example, cardinality is currently calculated from the iterator (gasp):
-  {{{
-      sage: F = Permutations(10)
-      sage: C = cartesian_product([F,F])
-      sage: C.cardinality()
-      *hangs forever*
-  }}}
+    - Accepting any iterable as input. This probably requires turning them
+      into parents (e.g. with FiniteEnumeratedSet). The overhead is
+      probably negligible in most cases, but one would need to double
+      check that we don't have spots where CartesianProduct is used
+      intensively for very small calculations.
 
-Once this is done, we can make CartesianProduct an alias for
-cartesian_product, and maybe deprecate it in the long run.
+      #14224 can be closed once this is fixed.
 
-My 2 cents for cartesian_product_iterator: it should be removed from
-the global name space, and deprecated altogether if after checking it
-turns out to be really just a duplicated of itertools.product.
+    - Some features of CartesianProduct still need to be lifted to
+      Sets.Finite.CartesianProducts or EnumeratedSets.CartesianProducts.
+      For example, cardinality is currently calculated from the iterator (gasp):
+      {{{
+	  sage: F = Permutations(10)
+	  sage: C = cartesian_product([F,F])
+	  sage: C.cardinality()
+	  *hangs forever*
+      }}}
 
-Another bug in cartesian_product (reported by Vincent Delecroix [1]):
+      Done by #16269/#10963 for cardinality and `__iter__`. Needs
+      double checking for the infinite cases.
 
-```
-sage: C = cartesian_product([ZZ,ZZ])
-...
-AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
-```
+#.  Remove cartesian_product_iterator from the global name space, and
+    deprecate it altogether if, after checking, it turns out to be
+    really just a duplicated of itertools.product.
 
-This is a regression that is caused by a small change introduced by
-#12959 in Sets.ParentMethods.CartesianProduct:
+#.  Fix bug in cartesian_product (reported by Vincent Delecroix [1]):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
 
-```
-            return parents[0].__class__ -> return parents[0].__class__
-```
+    This is a regression that is caused by a small change introduced by
+    #12959 in Sets.ParentMethods.CartesianProduct:
+    {{{
+ 		return parents[0].__class__ -> return parents[0].__class__
+    }}}
 
-I (Nicolas) take a double blame for it: I was reviewer of this ticket
-and did not notice this chunk (or don't remember why it was
-introduced), and I had not written an appropriate test in the first
-place. So this needs to be fixed too.
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
 
-Yet another bug reported by Nathann Cohen [2]: when converting a list
-to an element of a cartesian product:
+#.  #16269: Fix bug reported by Nathann Cohen [2]: when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
 
-```
-sage: Z3 = IntegerModRing(3)
-sage: C = cartesian_product([Z3,Z3])
-sage: C([Z3(2),Z3(2)])^2
-(1, 1)
-sage: C([2,2])^2   # Ooops
-(4, 4)
-```
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
 
-The fix would be convert the operands of the list into the respective
-parents in
-`sage.sets.cartesian_product.CartesianProduct._element_constructor`.
-
-Many features could be further added, like for example making the
-cartesian product of an additive magma into an additive magma and so
-on. This can go in this ticket or in later tickets.
+#.  Many features could be further added, like for example making the
+    cartesian product of an additive magma into an additive magma and
+    so on. A good step was done with #16269. Another step needs to be
+    done after #10963 to ventilate the features in the appropriate
+    axiom categories.
 
 [1] https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M
 [2] https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J
+
 
 Comment: 1
 
``````




---

archive/issue_comments_207946.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,127 @@\n+Currently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n+\n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+#.  Make `CartesianProduct` an alias for `cartesian_product`,\n+    and possibly deprecated it.\n+\n+    The missing features at this point are:\n+\n+    - Accepting any iterable as input. This probably requires turning them\n+      into parents (e.g. with FiniteEnumeratedSet). The overhead is\n+      probably negligible in most cases, but one would need to double\n+      check that we don't have spots where CartesianProduct is used\n+      intensively for very small calculations.\n+\n+      #14224 can be closed once this is fixed.\n+\n+    - Some features of CartesianProduct still need to be lifted to\n+      Sets.Finite.CartesianProducts or EnumeratedSets.CartesianProducts.\n+      For example, cardinality is currently calculated from the iterator (gasp):\n+      {{{\n+\t  sage: F = Permutations(10)\n+\t  sage: C = cartesian_product([F,F])\n+\t  sage: C.cardinality()\n+\t  *hangs forever*\n+      }}}\n+\n+      Done by #16269/#10963 for cardinality and `__iter__`. Needs\n+      double checking for the infinite cases.\n+\n+#.  Remove cartesian_product_iterator from the global name space, and\n+    deprecate it altogether if, after checking, it turns out to be\n+    really just a duplicated of itertools.product.\n+\n+#.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix [1]):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in Sets.ParentMethods.CartesianProduct:\n+    {{{\n+ \t\treturn parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+#.  #16269: Fix bug reported by Nathann Cohen [2]: when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+#.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+#.  Fix cartesian products involving NN:\n+    {{{\n+  \tsage: cartesian_product([NN,NN])\n+  \t170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+  \t172         # Should we pass a set of categories to reduce the cache size?\n+  \t173         # But then this would impose that, for any constructor, the\n+  \tAssertionError: \n+    }}}\n+    This is in fact a bug in the way NN is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+  \t<type 'sage.misc.lazy_import.LazyImport'>\n+  \tsage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of NN:\n+    {{{\n+  \tsage: NN = NonNegativeIntegers()\n+  \tsage: cartesian_product([NN,NN])\n+  \tThe cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+\n+#.  Many features could be further added, like for example making the\n+    cartesian product of an additive magma into an additive magma, and\n+    so on. A good step was done with #16269. Another step needs to be\n+    done after #10963 to ventilate the features in the appropriate\n+    axiom categories, and add Distributive.CartesianProducts.\n+\n+[1] https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M\n+[2] https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J\n \n \n Comment: 1\n``````\n",
    "created_at": "2014-05-05T00:04:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207946",
    "user": "https://github.com/nthiery"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,127 @@
+Currently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
+
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+#.  Make `CartesianProduct` an alias for `cartesian_product`,
+    and possibly deprecated it.
+
+    The missing features at this point are:
+
+    - Accepting any iterable as input. This probably requires turning them
+      into parents (e.g. with FiniteEnumeratedSet). The overhead is
+      probably negligible in most cases, but one would need to double
+      check that we don't have spots where CartesianProduct is used
+      intensively for very small calculations.
+
+      #14224 can be closed once this is fixed.
+
+    - Some features of CartesianProduct still need to be lifted to
+      Sets.Finite.CartesianProducts or EnumeratedSets.CartesianProducts.
+      For example, cardinality is currently calculated from the iterator (gasp):
+      {{{
+	  sage: F = Permutations(10)
+	  sage: C = cartesian_product([F,F])
+	  sage: C.cardinality()
+	  *hangs forever*
+      }}}
+
+      Done by #16269/#10963 for cardinality and `__iter__`. Needs
+      double checking for the infinite cases.
+
+#.  Remove cartesian_product_iterator from the global name space, and
+    deprecate it altogether if, after checking, it turns out to be
+    really just a duplicated of itertools.product.
+
+#.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix [1]):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in Sets.ParentMethods.CartesianProduct:
+    {{{
+ 		return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+#.  #16269: Fix bug reported by Nathann Cohen [2]: when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+#.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+#.  Fix cartesian products involving NN:
+    {{{
+  	sage: cartesian_product([NN,NN])
+  	170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+  	172         # Should we pass a set of categories to reduce the cache size?
+  	173         # But then this would impose that, for any constructor, the
+  	AssertionError: 
+    }}}
+    This is in fact a bug in the way NN is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+  	<type 'sage.misc.lazy_import.LazyImport'>
+  	sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of NN:
+    {{{
+  	sage: NN = NonNegativeIntegers()
+  	sage: cartesian_product([NN,NN])
+  	The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+
+#.  Many features could be further added, like for example making the
+    cartesian product of an additive magma into an additive magma, and
+    so on. A good step was done with #16269. Another step needs to be
+    done after #10963 to ventilate the features in the appropriate
+    axiom categories, and add Distributive.CartesianProducts.
+
+[1] https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M
+[2] https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J
 
 
 Comment: 1
``````




---

archive/issue_comments_207947.json:
```json
{
    "body": "Changing type from defect to task.",
    "created_at": "2014-05-05T00:04:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207947",
    "user": "https://github.com/nthiery"
}
```

Changing type from defect to task.



---

archive/issue_comments_207948.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,107 @@\n+Currently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n \n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n+    - Accepting any iterable as input. This probably requires turning\n+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n+      is probably negligible in most cases, but one would need to double\n+      check that we don't have spots where `CartesianProduct` is used\n+      intensively for very small calculations. #14224 can be closed once this is fixed.\n+    - Some features of `CartesianProduct` still need to be lifted to `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. For example, cardinality is currently calculated from the iterator (gasp):\n+      {{{\n+          sage: F = Permutations(10)\n+          sage: C = cartesian_product([F,F])\n+          sage: C.cardinality()\n+          *hangs forever*\n+      }}}\n+      Done by #16269/#10963 for cardinality and `__iter__`. Needs double checking for the infinite and zero cases.\n+\n+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n+\n+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in `Sets.ParentMethods.CartesianProduct`:\n+    {{{\n+ \t\treturn parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+5.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+6.  Fix cartesian products involving `NN`:\n+    {{{\n+  \tsage: cartesian_product([NN,NN])\n+  \t170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+  \t172         # Should we pass a set of categories to reduce the cache size?\n+  \t173         # But then this would impose that, for any constructor, the\n+  \tAssertionError: \n+    }}}\n+    This is in fact a bug in the way `NN` is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+  \t<type 'sage.misc.lazy_import.LazyImport'>\n+  \tsage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of `NN`:\n+    {{{\n+  \tsage: NN = NonNegativeIntegers()\n+  \tsage: cartesian_product([NN,NN])\n+  \tThe cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+\n+7.  Many features could be further added, like for example making the cartesian product of an additive magma into an additive magma, and so on. A good step was done with #16269. Another step needs to be done after #10963 to ventilate the features in the appropriate axiom categories, and add `Distributive.CartesianProducts`.\n \n Comment: 1\n \n``````\n",
    "created_at": "2014-05-05T06:08:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207948",
    "user": "https://github.com/videlec"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,107 @@
+Currently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
 
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
+    - Accepting any iterable as input. This probably requires turning
+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
+      is probably negligible in most cases, but one would need to double
+      check that we don't have spots where `CartesianProduct` is used
+      intensively for very small calculations. #14224 can be closed once this is fixed.
+    - Some features of `CartesianProduct` still need to be lifted to `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. For example, cardinality is currently calculated from the iterator (gasp):
+      {{{
+          sage: F = Permutations(10)
+          sage: C = cartesian_product([F,F])
+          sage: C.cardinality()
+          *hangs forever*
+      }}}
+      Done by #16269/#10963 for cardinality and `__iter__`. Needs double checking for the infinite and zero cases.
+
+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.
+
+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in `Sets.ParentMethods.CartesianProduct`:
+    {{{
+ 		return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+5.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+6.  Fix cartesian products involving `NN`:
+    {{{
+  	sage: cartesian_product([NN,NN])
+  	170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+  	172         # Should we pass a set of categories to reduce the cache size?
+  	173         # But then this would impose that, for any constructor, the
+  	AssertionError: 
+    }}}
+    This is in fact a bug in the way `NN` is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+  	<type 'sage.misc.lazy_import.LazyImport'>
+  	sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of `NN`:
+    {{{
+  	sage: NN = NonNegativeIntegers()
+  	sage: cartesian_product([NN,NN])
+  	The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+
+7.  Many features could be further added, like for example making the cartesian product of an additive magma into an additive magma, and so on. A good step was done with #16269. Another step needs to be done after #10963 to ventilate the features in the appropriate axiom categories, and add `Distributive.CartesianProducts`.
 
 Comment: 1
 
``````




---

archive/issue_comments_207949.json:
```json
{
    "body": "<a id='comment:4'></a>Hello,\n\n+1 on that ticket!\n\nI cleaned a bit the description.\n\nI think it is bad to hide `cartesian_product_iterator` as the object is very nice. We should advertise the `product` from `itertools` somewhere.\n\nVincent",
    "created_at": "2014-05-05T06:08:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207949",
    "user": "https://github.com/videlec"
}
```

<a id='comment:4'></a>Hello,

+1 on that ticket!

I cleaned a bit the description.

I think it is bad to hide `cartesian_product_iterator` as the object is very nice. We should advertise the `product` from `itertools` somewhere.

Vincent



---

archive/issue_comments_207950.json:
```json
{
    "body": "<a id='comment:5'></a>> I think it is bad to hide `cartesian_product_iterator` as the object is very nice. We should advertise the `product` from `itertools` somewhere.\n\n\nWe could mention it in the docstring of `cartesian_product`. \"If you just want to list the elements, use itertools.product as it is much faster\" ?",
    "created_at": "2014-05-05T07:53:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207950",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:5'></a>> I think it is bad to hide `cartesian_product_iterator` as the object is very nice. We should advertise the `product` from `itertools` somewhere.


We could mention it in the docstring of `cartesian_product`. "If you just want to list the elements, use itertools.product as it is much faster" ?



---

archive/issue_comments_207951.json:
```json
{
    "body": "<a id='comment:6'></a>Replying to [comment:5 ncohen]:\n> > I think it is bad to hide `cartesian_product_iterator` as the object is very nice. We should advertise the `product` from `itertools` somewhere.\n\n> \n> We could mention it in the docstring of `cartesian_product`. \"If you just want to list the elements, use itertools.product as it is much faster\" ?\n\n\nSounds good to me, with 'list -> iterate through'",
    "created_at": "2014-05-05T09:57:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207951",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>Replying to [comment:5 ncohen]:
> > I think it is bad to hide `cartesian_product_iterator` as the object is very nice. We should advertise the `product` from `itertools` somewhere.

> 
> We could mention it in the docstring of `cartesian_product`. "If you just want to list the elements, use itertools.product as it is much faster" ?


Sounds good to me, with 'list -> iterate through'



---

archive/issue_comments_207952.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,118 @@\n+eCurrently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n+\n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n+    - Accepting any iterable as input. This probably requires turning\n+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n+      is probably negligible in most cases, but one would need to double\n+      check that we don't have spots where `CartesianProduct` is used\n+      intensively for very small calculations. #14224 can be closed once this is fixed.\n+    - Some features of `CartesianProduct` still need to be lifted to `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. For example, cardinality is currently calculated from the iterator (gasp):\n+      {{{\n+          sage: F = Permutations(10)\n+          sage: C = cartesian_product([F,F])\n+          sage: C.cardinality()\n+          *hangs forever*\n+      }}}\n+      Done by #16269/#10963 for cardinality and `__iter__`. Needs double checking for the infinite and zero cases.\n+\n+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n+\n+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in `Sets.ParentMethods.CartesianProduct`:\n+    {{{\n+ \t\treturn parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+5.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+6.  Fix cartesian products involving `NN`:\n+    {{{\n+  \tsage: cartesian_product([NN,NN])\n+  \t170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+  \t172         # Should we pass a set of categories to reduce the cache size?\n+  \t173         # But then this would impose that, for any constructor, the\n+  \tAssertionError: \n+    }}}\n+    This is in fact a bug in the way `NN` is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+  \t<type 'sage.misc.lazy_import.LazyImport'>\n+  \tsage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of `NN`:\n+    {{{\n+  \tsage: NN = NonNegativeIntegers()\n+  \tsage: cartesian_product([NN,NN])\n+  \tThe cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+8.  Make `_cartesian_product_of_elements` a public method?\n+\n+9.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`\n+    describing the general scheme, possibly starting from the blurb there:\n+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ\n+\n+7.  Many features could be further added, like for example making the\n+    cartesian product of an additive magma into an additive magma, and\n+    so on. A good step was done with #16269. Another step needs to be\n+    done after #10963 to ventilate the features in the appropriate\n+    axiom categories, and implement\n+    `Distributive.CartesianProducts` so that a cartesian product\n+    of rings would be a ring.\n \n \n Comment: 1\n``````\n",
    "created_at": "2014-05-05T10:02:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207952",
    "user": "https://github.com/nthiery"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,118 @@
+eCurrently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
+
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
+    - Accepting any iterable as input. This probably requires turning
+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
+      is probably negligible in most cases, but one would need to double
+      check that we don't have spots where `CartesianProduct` is used
+      intensively for very small calculations. #14224 can be closed once this is fixed.
+    - Some features of `CartesianProduct` still need to be lifted to `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. For example, cardinality is currently calculated from the iterator (gasp):
+      {{{
+          sage: F = Permutations(10)
+          sage: C = cartesian_product([F,F])
+          sage: C.cardinality()
+          *hangs forever*
+      }}}
+      Done by #16269/#10963 for cardinality and `__iter__`. Needs double checking for the infinite and zero cases.
+
+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.
+
+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in `Sets.ParentMethods.CartesianProduct`:
+    {{{
+ 		return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+5.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+6.  Fix cartesian products involving `NN`:
+    {{{
+  	sage: cartesian_product([NN,NN])
+  	170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+  	172         # Should we pass a set of categories to reduce the cache size?
+  	173         # But then this would impose that, for any constructor, the
+  	AssertionError: 
+    }}}
+    This is in fact a bug in the way `NN` is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+  	<type 'sage.misc.lazy_import.LazyImport'>
+  	sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of `NN`:
+    {{{
+  	sage: NN = NonNegativeIntegers()
+  	sage: cartesian_product([NN,NN])
+  	The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+8.  Make `_cartesian_product_of_elements` a public method?
+
+9.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`
+    describing the general scheme, possibly starting from the blurb there:
+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ
+
+7.  Many features could be further added, like for example making the
+    cartesian product of an additive magma into an additive magma, and
+    so on. A good step was done with #16269. Another step needs to be
+    done after #10963 to ventilate the features in the appropriate
+    axiom categories, and implement
+    `Distributive.CartesianProducts` so that a cartesian product
+    of rings would be a ring.
 
 
 Comment: 1
``````




---

archive/issue_comments_207953.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,122 @@\n+Currently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n+\n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n+    - Accepting any iterable as input. This probably requires turning\n+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n+      is probably negligible in most cases, but one would need to double\n+      check that we don't have spots where `CartesianProduct` is used\n+      intensively for very small calculations. #14224 can be closed once this is fixed.\n+    - Some features of `CartesianProduct` still need to be lifted to `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. For example, cardinality is currently calculated from the iterator (gasp):\n+      {{{\n+          sage: F = Permutations(10)\n+          sage: C = cartesian_product([F,F])\n+          sage: C.cardinality()\n+          *hangs forever*\n+      }}}\n+      Done by #16269/#10963 for cardinality and `__iter__`. Needs double checking for the infinite and zero cases.\n+\n+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n+\n+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in `Sets.ParentMethods.CartesianProduct`:\n+    {{{\n+ \t\treturn parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+5.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+6.  Fix cartesian products involving `NN`:\n+    {{{\n+  \tsage: cartesian_product([NN,NN])\n+  \t170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+  \t172         # Should we pass a set of categories to reduce the cache size?\n+  \t173         # But then this would impose that, for any constructor, the\n+  \tAssertionError: \n+    }}}\n+    This is in fact a bug in the way `NN` is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+  \t<type 'sage.misc.lazy_import.LazyImport'>\n+  \tsage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of `NN`:\n+    {{{\n+  \tsage: NN = NonNegativeIntegers()\n+  \tsage: cartesian_product([NN,NN])\n+  \tThe cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+7.  Make `_cartesian_product_of_elements` a public method?\n+\n+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`\n+    describing the general scheme, possibly starting from the blurb there:\n+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ\n+\n+9.  Tidy up the documentation of sage.sets.cartesian_products:\n+    Return(s), the links to `Sets....` don't need to be prefixed with\n+    the python module (Sets is found from the global name space), ...\n+\n+10. Many features could be further added, like for example making the\n+    cartesian product of an additive magma into an additive magma, and\n+    so on. A good step was done with #16269. Another step needs to be\n+    done after #10963 to ventilate the features in the appropriate\n+    axiom categories, and implement\n+    `Distributive.CartesianProducts` so that a cartesian product\n+    of rings would be a ring.\n \n \n Comment: 1\n``````\n",
    "created_at": "2014-05-05T13:22:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207953",
    "user": "https://github.com/nthiery"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,122 @@
+Currently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
+
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
+    - Accepting any iterable as input. This probably requires turning
+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
+      is probably negligible in most cases, but one would need to double
+      check that we don't have spots where `CartesianProduct` is used
+      intensively for very small calculations. #14224 can be closed once this is fixed.
+    - Some features of `CartesianProduct` still need to be lifted to `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. For example, cardinality is currently calculated from the iterator (gasp):
+      {{{
+          sage: F = Permutations(10)
+          sage: C = cartesian_product([F,F])
+          sage: C.cardinality()
+          *hangs forever*
+      }}}
+      Done by #16269/#10963 for cardinality and `__iter__`. Needs double checking for the infinite and zero cases.
+
+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.
+
+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in `Sets.ParentMethods.CartesianProduct`:
+    {{{
+ 		return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+5.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+6.  Fix cartesian products involving `NN`:
+    {{{
+  	sage: cartesian_product([NN,NN])
+  	170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+  	172         # Should we pass a set of categories to reduce the cache size?
+  	173         # But then this would impose that, for any constructor, the
+  	AssertionError: 
+    }}}
+    This is in fact a bug in the way `NN` is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+  	<type 'sage.misc.lazy_import.LazyImport'>
+  	sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of `NN`:
+    {{{
+  	sage: NN = NonNegativeIntegers()
+  	sage: cartesian_product([NN,NN])
+  	The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+7.  Make `_cartesian_product_of_elements` a public method?
+
+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`
+    describing the general scheme, possibly starting from the blurb there:
+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ
+
+9.  Tidy up the documentation of sage.sets.cartesian_products:
+    Return(s), the links to `Sets....` don't need to be prefixed with
+    the python module (Sets is found from the global name space), ...
+
+10. Many features could be further added, like for example making the
+    cartesian product of an additive magma into an additive magma, and
+    so on. A good step was done with #16269. Another step needs to be
+    done after #10963 to ventilate the features in the appropriate
+    axiom categories, and implement
+    `Distributive.CartesianProducts` so that a cartesian product
+    of rings would be a ring.
 
 
 Comment: 1
``````




---

archive/issue_events_044914.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44914"
}
```



---

archive/issue_events_044915.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44915"
}
```



---

archive/issue_comments_207954.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,119 @@\n+Currently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n+\n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n+    - Accepting any iterable as input. This probably requires turning\n+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n+      is probably negligible in most cases, but one would need to double\n+      check that we don't have spots where `CartesianProduct` is used\n+      intensively for very small calculations. #14224 can be closed once this is fixed.\n+    - Some features of `CartesianProduct` still need to be lifted to `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. For example, cardinality is currently calculated from the iterator (gasp):\n+      {{{\n+          sage: F = Permutations(10)\n+          sage: C = cartesian_product([F,F])\n+          sage: C.cardinality()\n+          *hangs forever*\n+      }}}\n+      Done by #16269/#10963 for cardinality and `__iter__`. Needs double checking for the infinite and zero cases.\n+\n+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n+\n+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in `Sets.ParentMethods.CartesianProduct`:\n+    {{{\n+ \t\treturn parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+5.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+6.  Fix cartesian products involving `NN`:\n+    {{{\n+  \tsage: cartesian_product([NN,NN])\n+  \t170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+  \t172         # Should we pass a set of categories to reduce the cache size?\n+  \t173         # But then this would impose that, for any constructor, the\n+  \tAssertionError: \n+    }}}\n+    This is in fact a bug in the way `NN` is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+  \t<type 'sage.misc.lazy_import.LazyImport'>\n+  \tsage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of `NN`:\n+    {{{\n+  \tsage: NN = NonNegativeIntegers()\n+  \tsage: cartesian_product([NN,NN])\n+  \tThe cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+7.  Make `_cartesian_product_of_elements` a public method?\n+\n+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`\n+    describing the general scheme, possibly starting from the blurb there:\n+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ\n+\n+9.  Tidy up the documentation of sage.sets.cartesian_products:\n+    Return(s), the links to `Sets....` don't need to be prefixed with\n+    the python module (Sets is found from the global name space), ...\n+\n+10. #16269 and follow up #16405 (depended on #10963): make the\n+    cartesian product of an additive magma into an additive magma, and\n+    so on; implement `Distributive.CartesianProducts` so that a\n+    cartesian product of rings is a ring.\n \n \n Comment: 1\n``````\n",
    "created_at": "2014-05-27T15:03:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207954",
    "user": "https://github.com/nthiery"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,119 @@
+Currently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
+
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
+    - Accepting any iterable as input. This probably requires turning
+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
+      is probably negligible in most cases, but one would need to double
+      check that we don't have spots where `CartesianProduct` is used
+      intensively for very small calculations. #14224 can be closed once this is fixed.
+    - Some features of `CartesianProduct` still need to be lifted to `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. For example, cardinality is currently calculated from the iterator (gasp):
+      {{{
+          sage: F = Permutations(10)
+          sage: C = cartesian_product([F,F])
+          sage: C.cardinality()
+          *hangs forever*
+      }}}
+      Done by #16269/#10963 for cardinality and `__iter__`. Needs double checking for the infinite and zero cases.
+
+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.
+
+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in `Sets.ParentMethods.CartesianProduct`:
+    {{{
+ 		return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+5.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+6.  Fix cartesian products involving `NN`:
+    {{{
+  	sage: cartesian_product([NN,NN])
+  	170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+  	172         # Should we pass a set of categories to reduce the cache size?
+  	173         # But then this would impose that, for any constructor, the
+  	AssertionError: 
+    }}}
+    This is in fact a bug in the way `NN` is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+  	<type 'sage.misc.lazy_import.LazyImport'>
+  	sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of `NN`:
+    {{{
+  	sage: NN = NonNegativeIntegers()
+  	sage: cartesian_product([NN,NN])
+  	The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+7.  Make `_cartesian_product_of_elements` a public method?
+
+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`
+    describing the general scheme, possibly starting from the blurb there:
+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ
+
+9.  Tidy up the documentation of sage.sets.cartesian_products:
+    Return(s), the links to `Sets....` don't need to be prefixed with
+    the python module (Sets is found from the global name space), ...
+
+10. #16269 and follow up #16405 (depended on #10963): make the
+    cartesian product of an additive magma into an additive magma, and
+    so on; implement `Distributive.CartesianProducts` so that a
+    cartesian product of rings is a ring.
 
 
 Comment: 1
``````




---

archive/issue_events_044916.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44916"
}
```



---

archive/issue_events_044917.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44917"
}
```



---

archive/issue_comments_207955.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,114 @@\n+Currently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n+\n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n+    - Accepting any iterable as input. This probably requires turning\n+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n+      is probably negligible in most cases, but one would need to double\n+      check that we don't have spots where `CartesianProduct` is used\n+      intensively for very small calculations. #14224 can be closed once this is fixed.\n+    - Some features of `CartesianProduct` still need to be lifted to\n+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The\n+      `cardinality` and `is_finite` methods are taken care in #18290.\n+\n+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n+\n+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in `Sets.ParentMethods.CartesianProduct`:\n+    {{{\n+ \t\treturn parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+5.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+6.  Fix cartesian products involving `NN`:\n+    {{{\n+  \tsage: cartesian_product([NN,NN])\n+  \t170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+  \t172         # Should we pass a set of categories to reduce the cache size?\n+  \t173         # But then this would impose that, for any constructor, the\n+  \tAssertionError: \n+    }}}\n+    This is in fact a bug in the way `NN` is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+  \t<type 'sage.misc.lazy_import.LazyImport'>\n+  \tsage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of `NN`:\n+    {{{\n+  \tsage: NN = NonNegativeIntegers()\n+  \tsage: cartesian_product([NN,NN])\n+  \tThe cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+7.  Make `_cartesian_product_of_elements` a public method?\n+\n+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`\n+    describing the general scheme, possibly starting from the blurb there:\n+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ\n+\n+9.  Tidy up the documentation of sage.sets.cartesian_products:\n+    Return(s), the links to `Sets....` don't need to be prefixed with\n+    the python module (Sets is found from the global name space), ...\n+\n+10. #16269 and follow up #16405 (depended on #10963): make the\n+    cartesian product of an additive magma into an additive magma, and\n+    so on; implement `Distributive.CartesianProducts` so that a\n+    cartesian product of rings is a ring.\n \n \n Comment: 1\n``````\n",
    "created_at": "2015-04-23T15:04:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207955",
    "user": "https://github.com/videlec"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,114 @@
+Currently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
+
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
+    - Accepting any iterable as input. This probably requires turning
+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
+      is probably negligible in most cases, but one would need to double
+      check that we don't have spots where `CartesianProduct` is used
+      intensively for very small calculations. #14224 can be closed once this is fixed.
+    - Some features of `CartesianProduct` still need to be lifted to
+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The
+      `cardinality` and `is_finite` methods are taken care in #18290.
+
+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.
+
+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in `Sets.ParentMethods.CartesianProduct`:
+    {{{
+ 		return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+5.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+6.  Fix cartesian products involving `NN`:
+    {{{
+  	sage: cartesian_product([NN,NN])
+  	170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+  	172         # Should we pass a set of categories to reduce the cache size?
+  	173         # But then this would impose that, for any constructor, the
+  	AssertionError: 
+    }}}
+    This is in fact a bug in the way `NN` is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+  	<type 'sage.misc.lazy_import.LazyImport'>
+  	sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of `NN`:
+    {{{
+  	sage: NN = NonNegativeIntegers()
+  	sage: cartesian_product([NN,NN])
+  	The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+7.  Make `_cartesian_product_of_elements` a public method?
+
+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`
+    describing the general scheme, possibly starting from the blurb there:
+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ
+
+9.  Tidy up the documentation of sage.sets.cartesian_products:
+    Return(s), the links to `Sets....` don't need to be prefixed with
+    the python module (Sets is found from the global name space), ...
+
+10. #16269 and follow up #16405 (depended on #10963): make the
+    cartesian product of an additive magma into an additive magma, and
+    so on; implement `Distributive.CartesianProducts` so that a
+    cartesian product of rings is a ring.
 
 
 Comment: 1
``````




---

archive/issue_comments_207956.json:
```json
{
    "body": "<a id='comment:13'></a>Hello,\n\nI think that we should get rid of `_cartesian_product_of_elements`. If we want speed we can either:\n- add an argument `coerce` to the `_element_constructor_`\n- use directly `element_class`\n\nVincent",
    "created_at": "2015-04-23T15:12:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207956",
    "user": "https://github.com/videlec"
}
```

<a id='comment:13'></a>Hello,

I think that we should get rid of `_cartesian_product_of_elements`. If we want speed we can either:
- add an argument `coerce` to the `_element_constructor_`
- use directly `element_class`

Vincent



---

archive/issue_comments_207957.json:
```json
{
    "body": "<a id='comment:14'></a>Shouldn't the two following commands give the same answer\n\n```\nsage: ZZ**2\nAmbient free module of rank 2 over the principal ideal domain Integer Ring\nsage: cartesian_product([ZZ,ZZ])\nThe cartesian product of (Integer Ring, Integer Ring)\n```",
    "created_at": "2015-04-23T15:17:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207957",
    "user": "https://github.com/videlec"
}
```

<a id='comment:14'></a>Shouldn't the two following commands give the same answer

```
sage: ZZ**2
Ambient free module of rank 2 over the principal ideal domain Integer Ring
sage: cartesian_product([ZZ,ZZ])
The cartesian product of (Integer Ring, Integer Ring)
```



---

archive/issue_comments_207958.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,116 @@\n+Currently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n+\n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n+    - Accepting any iterable as input. This probably requires turning\n+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n+      is probably negligible in most cases, but one would need to double\n+      check that we don't have spots where `CartesianProduct` is used\n+      intensively for very small calculations. #14224 can be closed once this is fixed.\n+    - Some features of `CartesianProduct` still need to be lifted to\n+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The\n+      `cardinality` and `is_finite` methods are taken care in #18290.\n+\n+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n+\n+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in `Sets.ParentMethods.CartesianProduct`:\n+    {{{\n+ \t\treturn parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+5.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+    Also between modules on different ring, in particular #18309.\n+\n+6.  Fix cartesian products involving `NN`:\n+    {{{\n+  \tsage: cartesian_product([NN,NN])\n+  \t170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+  \t172         # Should we pass a set of categories to reduce the cache size?\n+  \t173         # But then this would impose that, for any constructor, the\n+  \tAssertionError: \n+    }}}\n+    This is in fact a bug in the way `NN` is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+  \t<type 'sage.misc.lazy_import.LazyImport'>\n+  \tsage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of `NN`:\n+    {{{\n+  \tsage: NN = NonNegativeIntegers()\n+  \tsage: cartesian_product([NN,NN])\n+  \tThe cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+7.  Make `_cartesian_product_of_elements` a public method?\n+\n+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`\n+    describing the general scheme, possibly starting from the blurb there:\n+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ\n+\n+9.  Tidy up the documentation of sage.sets.cartesian_products:\n+    Return(s), the links to `Sets....` don't need to be prefixed with\n+    the python module (Sets is found from the global name space), ...\n+\n+10. #16269 and follow up #16405 (depended on #10963): make the\n+    cartesian product of an additive magma into an additive magma, and\n+    so on; implement `Distributive.CartesianProducts` so that a\n+    cartesian product of rings is a ring.\n \n \n Comment: 1\n``````\n",
    "created_at": "2015-04-27T09:54:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207958",
    "user": "https://github.com/videlec"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,116 @@
+Currently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
+
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
+    - Accepting any iterable as input. This probably requires turning
+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
+      is probably negligible in most cases, but one would need to double
+      check that we don't have spots where `CartesianProduct` is used
+      intensively for very small calculations. #14224 can be closed once this is fixed.
+    - Some features of `CartesianProduct` still need to be lifted to
+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The
+      `cardinality` and `is_finite` methods are taken care in #18290.
+
+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.
+
+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in `Sets.ParentMethods.CartesianProduct`:
+    {{{
+ 		return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+5.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+    Also between modules on different ring, in particular #18309.
+
+6.  Fix cartesian products involving `NN`:
+    {{{
+  	sage: cartesian_product([NN,NN])
+  	170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+  	172         # Should we pass a set of categories to reduce the cache size?
+  	173         # But then this would impose that, for any constructor, the
+  	AssertionError: 
+    }}}
+    This is in fact a bug in the way `NN` is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+  	<type 'sage.misc.lazy_import.LazyImport'>
+  	sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of `NN`:
+    {{{
+  	sage: NN = NonNegativeIntegers()
+  	sage: cartesian_product([NN,NN])
+  	The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+7.  Make `_cartesian_product_of_elements` a public method?
+
+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`
+    describing the general scheme, possibly starting from the blurb there:
+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ
+
+9.  Tidy up the documentation of sage.sets.cartesian_products:
+    Return(s), the links to `Sets....` don't need to be prefixed with
+    the python module (Sets is found from the global name space), ...
+
+10. #16269 and follow up #16405 (depended on #10963): make the
+    cartesian product of an additive magma into an additive magma, and
+    so on; implement `Distributive.CartesianProducts` so that a
+    cartesian product of rings is a ring.
 
 
 Comment: 1
``````




---

archive/issue_comments_207959.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,116 @@\n+Currently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n+\n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n+    - Accepting any iterable as input. This probably requires turning\n+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n+      is probably negligible in most cases, but one would need to double\n+      check that we don't have spots where `CartesianProduct` is used\n+      intensively for very small calculations. #14224 can be closed once this is fixed.\n+    - Some features of `CartesianProduct` still need to be lifted to\n+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The\n+      `cardinality` and `is_finite` methods are taken care in #18290.\n+\n+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n+\n+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in `Sets.ParentMethods.CartesianProduct`:\n+    {{{\n+        return parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+5.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+    Also between modules on different ring, in particular #18309.\n+\n+6.  Fix cartesian products involving `NN`:\n+    {{{\n+    sage: cartesian_product([NN,NN])\n+    170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+    172         # Should we pass a set of categories to reduce the cache size?\n+    173         # But then this would impose that, for any constructor, the\n+    AssertionError: \n+    }}}\n+    This is in fact a bug in the way `NN` is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+    <type 'sage.misc.lazy_import.LazyImport'>\n+    sage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of `NN`:\n+    {{{\n+    sage: NN = NonNegativeIntegers()\n+    sage: cartesian_product([NN,NN])\n+    The cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+7.  Make `_cartesian_product_of_elements` a public method?\n+\n+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`\n+    describing the general scheme, possibly starting from the blurb there:\n+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ\n+\n+9.  Tidy up the documentation of sage.sets.cartesian_products:\n+    Return(s), the links to `Sets....` don't need to be prefixed with\n+    the python module (Sets is found from the global name space), ...\n+\n+10. #16269 and follow up #16405 (depended on #10963): make the\n+    cartesian product of an additive magma into an additive magma, and\n+    so on; implement `Distributive.CartesianProducts` so that a\n+    cartesian product of rings is a ring.\n \n \n Comment: 1\n``````\n",
    "created_at": "2015-09-06T13:28:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207959",
    "user": "https://github.com/fchapoton"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,116 @@
+Currently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
+
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+1.  Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
+    - Accepting any iterable as input. This probably requires turning
+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
+      is probably negligible in most cases, but one would need to double
+      check that we don't have spots where `CartesianProduct` is used
+      intensively for very small calculations. #14224 can be closed once this is fixed.
+    - Some features of `CartesianProduct` still need to be lifted to
+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The
+      `cardinality` and `is_finite` methods are taken care in #18290.
+
+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.
+
+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in `Sets.ParentMethods.CartesianProduct`:
+    {{{
+        return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+5.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+    Also between modules on different ring, in particular #18309.
+
+6.  Fix cartesian products involving `NN`:
+    {{{
+    sage: cartesian_product([NN,NN])
+    170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+    172         # Should we pass a set of categories to reduce the cache size?
+    173         # But then this would impose that, for any constructor, the
+    AssertionError: 
+    }}}
+    This is in fact a bug in the way `NN` is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+    <type 'sage.misc.lazy_import.LazyImport'>
+    sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of `NN`:
+    {{{
+    sage: NN = NonNegativeIntegers()
+    sage: cartesian_product([NN,NN])
+    The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+7.  Make `_cartesian_product_of_elements` a public method?
+
+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`
+    describing the general scheme, possibly starting from the blurb there:
+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ
+
+9.  Tidy up the documentation of sage.sets.cartesian_products:
+    Return(s), the links to `Sets....` don't need to be prefixed with
+    the python module (Sets is found from the global name space), ...
+
+10. #16269 and follow up #16405 (depended on #10963): make the
+    cartesian product of an additive magma into an additive magma, and
+    so on; implement `Distributive.CartesianProducts` so that a
+    cartesian product of rings is a ring.
 
 
 Comment: 1
``````




---

archive/issue_comments_207960.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,118 @@\n+Currently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n+\n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+1. #18411: Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n+    - Accepting any iterable as input. This probably requires turning\n+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n+      is probably negligible in most cases, but one would need to double\n+      check that we don't have spots where `CartesianProduct` is used\n+      intensively for very small calculations. #14224 can be closed once this is fixed.\n+    - Some features of `CartesianProduct` still need to be lifted to\n+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The\n+      `cardinality` and `is_finite` methods are taken care in #18290. Some other\n+      are in #18411.\n+    - #19195: Fix the use of `CartesianProduct` in `CombinatorialFreeModule`\n+\n+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n+\n+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in `Sets.ParentMethods.CartesianProduct`:\n+    {{{\n+        return parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+5.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+    Also between modules on different ring, in particular #18309.\n+\n+6.  Fix cartesian products involving `NN`:\n+    {{{\n+    sage: cartesian_product([NN,NN])\n+    170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+    172         # Should we pass a set of categories to reduce the cache size?\n+    173         # But then this would impose that, for any constructor, the\n+    AssertionError: \n+    }}}\n+    This is in fact a bug in the way `NN` is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+    <type 'sage.misc.lazy_import.LazyImport'>\n+    sage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of `NN`:\n+    {{{\n+    sage: NN = NonNegativeIntegers()\n+    sage: cartesian_product([NN,NN])\n+    The cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+7.  Make `_cartesian_product_of_elements` a public method?\n+\n+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`\n+    describing the general scheme, possibly starting from the blurb there:\n+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ\n+\n+9.  Tidy up the documentation of sage.sets.cartesian_products:\n+    Return(s), the links to `Sets....` don't need to be prefixed with\n+    the python module (Sets is found from the global name space), ...\n+\n+10. #16269 and follow up #16405 (depended on #10963): make the\n+    cartesian product of an additive magma into an additive magma, and\n+    so on; implement `Distributive.CartesianProducts` so that a\n+    cartesian product of rings is a ring.\n \n \n Comment: 1\n``````\n",
    "created_at": "2015-09-13T02:24:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207960",
    "user": "https://github.com/videlec"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,118 @@
+Currently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
+
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+1. #18411: Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
+    - Accepting any iterable as input. This probably requires turning
+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
+      is probably negligible in most cases, but one would need to double
+      check that we don't have spots where `CartesianProduct` is used
+      intensively for very small calculations. #14224 can be closed once this is fixed.
+    - Some features of `CartesianProduct` still need to be lifted to
+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The
+      `cardinality` and `is_finite` methods are taken care in #18290. Some other
+      are in #18411.
+    - #19195: Fix the use of `CartesianProduct` in `CombinatorialFreeModule`
+
+2.  Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.
+
+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in `Sets.ParentMethods.CartesianProduct`:
+    {{{
+        return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+5.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+    Also between modules on different ring, in particular #18309.
+
+6.  Fix cartesian products involving `NN`:
+    {{{
+    sage: cartesian_product([NN,NN])
+    170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+    172         # Should we pass a set of categories to reduce the cache size?
+    173         # But then this would impose that, for any constructor, the
+    AssertionError: 
+    }}}
+    This is in fact a bug in the way `NN` is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+    <type 'sage.misc.lazy_import.LazyImport'>
+    sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of `NN`:
+    {{{
+    sage: NN = NonNegativeIntegers()
+    sage: cartesian_product([NN,NN])
+    The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+7.  Make `_cartesian_product_of_elements` a public method?
+
+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`
+    describing the general scheme, possibly starting from the blurb there:
+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ
+
+9.  Tidy up the documentation of sage.sets.cartesian_products:
+    Return(s), the links to `Sets....` don't need to be prefixed with
+    the python module (Sets is found from the global name space), ...
+
+10. #16269 and follow up #16405 (depended on #10963): make the
+    cartesian product of an additive magma into an additive magma, and
+    so on; implement `Distributive.CartesianProducts` so that a
+    cartesian product of rings is a ring.
 
 
 Comment: 1
``````




---

archive/issue_events_044918.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2015-09-13T02:24:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44918"
}
```



---

archive/issue_events_044919.json:
```json
{
    "actor": "https://github.com/videlec",
    "created_at": "2015-09-13T02:24:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44919"
}
```



---

archive/issue_events_044920.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-10T21:20:40Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-6.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44920"
}
```



---

archive/issue_events_044921.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-10T21:20:40Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44921"
}
```



---

archive/issue_comments_207961.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,118 @@\n+Currently we have: `cartesian_product`, `CartesianProduct` and\n+`cartesian_product_iterator` for constructing cartesian products.\n+\n+- `CartesianProduct` is an old simple parent that focuses on the\n+  \"enumerated sets\" aspect: providing counting and enumeration over\n+  cartesian products of enumerated sets. It accepts any iterables as\n+  input.\n+\n+- `cartesian_product` is a \"functorial construction\". This means\n+  that it uses the categories to endow the resulting parent with as\n+  much structure as it can lift from the input. E.g. the cartesian\n+  product of two monoids is a monoid.\n+\n+- `cartesian_product_iterator` is just a function that provides an\n+  iterator\n+\n+To be done:\n+\n+1. #18411: Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:\n+    - Accepting any iterable as input. This probably requires turning\n+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead\n+      is probably negligible in most cases, but one would need to double\n+      check that we don't have spots where `CartesianProduct` is used\n+      intensively for very small calculations. #14224 can be closed once this is fixed.\n+    - Some features of `CartesianProduct` still need to be lifted to\n+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The\n+      `cardinality` and `is_finite` methods are taken care in #18290. Some other\n+      are in #18411.\n+    - #19195: Fix the use of `CartesianProduct` in `CombinatorialFreeModule`\n+\n+2.  #34337: Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.\n+\n+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):\n+    {{{\n+    sage: C = cartesian_product([ZZ,ZZ])\n+    ...\n+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'\n+    }}}\n+\n+    This is a regression that is caused by a small change introduced by\n+    #12959 in `Sets.ParentMethods.CartesianProduct`:\n+    {{{\n+        return parents[0].__class__ -> return parents[0].__class__\n+    }}}\n+\n+    I (Nicolas) take a double blame for it: I was reviewer of this ticket\n+    and did not notice this chunk (or don't remember why it was\n+    introduced), and I had not written an appropriate test in the first\n+    place. So this needs to be fixed too.\n+\n+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a\n+    list to an element of a cartesian product:\n+    {{{\n+    sage: Z3 = IntegerModRing(3)\n+    sage: C = cartesian_product([Z3,Z3])\n+    sage: C([Z3(2),Z3(2)])^2\n+    (1, 1)\n+    sage: C([2,2])^2   # Ooops\n+    (4, 4)\n+    }}}\n+\n+    The fix would be convert the operands of the list into the respective\n+    parents in\n+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.\n+\n+5.  Fix mixed cartesian products with modules and non modules:\n+    {{{\n+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename(\"A\")\n+    sage: cartesian_product([A, ZZ])\n+    ...\n+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'\n+    }}}\n+    This should instead detect that not all factors are modules, and\n+    just use a plain cartesian product.\n+\n+    Also between modules on different ring, in particular #18309.\n+\n+6.  Fix cartesian products involving `NN`:\n+    {{{\n+    sage: cartesian_product([NN,NN])\n+    170         from sage.structure.parent import Parent\n+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))\n+    172         # Should we pass a set of categories to reduce the cache size?\n+    173         # But then this would impose that, for any constructor, the\n+    AssertionError: \n+    }}}\n+    This is in fact a bug in the way `NN` is lazy imported in the global\n+    name space:\n+    {{{\n+        sage: type(NN)\n+    <type 'sage.misc.lazy_import.LazyImport'>\n+    sage: isinstance(NN, Parent)\n+        False\n+    }}}\n+    Things works if one forces the import of `NN`:\n+    {{{\n+    sage: NN = NonNegativeIntegers()\n+    sage: cartesian_product([NN,NN])\n+    The cartesian product of (Non negative integers, Non negative integers)\n+    }}}\n+\n+7.  Make `_cartesian_product_of_elements` a public method?\n+\n+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`\n+    describing the general scheme, possibly starting from the blurb there:\n+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ\n+\n+9.  Tidy up the documentation of sage.sets.cartesian_products:\n+    Return(s), the links to `Sets....` don't need to be prefixed with\n+    the python module (Sets is found from the global name space), ...\n+\n+10. #16269 and follow up #16405 (depended on #10963): make the\n+    cartesian product of an additive magma into an additive magma, and\n+    so on; implement `Distributive.CartesianProducts` so that a\n+    cartesian product of rings is a ring.\n \n \n Comment: 1\n``````\n",
    "created_at": "2022-08-10T21:48:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207961",
    "user": "https://github.com/mkoeppe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,118 @@
+Currently we have: `cartesian_product`, `CartesianProduct` and
+`cartesian_product_iterator` for constructing cartesian products.
+
+- `CartesianProduct` is an old simple parent that focuses on the
+  "enumerated sets" aspect: providing counting and enumeration over
+  cartesian products of enumerated sets. It accepts any iterables as
+  input.
+
+- `cartesian_product` is a "functorial construction". This means
+  that it uses the categories to endow the resulting parent with as
+  much structure as it can lift from the input. E.g. the cartesian
+  product of two monoids is a monoid.
+
+- `cartesian_product_iterator` is just a function that provides an
+  iterator
+
+To be done:
+
+1. #18411: Make `CartesianProduct` an alias for `cartesian_product`, and possibly deprecated it. The missing features at this point are:
+    - Accepting any iterable as input. This probably requires turning
+      them into parents (e.g. with `FiniteEnumeratedSet`). The overhead
+      is probably negligible in most cases, but one would need to double
+      check that we don't have spots where `CartesianProduct` is used
+      intensively for very small calculations. #14224 can be closed once this is fixed.
+    - Some features of `CartesianProduct` still need to be lifted to
+      `Sets.Finite.CartesianProducts` or `EnumeratedSets.CartesianProducts`. The
+      `cardinality` and `is_finite` methods are taken care in #18290. Some other
+      are in #18411.
+    - #19195: Fix the use of `CartesianProduct` in `CombinatorialFreeModule`
+
+2.  #34337: Remove `cartesian_product_iterator` from the global name space, and deprecate it altogether if, after checking, it turns out to be really just a duplicated of `itertools.product`.
+
+3.  #16289: Fix bug in cartesian_product (reported by Vincent Delecroix in [this thread](https://groups.google.com/forum/#!topic/sage-combinat-devel/8Aw63kro_0M)):
+    {{{
+    sage: C = cartesian_product([ZZ,ZZ])
+    ...
+    AttributeError: type object 'sage.rings.integer_ring.IntegerRing_class' has no attribute 'CartesianProduct'
+    }}}
+
+    This is a regression that is caused by a small change introduced by
+    #12959 in `Sets.ParentMethods.CartesianProduct`:
+    {{{
+        return parents[0].__class__ -> return parents[0].__class__
+    }}}
+
+    I (Nicolas) take a double blame for it: I was reviewer of this ticket
+    and did not notice this chunk (or don't remember why it was
+    introduced), and I had not written an appropriate test in the first
+    place. So this needs to be fixed too.
+
+4.  #16269: Fix bug reported by Nathann Cohen in [this thread](https://groups.google.com/forum/#!msg/sage-devel/tyAxhqxk3ZI/rff7pTrGIQ4J): when converting a
+    list to an element of a cartesian product:
+    {{{
+    sage: Z3 = IntegerModRing(3)
+    sage: C = cartesian_product([Z3,Z3])
+    sage: C([Z3(2),Z3(2)])^2
+    (1, 1)
+    sage: C([2,2])^2   # Ooops
+    (4, 4)
+    }}}
+
+    The fix would be convert the operands of the list into the respective
+    parents in
+    `sage.sets.cartesian_product.CartesianProduct._element_constructor`.
+
+5.  Fix mixed cartesian products with modules and non modules:
+    {{{
+    sage: A = AlgebrasWithBasis(QQ).example(); A.rename("A")
+    sage: cartesian_product([A, ZZ])
+    ...
+    AttributeError: 'sage.rings.integer_ring.IntegerRing_class' object has no attribute 'basis'
+    }}}
+    This should instead detect that not all factors are modules, and
+    just use a plain cartesian product.
+
+    Also between modules on different ring, in particular #18309.
+
+6.  Fix cartesian products involving `NN`:
+    {{{
+    sage: cartesian_product([NN,NN])
+    170         from sage.structure.parent import Parent
+    --> 171         assert(all(isinstance(parent, Parent) for parent in parents))
+    172         # Should we pass a set of categories to reduce the cache size?
+    173         # But then this would impose that, for any constructor, the
+    AssertionError: 
+    }}}
+    This is in fact a bug in the way `NN` is lazy imported in the global
+    name space:
+    {{{
+        sage: type(NN)
+    <type 'sage.misc.lazy_import.LazyImport'>
+    sage: isinstance(NN, Parent)
+        False
+    }}}
+    Things works if one forces the import of `NN`:
+    {{{
+    sage: NN = NonNegativeIntegers()
+    sage: cartesian_product([NN,NN])
+    The cartesian product of (Non negative integers, Non negative integers)
+    }}}
+
+7.  Make `_cartesian_product_of_elements` a public method?
+
+8.  Add a tutorial in `Sets.SubcategoryMethods.CartesianProducts`
+    describing the general scheme, possibly starting from the blurb there:
+    https://groups.google.com/d/msg/sage-combinat-devel/s_aPBD6BgOg/H1aJbCI1TYoJ
+
+9.  Tidy up the documentation of sage.sets.cartesian_products:
+    Return(s), the links to `Sets....` don't need to be prefixed with
+    the python module (Sets is found from the global name space), ...
+
+10. #16269 and follow up #16405 (depended on #10963): make the
+    cartesian product of an additive magma into an additive magma, and
+    so on; implement `Distributive.CartesianProducts` so that a
+    cartesian product of rings is a ring.
 
 
 Comment: 1
``````




---

archive/issue_comments_207962.json:
```json
{
    "body": "<a id='comment:20'></a>Bugs 5 and 6 are still present in 9.7.beta8",
    "created_at": "2022-08-11T04:52:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15425#issuecomment-207962",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:20'></a>Bugs 5 and 6 are still present in 9.7.beta8



---

archive/issue_events_044922.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44922"
}
```



---

archive/issue_events_044923.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15425",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15425#event-44923"
}
```
