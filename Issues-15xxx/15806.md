# Issue 15806: Integrable representations of (affine) Kac-Moody Lie Algebras

archive/issues_015569.json:
```json
{
    "body": "Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics, weight multiplicities and branching rules using Sage.\n\nThis patch creates a class for integrable representations of untwisted affine Lie algebras.\n\n```\nsage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\nsage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).print_strings()\n3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\nLambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\nLambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\nLambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n```\n\nThis creates the representation of `A_3^{(1)}` with highest weight `Lambda[1]+Lambda[2]+Lambda[3]`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.\n\nOnly untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class. We can do the branching rules as follows:\n\n```\nsage: Lambda = RootSystem(['D',4,1]).weight_lattice(extended=true).fundamental_weights()\nsage: v = IntegrableRepresentation(Lambda[2])\nsage: v.cartan_type().dynkin_diagram()\n    O 4\n    |\n    |\nO---O---O\n1   |2  3\n    |\n    O 0\nD4~\nsage: A1xA1xA1xA1 = WeylCharacterRing(\"A1xA1xA1xA1\",style=\"coroots\")\nsage: v.branch(i=2,weyl_character_ring=A1xA1xA1xA1)\n[A1xA1xA1xA1(0,0,0,0),\n A1xA1xA1xA1(1,1,1,1),\n A1xA1xA1xA1(0,0,0,0) + A1xA1xA1xA1(2,0,0,0) + A1xA1xA1xA1(2,2,0,0) + A1xA1xA1xA1(2,0,2,0) + A1xA1xA1xA1(2,0,0,2) + A1xA1xA1xA1(0,2,0,0) + A1xA1xA1xA1(0,2,2,0) + A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,0,2,0) + A1x\\\nA1xA1xA1(0,0,2,2) + A1xA1xA1xA1(0,0,0,2),\n 7*A1xA1xA1xA1(1,1,1,1) + A1xA1xA1xA1(1,1,1,3) + A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(3,1,1,1),\n 7*A1xA1xA1xA1(0,0,0,0) + 5*A1xA1xA1xA1(2,0,0,0) + 4*A1xA1xA1xA1(2,2,0,0) + 3*A1xA1xA1xA1(2,2,2,0) + A1xA1xA1xA1(2,2,2,2) + 3*A1xA1xA1xA1(2,2,0,2) + 4*A1xA1xA1xA1(2,0,2,0) + 3*A1xA1xA1xA1(2,0,2,2) + 4*A1xA1xA1xA\\\n1(2,0,0,2) + A1xA1xA1xA1(4,0,0,0) + 5*A1xA1xA1xA1(0,2,0,0) + 4*A1xA1xA1xA1(0,2,2,0) + 3*A1xA1xA1xA1(0,2,2,2) + 4*A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,4,0,0) + 5*A1xA1xA1xA1(0,0,2,0) + 4*A1xA1xA1xA1(0,0,2,2) + A1\\\nxA1xA1xA1(0,0,4,0) + 5*A1xA1xA1xA1(0,0,0,2) + A1xA1xA1xA1(0,0,0,4),\n 30*A1xA1xA1xA1(1,1,1,1) + 8*A1xA1xA1xA1(1,1,1,3) + 8*A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,1,3,3) + 8*A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(1,3,1,3) + A1xA1xA1xA1(1,3,3,1) + 8*A1xA1xA1xA1(3,1,1,1) + A1xA1xA1xA1(3,1\\\n,1,3) + A1xA1xA1xA1(3,1,3,1) + A1xA1xA1xA1(3,3,1,1)]\n```\n\n\n\n\nAssignee: @dwbump\n\nCC:  @dwbump sage-combinat\n\nKeywords: Kac-Moody, Integrable Representation, Affine Lie Algebra\n\nReviewer: Travis Scrimshaw\n\nAuthor: Daniel Bump\n\nBranch: 5856c64018eeb56840aaad2c117af4e849b009d1\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/15806\n\n",
    "closed_at": "2015-04-29T03:13:47Z",
    "created_at": "2014-02-10T19:31:18Z",
    "labels": [
        "component: combinatorics"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.7",
    "title": "Integrable representations of (affine) Kac-Moody Lie Algebras",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15806",
    "user": "https://github.com/dwbump"
}
```
Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics, weight multiplicities and branching rules using Sage.

This patch creates a class for integrable representations of untwisted affine Lie algebras.

```
sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).print_strings()
3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
```

This creates the representation of `A_3^{(1)}` with highest weight `Lambda[1]+Lambda[2]+Lambda[3]`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.

Only untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class. We can do the branching rules as follows:

```
sage: Lambda = RootSystem(['D',4,1]).weight_lattice(extended=true).fundamental_weights()
sage: v = IntegrableRepresentation(Lambda[2])
sage: v.cartan_type().dynkin_diagram()
    O 4
    |
    |
O---O---O
1   |2  3
    |
    O 0
D4~
sage: A1xA1xA1xA1 = WeylCharacterRing("A1xA1xA1xA1",style="coroots")
sage: v.branch(i=2,weyl_character_ring=A1xA1xA1xA1)
[A1xA1xA1xA1(0,0,0,0),
 A1xA1xA1xA1(1,1,1,1),
 A1xA1xA1xA1(0,0,0,0) + A1xA1xA1xA1(2,0,0,0) + A1xA1xA1xA1(2,2,0,0) + A1xA1xA1xA1(2,0,2,0) + A1xA1xA1xA1(2,0,0,2) + A1xA1xA1xA1(0,2,0,0) + A1xA1xA1xA1(0,2,2,0) + A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,0,2,0) + A1x\
A1xA1xA1(0,0,2,2) + A1xA1xA1xA1(0,0,0,2),
 7*A1xA1xA1xA1(1,1,1,1) + A1xA1xA1xA1(1,1,1,3) + A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(3,1,1,1),
 7*A1xA1xA1xA1(0,0,0,0) + 5*A1xA1xA1xA1(2,0,0,0) + 4*A1xA1xA1xA1(2,2,0,0) + 3*A1xA1xA1xA1(2,2,2,0) + A1xA1xA1xA1(2,2,2,2) + 3*A1xA1xA1xA1(2,2,0,2) + 4*A1xA1xA1xA1(2,0,2,0) + 3*A1xA1xA1xA1(2,0,2,2) + 4*A1xA1xA1xA\
1(2,0,0,2) + A1xA1xA1xA1(4,0,0,0) + 5*A1xA1xA1xA1(0,2,0,0) + 4*A1xA1xA1xA1(0,2,2,0) + 3*A1xA1xA1xA1(0,2,2,2) + 4*A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,4,0,0) + 5*A1xA1xA1xA1(0,0,2,0) + 4*A1xA1xA1xA1(0,0,2,2) + A1\
xA1xA1xA1(0,0,4,0) + 5*A1xA1xA1xA1(0,0,0,2) + A1xA1xA1xA1(0,0,0,4),
 30*A1xA1xA1xA1(1,1,1,1) + 8*A1xA1xA1xA1(1,1,1,3) + 8*A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,1,3,3) + 8*A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(1,3,1,3) + A1xA1xA1xA1(1,3,3,1) + 8*A1xA1xA1xA1(3,1,1,1) + A1xA1xA1xA1(3,1\
,1,3) + A1xA1xA1xA1(3,1,3,1) + A1xA1xA1xA1(3,3,1,1)]
```




Assignee: @dwbump

CC:  @dwbump sage-combinat

Keywords: Kac-Moody, Integrable Representation, Affine Lie Algebra

Reviewer: Travis Scrimshaw

Author: Daniel Bump

Branch: 5856c64018eeb56840aaad2c117af4e849b009d1

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/15806





---

archive/issue_comments_214444.json:
```json
{
    "body": "<a id='comment:1'></a>New commits:",
    "created_at": "2014-02-10T20:22:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214444",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:1'></a>New commits:



---

archive/issue_comments_214445.json:
```json
{
    "body": "Set assignee to @dwbump.",
    "created_at": "2014-02-10T20:24:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214445",
    "user": "https://github.com/dwbump"
}
```

Set assignee to @dwbump.



---

archive/issue_comments_214446.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,7 +1,7 @@\n Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The affine case is an important special case that was developed in connection with string theory. Since (in this affine case) generating functions for the weight dimensions may be modular forms there are all sorts of connections and it would be good to have this in Sage. It should be straighforward to write such code, and that is the purpose of this ticket.\n+The workhorse algorithm will be the Freudenthal multiplicity formula.\n+\n I am unsure at this point whether to implement only the affine case or the general Kac-Moody case.\n-\n-Keywords: Kac-Moody\n \n Author: bump\n \n```\n",
    "created_at": "2014-02-10T20:24:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214446",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,7 +1,7 @@
 Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The affine case is an important special case that was developed in connection with string theory. Since (in this affine case) generating functions for the weight dimensions may be modular forms there are all sorts of connections and it would be good to have this in Sage. It should be straighforward to write such code, and that is the purpose of this ticket.
+The workhorse algorithm will be the Freudenthal multiplicity formula.
+
 I am unsure at this point whether to implement only the affine case or the general Kac-Moody case.
-
-Keywords: Kac-Moody
 
 Author: bump
 
```




---

archive/issue_comments_214447.json:
```json
{
    "body": "<a id='comment:3'></a>Hey Dan,\n\nI don't know how much of #14901 you might be able to use, but if you want to use parts of it here, let me know and I can split off the necessary portions.\n\nAlso I'd like to see the general Kac-Moody case if it's not too much more work.\n\nBest,\n\nTravis",
    "created_at": "2014-02-10T23:51:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214447",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:3'></a>Hey Dan,

I don't know how much of #14901 you might be able to use, but if you want to use parts of it here, let me know and I can split off the necessary portions.

Also I'd like to see the general Kac-Moody case if it's not too much more work.

Best,

Travis



---

archive/issue_comments_214448.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2014-02-10T23:52:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214448",
    "user": "https://github.com/tscrim"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_214449.json:
```json
{
    "body": "<a id='comment:5'></a>Mainly what I need is the weight lattice and its invariant inner product. In the affine case, what is in `weight_lattice_realizations.py` is not what is needed because this describes the weight lattice for the derived Lie algebra. In other words, for type `['X',r,1]` the weight space that is currently available in Sage is r+1 dimensional, while the realization in Kac's book is r+2 dimensional, and this is what we need. It is not too hard to construct in the affine case. But is this in #14901?\n\nI agree that it is very desirable to have the general KM case. Can your code compute the multiplicities of the imaginary roots?",
    "created_at": "2014-02-11T01:09:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214449",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:5'></a>Mainly what I need is the weight lattice and its invariant inner product. In the affine case, what is in `weight_lattice_realizations.py` is not what is needed because this describes the weight lattice for the derived Lie algebra. In other words, for type `['X',r,1]` the weight space that is currently available in Sage is r+1 dimensional, while the realization in Kac's book is r+2 dimensional, and this is what we need. It is not too hard to construct in the affine case. But is this in #14901?

I agree that it is very desirable to have the general KM case. Can your code compute the multiplicities of the imaginary roots?



---

archive/issue_comments_214450.json:
```json
{
    "body": "<a id='comment:6'></a>There's currently the extended weight space:\n\n```\nsage: P = RootSystem(['A', 3, 1]).weight_space(extended=True)\nsage: P.basis()\nFinite family {0: Lambda[0], 1: Lambda[1], 2: Lambda[2], 3: Lambda[3], 'delta': delta}\nsage: P.simple_root(2).scalar(P.simple_coroot(1))\n-1\nsage: P.simple_root(2).scalar(P.simple_coroot(2))\n2\nsage: P.simple_root(2).scalar(P.null_coroot())\n0\nsage: P.basis()['delta'].scalar(P.simple_coroot(0))\n0\nsage: P.basis()['delta'].scalar(P.simple_coroot(3))\n0\nsage: P.basis()['delta'].scalar(P.null_coroot())\n0\n```\nand that doesn't that work?\n\nIn principle, my code can compute multiplicities of imaginary root space of the KM algebra (once I fix the finitely-presented Lie algebras).",
    "created_at": "2014-02-11T15:56:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214450",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>There's currently the extended weight space:

```
sage: P = RootSystem(['A', 3, 1]).weight_space(extended=True)
sage: P.basis()
Finite family {0: Lambda[0], 1: Lambda[1], 2: Lambda[2], 3: Lambda[3], 'delta': delta}
sage: P.simple_root(2).scalar(P.simple_coroot(1))
-1
sage: P.simple_root(2).scalar(P.simple_coroot(2))
2
sage: P.simple_root(2).scalar(P.null_coroot())
0
sage: P.basis()['delta'].scalar(P.simple_coroot(0))
0
sage: P.basis()['delta'].scalar(P.simple_coroot(3))
0
sage: P.basis()['delta'].scalar(P.null_coroot())
0
```
and that doesn't that work?

In principle, my code can compute multiplicities of imaginary root space of the KM algebra (once I fix the finitely-presented Lie algebras).



---

archive/issue_comments_214451.json:
```json
{
    "body": "<a id='comment:7'></a>The extended weight space should work. Thanks ...",
    "created_at": "2014-02-11T18:47:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214451",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:7'></a>The extended weight space should work. Thanks ...



---

archive/issue_events_046481.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15806#event-46481"
}
```



---

archive/issue_events_046482.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15806#event-46482"
}
```



---

archive/issue_events_046483.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15806#event-46483"
}
```



---

archive/issue_comments_214452.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-02T17:57:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214452",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214453.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,9 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage, though at the moment only untwisted type A is implemented.\n+\n+\n+\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-03T22:56:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214453",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,9 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage, though at the moment only untwisted type A is implemented.
+
+
+
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214454.json:
```json
{
    "body": "<a id='comment:12'></a>New commits:",
    "created_at": "2015-04-03T23:04:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214454",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:12'></a>New commits:



---

archive/issue_comments_214455.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,23 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage, though at the moment only untwisted type A is implemented.\n+\n+You can do the following with this code:\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`\\`Lambda[1]+Lambda[2]+Lambda[3]\\`\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8.\n+\n+\n+\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-03T23:13:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214455",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,23 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage, though at the moment only untwisted type A is implemented.
+
+You can do the following with this code:
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`\`Lambda[1]+Lambda[2]+Lambda[3]\`\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8.
+
+
+
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214456.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,21 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage, though at the moment only untwisted type A is implemented.\n+\n+You can do the following with this code:\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`\\`Lambda[1]+Lambda[2]+Lambda[3]\\`\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables Kass, Moody, Patera and Slansky.\n+\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-03T23:18:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214456",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,21 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage, though at the moment only untwisted type A is implemented.
+
+You can do the following with this code:
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`\`Lambda[1]+Lambda[2]+Lambda[3]\`\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables Kass, Moody, Patera and Slansky.
+
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214457.json:
```json
{
    "body": "<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-10T20:53:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214457",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214458.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,23 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage.\n+\n+You can do the following with this code:\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`\\`Lambda[1]+Lambda[2]+Lambda[3]\\`\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.\n+\n+For other untwisted Cartan types besides Type, I've tested it, and it seems to work correctly. In many cases I can push the results farther than KMPS. Unfortunately for \\`\\`['E',8,1]\\`\\` it is not fast enough to compute very many weights, so for E8 I cannot duplicate their results.\n+\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-10T21:01:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214458",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,23 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage.
+
+You can do the following with this code:
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`\`Lambda[1]+Lambda[2]+Lambda[3]\`\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.
+
+For other untwisted Cartan types besides Type, I've tested it, and it seems to work correctly. In many cases I can push the results farther than KMPS. Unfortunately for \`\`['E',8,1]\`\` it is not fast enough to compute very many weights, so for E8 I cannot duplicate their results.
+
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214459.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,24 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage.\n+\n+You can do the following with this code:\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`\\`Lambda[1]+Lambda[2]+Lambda[3]\\`\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.\n+\n+For other untwisted Cartan types besides Type, I've tested it, and it seems to work correctly. In many cases I can push the results farther than KMPS. Unfortunately for \\`\\`['E',8,1]\\`\\` it is not fast enough to compute very many weights, so for E8 I cannot duplicate their results.\n+\n+Due to a recursive caching scheme it can crash if pushed too hard. Obviously this should be fixed.\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-10T21:17:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214459",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,24 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage.
+
+You can do the following with this code:
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`\`Lambda[1]+Lambda[2]+Lambda[3]\`\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.
+
+For other untwisted Cartan types besides Type, I've tested it, and it seems to work correctly. In many cases I can push the results farther than KMPS. Unfortunately for \`\`['E',8,1]\`\` it is not fast enough to compute very many weights, so for E8 I cannot duplicate their results.
+
+Due to a recursive caching scheme it can crash if pushed too hard. Obviously this should be fixed.
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214460.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,24 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage.\n+\n+You can do the following with this code:\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`\\`Lambda[1]+Lambda[2]+Lambda[3]\\`\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.\n+\n+For other untwisted Cartan types besides Type A, it now seems to work correctly. In many cases I can push the results farther than KMPS. Unfortunately for \\`\\`['E',8,1]\\`\\` it is not fast enough to compute very many weights, so for E8 I cannot duplicate their results.\n+\n+Due to a recursive caching scheme it can crash if pushed too hard. Obviously this should be fixed.\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-10T21:19:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214460",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,24 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage.
+
+You can do the following with this code:
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`\`Lambda[1]+Lambda[2]+Lambda[3]\`\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.
+
+For other untwisted Cartan types besides Type A, it now seems to work correctly. In many cases I can push the results farther than KMPS. Unfortunately for \`\`['E',8,1]\`\` it is not fast enough to compute very many weights, so for E8 I cannot duplicate their results.
+
+Due to a recursive caching scheme it can crash if pushed too hard. Obviously this should be fixed.
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214461.json:
```json
{
    "body": "<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-12T03:07:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214461",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214462.json:
```json
{
    "body": "<a id='comment:20'></a>Okay, I've made some major optimization progress and now it takes half the time as previously. This was mainly achieved by being smart about the computation in `_freudenthal_accum` as to avoid doing multiple vector additions. The downside is this is also more obscure as code. I also did a bunch of other speedups on a smaller scale using little tricks I know and some timings.\n\nI've also some cleanup of the code. In particular, I changed the interface so that `depth` is something passed to the `string` argument rather than as part of the representation's construction data.\n\nThe biggest thing I would want to be changed is that `dominant_maximal` should not need `string` to be called (with some reasonable depth) in order to be computed. Thus if this could be done as a stand-alone, we could cache this, and at the very least, it would mean one less call to `string` in `strings`.\n\nI'm going to hack away at it a bit more tonight to see what other optimizations I might be able to get out of this.",
    "created_at": "2015-04-12T03:32:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214462",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:20'></a>Okay, I've made some major optimization progress and now it takes half the time as previously. This was mainly achieved by being smart about the computation in `_freudenthal_accum` as to avoid doing multiple vector additions. The downside is this is also more obscure as code. I also did a bunch of other speedups on a smaller scale using little tricks I know and some timings.

I've also some cleanup of the code. In particular, I changed the interface so that `depth` is something passed to the `string` argument rather than as part of the representation's construction data.

The biggest thing I would want to be changed is that `dominant_maximal` should not need `string` to be called (with some reasonable depth) in order to be computed. Thus if this could be done as a stand-alone, we could cache this, and at the very least, it would mean one less call to `string` in `strings`.

I'm going to hack away at it a bit more tonight to see what other optimizations I might be able to get out of this.



---

archive/issue_comments_214463.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-12T05:21:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214463",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214464.json:
```json
{
    "body": "<a id='comment:22'></a>So I managed to get another 30% out of it by making sure the tuples all contain integers (it surprised me how much those little casts from `QQ` to `ZZ` added up) and a more cleaver implementation of `to_dominant` and removed the recurrence calls. Both parts resulted in equal gain.\n\nI got a little bit more by taking advantage of the fact that roots are sometimes dense and directly storing and calling the inverse Cartan matrix. I also made the `inner_*q` methods private since they make some relatively strong assumptions.\n\nI'm done for now. Could you test it to make sure everything still works and perhaps also see if you can get further than before?",
    "created_at": "2015-04-12T05:27:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214464",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:22'></a>So I managed to get another 30% out of it by making sure the tuples all contain integers (it surprised me how much those little casts from `QQ` to `ZZ` added up) and a more cleaver implementation of `to_dominant` and removed the recurrence calls. Both parts resulted in equal gain.

I got a little bit more by taking advantage of the fact that roots are sometimes dense and directly storing and calling the inverse Cartan matrix. I also made the `inner_*q` methods private since they make some relatively strong assumptions.

I'm done for now. Could you test it to make sure everything still works and perhaps also see if you can get further than before?



---

archive/issue_comments_214465.json:
```json
{
    "body": "<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-13T23:33:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214465",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214466.json:
```json
{
    "body": "<a id='comment:24'></a>I pushed some mainly minor changes. I do an idea how things could be speeded up, which would be to use (Lambda+rho|Lambda+rho) - (mu+rho|mu+rho) as a hash function. This might be cheaper to compute than to_dominant(mu) and would almost determine m(mu).\n\nI have something else I want to implement, which is the modular characteristic. At the moment I'm trying to implement something that could be called _inner_pp which might be relevant to #18034.",
    "created_at": "2015-04-13T23:41:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214466",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:24'></a>I pushed some mainly minor changes. I do an idea how things could be speeded up, which would be to use (Lambda+rho|Lambda+rho) - (mu+rho|mu+rho) as a hash function. This might be cheaper to compute than to_dominant(mu) and would almost determine m(mu).

I have something else I want to implement, which is the modular characteristic. At the moment I'm trying to implement something that could be called _inner_pp which might be relevant to #18034.



---

archive/issue_comments_214467.json:
```json
{
    "body": "<a id='comment:25'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-14T20:12:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214467",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:25'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214468.json:
```json
{
    "body": "<a id='comment:26'></a>With the last commit inner products are implemented for (x|y) in three cases: when x and y are both elements of the root lattice, when one is in the root lattice and the other in the weight lattice, and when both are in the weight lattice. This code could be moved to `root_lattice_realizations.py` and `weight_lattice_realizations.py` addressing the problem in #18034.",
    "created_at": "2015-04-14T20:19:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214468",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:26'></a>With the last commit inner products are implemented for (x|y) in three cases: when x and y are both elements of the root lattice, when one is in the root lattice and the other in the weight lattice, and when both are in the weight lattice. This code could be moved to `root_lattice_realizations.py` and `weight_lattice_realizations.py` addressing the problem in #18034.



---

archive/issue_comments_214469.json:
```json
{
    "body": "<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-15T02:09:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214469",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214470.json:
```json
{
    "body": "<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-16T00:56:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214470",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214471.json:
```json
{
    "body": "<a id='comment:29'></a>Most of the objectives I had have been accomplished. There is just one problem, which is that the dominant_maximal method needs work. As implemented, the dominant maximal roots weights by just searching out of a suitably large set of roots. The algorithm is not guaranteed to be either correct or efficient. Instead, we should implement Proposition 12.6 of Kac (Infinite-dimensional Lie algebras) which says that the dominant integral weights are in bijection with the elements of the classical root lattice in a suitable dilation and translate of the fundamental alcove.",
    "created_at": "2015-04-16T01:01:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214471",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:29'></a>Most of the objectives I had have been accomplished. There is just one problem, which is that the dominant_maximal method needs work. As implemented, the dominant maximal roots weights by just searching out of a suitably large set of roots. The algorithm is not guaranteed to be either correct or efficient. Instead, we should implement Proposition 12.6 of Kac (Infinite-dimensional Lie algebras) which says that the dominant integral weights are in bijection with the elements of the classical root lattice in a suitable dilation and translate of the fundamental alcove.



---

archive/issue_comments_214472.json:
```json
{
    "body": "<a id='comment:30'></a>Continuing from previous comment:\n\nProposition 12.6 describes the dominant maximal weights as follows. They depend only on two things: the level `k` (currently implemented as `self.level()` and a coset of the weight lattice in the root lattice (called the class in KMPS). So different representations with the same level and class will have the same number of dominant maximal weights, and the same number of strings.\n\nThe weight lattice P has the classical weight lattice P0 of codimension two. It is obtained from P0 by adjoining Lambda[0] and the nullroot delta. The projection of the dominant maximal weights onto P0 has a simple description. Let F be the fundamental alcove, and let `k F` be the dilation of F by the level. So it is bounded by the innequalities `alphacheck[i] >= 0` for i nonzero, and `alphacheck[0] <= k`, where `alphacheck[0]` is the negative of the highest classical root.\n\nThen the projections of the dominant maximal roots into P0 are just the elements of `k F` that are in the right coset of the root lattice. If these are known, then I don't think it will be difficult to recover the dominant maximal roots. I believe that only the method `dominant_maximal` needs to be reimplemented.",
    "created_at": "2015-04-16T08:38:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214472",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:30'></a>Continuing from previous comment:

Proposition 12.6 describes the dominant maximal weights as follows. They depend only on two things: the level `k` (currently implemented as `self.level()` and a coset of the weight lattice in the root lattice (called the class in KMPS). So different representations with the same level and class will have the same number of dominant maximal weights, and the same number of strings.

The weight lattice P has the classical weight lattice P0 of codimension two. It is obtained from P0 by adjoining Lambda[0] and the nullroot delta. The projection of the dominant maximal weights onto P0 has a simple description. Let F be the fundamental alcove, and let `k F` be the dilation of F by the level. So it is bounded by the innequalities `alphacheck[i] >= 0` for i nonzero, and `alphacheck[0] <= k`, where `alphacheck[0]` is the negative of the highest classical root.

Then the projections of the dominant maximal roots into P0 are just the elements of `k F` that are in the right coset of the root lattice. If these are known, then I don't think it will be difficult to recover the dominant maximal roots. I believe that only the method `dominant_maximal` needs to be reimplemented.



---

archive/issue_comments_214473.json:
```json
{
    "body": "Changing keywords from \"Kac-Moody\" to \"Kac-Moody, Integrable Representation, Affine Lie Algebra\".",
    "created_at": "2015-04-16T08:41:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214473",
    "user": "https://github.com/dwbump"
}
```

Changing keywords from "Kac-Moody" to "Kac-Moody, Integrable Representation, Affine Lie Algebra".



---

archive/issue_comments_214474.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,21 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage.\n+\n+You can do the following with this code:\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`\\`Lambda[1]+Lambda[2]+Lambda[3]\\`\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.\n+\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-16T08:41:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214474",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,21 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables using Sage.
+
+You can do the following with this code:
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`\`Lambda[1]+Lambda[2]+Lambda[3]\`\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.
+
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214475.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,23 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities,  modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics and weight multiplicities using Sage.\n+\n+This patch creates a class for integrable representations of untwisted affine Lie algebras.\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`\\`Lambda[1]+Lambda[2]+Lambda[3]\\`\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.\n+\n+Only untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class.\n+\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-16T08:45:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214475",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,23 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities,  modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics and weight multiplicities using Sage.
+
+This patch creates a class for integrable representations of untwisted affine Lie algebras.
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`\`Lambda[1]+Lambda[2]+Lambda[3]\`\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.
+
+Only untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class.
+
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214476.json:
```json
{
    "body": "<a id='comment:33'></a>Here's some code which to get all weights in the `lvl`-dilated dominant chamber:\n\n```\nsage: P = RootSystem(['A',4,1]).weight_lattice(extended=True)\nsage: La = P.fundamental_weights()\nsage: lvl = 3\nsage: def next_level(wt):\n    return [wt + la for la in La if (wt+la).level() < lvl]\n....: \nsage: R = RecursivelyEnumeratedSet([P.zero()], next_level)\nsage: list(R)\n[0,\n Lambda[2],\n Lambda[4],\n Lambda[1],\n Lambda[3],\n Lambda[0],\n Lambda[3] + Lambda[4],\n 2*Lambda[0],\n Lambda[2] + Lambda[4],\n 2*Lambda[1],\n Lambda[2] + Lambda[3],\n Lambda[1] + Lambda[2],\n Lambda[1] + Lambda[3],\n Lambda[1] + Lambda[4],\n 2*Lambda[2],\n Lambda[0] + Lambda[4],\n Lambda[0] + Lambda[1],\n Lambda[0] + Lambda[3],\n Lambda[0] + Lambda[2],\n 2*Lambda[4],\n 2*Lambda[3]]\n```\nif you just want the classical fundamental weights, then do:\n\n```\nsage: La = [P.fundamental_weight(i) for i in P.index_set() if i != 0]\nsage: R = RecursivelyEnumeratedSet([P.zero()], next_level)\nsage: list(R)\n[0,\n Lambda[2],\n Lambda[4],\n Lambda[1],\n Lambda[3],\n Lambda[3] + Lambda[4],\n Lambda[2] + Lambda[4],\n 2*Lambda[1],\n Lambda[2] + Lambda[3],\n Lambda[1] + Lambda[2],\n Lambda[1] + Lambda[3],\n Lambda[1] + Lambda[4],\n 2*Lambda[2],\n 2*Lambda[4],\n 2*Lambda[3]]\n```\nI'm not sure how to check if it's in the right coset off-hand.",
    "created_at": "2015-04-16T14:56:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214476",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:33'></a>Here's some code which to get all weights in the `lvl`-dilated dominant chamber:

```
sage: P = RootSystem(['A',4,1]).weight_lattice(extended=True)
sage: La = P.fundamental_weights()
sage: lvl = 3
sage: def next_level(wt):
    return [wt + la for la in La if (wt+la).level() < lvl]
....: 
sage: R = RecursivelyEnumeratedSet([P.zero()], next_level)
sage: list(R)
[0,
 Lambda[2],
 Lambda[4],
 Lambda[1],
 Lambda[3],
 Lambda[0],
 Lambda[3] + Lambda[4],
 2*Lambda[0],
 Lambda[2] + Lambda[4],
 2*Lambda[1],
 Lambda[2] + Lambda[3],
 Lambda[1] + Lambda[2],
 Lambda[1] + Lambda[3],
 Lambda[1] + Lambda[4],
 2*Lambda[2],
 Lambda[0] + Lambda[4],
 Lambda[0] + Lambda[1],
 Lambda[0] + Lambda[3],
 Lambda[0] + Lambda[2],
 2*Lambda[4],
 2*Lambda[3]]
```
if you just want the classical fundamental weights, then do:

```
sage: La = [P.fundamental_weight(i) for i in P.index_set() if i != 0]
sage: R = RecursivelyEnumeratedSet([P.zero()], next_level)
sage: list(R)
[0,
 Lambda[2],
 Lambda[4],
 Lambda[1],
 Lambda[3],
 Lambda[3] + Lambda[4],
 Lambda[2] + Lambda[4],
 2*Lambda[1],
 Lambda[2] + Lambda[3],
 Lambda[1] + Lambda[2],
 Lambda[1] + Lambda[3],
 Lambda[1] + Lambda[4],
 2*Lambda[2],
 2*Lambda[4],
 2*Lambda[3]]
```
I'm not sure how to check if it's in the right coset off-hand.



---

archive/issue_comments_214477.json:
```json
{
    "body": "<a id='comment:34'></a>> I'm not sure how to check if it's in the right coset off-hand.\n\n\nThis is how I think it goes. Add a multiple of Lambda[0] to give it the right level.\nThen apply `from_weight`. If it does not give integers, discard. Then subtract the\nsmallest multiple of delta that makes `(Lambda+rho|Lambda+rho)-(mu+rho|mu+rho)`\npositive.\n\nI will try to implement this using `RecursivelyEnumeratedSet` as you suggest.",
    "created_at": "2015-04-17T11:44:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214477",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:34'></a>> I'm not sure how to check if it's in the right coset off-hand.


This is how I think it goes. Add a multiple of Lambda[0] to give it the right level.
Then apply `from_weight`. If it does not give integers, discard. Then subtract the
smallest multiple of delta that makes `(Lambda+rho|Lambda+rho)-(mu+rho|mu+rho)`
positive.

I will try to implement this using `RecursivelyEnumeratedSet` as you suggest.



---

archive/issue_comments_214478.json:
```json
{
    "body": "<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-17T17:42:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214478",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214479.json:
```json
{
    "body": "<a id='comment:36'></a>I pushed some code creating a new method `dommax` which is intended to substitute for `dominant_maximal`. I think it is correct and if it tests out OK I'll rename it `dominant_maximal` and retire the old function. At this point I think the status of the patch will be `needs_review`. Thanks Travis for suggesting `RecursivelyEnumeratedSet`.",
    "created_at": "2015-04-17T17:47:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214479",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:36'></a>I pushed some code creating a new method `dommax` which is intended to substitute for `dominant_maximal`. I think it is correct and if it tests out OK I'll rename it `dominant_maximal` and retire the old function. At this point I think the status of the patch will be `needs_review`. Thanks Travis for suggesting `RecursivelyEnumeratedSet`.



---

archive/issue_comments_214480.json:
```json
{
    "body": "<a id='comment:37'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-18T15:11:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214480",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:37'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214481.json:
```json
{
    "body": "<a id='comment:38'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-18T15:24:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214481",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:38'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214482.json:
```json
{
    "body": "<a id='comment:39'></a>I have replaced the `dominant_maximal` method as outlined above (after fixing a bug). I am not changing the status of the patch to `needs_review` yet because I still need to write doctests for a few methods, most importantly the modular characteristic.",
    "created_at": "2015-04-18T15:26:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214482",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:39'></a>I have replaced the `dominant_maximal` method as outlined above (after fixing a bug). I am not changing the status of the patch to `needs_review` yet because I still need to write doctests for a few methods, most importantly the modular characteristic.



---

archive/issue_comments_214483.json:
```json
{
    "body": "<a id='comment:40'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-19T21:24:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214483",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:40'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214484.json:
```json
{
    "body": "<a id='comment:41'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-20T19:35:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214484",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:41'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214485.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-04-20T19:36:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214485",
    "user": "https://github.com/dwbump"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_214486.json:
```json
{
    "body": "<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-21T00:19:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214486",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214487.json:
```json
{
    "body": "<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-21T02:44:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214487",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214488.json:
```json
{
    "body": "<a id='comment:46'></a>I added the branching rule from `[\"X\", r, 1]` to [\"X\", r].\n\nThere is one branching rule for every node in the extended Dynkin diagram. The rule corresponding to the affine node was not too hard to add, so I added it.",
    "created_at": "2015-04-21T02:55:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214488",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:46'></a>I added the branching rule from `["X", r, 1]` to ["X", r].

There is one branching rule for every node in the extended Dynkin diagram. The rule corresponding to the affine node was not too hard to add, so I added it.



---

archive/issue_comments_214489.json:
```json
{
    "body": "<a id='comment:47'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-22T13:29:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214489",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:47'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214490.json:
```json
{
    "body": "<a id='comment:48'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-22T16:19:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214490",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:48'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214491.json:
```json
{
    "body": "<a id='comment:49'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-22T20:05:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214491",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:49'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214492.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,48 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities,  modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics and weight multiplicities using Sage.\n+\n+This patch creates a class for integrable representations of untwisted affine Lie algebras.\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`\\`Lambda[1]+Lambda[2]+Lambda[3]\\`\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.\n+\n+Only untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class. We can do the branching rules as follows:\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['D',4,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: v = IntegrableRepresentation(Lambda[2])\n+sage: v.cartan_type().dynkin_diagram()\n+    O 4\n+    |\n+    |\n+O---O---O\n+1   |2  3\n+    |\n+    O 0\n+D4~\n+sage: A1xA1xA1xA1 = WeylCharacterRing(\"A1xA1xA1xA1\",style=\"coroots\")\n+sage: v.branch(i=2,weyl_character_ring=A1xA1xA1xA1)\n+[A1xA1xA1xA1(0,0,0,0),\n+ A1xA1xA1xA1(1,1,1,1),\n+ A1xA1xA1xA1(0,0,0,0) + A1xA1xA1xA1(2,0,0,0) + A1xA1xA1xA1(2,2,0,0) + A1xA1xA1xA1(2,0,2,0) + A1xA1xA1xA1(2,0,0,2) + A1xA1xA1xA1(0,2,0,0) + A1xA1xA1xA1(0,2,2,0) + A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,0,2,0) + A1x\\\n+A1xA1xA1(0,0,2,2) + A1xA1xA1xA1(0,0,0,2),\n+ 7*A1xA1xA1xA1(1,1,1,1) + A1xA1xA1xA1(1,1,1,3) + A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(3,1,1,1),\n+ 7*A1xA1xA1xA1(0,0,0,0) + 5*A1xA1xA1xA1(2,0,0,0) + 4*A1xA1xA1xA1(2,2,0,0) + 3*A1xA1xA1xA1(2,2,2,0) + A1xA1xA1xA1(2,2,2,2) + 3*A1xA1xA1xA1(2,2,0,2) + 4*A1xA1xA1xA1(2,0,2,0) + 3*A1xA1xA1xA1(2,0,2,2) + 4*A1xA1xA1xA\\\n+1(2,0,0,2) + A1xA1xA1xA1(4,0,0,0) + 5*A1xA1xA1xA1(0,2,0,0) + 4*A1xA1xA1xA1(0,2,2,0) + 3*A1xA1xA1xA1(0,2,2,2) + 4*A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,4,0,0) + 5*A1xA1xA1xA1(0,0,2,0) + 4*A1xA1xA1xA1(0,0,2,2) + A1\\\n+xA1xA1xA1(0,0,4,0) + 5*A1xA1xA1xA1(0,0,0,2) + A1xA1xA1xA1(0,0,0,4),\n+ 30*A1xA1xA1xA1(1,1,1,1) + 8*A1xA1xA1xA1(1,1,1,3) + 8*A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,1,3,3) + 8*A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(1,3,1,3) + A1xA1xA1xA1(1,3,3,1) + 8*A1xA1xA1xA1(3,1,1,1) + A1xA1xA1xA1(3,1\\\n+,1,3) + A1xA1xA1xA1(3,1,3,1) + A1xA1xA1xA1(3,3,1,1)]\n+\\`\\`\\`\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-22T20:27:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214492",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,48 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities,  modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics and weight multiplicities using Sage.
+
+This patch creates a class for integrable representations of untwisted affine Lie algebras.
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`\`Lambda[1]+Lambda[2]+Lambda[3]\`\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.
+
+Only untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class. We can do the branching rules as follows:
+
+\`\`\`
+sage: Lambda = RootSystem(['D',4,1]).weight_lattice(extended=true).fundamental_weights()
+sage: v = IntegrableRepresentation(Lambda[2])
+sage: v.cartan_type().dynkin_diagram()
+    O 4
+    |
+    |
+O---O---O
+1   |2  3
+    |
+    O 0
+D4~
+sage: A1xA1xA1xA1 = WeylCharacterRing("A1xA1xA1xA1",style="coroots")
+sage: v.branch(i=2,weyl_character_ring=A1xA1xA1xA1)
+[A1xA1xA1xA1(0,0,0,0),
+ A1xA1xA1xA1(1,1,1,1),
+ A1xA1xA1xA1(0,0,0,0) + A1xA1xA1xA1(2,0,0,0) + A1xA1xA1xA1(2,2,0,0) + A1xA1xA1xA1(2,0,2,0) + A1xA1xA1xA1(2,0,0,2) + A1xA1xA1xA1(0,2,0,0) + A1xA1xA1xA1(0,2,2,0) + A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,0,2,0) + A1x\
+A1xA1xA1(0,0,2,2) + A1xA1xA1xA1(0,0,0,2),
+ 7*A1xA1xA1xA1(1,1,1,1) + A1xA1xA1xA1(1,1,1,3) + A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(3,1,1,1),
+ 7*A1xA1xA1xA1(0,0,0,0) + 5*A1xA1xA1xA1(2,0,0,0) + 4*A1xA1xA1xA1(2,2,0,0) + 3*A1xA1xA1xA1(2,2,2,0) + A1xA1xA1xA1(2,2,2,2) + 3*A1xA1xA1xA1(2,2,0,2) + 4*A1xA1xA1xA1(2,0,2,0) + 3*A1xA1xA1xA1(2,0,2,2) + 4*A1xA1xA1xA\
+1(2,0,0,2) + A1xA1xA1xA1(4,0,0,0) + 5*A1xA1xA1xA1(0,2,0,0) + 4*A1xA1xA1xA1(0,2,2,0) + 3*A1xA1xA1xA1(0,2,2,2) + 4*A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,4,0,0) + 5*A1xA1xA1xA1(0,0,2,0) + 4*A1xA1xA1xA1(0,0,2,2) + A1\
+xA1xA1xA1(0,0,4,0) + 5*A1xA1xA1xA1(0,0,0,2) + A1xA1xA1xA1(0,0,0,4),
+ 30*A1xA1xA1xA1(1,1,1,1) + 8*A1xA1xA1xA1(1,1,1,3) + 8*A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,1,3,3) + 8*A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(1,3,1,3) + A1xA1xA1xA1(1,3,3,1) + 8*A1xA1xA1xA1(3,1,1,1) + A1xA1xA1xA1(3,1\
+,1,3) + A1xA1xA1xA1(3,1,3,1) + A1xA1xA1xA1(3,3,1,1)]
+\`\`\`
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214493.json:
```json
{
    "body": "<a id='comment:50'></a>I think everything I wanted to implement is now implemented.\nHere is a link to the reference manual documentation for this patch.\n\nhttp://sporadic.stanford.edu/reference/combinat/sage/combinat/root_system/integrable_representations.html",
    "created_at": "2015-04-22T20:27:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214493",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:50'></a>I think everything I wanted to implement is now implemented.
Here is a link to the reference manual documentation for this patch.

http://sporadic.stanford.edu/reference/combinat/sage/combinat/root_system/integrable_representations.html



---

archive/issue_comments_214494.json:
```json
{
    "body": "<a id='comment:51'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-22T20:50:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214494",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:51'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214495.json:
```json
{
    "body": "<a id='comment:52'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-22T22:18:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214495",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:52'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_events_046484.json:
```json
{
    "actor": "https://github.com/dwbump",
    "created_at": "2015-04-23T18:54:48Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15806#event-46484"
}
```



---

archive/issue_events_046485.json:
```json
{
    "actor": "https://github.com/dwbump",
    "created_at": "2015-04-23T18:54:48Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "milestone": "sage-6.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15806#event-46485"
}
```



---

archive/issue_comments_214496.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,48 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics, weight multiplicities and branching rules using Sage.\n+\n+This patch creates a class for integrable representations of untwisted affine Lie algebras.\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`\\`Lambda[1]+Lambda[2]+Lambda[3]\\`\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.\n+\n+Only untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class. We can do the branching rules as follows:\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['D',4,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: v = IntegrableRepresentation(Lambda[2])\n+sage: v.cartan_type().dynkin_diagram()\n+    O 4\n+    |\n+    |\n+O---O---O\n+1   |2  3\n+    |\n+    O 0\n+D4~\n+sage: A1xA1xA1xA1 = WeylCharacterRing(\"A1xA1xA1xA1\",style=\"coroots\")\n+sage: v.branch(i=2,weyl_character_ring=A1xA1xA1xA1)\n+[A1xA1xA1xA1(0,0,0,0),\n+ A1xA1xA1xA1(1,1,1,1),\n+ A1xA1xA1xA1(0,0,0,0) + A1xA1xA1xA1(2,0,0,0) + A1xA1xA1xA1(2,2,0,0) + A1xA1xA1xA1(2,0,2,0) + A1xA1xA1xA1(2,0,0,2) + A1xA1xA1xA1(0,2,0,0) + A1xA1xA1xA1(0,2,2,0) + A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,0,2,0) + A1x\\\n+A1xA1xA1(0,0,2,2) + A1xA1xA1xA1(0,0,0,2),\n+ 7*A1xA1xA1xA1(1,1,1,1) + A1xA1xA1xA1(1,1,1,3) + A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(3,1,1,1),\n+ 7*A1xA1xA1xA1(0,0,0,0) + 5*A1xA1xA1xA1(2,0,0,0) + 4*A1xA1xA1xA1(2,2,0,0) + 3*A1xA1xA1xA1(2,2,2,0) + A1xA1xA1xA1(2,2,2,2) + 3*A1xA1xA1xA1(2,2,0,2) + 4*A1xA1xA1xA1(2,0,2,0) + 3*A1xA1xA1xA1(2,0,2,2) + 4*A1xA1xA1xA\\\n+1(2,0,0,2) + A1xA1xA1xA1(4,0,0,0) + 5*A1xA1xA1xA1(0,2,0,0) + 4*A1xA1xA1xA1(0,2,2,0) + 3*A1xA1xA1xA1(0,2,2,2) + 4*A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,4,0,0) + 5*A1xA1xA1xA1(0,0,2,0) + 4*A1xA1xA1xA1(0,0,2,2) + A1\\\n+xA1xA1xA1(0,0,4,0) + 5*A1xA1xA1xA1(0,0,0,2) + A1xA1xA1xA1(0,0,0,4),\n+ 30*A1xA1xA1xA1(1,1,1,1) + 8*A1xA1xA1xA1(1,1,1,3) + 8*A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,1,3,3) + 8*A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(1,3,1,3) + A1xA1xA1xA1(1,3,3,1) + 8*A1xA1xA1xA1(3,1,1,1) + A1xA1xA1xA1(3,1\\\n+,1,3) + A1xA1xA1xA1(3,1,3,1) + A1xA1xA1xA1(3,3,1,1)]\n+\\`\\`\\`\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-23T19:40:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214496",
    "user": "https://github.com/dwbump"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,48 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics, weight multiplicities and branching rules using Sage.
+
+This patch creates a class for integrable representations of untwisted affine Lie algebras.
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`\`Lambda[1]+Lambda[2]+Lambda[3]\`\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.
+
+Only untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class. We can do the branching rules as follows:
+
+\`\`\`
+sage: Lambda = RootSystem(['D',4,1]).weight_lattice(extended=true).fundamental_weights()
+sage: v = IntegrableRepresentation(Lambda[2])
+sage: v.cartan_type().dynkin_diagram()
+    O 4
+    |
+    |
+O---O---O
+1   |2  3
+    |
+    O 0
+D4~
+sage: A1xA1xA1xA1 = WeylCharacterRing("A1xA1xA1xA1",style="coroots")
+sage: v.branch(i=2,weyl_character_ring=A1xA1xA1xA1)
+[A1xA1xA1xA1(0,0,0,0),
+ A1xA1xA1xA1(1,1,1,1),
+ A1xA1xA1xA1(0,0,0,0) + A1xA1xA1xA1(2,0,0,0) + A1xA1xA1xA1(2,2,0,0) + A1xA1xA1xA1(2,0,2,0) + A1xA1xA1xA1(2,0,0,2) + A1xA1xA1xA1(0,2,0,0) + A1xA1xA1xA1(0,2,2,0) + A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,0,2,0) + A1x\
+A1xA1xA1(0,0,2,2) + A1xA1xA1xA1(0,0,0,2),
+ 7*A1xA1xA1xA1(1,1,1,1) + A1xA1xA1xA1(1,1,1,3) + A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(3,1,1,1),
+ 7*A1xA1xA1xA1(0,0,0,0) + 5*A1xA1xA1xA1(2,0,0,0) + 4*A1xA1xA1xA1(2,2,0,0) + 3*A1xA1xA1xA1(2,2,2,0) + A1xA1xA1xA1(2,2,2,2) + 3*A1xA1xA1xA1(2,2,0,2) + 4*A1xA1xA1xA1(2,0,2,0) + 3*A1xA1xA1xA1(2,0,2,2) + 4*A1xA1xA1xA\
+1(2,0,0,2) + A1xA1xA1xA1(4,0,0,0) + 5*A1xA1xA1xA1(0,2,0,0) + 4*A1xA1xA1xA1(0,2,2,0) + 3*A1xA1xA1xA1(0,2,2,2) + 4*A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,4,0,0) + 5*A1xA1xA1xA1(0,0,2,0) + 4*A1xA1xA1xA1(0,0,2,2) + A1\
+xA1xA1xA1(0,0,4,0) + 5*A1xA1xA1xA1(0,0,0,2) + A1xA1xA1xA1(0,0,0,4),
+ 30*A1xA1xA1xA1(1,1,1,1) + 8*A1xA1xA1xA1(1,1,1,3) + 8*A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,1,3,3) + 8*A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(1,3,1,3) + A1xA1xA1xA1(1,3,3,1) + 8*A1xA1xA1xA1(3,1,1,1) + A1xA1xA1xA1(3,1\
+,1,3) + A1xA1xA1xA1(3,1,3,1) + A1xA1xA1xA1(3,3,1,1)]
+\`\`\`
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214497.json:
```json
{
    "body": "<a id='comment:55'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-24T01:28:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214497",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:55'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214498.json:
```json
{
    "body": "<a id='comment:56'></a>I added doctests to get full coverage, along with some other tweaks and fixes that I wanted to do. I changed the string representation to remove the \"the\" to follow Sage's conventions:\n\n```\nsage: ZZ\nInteger Ring\nsage: QQ\nRational Field\n```\nI also changed the output of `strings` to be a `dict` and implemented `print_strings` to have the formatted printing of the strings you previously had. I also removed the `rho` and `null_root` methods since you can get those from the weight lattice (where they are cached).\n\nHowever, what notation do you want for the representation, as I believe are using V<sub>\\Lambda</sub> and B(\\Lambda)?",
    "created_at": "2015-04-24T01:36:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214498",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:56'></a>I added doctests to get full coverage, along with some other tweaks and fixes that I wanted to do. I changed the string representation to remove the "the" to follow Sage's conventions:

```
sage: ZZ
Integer Ring
sage: QQ
Rational Field
```
I also changed the output of `strings` to be a `dict` and implemented `print_strings` to have the formatted printing of the strings you previously had. I also removed the `rho` and `null_root` methods since you can get those from the weight lattice (where they are cached).

However, what notation do you want for the representation, as I believe are using V<sub>\Lambda</sub> and B(\Lambda)?



---

archive/issue_comments_214499.json:
```json
{
    "body": "<a id='comment:57'></a>>However, what notation do you want for the representation, as I believe are using V\\Lambda and B(\\Lambda)?\n\n\nNot sure I understand the question.\n\nThe following takes a long time but is sort of cool:\n\n```\nsage: Lambda = RootSystem(\"E8~\").weight_lattice(extended=true).fundamental_weights()\nsage: gdim = [x.degree() for x in IntegrableRepresentation(Lambda[0]).branch(depth=4)]\nsage: gdim\n[1, 248, 4124, 34752, 213126]\nsage: oeis(gdim)\n0: A007245: McKay-Thompson series of class 3C for the Monster group.\n```",
    "created_at": "2015-04-24T04:11:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214499",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:57'></a>>However, what notation do you want for the representation, as I believe are using V\Lambda and B(\Lambda)?


Not sure I understand the question.

The following takes a long time but is sort of cool:

```
sage: Lambda = RootSystem("E8~").weight_lattice(extended=true).fundamental_weights()
sage: gdim = [x.degree() for x in IntegrableRepresentation(Lambda[0]).branch(depth=4)]
sage: gdim
[1, 248, 4124, 34752, 213126]
sage: oeis(gdim)
0: A007245: McKay-Thompson series of class 3C for the Monster group.
```



---

archive/issue_comments_214500.json:
```json
{
    "body": "<a id='comment:58'></a>> However, what notation do you want for the representation, as I believe are using V\\Lambda and B(\\Lambda)?\n\n\nThe letter v is used in the doc but perhaps this should be changed.",
    "created_at": "2015-04-24T04:56:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214500",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:58'></a>> However, what notation do you want for the representation, as I believe are using V\Lambda and B(\Lambda)?


The letter v is used in the doc but perhaps this should be changed.



---

archive/issue_comments_214501.json:
```json
{
    "body": "<a id='comment:59'></a>In the example from comment:57 the coefficients are actually those from the cube root of j.\n\n```\nsage: R.<q>=PowerSeriesRing(QQ)\nsage: j = j_invariant_qexp(5); j\nq^-1 + 744 + 196884*q + 21493760*q^2 + 864299970*q^3 + 20245856256*q^4 + O(q^5)\nsage: j.parent()\nLaurent Series Ring in q over Rational Field\nsage: q=j.parent().gen()\nsage: exp(R(q*j).log()/3)\n1 + 248*q + 4124*q^2 + 34752*q^3 + 213126*q^4 + 1057504*q^5 + O(q^6)\n```\n\nPlaying around with oeis gives occasional interpretations of characters and string functions.\n\n```\nsage: Lambda = RootSystem(\"A1~\").weight_lattice(extended=true).fundamental_weights()\nsage: V = IntegrableRepresentation(Lambda[0])\nsage: [x.degree() for x in V.branch(depth=10)]\n[1, 3, 4, 7, 13, 19, 29, 43, 62, 90, 126]\nsage: oeis(_)\n0: A029552: Expansion of phi(x) / f(-x) in powers of x where phi(), f() are Ramanujan \ntheta functions.\nsage: V.string(Lambda[0])\n[1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56]\nsage: oeis(_)\n0: A000041: a(n) = number of partitions of n (the partition numbers).\n```\nKac and Peterson showed in general that the string functions and characters have modular interpretation",
    "created_at": "2015-04-24T13:39:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214501",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:59'></a>In the example from comment:57 the coefficients are actually those from the cube root of j.

```
sage: R.<q>=PowerSeriesRing(QQ)
sage: j = j_invariant_qexp(5); j
q^-1 + 744 + 196884*q + 21493760*q^2 + 864299970*q^3 + 20245856256*q^4 + O(q^5)
sage: j.parent()
Laurent Series Ring in q over Rational Field
sage: q=j.parent().gen()
sage: exp(R(q*j).log()/3)
1 + 248*q + 4124*q^2 + 34752*q^3 + 213126*q^4 + 1057504*q^5 + O(q^6)
```

Playing around with oeis gives occasional interpretations of characters and string functions.

```
sage: Lambda = RootSystem("A1~").weight_lattice(extended=true).fundamental_weights()
sage: V = IntegrableRepresentation(Lambda[0])
sage: [x.degree() for x in V.branch(depth=10)]
[1, 3, 4, 7, 13, 19, 29, 43, 62, 90, 126]
sage: oeis(_)
0: A029552: Expansion of phi(x) / f(-x) in powers of x where phi(), f() are Ramanujan 
theta functions.
sage: V.string(Lambda[0])
[1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42, 56]
sage: oeis(_)
0: A000041: a(n) = number of partitions of n (the partition numbers).
```
Kac and Peterson showed in general that the string functions and characters have modular interpretation



---

archive/issue_comments_214502.json:
```json
{
    "body": "<a id='comment:60'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-24T17:24:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214502",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:60'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214503.json:
```json
{
    "body": "<a id='comment:61'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-24T18:20:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214503",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:61'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214504.json:
```json
{
    "body": "<a id='comment:62'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-24T19:21:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214504",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:62'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214505.json:
```json
{
    "body": "<a id='comment:63'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-24T19:26:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214505",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:63'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214506.json:
```json
{
    "body": "<a id='comment:64'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-24T23:05:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214506",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:64'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214507.json:
```json
{
    "body": "<a id='comment:65'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-25T14:03:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214507",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:65'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214508.json:
```json
{
    "body": "<a id='comment:66'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-26T13:43:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214508",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:66'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_214509.json:
```json
{
    "body": "<a id='comment:67'></a>From our discussion on Friday, my testing, and the patchbot, I'm ready to set this to positive review as we can make the possible cache speedup on a follow-up ticket. Are there any more changes you want to make before then?",
    "created_at": "2015-04-28T18:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214509",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:67'></a>From our discussion on Friday, my testing, and the patchbot, I'm ready to set this to positive review as we can make the possible cache speedup on a follow-up ticket. Are there any more changes you want to make before then?



---

archive/issue_comments_214510.json:
```json
{
    "body": "Description changed:\n```diff\n--- \n+++ \n@@ -1,3 +1,48 @@\n+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics, weight multiplicities and branching rules using Sage.\n+\n+This patch creates a class for integrable representations of untwisted affine Lie algebras.\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).print_strings()\n+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324\n+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655\n+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178\n+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570\n+\\`\\`\\`\n+\n+This creates the representation of \\`A_3^{(1)}\\` with highest weight \\`Lambda[1]+Lambda[2]+Lambda[3]\\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.\n+\n+Only untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class. We can do the branching rules as follows:\n+\n+\\`\\`\\`\n+sage: Lambda = RootSystem(['D',4,1]).weight_lattice(extended=true).fundamental_weights()\n+sage: v = IntegrableRepresentation(Lambda[2])\n+sage: v.cartan_type().dynkin_diagram()\n+    O 4\n+    |\n+    |\n+O---O---O\n+1   |2  3\n+    |\n+    O 0\n+D4~\n+sage: A1xA1xA1xA1 = WeylCharacterRing(\"A1xA1xA1xA1\",style=\"coroots\")\n+sage: v.branch(i=2,weyl_character_ring=A1xA1xA1xA1)\n+[A1xA1xA1xA1(0,0,0,0),\n+ A1xA1xA1xA1(1,1,1,1),\n+ A1xA1xA1xA1(0,0,0,0) + A1xA1xA1xA1(2,0,0,0) + A1xA1xA1xA1(2,2,0,0) + A1xA1xA1xA1(2,0,2,0) + A1xA1xA1xA1(2,0,0,2) + A1xA1xA1xA1(0,2,0,0) + A1xA1xA1xA1(0,2,2,0) + A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,0,2,0) + A1x\\\n+A1xA1xA1(0,0,2,2) + A1xA1xA1xA1(0,0,0,2),\n+ 7*A1xA1xA1xA1(1,1,1,1) + A1xA1xA1xA1(1,1,1,3) + A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(3,1,1,1),\n+ 7*A1xA1xA1xA1(0,0,0,0) + 5*A1xA1xA1xA1(2,0,0,0) + 4*A1xA1xA1xA1(2,2,0,0) + 3*A1xA1xA1xA1(2,2,2,0) + A1xA1xA1xA1(2,2,2,2) + 3*A1xA1xA1xA1(2,2,0,2) + 4*A1xA1xA1xA1(2,0,2,0) + 3*A1xA1xA1xA1(2,0,2,2) + 4*A1xA1xA1xA\\\n+1(2,0,0,2) + A1xA1xA1xA1(4,0,0,0) + 5*A1xA1xA1xA1(0,2,0,0) + 4*A1xA1xA1xA1(0,2,2,0) + 3*A1xA1xA1xA1(0,2,2,2) + 4*A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,4,0,0) + 5*A1xA1xA1xA1(0,0,2,0) + 4*A1xA1xA1xA1(0,0,2,2) + A1\\\n+xA1xA1xA1(0,0,4,0) + 5*A1xA1xA1xA1(0,0,0,2) + A1xA1xA1xA1(0,0,0,4),\n+ 30*A1xA1xA1xA1(1,1,1,1) + 8*A1xA1xA1xA1(1,1,1,3) + 8*A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,1,3,3) + 8*A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(1,3,1,3) + A1xA1xA1xA1(1,3,3,1) + 8*A1xA1xA1xA1(3,1,1,1) + A1xA1xA1xA1(3,1\\\n+,1,3) + A1xA1xA1xA1(3,1,3,1) + A1xA1xA1xA1(3,3,1,1)]\n+\\`\\`\\`\n+\n+\n \n \n Author: bump\n```\n",
    "created_at": "2015-04-28T18:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214510",
    "user": "https://github.com/tscrim"
}
```

Description changed:
```diff
--- 
+++ 
@@ -1,3 +1,48 @@
+Integrable representations of Kac-Moody Lie algebras are parametrized by dominant weights. They satisfy a character formula which is a straightforward generalization of the Weyl character formula. See Kac, Infinite-dimensional Lie algebras, Chapter 10. The weight multiplicities may be computed using the Freudenthal multiplicity formula, and Kass, Moody, Patera and Slansky (KMPS) in their book Affine Lie algebras, weight multiplicities, modular characteristics and branching rules (1990) gave tables of these for affine Lie algebras. We may duplicate their tables of modular characteristics, weight multiplicities and branching rules using Sage.
+
+This patch creates a class for integrable representations of untwisted affine Lie algebras.
+
+\`\`\`
+sage: Lambda = RootSystem(['A',3,1]).weight_lattice(extended=true).fundamental_weights()
+sage: IntegrableRepresentation(Lambda[1]+Lambda[2]+Lambda[3]).print_strings()
+3*Lambda[2] - delta: 3 21 107 450 1638 5367 16194 45687 121876 310056 757056 1783324
+2*Lambda[0] + Lambda[2]: 4 31 161 665 2380 7658 22721 63120 166085 417295 1007601 2349655
+Lambda[1] + Lambda[2] + Lambda[3]: 1 10 60 274 1056 3601 11199 32354 88009 227555 563390 1343178
+Lambda[0] + 2*Lambda[3]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+Lambda[0] + 2*Lambda[1]: 2 18 99 430 1593 5274 16005 45324 121200 308829 754884 1779570
+\`\`\`
+
+This creates the representation of \`A_3^{(1)}\` with highest weight \`Lambda[1]+Lambda[2]+Lambda[3]\`. It then computes the five dominant maximal weights and the corresponding weight strings. Every weight multiplicity occurs in one of these strings, and by results of Kac and Peterson, they are the Fourier coefficients of modular forms. The code is reasonably fast and I've tested it up to rank 8, comparing the output with the tables of KMPS.
+
+Only untwisted affine Cartan types are implemented in this patch. A number of other methods such as the modular characteristic are available as methods of the class. We can do the branching rules as follows:
+
+\`\`\`
+sage: Lambda = RootSystem(['D',4,1]).weight_lattice(extended=true).fundamental_weights()
+sage: v = IntegrableRepresentation(Lambda[2])
+sage: v.cartan_type().dynkin_diagram()
+    O 4
+    |
+    |
+O---O---O
+1   |2  3
+    |
+    O 0
+D4~
+sage: A1xA1xA1xA1 = WeylCharacterRing("A1xA1xA1xA1",style="coroots")
+sage: v.branch(i=2,weyl_character_ring=A1xA1xA1xA1)
+[A1xA1xA1xA1(0,0,0,0),
+ A1xA1xA1xA1(1,1,1,1),
+ A1xA1xA1xA1(0,0,0,0) + A1xA1xA1xA1(2,0,0,0) + A1xA1xA1xA1(2,2,0,0) + A1xA1xA1xA1(2,0,2,0) + A1xA1xA1xA1(2,0,0,2) + A1xA1xA1xA1(0,2,0,0) + A1xA1xA1xA1(0,2,2,0) + A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,0,2,0) + A1x\
+A1xA1xA1(0,0,2,2) + A1xA1xA1xA1(0,0,0,2),
+ 7*A1xA1xA1xA1(1,1,1,1) + A1xA1xA1xA1(1,1,1,3) + A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(3,1,1,1),
+ 7*A1xA1xA1xA1(0,0,0,0) + 5*A1xA1xA1xA1(2,0,0,0) + 4*A1xA1xA1xA1(2,2,0,0) + 3*A1xA1xA1xA1(2,2,2,0) + A1xA1xA1xA1(2,2,2,2) + 3*A1xA1xA1xA1(2,2,0,2) + 4*A1xA1xA1xA1(2,0,2,0) + 3*A1xA1xA1xA1(2,0,2,2) + 4*A1xA1xA1xA\
+1(2,0,0,2) + A1xA1xA1xA1(4,0,0,0) + 5*A1xA1xA1xA1(0,2,0,0) + 4*A1xA1xA1xA1(0,2,2,0) + 3*A1xA1xA1xA1(0,2,2,2) + 4*A1xA1xA1xA1(0,2,0,2) + A1xA1xA1xA1(0,4,0,0) + 5*A1xA1xA1xA1(0,0,2,0) + 4*A1xA1xA1xA1(0,0,2,2) + A1\
+xA1xA1xA1(0,0,4,0) + 5*A1xA1xA1xA1(0,0,0,2) + A1xA1xA1xA1(0,0,0,4),
+ 30*A1xA1xA1xA1(1,1,1,1) + 8*A1xA1xA1xA1(1,1,1,3) + 8*A1xA1xA1xA1(1,1,3,1) + A1xA1xA1xA1(1,1,3,3) + 8*A1xA1xA1xA1(1,3,1,1) + A1xA1xA1xA1(1,3,1,3) + A1xA1xA1xA1(1,3,3,1) + 8*A1xA1xA1xA1(3,1,1,1) + A1xA1xA1xA1(3,1\
+,1,3) + A1xA1xA1xA1(3,1,3,1) + A1xA1xA1xA1(3,3,1,1)]
+\`\`\`
+
+
 
 
 Author: bump
```




---

archive/issue_comments_214511.json:
```json
{
    "body": "<a id='comment:68'></a>I tried the hash trick, and it seemed slower.\n\nSo I have no more changes I want to make at this time.",
    "created_at": "2015-04-28T20:08:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214511",
    "user": "https://github.com/dwbump"
}
```

<a id='comment:68'></a>I tried the hash trick, and it seemed slower.

So I have no more changes I want to make at this time.



---

archive/issue_comments_214512.json:
```json
{
    "body": "<a id='comment:69'></a>Then let's get this into Sage.",
    "created_at": "2015-04-28T20:38:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214512",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:69'></a>Then let's get this into Sage.



---

archive/issue_comments_214513.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-04-28T20:38:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214513",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_046486.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-04-29T03:13:47Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15806#event-46486"
}
```



---

archive/issue_comments_214514.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-04-29T03:13:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214514",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_comments_214515.json:
```json
{
    "body": "<a id='comment:72'></a>In #20686, I will mark `TestSuite(V).run()` as `# known bug` because `IntegrableRepresentation` does not properly implement everything needed for its category. For example, it does not implement `zero()`.\n\nThese problems were not seen before simply because the category tests were not run. #20686 ensures that the correct tests are run, but then they fail for `IntegrableRepresentation`.",
    "created_at": "2016-09-01T08:42:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214515",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:72'></a>In #20686, I will mark `TestSuite(V).run()` as `# known bug` because `IntegrableRepresentation` does not properly implement everything needed for its category. For example, it does not implement `zero()`.

These problems were not seen before simply because the category tests were not run. #20686 ensures that the correct tests are run, but then they fail for `IntegrableRepresentation`.



---

archive/issue_comments_214516.json:
```json
{
    "body": "<a id='comment:73'></a>See #21387.",
    "created_at": "2016-09-01T08:51:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15806",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15806#issuecomment-214516",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:73'></a>See #21387.
