# Issue 15223: Let the `TestSuite` test that the construction of a parent returns the parent

archive/issues_014986.json:
```json
{
    "body": "CC:  @novoselt @nthiery combinat @tscrim @fchapoton @mwageringel @kwankyu @dkrenn\n\nKeywords: construction functor, test suite, sd53\n\nAndrey told me about the following problem. When he implemented toric lattices, he inherited a `.construction()` method from general lattices. Consequence: If he tried to add elements of two different toric lattices, then Sage applied a pushout construction and added the two elements after pushing them to `ZZ^2`, which was not what he wanted.\n\nHis solution was, I think, the correct one: He overloaded the `.construction()` method, so that it now returns `None`.\n\nUpdate: A similar problem also showed up in #30360.\n\nSuggestion: Introduce a test of the `TestSuite` of a parent P, that will complain if P.construction() returns a pair `F, O` such that `F(O)!=P`.\n\nI think this test should be put into ~~`sage.structure.parent.Parent`~~ (Update 9.2: `sage.categories.sets_cat`), because this is where `.construction()` is defined in the first place.\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/15223\n\n",
    "closed_at": "2020-09-27T09:09:57Z",
    "created_at": "2013-09-24T13:47:16Z",
    "labels": [
        "component: coercion",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.2",
    "title": "Let the `TestSuite` test that the construction of a parent returns the parent",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15223",
    "user": "https://github.com/simon-king-jena"
}
```
CC:  @novoselt @nthiery combinat @tscrim @fchapoton @mwageringel @kwankyu @dkrenn

Keywords: construction functor, test suite, sd53

Andrey told me about the following problem. When he implemented toric lattices, he inherited a `.construction()` method from general lattices. Consequence: If he tried to add elements of two different toric lattices, then Sage applied a pushout construction and added the two elements after pushing them to `ZZ^2`, which was not what he wanted.

His solution was, I think, the correct one: He overloaded the `.construction()` method, so that it now returns `None`.

Update: A similar problem also showed up in #30360.

Suggestion: Introduce a test of the `TestSuite` of a parent P, that will complain if P.construction() returns a pair `F, O` such that `F(O)!=P`.

I think this test should be put into ~~`sage.structure.parent.Parent`~~ (Update 9.2: `sage.categories.sets_cat`), because this is where `.construction()` is defined in the first place.



Issue created by migration from https://trac.sagemath.org/ticket/15223





---

archive/issue_comments_191120.json:
```json
{
    "body": "I did not run the full test suite yet, but I already detected several bugs in `.construction()`. So, introducing this test really is a good idea.\n\nUntil now, I found:\n\n1. Boolean polynomial rings:\n   {{{\nsage: P.<x0, x1, x2, x3> = BooleanPolynomialRing(4,order='degrevlex(2),degrevlex(2)')\nsage: P.construction()\n(MPoly[x0,x1,x2,x3], Finite Field of size 2)\nsage: F, O = P.construction()\nsage: F(O)\nMultivariate Polynomial Ring in x0, x1, x2, x3 over Finite Field of size 2\nsage: P\nBoolean PolynomialRing in x0, x1, x2, x3\n   }}}\n   Suggested solution: A boolean polynomial ring is, after all, a quotient of a polynomial ring. So, it should be constructed as such, but the `QuotientFunctor` should be provided with an additional attribute making it notice that a boolean polynomial ring shall be returned.\n\n2. Integer mod rings that are initialised in a non-default category:\n   {{{\nsage: P = IntegerModRing(19, category = Fields())\nsage: F,O = P.construction()\nsage: F(O)\nRing of integers modulo 19\nsage: P\nRing of integers modulo 19\nsage: F(O) == P\nFalse\n   }}}\n   Why is this? Well, providing a different category changes the class of P (this is how the category framework works), and the `__cmp__` method of integer mod rings checks for the class. And the construction functor `F` is not aware of the category of `P`.\n\n   Suggested solutions: Change `__cmp__` such that `F(O)` evaluates equal to `P`, even though `F(O)` is not in the category of fields, or alternatively make the construction functor aware of the category, so that `F(O)` actually *is* in the category of fields.",
    "created_at": "2013-09-24T16:54:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191120",
    "user": "https://github.com/simon-king-jena"
}
```

I did not run the full test suite yet, but I already detected several bugs in `.construction()`. So, introducing this test really is a good idea.

Until now, I found:

1. Boolean polynomial rings:
   {{{
sage: P.<x0, x1, x2, x3> = BooleanPolynomialRing(4,order='degrevlex(2),degrevlex(2)')
sage: P.construction()
(MPoly[x0,x1,x2,x3], Finite Field of size 2)
sage: F, O = P.construction()
sage: F(O)
Multivariate Polynomial Ring in x0, x1, x2, x3 over Finite Field of size 2
sage: P
Boolean PolynomialRing in x0, x1, x2, x3
   }}}
   Suggested solution: A boolean polynomial ring is, after all, a quotient of a polynomial ring. So, it should be constructed as such, but the `QuotientFunctor` should be provided with an additional attribute making it notice that a boolean polynomial ring shall be returned.

2. Integer mod rings that are initialised in a non-default category:
   {{{
sage: P = IntegerModRing(19, category = Fields())
sage: F,O = P.construction()
sage: F(O)
Ring of integers modulo 19
sage: P
Ring of integers modulo 19
sage: F(O) == P
False
   }}}
   Why is this? Well, providing a different category changes the class of P (this is how the category framework works), and the `__cmp__` method of integer mod rings checks for the class. And the construction functor `F` is not aware of the category of `P`.

   Suggested solutions: Change `__cmp__` such that `F(O)` evaluates equal to `P`, even though `F(O)` is not in the category of fields, or alternatively make the construction functor aware of the category, so that `F(O)` actually *is* in the category of fields.



---

archive/issue_comments_191121.json:
```json
{
    "body": "And I am to blame for a third problem, that is actually fairly similar to the second problem mentioned above. It is in my thematic tutorial on categories and coercion.\n\n- I create a parent class inheriting from `UniqueRepresentation`.\n- The parent class has a construction functor that keeps track of the \"important\" arguments needed to reconstruct the parent.\n- I create one instance P of the parent class using an additional \"unimportant\" argument, namely a category.\n\nConsequence: When trying to reconstruct P using the construction functor, the \"unimportant\" argument is missing, and hence `UniqueRepresentation` believes that a new instance needs to be created. After all, for `UniqueRepresentation`, *all* arguments are important parts of the cache key.\n\nI have to think how to solve this.",
    "created_at": "2013-09-24T18:32:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191121",
    "user": "https://github.com/simon-king-jena"
}
```

And I am to blame for a third problem, that is actually fairly similar to the second problem mentioned above. It is in my thematic tutorial on categories and coercion.

- I create a parent class inheriting from `UniqueRepresentation`.
- The parent class has a construction functor that keeps track of the "important" arguments needed to reconstruct the parent.
- I create one instance P of the parent class using an additional "unimportant" argument, namely a category.

Consequence: When trying to reconstruct P using the construction functor, the "unimportant" argument is missing, and hence `UniqueRepresentation` believes that a new instance needs to be created. After all, for `UniqueRepresentation`, *all* arguments are important parts of the cache key.

I have to think how to solve this.



---

archive/issue_comments_191122.json:
```json
{
    "body": "Is it really needed that `BooleanPolynomialRing` has a `.construction()`? Granted, one could describe it as the quotient of a polynomial ring over GF(2). However, you could actually not take an arbitrary ring R and create a boolean polynomial ring over R---the base ring will always be GF(2).\n\nAnyway, using the construction functor for multivariate polynomial rings is plain wrong. We have two options:\n\n1. Let the construction be None\n2. Create a new construction functor for boolean polynomial rings, either similar to the multivariate polynomial ring functor, or similar to the quotient functor.\n\nIf we go for None, then we would have problems to do fancy constructions starting with a boolean polynomial ring: There would be no pushout constructions. I wonder if we *need* pushout constructions.\n\nIf we go for a new construction functor, I'd suggest to modify quotient functors. After all, it is a quotient in a particular implementation.\n\nAnd looking at the second problem, it seems to be a general problem with quotient functors: Sometimes we want to add more information on a quotient, such as \"the quotient shall belong to the category of fields\" or, \"the quotient shall be implemented as a boolean polynomial ring\". So, we should invent a general scheme to load the quotient functor with this additional information.",
    "created_at": "2013-09-24T21:24:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191122",
    "user": "https://github.com/simon-king-jena"
}
```

Is it really needed that `BooleanPolynomialRing` has a `.construction()`? Granted, one could describe it as the quotient of a polynomial ring over GF(2). However, you could actually not take an arbitrary ring R and create a boolean polynomial ring over R---the base ring will always be GF(2).

Anyway, using the construction functor for multivariate polynomial rings is plain wrong. We have two options:

1. Let the construction be None
2. Create a new construction functor for boolean polynomial rings, either similar to the multivariate polynomial ring functor, or similar to the quotient functor.

If we go for None, then we would have problems to do fancy constructions starting with a boolean polynomial ring: There would be no pushout constructions. I wonder if we *need* pushout constructions.

If we go for a new construction functor, I'd suggest to modify quotient functors. After all, it is a quotient in a particular implementation.

And looking at the second problem, it seems to be a general problem with quotient functors: Sometimes we want to add more information on a quotient, such as "the quotient shall belong to the category of fields" or, "the quotient shall be implemented as a boolean polynomial ring". So, we should invent a general scheme to load the quotient functor with this additional information.



---

archive/issue_comments_191123.json:
```json
{
    "body": "By the way, the branch that I uploaded fixes all doctests, except for the three issues described in the previous posts (boolean polynomial rings, quotients that are pushed into a sub-category of the default, and the stuff that I wrote in the thematic tutorial).",
    "created_at": "2013-09-24T21:26:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191123",
    "user": "https://github.com/simon-king-jena"
}
```

By the way, the branch that I uploaded fixes all doctests, except for the three issues described in the previous posts (boolean polynomial rings, quotients that are pushed into a sub-category of the default, and the stuff that I wrote in the thematic tutorial).



---

archive/issue_comments_191124.json:
```json
{
    "body": "The quotient functors (`sage.categories.pushout.QuotientFunctor`) eventually call the `.quo()` method when they are called. They actually do make a special case for fields that are constructed as a quotient.\n\nI think it would be possible to store further arguments in an attribute, say, `_further_arguments`, which should be a dictionary, and then do\n\n```\n   Q = R.quo(I, names=self.names, **self._further_arguments)\n```\nThen, one should also make the `.quo()` method accept these additional arguments.",
    "created_at": "2013-09-24T21:46:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191124",
    "user": "https://github.com/simon-king-jena"
}
```

The quotient functors (`sage.categories.pushout.QuotientFunctor`) eventually call the `.quo()` method when they are called. They actually do make a special case for fields that are constructed as a quotient.

I think it would be possible to store further arguments in an attribute, say, `_further_arguments`, which should be a dictionary, and then do

```
   Q = R.quo(I, names=self.names, **self._further_arguments)
```
Then, one should also make the `.quo()` method accept these additional arguments.



---

archive/issue_comments_191125.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-09-24T22:10:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191125",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191126.json:
```json
{
    "body": "In the current commit, I fix the example in the thematic tutorial by making the construction functor aware of the additional arguments that were originally used to construct the parent.\n\nIt works, and I think a similar idea would work for quotient functors.",
    "created_at": "2013-09-24T22:13:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191126",
    "user": "https://github.com/simon-king-jena"
}
```

In the current commit, I fix the example in the thematic tutorial by making the construction functor aware of the additional arguments that were originally used to construct the parent.

It works, and I think a similar idea would work for quotient functors.



---

archive/issue_comments_191127.json:
```json
{
    "body": "I just added Nicolas to this ticket, since it relates not only with coercion (this is the component of this ticket) but also with categories.\n\nIn a nutshell: If P is a parent, then `P.construction()` should return None, or a pair F,O, where F is a construction functor and O is some object.\n\nThe contract is that `F(O)==P`. But nobody has checked this contract so far. The original aim of this ticket is to introduce a test.\n\nWhile we are at it, I thought one could improve `QuotientFunctor`. First of all, it *must* allow to pass additional arguments to the quotient being constructed. For example, the construction functor for `IntegerModRing(19, category=Fields())` must know that the category is specialised. Similarly, the construction functor for `BooleanPolynomialRing(...)` must know that the result is not just a quotient of a polynomial ring, but has a special implementation.\n\nAnd something else that I want to improve with the `QuotientFunctor`: Currently, it is a functor from Rings() to Rings(). But why?? Perhaps, at some point, we want to apply the `QuotientFunctor` in the context of groups!\n\nHence, I think it would make sense to be more precise when choosing the domain and codomain of the functor.\n\nToday, I experimented with this idea: If Q is a quotient, and `F,O=Q.construction()`, then the quotient functor F should go from `O.category()` to `Q.category()`.\n\nBut when running the tests, it turns out that this is too narrow: Sometimes, we want to apply the quotient functor F to a ring over a *different* base ring.\n\nThis makes me think of the following: Would it make sense to introduce a method of categories `C.without_parameters()`, returning the join of all super-categories of C that are not instances of `CategoryWithParameters`?\n\nFor example, for `C = Category.join([EnumeratedSets(),Algebras(QQ)])`, `C.without_parameters()` would return `Join of Category of rings and Category of enumerated sets`.\n\nNicolas, do you think it would hurt to introduce such method here?",
    "created_at": "2013-09-25T16:37:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191127",
    "user": "https://github.com/simon-king-jena"
}
```

I just added Nicolas to this ticket, since it relates not only with coercion (this is the component of this ticket) but also with categories.

In a nutshell: If P is a parent, then `P.construction()` should return None, or a pair F,O, where F is a construction functor and O is some object.

The contract is that `F(O)==P`. But nobody has checked this contract so far. The original aim of this ticket is to introduce a test.

While we are at it, I thought one could improve `QuotientFunctor`. First of all, it *must* allow to pass additional arguments to the quotient being constructed. For example, the construction functor for `IntegerModRing(19, category=Fields())` must know that the category is specialised. Similarly, the construction functor for `BooleanPolynomialRing(...)` must know that the result is not just a quotient of a polynomial ring, but has a special implementation.

And something else that I want to improve with the `QuotientFunctor`: Currently, it is a functor from Rings() to Rings(). But why?? Perhaps, at some point, we want to apply the `QuotientFunctor` in the context of groups!

Hence, I think it would make sense to be more precise when choosing the domain and codomain of the functor.

Today, I experimented with this idea: If Q is a quotient, and `F,O=Q.construction()`, then the quotient functor F should go from `O.category()` to `Q.category()`.

But when running the tests, it turns out that this is too narrow: Sometimes, we want to apply the quotient functor F to a ring over a *different* base ring.

This makes me think of the following: Would it make sense to introduce a method of categories `C.without_parameters()`, returning the join of all super-categories of C that are not instances of `CategoryWithParameters`?

For example, for `C = Category.join([EnumeratedSets(),Algebras(QQ)])`, `C.without_parameters()` would return `Join of Category of rings and Category of enumerated sets`.

Nicolas, do you think it would hurt to introduce such method here?



---

archive/issue_comments_191128.json:
```json
{
    "body": "Replying to [comment:10 SimonKing]:\n\n> While we are at it, I thought one could improve `QuotientFunctor`. First of all, it *must* allow to pass additional arguments to the quotient being constructed. For example, the construction functor for `IntegerModRing(19, category=Fields())` must know that the category is specialised.\n\n\nIsn't that going to be a problem?\n\n```\nsage: A=IntegerModRing(19, category=Fields())\nsage: B=IntegerModRing(19)\nsage: B in Fields()\nTrue\n```\nAfter this isn't the category of `B` refined to fields? And doesn't that then mean that A and B are the same, and hence should be identical? But if UniqueRepresentation takes the category argument into account, they won't be identical.",
    "created_at": "2013-09-25T18:25:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191128",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:10 SimonKing]:

> While we are at it, I thought one could improve `QuotientFunctor`. First of all, it *must* allow to pass additional arguments to the quotient being constructed. For example, the construction functor for `IntegerModRing(19, category=Fields())` must know that the category is specialised.


Isn't that going to be a problem?

```
sage: A=IntegerModRing(19, category=Fields())
sage: B=IntegerModRing(19)
sage: B in Fields()
True
```
After this isn't the category of `B` refined to fields? And doesn't that then mean that A and B are the same, and hence should be identical? But if UniqueRepresentation takes the category argument into account, they won't be identical.



---

archive/issue_comments_191129.json:
```json
{
    "body": "Replying to [comment:10 SimonKing]:\n> I just added Nicolas to this ticket, since it relates not only with coercion (this is the component of this ticket) but also with categories.\n> \n> In a nutshell: If P is a parent, then `P.construction()` should return None, or a pair F,O, where F is a construction functor and O is some object.\n> \n> The contract is that `F(O)==P`. But nobody has checked this contract so far. The original aim of this ticket is to introduce a test.\n\n\nThis sounds like a good idea indeed! I would tend to put the test in\nSets (in the general trend that there is already too much stuff in\nParent; and maybe construction should be moved there, so as to make it\neasier to overload it, e.g. in some categories).\n\nIt would make sense as well for the test to accept the case where\n`construction` is an undefined abstract method. But maybe we don't\nhave a use case for now.\n\n> While we are at it, I thought one could improve `QuotientFunctor`. First of all, it *must* allow to pass additional arguments to the quotient being constructed. For example, the construction functor for `IntegerModRing(19, category=Fields())` must know that the category is specialised. Similarly, the construction functor for `BooleanPolynomialRing(...)` must know that the result is not just a quotient of a polynomial ring, but has a special implementation.\n> \n> And something else that I want to improve with the `QuotientFunctor`: Currently, it is a functor from Rings() to Rings(). But why?? Perhaps, at some point, we want to apply the `QuotientFunctor` in the context of groups!\n> \n> Hence, I think it would make sense to be more precise when choosing the domain and codomain of the functor.\n> \n> Today, I experimented with this idea: If Q is a quotient, and `F,O=Q.construction()`, then the quotient functor F should go from `O.category()` to `Q.category()`.\n> \n> But when running the tests, it turns out that this is too narrow: Sometimes, we want to apply the quotient functor F to a ring over a *different* base ring.\n\n\nThis does not seem directly related to this ticket. Could this easily\nbe split off into a separate ticket?\n\n> This makes me think of the following: Would it make sense to introduce a method of categories `C.without_parameters()`, returning the join of all super-categories of C that are not instances of `CategoryWithParameters`?\n> \n> For example, for `C = Category.join([EnumeratedSets(),Algebras(QQ)])`, `C.without_parameters()` would return `Join of Category of rings and Category of enumerated sets`.\n> \n> Nicolas, do you think it would hurt to introduce such method here?\n\n\nThis seems like a sensible method; so if you have a use for it, go\nahead.\n\nCheers,\n                             Nicolas",
    "created_at": "2013-09-25T19:15:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191129",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:10 SimonKing]:
> I just added Nicolas to this ticket, since it relates not only with coercion (this is the component of this ticket) but also with categories.
> 
> In a nutshell: If P is a parent, then `P.construction()` should return None, or a pair F,O, where F is a construction functor and O is some object.
> 
> The contract is that `F(O)==P`. But nobody has checked this contract so far. The original aim of this ticket is to introduce a test.


This sounds like a good idea indeed! I would tend to put the test in
Sets (in the general trend that there is already too much stuff in
Parent; and maybe construction should be moved there, so as to make it
easier to overload it, e.g. in some categories).

It would make sense as well for the test to accept the case where
`construction` is an undefined abstract method. But maybe we don't
have a use case for now.

> While we are at it, I thought one could improve `QuotientFunctor`. First of all, it *must* allow to pass additional arguments to the quotient being constructed. For example, the construction functor for `IntegerModRing(19, category=Fields())` must know that the category is specialised. Similarly, the construction functor for `BooleanPolynomialRing(...)` must know that the result is not just a quotient of a polynomial ring, but has a special implementation.
> 
> And something else that I want to improve with the `QuotientFunctor`: Currently, it is a functor from Rings() to Rings(). But why?? Perhaps, at some point, we want to apply the `QuotientFunctor` in the context of groups!
> 
> Hence, I think it would make sense to be more precise when choosing the domain and codomain of the functor.
> 
> Today, I experimented with this idea: If Q is a quotient, and `F,O=Q.construction()`, then the quotient functor F should go from `O.category()` to `Q.category()`.
> 
> But when running the tests, it turns out that this is too narrow: Sometimes, we want to apply the quotient functor F to a ring over a *different* base ring.


This does not seem directly related to this ticket. Could this easily
be split off into a separate ticket?

> This makes me think of the following: Would it make sense to introduce a method of categories `C.without_parameters()`, returning the join of all super-categories of C that are not instances of `CategoryWithParameters`?
> 
> For example, for `C = Category.join([EnumeratedSets(),Algebras(QQ)])`, `C.without_parameters()` would return `Join of Category of rings and Category of enumerated sets`.
> 
> Nicolas, do you think it would hurt to introduce such method here?


This seems like a sensible method; so if you have a use for it, go
ahead.

Cheers,
                             Nicolas



---

archive/issue_comments_191130.json:
```json
{
    "body": "Replying to [comment:11 nbruin]:\n> Isn't that going to be a problem?\n> \n> ```\n> sage: A=IntegerModRing(19, category=Fields())\n> sage: B=IntegerModRing(19)\n> sage: B in Fields()\n> True\n> ```\n> After this isn't the category of `B` refined to fields?\n\n\nIt is:\n\n```\nsage: A = IntegerModRing(19)\nsage: B = IntegerModRing(19,category=Fields())\nsage: A==B\nFalse\nsage: issubclass(type(A), Fields().parent_class)\nFalse\nsage: A in Fields()\nTrue\nsage: issubclass(type(A), Fields().parent_class)\nTrue\n```\n\n> And doesn't that then mean that A and B are the same,\n\n\nNo, it doesn't (to my surprise, I actually thought they *should* be recognised as equal now):\n\n```\nsage: A==B\nFalse\nsage: type(A)==type(B)\nFalse\nsage: A.category() == B.category()\nFalse\nsage: A.category()\nJoin of Category of fields and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets\nsage: B.category()\nJoin of Category of fields and Category of subquotients of monoids and Category of quotients of semigroups\n```\n\n> and hence should be identical? But if UniqueRepresentation takes the category argument into account, they won't be identical.\n\n\nNo, it is not UniqueRepresentation:\n\n```\nsage: isinstance(A,UniqueRepresentation)\nFalse\n```",
    "created_at": "2013-09-25T20:23:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191130",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:11 nbruin]:
> Isn't that going to be a problem?
> 
> ```
> sage: A=IntegerModRing(19, category=Fields())
> sage: B=IntegerModRing(19)
> sage: B in Fields()
> True
> ```
> After this isn't the category of `B` refined to fields?


It is:

```
sage: A = IntegerModRing(19)
sage: B = IntegerModRing(19,category=Fields())
sage: A==B
False
sage: issubclass(type(A), Fields().parent_class)
False
sage: A in Fields()
True
sage: issubclass(type(A), Fields().parent_class)
True
```

> And doesn't that then mean that A and B are the same,


No, it doesn't (to my surprise, I actually thought they *should* be recognised as equal now):

```
sage: A==B
False
sage: type(A)==type(B)
False
sage: A.category() == B.category()
False
sage: A.category()
Join of Category of fields and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets
sage: B.category()
Join of Category of fields and Category of subquotients of monoids and Category of quotients of semigroups
```

> and hence should be identical? But if UniqueRepresentation takes the category argument into account, they won't be identical.


No, it is not UniqueRepresentation:

```
sage: isinstance(A,UniqueRepresentation)
False
```



---

archive/issue_comments_191131.json:
```json
{
    "body": "Replying to [comment:12 nthiery]:\n> This sounds like a good idea indeed! I would tend to put the test in\n> Sets (in the general trend that there is already too much stuff in\n> Parent; and maybe construction should be moved there, so as to make it\n> easier to overload it, e.g. in some categories).\n\n\nI am not so sure about this. `.construction()` is one of the places where mathematics and implementation meet: On the one hand, `.construction()` returns a functor (or at least something that pretends to be a functor), which is a mathematical notion. On the other hand, the construction functors are quite clearly *also* responsible for choosing implementations. For example, the fact that the following pushout uses *dense* power series rings is entirely due to construction functors:\n\n```\nsage: Ps.<x> = PowerSeriesRing(QQ, sparse=True)\nsage: Pd.<x> = PowerSeriesRing(ZZ, sparse=False)\nsage: Pd['y'].has_coerce_map_from(Ps['y'])\nFalse\nsage: pushout(Ps['y'],Pd['y'])\nUnivariate Polynomial Ring in y over Power Series Ring in x over Rational Field\nsage: pushout(Ps['y'],Pd['y']) == Ps['y']\nFalse\n```\n\nBut if it is (partially) about implementation, then I believe its place is not in `Sets.ParentMethods`.\n\n> > But when running the tests, it turns out that this is too narrow: Sometimes, we want to apply the quotient functor F to a ring over a *different* base ring.\n\n> \n> This does not seem directly related to this ticket. Could this easily\n> be split off into a separate ticket?\n\n\nProbably better. I am actually not sure if it would be a good idea to modify the quotient functor in that way.\n\n> > Nicolas, do you think it would hurt to introduce such method here?\n\n> \n> This seems like a sensible method; so if you have a use for it, go\n> ahead.\n\n\nNot sure yet.",
    "created_at": "2013-09-25T20:37:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191131",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:12 nthiery]:
> This sounds like a good idea indeed! I would tend to put the test in
> Sets (in the general trend that there is already too much stuff in
> Parent; and maybe construction should be moved there, so as to make it
> easier to overload it, e.g. in some categories).


I am not so sure about this. `.construction()` is one of the places where mathematics and implementation meet: On the one hand, `.construction()` returns a functor (or at least something that pretends to be a functor), which is a mathematical notion. On the other hand, the construction functors are quite clearly *also* responsible for choosing implementations. For example, the fact that the following pushout uses *dense* power series rings is entirely due to construction functors:

```
sage: Ps.<x> = PowerSeriesRing(QQ, sparse=True)
sage: Pd.<x> = PowerSeriesRing(ZZ, sparse=False)
sage: Pd['y'].has_coerce_map_from(Ps['y'])
False
sage: pushout(Ps['y'],Pd['y'])
Univariate Polynomial Ring in y over Power Series Ring in x over Rational Field
sage: pushout(Ps['y'],Pd['y']) == Ps['y']
False
```

But if it is (partially) about implementation, then I believe its place is not in `Sets.ParentMethods`.

> > But when running the tests, it turns out that this is too narrow: Sometimes, we want to apply the quotient functor F to a ring over a *different* base ring.

> 
> This does not seem directly related to this ticket. Could this easily
> be split off into a separate ticket?


Probably better. I am actually not sure if it would be a good idea to modify the quotient functor in that way.

> > Nicolas, do you think it would hurt to introduce such method here?

> 
> This seems like a sensible method; so if you have a use for it, go
> ahead.


Not sure yet.



---

archive/issue_comments_191132.json:
```json
{
    "body": "And now I realise that I use git, and I have no idea how to pick some part of the changeset of my last commit, and move it to a different branch.",
    "created_at": "2013-09-25T20:44:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191132",
    "user": "https://github.com/simon-king-jena"
}
```

And now I realise that I use git, and I have no idea how to pick some part of the changeset of my last commit, and move it to a different branch.



---

archive/issue_comments_191133.json:
```json
{
    "body": "Hi Simon,\n\nI am not sure how to just take a part of your last commit, but you can do the following:\nWhile you're on your current development branch, write git branch new_branch to start a new branch pointing to the current commit.\nThen go back to the old branch via git checkout old_branch and either delete manually the changes you don't want to to have on that branch or go back to a previous commit via\ngit reset --hard first_few_digits_of_sha_to_revert_to\nYou can then recommit some of the changes or just start working from there again.\n\nThis probably doesn't do exactly what you want, but it might be a start.",
    "created_at": "2013-09-25T21:11:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191133",
    "user": "https://trac.sagemath.org/admin/accounts/users/jkeitel"
}
```

Hi Simon,

I am not sure how to just take a part of your last commit, but you can do the following:
While you're on your current development branch, write git branch new_branch to start a new branch pointing to the current commit.
Then go back to the old branch via git checkout old_branch and either delete manually the changes you don't want to to have on that branch or go back to a previous commit via
git reset --hard first_few_digits_of_sha_to_revert_to
You can then recommit some of the changes or just start working from there again.

This probably doesn't do exactly what you want, but it might be a start.



---

archive/issue_comments_191134.json:
```json
{
    "body": "Replying to [comment:16 jkeitel]:\n> I am not sure how to just take a part of your last commit, but you can do the following:\n> While you're on your current development branch, write git branch new_branch to start a new branch pointing to the current commit.\n> Then go back to the old branch via git checkout old_branch and either delete manually the changes you don't want to to have on that branch or go back to a previous commit via\n> git reset --hard first_few_digits_of_sha_to_revert_to\n> You can then recommit some of the changes or just start working from there again.\n> \n> This probably doesn't do exactly what you want, but it might be a start.\n\n\nThank you!\n\nI had already started before your answer came. That's to say, I have stored `git diff HEAD~ HEAD` into a file `tmp.patch`, then manually reverted the changes that I didn't like, did `git add <changed_files>` and `git commit --amend`. And now, I should be able to create a branch for a different ticket, and apply the relevant changes stored in `tmp.patch`.\n\nSince I didn't push the \"wrong\" commit to trac (in particular, clearly no other branch on trac will use my wrong commit), I guess it is ok to do `git commit --amend`, although it changes SHA1.",
    "created_at": "2013-09-25T21:19:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191134",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:16 jkeitel]:
> I am not sure how to just take a part of your last commit, but you can do the following:
> While you're on your current development branch, write git branch new_branch to start a new branch pointing to the current commit.
> Then go back to the old branch via git checkout old_branch and either delete manually the changes you don't want to to have on that branch or go back to a previous commit via
> git reset --hard first_few_digits_of_sha_to_revert_to
> You can then recommit some of the changes or just start working from there again.
> 
> This probably doesn't do exactly what you want, but it might be a start.


Thank you!

I had already started before your answer came. That's to say, I have stored `git diff HEAD~ HEAD` into a file `tmp.patch`, then manually reverted the changes that I didn't like, did `git add <changed_files>` and `git commit --amend`. And now, I should be able to create a branch for a different ticket, and apply the relevant changes stored in `tmp.patch`.

Since I didn't push the "wrong" commit to trac (in particular, clearly no other branch on trac will use my wrong commit), I guess it is ok to do `git commit --amend`, although it changes SHA1.



---

archive/issue_comments_191135.json:
```json
{
    "body": "Replying to [comment:13 SimonKing]: \n> No, it is not UniqueRepresentation:\n> \n> ```\n> sage: isinstance(A,UniqueRepresentation)\n> False\n> ```\n\nThat doesn't tell the entire story, though:\n\n```\nsage: type(IntegerModRing).mro()\n[sage.rings.finite_rings.integer_mod_ring.IntegerModFactory,\n sage.structure.factory.UniqueFactory,\n sage.structure.sage_object.SageObject,\n object]\n```\nso perhaps the *object* isn't really UniqueRepresentation but the *system* tries to implement the semantics via a factory. So I think you're seeing exactly the problem I was afraid of:\n\n```\nsage: A1=IntegerModRing(19)\nsage: A2=IntegerModRing(19)\nsage: B1=IntegerModRing(19,category=Fields())\nsage: B2=IntegerModRing(19,category=Fields())\nsage: A1 is A2\nTrue\nsage: B1 is B2\nTrue\nsage: A1 in Fields()\nTrue\nsage: type(A1)\n<class 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic_with_category'>\nsage: type(B1)\n<class 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic_with_category'>\nsage: type(A1) == type(B1)\nFalse\n```\nso after this we do have two functionally equivalent copies of the same ring: `A1,B1`, but they are not identical. Furthermore, their types are not identical or equal either, but it's hard to see what the difference is between them (note `A1.__cmp__` to see that this last `False` is the reason why `A1 != B1`.\n\nAllowing categories to be refined on \"global\" (uniqueified) objects implies that the `category` argument needs to be ignored on lookup during the uniqueification. You can't really control the category anyway:\n\n```\nsage: A1=IntegerModRing(19,category=Rings())\nsage: A1.category()\nJoin of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups\nsage: A1 in Fields()\nTrue\nsage: A2=IntegerModRing(19,category=Rings())\nsage: A2.category()\nJoin of Category of subquotients of monoids and Category of quotients of semigroups and Category of fields\n```",
    "created_at": "2013-09-25T22:11:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191135",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:13 SimonKing]: 
> No, it is not UniqueRepresentation:
> 
> ```
> sage: isinstance(A,UniqueRepresentation)
> False
> ```

That doesn't tell the entire story, though:

```
sage: type(IntegerModRing).mro()
[sage.rings.finite_rings.integer_mod_ring.IntegerModFactory,
 sage.structure.factory.UniqueFactory,
 sage.structure.sage_object.SageObject,
 object]
```
so perhaps the *object* isn't really UniqueRepresentation but the *system* tries to implement the semantics via a factory. So I think you're seeing exactly the problem I was afraid of:

```
sage: A1=IntegerModRing(19)
sage: A2=IntegerModRing(19)
sage: B1=IntegerModRing(19,category=Fields())
sage: B2=IntegerModRing(19,category=Fields())
sage: A1 is A2
True
sage: B1 is B2
True
sage: A1 in Fields()
True
sage: type(A1)
<class 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic_with_category'>
sage: type(B1)
<class 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic_with_category'>
sage: type(A1) == type(B1)
False
```
so after this we do have two functionally equivalent copies of the same ring: `A1,B1`, but they are not identical. Furthermore, their types are not identical or equal either, but it's hard to see what the difference is between them (note `A1.__cmp__` to see that this last `False` is the reason why `A1 != B1`.

Allowing categories to be refined on "global" (uniqueified) objects implies that the `category` argument needs to be ignored on lookup during the uniqueification. You can't really control the category anyway:

```
sage: A1=IntegerModRing(19,category=Rings())
sage: A1.category()
Join of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups
sage: A1 in Fields()
True
sage: A2=IntegerModRing(19,category=Rings())
sage: A2.category()
Join of Category of subquotients of monoids and Category of quotients of semigroups and Category of fields
```



---

archive/issue_comments_191136.json:
```json
{
    "body": "Should specifying the category even be allowed anyway? What can be achieved by doing so? You can get horrible nonsense:\n\n```\nsage: A=IntegerModRing(16,category=Fields())\nsage: P.<x>=A[]\nsage: P in UniqueFactorizationDomains()\nTrue\nsage: (2*x+1)^8\n1\n```\nOf course if you do this, you're just asking for the insanity. Normally everything is fine:\n\n```\nsage: B=IntegerModRing(16)\nsage: Q.<x>=B[]\nsage: Q in UniqueFactorizationDomains()\nFalse\n```\nBut it does mean that if `B` here were to be identical to `A`, then the first example would permanently poison the sage session with nonsense. So I'd think `IntegerModRing(16,category=Fields())` should produce an error.",
    "created_at": "2013-09-25T22:55:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191136",
    "user": "https://github.com/nbruin"
}
```

Should specifying the category even be allowed anyway? What can be achieved by doing so? You can get horrible nonsense:

```
sage: A=IntegerModRing(16,category=Fields())
sage: P.<x>=A[]
sage: P in UniqueFactorizationDomains()
True
sage: (2*x+1)^8
1
```
Of course if you do this, you're just asking for the insanity. Normally everything is fine:

```
sage: B=IntegerModRing(16)
sage: Q.<x>=B[]
sage: Q in UniqueFactorizationDomains()
False
```
But it does mean that if `B` here were to be identical to `A`, then the first example would permanently poison the sage session with nonsense. So I'd think `IntegerModRing(16,category=Fields())` should produce an error.



---

archive/issue_comments_191137.json:
```json
{
    "body": "Replying to [comment:19 nbruin]:\n> But it does mean that if `B` here were to be identical to `A`, then the first example would permanently poison the sage session with nonsense.\n\n\nAnd that's why I think it is a good idea that *all* given arguments, including the category, are taken into the cache key of the factory. That way, it won't matter if you put a non-field into the category of fields, because you are still able to create a \"sane\" version of the same ring.\n\n> So I'd think `IntegerModRing(16,category=Fields())` should produce an error.\n\n\nI don't think so. And in any case, it should be on a different ticket.",
    "created_at": "2013-09-26T08:23:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191137",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:19 nbruin]:
> But it does mean that if `B` here were to be identical to `A`, then the first example would permanently poison the sage session with nonsense.


And that's why I think it is a good idea that *all* given arguments, including the category, are taken into the cache key of the factory. That way, it won't matter if you put a non-field into the category of fields, because you are still able to create a "sane" version of the same ring.

> So I'd think `IntegerModRing(16,category=Fields())` should produce an error.


I don't think so. And in any case, it should be on a different ticket.



---

archive/issue_comments_191138.json:
```json
{
    "body": "Hm. But the more I think about it...:\n\nIn the `__cmp__` method of `IntegerModRing`, it is said:\n\n```\n        if type(other) is not type(self):   # so that GF(p) =/= Z/pZ\n            return cmp(type(self), type(other))\n        return cmp(self.__order, other.__order)\n```\n\nNote the comment: The aim is to let `GF(p)` and `Z/pZ` evaluate unequal. This gives rise to two questions:\n\n1. Do we really want that they evaluate unequal?\n\n   We have\n   {{{\nsage: GF(5).has_coerce_map_from(IntegerModRing(5))\nTrue\nsage: IntegerModRing(5).has_coerce_map_from(GF(5))\nFalse\n   }}}\n   Since there is no coercion in both directions, the two rings can not be equal. So, I'd say `GF(5)!=IntegerModRing(5)` is correct, or at least consistent.\n\n2. Do we really want that `IntegerModRing(5)` and `IntegerModRing(5,category=Fields())` evaluate unequal?\n\n   This time, the coercions exist in both directions:\n   {{{\nsage: IntegerModRing(5).has_coerce_map_from(IntegerModRing(5, category=Fields()))\nTrue\nsage: IntegerModRing(5, category=Fields()).has_coerce_map_from(IntegerModRing(5))\nTrue\n   }}}\n   Hence, we might want to let them evaluate equal.\n\nI see the following options:\n\n- Make it so that integer mod rings with the same modulus evaluate equal, regardless of their type and category. This would be in spite of the comment in the code of `__cmp__`.\n- Change `__cmp__` so that integer mod rings evaluate equal if and only if there is a coercion in both directions. Hence, `GF(5)` and `ZZ.quo(5)` would evaluate unequal, but `IntegerModRing(5, category=...)` would all evaluate equal, independent of the category.\n- Change `_coerce_map_from_`, so that there is a coercion in both directions if and only if the two integer mod rings evaluate equal. Hence, `IntegerModRing(5, category=...)` would all be distinct, for different categories.\n- Do not allow to put in a \"category\" argument. But then, we might want to learn the rationale of introducing the argument in the first place. After all, if the modulus of integer mod ring R is a prime number, then asking `R in Fields()` will return true. So, if one knows during creation of the ring that the modulus is prime, one might use `GF(p)` instead of `IntegerModRing(p,category=Fields())`.\n\nFurther ways to go? In any case, there should be a new ticket.",
    "created_at": "2013-09-26T08:53:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191138",
    "user": "https://github.com/simon-king-jena"
}
```

Hm. But the more I think about it...:

In the `__cmp__` method of `IntegerModRing`, it is said:

```
        if type(other) is not type(self):   # so that GF(p) =/= Z/pZ
            return cmp(type(self), type(other))
        return cmp(self.__order, other.__order)
```

Note the comment: The aim is to let `GF(p)` and `Z/pZ` evaluate unequal. This gives rise to two questions:

1. Do we really want that they evaluate unequal?

   We have
   {{{
sage: GF(5).has_coerce_map_from(IntegerModRing(5))
True
sage: IntegerModRing(5).has_coerce_map_from(GF(5))
False
   }}}
   Since there is no coercion in both directions, the two rings can not be equal. So, I'd say `GF(5)!=IntegerModRing(5)` is correct, or at least consistent.

2. Do we really want that `IntegerModRing(5)` and `IntegerModRing(5,category=Fields())` evaluate unequal?

   This time, the coercions exist in both directions:
   {{{
sage: IntegerModRing(5).has_coerce_map_from(IntegerModRing(5, category=Fields()))
True
sage: IntegerModRing(5, category=Fields()).has_coerce_map_from(IntegerModRing(5))
True
   }}}
   Hence, we might want to let them evaluate equal.

I see the following options:

- Make it so that integer mod rings with the same modulus evaluate equal, regardless of their type and category. This would be in spite of the comment in the code of `__cmp__`.
- Change `__cmp__` so that integer mod rings evaluate equal if and only if there is a coercion in both directions. Hence, `GF(5)` and `ZZ.quo(5)` would evaluate unequal, but `IntegerModRing(5, category=...)` would all evaluate equal, independent of the category.
- Change `_coerce_map_from_`, so that there is a coercion in both directions if and only if the two integer mod rings evaluate equal. Hence, `IntegerModRing(5, category=...)` would all be distinct, for different categories.
- Do not allow to put in a "category" argument. But then, we might want to learn the rationale of introducing the argument in the first place. After all, if the modulus of integer mod ring R is a prime number, then asking `R in Fields()` will return true. So, if one knows during creation of the ring that the modulus is prime, one might use `GF(p)` instead of `IntegerModRing(p,category=Fields())`.

Further ways to go? In any case, there should be a new ticket.



---

archive/issue_comments_191139.json:
```json
{
    "body": "Replying to [comment:21 SimonKing]:\n> - Do not allow to put in a \"category\" argument. But then, we might want to learn the rationale of introducing the argument in the first place. After all, if the modulus of integer mod ring R is a prime number, then asking `R in Fields()` will return true. So, if one knows during creation of the ring that the modulus is prime, one might use `GF(p)` instead of `IntegerModRing(p,category=Fields())`.\n\n\nHow embarrassing!\n\nI just used `git blame` to find out who introduced the use of a \"category\" argument for integer mod rings---and found that it was **I**, namely in #9138.\n\nI hope #9138 gives a rationale...",
    "created_at": "2013-09-26T11:04:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191139",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:21 SimonKing]:
> - Do not allow to put in a "category" argument. But then, we might want to learn the rationale of introducing the argument in the first place. After all, if the modulus of integer mod ring R is a prime number, then asking `R in Fields()` will return true. So, if one knows during creation of the ring that the modulus is prime, one might use `GF(p)` instead of `IntegerModRing(p,category=Fields())`.


How embarrassing!

I just used `git blame` to find out who introduced the use of a "category" argument for integer mod rings---and found that it was **I**, namely in #9138.

I hope #9138 gives a rationale...



---

archive/issue_comments_191140.json:
```json
{
    "body": "`IntegerModRing` is not mentioned in the discussion of #9138. But in the patch, I found that providing the category as an additional argument used to be a \"todo\". Namely, before #9138, we had this:\n\n```\nsage: FF = IntegerModRing(17, category = Fields()) # todo: not implemented \nsage: FF.category()\nJoin of Category of fields and Category of finite enumerated sets\nsage: TestSuite(FF).run()                          # todo: not implemented\n```\n\nSo, this yields to the question: Why has it been a \"todo\"? Nicolas, did you added this \"todo\"?",
    "created_at": "2013-09-26T11:10:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191140",
    "user": "https://github.com/simon-king-jena"
}
```

`IntegerModRing` is not mentioned in the discussion of #9138. But in the patch, I found that providing the category as an additional argument used to be a "todo". Namely, before #9138, we had this:

```
sage: FF = IntegerModRing(17, category = Fields()) # todo: not implemented 
sage: FF.category()
Join of Category of fields and Category of finite enumerated sets
sage: TestSuite(FF).run()                          # todo: not implemented
```

So, this yields to the question: Why has it been a "todo"? Nicolas, did you added this "todo"?



---

archive/issue_comments_191141.json:
```json
{
    "body": "It seems that it became \"todo\" in #8562. And there is a discussion [here](https://groups.google.com/forum/#!topic/sage-devel/IeIeHsnNIf4). It seems indeed that in this discussion there was an agreement that\n1. one should not do primality test when creating the `IntegerModRing`\n2. calling `is_field()` will do a primality test, and it was even suggested to update the category to `Fields()`, which actually has been impossible at that time\n3. it should be possible for the user to assert that the modulus is prime, *without* using `GF(n)`. And, by the way, note that `GF(n)` would by default do a factorisation of `n`, and I don't know if it is possible for the user to skip this.\n\nWhat do I conclude from this?\n\n- Given 3., I see why people want to work with `IntegerModRing(n,category=Fields())` instead of `GF(n)` when they know that the huge number n is prime.\n- Given 2., it might make sense to call `_refine_category` in `is_field` (and not only by 'R in Fields()') when the primality test succeeds.\n- Given the cited discussion, it seems that the existence of an optional `category` argument is good.\n- Providing the category `Fields()` at creation time should have the same effect as refining the category to `Fields()`. Namely, at the moment, the categories of `IntegerModRing(5,category=Fields())` and `IntegerModRing(5)` after `... in Fields()` are different.\n\nAnd I am stuck with the following questions:\n\n- Should the choice of a category play a role in testing equality for integer mod rings?\n- Would we like that there is precisely *one* instance of an integer mod ring for a given modulus, that is automatically updated if the user later provides more information? What I mean is this:\n  {{{\nsage: R = IntegerModRing(5)\nsage: R.category()\nJoin of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets\nsage: S = IntegerModRing(5, category=Fields())\nsage: R is S\nTrue\nsage: R.category()\nJoin of Category of fields and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets\n   }}}\n\n__Suggested way to proceed__\n\n- I open a new ticket implementing the conclusions formulated above.\n- Depending on your answers to my questions, I open another new ticket to address them.\n- I make these one or two tickets a dependency for this ticket.",
    "created_at": "2013-09-26T11:45:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191141",
    "user": "https://github.com/simon-king-jena"
}
```

It seems that it became "todo" in #8562. And there is a discussion [here](https://groups.google.com/forum/#!topic/sage-devel/IeIeHsnNIf4). It seems indeed that in this discussion there was an agreement that
1. one should not do primality test when creating the `IntegerModRing`
2. calling `is_field()` will do a primality test, and it was even suggested to update the category to `Fields()`, which actually has been impossible at that time
3. it should be possible for the user to assert that the modulus is prime, *without* using `GF(n)`. And, by the way, note that `GF(n)` would by default do a factorisation of `n`, and I don't know if it is possible for the user to skip this.

What do I conclude from this?

- Given 3., I see why people want to work with `IntegerModRing(n,category=Fields())` instead of `GF(n)` when they know that the huge number n is prime.
- Given 2., it might make sense to call `_refine_category` in `is_field` (and not only by 'R in Fields()') when the primality test succeeds.
- Given the cited discussion, it seems that the existence of an optional `category` argument is good.
- Providing the category `Fields()` at creation time should have the same effect as refining the category to `Fields()`. Namely, at the moment, the categories of `IntegerModRing(5,category=Fields())` and `IntegerModRing(5)` after `... in Fields()` are different.

And I am stuck with the following questions:

- Should the choice of a category play a role in testing equality for integer mod rings?
- Would we like that there is precisely *one* instance of an integer mod ring for a given modulus, that is automatically updated if the user later provides more information? What I mean is this:
  {{{
sage: R = IntegerModRing(5)
sage: R.category()
Join of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets
sage: S = IntegerModRing(5, category=Fields())
sage: R is S
True
sage: R.category()
Join of Category of fields and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets
   }}}

__Suggested way to proceed__

- I open a new ticket implementing the conclusions formulated above.
- Depending on your answers to my questions, I open another new ticket to address them.
- I make these one or two tickets a dependency for this ticket.



---

archive/issue_comments_191142.json:
```json
{
    "body": "I have opened #15229 for the new problems.",
    "created_at": "2013-09-26T13:17:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191142",
    "user": "https://github.com/simon-king-jena"
}
```

I have opened #15229 for the new problems.



---

archive/issue_comments_191143.json:
```json
{
    "body": "Changing keywords from \"\" to \"construction functor, test suite, sd53\".",
    "created_at": "2013-09-27T10:45:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191143",
    "user": "https://github.com/simon-king-jena"
}
```

Changing keywords from "" to "construction functor, test suite, sd53".



---

archive/issue_comments_191144.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-09-28T18:55:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191144",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191145.json:
```json
{
    "body": "#15229 is ready for review (hint). I have merged #15229 into this branch, and rebased this branch, which was needed, as #15229 introduced a new convention for teaching to an integer mod ring that it is a field.\n\nFor me all tests pass. Hence, this one is ready for review, too!",
    "created_at": "2013-09-28T19:00:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191145",
    "user": "https://github.com/simon-king-jena"
}
```

#15229 is ready for review (hint). I have merged #15229 into this branch, and rebased this branch, which was needed, as #15229 introduced a new convention for teaching to an integer mod ring that it is a field.

For me all tests pass. Hence, this one is ready for review, too!



---

archive/issue_comments_191146.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-09-28T19:00:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191146",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_191147.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-12-20T12:40:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191147",
    "user": "https://github.com/mezzarobba"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_191148.json:
```json
{
    "body": "There are new test failures with the current `develop`, unfortunately:\n\n```\n----------------------------------------------------------------------\nsage -t src/sage/rings/polynomial/pbori.pyx  # 1 doctest failed\nsage -t src/sage/rings/finite_rings/integer_mod_ring.py  # 4 doctests failed\nsage -t src/sage/rings/residue_field.pyx  # 2 doctests failed\nsage -t src/sage/rings/finite_rings/finite_field_pari_ffelt.py  # 1 doctest failed\n----------------------------------------------------------------------\n```",
    "created_at": "2013-12-20T12:40:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191148",
    "user": "https://github.com/mezzarobba"
}
```

There are new test failures with the current `develop`, unfortunately:

```
----------------------------------------------------------------------
sage -t src/sage/rings/polynomial/pbori.pyx  # 1 doctest failed
sage -t src/sage/rings/finite_rings/integer_mod_ring.py  # 4 doctests failed
sage -t src/sage/rings/residue_field.pyx  # 2 doctests failed
sage -t src/sage/rings/finite_rings/finite_field_pari_ffelt.py  # 1 doctest failed
----------------------------------------------------------------------
```



---

archive/issue_comments_191149.json:
```json
{
    "body": "Reviewing the errors:\n\n```\nsage -t src/sage/rings/polynomial/pbori.pyx\n**********************************************************************\nFile \"src/sage/rings/polynomial/pbori.pyx\", line 476, in sage.rings.polynomial.pbori.BooleanPolynomialRing.construction\nFailed example:\n    P.<x0, x1, x2, x3> = BooleanPolynomialRing(4,order='degrevlex(2),degrevlex(2)')\nExpected nothing\nGot:\n    doctest:1: DeprecationWarning: using 'degrevlex' in Boolean polynomial rings is deprecated. If needed, reverse the order of variables manually and use 'degneglex'\n    See http://trac.sagemath.org/13849 for details.\n**********************************************************************\n```\nOK, it seems we need a different ordering. Mostly harmless\n\n`sage -t src/sage/rings/residue_field.pyx` and `sage -t src/sage/rings/finite_rings/finite_field_pari_ffelt.py`: The new test fails on some examples. Hooray! The new test helped to detect another bug!\n\nFor me, `sage -t src/sage/rings/finite_rings/integer_mod_ring.py` passes without error.",
    "created_at": "2013-12-28T12:25:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191149",
    "user": "https://github.com/simon-king-jena"
}
```

Reviewing the errors:

```
sage -t src/sage/rings/polynomial/pbori.pyx
**********************************************************************
File "src/sage/rings/polynomial/pbori.pyx", line 476, in sage.rings.polynomial.pbori.BooleanPolynomialRing.construction
Failed example:
    P.<x0, x1, x2, x3> = BooleanPolynomialRing(4,order='degrevlex(2),degrevlex(2)')
Expected nothing
Got:
    doctest:1: DeprecationWarning: using 'degrevlex' in Boolean polynomial rings is deprecated. If needed, reverse the order of variables manually and use 'degneglex'
    See http://trac.sagemath.org/13849 for details.
**********************************************************************
```
OK, it seems we need a different ordering. Mostly harmless

`sage -t src/sage/rings/residue_field.pyx` and `sage -t src/sage/rings/finite_rings/finite_field_pari_ffelt.py`: The new test fails on some examples. Hooray! The new test helped to detect another bug!

For me, `sage -t src/sage/rings/finite_rings/integer_mod_ring.py` passes without error.



---

archive/issue_comments_191150.json:
```json
{
    "body": "PS: What has failed for you in `sage -t src/sage/rings/finite_rings/integer_mod_ring.py`?",
    "created_at": "2013-12-28T12:27:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191150",
    "user": "https://github.com/simon-king-jena"
}
```

PS: What has failed for you in `sage -t src/sage/rings/finite_rings/integer_mod_ring.py`?



---

archive/issue_comments_191151.json:
```json
{
    "body": "Replying to [comment:31 SimonKing]:\n> PS: What has failed for you in `sage -t src/sage/rings/finite_rings/integer_mod_ring.py`?\n\n\nThe failures do not look deterministic. With the current state of your branch, all tests passed when I did `sage -t integer_mod_ring.py` for the first time. Then I tried again and repeatedly got:\n\n```\n$ sage -t src/sage/rings/finite_rings/integer_mod_ring.py\nRunning doctests with ID 2013-12-28-16-42-51-6b28af73.\nDoctesting 1 file.\nsage -t src/sage/rings/finite_rings/integer_mod_ring.py\n**********************************************************************\nFile \"src/sage/rings/finite_rings/integer_mod_ring.py\", line 729, in sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic._pseudo_fraction_field\nFailed example:\n    Integers(15).fraction_field()\nExpected:\n    Traceback (most recent call last):\n    ...\n    TypeError: self must be an integral domain.\nGot:\n    Ring of integers modulo 15\n**********************************************************************\n1 item had failures:\n   1 of   7 in sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic._pseudo_fraction_field\n    [251 tests, 1 failure, 1.68 s]\n----------------------------------------------------------------------\nsage -t src/sage/rings/finite_rings/integer_mod_ring.py  # 1 doctest failed\n----------------------------------------------------------------------\n```\nBut I'm unable to reproduce this behaviour from the sage command line.\n\nI will run the tests again after rebuilding sage from scratch.",
    "created_at": "2013-12-28T15:54:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191151",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:31 SimonKing]:
> PS: What has failed for you in `sage -t src/sage/rings/finite_rings/integer_mod_ring.py`?


The failures do not look deterministic. With the current state of your branch, all tests passed when I did `sage -t integer_mod_ring.py` for the first time. Then I tried again and repeatedly got:

```
$ sage -t src/sage/rings/finite_rings/integer_mod_ring.py
Running doctests with ID 2013-12-28-16-42-51-6b28af73.
Doctesting 1 file.
sage -t src/sage/rings/finite_rings/integer_mod_ring.py
**********************************************************************
File "src/sage/rings/finite_rings/integer_mod_ring.py", line 729, in sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic._pseudo_fraction_field
Failed example:
    Integers(15).fraction_field()
Expected:
    Traceback (most recent call last):
    ...
    TypeError: self must be an integral domain.
Got:
    Ring of integers modulo 15
**********************************************************************
1 item had failures:
   1 of   7 in sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic._pseudo_fraction_field
    [251 tests, 1 failure, 1.68 s]
----------------------------------------------------------------------
sage -t src/sage/rings/finite_rings/integer_mod_ring.py  # 1 doctest failed
----------------------------------------------------------------------
```
But I'm unable to reproduce this behaviour from the sage command line.

I will run the tests again after rebuilding sage from scratch.



---

archive/issue_comments_191152.json:
```json
{
    "body": "Replying to [comment:32 mmezzarobba]:\n> I will run the tests again after rebuilding sage from scratch.\n\n\nDone: I get the same heisenfailure in `integer_mod_ring.py` on your branch, *without* merging in develop. I'm currently checking whether the problem exists on `develop` (again with a clean build, so it will take a while).",
    "created_at": "2013-12-28T17:32:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191152",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:32 mmezzarobba]:
> I will run the tests again after rebuilding sage from scratch.


Done: I get the same heisenfailure in `integer_mod_ring.py` on your branch, *without* merging in develop. I'm currently checking whether the problem exists on `develop` (again with a clean build, so it will take a while).



---

archive/issue_comments_191153.json:
```json
{
    "body": "Replying to [comment:33 mmezzarobba]:\n> I'm currently checking whether the problem exists on `develop`\n\n\nApparently it doesn't.",
    "created_at": "2013-12-28T19:17:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191153",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:33 mmezzarobba]:
> I'm currently checking whether the problem exists on `develop`


Apparently it doesn't.



---

archive/issue_comments_191154.json:
```json
{
    "body": "Replying to [comment:34 mmezzarobba]:\n> Replying to [comment:33 mmezzarobba]:\n> > I'm currently checking whether the problem exists on `develop`\n\n> \n> Apparently it doesn't.\n\n\nAnd I'm also unable to reproduce it when I first build `develop` from scratch, and then merge in your branch and do an incremental build.\n\nPerhaps a bug of 5.12.x that was fixed since them and resurfaced randomly in my tests due to problems with incremental builds, then?",
    "created_at": "2013-12-28T19:26:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191154",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:34 mmezzarobba]:
> Replying to [comment:33 mmezzarobba]:
> > I'm currently checking whether the problem exists on `develop`

> 
> Apparently it doesn't.


And I'm also unable to reproduce it when I first build `develop` from scratch, and then merge in your branch and do an incremental build.

Perhaps a bug of 5.12.x that was fixed since them and resurfaced randomly in my tests due to problems with incremental builds, then?



---

archive/issue_comments_191155.json:
```json
{
    "body": "Replying to [comment:32 mmezzarobba]:\n> The failures do not look deterministic. With the current state of your branch, all tests passed when I did `sage -t integer_mod_ring.py` for the first time. Then I tried again and repeatedly got:\n> \n> ```\n> $ sage -t src/sage/rings/finite_rings/integer_mod_ring.py\n> Running doctests with ID 2013-12-28-16-42-51-6b28af73.\n> Doctesting 1 file.\n> sage -t src/sage/rings/finite_rings/integer_mod_ring.py\n> **********************************************************************\n> File \"src/sage/rings/finite_rings/integer_mod_ring.py\", line 729, in sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic._pseudo_fraction_field\n> Failed example:\n>     Integers(15).fraction_field()\n> Expected:\n>     Traceback (most recent call last):\n>     ...\n>     TypeError: self must be an integral domain.\n> Got:\n>     Ring of integers modulo 15\n> ```\n\n\nAhahahaha! It looks like the same example (modulus 15) was used in a different example to demonstrate that one can erroneously claim that `IntegerModRing(15)` is a field, and it could be that by random order of executing the tests this false information was cached. To be on the safe side, we could empty the cache.\n\n> I will run the tests again after rebuilding sage from scratch.\n\n\nDid you pull from #15229?\n\nFor the record: I get\n\n```\nsage -t src/sage/rings/residue_field.pyx  # 2 doctests failed\nsage -t src/sage/rings/polynomial/pbori.pyx  # 1 doctest failed\nsage -t src/sage/rings/finite_rings/finite_field_pari_ffelt.py  # 1 doctest failed\n```",
    "created_at": "2013-12-28T20:12:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191155",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:32 mmezzarobba]:
> The failures do not look deterministic. With the current state of your branch, all tests passed when I did `sage -t integer_mod_ring.py` for the first time. Then I tried again and repeatedly got:
> 
> ```
> $ sage -t src/sage/rings/finite_rings/integer_mod_ring.py
> Running doctests with ID 2013-12-28-16-42-51-6b28af73.
> Doctesting 1 file.
> sage -t src/sage/rings/finite_rings/integer_mod_ring.py
> **********************************************************************
> File "src/sage/rings/finite_rings/integer_mod_ring.py", line 729, in sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic._pseudo_fraction_field
> Failed example:
>     Integers(15).fraction_field()
> Expected:
>     Traceback (most recent call last):
>     ...
>     TypeError: self must be an integral domain.
> Got:
>     Ring of integers modulo 15
> ```


Ahahahaha! It looks like the same example (modulus 15) was used in a different example to demonstrate that one can erroneously claim that `IntegerModRing(15)` is a field, and it could be that by random order of executing the tests this false information was cached. To be on the safe side, we could empty the cache.

> I will run the tests again after rebuilding sage from scratch.


Did you pull from #15229?

For the record: I get

```
sage -t src/sage/rings/residue_field.pyx  # 2 doctests failed
sage -t src/sage/rings/polynomial/pbori.pyx  # 1 doctest failed
sage -t src/sage/rings/finite_rings/finite_field_pari_ffelt.py  # 1 doctest failed
```



---

archive/issue_comments_191156.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-12-28T20:31:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191156",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191157.json:
```json
{
    "body": "I have merged #15229, since it changes `integer_mod_ring.py`, and I added a commit to clear the cache of the integer mod ring factory after compromising the cache by lying about `is_field=True`.\n\nHopefully this will fix the \"Heisenbug\" (which probably is not more than a side-effect between doc-tests). The remaining failures shall be fixed in the next commit.",
    "created_at": "2013-12-28T20:36:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191157",
    "user": "https://github.com/simon-king-jena"
}
```

I have merged #15229, since it changes `integer_mod_ring.py`, and I added a commit to clear the cache of the integer mod ring factory after compromising the cache by lying about `is_field=True`.

Hopefully this will fix the "Heisenbug" (which probably is not more than a side-effect between doc-tests). The remaining failures shall be fixed in the next commit.



---

archive/issue_comments_191158.json:
```json
{
    "body": "Concerning the error with residue fields:\n\n```\nsage: K.<z> = CyclotomicField(7)\nsage: P = K.factor(17)[0][0]\nsage: ff = K.residue_field(P)\nsage: ff.construction()\n(AlgebraicExtensionFunctor, Finite Field of size 17)\nsage: F,R = _\nsage: F(R)\nFinite Field in zbar of size 17^6\nsage: ff\nResidue field in zbar of Fractional ideal (17)\nsage: ff.order()\n24137569\nsage: F(R).order()\n24137569\n```\n\nSo, the construction of a residue field just yields a finite field, not a residue field. Either the algebraic extension functor needs information of whether it is a residue field or not, or we need a \"residue field functor\". I wouldn't like to see the latter, since it is clearly no functor. OK, it would also be possible to kill the construction of residue fields.",
    "created_at": "2013-12-28T20:52:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191158",
    "user": "https://github.com/simon-king-jena"
}
```

Concerning the error with residue fields:

```
sage: K.<z> = CyclotomicField(7)
sage: P = K.factor(17)[0][0]
sage: ff = K.residue_field(P)
sage: ff.construction()
(AlgebraicExtensionFunctor, Finite Field of size 17)
sage: F,R = _
sage: F(R)
Finite Field in zbar of size 17^6
sage: ff
Residue field in zbar of Fractional ideal (17)
sage: ff.order()
24137569
sage: F(R).order()
24137569
```

So, the construction of a residue field just yields a finite field, not a residue field. Either the algebraic extension functor needs information of whether it is a residue field or not, or we need a "residue field functor". I wouldn't like to see the latter, since it is clearly no functor. OK, it would also be possible to kill the construction of residue fields.



---

archive/issue_comments_191159.json:
```json
{
    "body": "The algebraic extension functors already have a version to construct cyclotomic fields. It should be straight forward to make them deal with residue fields, too.",
    "created_at": "2013-12-28T21:08:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191159",
    "user": "https://github.com/simon-king-jena"
}
```

The algebraic extension functors already have a version to construct cyclotomic fields. It should be straight forward to make them deal with residue fields, too.



---

archive/issue_comments_191160.json:
```json
{
    "body": "Rather than killing the construction, I guess the following is a nice behaviour:\n\n```\n        sage: K.<z> = CyclotomicField(7)\n        sage: P = K.factor(17)[0][0]\n        sage: k = K.residue_field(P)\n        sage: F, R = k.construction()\n        sage: F\n        AlgebraicExtensionFunctor\n        sage: R\n        Cyclotomic Field of order 7 and degree 6\n        sage: F(R) is k\n        True\n        sage: F(ZZ)\n        Residue field of Integers modulo 17\n        sage: F(CyclotomicField(49))\n        Residue field in zeta49bar of Fractional ideal (17)\n```",
    "created_at": "2013-12-28T21:35:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191160",
    "user": "https://github.com/simon-king-jena"
}
```

Rather than killing the construction, I guess the following is a nice behaviour:

```
        sage: K.<z> = CyclotomicField(7)
        sage: P = K.factor(17)[0][0]
        sage: k = K.residue_field(P)
        sage: F, R = k.construction()
        sage: F
        AlgebraicExtensionFunctor
        sage: R
        Cyclotomic Field of order 7 and degree 6
        sage: F(R) is k
        True
        sage: F(ZZ)
        Residue field of Integers modulo 17
        sage: F(CyclotomicField(49))
        Residue field in zeta49bar of Fractional ideal (17)
```



---

archive/issue_comments_191161.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-12-28T21:41:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191161",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191162.json:
```json
{
    "body": "Residue fields are fixed with the latest commit.\n\n---\nNew commits:\n|                                                                                                         |                                            |\n|---------------------------------------------------------------------------------------------------------|--------------------------------------------|\n|[ab2c12e](http://git.sagemath.org/sage.git/commit/?id=ab2c12e)|`Trac 15223: Construction of residue fields`|\n---\nNew commits:",
    "created_at": "2013-12-28T22:14:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191162",
    "user": "https://github.com/simon-king-jena"
}
```

Residue fields are fixed with the latest commit.

---
New commits:
|                                                                                                         |                                            |
|---------------------------------------------------------------------------------------------------------|--------------------------------------------|
|[ab2c12e](http://git.sagemath.org/sage.git/commit/?id=ab2c12e)|`Trac 15223: Construction of residue fields`|
---
New commits:



---

archive/issue_comments_191163.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-12-28T22:45:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191163",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191164.json:
```json
{
    "body": "With the new commit, the construction of field extensions is fixed.\n\nProblem was: Finite fields may have different implementations (givaro, pari_ffelt, ...), but this was ignored in the construction of the construction functor. Now, the implementation is tracked in the construction functor.\n\nOne complication: When we merge the construction functors, we need to choose among the implementations. I decided (for now) to always rely on the *default* implementation upon merging. \n\n__Rationale__\n\n- The situation is not worse than before. Without the latest commit, applying the construction functor of a finite field would *always* use the default implementation. With the latest commit, applying the construction functor of a finite field F will use the implementation that was used for F. Only if a new construction functor is created by merging two functors (which may happen in the pushout construction), the default implementation will be used, \n\n- We can't rely on a custom implementation in the merged functor, since a custom implementation may not be available for a non-prime field, that could be the result of merging.",
    "created_at": "2013-12-28T22:59:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191164",
    "user": "https://github.com/simon-king-jena"
}
```

With the new commit, the construction of field extensions is fixed.

Problem was: Finite fields may have different implementations (givaro, pari_ffelt, ...), but this was ignored in the construction of the construction functor. Now, the implementation is tracked in the construction functor.

One complication: When we merge the construction functors, we need to choose among the implementations. I decided (for now) to always rely on the *default* implementation upon merging. 

__Rationale__

- The situation is not worse than before. Without the latest commit, applying the construction functor of a finite field would *always* use the default implementation. With the latest commit, applying the construction functor of a finite field F will use the implementation that was used for F. Only if a new construction functor is created by merging two functors (which may happen in the pushout construction), the default implementation will be used, 

- We can't rely on a custom implementation in the merged functor, since a custom implementation may not be available for a non-prime field, that could be the result of merging.



---

archive/issue_comments_191165.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-12-28T23:02:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191165",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_191166.json:
```json
{
    "body": "Hooray, with the last commit, `sage -t src/sage/rings/polynomial/pbori.pyx` passes, too!\n\nHence, I think it could be reviewed now (but I will run the tests while sleeping).",
    "created_at": "2013-12-28T23:02:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191166",
    "user": "https://github.com/simon-king-jena"
}
```

Hooray, with the last commit, `sage -t src/sage/rings/polynomial/pbori.pyx` passes, too!

Hence, I think it could be reviewed now (but I will run the tests while sleeping).



---

archive/issue_comments_191167.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-12-29T07:40:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191167",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191168.json:
```json
{
    "body": "Sigh. I still don't like git. It makes it soooooo easy to do mistakes, whose reversal is considered \"changing history\".\n\nAnyway. It was an accident that I did not revert merging the branch 'develop' before pushing it here.\n\nCan someone tell me, *if* and *how* I should remove the merge commit?\n\nBut now all tests pass, and thus it can be reviewed.",
    "created_at": "2013-12-29T07:50:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191168",
    "user": "https://github.com/simon-king-jena"
}
```

Sigh. I still don't like git. It makes it soooooo easy to do mistakes, whose reversal is considered "changing history".

Anyway. It was an accident that I did not revert merging the branch 'develop' before pushing it here.

Can someone tell me, *if* and *how* I should remove the merge commit?

But now all tests pass, and thus it can be reviewed.



---

archive/issue_comments_191169.json:
```json
{
    "body": "Replying to [comment:48 SimonKing]:\n> Can someone tell me, *if* and *how* I should remove the merge commit?\n\n\nIm my opinion (some people might disagree), yes, you should, since it is very unlikely that anyone has based anything on the last state of your branch. There is no need to be religious about history rewrites, one just needs to avoid forcing people to do rebases.\n\nTo remove the merge commit, just do `git rebase HEAD^ --onto HEAD^^` on your branch (and then `git push -f` to push the modified branch to trac).",
    "created_at": "2013-12-29T12:58:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191169",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:48 SimonKing]:
> Can someone tell me, *if* and *how* I should remove the merge commit?


Im my opinion (some people might disagree), yes, you should, since it is very unlikely that anyone has based anything on the last state of your branch. There is no need to be religious about history rewrites, one just needs to avoid forcing people to do rebases.

To remove the merge commit, just do `git rebase HEAD^ --onto HEAD^^` on your branch (and then `git push -f` to push the modified branch to trac).



---

archive/issue_comments_191170.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:",
    "created_at": "2013-12-29T13:24:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191170",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:



---

archive/issue_comments_191171.json:
```json
{
    "body": "Replying to [comment:49 mmezzarobba]:\n> Replying to [comment:48 SimonKing]:\n> > Can someone tell me, *if* and *how* I should remove the merge commit?\n\n> \n> Im my opinion (some people might disagree), yes, you should, since it is very unlikely that anyone has based anything on the last state of your branch. There is no need to be religious about history rewrites, one just needs to avoid forcing people to do rebases.\n> \n> To remove the merge commit, just do `git rebase HEAD^ --onto HEAD^^` on your branch (and then `git push -f` to push the modified branch to trac).\n\n\nThank you! Can you briefly explain to me the differences between `^HEAD`, `HEAD^` and `HEAD~`? I keep forgetting what is what.",
    "created_at": "2013-12-29T13:29:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191171",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:49 mmezzarobba]:
> Replying to [comment:48 SimonKing]:
> > Can someone tell me, *if* and *how* I should remove the merge commit?

> 
> Im my opinion (some people might disagree), yes, you should, since it is very unlikely that anyone has based anything on the last state of your branch. There is no need to be religious about history rewrites, one just needs to avoid forcing people to do rebases.
> 
> To remove the merge commit, just do `git rebase HEAD^ --onto HEAD^^` on your branch (and then `git push -f` to push the modified branch to trac).


Thank you! Can you briefly explain to me the differences between `^HEAD`, `HEAD^` and `HEAD~`? I keep forgetting what is what.



---

archive/issue_comments_191172.json:
```json
{
    "body": "Replying to [comment:51 SimonKing]:\n> Thank you! Can you briefly explain to me the differences between `^HEAD`, `HEAD^` and `HEAD~`? I keep forgetting what is what.\n\n\nThe last two specify revisions (commits): `rev^k` is the `k`-th parent of `rev`; `rev~k` is the grand<sup>`k`</sup>-first-parent of `rev`; `rev^` and `rev~` are shorthands `rev^1` == `rev~1`.\n\n`^rev` is something different: it is used to specify lower bounds of ranges of revisions. For example, `rev1 rev2 ^rev3` is the set of all ancestors of `rev1` or `rev2` that are not ancestors of `rev3`.\n\nSee `git help revisions` for the full syntax of revision specifications.",
    "created_at": "2013-12-29T18:16:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191172",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:51 SimonKing]:
> Thank you! Can you briefly explain to me the differences between `^HEAD`, `HEAD^` and `HEAD~`? I keep forgetting what is what.


The last two specify revisions (commits): `rev^k` is the `k`-th parent of `rev`; `rev~k` is the grand<sup>`k`</sup>-first-parent of `rev`; `rev^` and `rev~` are shorthands `rev^1` == `rev~1`.

`^rev` is something different: it is used to specify lower bounds of ranges of revisions. For example, `rev1 rev2 ^rev3` is the set of all ancestors of `rev1` or `rev2` that are not ancestors of `rev3`.

See `git help revisions` for the full syntax of revision specifications.



---

archive/issue_events_043999.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15223#event-43999"
}
```



---

archive/issue_events_044000.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15223#event-44000"
}
```



---

archive/issue_events_044001.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15223#event-44001"
}
```



---

archive/issue_comments_191173.json:
```json
{
    "body": "Set to 'needs work' because patchbot fails to apply the patch (open dependency).",
    "created_at": "2014-05-09T08:18:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191173",
    "user": "https://github.com/rwst"
}
```

Set to 'needs work' because patchbot fails to apply the patch (open dependency).



---

archive/issue_comments_191174.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-05-09T08:18:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191174",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_events_044002.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15223#event-44002"
}
```



---

archive/issue_events_044003.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15223#event-44003"
}
```



---

archive/issue_comments_191175.json:
```json
{
    "body": "The dependency *is* closed, but apparently the branch doesn't merge.",
    "created_at": "2017-01-09T12:54:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191175",
    "user": "https://github.com/simon-king-jena"
}
```

The dependency *is* closed, but apparently the branch doesn't merge.



---

archive/issue_comments_191176.json:
```json
{
    "body": "In the middle of manually rebasing this onto 9.2.beta10.\n\n```\nDONE 91712d0545 Test that the construction of a parent really constructs the parent\nDONE 91bbab6438 Add a test to Parent._test_construction\nREDONE 2bb2cf269b Fix most doctest errors that are due to enlarging the test suite\nDONE a81fcc1072 Make _test_construction pass in the thematic tutorial\nDONE e83735ca25 Provide several constr. functors with more parameters\n```\n\nTODO:\n\n```\npick cb4929aa68 Rebase wrt. #15229. Fix remaining doc test errors.\npick d0c42ff938 Trac 15223: Avoid side-effects between doctests of integer_mod_ring\npick ab2c12e1fb Trac 15223: Construction of residue fields\npick b23f18d716 Trac 15223: Construction of field extensions with implementation\npick 7a24de6caa Trac 15223: Avoid deprecation warning in a new test\n```\n\n---\nNew commits:",
    "created_at": "2020-08-31T01:15:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191176",
    "user": "https://github.com/mkoeppe"
}
```

In the middle of manually rebasing this onto 9.2.beta10.

```
DONE 91712d0545 Test that the construction of a parent really constructs the parent
DONE 91bbab6438 Add a test to Parent._test_construction
REDONE 2bb2cf269b Fix most doctest errors that are due to enlarging the test suite
DONE a81fcc1072 Make _test_construction pass in the thematic tutorial
DONE e83735ca25 Provide several constr. functors with more parameters
```

TODO:

```
pick cb4929aa68 Rebase wrt. #15229. Fix remaining doc test errors.
pick d0c42ff938 Trac 15223: Avoid side-effects between doctests of integer_mod_ring
pick ab2c12e1fb Trac 15223: Construction of residue fields
pick b23f18d716 Trac 15223: Construction of field extensions with implementation
pick 7a24de6caa Trac 15223: Avoid deprecation warning in a new test
```

---
New commits:



---

archive/issue_events_044004.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-31T01:15:23Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15223#event-44004"
}
```



---

archive/issue_events_044005.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-31T01:15:23Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15223#event-44005"
}
```



---

archive/issue_comments_191177.json:
```json
{
    "body": "Looks like there is a circular import problem now:\n\n```\nImportError: cannot import name 'AlgebrasCategory' from 'sage.categories.algebra_functor' (/Users/mkoeppe/s/sage/sage-rebasing/local/lib/python3.7/site-packages/sage/categories/algebra_functor.py)\n```",
    "created_at": "2020-08-31T01:22:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191177",
    "user": "https://github.com/mkoeppe"
}
```

Looks like there is a circular import problem now:

```
ImportError: cannot import name 'AlgebrasCategory' from 'sage.categories.algebra_functor' (/Users/mkoeppe/s/sage/sage-rebasing/local/lib/python3.7/site-packages/sage/categories/algebra_functor.py)
```



---

archive/issue_comments_191178.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T01:36:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191178",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191179.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T01:39:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191179",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191180.json:
```json
{
    "body": "Help with this circular import business would be very welcome",
    "created_at": "2020-08-31T01:40:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191180",
    "user": "https://github.com/mkoeppe"
}
```

Help with this circular import business would be very welcome



---

archive/issue_comments_191181.json:
```json
{
    "body": "In `polynomial_quotient_ring.py`, a way around the problem is to just make those imports locally where you need them in `construction()`. Welcome to Sage's circular import hell. `:P`\n\nAlso\n\n```diff\n \n-        TESTS:\n+        TESTS::\n \n             sage: M2 = PowerSeriesRing(QQ,4,'f', sparse=True)\n             sage: M == M2\n             False\n```",
    "created_at": "2020-08-31T01:50:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191181",
    "user": "https://github.com/tscrim"
}
```

In `polynomial_quotient_ring.py`, a way around the problem is to just make those imports locally where you need them in `construction()`. Welcome to Sage's circular import hell. `:P`

Also

```diff
 
-        TESTS:
+        TESTS::
 
             sage: M2 = PowerSeriesRing(QQ,4,'f', sparse=True)
             sage: M == M2
             False
```



---

archive/issue_comments_191182.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T02:17:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191182",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191183.json:
```json
{
    "body": "Hm... this alone did not do the trick",
    "created_at": "2020-08-31T02:18:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191183",
    "user": "https://github.com/mkoeppe"
}
```

Hm... this alone did not do the trick



---

archive/issue_comments_191184.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T02:24:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191184",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191185.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-08-31T02:24:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191185",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_191186.json:
```json
{
    "body": "OK, got it.",
    "created_at": "2020-08-31T02:25:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191186",
    "user": "https://github.com/mkoeppe"
}
```

OK, got it.



---

archive/issue_comments_191187.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T02:26:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191187",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191188.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T02:30:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191188",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191189.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-08-31T02:42:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191189",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_191190.json:
```json
{
    "body": "Setting it to needs_review so that the patchbot runs",
    "created_at": "2020-08-31T02:42:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191190",
    "user": "https://github.com/mkoeppe"
}
```

Setting it to needs_review so that the patchbot runs



---

archive/issue_comments_191191.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T03:06:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191191",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191192.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T03:13:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191192",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191193.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T03:22:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191193",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191194.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T03:23:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191194",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191195.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T03:28:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191195",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191196.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-08-31T05:24:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191196",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_191197.json:
```json
{
    "body": "As expected, there are a number of `AssertionError: the object's construction does not recreate this object` errors.\n\nIn addition, there are some other errors, probably because of faulty rebasing:\n\n```\nsage -t --random-seed=0 src/sage/rings/polynomial/polynomial_quotient_ring.py\nsage -t --random-seed=0 src/sage/rings/multi_power_series_ring_element.py\nsage -t --random-seed=0 src/sage/rings/multi_power_series_ring.py\nsage -t --random-seed=0 src/sage/rings/power_series_ring_element.pyx\nsage -t --random-seed=0 src/sage/rings/finite_rings/element_pari_ffelt.pyx\n```",
    "created_at": "2020-08-31T05:24:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191197",
    "user": "https://github.com/mkoeppe"
}
```

As expected, there are a number of `AssertionError: the object's construction does not recreate this object` errors.

In addition, there are some other errors, probably because of faulty rebasing:

```
sage -t --random-seed=0 src/sage/rings/polynomial/polynomial_quotient_ring.py
sage -t --random-seed=0 src/sage/rings/multi_power_series_ring_element.py
sage -t --random-seed=0 src/sage/rings/multi_power_series_ring.py
sage -t --random-seed=0 src/sage/rings/power_series_ring_element.pyx
sage -t --random-seed=0 src/sage/rings/finite_rings/element_pari_ffelt.pyx
```



---

archive/issue_comments_191198.json:
```json
{
    "body": "```\nFile \"src/sage/rings/multi_power_series_ring.py\", line 504, in sage.rings.multi_power_series_ring.MPowerSeriesRing_generic.construction\nFailed example:\n    c(R)\nException raised:\n    Traceback (most recent call last):\n      File \"/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 715, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/doctest/forker.py\", line 1139, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.rings.multi_power_series_ring.MPowerSeriesRing_generic.construction[3]>\", line 1, in <module>\n        c(R)\n      File \"sage/categories/functor.pyx\", line 383, in sage.categories.functor.Functor.__call__ (build/cythonized/sage/categories/functor.c:3146)\n        y = self._apply_functor(self._coerce_into_domain(x))\n      File \"/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/categories/pushout.py\", line 2456, in _apply_functor\n        return R.completion(self.p, self.prec, extras)\n      File \"sage/rings/polynomial/multi_polynomial_ring_base.pyx\", line 184, in sage.rings.polynomial.multi_polynomial_ring_base.MPolynomialRing_base.completion (build/cythonized/sage/rings/polynomial/multi_polynomial_ring_base.c:5003)\n        def completion(self, names, prec=20):\n    TypeError: completion() takes at most 2 positional arguments (3 given)\n**********************************************************************\n```\nThe method `MPolynomialRing_base.completion` lost its `extras` parameter in #23377/#26773, so this method is no longer compatible with other methods...",
    "created_at": "2020-09-01T22:42:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191198",
    "user": "https://github.com/mkoeppe"
}
```

```
File "src/sage/rings/multi_power_series_ring.py", line 504, in sage.rings.multi_power_series_ring.MPowerSeriesRing_generic.construction
Failed example:
    c(R)
Exception raised:
    Traceback (most recent call last):
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 715, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 1139, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.rings.multi_power_series_ring.MPowerSeriesRing_generic.construction[3]>", line 1, in <module>
        c(R)
      File "sage/categories/functor.pyx", line 383, in sage.categories.functor.Functor.__call__ (build/cythonized/sage/categories/functor.c:3146)
        y = self._apply_functor(self._coerce_into_domain(x))
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/categories/pushout.py", line 2456, in _apply_functor
        return R.completion(self.p, self.prec, extras)
      File "sage/rings/polynomial/multi_polynomial_ring_base.pyx", line 184, in sage.rings.polynomial.multi_polynomial_ring_base.MPolynomialRing_base.completion (build/cythonized/sage/rings/polynomial/multi_polynomial_ring_base.c:5003)
        def completion(self, names, prec=20):
    TypeError: completion() takes at most 2 positional arguments (3 given)
**********************************************************************
```
The method `MPolynomialRing_base.completion` lost its `extras` parameter in #23377/#26773, so this method is no longer compatible with other methods...



---

archive/issue_comments_191199.json:
```json
{
    "body": "```\n$ git grep 'def completion('\nsrc/sage/combinat/finite_state_machine.py:    def completion(self, sink=None):\nsrc/sage/rings/function_field/function_field.py:    def completion(self, place, name=None, prec=None, gen_name=None):\nsrc/sage/rings/integer_ring.pyx:    def completion(self, p, prec, extras = {}):\nsrc/sage/rings/number_field/number_field.py:    def completion(self, p, prec, extras={}):\nsrc/sage/rings/polynomial/laurent_polynomial_ring.py:    def completion(self, p, prec=20, extras=None):\nsrc/sage/rings/polynomial/multi_polynomial_ring_base.pyx:    def completion(self, names, prec=20):\nsrc/sage/rings/polynomial/polynomial_ring.py:    def completion(self, p, prec=20, extras=None):\nsrc/sage/rings/qqbar.py:    def completion(self, p, prec, extras={}):\nsrc/sage/rings/qqbar.py:    def completion(self, p, prec, extras={}):\nsrc/sage/rings/rational_field.py:    def completion(self, p, prec, extras = {}):\n```",
    "created_at": "2020-09-01T22:51:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191199",
    "user": "https://github.com/mkoeppe"
}
```

```
$ git grep 'def completion('
src/sage/combinat/finite_state_machine.py:    def completion(self, sink=None):
src/sage/rings/function_field/function_field.py:    def completion(self, place, name=None, prec=None, gen_name=None):
src/sage/rings/integer_ring.pyx:    def completion(self, p, prec, extras = {}):
src/sage/rings/number_field/number_field.py:    def completion(self, p, prec, extras={}):
src/sage/rings/polynomial/laurent_polynomial_ring.py:    def completion(self, p, prec=20, extras=None):
src/sage/rings/polynomial/multi_polynomial_ring_base.pyx:    def completion(self, names, prec=20):
src/sage/rings/polynomial/polynomial_ring.py:    def completion(self, p, prec=20, extras=None):
src/sage/rings/qqbar.py:    def completion(self, p, prec, extras={}):
src/sage/rings/qqbar.py:    def completion(self, p, prec, extras={}):
src/sage/rings/rational_field.py:    def completion(self, p, prec, extras = {}):
```



---

archive/issue_comments_191200.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-01T23:06:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191200",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191201.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-01T23:50:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191201",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191202.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-01T23:52:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191202",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191203.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-02T00:37:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191203",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191204.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-02T00:44:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191204",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191205.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-09-02T01:19:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191205",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_191206.json:
```json
{
    "body": "Help with fixing the remaining failures would be welcome",
    "created_at": "2020-09-02T01:23:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191206",
    "user": "https://github.com/mkoeppe"
}
```

Help with fixing the remaining failures would be welcome



---

archive/issue_comments_191207.json:
```json
{
    "body": "Replying to [comment:91 mkoeppe]:\n> Help with fixing the remaining failures would be welcome\n\n\nHere is an attempt (not really tested)...\n\n---\nNew commits:",
    "created_at": "2020-09-02T17:49:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191207",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:91 mkoeppe]:
> Help with fixing the remaining failures would be welcome


Here is an attempt (not really tested)...

---
New commits:



---

archive/issue_comments_191208.json:
```json
{
    "body": "`src/sage/algebras/free_zinbiel_algebra.py` needs some help",
    "created_at": "2020-09-03T04:07:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191208",
    "user": "https://github.com/mkoeppe"
}
```

`src/sage/algebras/free_zinbiel_algebra.py` needs some help



---

archive/issue_comments_191209.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-03T04:10:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191209",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191210.json:
```json
{
    "body": "A number of those `verbose=True` tests probably are best made `verbose=False` so we don't have this problem.\n\nRight now beta11 is compiling for me. Can you tell me what the problem is with `free_zinbiel_algebra.py` so I know what to start looking for?",
    "created_at": "2020-09-03T04:14:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191210",
    "user": "https://github.com/tscrim"
}
```

A number of those `verbose=True` tests probably are best made `verbose=False` so we don't have this problem.

Right now beta11 is compiling for me. Can you tell me what the problem is with `free_zinbiel_algebra.py` so I know what to start looking for?



---

archive/issue_comments_191211.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-03T04:16:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191211",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191212.json:
```json
{
    "body": "Also relevant: #23010.",
    "created_at": "2020-09-03T04:17:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191212",
    "user": "https://github.com/tscrim"
}
```

Also relevant: #23010.



---

archive/issue_comments_191213.json:
```json
{
    "body": "Replying to [comment:97 tscrim]:\n> Right now beta11 is compiling for me. Can you tell me what the problem is with `free_zinbiel_algebra.py` so I know what to start looking for?\n\n\nOn this ticket: \n\n```\nsage -t --long --random-seed=0 src/sage/algebras/free_zinbiel_algebra.py\n**********************************************************************\nFile \"src/sage/algebras/free_zinbiel_algebra.py\", line 211, in sage.algebras.free_zinbiel_algebra.FreeZinbielAlgebra.__init__\nFailed example:\n    TestSuite(Z).run(elements=[Z.an_element(), G[1], G[1]*G[2]*G[0]])\nExpected nothing\nGot:\n    Failure in _test_construction:\n    Traceback (most recent call last):\n      File \"/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/misc/sage_unittest.py\", line 297, in run\n        test_method(tester=tester)\n      File \"/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/categories/sets_cat.py\", line 1508, in _test_construction\n        FO = self.construction()\n      File \"/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/algebras/free_zinbiel_algebra.py\", line 498, in construction\n        return ZinbielFunctor(self.variable_names()), self.base_ring()\n      File \"sage/structure/category_object.pyx\", line 474, in sage.structure.category_object.CategoryObject.variable_names (build/cythonized/sage/structure/category_object.c:4392)\n        raise ValueError(\"variable names have not yet been set using self._assign_names(...)\")\n    ValueError: variable names have not yet been set using self._assign_names(...)\n    ------------------------------------------------------------\n    The following tests failed: _test_construction\n```",
    "created_at": "2020-09-03T04:18:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191213",
    "user": "https://github.com/mkoeppe"
}
```

Replying to [comment:97 tscrim]:
> Right now beta11 is compiling for me. Can you tell me what the problem is with `free_zinbiel_algebra.py` so I know what to start looking for?


On this ticket: 

```
sage -t --long --random-seed=0 src/sage/algebras/free_zinbiel_algebra.py
**********************************************************************
File "src/sage/algebras/free_zinbiel_algebra.py", line 211, in sage.algebras.free_zinbiel_algebra.FreeZinbielAlgebra.__init__
Failed example:
    TestSuite(Z).run(elements=[Z.an_element(), G[1], G[1]*G[2]*G[0]])
Expected nothing
Got:
    Failure in _test_construction:
    Traceback (most recent call last):
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/misc/sage_unittest.py", line 297, in run
        test_method(tester=tester)
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/categories/sets_cat.py", line 1508, in _test_construction
        FO = self.construction()
      File "/home/sagemath/sage-9.1/local/lib/python3.7/site-packages/sage/algebras/free_zinbiel_algebra.py", line 498, in construction
        return ZinbielFunctor(self.variable_names()), self.base_ring()
      File "sage/structure/category_object.pyx", line 474, in sage.structure.category_object.CategoryObject.variable_names (build/cythonized/sage/structure/category_object.c:4392)
        raise ValueError("variable names have not yet been set using self._assign_names(...)")
    ValueError: variable names have not yet been set using self._assign_names(...)
    ------------------------------------------------------------
    The following tests failed: _test_construction
```



---

archive/issue_comments_191214.json:
```json
{
    "body": "Replying to [comment:99 tscrim]:\n> Also relevant: #23010.\n\nSee my comment there -- all commits have already merged apparently",
    "created_at": "2020-09-03T04:23:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191214",
    "user": "https://github.com/mkoeppe"
}
```

Replying to [comment:99 tscrim]:
> Also relevant: #23010.

See my comment there -- all commits have already merged apparently



---

archive/issue_comments_191215.json:
```json
{
    "body": "Replying to [comment:93 mmezzarobba]:\n> Here is an attempt (not really tested)...\n> New commits:\n> |                                                                                                                                          |                                                                            |\n> |------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|\n> |[3630d25](https://git.sagemath.org/sage.git/commit?id=3630d255fe8330c8772eb856a1acdae3749f2101)|`#15223 pass variable names to residue_field() in AlgebraicExtensionFunctor`|\n\n\nI have fixed one bug, but more work is needed because the interface of method `residue_field` is not very consistent:\n\n```\n$ git grep 'def residue_field'\nsrc/sage/categories/discrete_valuation.py:        def residue_field(self):\nsrc/sage/categories/discrete_valuation.py:        def residue_field(self):\nsrc/sage/rings/function_field/function_field.py:    def residue_field(self, place, name=None):\nsrc/sage/rings/function_field/function_field.py:    def residue_field(self, place, name=None):\nsrc/sage/rings/function_field/place.py:    def residue_field(self, name=None):\nsrc/sage/rings/function_field/place.py:    def residue_field(self, name=None):\nsrc/sage/rings/function_field/valuation_ring.py:    def residue_field(self, name=None):\nsrc/sage/rings/ideal.py:    def residue_field(self):\nsrc/sage/rings/integer_ring.pyx:    def residue_field(self, prime, check = True):\nsrc/sage/rings/laurent_series_ring.py:    def residue_field(self):\nsrc/sage/rings/number_field/number_field.py:    def residue_field(self, prime, names=None, check=True):\nsrc/sage/rings/number_field/number_field_ideal.py:    def residue_field(self, names=None):\nsrc/sage/rings/number_field/order.py:    def residue_field(self, prime, names=None, check=False):\nsrc/sage/rings/padics/padic_generic.py:    def residue_field(self):\nsrc/sage/rings/polynomial/ideal.py:    def residue_field(self, names=None, check=True):\nsrc/sage/rings/polynomial/polynomial_ring.py:    def residue_field(self, ideal, names=None):\nsrc/sage/rings/power_series_ring.py:    def residue_field(self):\nsrc/sage/rings/puiseux_series_ring.py:    def residue_field(self):\nsrc/sage/rings/rational_field.py:    def residue_field(self, p, check=True):\nsrc/sage/rings/valuation/valuation_space.py:        def residue_field(self):\n```",
    "created_at": "2020-09-03T04:25:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191215",
    "user": "https://github.com/mkoeppe"
}
```

Replying to [comment:93 mmezzarobba]:
> Here is an attempt (not really tested)...
> New commits:
> |                                                                                                                                          |                                                                            |
> |------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
> |[3630d25](https://git.sagemath.org/sage.git/commit?id=3630d255fe8330c8772eb856a1acdae3749f2101)|`#15223 pass variable names to residue_field() in AlgebraicExtensionFunctor`|


I have fixed one bug, but more work is needed because the interface of method `residue_field` is not very consistent:

```
$ git grep 'def residue_field'
src/sage/categories/discrete_valuation.py:        def residue_field(self):
src/sage/categories/discrete_valuation.py:        def residue_field(self):
src/sage/rings/function_field/function_field.py:    def residue_field(self, place, name=None):
src/sage/rings/function_field/function_field.py:    def residue_field(self, place, name=None):
src/sage/rings/function_field/place.py:    def residue_field(self, name=None):
src/sage/rings/function_field/place.py:    def residue_field(self, name=None):
src/sage/rings/function_field/valuation_ring.py:    def residue_field(self, name=None):
src/sage/rings/ideal.py:    def residue_field(self):
src/sage/rings/integer_ring.pyx:    def residue_field(self, prime, check = True):
src/sage/rings/laurent_series_ring.py:    def residue_field(self):
src/sage/rings/number_field/number_field.py:    def residue_field(self, prime, names=None, check=True):
src/sage/rings/number_field/number_field_ideal.py:    def residue_field(self, names=None):
src/sage/rings/number_field/order.py:    def residue_field(self, prime, names=None, check=False):
src/sage/rings/padics/padic_generic.py:    def residue_field(self):
src/sage/rings/polynomial/ideal.py:    def residue_field(self, names=None, check=True):
src/sage/rings/polynomial/polynomial_ring.py:    def residue_field(self, ideal, names=None):
src/sage/rings/power_series_ring.py:    def residue_field(self):
src/sage/rings/puiseux_series_ring.py:    def residue_field(self):
src/sage/rings/rational_field.py:    def residue_field(self, p, check=True):
src/sage/rings/valuation/valuation_space.py:        def residue_field(self):
```



---

archive/issue_comments_191216.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-09-03T05:25:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191216",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_191217.json:
```json
{
    "body": "Replying to [comment:102 mkoeppe]:\n> I have fixed one bug,\n\n\nUh, I said I had not really tested my patches, but I thought I had run the tests from the few most relevant files, sorry.\n\n> but more work is needed because the interface of method `residue_field` is not very consistent:\n\n\nIt is not clear to me on what kinds of objects this functor can be called with `residue != None`. It may be good enough for this ticket to take care of the cases that currently work...",
    "created_at": "2020-09-05T07:01:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191217",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:102 mkoeppe]:
> I have fixed one bug,


Uh, I said I had not really tested my patches, but I thought I had run the tests from the few most relevant files, sorry.

> but more work is needed because the interface of method `residue_field` is not very consistent:


It is not clear to me on what kinds of objects this functor can be called with `residue != None`. It may be good enough for this ticket to take care of the cases that currently work...



---

archive/issue_comments_191218.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-05T07:21:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191218",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191219.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-09-05T07:22:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191219",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_191220.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-05T09:00:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191220",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191221.json:
```json
{
    "body": "`@`dkrenn: Commit \u200be664f08 fixes an issue with the uniqueness of cartesian product asymptotic growth groups. My fix is a bit fragile, do you have a better idea?",
    "created_at": "2020-09-05T09:02:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191221",
    "user": "https://github.com/mezzarobba"
}
```

`@`dkrenn: Commit ​e664f08 fixes an issue with the uniqueness of cartesian product asymptotic growth groups. My fix is a bit fragile, do you have a better idea?



---

archive/issue_comments_191222.json:
```json
{
    "body": "Replying to [comment:110 mmezzarobba]:\n> `@`dkrenn: Commit b6b012b fixes an issue with the uniqueness of cartesian product asymptotic growth groups. My fix is a bit fragile, do you have a better idea?\n\n\nHmm, actually, we have the same issue with `CartesianProductPoset` itself. So I think we need a factory for them, and that's where the normalization of the category should go. But `CartesianProductPoset` can depend on arbitrary functions. I suppose one would like to ensure uniqueness at least for the standard orderings, even if posets with custom orderings are all distinct. I'm not sure how to do that best; using `UniqueFactory`, the code will be a bit unwieldy.",
    "created_at": "2020-09-05T10:02:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191222",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:110 mmezzarobba]:
> `@`dkrenn: Commit b6b012b fixes an issue with the uniqueness of cartesian product asymptotic growth groups. My fix is a bit fragile, do you have a better idea?


Hmm, actually, we have the same issue with `CartesianProductPoset` itself. So I think we need a factory for them, and that's where the normalization of the category should go. But `CartesianProductPoset` can depend on arbitrary functions. I suppose one would like to ensure uniqueness at least for the standard orderings, even if posets with custom orderings are all distinct. I'm not sure how to do that best; using `UniqueFactory`, the code will be a bit unwieldy.



---

archive/issue_comments_191223.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-09-05T10:03:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191223",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_191224.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-05T23:24:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191224",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191225.json:
```json
{
    "body": "To fix failures like the one in `src/sage/combinat/symmetric_group_algebra.py`, we also need to give `AlgebraFunctor` and `GroupAlgebraFunctor` a category argument.\n\nDo we already have a forgetful functor somewhere that can take care of such things by composing?",
    "created_at": "2020-09-06T00:29:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191225",
    "user": "https://github.com/mkoeppe"
}
```

To fix failures like the one in `src/sage/combinat/symmetric_group_algebra.py`, we also need to give `AlgebraFunctor` and `GroupAlgebraFunctor` a category argument.

Do we already have a forgetful functor somewhere that can take care of such things by composing?



---

archive/issue_comments_191226.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-06T00:38:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191226",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191227.json:
```json
{
    "body": "Replying to [comment:100 mkoeppe]:\n> Replying to [comment:97 tscrim]:\n> > Right now beta11 is compiling for me. Can you tell me what the problem is with `free_zinbiel_algebra.py` so I know what to start looking for?\n\n\nMinimal example:\n\n```\nsage: algebras.FreeZinbiel(QQ, ZZ).construction()                                                                                               \nValueError: variable names have not yet been set using self._assign_names(...)\n```",
    "created_at": "2020-09-06T00:59:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191227",
    "user": "https://github.com/mkoeppe"
}
```

Replying to [comment:100 mkoeppe]:
> Replying to [comment:97 tscrim]:
> > Right now beta11 is compiling for me. Can you tell me what the problem is with `free_zinbiel_algebra.py` so I know what to start looking for?


Minimal example:

```
sage: algebras.FreeZinbiel(QQ, ZZ).construction()                                                                                               
ValueError: variable names have not yet been set using self._assign_names(...)
```



---

archive/issue_comments_191228.json:
```json
{
    "body": "To fix the failures in `src/sage/matrix/matrix_gap.pyx`, we would need to store `implementation` in `MatrixFunctor`.",
    "created_at": "2020-09-06T05:35:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191228",
    "user": "https://github.com/mkoeppe"
}
```

To fix the failures in `src/sage/matrix/matrix_gap.pyx`, we would need to store `implementation` in `MatrixFunctor`.



---

archive/issue_comments_191229.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-10T23:33:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191229",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191230.json:
```json
{
    "body": "Thank you. Sorry for taking a week to get to this.\n\nSo the problem is the extension of the free Zinbiel algebra to the infinite number of variables but the `construction()` was only implemented for the finite case. I have fixed this and some other minor things with the construction functor for handling infinite number of variables.",
    "created_at": "2020-09-10T23:34:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191230",
    "user": "https://github.com/tscrim"
}
```

Thank you. Sorry for taking a week to get to this.

So the problem is the extension of the free Zinbiel algebra to the infinite number of variables but the `construction()` was only implemented for the finite case. I have fixed this and some other minor things with the construction functor for handling infinite number of variables.



---

archive/issue_comments_191231.json:
```json
{
    "body": "Replying to [comment:114 mkoeppe]:\n> To fix failures like the one in `src/sage/combinat/symmetric_group_algebra.py`, we also need to give `AlgebraFunctor` and `GroupAlgebraFunctor` a category argument.\n> \n> Do we already have a forgetful functor somewhere that can take care of such things by composing?\n\n\nSort of, there is the `ForgetfulFunction_generic` in `categories/functor.pyx`. You probably will need to implement a subclass of that for this purpose.",
    "created_at": "2020-09-13T02:11:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191231",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:114 mkoeppe]:
> To fix failures like the one in `src/sage/combinat/symmetric_group_algebra.py`, we also need to give `AlgebraFunctor` and `GroupAlgebraFunctor` a category argument.
> 
> Do we already have a forgetful functor somewhere that can take care of such things by composing?


Sort of, there is the `ForgetfulFunction_generic` in `categories/functor.pyx`. You probably will need to implement a subclass of that for this purpose.



---

archive/issue_comments_191232.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-14T18:48:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191232",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_191233.json:
```json
{
    "body": "Proposing to take care of the remaining failures in a follow-up ticket.",
    "created_at": "2020-09-14T18:49:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191233",
    "user": "https://github.com/mkoeppe"
}
```

Proposing to take care of the remaining failures in a follow-up ticket.



---

archive/issue_comments_191234.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-09-14T18:49:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191234",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_191235.json:
```json
{
    "body": "I am happy with that and the rest of the changes. Anyone else have any objections?",
    "created_at": "2020-09-15T03:46:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191235",
    "user": "https://github.com/tscrim"
}
```

I am happy with that and the rest of the changes. Anyone else have any objections?



---

archive/issue_comments_191236.json:
```json
{
    "body": "Replying to [comment:123 tscrim]:\n> I am happy with that and the rest of the changes. Anyone else have any objections?\n\n\nNo, I was going to make the same suggestion as Matthias.",
    "created_at": "2020-09-15T06:08:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191236",
    "user": "https://github.com/mezzarobba"
}
```

Replying to [comment:123 tscrim]:
> I am happy with that and the rest of the changes. Anyone else have any objections?


No, I was going to make the same suggestion as Matthias.



---

archive/issue_comments_191237.json:
```json
{
    "body": "Replying to [comment:123 tscrim]:\n> I am happy with that and the rest of the changes. \n\nFor completeness, I have reviewed your changes to the Zinbiel construction functor.",
    "created_at": "2020-09-15T06:26:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191237",
    "user": "https://github.com/mkoeppe"
}
```

Replying to [comment:123 tscrim]:
> I am happy with that and the rest of the changes. 

For completeness, I have reviewed your changes to the Zinbiel construction functor.



---

archive/issue_comments_191238.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-09-15T06:26:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191238",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_191239.json:
```json
{
    "body": "Follow-up in #30574",
    "created_at": "2020-09-15T06:30:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191239",
    "user": "https://github.com/mkoeppe"
}
```

Follow-up in #30574



---

archive/issue_comments_191240.json:
```json
{
    "body": "Is #30507 really a dependency? If not, we should remove it so this gets picked up into Sage.",
    "created_at": "2020-09-21T23:25:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191240",
    "user": "https://github.com/tscrim"
}
```

Is #30507 really a dependency? If not, we should remove it so this gets picked up into Sage.



---

archive/issue_comments_191241.json:
```json
{
    "body": "It isn't - thanks for catching this",
    "created_at": "2020-09-21T23:26:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191241",
    "user": "https://github.com/mkoeppe"
}
```

It isn't - thanks for catching this



---

archive/issue_events_044006.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2020-09-27T09:09:57Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15223#event-44006"
}
```



---

archive/issue_comments_191242.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2020-09-27T09:09:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15223",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15223#issuecomment-191242",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
