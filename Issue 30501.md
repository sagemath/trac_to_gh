# Issue 30501: Replace custom test discovery by pytest

Issue created by migration from https://trac.sagemath.org/ticket/30738

Original creator: @tobiasdiez

Original creation time: 2020-10-07 18:06:19

CC:  mkoeppe tscrim nthiery slelievre

Currently, the sage code contains `_test_xyz` methods that are invoked via doctests and discovered via a custom `TestSuit` class. In this ticket, we are proposing to replace this custom designed test discovery by using the established pytest framework https://docs.pytest.org/ (this is inline with #28936 - using mainstraim Python test infrastructure).

The changes are as follows:
- Move `_test_xyz` from `module` to new file `test_module`
- Rewrite test using pytest (which is straightforward and more or less only amounts to removing all the custom code involving `self_tester`)
- Remove invoking the `TestSuit` in the doctests
- Instead, add the corresponding test elements as parameterized fixtures for pytest

For the moment, I did this only for one test method in `sets_cat` to illustrate the process.
What is still remaining is to call `pytest` as part of the build process so that the newly added tests are found and checked.

Advantages of this approach:
- Reuse standard test infrastructure instead of a custom test discovery interface (this is a big plus as we do not have to maintain it ourself, especially given the large list of todo's in the TestSuite code)
- With this there also comes better error messages in case a test fails.
- Easier onboarding of new Python developers
- Clear separation of test methods vs production code. For example, the `test_*.py` files can easily be excluded from distribution.
- Good support by IDE (auto completion, test discovery and easier invocation)

Disadvantages of this approach:
- Current developer have to learn the new conventions (files need to be named `test_*.py` and tests methods need to start with `test_`) and pytest
- Tests no longer live in the same file as the code (I would say this is an advantage, but some people may prefer to have them really close together).


What do you think? (Please feel free to add more people to cc if you think they may be interested.)


---

Comment by mkoeppe created at 2020-10-07 18:13:14

Are you aware that the crucial point of our _test methods, in particular those provided in the category framework, is that objects of subclasses run these tests?


---

Comment by @tobiasdiez created at 2020-10-07 18:31:34

Yes, and this structure is also somewhat reflected in the new code as the tests for the subclasses inherit from the general base test class. If I understood the code correctly, then the main purpose of these subclasses (with respect to the tests) is to provide the examples (e.g. using the `example()` convention). This can be archived in a more transparent and cleaner way using parameterized test fixtures of pytest.


---

Comment by mkoeppe created at 2020-10-07 19:10:47

Replying to [comment:3 gh-tobiasdiez]:
> If I understood the code correctly, then the main purpose of these subclasses (with respect to the tests) is to provide the examples (e.g. using the `example()` convention).

No, the category classes provide mixins for dynamically generated classes for all `Parent` and `Element` objects. The `example()` are just additional documentation.


---

Comment by @tobiasdiez created at 2020-10-08 07:05:16

Sure, but that doesn't seem to be important for the tests itself. Take for example the tests in `sets_cat`. Almost all of them simply call `tester.some_elements()` and then run certain assertions against the returned elements. Thus, there is no semantical difference to having one general test method accepting an element as argument, and then testing the elements returned by `some_elements()` using this method. This is exactly what is proposed in this ticket.

One question though: is the purpose of these tests to check that one general implementation is correct for all these examples (e.g `sets_cat` provides a general equality implementation which is checked), or that the subclasses provide an implementation that adheres to general principles (e.g. `finitely_generated_semigroups` provides an implementation of equality that is checked). Just so that I know where to best place these tests (test_sets_cat vs test_finitely_generated_semigroups).


---

Comment by mkoeppe created at 2020-10-08 16:22:42

Replying to [comment:5 gh-tobiasdiez]:
> One question though: is the purpose of these tests to check that one general implementation is correct for all these examples (e.g `sets_cat` provides a general equality implementation which is checked), or that the subclasses provide an implementation that adheres to general principles (e.g. `finitely_generated_semigroups` provides an implementation of equality that is checked).
The latter.


---

Comment by @tobiasdiez created at 2020-10-08 16:45:33

Thanks, I thought so too. Then the current file structure should be right.
Should I go ahead and convert the other test methods to pytest as well? (As part of this ticket, or open a new ticket for every method?)


---

Comment by mkoeppe created at 2020-10-08 17:45:46

I do not know enough about pytest. Can you expand the ticket description to explain how the test discovery works after the ticket, and how it ensures that still the same things get tested?


---

Comment by @tobiasdiez created at 2020-10-24 20:59:10

Changing status from new to needs_review.


---

Comment by @tobiasdiez created at 2020-10-24 21:01:21

I've extended the ticket description. Does this clarify your questions?

The test `test_element_eq_reflexive` (and other similar tests to be added) are invoked for each element of `test_elements`. Thus, by adding all the instances currently covered by the unit tests we make sure that the test coverage stays the same.


---

Comment by mkoeppe created at 2020-10-24 21:31:09

Sorry, I still don't get it. The branch as it is on the ticket - do you claim that it still tests the same objects as before?


---

Comment by @tobiasdiez created at 2020-10-24 21:54:21

If you run `pytest` on this branch, it invokes `test_elements_eq_reflexive` with the arguments `['a', 'b', 'c', 'ab', 'ac', 'ba', 'bc', 'ca', 'cb', 'abc']`. 
This is the same as the doctest for `finite_semigroups`:


```
Now, let us look at the structure of the semigroup::

        sage: S = FiniteSemigroups().example(alphabet = ('a','b','c'))
        sage: S.cayley_graph(side="left", simple=True).plot()
        Graphics object consisting of 60 graphics primitives
        sage: S.j_transversal_of_idempotents() # random (arbitrary choice)
        ['acb', 'ac', 'ab', 'bc', 'a', 'c', 'b']

    We conclude by running systematic tests on this semigroup::

        sage: TestSuite(S).run(verbose = True)
        running ._test_an_element() . . . pass
        running ._test_associativity() . . . pass
        running ._test_cardinality() . . . pass
        running ._test_category() . . . pass
        running ._test_construction() . . . pass
        running ._test_elements() . . .
          Running the test suite of self.an_element()
          running ._test_category() . . . pass
          running ._test_eq() . . . pass
          running ._test_new() . . . pass
          running ._test_not_implemented_methods() . . . pass
          running ._test_pickling() . . . pass
          pass
        running ._test_elements_eq_reflexive() . . . pass
        running ._test_elements_eq_symmetric() . . . pass
        running ._test_elements_eq_transitive() . . . pass
        running ._test_elements_neq() . . . pass
        running ._test_enumerated_set_contains() . . . pass
        running ._test_enumerated_set_iter_cardinality() . . . pass
        running ._test_enumerated_set_iter_list() . . . pass
        running ._test_eq() . . . pass
        running ._test_new() . . . pass
        running ._test_not_implemented_methods() . . . pass
        running ._test_pickling() . . . pass
        running ._test_some_elements() . . . pass
```

So the idea would be to replace this doctest by `pytest`. There are a few more doctests of this form that can be replaced in a similar vain by adding the corresponding elements to the `test_elements` list.


---

Comment by mkoeppe created at 2020-10-24 22:01:42

Replying to [comment:13 gh-tobiasdiez]:
> There are a few more doctests of this form that can be replaced in a similar vain by adding the corresponding elements to the `test_elements` list.

A few? Currently `_test_elements_eq_reflexive` is invoked by `TestSuite(object).run()` whenever `object` happens to be in the category of sets. This is a huge, dynamically determined list.


---

Comment by @tobiasdiez created at 2020-10-24 22:20:27

Sure, there are quite a lot of instances where a `TestSuite` is run from the doctest. Each one would need to be replaced by a test file similar to `test_finite_semigroups.py`. Pytest is not a magician and the information which examples to test still needs to be provided.

So the replacement dictionary roughly speaking looks like:
- `TestSuite` -> `pytest`
- `TestSuite(S).run(verbose = True)` -> ``@`pytest.fixture(params=S)`

The idea is not to change the way the tests cases are provided (although that may certainly be improved in the future) but to replace sage's only implementation of test discovery and invocation by what is probably the most establish Python testing framework.


---

Comment by mkoeppe created at 2020-10-24 22:29:11

So in your design, there would be a hierarchy of `Tests` classes parallel to the hierarchy of, say, parent classes in sage?


---

Comment by @tobiasdiez created at 2020-10-24 22:44:40

Yes! Every parent class would have a corresponding test class which specifies which general axioms this parent class wants to adhere to. This is done by deriving from one or more generic test classes (the one in the branch should probably be renamed to `GenericSetTests`).


---

Comment by mkoeppe created at 2020-10-24 22:45:46

Okay, but the parent classes are dynamic classes formed by mixing in axioms.
So the test classes would also be determined dynamically?


---

Comment by mkoeppe created at 2020-10-24 22:55:46

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2020-10-24 22:55:46

Replying to [comment:15 gh-tobiasdiez]:
> here are quite a lot of instances where a `TestSuite` is run from the doctest. Each one would need to be replaced by a test file similar to `test_finite_semigroups.py`. Pytest is not a magician and the information which examples to test still needs to be provided.

Thanks for this clarification. I'm setting this ticket to "needs_work" because the branch in this form is not complete -- it effectively removes existing tests for  `_test_elements_eq_reflexive`. Without a much more complete branch that reaches test parity, this idea is difficult to evaluate.

Overall I think there is a conflict here between the dynamic nature of our category system and what seems to amount to a static determination of what objects to test for what properties (in the proposed changes).


---

Comment by @tobiasdiez created at 2020-10-24 23:00:06

I'm not that familiar yet with the category framework. When you say "dynamic classes formed by mixing in axioms" you mean something like `Parent.__init__(self, category = Semigroups().Finite().FinitelyGenerated())`? But, in general, yes the idea is to mixin the tests. I don't see any reason why this couldn't be done dynamically.

I agree, this branch has not yet feature parity with the master branch. Before I invest more time into it, I just wanted to confirm that this idea would be worth looking at in general.


---

Comment by mkoeppe created at 2020-10-24 23:05:49

Replying to [comment:20 gh-tobiasdiez]:
> When you say "dynamic classes formed by mixing in axioms" you mean something like `Parent.__init__(self, category = Semigroups().Finite().FinitelyGenerated())`?

Yes, things like this.


---

Comment by git created at 2020-11-08 12:53:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-11-08 13:15:20

Thanks for the input. I've now reworked the code completely. The generic category tests are now dynamically mixed in the test class. The new approach is explained in the ticket description in more detail. The upshot is that it is very easy to add new generic test methods (simply add them to the category test class, e.g. `test_sets_cat`) and to add new examples (simply create a new test class implementing `category_instances`).


---

Comment by @tobiasdiez created at 2020-11-08 13:15:20

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2020-12-05 18:30:31

It's really hard to see from this ticket how this is intended to go.

The previous version that I reviewed was removing existing doctests and reimplementing a small subset of them using pytest.

Now the new version is only adding some new tests using pytest that seem to duplicate some existing tests run by the doctest framework.


---

Comment by mkoeppe created at 2020-12-05 18:30:31

Changing status from needs_review to needs_work.


---

Comment by @tobiasdiez created at 2020-12-05 20:42:33

The current version is meant as a starting point for discussion whether this approach is ok.  So it is a fully working prototype that indeed reimplements a subset of the current category framework tests, and is flexible enough to be extended to cover everything.
Getting full parity with the current category tests needs a bit of work by extending `test_sets_cat` with the remaining test functions.

I'm not sure what I should do now. The only open point is that pytest needs to be run during the normal test run (on user systems as well as on the ci pipeline). But that's not really the purpose of this ticket. I think, it's clear that one cannot reimplement the complete category tests in one ticket, so this is why I opted for a minimal version. What is your proposal to proceed from here?


---

Comment by @tobiasdiez created at 2020-12-20 22:42:37

Feedback/review still needed.


---

Comment by @tobiasdiez created at 2020-12-20 22:42:37

Changing status from needs_work to needs_review.


---

Comment by mkoeppe created at 2020-12-21 01:37:29

Replying to [comment:25 gh-tobiasdiez]:
> Getting full parity with the current category tests needs a bit of work by extending `test_sets_cat` with the remaining test functions.

But even for the test function that you already added, it is only testing a few objects.

So to get parity even for this one test function, `category_instances` would have to be extended vastly -- if I understand the design correctly.

It is unclear who should do this work and why.


---

Comment by @tobiasdiez created at 2020-12-21 11:14:36

I've now vastly extended the tests, and replaced some of the TestSuite calls by pytest. A handful of test methods are still missing to get full feature parity (will do this later), but I hope the idea and design get clearer now (at the cost that there are bigger changes).

The following change is characteristic for the aim of migrating from Sage's custom TestSuite framework to pytest:

```
-        sage: TestSuite(C).run()
+        sage: import pytest
+        sage: pytest.main(["-r", "test_finite_semigroups.py"])
```

(calling pytest from the doctests is only a temporary work-around until it's properly integrated into the build chain)


---

Comment by git created at 2020-12-21 11:14:59

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by mkoeppe created at 2020-12-21 18:16:29

Replying to [comment:27 mkoeppe]:
> But even for the test function that you already added, it is only testing a few objects.
> 
> So to get parity even for this one test function, `category_instances` would have to be extended vastly -- if I understand the design correctly.

These changes do not seem to address the above comment? You added more test functions, instead of showing how one would achieve parity for what one test function covers. Or maybe I'm misunderstanding.


---

Comment by @tobiasdiez created at 2020-12-21 20:26:28

I guess there are two ways for migration:
- Replace one test in the category framework by a pytest, and then make sure that this test is invoked for every example. Do this again for every test.
- Duplicate all tests in the category framework using pytest, and then replace one `TestSuite(...).run` statement by its pytest equivalent. Do this again for every test invocation.

Since there are only a small number of tests (order of 10) but way more examples (order of 1000), my idea was follow the second approach since this can be done easier in steps.

Of course, the complete migration is quite a huge project. This ticket was meant to as a starting point.

The advantages I see of pytest over a custom testsuite implementation are in the ticket description.


---

Comment by mkoeppe created at 2020-12-23 19:25:09

If I understand the proposed design correctly, for each category you would manually maintain a list of category instances to test. To me this seems like a huge step backward: The categories of an object are computed dynamically - and thus all test methods that come with the categories are run.


---

Comment by mkoeppe created at 2020-12-23 19:25:41

(Feel free to add this to "disadvantages of the approach" in the ticket description.)


---

Comment by mkoeppe created at 2020-12-23 19:27:35

From "advantages" in the ticket description:
> Clear separation of test methods vs production code. For example, the test_*.py files can easily be excluded from distribution.
We definitely would not want to exclude them from the distribution! Also user-defined classes will want to run the test methods that are provided by the categories as part of their tests.


---

Comment by mkoeppe created at 2020-12-23 19:29:05

Could you elaborate on this in the ticket description:
> Good support by IDE (auto completion, test discovery and easier invocation)


---

Comment by @tobiasdiez created at 2020-12-23 19:37:41

Replying to [comment:33 mkoeppe]:
> If I understand the proposed design correctly, for each category you would manually maintain a list of category instances to test.

Yes, but that's not different from the current code. There you also create the examples and then run the testsuite (which makes sure to run the correct tests for this category). This is the same in the proposed design, except that you now define the examples in the test file. I would even argue that the proposed design is more flexible and makes it very transparent which examples are used to test a given category.


---

Comment by @tobiasdiez created at 2020-12-23 19:39:55

Replying to [comment:36 mkoeppe]:
> Could you elaborate on this in the ticket description:
> > Good support by IDE (auto completion, test discovery and easier invocation)

Done.


---

Comment by @tobiasdiez created at 2020-12-23 19:43:56

Replying to [comment:35 mkoeppe]:
> From "advantages" in the ticket description:
> > Clear separation of test methods vs production code. For example, the test_*.py files can easily be excluded from distribution.
> We definitely would not want to exclude them from the distribution! Also user-defined classes will want to run the test methods that are provided by the categories as part of their tests.

Probably depends on the context. People using sagelib only as a (calculation) library may not need these tests. One could for example easily split them out into a new sage.testing package (or sage.categories.testing) once everything is modularized nicely.


---

Comment by mkoeppe created at 2020-12-23 19:47:58

Replying to [comment:37 gh-tobiasdiez]:
> Replying to [comment:33 mkoeppe]:
> > If I understand the proposed design correctly, for each category you would manually maintain a list of category instances to test.
> 
> Yes, but that's not different from the current code. There you also create the examples and then run the testsuite (which makes sure to run the correct tests for this category). This is the same in the proposed design, except that you now define the examples in the test file.

I think you may be missing that the category of an object is not statically known but is computed by code.


---

Comment by @tobiasdiez created at 2020-12-23 19:51:51

No, I'm not. The `test_some_category.py` says only "please check the category tests for the following examples" and pytest automatically determines based on the category of these examples which tests to run. In fact, the latter is done here

```
+def pytest_pycollect_makeitem(collector: PyCollector, name: str, obj: type):
+    if inspect.isclass(obj) and "category_instances" in dir(obj):
+        # Enrich test class by functions from the corresponding category test class
+        for category, category_test_class in categories_with_tests.items():
+            if category() in obj.category_instances()[0].category().all_super_categories():
+                methods= [method for method in dir(category_test_class)
+                        if not method.startswith('__') and callable(getattr(category_test_class, method))]
+            
+                for method in methods:
+                    setattr(obj, method, getattr(category_test_class, method))
+
+        return pytest.Class.from_parent(collector, name=name, obj=obj)
+    else:
+        return None
```



---

Comment by mkoeppe created at 2020-12-23 19:59:27

OK, but how is this compatible with your design to list the test objects in `category_instances`?


---

Comment by @tobiasdiez created at 2020-12-23 20:11:18

The design is as follows. Say you have a category `LieGroups` combining the categories `Manifolds` and `Groups`.
Then you:
1. Create `manifolds_test` and `groups_test` files, specifying the category tests that should hold for all objects of this category.
2. Create a `liegroups_test` file, specifying in `category_instances` the examples of Lie groups you want to test, say `SO(3)` and `SU(2)`. Moreover, add test methods that are particular for the cateogory of Lie groups.

When run, the code then looks at these examples, determines that they are objects of the categories Manifolds, Groups and Lie Groups and collects all tests from `manifolds_test`, `groups_test` and `liegroups_test`.

This can already be seen in action in the code, where the finite semigroups inhert tests from the category of sets and of finite sets.


---

Comment by mkoeppe created at 2020-12-23 20:45:09

So in the end it does not matter at all in which method `category_instances` an object is put?


---

Comment by mkoeppe created at 2020-12-23 20:54:18

Replying to [comment:43 gh-tobiasdiez]:
> This can already be seen in action in the code, where the finite semigroups inhert tests from the category of sets and of finite sets.

But having `test_associativity` supplied by `TestFiniteSemigroup` surely can't be the final design?!


---

Comment by @tobiasdiez created at 2020-12-23 21:06:46

Replying to [comment:44 mkoeppe]:
> So in the end it does not matter at all in which method `category_instances` an object is put?

No, it doesn't really matter. One could also have one big test file listing all these examples. But I would advocate to have one test file for each category, because then one can easily also write additional tests (not related to the category framework). It's also consistent with the usual conventions where one usually has one test file for each module file.


---

Comment by @tobiasdiez created at 2020-12-23 21:09:29

Replying to [comment:45 mkoeppe]:
> But having `test_associativity` supplied by `TestFiniteSemigroup` surely can't be the final design?!

I think this was a mistake on my side, it should be in a new test file for the "Semigroup" category.


---

Comment by mkoeppe created at 2020-12-23 21:28:55

Replying to [comment:46 gh-tobiasdiez]:
> Replying to [comment:44 mkoeppe]:
> > So in the end it does not matter at all in which method `category_instances` an object is put?
> 
> No, it doesn't really matter. One could also have one big test file listing all these examples. 

OK, this is an important clarification, thanks.

> But I would advocate to have one test file for each category, because then one can easily also write additional tests (not related to the category framework). 

Would it not be better to have one test file for each module (... whose doctest currently has calls to `TestSuite`)? I really don't see what is gained by grouping the test objects by category -- which is coarser than how things are grouped currently (i.e., by module) and also arbitrary (because for join categories you would be making an arbitrary choice into which test file to put an object).


---

Comment by @tobiasdiez created at 2020-12-23 21:48:54

Replying to [comment:48 mkoeppe]:
> Would it not be better to have one test file for each module (... whose doctest currently has calls to `TestSuite`)? I really don't see what is gained by grouping the test objects by category -- which is coarser than how things are grouped currently (i.e., by module) and also arbitrary (because for join categories you would be making an arbitrary choice into which test file to put an object).
> 

It depends on what you want to test. If you want to test that the implementation of the category is correct, you put it in the test file of the category. If you want to test the implementation of an example, you put it in the test file of the example.


---

Comment by nthiery created at 2020-12-23 22:37:52

Hello!

Thanks for bringing me in the conversation. It's been
ten years since I designed TestSuite (with the help
from many). Since that time, Python and the available
testing tools have evolved a lot. I am
glad to see efforts going into rethinking the design
in this new context, questioning the implementation,
and studying alternatives that would reach the
same design goals but better suit the context.
Especially toward using
now standard infrastructure and practice to reduce
both the technical debt and the entry barrier for
new devs and/or for integration with other software.


---

Comment by nthiery created at 2020-12-23 22:58:49

(the rant may be a bit long, so I am splitting this into several comments).

So, what were these design goals:

(I) Hardening library and user defined algebraic structures, and beyond

The tests are there for checking the internal consistency
of category code and for checking that parents (and their
elements, morphisms, ...) satisfy the specifications of their
categories (e.g. axioms). Supporting user defined algebraic structures is
a must. In my research area we routinely create new algebraic
structures, and when doing so TestSuite is a daily tool:
practice has told me that, once the implementation of
that algebraic structure pass the testsuite, most of the time
it's actually correct (certainly something that is research
area dependent!).

In some cases, it even becomes a research tool: I am not
sure whether the newly defined algebraic structure actually
satisfy the axioms I want it to satisfy, and I use TestSuite
to actually run checks. And use post-mortem instrospection
with the debugger to actually recover the counter examples ot
my conjectures.

The next step in this direction is to work toward merging
the `_test_xxx` methods and `_is_xxx` methods: most of the time,
the code is mostly the same: checking whether axiom xxx is
satisfied. What changes is how thorough the test is, and
how failures are reported. I have toyed around with the idea
with prototypes in sage-semigroups. Alas I never got to actually
converge to a proposal for Sage. But this is something we want
to keep in mind.


---

Comment by tscrim created at 2020-12-23 23:07:08

Something else I want to clarify is that the category examples are generally meant to minimal working examples of what needs to be implemented for a particular category. However, some categories actually use other existing objects in Sage, which is something many of the categories do, but such a WME is not essential to defining a category.


---

Comment by nthiery created at 2020-12-23 23:22:45

(II) Categories as bookshelves of code, documentation and tests

Each category models some algebraic realm. 
Like the bookshelf about Group Theory in a library,
the category of groups in GAP or Sage ties together
everything that applies to all groups: code, documentation,
and tests. In a perfect world where the same system would
be used for computations and proofs, I would include here
mathematical statements (e.g. formulae for the axioms)
and proofs! Then, there are subshelves for group elements,
group morphisms, ... Subshelves for particular types of
groups, and so on.

There are several ways to implement that tying together.
In GAP, categories are a mere filters; each method is
tied to a category through an individual declaration.
And the language uses a bespoke method resolution that
data. In [SageMath](SageMath) instead, we decided to rely on
standard OO method resolution, grouping together methods
in classes. Both approaches have their advantages notably
in terms of flexibility left to organize the code, and
enable user extensions to existing categories.


Two features are required for testing purposes:

(a) Recovering all the tests that one wants to run to check an object in category A

(b) For each of them, resolving which test method is to be called. Indeed, a subcategory may overload a _test_xxx method when, for example, it has a more efficient way to check xxx.


Note that (b) is of the same nature as when resolving a usual method call. It thus seems highly desirable to use the exact same resolution mechanism as for code.


---

Comment by nthiery created at 2020-12-23 23:31:07

(III) Scalability

Nothing much to say here: whatever design is chosen should scale to
the rich hierarchy of categories in [SageMath](SageMath), with all the mantras
(axioms, ...) that were implemented to support that richness.

A critical bit is to satisfy as much as possible the Single Source
Of Truth principle. E.g. if at some point I want to refine the
category of a parent (e.g. because a new category was created),
I should only need to update a single location in the code.


---

Comment by nthiery created at 2020-12-23 23:39:34

Sorry for the rant; I am trying to clarify for myself what
guided -- implicitly or explicitly -- the design back then :-)
Hopefully this is useful food for thought for a redesign.


---

Comment by nthiery created at 2020-12-23 23:44:16

Oh, one piece of information in case it would be relevant: for the longest time
it's been on my pile to instrument TestSuite so that, by running the Sage
tests, one would get a relatively thorough list of all Sage parents together
with their categories.

A typical applications would be to enable inverse lookup: given a category, suggest to the user a relatively thorough list of parents implementing that category; e.g. for documentation purposes.


---

Comment by @tobiasdiez created at 2020-12-24 11:18:30

Oh, that's wonderful feedback! This kind of deep insight is hard to get if you only read the existing code and don't know the story behind it's origin. Thanks a lot for your detailed account.

Please don't take this proposal as a critics of your work on the TestSuite. I was actually amazed when I discovered that Sage has it's own testing framework. The main idea behind this ticket was to outsource the cost of maintenance of such a framework to the broader Python community, so that we can focus on the math-related elements.

Concerning your points, I'm happy to report that the proposed design should fit all the points you mentioned. In short:

(I): It is flexible enough to accommodate new user-defined categories and examples.

(II): It relies on pytest's discovery mechanism, which makes it very transparent which tests are run for a given category object.

(III): Scalability is a bit hard to judge for me, since I'm not that familiar with all the possible edge cases. But so far I had no problems migrating the existing code.
In particular, the "single source of truth principle" applies, since the testing code only relies on the calculated super categories.


Hence, I would like to invite you to play around with the new design and see if it's works for your use cases. Basic documentation about pytest is added in #31003. Let me know if you encounter any problems.

Merry Christmas!


---

Comment by @kliem created at 2020-12-29 09:25:59

Red branch.


---

Comment by @kliem created at 2020-12-29 09:25:59

Changing status from needs_review to needs_work.


---

Comment by git created at 2020-12-29 10:15:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-12-29 10:15:55

New commits:


---

Comment by @tobiasdiez created at 2020-12-29 10:15:55

Changing status from needs_work to needs_review.


---

Comment by git created at 2020-12-29 10:20:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2020-12-29 10:21:33

Merged develop branch and removed the (unnecessary) dependencies.


---

Comment by mkoeppe created at 2021-03-15 22:07:04

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by chapoton created at 2021-07-13 13:15:19

red branch => needs work


---

Comment by chapoton created at 2021-07-13 13:15:19

Changing status from needs_review to needs_work.


---

Comment by @tobiasdiez created at 2021-11-28 17:42:25

Changing status from needs_work to needs_review.


---

Comment by @tobiasdiez created at 2021-11-28 17:42:25

Rebased, so ready-for-review again.


---

Comment by git created at 2021-11-28 17:42:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-11-28 17:46:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by slelievre created at 2021-12-09 23:10:06

Changing keywords from "" to "testsuite".


---

Comment by @tobiasdiez created at 2022-02-23 21:54:47

Why did you change the milestone? I don't see anything that would prevent this being merged soon (except for the missing review).


---

Comment by mkoeppe created at 2022-02-23 23:50:29

There's been no activity, and it's not clear if there are any developers who would be interested in rewriting the entirety of our test suite.


---

Comment by @tobiasdiez created at 2022-03-20 17:22:01

While being a relatively huge project, I think, a completely migration can be done in a relatively straightforward way with an overseeable time investment. I would definitely up for doing this alone if necessary. So I'm appreciate if this ticket could be reviewed soon. Thanks!


---

Comment by mkoeppe created at 2022-03-21 23:52:41

You have received review comments: comment:45, comment:48, etc.


---

Comment by git created at 2022-03-29 12:51:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @tobiasdiez created at 2022-03-29 13:13:58

Replying to [comment:77 mkoeppe]:
> You have received review comments: comment:45, comment:48, etc. 
> 

I've fixed comment:45. To comment:48 I've already reacted in comment:49.


---

Comment by git created at 2022-04-08 21:28:18

Branch pushed to git repo; I updated commit sha1. New commits:
