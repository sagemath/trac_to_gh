# Issue 19594: Add random_element() for cones

Issue created by migration from https://trac.sagemath.org/ticket/19831

Original creator: mjo

Original creation time: 2016-01-04 17:04:09

CC:  novoselt

For testing and demonstration it's sometimes useful to be able to get "any" element of a cone. Other structures use `random_element` for the same purpose.



---

Comment by mjo created at 2016-01-04 17:17:23

New commits:


---

Comment by mjo created at 2016-01-04 17:17:23

Changing status from new to needs_review.


---

Comment by novoselt created at 2016-01-05 04:33:37

In the end comment "coercion" is not the right word - it is what happens automatically when mixing objects. Explicit one is "conversion".

I am a bit unsure about rationality. Seems like returning a random element of the lattice would be more natural and those who want can then scale by a rational or even real factor. Or there could be an optional parameter for this, defaulting to all integral weights?


---

Comment by git created at 2016-01-05 14:18:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2016-01-05 14:44:38

Replying to [comment:2 novoselt]:
> I am a bit unsure about rationality. Seems like returning a random element of the lattice would be more natural and those who want can then scale by a rational or even real factor.

This wouldn't be too bad but it makes all of my uses of it ugly. Each invocation is `K.random_element()` versus `QQ.random_element().abs()*vector(K.random_element())`.

I'm using rationals because some of the properties I'm testing involve norms (say, in a denominator) where you really want to test a value between zero and one.

> Or there could be an optional parameter for this, defaulting to all integral weights?

This would be no problem, but how should the return type work? If we use integral weights we could return a lattice element but with any other field it would have to be a vector.


---

Comment by novoselt created at 2016-01-07 05:49:15

Replying to [comment:4 mjo]:
> Replying to [comment:2 novoselt]:
> > Or there could be an optional parameter for this, defaulting to all integral weights?
> 
> This would be no problem, but how should the return type work? If we use integral weights we could return a lattice element but with any other field it would have to be a vector.

I definitely would like to get an appropriate lattice element for (default) integral weights and with anything else a vector is fine, that's consistent with other places that attempt to work with lattices but fall back to generic vectors/modules when this is not possible/implemented.


---

Comment by git created at 2016-01-07 16:51:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2016-01-07 16:59:16

Replying to [comment:5 novoselt]:
> I definitely would like to get an appropriate lattice element for (default) integral weights and with anything else a vector is fine, that's consistent with other places that attempt to work with lattices but fall back to generic vectors/modules when this is not possible/implemented.

That works for me; it only adds two characters to most invocations.

I decided to limit the possible choices to `ZZ`/`QQ` for a few reasons. First, for "nonnegative" to make any sense, we need to have a subthing of `RR`. But `RR.is_subring(RR)` doesn't work, and more importantly, the resulting elements don't live in either the cone's lattice or its ambient vector space. That means matrix multiplication (on the ambient space) might crash even though `K.contains(x)` still returns `True`.

Maybe it makes more sense to have e.g. `latticial=True` instead of `ring=ZZ` when there are only two choices (ambient lattice or ambient vector space)?


---

Comment by novoselt created at 2016-01-08 03:50:01

Replying to [comment:7 mjo]:
> Maybe it makes more sense to have e.g. `latticial=True` instead of `ring=ZZ` when there are only two choices (ambient lattice or ambient vector space)?
That's the first time I hear such a word ;-) In the toric geometry cones live in real vector spaces. The fact that Sage associates a rational and not real one to free modules is just the way how Sage is, in part due to technical reasons of working with reals on computers, I guess. In any case there is no reason why eventually we can't accept any kind of real field with different precision or perhaps some other subrings. So I am more in favour of `NotImplementedError` rather than `ValueError` since `RR`, `RDF` etc are very sensible choices.


---

Comment by git created at 2016-01-08 04:28:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mjo created at 2016-01-08 04:30:45

I made up the word, but it sounds very official =P

`NotImplementedError` is fine with me. My cones are real, too, but nothing works when we use floating point numbers.


---

Comment by novoselt created at 2016-01-11 00:04:54

Thank you!


---

Comment by novoselt created at 2016-01-11 00:04:54

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-01-12 17:03:30

Resolution: fixed
