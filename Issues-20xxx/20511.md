# Issue 20511: Not all empty schemes are created equal

archive/issues_020274.json:
```json
{
    "body": "Keywords: schemes, empty\n\nIn this example, both schemes are empty, so they should be equal as subschemes of P^2. However...\n\n```\nsage: P2.<x,y,z> = ProjectiveSpace(2, QQ)\nsage: P2.subscheme([x,y^2,z]) == P2.subscheme([x,y,z])\nFalse\n```\nWhile I'm at it, an `is_empty` method would be nice. It could be defined as follows:\n\n```\ndef self.is_empty():\n   return (len(self.irreducible_components() == 0)\n```\n\nIssue created by migration from https://trac.sagemath.org/ticket/20511\n\n",
    "created_at": "2016-04-27T20:54:37Z",
    "labels": [
        "component: algebraic geometry",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.2",
    "title": "Not all empty schemes are created equal",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20511",
    "user": "https://github.com/kedlaya"
}
```
Keywords: schemes, empty

In this example, both schemes are empty, so they should be equal as subschemes of P^2. However...

```
sage: P2.<x,y,z> = ProjectiveSpace(2, QQ)
sage: P2.subscheme([x,y^2,z]) == P2.subscheme([x,y,z])
False
```
While I'm at it, an `is_empty` method would be nice. It could be defined as follows:

```
def self.is_empty():
   return (len(self.irreducible_components() == 0)
```

Issue created by migration from https://trac.sagemath.org/ticket/20511





---

archive/issue_comments_279039.json:
```json
{
    "body": "Projective scheme comparison should compare ideals saturated with respect to the irrelevant ideal:\n\n```\nsage: U=P2.subscheme([x,y,z])\nsage: V=P2.subscheme([x,y^2,z])\nsage: J=U.defining_ideal()\nsage: U.defining_ideal().saturation(J)[0] == V.defining_ideal().saturation(J)[0] \nTrue\n```\n\nSimilarly, the `is_empty` should do:\n\n```\nsage: one_ideal= J^0 #just get the ideal generated by 1\nsage: U.defining_ideal().saturation(J)[0] == one_ideal\n```\ndecomposing in irreducible components is a more expensive operation.",
    "created_at": "2016-04-27T22:15:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20511",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20511#issuecomment-279039",
    "user": "https://github.com/nbruin"
}
```

Projective scheme comparison should compare ideals saturated with respect to the irrelevant ideal:

```
sage: U=P2.subscheme([x,y,z])
sage: V=P2.subscheme([x,y^2,z])
sage: J=U.defining_ideal()
sage: U.defining_ideal().saturation(J)[0] == V.defining_ideal().saturation(J)[0] 
True
```

Similarly, the `is_empty` should do:

```
sage: one_ideal= J^0 #just get the ideal generated by 1
sage: U.defining_ideal().saturation(J)[0] == one_ideal
```
decomposing in irreducible components is a more expensive operation.



---

archive/issue_comments_279040.json:
```json
{
    "body": "Replying to [comment:1 nbruin]:\n> Projective scheme comparison should compare ideals saturated with respect to the irrelevant ideal:\n> \n> \n> ```\n> sage: U=P2.subscheme([x,y,z])\n> sage: V=P2.subscheme([x,y^2,z])\n> sage: J=U.defining_ideal()\n> sage: U.defining_ideal().saturation(J)[0] == V.defining_ideal().saturation(J)[0] \n> True\n> ```\n> \nAgreed. I guess we don't want to transform the generating set at creation, so we can recover the generators as specified, but maybe we want to cache the saturation?\n\n> Similarly, the `is_empty` should do:\n> \n> ```\n> sage: one_ideal= J^0 #just get the ideal generated by 1\n> sage: U.defining_ideal().saturation(J)[0] == one_ideal\n> ```\n> decomposing in irreducible components is a more expensive operation.\n\n\nAgreed again.",
    "created_at": "2016-04-27T23:12:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20511",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20511#issuecomment-279040",
    "user": "https://github.com/kedlaya"
}
```

Replying to [comment:1 nbruin]:
> Projective scheme comparison should compare ideals saturated with respect to the irrelevant ideal:
> 
> 
> ```
> sage: U=P2.subscheme([x,y,z])
> sage: V=P2.subscheme([x,y^2,z])
> sage: J=U.defining_ideal()
> sage: U.defining_ideal().saturation(J)[0] == V.defining_ideal().saturation(J)[0] 
> True
> ```
> 
Agreed. I guess we don't want to transform the generating set at creation, so we can recover the generators as specified, but maybe we want to cache the saturation?

> Similarly, the `is_empty` should do:
> 
> ```
> sage: one_ideal= J^0 #just get the ideal generated by 1
> sage: U.defining_ideal().saturation(J)[0] == one_ideal
> ```
> decomposing in irreducible components is a more expensive operation.


Agreed again.



---

archive/issue_comments_279041.json:
```json
{
    "body": "Also note that if we change equality we also have to change the hash, i.e., the hash should be the hash of the generators of the groebner basis of the saturation of the defining ideal. That'll probably shake out another few bugs out of the doctests.",
    "created_at": "2016-04-28T17:25:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20511",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20511#issuecomment-279041",
    "user": "https://github.com/nbruin"
}
```

Also note that if we change equality we also have to change the hash, i.e., the hash should be the hash of the generators of the groebner basis of the saturation of the defining ideal. That'll probably shake out another few bugs out of the doctests.



---

archive/issue_comments_279042.json:
```json
{
    "body": "Speaking of shaking out bugs, here is a first attempt (minus the hash), which already runs into something further afield:\n\n```\nsage -t --warn-long 237.1 src/sage/schemes/hyperelliptic_curves/hyperelliptic_padic_field.py\n**********************************************************************\nFile \"src/sage/schemes/hyperelliptic_curves/hyperelliptic_padic_field.py\", line 809, in sage.schemes.hyperelliptic_curves.hyperelliptic_padic_field.HyperellipticCurve_padic_field.coleman_integral\nFailed example:\n    HK.coleman_integral(w,S,P)\nException raised:\n    Traceback (most recent call last):\n      File \"/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 495, in _run\n        self.compile_and_execute(example, compiler, test.globs)\n      File \"/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 858, in compile_and_execute\n        exec(compiled, globs)\n      File \"<doctest sage.schemes.hyperelliptic_curves.hyperelliptic_padic_field.HyperellipticCurve_padic_field.coleman_integral[70]>\", line 1, in <module>\n        HK.coleman_integral(w,S,P)\n      File \"/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/hyperelliptic_curves/hyperelliptic_padic_field.py\", line 837, in coleman_integral\n        basis_values = self.coleman_integrals_on_basis(P, Q, algorithm)\n      File \"/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/hyperelliptic_curves/hyperelliptic_padic_field.py\", line 621, in coleman_integrals_on_basis\n        M_frob, forms = self._frob_calc = monsky_washnitzer.matrix_of_frobenius_hyperelliptic(self)\n      File \"/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/hyperelliptic_curves/monsky_washnitzer.py\", line 1799, in matrix_of_frobenius_hyperelliptic\n        S = SpecialHyperellipticQuotientRing(Q, extra_prec_ring, True)\n      File \"sage/misc/classcall_metaclass.pyx\", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/misc/classcall_m\netaclass.c:1251)\n        return cls.classcall(cls, *args, **kwds)\n      File \"sage/misc/cachefunc.pyx\", line 1057, in sage.misc.cachefunc.CachedFunction.__call__ (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/misc/cachefunc.c:5558)\n        return self.cache[k]\n      File \"sage/misc/weak_dict.pyx\", line 874, in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/misc/weak_dict.c:3905)\n        cdef PyObject* wr = PyDict_GetItemWithError(self, k)\n      File \"sage/misc/weak_dict.pyx\", line 150, in sage.misc.weak_dict.PyDict_GetItemWithError (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/misc/weak_dict.c:1259)\n        ep = mp.ma_lookup(mp, <PyObject*><void*>key, PyObject_Hash(key))\n      File \"/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/generic/algebraic_scheme.py\", line 2299, in __eq__\n        return(self.saturated_defining_ideal() == other.saturated_defining_ideal())\n      File \"/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/generic/algebraic_scheme.py\", line 2280, in saturated_defining_ideal\n        I3 = I1.saturation(I2)[0]\n      File \"/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/rings/polynomial/multi_polynomial_ideal.py\", line 2083, in saturation\n        ideal, expo = sat(self, other)\n      File \"sage/libs/singular/function.pyx\", line 1319, in sage.libs.singular.function.SingularFunction.__call__ (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/libs/singular/functio\nn.cpp:14767)\n        raise TypeError(\"Cannot call Singular function '%s' with ring parameter of type '%s'\"%(self._name,type(ring)))\n    TypeError: Cannot call Singular function 'sat' with ring parameter of type '<class 'sage.rings.polynomial.multi_polynomial_ring.MPolynomialRing_polydict_domain_with_category'>'\n**********************************************************************\n```\nSo it seems that there is something wrong with the definition of `saturation` in `sage/rings/polynomial/multi_polynomial_ideal.py`.\n\n---\nNew commits:",
    "created_at": "2016-08-18T17:03:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20511",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20511#issuecomment-279042",
    "user": "https://github.com/kedlaya"
}
```

Speaking of shaking out bugs, here is a first attempt (minus the hash), which already runs into something further afield:

```
sage -t --warn-long 237.1 src/sage/schemes/hyperelliptic_curves/hyperelliptic_padic_field.py
**********************************************************************
File "src/sage/schemes/hyperelliptic_curves/hyperelliptic_padic_field.py", line 809, in sage.schemes.hyperelliptic_curves.hyperelliptic_padic_field.HyperellipticCurve_padic_field.coleman_integral
Failed example:
    HK.coleman_integral(w,S,P)
Exception raised:
    Traceback (most recent call last):
      File "/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 495, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 858, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.schemes.hyperelliptic_curves.hyperelliptic_padic_field.HyperellipticCurve_padic_field.coleman_integral[70]>", line 1, in <module>
        HK.coleman_integral(w,S,P)
      File "/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/hyperelliptic_curves/hyperelliptic_padic_field.py", line 837, in coleman_integral
        basis_values = self.coleman_integrals_on_basis(P, Q, algorithm)
      File "/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/hyperelliptic_curves/hyperelliptic_padic_field.py", line 621, in coleman_integrals_on_basis
        M_frob, forms = self._frob_calc = monsky_washnitzer.matrix_of_frobenius_hyperelliptic(self)
      File "/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/hyperelliptic_curves/monsky_washnitzer.py", line 1799, in matrix_of_frobenius_hyperelliptic
        S = SpecialHyperellipticQuotientRing(Q, extra_prec_ring, True)
      File "sage/misc/classcall_metaclass.pyx", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/misc/classcall_m
etaclass.c:1251)
        return cls.classcall(cls, *args, **kwds)
      File "sage/misc/cachefunc.pyx", line 1057, in sage.misc.cachefunc.CachedFunction.__call__ (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/misc/cachefunc.c:5558)
        return self.cache[k]
      File "sage/misc/weak_dict.pyx", line 874, in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/misc/weak_dict.c:3905)
        cdef PyObject* wr = PyDict_GetItemWithError(self, k)
      File "sage/misc/weak_dict.pyx", line 150, in sage.misc.weak_dict.PyDict_GetItemWithError (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/misc/weak_dict.c:1259)
        ep = mp.ma_lookup(mp, <PyObject*><void*>key, PyObject_Hash(key))
      File "/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/generic/algebraic_scheme.py", line 2299, in __eq__
        return(self.saturated_defining_ideal() == other.saturated_defining_ideal())
      File "/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/schemes/generic/algebraic_scheme.py", line 2280, in saturated_defining_ideal
        I3 = I1.saturation(I2)[0]
      File "/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/local/lib/python2.7/site-packages/sage/rings/polynomial/multi_polynomial_ideal.py", line 2083, in saturation
        ideal, expo = sat(self, other)
      File "sage/libs/singular/function.pyx", line 1319, in sage.libs.singular.function.SingularFunction.__call__ (/projects/b8cc019c-1204-44b1-bea9-eb81c119388e/sage/src/build/cythonized/sage/libs/singular/functio
n.cpp:14767)
        raise TypeError("Cannot call Singular function '%s' with ring parameter of type '%s'"%(self._name,type(ring)))
    TypeError: Cannot call Singular function 'sat' with ring parameter of type '<class 'sage.rings.polynomial.multi_polynomial_ring.MPolynomialRing_polydict_domain_with_category'>'
**********************************************************************
```
So it seems that there is something wrong with the definition of `saturation` in `sage/rings/polynomial/multi_polynomial_ideal.py`.

---
New commits:



---

archive/issue_comments_279043.json:
```json
{
    "body": "It might be that dealing with hashing will help with this. But hashing ideals itself need to be fixed; see #21297 (which itself has dependencies on hashing for polynomials).",
    "created_at": "2016-08-19T21:11:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20511",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20511#issuecomment-279043",
    "user": "https://github.com/kedlaya"
}
```

It might be that dealing with hashing will help with this. But hashing ideals itself need to be fixed; see #21297 (which itself has dependencies on hashing for polynomials).



---

archive/issue_comments_279044.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-08-19T22:57:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20511",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20511#issuecomment-279044",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:
