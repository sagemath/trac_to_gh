# Issue 27264: all_paths method does not distinguish between multiple edges

Issue created by migration from https://trac.sagemath.org/ticket/27501

Original creator: @rajat1433

Original creation time: 2019-03-16 10:22:15

CC:  dcoudert

While running all_paths method on multiedges graphs it is not able to distinguish between multiple edges even though they may have different labels.



```
sage: eg2 = Graph(multiedges=True)
sage: eg2.add_edge(0,1,1)
sage: eg2.add_edge(0,2,3)
sage: eg2.add_edge(1,4,3)
sage: eg2.add_edge(2,3,5)
sage: eg2.add_edge(2,4,15)
sage: eg2.add_edge(2,4,12)
sage: eg2.add_edge(4,5,7)
sage: eg2.add_edge(4,5,8)
sage: eg2.add_edge(5,6,2)

```


currently it returns 


```
[[0, 1, 4, 5, 6], [0, 2, 4, 5, 6]]
```



 but it should be 


```
[[0, 1, 4, 5, 6],
 [0, 1, 4, 5, 6],
 [0, 2, 4, 5, 6],
 [0, 2, 4, 5, 6],
 [0, 2, 4, 5, 6],
 [0, 2, 4, 5, 6]]
```


As that is the meaning of all paths between source and destination node.


---

Comment by @rajat1433 created at 2019-03-16 14:36:37

As per my understanding this problem is arising because neighbor_out_iterator and neighbor_iterator methods are not able to return the iterator over vertices which are connected via multiedges they are only returning the vertices one time. I have looked into the graph backend files and couldn't find a function capable to return iterator over neighbors connected via multiedges.

As a solution to it I can write a function in backend capable of returning such iterator in case if the graph is multiedged that will be efficient too. (I found out_neighbors_unsafe method in sparse graph class which Gives all v such that (u, v) is an arc of the graph.) 
Alternatively, I can define an iterator myself in all_paths() function mimicking such functionality maybe by using edge_iterator to collect vertices connected via multiedges. I don't know which one is best. If there is any better ideas , I'll be glad to follow on that.


---

Comment by dcoudert created at 2019-03-16 18:21:02

The neighbor iterator is doing exactly what it should. Even if you have 1000 edges between u and v, u has only 1 neighbor.

I think the easiest solution is:
- If the graph has multiedges, record the edge multiplicity
- Then, before yielding a path, compute how many time it should be returned (multiplication of # multiedges) and yield it than number of times.


---

Comment by @rajat1433 created at 2019-03-16 19:29:58

Changing status from new to needs_review.


---

Comment by git created at 2019-03-16 19:30:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-16 19:33:27

Set assignee to @rajat1433.


---

Comment by @rajat1433 created at 2019-03-16 19:34:21

Added paths multiple times based on the multiplicity of multiedges in a path.


---

Comment by dcoudert created at 2019-03-18 07:39:54

I think there is a better solution:
1. at the beginning of the method, count the multiplicity of each edge
2. when a path is added to `all_paths`, count the number x of times the path must be added, and add it x times.


---

Comment by git created at 2019-03-18 08:42:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-18 08:45:01

I have followed your advice and maintained a dictionary for maintaining edge_multiplicity. first it calculates all the paths then for each path it sees how many times it should be present and returns accordingly. I know the paths can be added multiple times in all_paths variable by checking the multiplicty in between but that would require to restructure the whole code so I thought to add the path multiple times in the end.


---

Comment by dcoudert created at 2019-03-18 10:24:16

For counting the edge multiplicity, I have a shorter solution:

```diff
         if self.has_multiple_edges():
-            edge_multiplicity = {}
-            for e in self.edges():
-                if (e[0], e[1]) in edge_multiplicity.keys():
-                    edge_multiplicity[(e[0], e[1])] += 1
-                else:
-                    edge_multiplicity[(e[0], e[1])] = 1
+            from collections import Counter
+            edge_multiplicity = Counter(self.edge_iterator(labels=False))
```

Try `Counter` to see how it works

For counting the multiplicity of path `p`, a more elegant version is:

```
m = prod(edge_multiplicity[e] for e in zip(p[:-1], p[1:]))
```

I don't know if you need to import `prod` from `sage/misc/misc_c.pyx`
}}}


---

Comment by git created at 2019-03-18 11:04:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-18 11:05:25

Those things really saved a lot of lines of codes. Good to learn that. Also thanks for the review.


---

Comment by dcoudert created at 2019-03-18 13:46:26

Replying to [comment:15 gh-rajat1433]:
> Those things really saved a lot of lines of codes. Good to learn that. 

These methods are simple and fast. Also a good way to avoid bugs.

> Also thanks for the review.
Doing my best to help, but don't expect me to always answer so quickly...


TODO: add in the documentation of the method that if the graph has multiple edges, a path may be reported several times.


---

Comment by git created at 2019-03-18 16:46:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-18 16:48:47

added the documentation part for multiple edges.


---

Comment by dcoudert created at 2019-03-18 17:31:53

- for documentation, I meant to add some text just after

```
        If ``start`` is the same vertex as ``end``, then ``[[start]]`` is
        returned -- a list containing the 1-vertex, 0-edge path "``start``".
```

  to get for instance (feel free to reformulate)

```
        If ``start`` is the same vertex as ``end``, then ``[[start]]`` is
        returned -- a list containing the 1-vertex, 0-edge path "``start``".

        If ``self`` has multiple edges, a path will be returned as many
        times as the product of the multiplicity of the edges along that path.
```


- please revert this change. No need for `::` here.

```diff
-        EXAMPLES::
+        EXAMPLES:
```


- You could use a simpler example like this one. I think it's more clear

```
sage: G = Graph([(0, 1), (0, 1), (1, 2), (1, 2)], multiedges=True)
sage: G.all_paths(0, 2)
[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]
```


- and you can move the examples you added in the TESTS bloc into the EXAMPLES bloc. The example for Graph is essentially the same as the other one. The example for DiGraph is good.


---

Comment by git created at 2019-03-19 04:00:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-19 04:01:42

Made the changes!


---

Comment by @rajat1433 created at 2019-03-19 04:57:16

Changing status from needs_review to needs_work.


---

Comment by @rajat1433 created at 2019-03-19 04:57:39

Changing status from needs_work to needs_review.


---

Comment by dcoudert created at 2019-03-19 13:11:22

Looking at the errors induced by this ticket in `src/sage/quivers/path_semigroup.py` and `src/sage/quivers/representation.py` (see the patchbot), I realize that we are making a mistake in this ticket and in #27504.

In graph theory, 2 definitions of paths are used:
1. ordered list of vertices `s=u1, u2, ..., uk=t` such that there is an edge from `ui` to `ui+1`
2. ordered list of edges `(s=u1, u2), (u2, u3), ..., (uk-1, uk=t)`

Most of the time, when we use the list of vertices, we care about the existence of an edge from `ui` to `ui+1`, and so we want only 1 path.
But when we use the list of edges, we are more interested in the existence of many paths due to multiedges.


So, if you agree, I suggest to add parameters to:
* switch on/off the use of multiple edges, if any, sets to off by default to avoid changing the behavior for methods calling this one. A possible name could be `multiedges`. I don't have a better name in mind yet
* return list of edges instead of vertices (possibly with/without edge labels). A possible name could be `report_edges=False`, combined with `labels=False`.


The main difficulty will be to build all the possibles paths with edges and labels...
There might exist some macro to ease this operation.


---

Comment by @rajat1433 created at 2019-03-19 15:22:42

I see the underlying problem.

- switch on/off the use of multiple edges, if any, sets to off by default to avoid changing the behavior for methods calling this one. A possible name could be multiedges. I don't have a better name in mind yet 

I think use_multiedges might be a suitable variable...

- return list of edges instead of vertices (possibly with/without edge labels). A possible name could be report_edges=False, combined with labels=False. 

I was thinking this for a long time to output paths as edges using labels, even wanted to include in my proposal I think it can be done for now using something like Cartesian Product function by adding the edges using edge_boundary.



```
    path_with_labels = []
    for p in all_paths:
        multiple_path=[]
        for i,u in enumerate(p):
            if i < len(p)-1:
                v = p[i+1]
                edges = g.edge_boundary([u], [v])
                multiple_path.append(edges)
        path_with_labels.extend(CartesianProduct(*multiple_path))
```


If it looks ok then I can start adding it.


---

Comment by dcoudert created at 2019-03-19 15:53:42

Great !

`CartesianProduct` is deprecated, so you must use `cartesian_product(multiple_path)` instead.

Calling `edge_boundary` is quite expensive. You should better store all edges between u and v in a dictionary. When it's done, do `mydict[v, u] = mydict[u, v]` so that cell `(v, u)` points to the list of cell `(u,v)`.

Then you can use `cartesian_product(mydict[e] for e in zip(p[:-1], p[1:]))`


---

Comment by @rajat1433 created at 2019-03-19 16:52:47

I don't understand why mydict[v, u] = mydict[u, v] as we can have digraphs also so edges between u and v may not be same as edges between v and u.


---

Comment by dcoudert created at 2019-03-19 16:59:07

Right. You should not do that for digraphs. But for graphs we can save time and space doing so.


---

Comment by @rajat1433 created at 2019-03-19 17:59:17

I am not able to import cartesian_product method.
Any help where it is located?


---

Comment by @rajat1433 created at 2019-03-19 18:02:21

Changing status from needs_review to needs_work.


---

Comment by dcoudert created at 2019-03-19 18:07:49

`from sage.categories.cartesian_product import cartesian_product`


---

Comment by git created at 2019-03-20 06:14:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-20 06:30:39

This ticket adds 3 new parameter to all_paths method namely use_multiedges, report_edges and labels to use multiedges while reporting paths, to use edges instead of vertices in outputing the paths and outputing labels as well in the paths.


---

Comment by git created at 2019-03-20 06:32:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-03-20 07:59:02

Hello,

there is a merge conflict with your branch. This is certainly because version 8.6.rc0 has been released. You have to rebase the ticket.


---

Comment by @rajat1433 created at 2019-03-20 09:09:13

You are right yesterday only version 8.7.rc0 has been released. Working on rebase thing.


---

Comment by git created at 2019-03-20 09:26:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-20 09:31:05

Changing status from needs_work to needs_review.


---

Comment by @rajat1433 created at 2019-03-20 09:31:05

Now its clean , I have added the parameters as discussed.


---

Comment by dcoudert created at 2019-03-21 09:51:45

I'm still thinking to the logic of these parameters. I'm not fully convinced by the choices done like if `label is True` then set other parameters to `True`. 

Anyway,
- parameter `label` should be `labels`, as for other methods like `.edges(labels=True)`

- would you agree with the following changes in the documentation

```diff
-        - ``report_edges`` -- boolean (default: ``False``);  if ``True``, then
-          edges are used instead of vertices in representing the path else by
-          default vertices are used to represent the path
+        - ``report_edges`` -- boolean (default: ``False``); whether to report
+          paths as list of vertices (default) or list of edges
```


```diff
-        - ``use_multiedges`` -- boolean (default: ``False``); if ``True``, then
-          multiple edges present between the nodes are taken into account for
-          finding all paths else these multiedges if present are ignored
+        - ``use_multiedges`` -- boolean (default: ``False``); this parameter is
+          used only if the graph has multiple edges. 
+
+          - If ``False``, the graph is considered as simple and an edge label
+            is arbitrarily selected for each edge as in 
+            :meth:`~GenericGraph.to_simple`
+
+          - If ``True``, a path will be reported as many times as the edges
+            multiplicities along that path (when ``report_edges = False`` or 
+            ``labels = False``), or with all possible combinations of edge labels
+            (when ``report_edges = True`` and ``labels = True``) 
```


```diff
-        - ``label`` -- boolean (default: ``False``);  if ``True``,
-          ``report_edges`` is automatically set to ``True`` and labels are
-          reported along with the edges. Also multiedges are also automatically
-          taken into account when label is ``True``.
+        - ``labels`` -- boolean (default: ``False``); if ``False``, each edge is
+          simply a pair ``(u, v)``of vertices. This parameter is ignored when
+          ``report_edges = False``
```


- this is better

```diff
             for e in self.edge_iterator():
                 if (e[0], e[1]) in my_dict.keys():
                     my_dict[(e[0], e[1])].append(e)
                 else:
                     my_dict[(e[0], e[1])] = [e]
-                if not self.is_directed():   
-                    my_dict[(e[1], e[0])] = my_dict[(e[0], e[1])]
+            if not self.is_directed():
+                for u, v in my_dict.keys():
+                    my_dict[v, u] = my_dict[u, v]
```



---

Comment by @rajat1433 created at 2019-03-21 09:58:02

This was done because if labels were true and report_edges were false then there will be no point in labels being true as labels will make sense only if we were to output edges in the path. 

Like in shortest_path function of generic graph we say if weight_function is not None then by_weight parameter is automatically set to true.


---

Comment by dcoudert created at 2019-03-21 10:42:06

OK. But you have to improve the documentation anyway :P


---

Comment by git created at 2019-03-21 11:06:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-03-21 11:08:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-21 11:11:32

Currently I have modified the docs and kept the parameter labels = True leading to make report_edges True. I don't know if this is the best thing. I can change it if you are not convinced by this usage of automatically setting of report_edges thing.


---

Comment by dcoudert created at 2019-03-21 17:19:23

I'm not fully convinced, but I don't have a better proposal.

- you have not documented the case `use_multiedges=False` and `report_edges=True` and `labels=True`

- avoid trailing white spaces

```diff
-        return all_paths 
+        return all_paths
```



---

Comment by @rajat1433 created at 2019-03-21 17:28:07

I had a little query

when use_multiedges=False but labels is True 

should I automatically make use_multiedges as True or 

should I output any simple path by choosing any label in case of multiedges as in :meth:`~GenericGraph.to_simple`


---

Comment by dcoudert created at 2019-03-21 17:42:42

2 option, as I wrote in #comment:41


---

Comment by git created at 2019-03-21 17:59:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-21 18:02:36

Added the doc and code for the case of labels=True and multiedges=False


---

Comment by dcoudert created at 2019-03-22 13:50:46

To better illustrate the combinations of parameter, you should better use a simple example. Your examples are quite complex I think

```
sage: g = Graph([(0, 1, 'a'), (0, 1, 'b'), (1, 2,'c'), (1, 2,'d')], multiedges=True)
sage: g.all_paths(0, 2, use_multiedges=False)
[[0, 1, 2]]
sage: g.all_paths(0, 2, use_multiedges=True)
[[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]
sage: g.all_paths(0, 2, use_multiedges=True, report_edges=True)
[[(0, 1), (1, 2)], [(0, 1), (1, 2)], [(0, 1), (1, 2)], [(0, 1), (1, 2)]]
sage: g.all_paths(0, 2, use_multiedges=True, report_edges=True, labels=True)
[((0, 1, 'b'), (1, 2, 'd')),
 ((0, 1, 'b'), (1, 2, 'c')),
 ((0, 1, 'a'), (1, 2, 'd')),
 ((0, 1, 'a'), (1, 2, 'c'))]
sage: g.all_paths(0, 2, use_multiedges=False, report_edges=True, labels=True)
[((0, 1, 'b'), (1, 2, 'd'))]
sage: g.all_paths(0, 2, use_multiedges=False, report_edges=False, labels=True)
[((0, 1, 'b'), (1, 2, 'd'))]
sage: g.all_paths(0, 2, use_multiedges=True, report_edges=False, labels=True)
[((0, 1, 'b'), (1, 2, 'd')),
 ((0, 1, 'b'), (1, 2, 'c')),
 ((0, 1, 'a'), (1, 2, 'd')),
 ((0, 1, 'a'), (1, 2, 'c'))]
```


I think that the results with `report_edges=False, labels=True` are very confusing.
For me, setting `report_edges=False` means that I want list of vertices, not edges, and so that I don't care of edge labels.


---

Comment by @rajat1433 created at 2019-03-22 14:02:02

So I guess I can make a change that  doing report_edges = False I can print vertices and ignore the labels parameters.


---

Comment by git created at 2019-03-22 14:39:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-22 14:41:31

Now it seems better with changed behaviour of the parameters in case of report_edges=False, labels=True.


---

Comment by dcoudert created at 2019-03-22 15:27:59

Much better ;)

2 minor details

```diff
-        depending on the value of the flag use_multiedges.
+        depending on the value of the flag ``use_multiedges``.
```



```diff
-            :meth:`~GenericGraph.to_simple` if report_edges is ``True``
+            :meth:`~GenericGraph.to_simple` if ``report_edges`` is ``True``
```



---

Comment by git created at 2019-03-22 15:45:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @rajat1433 created at 2019-03-22 15:46:40

Thanks for the review. I have corrected the documentation.


---

Comment by dcoudert created at 2019-03-22 16:08:50

LGTM.


---

Comment by dcoudert created at 2019-03-22 16:08:50

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2019-03-25 19:43:41

Resolution: fixed
