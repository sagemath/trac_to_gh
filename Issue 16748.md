# Issue 16748: Poset: Faster is_dual()

Issue created by migration from https://trac.sagemath.org/ticket/16985

Original creator: jmantysalo

Original creation time: 2014-09-15 09:04:15

CC:  ncohen

For now at Poset class the code for `is_dual()` does just `is_isomorphic(self.dual())`. It of course works, but is quite slow on most cases. Before full isomorphic test one can at least check that cardinalities are same, number of maximal and minimal elements are same and that sorted lists of in- and out-degrees are same.


---

Comment by ncohen created at 2014-09-15 12:29:07

Could you provide timings for the latest improvement you added ?

Also: the code of `Poset.level_sets` is a call to `.hasse_diagram()`, so perhaps you should call that function instead.

Nathann
----
New commits:


---

Comment by jmantysalo created at 2014-09-15 12:42:00

Timings depend on test set. But with all 7-element posets this seems to be about 10-times faster. On the other hand, when testing with 7-element posets that really are duals this runs about 10% slower.

How should this kind of codes be tested, what kind of random posets to use?


---

Comment by ncohen created at 2014-09-15 13:24:56

> Timings depend on test set. But with all 7-element posets this seems to be about 10-times faster. On the other hand, when testing with 7-element posets that really are duals this runs about 10% slower.

I was only talking of the improvement which uses level sets.

> How should this kind of codes be tested, what kind of random posets to use?

Hmmmm... With what we have at our disposal I suppose. But I wondered whether computing the label sets was much faster than isomorphism. It probably is, but I wondered `^^;`

Nathann


---

Comment by tscrim created at 2014-09-15 16:30:14

I'm not surprised by the slowdown because extra checks are being done first. However I'd say the slowdown is acceptable in comparison to the speedup because (I believe) most posets are not self-dual. Could you post your before/after timings?

I'd also not use random posets but instead make sure there is a poset which fails each check to make sure the code works (so fails the in-degree -> out-degree comparison and the level sets comparison [but passes the first test]).

One thing from a quick glance at the code, we're trying to be python3 compliant. So you should change `<>` into `!=`.


---

Comment by jmantysalo created at 2014-09-15 19:00:17

Simple test can be done with Sage without coding anything. For example after `L=Posets(6).list()` I just got

`len([P for P in L if P.is_selfdual()])` -> CPU time: 60.21 s,  Wall time: 65.77 s

`len([P for P in L if sorted(P._hasse_diagram.in_degree()) == sorted(P._hasse_diagram.out_degree()) and P.is_selfdual()])` -> CPU time: 38.73 s,  Wall time: 40.53 s

`len([P for P in L if sorted(P._hasse_diagram.in_degree()) == sorted(P._hasse_diagram.out_degree()) and [len(x) for x in P.level_sets()]==[len(x) for x in P.dual().level_sets()] and P.is_selfdual()])` -> CPU time: 28.94 s,  Wall time: 30.20 s

Difference grows bigger wiht `Posets(7)`, and is also bigger when coding this directly to `.py`-file.

There are 318 posets of size 6. Of those 30 pass first test but fails second, and 12 pass first and second test but fails last one. This is an example of poset passing 1. and 2. test:

`Poset([[0,1,2,3,4,5],[[1, 5], [2, 3], [2, 5], [3, 4]]])`.

I can calculate these numbers for 7- and 8-element posets if needed.


---

Comment by git created at 2014-09-15 19:05:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2014-09-15 19:07:59

Replying to [comment:3 ncohen]:

> Also: the code of `Poset.level_sets` is a call to `.hasse_diagram()`, so perhaps you should call that function instead.

Hmm, actually it seems that only `reverse()` is needed. There is no need at all to calculate full dual with element labels. Got to think about this tomorrow.


---

Comment by ncohen created at 2014-09-16 09:05:39

> Hmm, actually it seems that only `reverse()` is needed. There is no need at all to calculate full dual with element labels. Got to think about this tomorrow.


```
sage: Poset(DiGraph({0:[],1:[2]})).level_sets()
[[1, 0], [2]]
sage: Poset(DiGraph({0:[],1:[2]})).dual().level_sets()
[[0, 2], [1]]
```



---

Comment by jmantysalo created at 2014-09-16 10:45:08

Replying to [comment:10 ncohen]:
> > Hmm, actually it seems that only `reverse()` is needed. There is no need at all to calculate full dual with element labels. Got to think about this tomorrow.
> 
> {{{
> sage: Poset(DiGraph({0:[],1:[2]})).level_sets()
> [[1, 0], [2]]
> sage: Poset(DiGraph({0:[],1:[2]})).dual().level_sets()
> [[0, 2], [1]]
> }}}

I don't understand. Of course we must sometimes do full test for isomorphicity. This is one example of those.

Saying `Poset({'a':['b']})._hasse_diagram.level_sets()` will return `[[0], [1]]`, not `[['a'], ['b']]`. But in any case, code seems to reverse an array, which is unneeded.


---

Comment by ncohen created at 2014-09-16 11:54:21

> I don't understand. 

Then I probably misunderstood your comment about "reverse", sorry.

Nathann


---

Comment by git created at 2014-09-16 19:39:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2014-09-16 19:57:10

Changing status from new to needs_review.


---

Comment by ncohen created at 2014-09-17 09:23:44

Changing status from needs_review to positive_review.


---

Comment by ncohen created at 2014-09-17 09:23:44

please add your name to the "Authors" fields in this ticket.

Nathann


---

Comment by vbraun created at 2014-09-19 15:08:58

Resolution: fixed
