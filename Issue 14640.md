# Issue 14640: Implement cluster algebras with universal coefficients

Issue created by migration from Trac.

Original creator: etn40ff

Original creation time: 2013-07-01 12:23:10

Assignee: sage-combinat

CC:  gmoose05

Keywords: cluster algebras

This is a first implementation of cluster algebras with universal coefficients. 

It is far from being optimal for several reasons. The biggest issues comes from an incompatibility between QuiverMutationType and CartanType: there is no clean way to translate one into the other. A more subtle issue is that CartanType does not allow to choose the ordering on simple roots while in a cluster algebra everything is defined up to relabeling. 
To solve these issues, in this patch,  the set of positive roots is computed by hand. As a consequence the order in which they appear is not the standard one. 

For the overall development of sage we might consider a cleanup and extension of CartanType, RootSystem etc to allow Cartan matrices as input.


---

Comment by stumpc5 created at 2013-07-04 09:10:46

Changing status from new to needs_info.


---

Comment by stumpc5 created at 2013-07-04 09:10:46

Some random thoughts:

- if you want a review, set the ticket to needs review, and if you want to ping Gregg or whoever, add his trac name (or plain email address) into the cc box. This makes it easier and quicker to interact...

- arxiv links should be inserted as :arxiv:`1202.1506`

- shouldn't the AND's in
  {{{
  if self._m !=0 and not self.is_bipartite() and not self.is_finite(): 
      raise ValueError("Universal coefficients are defined only for finite type cluster algebras at a bipartite initial cluster")
  }}}
  rather be OR's?

- isn't there a way to pass around the positive roots issue? Basically by providing a method yourself (in `quiver_mutation_type.py`) which takes a finite quiver mutation type and turns it into a Cartan type. This would at least make it possible to remove the code duplicity for computing positive roots.

Cheers, Christian


---

Comment by etn40ff created at 2013-07-04 09:42:30

Hi Christian,

thank you for the advices on the use of trac: I am quite new to all of it. 
Thank you also for catching the problem with the if statement: I uploaded an old version of the patch; sorry about that.
As for the last point here is my reasoning:

I agree with you that this is not an optimal way of coding this function; the first idea I had was to add a method to translate  `QuiverMutationType` into `CartanType`. Unfortunately we need slightly more than what `CartanType` provides: it is important to able to choose an ordering of the simple roots (a labeling of the vertices of the quiver if you prefer) and this is not possible in the current implementation. We could translate `QuiverMutationType` into a pair `(CartanType, Permutation)` but I am not sure this would be any better. Slightly annoying is also the fact that  `CartanType` labels nodes from 1 while  `QuiverMutationType` from 0.

I will shortly update a new version of the patch including your observations.
S.


---

Attachment

Hi Salvatore,

Replying to [comment:2 etn40ff]:
> Unfortunately we need slightly more than what `CartanType` provides:
> it is important to able to choose an ordering of the simple roots (a
> labeling of the vertices of the quiver if you prefer) and this is
> not possible in the current implementation.

Can you be specific? Could CartanType(["A",4]).relabel(...) be useful?

> Slightly annoying is also the fact that `CartanType` labels nodes
> from 1 while `QuiverMutationType` from 0.

Just to clarify: it turns out that the classical cartan types (A_4,
...) label their nodes starting from 1 to match the usual
conventions. But the code makes no assumption whatsoever about this;
so you don't have to follow the same labeling for your own Cartan
types.

Cheers,
                Nicolas


---

Comment by etn40ff created at 2013-07-08 11:25:32

Hi Nicolas,

`CartanType(["A",4]).relabel(...)` could certanly be useful but it would still require some thin wrapper in `QuiverMutationType` in order to do the translation. Ideally I'd rather be able to produce a `CartanType` (of any type) directly form a `CartanMatrix`: my feeling is that such a feature might be what Vivien was looking for at days49

Best

S.


---

Comment by chapoton created at 2014-03-05 12:32:32

Here is a git branch, made from the patch.
----
New commits:


---

Comment by etn40ff created at 2014-03-05 19:40:21

Changing status from needs_info to needs_review.


---

Comment by chapoton created at 2014-03-07 20:47:07

Hello,

here is a tentative, that could work. I have tried to use the CartanMatrix setting to produce the almost positive roots.


Could you please tell me if it does what it should ?
----
New commits:


---

Comment by etn40ff created at 2014-03-10 02:45:45

Hi,
your code looks good to me. The only issue I could see is that it was taking the
transpose of the matrix A before computing coroots hence constructing roots.
(This is probably a leftover of my previous implementation.) I am not sure why I
did not use CartanMatrix back when I coded this first; was it already in sage?
S.


---

Comment by git created at 2014-03-10 02:47:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2014-03-11 15:56:40

There is even an existing method 'almost_positive_roots' in `sage/combinat/root_system/root_lattice_realizations.py`, maybe one should use that.


---

Comment by git created at 2014-03-11 16:56:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2014-03-11 21:26:41

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2014-03-11 21:26:41

ok, good enough for me. positive review


---

Comment by vbraun created at 2014-03-14 14:47:11

Resolution: fixed
