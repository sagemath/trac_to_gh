# Issue 32577: Add method extend_basis to CombinatorialFreeModule

Issue created by migration from https://trac.sagemath.org/ticket/32814

Original creator: @louisng114

Original creation time: 2021-11-02 16:19:54

CC:  tscrim nthiery

Keywords: CombinatorialFreeModule

Add method extend_basis to CombinatorialFreeModule which constructs the canonical morphism between the user-submitted module and the module with additional user-submitted basis elements added.

https://github.com/louisng114/SageMath_CombinatorialFreeModule_extend_basis


---

Comment by @louisng114 created at 2021-11-08 21:31:35

New commits:


---

Comment by tscrim created at 2021-11-09 06:46:51

Thank you for this contribution. This could be a very useful addition. I know it is not yet set to needs review, but have some quick comments from a quick reading.

I am generally -1 to renaming the variables as it violates the principle of least surprise and is usually very brittle. You need to explicitly describe what happens if we decide to continue in this way. However, I am not convinced this is the correct behavior. Can you justify why you are renaming things rather than dropping them. In particular, submodule behavior differs from the top-level. I also feel it should be consistent.

This also will not work with infinite dimensional modules. Not that it needs to, but this needs to be documented at least.


---

Comment by @louisng114 created at 2021-11-09 18:27:30

Replying to [comment:3 tscrim]:
> Thank you for this contribution. This could be a very useful addition. I know it is not yet set to needs review, but have some quick comments from a quick reading.
> 
> I am generally -1 to renaming the variables as it violates the principle of least surprise and is usually very brittle. You need to explicitly describe what happens if we decide to continue in this way. However, I am not convinced this is the correct behavior. Can you justify why you are renaming things rather than dropping them. In particular, submodule behavior differs from the top-level. I also feel it should be consistent.
> 
> This also will not work with infinite dimensional modules. Not that it needs to, but this needs to be documented at least.

Thank you for your response.

Sagemath automatically renames the basis when submodules are taken, so there is no way to get around that if the user submits a submodule. However, if the variable is lifted, it does have the intended names. For example, When making a 2-dimensional submodule of a module with basis x, y, z, Sage renames the indices to 0 and 1. If the user submits this submodule and wants to extend this by a, b, c, then the returned submodule would have basis indices 0, 1, 2, 3, 4, where 2, 3, 4 are lifted to a, b, c respectively.

As for the specifying that it does not work with infinitely dimensional module, I agree.


---

Comment by tscrim created at 2021-11-10 09:59:34

I think the submodules is a non sequitur because you are constructing a new basis that you have (in principle) no control over the size or the relation to the original basis, so you cannot do better as you said. Also, if you pass something you know is a basis, then you do set the indices.

This case is different. You are introducing an inconsistency here: ambient modules are treated differently than something that knows it is a submodule. What is the mathematical operation you want to implement here? Is it a direct sum, which is what the case for the ambient module is, or is it the sum of two subspaces, which is what I think the submodule case does. Furthermore, for the submodule case, it seems like you want to add something to a basis you already have and explicitly set a basis, so you should just discard the basis elements already in the span of what you have (processed inductively to make the operation canonical). However, things will be clarified if you define precisely what you want to model.


---

Comment by nthiery created at 2021-11-10 10:10:22

Hello!

I did not look in details, so am not sure of the exact use case. 
So just asking: could the desired functionality be achieved with
the current cartesian product construction (or improving it if needed)?


```
sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])
sage: G = CombinatorialFreeModule(QQ, ['i','j','k'])
sage: FG = cartesian_product([F, G])
sage: FG.basis().keys()
Disjoint union of Family ({'a', 'b', 'c'}, {'i', 'j', 'k'})
sage: phi = FG.cartesian_embedding(0)
sage: phi(F.an_element())
2*B[(0, 'a')] + 2*B[(0, 'b')] + 3*B[(0, 'c')]
```


Cheers,


---

Comment by mkoeppe created at 2021-11-10 16:19:20

Should there be a coercion map from `CombinatorialFreeModule(QQ, ['a'])` to `CombinatorialFreeModule(QQ, ['a', 'b'])`?


---

Comment by nthiery created at 2021-11-11 07:33:06

Thanks Matthias for the suggestion.

FreeModule is meant to be subclassed to produce parents
which may have additional structure which may not be
preserved by the trivial linear map. For example,
we have a dozen of different realizations of the algebra
of symmetric functions which all share the same basis and
which are isomorphic (available as coercions); but these
isomorphisms are non trivial.

If we would add such a coercion, we would need to make
sure that it is not inherited which gets tricky.

In general: it's easy to add a coercion; hard to remove
an existing one. So my preferred approach is to be
very conservative in defining coercions by default,
and instead make it as trivial as possible for the user 
to add these that he cares about.


---

Comment by @louisng114 created at 2021-11-13 20:33:45

Replying to [comment:6 tscrim]:
> I think the submodules is a non sequitur because you are constructing a new basis that you have (in principle) no control over the size or the relation to the original basis, so you cannot do better as you said. Also, if you pass something you know is a basis, then you do set the indices.
> 
> This case is different. You are introducing an inconsistency here: ambient modules are treated differently than something that knows it is a submodule. What is the mathematical operation you want to implement here? Is it a direct sum, which is what the case for the ambient module is, or is it the sum of two subspaces, which is what I think the submodule case does. Furthermore, for the submodule case, it seems like you want to add something to a basis you already have and explicitly set a basis, so you should just discard the basis elements already in the span of what you have (processed inductively to make the operation canonical). However, things will be clarified if you define precisely what you want to model.

I am not sure I understand the inconsistency. The method goes to the top level, add new basis elements, and drops back down using the information gathered while climbing up.


---

Comment by @louisng114 created at 2021-11-13 21:20:40

Replying to [comment:7 nthiery]:
> Hello!
> 
> I did not look in details, so am not sure of the exact use case. 
> So just asking: could the desired functionality be achieved with
> the current cartesian product construction (or improving it if needed)?
> 
> {{{
> sage: F = CombinatorialFreeModule(QQ, ['a','b','c'])
> sage: G = CombinatorialFreeModule(QQ, ['i','j','k'])
> sage: FG = cartesian_product([F, G])
> sage: FG.basis().keys()
> Disjoint union of Family ({'a', 'b', 'c'}, {'i', 'j', 'k'})
> sage: phi = FG.cartesian_embedding(0)
> sage: phi(F.an_element())
> 2*B[(0, 'a')] + 2*B[(0, 'b')] + 3*B[(0, 'c')]
> }}}
> 
> Cheers,

The module from extend_basis would have a cleaner basis. For example, as I am working on #29806, I want to add the needed basis elements (if necessary) and reference specific basis elements without needing to check whether or not it is a product.


---

Comment by tscrim created at 2021-11-15 08:12:47

Replying to [comment:10 gh-louisng114]:
>
> I am not sure I understand the inconsistency. The method goes to the top level, add new basis elements, and drops back down using the information gathered while climbing up.

If that's the case, then it sounds like a direct sum. When forming `A (+) B`, it does not care about how the module `A` was constructed. Contrast this with taking the union. Is the union more of the behavior you want, so repeated indices are discarded? How the basis elements are indexed should not matter on if it is an ambient module or a submodule, no matter if you mean direct sum or union. The only thing is matters is what does an element indexed by `X` mean? Is it meant to always be something in the ambient module?

As an example, consider `A = span{X,Y}`, where this means the basis elements of `A` are `b_X` and `b_Y`. Then take a 1 dimensional submodule `B = span{Z} < A`, where `b_Z` is some vector in `A`. What happens when I extend the basis of `A` and `B` by `{W}`, by `{X}`, and by `{Z}`? The first case is easy, it just adds the basis element. In the `{X}` case, I would think it would be a no-op in both cases if you mean union (the direct sum case would be a disjoint union). The `{Z}` case is the interesting one.

This does bring up another question when starting with a submodule: Should we also create the other ambient module and the returned module as a submodule or just a brand-new module? If the former, then should there also be a coercion between the ambient modules? My thought is actually we should just create a brand new module as a module without an ambient one (at least by default). My reasoning is this: you are simply building a new module and if you wanted a submodule, you could extend the ambient one and then build a submodule from that.
