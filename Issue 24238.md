# Issue 24238: str_to_bytes() should accept unicode

Issue created by migration from https://trac.sagemath.org/ticket/24475

Original creator: jdemeyer

Original creation time: 2018-01-05 12:42:42

CC:  embray




---

Comment by embray created at 2018-01-05 12:52:05

We might still have both.   The implementation details depend on the Python version, and checking for `unicode` vs `str` is only useful on Python 2.


---

Comment by embray created at 2018-01-09 11:29:31

From #24223#comment:20:

> Instead of `PyUnicode_EncodeLocale`, you can just pass `NULL` as encoding to `PyUnicode_AsEncodedString`

That's not true.  The latter uses UTF-8 as the default encoding.


---

Comment by jdemeyer created at 2018-01-09 11:46:36

Replying to [comment:4 embray]:
> From #24223#comment:20:
> 
> > Instead of `PyUnicode_EncodeLocale`, you can just pass `NULL` as encoding to `PyUnicode_AsEncodedString`
> 
> That's not true.  The latter uses UTF-8 as the default encoding.

You are right as usual :-) Actually, the default is ASCII on Python 2.

But you have to admit that it is confusing: there is a notion of a "default encoding" (ASCII on py2 and UTF-8 on py3) which is different from the "preferred encoding" determined by the locale.


---

Comment by embray created at 2018-01-09 12:02:42

I agree, it's confusing.  The "default encoding" is a different thing, which is the default encoding used, for example, in `str.encode` and `bytes.decode`.  On Python 2 it's "ascii" which is why you get so many encoding errors when, for example, you try to append a unicode string with  a non-unicode string.

I'm starting to lean more towards maybe these functions should just use UTF-8 as a sane, predictable default (basically the Python 3 value for `sys.getdefaultencoding()`).  As I've written before this may be a problem when interacting with locale-aware interfaces and libraries in situations where the user is in a non-UTF8 locale (which is more likely than one might think).  But as I've found so far in my Python 3 work on Sage that seems to be a less common case than in general.  In those cases we can take care to pass in the correct encoding for the current locale where necessary.

My intuition was that using the locale encoding would be a safer default to work with for now--and it probably is--but maybe explicit would be better than implicit in this case too.


---

Comment by embray created at 2018-01-09 13:14:29

Here's my current attempt, including switch to UTF-8 by default.
----
New commits:


---

Comment by embray created at 2018-01-09 13:14:29

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2018-01-09 14:04:51

Replying to [comment:6 embray]:
> I'm starting to lean more towards maybe these functions should just use UTF-8 as a sane, predictable default

After all the effort you put into convincing me that `locale.getpreferredencoding()` is the right default, why change it to UTF-8?

Personally, I still think that the best solution is still "Explicit is better than implicit", so always require choosing an encoding. As second best option, I would use `locale.getpreferredencoding()` as default since that is what Python mostly uses as default (`open()` is an important example)


---

Comment by jdemeyer created at 2018-01-09 14:08:35

About the implementation: I would write the code to be as much as possible independent of the Python version. For example, for the type checking you could write

```
if isinstance(s, bytes):
    return <bytes>s
if not isinstance(s, unicode):
    raise TypeError(f"expected str or unicode, {type(s).__name__} found")
```

This will work as expected on both Python 2 and Python 3. As a bonus, the behaviour is also more consistent because it allows `bytes` on Python 2 and 3.


---

Comment by embray created at 2018-01-10 12:17:29

On the encoding: I thought I explained my change of thinking above, but there are a few reasons (and I'm torn either way):

1) On Python 2 encoding with the locale is going to be annoying, as there's no equivalent of `PyUnicode_EncodeLocale`.  Instead, one has to `import locale` (which has to be done in the function, otherwise it won't work when Cython inlines it), and call `locale.getpreferredencoding()`.  This in turn calls `setlocale` which isn't thread-safe (though maybe that doesn't matter for Sage's purposes, but I worried it would limit where this could be used).

2) You can avoid the `setlocale` call by calling `locale.getpreferredencoding(False)`. However, this has unfortunate ramifications on Python 2.  All programs start out in the "C" locale (i.e. ASCII) by default.  In Python 2 the interpreter only temporarily enables the user's locale in order to determine what to use for "filesystem encoding", but then switches back to the default.  That is, if you want Python to use anything other than the "C" locale (or at least any non-ASCII encoding from the locale) you have to at least manually call `setlocale(LC_CTYPE, "")` at least once.  Python 3, however, does exactly this during interpreter startup, which makes a major difference.

3) While it's true that Python uses `locale.getpreferredencoding()` in lots of places as the default encoding (most notably `open()`) I've found so far with these utility functions that they don't have a lot of impact w.r.t. file I/O.  In the past, the most challenging Python 3 ports I've worked on have had a lot to do with file I/O which is why this was heavily on my mind, but so far in porting Sage this has been less of any issue. 

4) It might actually be saner and more predictable to defaulting to UTF-8, especially when a user explicitly passes some non-ASCII unicode text to a function that is supposed to support unicode, if the user's locale is non-unicode they may get encoding errors.  

Relatedly, having a default does not necessarily violate "explicit is better than implicit" as long as that default is predictable and well-documented.  With the locale-based encoding it isn't that, even though I personally would prefer it in most cases.

And yes, I realize I've previously argued for the opposite--I think with good reasons--but now I've convinced myself the other way around.  Take it with a grain of salt though; if you'd prefer not to change things again I can undo that.  It just makes the code a little more complicated unfortunately.


---

Comment by embray created at 2018-01-10 12:22:25

Replying to [comment:9 jdemeyer]:
> About the implementation: I would write the code to be as much as possible independent of the Python version. For example, for the type checking you could write

While I would also prefer to write the code as independent as possible I'm not sure I follow your suggestion here.

> {{{
> if isinstance(s, bytes):
>     return <bytes>s
> }}}

> As a bonus, the behaviour is also more consistent because it allows `bytes` on Python 2 and 3.

I'm not sure what you're getting at here.  `str_to_bytes` really shouldn't accept `bytes` on Python 3.

> {{{
> if not isinstance(s, unicode):
>     raise TypeError(f"expected str or unicode, {type(s).__name__} found")
> }}}
> This will work as expected on both Python 2 and Python 3. 

The error message would be wrong on Python 3 since there is no "unicode" (and this error message is intended for users who would normally be writing plain Python, not Cython).  That's why I have slightly different duplicates of this code.


---

Comment by jdemeyer created at 2018-01-12 09:52:00

I'll give you the benefit of the doubt for the encoding discussion. Do you agree with this review commit?
----
New commits:


---

Comment by embray created at 2018-01-16 16:35:52

Replying to [comment:13 jdemeyer]:
> I'll give you the benefit of the doubt for the encoding discussion. Do you agree with this review commit?


```
-IF PY_MAJOR_VERSION >= 3:
-    cdef extern from "Python.h":
-        # Missing from cpython.unicode in Cython 0.27.3
-        char* PyUnicode_AsUTF8(object s)
+
+cdef extern from "Python.h":
+    # Missing from cpython.unicode in Cython 0.27.3
+    char* PyUnicode_AsUTF8(object s)
```


`PyUnicode_AsUTF8` doesn't exist on Python 2 so I'm not sure why you removed this check.  I'm not sure if that actually matters from Cython's end though.

Looks good to me otherwise in principle; I just want to test it on my Python 3 branch.


---

Comment by jdemeyer created at 2018-01-16 18:16:49

Replying to [comment:14 embray]:
> `PyUnicode_AsUTF8` doesn't exist on Python 2 so I'm not sure why you removed this check.

I removed it because I want to upstream that declaration and Cython doesn't differentiate between Python 2 and Python 3.

> I'm not sure if that actually matters from Cython's end though.

No, it doesn't.


---

Comment by embray created at 2018-01-17 12:15:19

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-01-18 18:09:11

Resolution: fixed
