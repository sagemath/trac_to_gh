# Issue 16304: Non-deterministic ordering of GMP-ECM output

archive/issues_016067.json:
```json
{
    "body": "It seems that there is a small but positive probability that the factors found by the GMP-ECM elliptic curve factorisation program are in non-increasing order.  From [a recent patchbot report](http://patchbot.sagemath.org/log/11475/debian/wheezy/sid/x86_64/3.2.0-57-generic/selmer/2014-05-07%2007:23:33%20+0100):\n\n```\nsage -t --long src/sage/interfaces/ecm.py\n**********************************************************************\nFile \"src/sage/interfaces/ecm.py\", line 548, in sage.interfaces.ecm.ECM.find_factor\nFailed example:\n    f.find_factor(n)\nExpected:\n    [79792266297612017, 6366805760909027985741435139224233]\nGot:\n    [6366805760909027985741435139224233, 79792266297612017]\n**********************************************************************\n1 item had failures:\n   1 of   6 in sage.interfaces.ecm.ECM.find_factor\n    [44 tests, 1 failure, 15.27 s]\n```\nI have not been able to reproduce this, nor can Google find it in other patchbot reports.\n\nThis is related to #10951, which makes GMP-ECM's optional `sigma` argument accessible in the interface; passing such a sigma would give deterministic behaviour.\n\nCC:  @zimmermann6\n\nKeywords: gmp-ecm elliptic curve factoring\n\nStatus: needs_info\n\nIssue created by migration from https://trac.sagemath.org/ticket/16304\n\n",
    "created_at": "2014-05-07T14:52:48Z",
    "labels": [
        "component: interfaces",
        "minor",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Non-deterministic ordering of GMP-ECM output",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16304",
    "user": "https://github.com/pjbruin"
}
```
It seems that there is a small but positive probability that the factors found by the GMP-ECM elliptic curve factorisation program are in non-increasing order.  From [a recent patchbot report](http://patchbot.sagemath.org/log/11475/debian/wheezy/sid/x86_64/3.2.0-57-generic/selmer/2014-05-07%2007:23:33%20+0100):

```
sage -t --long src/sage/interfaces/ecm.py
**********************************************************************
File "src/sage/interfaces/ecm.py", line 548, in sage.interfaces.ecm.ECM.find_factor
Failed example:
    f.find_factor(n)
Expected:
    [79792266297612017, 6366805760909027985741435139224233]
Got:
    [6366805760909027985741435139224233, 79792266297612017]
**********************************************************************
1 item had failures:
   1 of   6 in sage.interfaces.ecm.ECM.find_factor
    [44 tests, 1 failure, 15.27 s]
```
I have not been able to reproduce this, nor can Google find it in other patchbot reports.

This is related to #10951, which makes GMP-ECM's optional `sigma` argument accessible in the interface; passing such a sigma would give deterministic behaviour.

CC:  @zimmermann6

Keywords: gmp-ecm elliptic curve factoring

Status: needs_info

Issue created by migration from https://trac.sagemath.org/ticket/16304





---

archive/issue_comments_267016.json:
```json
{
    "body": "<a id='comment:1'></a>indeed, the closer the (smallest) factors, the higher is the probability that the factor\nfound is non-deterministic:\n\n```\nsage: f = ECM()\nsage: n=6366805760909033411615543376840901\nsage: f.find_factor(n)\n[79792266297612017, 79792266297612053]\nsage: f.find_factor(n)\n[79792266297612053, 79792266297612017]\n```\nA better check would be to first sort the liste returned (in case of two prime factors).\n\nPaul",
    "created_at": "2014-05-07T15:16:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267016",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:1'></a>indeed, the closer the (smallest) factors, the higher is the probability that the factor
found is non-deterministic:

```
sage: f = ECM()
sage: n=6366805760909033411615543376840901
sage: f.find_factor(n)
[79792266297612017, 79792266297612053]
sage: f.find_factor(n)
[79792266297612053, 79792266297612017]
```
A better check would be to first sort the liste returned (in case of two prime factors).

Paul



---

archive/issue_comments_267017.json:
```json
{
    "body": "<a id='comment:2'></a>> A better check would be to first sort the liste returned (in case of two prime factors).\n\n\nsorry, I meant \"list\" instead of \"liste\".\n\nPaul",
    "created_at": "2014-05-07T15:16:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267017",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:2'></a>> A better check would be to first sort the liste returned (in case of two prime factors).


sorry, I meant "list" instead of "liste".

Paul



---

archive/issue_comments_267018.json:
```json
{
    "body": "<a id='comment:3'></a>Replying to [comment:1 zimmerma]:\n> A better check would be to first sort the liste returned (in case of two prime factors).\n\nHow about letting `_parse_output()` always sort the list of pairs `(factor, probable_prime)` before returning it, regardless of the number of factors and the value of `probable_prime` for each?",
    "created_at": "2014-05-07T15:30:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267018",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:3'></a>Replying to [comment:1 zimmerma]:
> A better check would be to first sort the liste returned (in case of two prime factors).

How about letting `_parse_output()` always sort the list of pairs `(factor, probable_prime)` before returning it, regardless of the number of factors and the value of `probable_prime` for each?



---

archive/issue_comments_267019.json:
```json
{
    "body": "<a id='comment:4'></a>> How about letting `_parse_output()` always sort the list of pairs `(factor, probable_prime)` before returning it, regardless of the number of factors and the value of `probable_prime` for each?\n\n\nbut then we would lose some information, since the first factor is the one which is really found by ECM.\n\nAnd with 3 prime factors or more, we would still have non-deterministic output.\n\nPaul",
    "created_at": "2014-05-07T15:39:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267019",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:4'></a>> How about letting `_parse_output()` always sort the list of pairs `(factor, probable_prime)` before returning it, regardless of the number of factors and the value of `probable_prime` for each?


but then we would lose some information, since the first factor is the one which is really found by ECM.

And with 3 prime factors or more, we would still have non-deterministic output.

Paul



---

archive/issue_comments_267020.json:
```json
{
    "body": "<a id='comment:5'></a>Replying to [comment:4 zimmerma]:\n> > How about letting `_parse_output()` always sort the list of pairs `(factor, probable_prime)` before returning it, regardless of the number of factors and the value of `probable_prime` for each?\n\n> \n> but then we would lose some information, since the first factor is the one which is really found by ECM.\n> \n> And with 3 prime factors or more, we would still have non-deterministic output.\n\nAh, right.  Then maybe the most reasonable solution is not to change the code at all, but to make the doctests resistant to non-deterministic results: sort the output in those tests where *n* has only two prime factors, and check that the output consists of at least 2 factors with the correct product if *n* has at least three prime factors.",
    "created_at": "2014-05-07T15:47:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267020",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:5'></a>Replying to [comment:4 zimmerma]:
> > How about letting `_parse_output()` always sort the list of pairs `(factor, probable_prime)` before returning it, regardless of the number of factors and the value of `probable_prime` for each?

> 
> but then we would lose some information, since the first factor is the one which is really found by ECM.
> 
> And with 3 prime factors or more, we would still have non-deterministic output.

Ah, right.  Then maybe the most reasonable solution is not to change the code at all, but to make the doctests resistant to non-deterministic results: sort the output in those tests where *n* has only two prime factors, and check that the output consists of at least 2 factors with the correct product if *n* has at least three prime factors.



---

archive/issue_events_048056.json:
```json
{
    "actor": "https://github.com/nexttime",
    "created_at": "2014-05-11T14:29:17Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16304#event-48056"
}
```



---

archive/issue_events_048057.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16304#event-48057"
}
```



---

archive/issue_events_048058.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16304#event-48058"
}
```



---

archive/issue_comments_267021.json:
```json
{
    "body": "<a id='comment:8'></a>Am I right in thinking that #10951 makes the factorisation deterministic, thereby solving the problem in this ticket?",
    "created_at": "2015-08-17T12:17:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267021",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:8'></a>Am I right in thinking that #10951 makes the factorisation deterministic, thereby solving the problem in this ticket?



---

archive/issue_comments_267022.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2015-08-17T12:17:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267022",
    "user": "https://github.com/pjbruin"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_267023.json:
```json
{
    "body": "<a id='comment:9'></a>Replying to [comment:8 pbruin]:\n> Am I right in thinking that #10951 makes the factorisation deterministic, thereby solving the problem in this ticket?\n\n\nno, unless we fix the sigma values used by ECM, it should still be non deterministic.",
    "created_at": "2015-08-17T16:59:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267023",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:9'></a>Replying to [comment:8 pbruin]:
> Am I right in thinking that #10951 makes the factorisation deterministic, thereby solving the problem in this ticket?


no, unless we fix the sigma values used by ECM, it should still be non deterministic.



---

archive/issue_comments_267024.json:
```json
{
    "body": "<a id='comment:10'></a>Just put a `sorted(...)` around each of the problematic lines.",
    "created_at": "2015-08-17T17:15:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267024",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:10'></a>Just put a `sorted(...)` around each of the problematic lines.



---

archive/issue_comments_267025.json:
```json
{
    "body": "<a id='comment:11'></a>Replying to [comment:9 zimmerma]:\n> Replying to [comment:8 pbruin]:\n> > Am I right in thinking that #10951 makes the factorisation deterministic, thereby solving the problem in this ticket?\n\n> \n> no, unless we fix the sigma values used by ECM, it should still be non deterministic.\n\nOK, I see, #10951 only makes it possible to pass a sigma value; the default `sigma=0` apparently means that a random one is chosen.",
    "created_at": "2015-08-17T17:35:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267025",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:11'></a>Replying to [comment:9 zimmerma]:
> Replying to [comment:8 pbruin]:
> > Am I right in thinking that #10951 makes the factorisation deterministic, thereby solving the problem in this ticket?

> 
> no, unless we fix the sigma values used by ECM, it should still be non deterministic.

OK, I see, #10951 only makes it possible to pass a sigma value; the default `sigma=0` apparently means that a random one is chosen.



---

archive/issue_comments_267026.json:
```json
{
    "body": "<a id='comment:12'></a>Replying to [comment:10 nbruin]:\n> Just put a `sorted(...)` around each of the problematic lines.\n\nWe could do that, but see comment:4.",
    "created_at": "2015-08-17T17:35:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16304",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16304#issuecomment-267026",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:12'></a>Replying to [comment:10 nbruin]:
> Just put a `sorted(...)` around each of the problematic lines.

We could do that, but see comment:4.
