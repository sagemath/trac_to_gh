# Issue 16411: Memory leak in polynomial evaluation

archive/issues_016174.json:
```json
{
    "body": "The following was reported at sage-support:\n\n```\nsage: C.<x,y,z> = GF(2)[]\nsage: f = x^4+x*y^3+z^6\nsage: a = f(1,0,0)\nsage: get_memory_usage()\n176.08984375\nsage: for i in xrange(1000000):\n....:     a = f(1,0,0)\n....:\nsage: get_memory_usage()\n198.08984375\nsage: for i in xrange(1000000):\n....:    a = f(1,0,0)\n....:\nsage: get_memory_usage()\n222.08984375\n```\n\nIn the following I am citing Leif's comments from sage-devel:\n\nIn `singular_polynomial_call(&res, self._poly, _ring, coerced_x, MPolynomial_libsingular_get_element)` we have\n\n```\nstruct  spolyrec\n{\n   poly      next;           // next needs to be the first field\n   number    coef;           // and coef the second --- do not change\nthis !!!\n   unsigned long exp[VARS];  // make sure that exp is aligned\n};\n```\nwhere both `next` and `coef` are pointers, and `VARS` is usually zero, so\n`exp` is an \"open-ended\" array, such that the effective size of the struct varies.\n\nThe leak depends on the values (and the amount also on the field\nand the function).  My impression is also that it appears whenever\nres!=NULL, i.e., the result is non-zero.\n\nThe code in singular_polynomial_call() (in\nsrc/sage/libs/singular/polynomial.pyx) explicitly prevents Singular from\nreclaiming the memory:\n\n```\n     ...\n     ret[0] = res_id.m[0]\n\n     from_id.m[0] = NULL\n     res_id.m[0] = NULL\n\n     id_Delete(&to_id, r)\n     id_Delete(&from_id, r)\n     id_Delete(&res_id, r)\n\n     return 0\n```\n(`from_id.m[0]` was set to the input parameter `p`, so that's ok.)\n\nEither it should make a garbage-collected copy of it (the result\nret / ret[0]) instead, or the caller has to clean up afterwards.\n\nThe docstring is quite misleading w.r.t. 'ret', as only the address of a\npointer to be changed is passed to the function, while the struct it\nlater points to always gets allocated by the callee, not the caller.\n\n**CC:**  @nexttime @malb\n\n**Keywords:** memory leak polynomial evaluation libsingular\n\n**Reviewer:** Simon King\n\nIssue created by migration from https://trac.sagemath.org/ticket/16411\n\n",
    "closed_at": "2015-07-26T12:39:24Z",
    "created_at": "2014-05-29T11:16:29Z",
    "labels": [
        "component: commutative algebra",
        "bug",
        "duplicate"
    ],
    "title": "Memory leak in polynomial evaluation",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/16411",
    "user": "https://github.com/simon-king-jena"
}
```
The following was reported at sage-support:

```
sage: C.<x,y,z> = GF(2)[]
sage: f = x^4+x*y^3+z^6
sage: a = f(1,0,0)
sage: get_memory_usage()
176.08984375
sage: for i in xrange(1000000):
....:     a = f(1,0,0)
....:
sage: get_memory_usage()
198.08984375
sage: for i in xrange(1000000):
....:    a = f(1,0,0)
....:
sage: get_memory_usage()
222.08984375
```

In the following I am citing Leif's comments from sage-devel:

In `singular_polynomial_call(&res, self._poly, _ring, coerced_x, MPolynomial_libsingular_get_element)` we have

```
struct  spolyrec
{
   poly      next;           // next needs to be the first field
   number    coef;           // and coef the second --- do not change
this !!!
   unsigned long exp[VARS];  // make sure that exp is aligned
};
```
where both `next` and `coef` are pointers, and `VARS` is usually zero, so
`exp` is an "open-ended" array, such that the effective size of the struct varies.

The leak depends on the values (and the amount also on the field
and the function).  My impression is also that it appears whenever
res!=NULL, i.e., the result is non-zero.

The code in singular_polynomial_call() (in
src/sage/libs/singular/polynomial.pyx) explicitly prevents Singular from
reclaiming the memory:

```
     ...
     ret[0] = res_id.m[0]

     from_id.m[0] = NULL
     res_id.m[0] = NULL

     id_Delete(&to_id, r)
     id_Delete(&from_id, r)
     id_Delete(&res_id, r)

     return 0
```
(`from_id.m[0]` was set to the input parameter `p`, so that's ok.)

Either it should make a garbage-collected copy of it (the result
ret / ret[0]) instead, or the caller has to clean up afterwards.

The docstring is quite misleading w.r.t. 'ret', as only the address of a
pointer to be changed is passed to the function, while the struct it
later points to always gets allocated by the callee, not the caller.

**CC:**  @nexttime @malb

**Keywords:** memory leak polynomial evaluation libsingular

**Reviewer:** Simon King

Issue created by migration from https://trac.sagemath.org/ticket/16411





---

archive/issue_comments_214323.json:
```json
{
    "body": "<a id='comment:1'></a>\nI am not sure if this is a problem to be reported upstream. Probably not, it seems like the culprit is on our side, in `sage.libs.singular.polynomial`.",
    "created_at": "2014-05-29T11:17:46Z",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16411#issuecomment-214323",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
I am not sure if this is a problem to be reported upstream. Probably not, it seems like the culprit is on our side, in `sage.libs.singular.polynomial`.



---

archive/issue_comments_214324.json:
```json
{
    "body": "<a id='comment:2'></a>\nReplying to [SimonKing](#comment%3A1):\n> It seems like the culprit is on our side, in `sage.libs.singular.polynomial`.\n\n\nYep, that's my impression at least.  If the caller should clean up, it's `sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular.__call__()` (and probably more).\n\nWe'd presumably have to change both functions though.\n\n(I haven't looked at the modules in whole; perhaps there are more potential leaks.  `new_MP()` looked suspicious to me as well, but isn't used / called in the given example.)",
    "created_at": "2014-05-29T15:54:49Z",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16411#issuecomment-214324",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:2'></a>
Replying to [SimonKing](#comment%3A1):
> It seems like the culprit is on our side, in `sage.libs.singular.polynomial`.


Yep, that's my impression at least.  If the caller should clean up, it's `sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular.__call__()` (and probably more).

We'd presumably have to change both functions though.

(I haven't looked at the modules in whole; perhaps there are more potential leaks.  `new_MP()` looked suspicious to me as well, but isn't used / called in the given example.)



---

archive/issue_events_146605.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16411#event-146605"
}
```



---

archive/issue_events_146606.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16411#event-146606"
}
```



---

archive/issue_comments_214325.json:
```json
{
    "body": "<a id='comment:4'></a>\nWith #18905, I get\n\n```\nsage: C.<x,y,z> = GF(2)[]\nsage: f = x^4+x*y^3+z^6\nsage: a = f(1,0,0)\nsage: get_memory_usage()\n1028.44921875\nsage: for i in xrange(1000000):\n....:     a = f(1,0,0)\n....:     \nsage: get_memory_usage()\n1028.44921875\n```\n\nSo, I suggest to close it as a duplicate.",
    "created_at": "2015-07-23T14:45:23Z",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16411#issuecomment-214325",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
With #18905, I get

```
sage: C.<x,y,z> = GF(2)[]
sage: f = x^4+x*y^3+z^6
sage: a = f(1,0,0)
sage: get_memory_usage()
1028.44921875
sage: for i in xrange(1000000):
....:     a = f(1,0,0)
....:     
sage: get_memory_usage()
1028.44921875
```

So, I suggest to close it as a duplicate.



---

archive/issue_comments_214326.json:
```json
{
    "body": "**Reviewer:** Simon King",
    "created_at": "2015-07-23T14:45:23Z",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16411#issuecomment-214326",
    "user": "https://github.com/simon-king-jena"
}
```

**Reviewer:** Simon King



---

archive/issue_events_146607.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-07-23T14:45:23Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16411#event-146607"
}
```



---

archive/issue_events_146608.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-07-23T14:45:23Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16411#event-146608"
}
```



---

archive/issue_comments_214327.json:
```json
{
    "body": "<a id='comment:5'></a>\n(duplicate of #18905)",
    "created_at": "2015-07-23T14:45:48Z",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16411#issuecomment-214327",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
(duplicate of #18905)



---

archive/issue_events_146609.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-07-23T14:45:48Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16411#event-146609"
}
```



---

archive/issue_events_146610.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2015-07-23T14:45:48Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16411#event-146610"
}
```



---

archive/issue_events_146611.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-07-26T12:39:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16411#event-146611"
}
```



---

archive/issue_events_146612.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-07-26T12:39:24Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16411#event-146612"
}
```



---

archive/issue_events_146613.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-07-26T12:39:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/16411",
    "label": "duplicate",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16411#event-146613"
}
```
