# Issue 16471: The Push-Relabel method for Maximum Flow

archive/issues_016234.json:
```json
{
    "body": "The Push-Relabel method is a method to compute the Maximum Flow in a graph. Research has shown that it is both asymptotically and practically faster than several other methods, including Ford-Fulkerson, and its much used implementation, Edmonds-Karp.\n\nI have been busy with implementing this method for Sage and will be uploading it shortly to this ticket. With it, I will explain some design decisions that I made and provide the (in my opinion) extensive testcases I ran, and later some profiling results (after all tests have ran again, since I lost my profiling info of earlier runs).\n\nCC:  rudi @nathanncohen @dcoudert borassi\n\nKeywords: maximum flow push relabel\n\nBranch: u/foosterhof/ticket/16471\n\nStatus: needs_work\n\nDependencies: #16467, #16470\n\nCommit: 01276c00c318b082e2639c9e59b33118b9c5f8ca\n\nIssue created by migration from https://trac.sagemath.org/ticket/16471\n\n",
    "created_at": "2014-06-11T14:25:01Z",
    "labels": [
        "component: graph theory",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "The Push-Relabel method for Maximum Flow",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16471",
    "user": "https://trac.sagemath.org/admin/accounts/users/foosterhof"
}
```
The Push-Relabel method is a method to compute the Maximum Flow in a graph. Research has shown that it is both asymptotically and practically faster than several other methods, including Ford-Fulkerson, and its much used implementation, Edmonds-Karp.

I have been busy with implementing this method for Sage and will be uploading it shortly to this ticket. With it, I will explain some design decisions that I made and provide the (in my opinion) extensive testcases I ran, and later some profiling results (after all tests have ran again, since I lost my profiling info of earlier runs).

CC:  rudi @nathanncohen @dcoudert borassi

Keywords: maximum flow push relabel

Branch: u/foosterhof/ticket/16471

Status: needs_work

Dependencies: #16467, #16470

Commit: 01276c00c318b082e2639c9e59b33118b9c5f8ca

Issue created by migration from https://trac.sagemath.org/ticket/16471





---

archive/issue_comments_212005.json:
```json
{
    "body": "<a id='comment:2'></a>The push implements the push_relabel method, which has an interface much like the flow and _ford_fulkerson methods, except that it has 2 extra optional arguments:\n- use_global_relabeling: Whether or not to use the global relabeling heuristic. Though theoretically very nice, as well as in practice, as stated in some papers, it creates a huge overhead by needing to initialize the Residual Graph. Not using it gave in my own testcases a generally better result, meaning much faster.\n- use_gap_relabeling: A nice heuristic with little overhead. It checks for gaps in the labels that are used by the vertices. If label D is not used, then any vertex with label d for D < d < n can never become active again, so it just relabels them to n then.\n\nFor those interested: This was my testsuite used:\n\n```\ndef test_small_graphs(rangeList = xrange(2, 5)):\n    use_labels = False\n    value = True\n    total = 0\n    set_random_seed(5)\n\n    def test_graph(A):\n        count = 0\n\tfor s in xrange(0, n-1):\n            for t in xrange(0, n-1):\n                count += 1\n                if s != t and A.shortest_path(s, t) != []:\n                    f1, G1 = A._ford_fulkerson(s, t, value_only=value, use_edge_labels= use_labels)\n                    f2, G2 = A.push_relabel(s, t, value_only=value, use_edge_labels = use_labels)\n                    if abs(f1-f2) > 10**(-14)*f1:\n                        print 'Unequal Flows in graph; Ford-Fulkerson:', f1, ' - Push-Relabel:', f2\n                        return False, A, s, t\n        return True, None, None, count\n    \n    for n in rangeList:\n        G = graphs.CompleteGraph(n)\n        E = G.edges()\n        \n        for EP in powerset(E):\n            A = Graph(n, loops=False)\n            A.add_edges(EP)\n            if use_labels:\n                for e in A.edge_iterator():\n                    A.set_edge_label(e[0],e[1], 1+random()*99)\n            good, A, s, t = test_graph(A)\n            if good:\n                total += t\n            else:\n                return False, A, s, t\n        \n        E = G.to_directed().edges()\n        for EP in powerset(E):\n            A = DiGraph(n, loops=False)\n            A.add_edges(EP)\n            if use_labels:\n                for e in A.edge_iterator():\n                    A.set_edge_label(e[0],e[1], 1+random()*99)\n            good, A, s, t = test_graph(A)\n            if good:\n                total += t\n            else:\n                return False, A, s, t\n        print 'Done with', n\n    print 'Done, total number of instances done:', total\n    return True, None, None, None\n\ndef test_random_graphs(size, probability, count):\n    for i in xrange(count):\n        G = digraphs.RandomDirectedGNP(size, probability)\n        if G.shortest_path(0, size-1) != []:\n            f1 = G._ford_fulkerson(0, size-1, use_edge_labels=True, value_only=True)\n            f2 = G.push_relabel(0, size-1, use_edge_labels=True, value_only=True)\n            if abs(f1-f2) > 10**(-14)*f1:\n                print 'Unequal Flows in graph; Ford-Fulkerson:', f1, ' - Push-Relabel:', f2, ' - Absolute Error:', abs(f1-f2), ' - Relative Error:', abs(f1-f2)/f1\n\ndef test(cmd, sort, num):\n    import cProfile, pstats, StringIO\n    pr = cProfile.Profile()\n    pr.run(cmd)\n    ps = pstats.Stats(pr).strip_dirs().sort_stats(sort).print_stats(num)\n```\n\nwith the collowing calling code:\n\n```\ntest(\"good, A, s, t = test_small_graphs([2, 3, 4])\", 'cumulative', int(10))\n\n# NOTE: This test can run extremely long!!\n#test(\"good, A, s, t = test_small_graphs([5])\", 'cumulative', int(10))\n\n# NOTE: This test can also run extremely long when all values (now commented) are used.\nfor size in [10, 20, 50]: #, 100, 200, 500, 1000, 2000]:\n    for probability in [0.2, 0.4, 0.6, 0.8]:\n        count = 10000/size\n        test(\"test_random_graphs(\" + str(size) + \",\" + str(probability) + \",\" + str(count) + \")\", 'cumulative', int(10))\n```\n\nThe testsuite could sure use some revamping, as for instance isomorphism is now neglected, meaning alot of double work, but that is not relevant for its results.\n\nThere are a few questions I have for people out there:\n- Currently, there are quite some subroutines to push_relabel, such as push, relabel, discharge, etc. I am not sure what is customary in Sage, but since they are property of push_relabel, so to speak, I put them inside the push_relabel code, rather than outside.\n- As already stated in the ticket, this depends on two other tickets I have submitted. Commits I made there are used in this code. I do have some experience with git, but not with Trac, and therefor I had no idea how to properly make sure that I could use them on my local computer, but that they would not be committed to this ticket. I am sorry if this push created duplicate code of the commits on the other tickets. Can anyone explain to me how to properly do this? For now, I called\n\n```\nsage: dev.checkout(16471)\nsage: dev.pull(16467)\nsage: dev.pull(16470)\n```\nIs this correct, or is there perhaps a cleaner way to do this?\n\nWith kind regards,\n\nFlorian Oosterhof\n\n---\nNew commits:",
    "created_at": "2014-06-11T15:54:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16471#issuecomment-212005",
    "user": "https://trac.sagemath.org/admin/accounts/users/foosterhof"
}
```

<a id='comment:2'></a>The push implements the push_relabel method, which has an interface much like the flow and _ford_fulkerson methods, except that it has 2 extra optional arguments:
- use_global_relabeling: Whether or not to use the global relabeling heuristic. Though theoretically very nice, as well as in practice, as stated in some papers, it creates a huge overhead by needing to initialize the Residual Graph. Not using it gave in my own testcases a generally better result, meaning much faster.
- use_gap_relabeling: A nice heuristic with little overhead. It checks for gaps in the labels that are used by the vertices. If label D is not used, then any vertex with label d for D < d < n can never become active again, so it just relabels them to n then.

For those interested: This was my testsuite used:

```
def test_small_graphs(rangeList = xrange(2, 5)):
    use_labels = False
    value = True
    total = 0
    set_random_seed(5)

    def test_graph(A):
        count = 0
	for s in xrange(0, n-1):
            for t in xrange(0, n-1):
                count += 1
                if s != t and A.shortest_path(s, t) != []:
                    f1, G1 = A._ford_fulkerson(s, t, value_only=value, use_edge_labels= use_labels)
                    f2, G2 = A.push_relabel(s, t, value_only=value, use_edge_labels = use_labels)
                    if abs(f1-f2) > 10**(-14)*f1:
                        print 'Unequal Flows in graph; Ford-Fulkerson:', f1, ' - Push-Relabel:', f2
                        return False, A, s, t
        return True, None, None, count
    
    for n in rangeList:
        G = graphs.CompleteGraph(n)
        E = G.edges()
        
        for EP in powerset(E):
            A = Graph(n, loops=False)
            A.add_edges(EP)
            if use_labels:
                for e in A.edge_iterator():
                    A.set_edge_label(e[0],e[1], 1+random()*99)
            good, A, s, t = test_graph(A)
            if good:
                total += t
            else:
                return False, A, s, t
        
        E = G.to_directed().edges()
        for EP in powerset(E):
            A = DiGraph(n, loops=False)
            A.add_edges(EP)
            if use_labels:
                for e in A.edge_iterator():
                    A.set_edge_label(e[0],e[1], 1+random()*99)
            good, A, s, t = test_graph(A)
            if good:
                total += t
            else:
                return False, A, s, t
        print 'Done with', n
    print 'Done, total number of instances done:', total
    return True, None, None, None

def test_random_graphs(size, probability, count):
    for i in xrange(count):
        G = digraphs.RandomDirectedGNP(size, probability)
        if G.shortest_path(0, size-1) != []:
            f1 = G._ford_fulkerson(0, size-1, use_edge_labels=True, value_only=True)
            f2 = G.push_relabel(0, size-1, use_edge_labels=True, value_only=True)
            if abs(f1-f2) > 10**(-14)*f1:
                print 'Unequal Flows in graph; Ford-Fulkerson:', f1, ' - Push-Relabel:', f2, ' - Absolute Error:', abs(f1-f2), ' - Relative Error:', abs(f1-f2)/f1

def test(cmd, sort, num):
    import cProfile, pstats, StringIO
    pr = cProfile.Profile()
    pr.run(cmd)
    ps = pstats.Stats(pr).strip_dirs().sort_stats(sort).print_stats(num)
```

with the collowing calling code:

```
test("good, A, s, t = test_small_graphs([2, 3, 4])", 'cumulative', int(10))

# NOTE: This test can run extremely long!!
#test("good, A, s, t = test_small_graphs([5])", 'cumulative', int(10))

# NOTE: This test can also run extremely long when all values (now commented) are used.
for size in [10, 20, 50]: #, 100, 200, 500, 1000, 2000]:
    for probability in [0.2, 0.4, 0.6, 0.8]:
        count = 10000/size
        test("test_random_graphs(" + str(size) + "," + str(probability) + "," + str(count) + ")", 'cumulative', int(10))
```

The testsuite could sure use some revamping, as for instance isomorphism is now neglected, meaning alot of double work, but that is not relevant for its results.

There are a few questions I have for people out there:
- Currently, there are quite some subroutines to push_relabel, such as push, relabel, discharge, etc. I am not sure what is customary in Sage, but since they are property of push_relabel, so to speak, I put them inside the push_relabel code, rather than outside.
- As already stated in the ticket, this depends on two other tickets I have submitted. Commits I made there are used in this code. I do have some experience with git, but not with Trac, and therefor I had no idea how to properly make sure that I could use them on my local computer, but that they would not be committed to this ticket. I am sorry if this push created duplicate code of the commits on the other tickets. Can anyone explain to me how to properly do this? For now, I called

```
sage: dev.checkout(16471)
sage: dev.pull(16467)
sage: dev.pull(16470)
```
Is this correct, or is there perhaps a cleaner way to do this?

With kind regards,

Florian Oosterhof

---
New commits:



---

archive/issue_comments_212006.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-06-13T13:16:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16471#issuecomment-212006",
    "user": "https://trac.sagemath.org/admin/accounts/users/foosterhof"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_212007.json:
```json
{
    "body": "<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-13T13:21:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16471#issuecomment-212007",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_212008.json:
```json
{
    "body": "<a id='comment:6'></a>Hello !!\n\nPlease provide timings if you want to make your function the default one. Also, could you rename it to  `_push_relabel`, as it is the case already for Ford-Fulkerson ?\n\nNathann",
    "created_at": "2014-06-13T13:26:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16471#issuecomment-212008",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:6'></a>Hello !!

Please provide timings if you want to make your function the default one. Also, could you rename it to  `_push_relabel`, as it is the case already for Ford-Fulkerson ?

Nathann



---

archive/issue_comments_212009.json:
```json
{
    "body": "<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-15T13:30:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16471#issuecomment-212009",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_212010.json:
```json
{
    "body": "<a id='comment:8'></a>Profiling Code:\n\n```\ndef test_small_graphs(rangeList = xrange(2, 5)):\n    use_labels = False\n    value = True\n    total = 0\n    set_random_seed(5)\n\n    def test_graph(A):\n        count = 0\n\tfor s in xrange(0, n-1):\n            for t in xrange(0, n-1):\n                count += 1\n                if s != t and A.shortest_path(s, t) != []:\n                    f1 = A._ford_fulkerson(s, t, value_only=value, use_edge_labels= use_labels)\n                    f2 = A._push_relabel(s, t, value_only=value, use_edge_labels = use_labels)\n                    if abs(f1-f2) > 10**(-14)*f1:\n                        print 'Unequal Flows in graph; Ford-Fulkerson:', f1, ' - Push-Relabel:', f2, ' - Absolute Error:', abs(f1-f2), ' - Relative Error:', abs(f1-f2)/f1\n                        return False, A, s, t\n        return True, None, None, count\n    \n    for n in rangeList:\n        for A in graphs(n):\n            if use_labels:\n                for e in A.edge_iterator():\n                    A.set_edge_label(e[0],e[1], 1+random()*99)\n            good, A, s, t = test_graph(A)\n            if good:\n                total += t\n            else:\n                return False, A, s, t\n        \n        for A in digraphs(n):\n            if use_labels:\n                for e in A.edge_iterator():\n                    A.set_edge_label(e[0],e[1], 1+random()*99)\n            good, A, s, t = test_graph(A)\n            if good:\n                total += t\n            else:\n                return False, A, s, t\n        print 'Done with', n\n    print 'Done, total number of instances done:', total\n    return True, None, None, None\n\ndef test_random_graphs(size, probability, count):\n    for i in xrange(count):\n        G = digraphs.RandomDirectedGNP(size, probability)\n        if G.shortest_path(0, size-1) != []:\n            f1, F1 = G._ford_fulkerson(0, size-1, use_edge_labels=True, value_only=False)\n            f2, F2 = G._push_relabel(0, size-1, use_edge_labels=True, value_only=False)\n            if abs(f1-f2) > 10**(-14)*f1:\n                print 'Unequal Flows in graph; Ford-Fulkerson:', f1, ' - Push-Relabel:', f2, ' - Absolute Error:', abs(f1-f2), ' - Relative Error:', abs(f1-f2)/f1\n                \ndef test(cmd, sort, num):\n    import cProfile, pstats, StringIO\n    pr = cProfile.Profile()\n    pr.run(cmd)\n    ps = pstats.Stats(pr).strip_dirs().sort_stats(sort).print_stats(num)\n```\n\nCalling Code:\n\n```\ntest(\"test_small_graphs([2, 3, 4])\", 'cumulative', int(100))\ntest(\"test_small_graphs([5])\", 'cumulative', int(15))\n\nfor size in [10, 20, 50, 100, 200, 500, 1000, 2000]:\n    for probability in [0.2, 0.4, 0.6, 0.8]:\n        count = 10000/size\n        test(\"test_random_graphs(\" + str(size) + \",\" + str(probability) + \",\" + str(count) + \")\", 'cumulative', int(8))\n```\n\nProfiling Data:\n![](http://i62.tinypic.com/19wfx5.png)\n\nFirst column after data represents the relative difference.\n\nThe second column represents the relative speedup.\n\nIn general, I think I can safely say that this method is faster, except for smaller graphs perhaps, though it seems to be at most two times as slow.\n\nThose 2 questions from before still stand:\n- Is the way I nested those functions such as discharge, relabel and push good practice?\n- Is the way I merged the dependency on the other tickets correct?\n\nFlorian",
    "created_at": "2014-06-15T13:56:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16471#issuecomment-212010",
    "user": "https://trac.sagemath.org/admin/accounts/users/foosterhof"
}
```

<a id='comment:8'></a>Profiling Code:

```
def test_small_graphs(rangeList = xrange(2, 5)):
    use_labels = False
    value = True
    total = 0
    set_random_seed(5)

    def test_graph(A):
        count = 0
	for s in xrange(0, n-1):
            for t in xrange(0, n-1):
                count += 1
                if s != t and A.shortest_path(s, t) != []:
                    f1 = A._ford_fulkerson(s, t, value_only=value, use_edge_labels= use_labels)
                    f2 = A._push_relabel(s, t, value_only=value, use_edge_labels = use_labels)
                    if abs(f1-f2) > 10**(-14)*f1:
                        print 'Unequal Flows in graph; Ford-Fulkerson:', f1, ' - Push-Relabel:', f2, ' - Absolute Error:', abs(f1-f2), ' - Relative Error:', abs(f1-f2)/f1
                        return False, A, s, t
        return True, None, None, count
    
    for n in rangeList:
        for A in graphs(n):
            if use_labels:
                for e in A.edge_iterator():
                    A.set_edge_label(e[0],e[1], 1+random()*99)
            good, A, s, t = test_graph(A)
            if good:
                total += t
            else:
                return False, A, s, t
        
        for A in digraphs(n):
            if use_labels:
                for e in A.edge_iterator():
                    A.set_edge_label(e[0],e[1], 1+random()*99)
            good, A, s, t = test_graph(A)
            if good:
                total += t
            else:
                return False, A, s, t
        print 'Done with', n
    print 'Done, total number of instances done:', total
    return True, None, None, None

def test_random_graphs(size, probability, count):
    for i in xrange(count):
        G = digraphs.RandomDirectedGNP(size, probability)
        if G.shortest_path(0, size-1) != []:
            f1, F1 = G._ford_fulkerson(0, size-1, use_edge_labels=True, value_only=False)
            f2, F2 = G._push_relabel(0, size-1, use_edge_labels=True, value_only=False)
            if abs(f1-f2) > 10**(-14)*f1:
                print 'Unequal Flows in graph; Ford-Fulkerson:', f1, ' - Push-Relabel:', f2, ' - Absolute Error:', abs(f1-f2), ' - Relative Error:', abs(f1-f2)/f1
                
def test(cmd, sort, num):
    import cProfile, pstats, StringIO
    pr = cProfile.Profile()
    pr.run(cmd)
    ps = pstats.Stats(pr).strip_dirs().sort_stats(sort).print_stats(num)
```

Calling Code:

```
test("test_small_graphs([2, 3, 4])", 'cumulative', int(100))
test("test_small_graphs([5])", 'cumulative', int(15))

for size in [10, 20, 50, 100, 200, 500, 1000, 2000]:
    for probability in [0.2, 0.4, 0.6, 0.8]:
        count = 10000/size
        test("test_random_graphs(" + str(size) + "," + str(probability) + "," + str(count) + ")", 'cumulative', int(8))
```

Profiling Data:
![](http://i62.tinypic.com/19wfx5.png)

First column after data represents the relative difference.

The second column represents the relative speedup.

In general, I think I can safely say that this method is faster, except for smaller graphs perhaps, though it seems to be at most two times as slow.

Those 2 questions from before still stand:
- Is the way I nested those functions such as discharge, relabel and push good practice?
- Is the way I merged the dependency on the other tickets correct?

Florian



---

archive/issue_comments_212011.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-18T12:38:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16471#issuecomment-212011",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_events_048411.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16471#event-48411"
}
```



---

archive/issue_comments_212012.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-09-20T13:09:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16471#issuecomment-212012",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_212013.json:
```json
{
    "body": "<a id='comment:11'></a>This ticket need to be rebased, and in the meantime we have a new `flow` function through igraph. Set to `needs_work`",
    "created_at": "2015-09-20T13:09:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16471",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16471#issuecomment-212013",
    "user": "https://github.com/nathanncohen"
}
```

<a id='comment:11'></a>This ticket need to be rebased, and in the meantime we have a new `flow` function through igraph. Set to `needs_work`
