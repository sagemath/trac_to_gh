# Issue 16014: Improvements to discriminant computation

archive/issues_015777.json:
```json
{
    "body": "Currently (i.e. on sage 6.1.1), the discriminant computation fails with a segmenttation fault when the coefficients are too complicated. For example:\n\n```python\nPR.<b,t1,t2,x1,y1,x2,y2> = QQ[]\nPRmu.<mu> = PR[]\nE1 = diagonal_matrix(PR, [1, b^2, -b^2])\nRotScale = matrix(PR, [[1, -t1, 0], [t1, 1, 0], [0, 0, 1]])\nE2 = diagonal_matrix(PR, [1, 1, 1+t1^2])*RotScale.transpose()*E1*RotScale\nTransl = matrix(PR, [[1, 0, -x1], [0, 1, -y1], [0, 0, 1]])\nE3 = Transl.transpose()*E2*Transl\nE4 = E3.subs(t1=t2, x1=x2, y1=y2)\ndet(mu*E3 + E4).discriminant()\n```\n\nApparently the Python interpreter reaches some limit on the depth of the call stack, since it seems to call `symtable_visit_expr` from `Python-2.7.6/Python/symtable.c:1191` over and over and over again. But this ticket here is not about fixing Python. (If you want a ticket for that, feel free to create one and provide a reference here.)\n\nInstead, one should observe that the above is only a discriminant of a third degree polynomial. As such, it has an easy and well-known formula for the discriminant. Plugging the complicated coefficients into this easy formula leads to the solution rather quickly (considering the immense size of said solution). So perhaps we should employ this approach in the `discriminant` method.\n\nI've [discussed this question on sage-support](https://groups.google.com/d/topic/sage-support/fABfhHyioa0/discussion), and will probably continue the discussion. Right now, I'm unsure about when to choose a new method over the existing one. Should it be based on degree, using hardcoded versions of the well-known discriminants for lower degrees? Or should it rather be based on base ring, thus employing a computation over some simple generators instead of the full coefficients if the base ring is a polynomial ring or some other fairly complex object. Here is a code snippet to illustrate the latter idea:\n\n```python\ndef generic_discriminant(p):\n    \"\"\"\n    Compute discriminant of univariate (sparse or dense) polynomial.\n   \n    The discriminant is computed in two steps. First all non-zero\n    coefficients of the polynomial are replaced with variables, and\n    the discriminant is computed using these variables. Then the\n    original coefficients are substituted into the result of this\n    computation. This should be faster in many cases, particularly\n    with big coefficients like complicated polynomials. In those\n    cases, the matrix computation on simple generators is a lot\n    faster, and the final substitution is cheaper than carrying all\n    that information along at all times.\n    \"\"\"\n    pr = p.parent()\n    if not pr.ngens() == 1:\n        raise ValueError(\"Must be univariate\")\n    ex = p.exponents()\n    pr1 = PolynomialRing(ZZ, \"x\", len(ex))\n    pr2.<y> = pr1[]\n    py = sum(v*y^e for v, e in zip(pr1.gens(), ex))\n    d = py.discriminant()\n    return d(p.coefficients())\n```\n\nPersonally I think I prefer a case distinction based on base ring, or a combination. If we do the case distinction based on base ring, then I'd also value some input as to what rings should make use of this new approach, and how to check for them. For example, I just noticed that #15061 discusses issues with discriminants of polynomials over power series. So I guess those might benefit from this approach as well.\n\n**CC:**  @pjbruin\n\n**Keywords:** discriminant\n\n**Branch:** [1892c84d6372e882fa0c39667d06ba83cc61f3be](https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be)\n\n**Reviewer:** Peter Bruin\n\n**Author:** Martin von Gagern\n\nIssue created by migration from https://trac.sagemath.org/ticket/16014\n\n",
    "closed_at": "2014-04-20T16:43:53Z",
    "created_at": "2014-03-26T14:11:15Z",
    "labels": [
        "component: algebra",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.2",
    "title": "Improvements to discriminant computation",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/16014",
    "user": "https://github.com/gagern"
}
```
Currently (i.e. on sage 6.1.1), the discriminant computation fails with a segmenttation fault when the coefficients are too complicated. For example:

```python
PR.<b,t1,t2,x1,y1,x2,y2> = QQ[]
PRmu.<mu> = PR[]
E1 = diagonal_matrix(PR, [1, b^2, -b^2])
RotScale = matrix(PR, [[1, -t1, 0], [t1, 1, 0], [0, 0, 1]])
E2 = diagonal_matrix(PR, [1, 1, 1+t1^2])*RotScale.transpose()*E1*RotScale
Transl = matrix(PR, [[1, 0, -x1], [0, 1, -y1], [0, 0, 1]])
E3 = Transl.transpose()*E2*Transl
E4 = E3.subs(t1=t2, x1=x2, y1=y2)
det(mu*E3 + E4).discriminant()
```

Apparently the Python interpreter reaches some limit on the depth of the call stack, since it seems to call `symtable_visit_expr` from `Python-2.7.6/Python/symtable.c:1191` over and over and over again. But this ticket here is not about fixing Python. (If you want a ticket for that, feel free to create one and provide a reference here.)

Instead, one should observe that the above is only a discriminant of a third degree polynomial. As such, it has an easy and well-known formula for the discriminant. Plugging the complicated coefficients into this easy formula leads to the solution rather quickly (considering the immense size of said solution). So perhaps we should employ this approach in the `discriminant` method.

I've [discussed this question on sage-support](https://groups.google.com/d/topic/sage-support/fABfhHyioa0/discussion), and will probably continue the discussion. Right now, I'm unsure about when to choose a new method over the existing one. Should it be based on degree, using hardcoded versions of the well-known discriminants for lower degrees? Or should it rather be based on base ring, thus employing a computation over some simple generators instead of the full coefficients if the base ring is a polynomial ring or some other fairly complex object. Here is a code snippet to illustrate the latter idea:

```python
def generic_discriminant(p):
    """
    Compute discriminant of univariate (sparse or dense) polynomial.
   
    The discriminant is computed in two steps. First all non-zero
    coefficients of the polynomial are replaced with variables, and
    the discriminant is computed using these variables. Then the
    original coefficients are substituted into the result of this
    computation. This should be faster in many cases, particularly
    with big coefficients like complicated polynomials. In those
    cases, the matrix computation on simple generators is a lot
    faster, and the final substitution is cheaper than carrying all
    that information along at all times.
    """
    pr = p.parent()
    if not pr.ngens() == 1:
        raise ValueError("Must be univariate")
    ex = p.exponents()
    pr1 = PolynomialRing(ZZ, "x", len(ex))
    pr2.<y> = pr1[]
    py = sum(v*y^e for v, e in zip(pr1.gens(), ex))
    d = py.discriminant()
    return d(p.coefficients())
```

Personally I think I prefer a case distinction based on base ring, or a combination. If we do the case distinction based on base ring, then I'd also value some input as to what rings should make use of this new approach, and how to check for them. For example, I just noticed that #15061 discusses issues with discriminants of polynomials over power series. So I guess those might benefit from this approach as well.

**CC:**  @pjbruin

**Keywords:** discriminant

**Branch:** [1892c84d6372e882fa0c39667d06ba83cc61f3be](https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be)

**Reviewer:** Peter Bruin

**Author:** Martin von Gagern

Issue created by migration from https://trac.sagemath.org/ticket/16014





---

archive/issue_comments_205987.json:
```json
{
    "body": "**Branch:** [u/gagern/ticket/16014](https://github.com/sagemath/sagetrac-mirror/tree/u/gagern/ticket/16014)",
    "created_at": "2014-03-27T00:15:13Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205987",
    "user": "https://github.com/gagern"
}
```

**Branch:** [u/gagern/ticket/16014](https://github.com/sagemath/sagetrac-mirror/tree/u/gagern/ticket/16014)



---

archive/issue_comments_205988.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -45,5 +45,3 @@\n ```\n \n Personally I think I prefer a case distinction based on base ring, or a combination. If we do the case distinction based on base ring, then I'd also value some input as to what rings should make use of this new approach, and how to check for them. For example, I just noticed that #15061 discusses issues with discriminants of polynomials over power series. So I guess those might benefit from this approach as well.\n-\n-I intend to create a git branch once I know the direction to take, but I'd prefer some discussion up front to know what direction to take, how to make my case distinctions, and where to place my new code.\n``````\n",
    "created_at": "2014-03-27T00:19:35Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205988",
    "user": "https://github.com/gagern"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -45,5 +45,3 @@
 ```
 
 Personally I think I prefer a case distinction based on base ring, or a combination. If we do the case distinction based on base ring, then I'd also value some input as to what rings should make use of this new approach, and how to check for them. For example, I just noticed that #15061 discusses issues with discriminants of polynomials over power series. So I guess those might benefit from this approach as well.
-
-I intend to create a git branch once I know the direction to take, but I'd prefer some discussion up front to know what direction to take, how to make my case distinctions, and where to place my new code.
``````




---

archive/issue_comments_205989.json:
```json
{
    "body": "<a id='comment:2'></a>\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/28980e9539c18fe3b9b7751ecd480e11e2089ddb\">28980e9</a></td><td><code>Added test case to expose the segfault of discriminant.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0758de125303597e5d207e5c272a003287ebe705\">0758de1</a></td><td><code>Drive-by fix to TeX notation in docstring.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d5e03075e3a9a8beac80396027413256d9b39289\">d5e0307</a></td><td><code>Use simple coefficients if base is multivariate polynomial.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/66a8c198b7aa57f4567906baf964b30b88f4048f\">66a8c19</a></td><td><code>Compute discriminant of power series polynomial using substitution.</code></td></tr></table>\n",
    "created_at": "2014-03-27T00:19:35Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205989",
    "user": "https://github.com/gagern"
}
```

<a id='comment:2'></a>
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/28980e9539c18fe3b9b7751ecd480e11e2089ddb">28980e9</a></td><td><code>Added test case to expose the segfault of discriminant.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0758de125303597e5d207e5c272a003287ebe705">0758de1</a></td><td><code>Drive-by fix to TeX notation in docstring.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d5e03075e3a9a8beac80396027413256d9b39289">d5e0307</a></td><td><code>Use simple coefficients if base is multivariate polynomial.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/66a8c198b7aa57f4567906baf964b30b88f4048f">66a8c19</a></td><td><code>Compute discriminant of power series polynomial using substitution.</code></td></tr></table>




---

archive/issue_events_142481.json:
```json
{
    "actor": "https://github.com/gagern",
    "created_at": "2014-03-27T00:19:35Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16014#event-142481"
}
```



---

archive/issue_comments_205990.json:
```json
{
    "body": "**Commit:** [66a8c198b7aa57f4567906baf964b30b88f4048f](https://github.com/sagemath/sagetrac-mirror/commit/66a8c198b7aa57f4567906baf964b30b88f4048f)",
    "created_at": "2014-03-27T00:19:35Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205990",
    "user": "https://github.com/gagern"
}
```

**Commit:** [66a8c198b7aa57f4567906baf964b30b88f4048f](https://github.com/sagemath/sagetrac-mirror/commit/66a8c198b7aa57f4567906baf964b30b88f4048f)



---

archive/issue_comments_205991.json:
```json
{
    "body": "<a id='comment:3'></a>\nWhat I implemented so far is a case distinction based on the base ring, with the new implementation being used for multivariate polynomials and power series.\n\nI implemented the new code in the existing method for now, in part because I wasn't sure whether I should add new methods (e.g. `discriminant_by_resultant` and `discriminant_by_substitution`) or rather an `algorithm` argument for the `discriminant` method. In the latter case, the code would stay in that method but be reorganized because the substitution version could call the resultant version instead of executing that computation directly.\n\nI'm not sure about this whole `ZeroDivisionError` stuff from #11782 resp. [a224fe3](https://github.com/sagemath/sagetrac-mirror/commit/a224fe31d5c960ce56acf2e09e0f408ef92c0899). When doing the substitution approach, there should be no zero divisors, so replacing `self` by `poly` in that exception handler is only for the sake of consistency, but not really required. I guess if I were to write code for the substitution approach exclusively, I might consider using `// poly[n]` instead of `* an` to avoid the detour to the fraction field.",
    "created_at": "2014-03-27T08:49:06Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205991",
    "user": "https://github.com/gagern"
}
```

<a id='comment:3'></a>
What I implemented so far is a case distinction based on the base ring, with the new implementation being used for multivariate polynomials and power series.

I implemented the new code in the existing method for now, in part because I wasn't sure whether I should add new methods (e.g. `discriminant_by_resultant` and `discriminant_by_substitution`) or rather an `algorithm` argument for the `discriminant` method. In the latter case, the code would stay in that method but be reorganized because the substitution version could call the resultant version instead of executing that computation directly.

I'm not sure about this whole `ZeroDivisionError` stuff from #11782 resp. [a224fe3](https://github.com/sagemath/sagetrac-mirror/commit/a224fe31d5c960ce56acf2e09e0f408ef92c0899). When doing the substitution approach, there should be no zero divisors, so replacing `self` by `poly` in that exception handler is only for the sake of consistency, but not really required. I guess if I were to write code for the substitution approach exclusively, I might consider using `// poly[n]` instead of `* an` to avoid the detour to the fraction field.



---

archive/issue_comments_205992.json:
```json
{
    "body": "<a id='comment:5'></a>\nThis looks good and passes doctests.  However, I'm wondering if you couldn't be convinced to adopt John Cremona's [proposal on sage-dev](https://groups.google.com/d/msg/sage-support/fABfhHyioa0/kPlhGN4Ri-EJ) to have a separate function `generic_univariate_discriminant()` (or similar), which caches its output, and hardcodes it for small degrees.  This would be useful for two reasons:\n- computing the universal discriminant takes a substantial amount of time (several seconds for degree 7, several minutes for degree 8, probably extremely long for higher degrees);\n- it would make the `discriminant()` method cleaner and therefore more attractive to add an `algorithm` flag and/or a more sophisticated algorithm selection heuristic.\nI would think `sage.rings.polynomial.polynomial_element` would be a logical place for such a function, although `sage.rings.invariant_theory` would also be defensible.\n\nHere is a simple function to compute the universal discriminant:\n\n```python\ndef universal_discriminant(n):\n    r\"\"\"Return the discriminant of the 'universal' univariate polynomial\n    `a_n x^n + \\cdots + a_1 x + a_0` in `\\ZZ[a_0, \\ldots, a_n][x]`.\"\"\"\n    R = PolynomialRing(ZZ, n + 1, 'a')\n    S = PolynomialRing(R, 'x')\n    return S(list(R.gens())).discriminant()\n```",
    "created_at": "2014-04-07T12:47:48Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205992",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:5'></a>
This looks good and passes doctests.  However, I'm wondering if you couldn't be convinced to adopt John Cremona's [proposal on sage-dev](https://groups.google.com/d/msg/sage-support/fABfhHyioa0/kPlhGN4Ri-EJ) to have a separate function `generic_univariate_discriminant()` (or similar), which caches its output, and hardcodes it for small degrees.  This would be useful for two reasons:
- computing the universal discriminant takes a substantial amount of time (several seconds for degree 7, several minutes for degree 8, probably extremely long for higher degrees);
- it would make the `discriminant()` method cleaner and therefore more attractive to add an `algorithm` flag and/or a more sophisticated algorithm selection heuristic.
I would think `sage.rings.polynomial.polynomial_element` would be a logical place for such a function, although `sage.rings.invariant_theory` would also be defensible.

Here is a simple function to compute the universal discriminant:

```python
def universal_discriminant(n):
    r"""Return the discriminant of the 'universal' univariate polynomial
    `a_n x^n + \cdots + a_1 x + a_0` in `\ZZ[a_0, \ldots, a_n][x]`."""
    R = PolynomialRing(ZZ, n + 1, 'a')
    S = PolynomialRing(R, 'x')
    return S(list(R.gens())).discriminant()
```



---

archive/issue_comments_205993.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be\">1892c84</a></td><td><code>Introduce a caching function universal_discriminant.</code></td></tr></table>\n",
    "created_at": "2014-04-16T16:01:45Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205993",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be">1892c84</a></td><td><code>Introduce a caching function universal_discriminant.</code></td></tr></table>




---

archive/issue_comments_205994.json:
```json
{
    "body": "**Changing commit** from \"[66a8c198b7aa57f4567906baf964b30b88f4048f](https://github.com/sagemath/sagetrac-mirror/commit/66a8c198b7aa57f4567906baf964b30b88f4048f)\" to \"[1892c84d6372e882fa0c39667d06ba83cc61f3be](https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be)\".",
    "created_at": "2014-04-16T16:01:45Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205994",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[66a8c198b7aa57f4567906baf964b30b88f4048f](https://github.com/sagemath/sagetrac-mirror/commit/66a8c198b7aa57f4567906baf964b30b88f4048f)" to "[1892c84d6372e882fa0c39667d06ba83cc61f3be](https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be)".



---

archive/issue_comments_205995.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [pbruin](#comment%3A5):\n> I'm wondering if you couldn't be convinced to adopt John Cremona's [proposal on sage-dev](https://groups.google.com/d/msg/sage-support/fABfhHyioa0/kPlhGN4Ri-EJ) to have a separate function `generic_univariate_discriminant()` (or similar), which caches its output, and hardcodes it for small degrees.\n\nSure I can be convinced, particularly if two people request something. I've implemented the caching, but not the hardcoding so far. I wonder how small \u201csmall\u201d actually should be. Up to 7, things compute fairly quickly so there seems to be little benefit from hardcoding, particularly since we do caching. For higher degrees, computing them for hardcoding takes considerable time, and writing down the hard code will take up quite a lot of space in the source file. Should this really be implemented in Cython code, or should we make some effort to obtain or compute discriminants up to say 10 or so and store them in some kind of persistent data representation instead of source code?\n\nI also wonder how public this function should be. I prefer `polynomial_element` over `invariant_theory` simply because it keeps all my changes in one place. I've written a full docstring for the code, and inside that docstring I had to import the function. Is this a reasonable approach? Should I add the function to `sage.rings.polynomial.all`? Should I prepend the function name with an underscore to mark it non-public?\n\nI also have a question regarding my late import. I noticed the `cdef void late_import` near the beginning of the module. I could add `is_PowerSeriesRing` to that. But on the other hand, it seems as if that function only gets called by `Polynomial.roots`. Which suggests that I might not be able to rely on `is_PowertSeriesRing` if I were to follow that approach. Do you agree with keeping the import where I have it so far? Should the function `late_import` be renamed to something like `late_import_for_root` to make it clearer that this does no general late importing but specific to that method? Or should I add my imports to that function and make sure to call `late_import` in `discriminant` as well?\n\nShould I add myself as an author of that module, at the beginning of the file?",
    "created_at": "2014-04-16T16:29:06Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205995",
    "user": "https://github.com/gagern"
}
```

<a id='comment:7'></a>
Replying to [pbruin](#comment%3A5):
> I'm wondering if you couldn't be convinced to adopt John Cremona's [proposal on sage-dev](https://groups.google.com/d/msg/sage-support/fABfhHyioa0/kPlhGN4Ri-EJ) to have a separate function `generic_univariate_discriminant()` (or similar), which caches its output, and hardcodes it for small degrees.

Sure I can be convinced, particularly if two people request something. I've implemented the caching, but not the hardcoding so far. I wonder how small “small” actually should be. Up to 7, things compute fairly quickly so there seems to be little benefit from hardcoding, particularly since we do caching. For higher degrees, computing them for hardcoding takes considerable time, and writing down the hard code will take up quite a lot of space in the source file. Should this really be implemented in Cython code, or should we make some effort to obtain or compute discriminants up to say 10 or so and store them in some kind of persistent data representation instead of source code?

I also wonder how public this function should be. I prefer `polynomial_element` over `invariant_theory` simply because it keeps all my changes in one place. I've written a full docstring for the code, and inside that docstring I had to import the function. Is this a reasonable approach? Should I add the function to `sage.rings.polynomial.all`? Should I prepend the function name with an underscore to mark it non-public?

I also have a question regarding my late import. I noticed the `cdef void late_import` near the beginning of the module. I could add `is_PowerSeriesRing` to that. But on the other hand, it seems as if that function only gets called by `Polynomial.roots`. Which suggests that I might not be able to rely on `is_PowertSeriesRing` if I were to follow that approach. Do you agree with keeping the import where I have it so far? Should the function `late_import` be renamed to something like `late_import_for_root` to make it clearer that this does no general late importing but specific to that method? Or should I add my imports to that function and make sure to call `late_import` in `discriminant` as well?

Should I add myself as an author of that module, at the beginning of the file?



---

archive/issue_comments_205996.json:
```json
{
    "body": "<a id='comment:8'></a>\nReplying to [gagern](#comment%3A7):\n> Replying to [pbruin](#comment%3A5):\n> > I'm wondering if you couldn't be convinced to adopt John Cremona's [proposal on sage-dev](https://groups.google.com/d/msg/sage-support/fABfhHyioa0/kPlhGN4Ri-EJ) to have a separate function `generic_univariate_discriminant()` (or similar), which caches its output, and hardcodes it for small degrees.\n\n> \n> Sure I can be convinced, particularly if two people request something. I've implemented the caching, but not the hardcoding so far. I wonder how small \u201csmall\u201d actually should be. Up to 7, things compute fairly quickly so there seems to be little benefit from hardcoding, particularly since we do caching.\n\nThanks, this looks very good.  You're probably right about not hardcoding the polynomials.\n> For higher degrees, computing them for hardcoding takes considerable time, and writing down the hard code will take up quite a lot of space in the source file. Should this really be implemented in Cython code, or should we make some effort to obtain or compute discriminants up to say 10 or so and store them in some kind of persistent data representation instead of source code?\n\nMaybe, but I doubt it is very important.  If at all, it should be done in a later ticket.\n> I also wonder how public this function should be. I prefer `polynomial_element` over `invariant_theory` simply because it keeps all my changes in one place. I've written a full docstring for the code, and inside that docstring I had to import the function. Is this a reasonable approach? Should I add the function to `sage.rings.polynomial.all`? Should I prepend the function name with an underscore to mark it non-public?\n\nI actually agree completely with the way you did all these things.  I wouldn't add anything to `sage.rings.polynomial.all`; this would add it to the global namespace, which is already very crowded. \n> I also have a question regarding my late import. I noticed the `cdef void late_import` near the beginning of the module. I could add `is_PowerSeriesRing` to that. But on the other hand, it seems as if that function only gets called by `Polynomial.roots`. Which suggests that I might not be able to rely on `is_PowertSeriesRing` if I were to follow that approach. Do you agree with keeping the import where I have it so far? Should the function `late_import` be renamed to something like `late_import_for_root` to make it clearer that this does no general late importing but specific to that method? Or should I add my imports to that function and make sure to call `late_import` in `discriminant` as well?\n\nHere, too, I think the way you did it is absolutely fine.  In fact one can argue that modules should generally be imported locally in the function that needs it.  On the other hand, global imports (including the `late_import` approach) are useful if the imported module is used in many places, or if the function is time-critical enough that a local import would add too much overhead.\n> Should I add myself as an author of that module, at the beginning of the file?\n\nIf you want; as you will have seen, authors for some other additions/changes are listed, but it is certainly not done in a very systematic way througout Sage.  In any case, your changes and authorship will be remembered by the revision control system, and using `git annotate` gives a line-by-line overview of who wrote/changed what.\n\nCould you also fill in your name (i.e. real name, not Trac username) in the \"Author\" field of this ticket?\n\nI will test this and then set it to positive review.",
    "created_at": "2014-04-16T21:57:11Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205996",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:8'></a>
Replying to [gagern](#comment%3A7):
> Replying to [pbruin](#comment%3A5):
> > I'm wondering if you couldn't be convinced to adopt John Cremona's [proposal on sage-dev](https://groups.google.com/d/msg/sage-support/fABfhHyioa0/kPlhGN4Ri-EJ) to have a separate function `generic_univariate_discriminant()` (or similar), which caches its output, and hardcodes it for small degrees.

> 
> Sure I can be convinced, particularly if two people request something. I've implemented the caching, but not the hardcoding so far. I wonder how small “small” actually should be. Up to 7, things compute fairly quickly so there seems to be little benefit from hardcoding, particularly since we do caching.

Thanks, this looks very good.  You're probably right about not hardcoding the polynomials.
> For higher degrees, computing them for hardcoding takes considerable time, and writing down the hard code will take up quite a lot of space in the source file. Should this really be implemented in Cython code, or should we make some effort to obtain or compute discriminants up to say 10 or so and store them in some kind of persistent data representation instead of source code?

Maybe, but I doubt it is very important.  If at all, it should be done in a later ticket.
> I also wonder how public this function should be. I prefer `polynomial_element` over `invariant_theory` simply because it keeps all my changes in one place. I've written a full docstring for the code, and inside that docstring I had to import the function. Is this a reasonable approach? Should I add the function to `sage.rings.polynomial.all`? Should I prepend the function name with an underscore to mark it non-public?

I actually agree completely with the way you did all these things.  I wouldn't add anything to `sage.rings.polynomial.all`; this would add it to the global namespace, which is already very crowded. 
> I also have a question regarding my late import. I noticed the `cdef void late_import` near the beginning of the module. I could add `is_PowerSeriesRing` to that. But on the other hand, it seems as if that function only gets called by `Polynomial.roots`. Which suggests that I might not be able to rely on `is_PowertSeriesRing` if I were to follow that approach. Do you agree with keeping the import where I have it so far? Should the function `late_import` be renamed to something like `late_import_for_root` to make it clearer that this does no general late importing but specific to that method? Or should I add my imports to that function and make sure to call `late_import` in `discriminant` as well?

Here, too, I think the way you did it is absolutely fine.  In fact one can argue that modules should generally be imported locally in the function that needs it.  On the other hand, global imports (including the `late_import` approach) are useful if the imported module is used in many places, or if the function is time-critical enough that a local import would add too much overhead.
> Should I add myself as an author of that module, at the beginning of the file?

If you want; as you will have seen, authors for some other additions/changes are listed, but it is certainly not done in a very systematic way througout Sage.  In any case, your changes and authorship will be remembered by the revision control system, and using `git annotate` gives a line-by-line overview of who wrote/changed what.

Could you also fill in your name (i.e. real name, not Trac username) in the "Author" field of this ticket?

I will test this and then set it to positive review.



---

archive/issue_comments_205997.json:
```json
{
    "body": "**Reviewer:** Peter Bruin",
    "created_at": "2014-04-16T21:57:11Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205997",
    "user": "https://github.com/pjbruin"
}
```

**Reviewer:** Peter Bruin



---

archive/issue_comments_205998.json:
```json
{
    "body": "<a id='comment:9'></a>\nAll tests pass and I am happy with the patch as it is.  Please add your name and set the ticket to positive review.",
    "created_at": "2014-04-16T22:59:08Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205998",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:9'></a>
All tests pass and I am happy with the patch as it is.  Please add your name and set the ticket to positive review.



---

archive/issue_events_142482.json:
```json
{
    "actor": "https://github.com/gagern",
    "created_at": "2014-04-17T04:29:10Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16014#event-142482"
}
```



---

archive/issue_events_142483.json:
```json
{
    "actor": "https://github.com/gagern",
    "created_at": "2014-04-17T04:29:10Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16014#event-142483"
}
```



---

archive/issue_comments_205999.json:
```json
{
    "body": "**Author:** Martin von Gagern",
    "created_at": "2014-04-17T04:29:10Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-205999",
    "user": "https://github.com/gagern"
}
```

**Author:** Martin von Gagern



---

archive/issue_events_142484.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-04-20T16:43:53Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16014#event-142484"
}
```



---

archive/issue_events_142485.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "5574c7af05f36c139c3b22cb09e3a3726080f733",
    "created_at": "2014-04-20T16:43:53Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/16014#event-142485"
}
```



---

archive/issue_comments_206000.json:
```json
{
    "body": "**Changing branch** from \"[u/gagern/ticket/16014](https://github.com/sagemath/sagetrac-mirror/tree/u/gagern/ticket/16014)\" to \"[1892c84d6372e882fa0c39667d06ba83cc61f3be](https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be)\".",
    "created_at": "2014-04-20T16:43:53Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-206000",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[u/gagern/ticket/16014](https://github.com/sagemath/sagetrac-mirror/tree/u/gagern/ticket/16014)" to "[1892c84d6372e882fa0c39667d06ba83cc61f3be](https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be)".



---

archive/issue_comments_206001.json:
```json
{
    "body": "**Changing commit** from \"[1892c84d6372e882fa0c39667d06ba83cc61f3be](https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be)\" to \"\".",
    "created_at": "2016-08-22T16:12:58Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-206001",
    "user": "https://github.com/embray"
}
```

**Changing commit** from "[1892c84d6372e882fa0c39667d06ba83cc61f3be](https://github.com/sagemath/sagetrac-mirror/commit/1892c84d6372e882fa0c39667d06ba83cc61f3be)" to "".



---

archive/issue_comments_206002.json:
```json
{
    "body": "<a id='comment:12'></a>\nFWIW the segfault in Python was fixed in newer Python versions: http://bugs.python.org/issue5765\n\nFor some reason (it seems just developer resources) a version of the patch was never backported to 2.7.  I might take a stab at that (and open a separate ticket if so).  Note the patch doesn't magically allow unlimited stack depth and one can still blow the stack.  But with the default settings it will raise a `RuntimeError` instead, and give one the opportunity to increase the limit with `sys.setrecursionlimit`.",
    "created_at": "2016-08-22T16:12:58Z",
    "issue": "https://github.com/sagemath/sage/issues/16014",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/16014#issuecomment-206002",
    "user": "https://github.com/embray"
}
```

<a id='comment:12'></a>
FWIW the segfault in Python was fixed in newer Python versions: http://bugs.python.org/issue5765

For some reason (it seems just developer resources) a version of the patch was never backported to 2.7.  I might take a stab at that (and open a separate ticket if so).  Note the patch doesn't magically allow unlimited stack depth and one can still blow the stack.  But with the default settings it will raise a `RuntimeError` instead, and give one the opportunity to increase the limit with `sys.setrecursionlimit`.
