# Issue 16385: Fix rounding ZZ -> Python float

archive/issues_016148.json:
```json
{
    "body": "Consider the following conversions:\nA. Sage `Integer` -> Python `float` (or Sage `RDF`)\nB. Python `int`/`long` -> Python `float`\nC. Sage `Integer` -> Sage `RR`\nD. C `unsigned long` -> C `double`\n\nConversion A rounds to zero, while the others round to nearest (by default). We should make A consistent with the rest:\n\n```\nsage: int(float(ZZ(10^17-1)))\n99999999999999984\nsage: int(float(int(10^17-1)))\n100000000000000000\nsage: int(RR(10^17-1))\n100000000000000000\nsage: cython(\"\"\"print <unsigned long>(<double> (%sUL))\"\"\" % (10^17-1))\n100000000000000000\n```\n\nCurrently, `Integer` -> `float` uses `mpz_get_d()` which rounds to zero. We should fix this, similar to #14416.\n\nCC:  @zimmermann6\n\nBranch/Commit: 04138f3d9118767c4062f4a7166b89b591846e3a\n\nReviewer: Christoph Lauter, Marc Mezzarobba\n\nAuthor: Jeroen Demeyer\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/16385\n\n",
    "closed_at": "2014-05-29T14:51:24Z",
    "created_at": "2014-05-21T15:44:49Z",
    "labels": [
        "component: basic arithmetic",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.3",
    "title": "Fix rounding ZZ -> Python float",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16385",
    "user": "https://github.com/jdemeyer"
}
```
Consider the following conversions:
A. Sage `Integer` -> Python `float` (or Sage `RDF`)
B. Python `int`/`long` -> Python `float`
C. Sage `Integer` -> Sage `RR`
D. C `unsigned long` -> C `double`

Conversion A rounds to zero, while the others round to nearest (by default). We should make A consistent with the rest:

```
sage: int(float(ZZ(10^17-1)))
99999999999999984
sage: int(float(int(10^17-1)))
100000000000000000
sage: int(RR(10^17-1))
100000000000000000
sage: cython("""print <unsigned long>(<double> (%sUL))""" % (10^17-1))
100000000000000000
```

Currently, `Integer` -> `float` uses `mpz_get_d()` which rounds to zero. We should fix this, similar to #14416.

CC:  @zimmermann6

Branch/Commit: 04138f3d9118767c4062f4a7166b89b591846e3a

Reviewer: Christoph Lauter, Marc Mezzarobba

Author: Jeroen Demeyer

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/16385





---

archive/issue_comments_210525.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-05-22T14:43:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16385",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16385#issuecomment-210525",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_210526.json:
```json
{
    "body": "<a id='comment:5'></a>New commits:",
    "created_at": "2014-05-22T14:43:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16385",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16385#issuecomment-210526",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:5'></a>New commits:



---

archive/issue_comments_210527.json:
```json
{
    "body": "<a id='comment:6'></a>Looks good to me. But Christoph Lauter sitting next to me noticed that expressions like `1.0/0.0` raise the *Division by zero* FP exception, while IEEE-754 conversions are supposed to raise *Overflow* when the result is too large to be represented in the target format.\n\nAnother minor issue is that your `mpz_get_d_nearest` actually assumes that the current hardware rounding mode is round-to-nearest, because the final call to `ldexp` can overflow:\n\n```\nsage: b = 2^1024-1\nsage: float(b)\ninf\nsage: from ctypes import cdll                                                                 \nsage: from ctypes.util import find_library                                                    \nsage: libm = cdll.LoadLibrary(find_library('m'))                                              \nsage: FE_TOWARDZERO = int(0xc00)                                                              \nsage: libm.fesetround(FE_TOWARDZERO)\n0\nsage: float(b)\n1.7976931348623157e+308\n```\n\nBut I don't know if we really want to go into this kind of business in sage, and your patch clearly improves the previous implementation. So I'll give it positive review and let you decide if you want to support FP flags and non-default rounding modes.\n\nChristoph also suggests to simplify the code a bit by remplacing the part that rounds from 64 to 63 bits by something like\n\n```\nd = <double> ((q64 << 1 ) | !remainder_is_zero)\n```\n(Of course, this version also assumes that the FPU rounds to nearest.)",
    "created_at": "2014-05-27T13:49:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16385",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16385#issuecomment-210527",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:6'></a>Looks good to me. But Christoph Lauter sitting next to me noticed that expressions like `1.0/0.0` raise the *Division by zero* FP exception, while IEEE-754 conversions are supposed to raise *Overflow* when the result is too large to be represented in the target format.

Another minor issue is that your `mpz_get_d_nearest` actually assumes that the current hardware rounding mode is round-to-nearest, because the final call to `ldexp` can overflow:

```
sage: b = 2^1024-1
sage: float(b)
inf
sage: from ctypes import cdll                                                                 
sage: from ctypes.util import find_library                                                    
sage: libm = cdll.LoadLibrary(find_library('m'))                                              
sage: FE_TOWARDZERO = int(0xc00)                                                              
sage: libm.fesetround(FE_TOWARDZERO)
0
sage: float(b)
1.7976931348623157e+308
```

But I don't know if we really want to go into this kind of business in sage, and your patch clearly improves the previous implementation. So I'll give it positive review and let you decide if you want to support FP flags and non-default rounding modes.

Christoph also suggests to simplify the code a bit by remplacing the part that rounds from 64 to 63 bits by something like

```
d = <double> ((q64 << 1 ) | !remainder_is_zero)
```
(Of course, this version also assumes that the FPU rounds to nearest.)



---

archive/issue_comments_210528.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-05-27T13:49:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16385",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16385#issuecomment-210528",
    "user": "https://github.com/mezzarobba"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_210529.json:
```json
{
    "body": "<a id='comment:7'></a>Another minor point in case you decide to further improve the implementation: why test it with `ZZ((2^53 - 3/4) * 2^971)` rather than `ZZ((2^53 - 1/2) * 2^971) - 1`?",
    "created_at": "2014-05-27T13:53:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16385",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16385#issuecomment-210529",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:7'></a>Another minor point in case you decide to further improve the implementation: why test it with `ZZ((2^53 - 3/4) * 2^971)` rather than `ZZ((2^53 - 1/2) * 2^971) - 1`?



---

archive/issue_comments_210530.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-05-29T14:51:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16385",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16385#issuecomment-210530",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_048243.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-05-29T14:51:24Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/16385",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16385#event-48243"
}
```
