# Issue 16522: lazy_import doesn't resolve properly when indirectly imported

archive/issues_016285.json:
```json
{
    "body": "We have several places where lazy_import objects are used in a way that prevents them from behaving as designed.\n\nThe original idea of `LazyImport` proxies is that they have a pointer to the namespace in which they are bound, so that once the import gets triggered, the proxy object redirects the binding in the namespace to point straight to the proxied object. Once this redirection has happened, the proxy object should not play a role anymore and no performance impact should happen at all.\n\nThe problem occurs from statements such as:\n\n```\ncalculus/all.py:1:from calculus import maxima as maxima_calculus\n```\nThis doesn't work, because this is a `LazyImport` proxy, which needs to know the namespace in which it is bound to do the proper replacement. This one is tied to `sage.calculus.calculus.maxima`, so it can't rebind the global `maxima_calculus`. Indeed:\n\n```\nsage: type(sage.calculus.calculus.maxima)\n<type 'sage.misc.lazy_import.LazyImport'>\nsage: type(maxima_calculus)\n<type 'sage.misc.lazy_import.LazyImport'>\nsage: hash(maxima_calculus)\n-7971541566211231133\nsage: type(sage.calculus.calculus.maxima)\n<class 'sage.interfaces.maxima_lib.MaximaLib'>\nsage: type(maxima_calculus)\n<type 'sage.misc.lazy_import.LazyImport'>\n```\nThe binding of `maxima_calculus` in the global namespace (and the one in `calculus.all` too) remains to the `LazyImport` proxy. Thus we suffer from indirection overhead [one might worry we'd suffer repeated extraneous dictionary modifications, but `LazyImport` is smart enough to only attempt to rebind `sage.calculus.calculus.maxima` only on the first access] as well as problems that things like `id(LazyImportShim)` and `type(LazyImportShim)` are not what they're supposed to model.\n\nIf instead we do:\n\n```\nsage: lazy_import('sage.interfaces.maxima_lib','maxima','maxima_calculus')\n```\nwe see that things do resolve:\n\n```\nsage: type(maxima_calculus)\n<type 'sage.misc.lazy_import.LazyImport'>\nsage: hash(maxima_calculus)\n-7971541566211231133\nsage: type(maxima_calculus)\n<class 'sage.interfaces.maxima_lib.MaximaLib'>\n```\nOther bindings need their own chance to resolve, but do:\n\n```\nsage: type(sage.calculus.calculus.maxima)\n<type 'sage.misc.lazy_import.LazyImport'>\nsage: hash(sage.calculus.calculus.maxima)\n-7971541566211231133\nsage: type(sage.calculus.calculus.maxima)\n<class 'sage.interfaces.maxima_lib.MaximaLib'>\n```\nThe obvious fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus` only kicks the can further, since in `sage.all` we have `from sage.calculus.all import *` (which I think is where it really gets placed in the global sage namespace).\n\nCC:  @kcrisman @embray @tscrim\n\nReviewer: Matthias Koeppe, Nils Bruin\n\nAuthor: Nils Bruin, Matthias Koeppe\n\nBranch: u/mkoeppe/lazy_import_doesn_t_resolve_properly_when_indirectly_imported_\n\nStatus: positive_review\n\nCommit: 9837dec14225aec881004e98ed92c2a61b920906\n\nIssue created by migration from https://trac.sagemath.org/ticket/16522\n\n",
    "created_at": "2014-06-24T02:44:59Z",
    "labels": [
        "component: misc",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "lazy_import doesn't resolve properly when indirectly imported",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16522",
    "user": "https://github.com/nbruin"
}
```
We have several places where lazy_import objects are used in a way that prevents them from behaving as designed.

The original idea of `LazyImport` proxies is that they have a pointer to the namespace in which they are bound, so that once the import gets triggered, the proxy object redirects the binding in the namespace to point straight to the proxied object. Once this redirection has happened, the proxy object should not play a role anymore and no performance impact should happen at all.

The problem occurs from statements such as:

```
calculus/all.py:1:from calculus import maxima as maxima_calculus
```
This doesn't work, because this is a `LazyImport` proxy, which needs to know the namespace in which it is bound to do the proper replacement. This one is tied to `sage.calculus.calculus.maxima`, so it can't rebind the global `maxima_calculus`. Indeed:

```
sage: type(sage.calculus.calculus.maxima)
<type 'sage.misc.lazy_import.LazyImport'>
sage: type(maxima_calculus)
<type 'sage.misc.lazy_import.LazyImport'>
sage: hash(maxima_calculus)
-7971541566211231133
sage: type(sage.calculus.calculus.maxima)
<class 'sage.interfaces.maxima_lib.MaximaLib'>
sage: type(maxima_calculus)
<type 'sage.misc.lazy_import.LazyImport'>
```
The binding of `maxima_calculus` in the global namespace (and the one in `calculus.all` too) remains to the `LazyImport` proxy. Thus we suffer from indirection overhead [one might worry we'd suffer repeated extraneous dictionary modifications, but `LazyImport` is smart enough to only attempt to rebind `sage.calculus.calculus.maxima` only on the first access] as well as problems that things like `id(LazyImportShim)` and `type(LazyImportShim)` are not what they're supposed to model.

If instead we do:

```
sage: lazy_import('sage.interfaces.maxima_lib','maxima','maxima_calculus')
```
we see that things do resolve:

```
sage: type(maxima_calculus)
<type 'sage.misc.lazy_import.LazyImport'>
sage: hash(maxima_calculus)
-7971541566211231133
sage: type(maxima_calculus)
<class 'sage.interfaces.maxima_lib.MaximaLib'>
```
Other bindings need their own chance to resolve, but do:

```
sage: type(sage.calculus.calculus.maxima)
<type 'sage.misc.lazy_import.LazyImport'>
sage: hash(sage.calculus.calculus.maxima)
-7971541566211231133
sage: type(sage.calculus.calculus.maxima)
<class 'sage.interfaces.maxima_lib.MaximaLib'>
```
The obvious fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus` only kicks the can further, since in `sage.all` we have `from sage.calculus.all import *` (which I think is where it really gets placed in the global sage namespace).

CC:  @kcrisman @embray @tscrim

Reviewer: Matthias Koeppe, Nils Bruin

Author: Nils Bruin, Matthias Koeppe

Branch: u/mkoeppe/lazy_import_doesn_t_resolve_properly_when_indirectly_imported_

Status: positive_review

Commit: 9837dec14225aec881004e98ed92c2a61b920906

Issue created by migration from https://trac.sagemath.org/ticket/16522





---

archive/issue_comments_226962.json:
```json
{
    "body": "<a id='comment:2'></a>Ouch. This is difficult to fix. Sure, we can put in `sage/calculus/all.py`:\n\n```\nfrom sage.misc.lazy_import import lazy_import\n#this is sage.calculus.calculus.maxima. It needs to be lazily imported.\nlazy_import(\"sage.interfaces.maxima_lib\",\"maxima\",\"maxima_calculus\")\n```\nbut that only solves one step of the problem. Next we get in `sage/all.py`:\n\n```\nfrom sage.calculus.all   import *\n```\nso if we want to solve this problem, we'd have to do so manually unless we come up with very smart hack in `lazy_import`. There are other lazy_imports of this type:\n\n```\nsage: type(Riemann_Map)\n<type 'sage.misc.lazy_import.LazyImport'>\nsage: %time hash(Riemann_Map)\nCPU times: user 42 ms, sys: 5 ms, total: 47 ms\nWall time: 45.2 ms\n8795750155546\nsage: %time hash(Riemann_Map)\nCPU times: user 0 ns, sys: 0 ns, total: 0 ns\nWall time: 7.87 \u00b5s\n8795750155546\nsage: type(Riemann_Map)\n<type 'sage.misc.lazy_import.LazyImport'>\n```\nExactly the same story. Luckily, the lazy_import proxy objects are pretty transparent when the import has already happened, so it's not too much of an issue when they're in the way (unless you're in a very tight loop). I'll be upgrading the severity and scope of this ticket.",
    "created_at": "2014-06-24T03:58:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226962",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:2'></a>Ouch. This is difficult to fix. Sure, we can put in `sage/calculus/all.py`:

```
from sage.misc.lazy_import import lazy_import
#this is sage.calculus.calculus.maxima. It needs to be lazily imported.
lazy_import("sage.interfaces.maxima_lib","maxima","maxima_calculus")
```
but that only solves one step of the problem. Next we get in `sage/all.py`:

```
from sage.calculus.all   import *
```
so if we want to solve this problem, we'd have to do so manually unless we come up with very smart hack in `lazy_import`. There are other lazy_imports of this type:

```
sage: type(Riemann_Map)
<type 'sage.misc.lazy_import.LazyImport'>
sage: %time hash(Riemann_Map)
CPU times: user 42 ms, sys: 5 ms, total: 47 ms
Wall time: 45.2 ms
8795750155546
sage: %time hash(Riemann_Map)
CPU times: user 0 ns, sys: 0 ns, total: 0 ns
Wall time: 7.87 Âµs
8795750155546
sage: type(Riemann_Map)
<type 'sage.misc.lazy_import.LazyImport'>
```
Exactly the same story. Luckily, the lazy_import proxy objects are pretty transparent when the import has already happened, so it's not too much of an issue when they're in the way (unless you're in a very tight loop). I'll be upgrading the severity and scope of this ticket.



---

archive/issue_comments_226963.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -42,7 +42,7 @@\n sage: type(sage.calculus.calculus.maxima)\n <class 'sage.interfaces.maxima_lib.MaximaLib'>\n ```\n-So, the proposed fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus`. LazyImports can't handle indirect imports.\n+The obvious fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus` only kicks the can further, since in `sage.all` we have `from sage.calculus.all import *` (which I think is where it really gets placed in the global sage namespace).\n \n Comment: 1\n \n``````\n",
    "created_at": "2014-06-24T03:58:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226963",
    "user": "https://github.com/nbruin"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -42,7 +42,7 @@
 sage: type(sage.calculus.calculus.maxima)
 <class 'sage.interfaces.maxima_lib.MaximaLib'>
 ```
-So, the proposed fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus`. LazyImports can't handle indirect imports.
+The obvious fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus` only kicks the can further, since in `sage.all` we have `from sage.calculus.all import *` (which I think is where it really gets placed in the global sage namespace).
 
 Comment: 1
 
``````




---

archive/issue_comments_226964.json:
```json
{
    "body": "Changing component from calculus to misc.",
    "created_at": "2014-06-24T03:58:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226964",
    "user": "https://github.com/nbruin"
}
```

Changing component from calculus to misc.



---

archive/issue_events_048524.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16522#event-48524"
}
```



---

archive/issue_comments_226965.json:
```json
{
    "body": "<a id='comment:5'></a>Following up on the code in comment\n[#19628:12](https://trac.sagemath.org/ticket/19628#comment:12)\nand the discussion below it, we can consider cleaning the some of the namespaces of some of the improperly placed lazy_imports. It looks like cleaning them after the fact isn't very expensive, so perhaps that's easier than to avoid improper lazy_imports in the first place.",
    "created_at": "2019-06-06T15:54:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226965",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:5'></a>Following up on the code in comment
[#19628:12](https://trac.sagemath.org/ticket/19628#comment:12)
and the discussion below it, we can consider cleaning the some of the namespaces of some of the improperly placed lazy_imports. It looks like cleaning them after the fact isn't very expensive, so perhaps that's easier than to avoid improper lazy_imports in the first place.



---

archive/issue_comments_226966.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2019-06-06T16:23:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226966",
    "user": "https://github.com/nbruin"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_226967.json:
```json
{
    "body": "<a id='comment:7'></a>Seeing how many improperly placed LazyImport (i.e., LazyImport objects that do have a namespace set, but it doesn't match the namespace in which they are bound, or the name they are bound to doesn't match the `_as_name` attribute):\n\n```\nfrom sage.misc.lazy_import import LazyImport, attributes, clean_namespace\ndef misbound_lazies(S):\n    return [k for k,v in S.items() if\n        type(v) is LazyImport and\n        attributes(v)['_namespace'] is not None and\n            (attributes(v)['_namespace'] is not S or\n             attributes(v)['_as_name'] != k)]\nM=[(k,len(misbound_lazies(m.__dict__))) for k,m in sys.modules.iteritems() if m is not None]\n```\ngives currently:\n\n```\nsage: [m for m in M if m[1] > 0]\n[('sage.groups.all', 9),\n ('sage.combinat.non_decreasing_parking_function', 1),\n ('sage.groups.libgap_mixin', 1),\n ('__main__', 330),\n ('sage.categories.all', 1),\n ('sage.combinat.all', 23),\n ('sage.calculus.all', 1),\n ('sage.tensor.all', 1),\n ('sage.combinat.integer_vector', 1),\n ('sage.geometry.all', 3),\n ('sage.graphs.digraph', 1),\n ('sage.all_cmdline', 330),\n ('sage.combinat.partition_tuple', 1),\n ('sage.algebras.lie_algebras.affine_lie_algebra', 1),\n ('sage.modular.arithgroup.congroup_generic', 1),\n ('sage.schemes.all', 4),\n ('sage.rings.all', 13),\n ('sage.combinat.set_partition_ordered', 1),\n ('sage.categories.groups', 1),\n ('sage.graphs.generic_graph', 1),\n ('sage.algebras.all', 2),\n ('sage.modular.all', 4),\n ('sage.combinat.integer_vectors_mod_permgroup', 1),\n ('sage.dynamics.all', 7),\n ('sage.combinat.composition', 1),\n ('sage.combinat.partition', 1),\n ('sage.all', 314)]\n```\nExecuting:\n\n```\nfor m in sys.modules.values():\n    if m is not None:\n        clean_namespace(m)\n```\nnaturally resolves all these. Two options to use this in practice:\n* put a `clean_namespace(globals())` at the end of offending modules.\n* execute this on `sys.modules.values()` at the end of initialization in sage\n\nComments welcome.",
    "created_at": "2019-06-06T16:23:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226967",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:7'></a>Seeing how many improperly placed LazyImport (i.e., LazyImport objects that do have a namespace set, but it doesn't match the namespace in which they are bound, or the name they are bound to doesn't match the `_as_name` attribute):

```
from sage.misc.lazy_import import LazyImport, attributes, clean_namespace
def misbound_lazies(S):
    return [k for k,v in S.items() if
        type(v) is LazyImport and
        attributes(v)['_namespace'] is not None and
            (attributes(v)['_namespace'] is not S or
             attributes(v)['_as_name'] != k)]
M=[(k,len(misbound_lazies(m.__dict__))) for k,m in sys.modules.iteritems() if m is not None]
```
gives currently:

```
sage: [m for m in M if m[1] > 0]
[('sage.groups.all', 9),
 ('sage.combinat.non_decreasing_parking_function', 1),
 ('sage.groups.libgap_mixin', 1),
 ('__main__', 330),
 ('sage.categories.all', 1),
 ('sage.combinat.all', 23),
 ('sage.calculus.all', 1),
 ('sage.tensor.all', 1),
 ('sage.combinat.integer_vector', 1),
 ('sage.geometry.all', 3),
 ('sage.graphs.digraph', 1),
 ('sage.all_cmdline', 330),
 ('sage.combinat.partition_tuple', 1),
 ('sage.algebras.lie_algebras.affine_lie_algebra', 1),
 ('sage.modular.arithgroup.congroup_generic', 1),
 ('sage.schemes.all', 4),
 ('sage.rings.all', 13),
 ('sage.combinat.set_partition_ordered', 1),
 ('sage.categories.groups', 1),
 ('sage.graphs.generic_graph', 1),
 ('sage.algebras.all', 2),
 ('sage.modular.all', 4),
 ('sage.combinat.integer_vectors_mod_permgroup', 1),
 ('sage.dynamics.all', 7),
 ('sage.combinat.composition', 1),
 ('sage.combinat.partition', 1),
 ('sage.all', 314)]
```
Executing:

```
for m in sys.modules.values():
    if m is not None:
        clean_namespace(m)
```
naturally resolves all these. Two options to use this in practice:
* put a `clean_namespace(globals())` at the end of offending modules.
* execute this on `sys.modules.values()` at the end of initialization in sage

Comments welcome.



---

archive/issue_events_048525.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2019-06-06T16:23:21Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16522#event-48525"
}
```



---

archive/issue_events_048526.json:
```json
{
    "actor": "https://github.com/nbruin",
    "created_at": "2019-06-06T16:23:21Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "milestone": "sage-feature",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16522#event-48526"
}
```



---

archive/issue_comments_226968.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-06-11T17:27:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226968",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_226969.json:
```json
{
    "body": "<a id='comment:10'></a>What is the actual problem? The first lines of the ticket description are very cryptic.",
    "created_at": "2021-04-20T18:38:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226969",
    "user": "https://github.com/videlec"
}
```

<a id='comment:10'></a>What is the actual problem? The first lines of the ticket description are very cryptic.



---

archive/issue_comments_226970.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,54 @@\n+We have several places where lazy_import objects are used in a way that prevents them from behaving as designed.\n \n+The original idea of `LazyImport` proxies is that they have a pointer to the namespace in which they are bound, so that once the import gets triggered, the proxy object redirects the binding in the namespace to point straight to the proxied object. Once this redirection has happened, the proxy object should not play a role anymore and no performance impact should happen at all.\n+\n+The problem occurs from statements such as:\n+\n+```\n+calculus/all.py:1:from calculus import maxima as maxima_calculus\n+```\n+This doesn't work, because this is a `LazyImport` proxy, which needs to know the namespace in which it is bound to do the proper replacement. This one is tied to `sage.calculus.calculus.maxima`, so it can't rebind the global `maxima_calculus`. Indeed:\n+\n+```\n+sage: type(sage.calculus.calculus.maxima)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+sage: type(maxima_calculus)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+sage: hash(maxima_calculus)\n+-7971541566211231133\n+sage: type(sage.calculus.calculus.maxima)\n+<class 'sage.interfaces.maxima_lib.MaximaLib'>\n+sage: type(maxima_calculus)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+```\n+The binding of `maxima_calculus` in the global namespace (and the one in `calculus.all` too) remains to the `LazyImport` proxy and upon each access this object will rebind `sage.calculus.calculus.maxima`. Thus, not only do we suffer from indirection overhead, we're even suffering extraneous dictionary modifications.\n+\n+If instead we do:\n+\n+```\n+sage: lazy_import('sage.interfaces.maxima_lib','maxima','maxima_calculus')\n+```\n+we see that things do resolve:\n+\n+```\n+sage: type(maxima_calculus)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+sage: hash(maxima_calculus)\n+-7971541566211231133\n+sage: type(maxima_calculus)\n+<class 'sage.interfaces.maxima_lib.MaximaLib'>\n+```\n+Other bindings need their own chance to resolve, but do:\n+\n+```\n+sage: type(sage.calculus.calculus.maxima)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+sage: hash(sage.calculus.calculus.maxima)\n+-7971541566211231133\n+sage: type(sage.calculus.calculus.maxima)\n+<class 'sage.interfaces.maxima_lib.MaximaLib'>\n+```\n+The obvious fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus` only kicks the can further, since in `sage.all` we have `from sage.calculus.all import *` (which I think is where it really gets placed in the global sage namespace).\n \n Comment: 1\n \n``````\n",
    "created_at": "2021-04-21T03:17:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226970",
    "user": "https://github.com/nbruin"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,54 @@
+We have several places where lazy_import objects are used in a way that prevents them from behaving as designed.
 
+The original idea of `LazyImport` proxies is that they have a pointer to the namespace in which they are bound, so that once the import gets triggered, the proxy object redirects the binding in the namespace to point straight to the proxied object. Once this redirection has happened, the proxy object should not play a role anymore and no performance impact should happen at all.
+
+The problem occurs from statements such as:
+
+```
+calculus/all.py:1:from calculus import maxima as maxima_calculus
+```
+This doesn't work, because this is a `LazyImport` proxy, which needs to know the namespace in which it is bound to do the proper replacement. This one is tied to `sage.calculus.calculus.maxima`, so it can't rebind the global `maxima_calculus`. Indeed:
+
+```
+sage: type(sage.calculus.calculus.maxima)
+<type 'sage.misc.lazy_import.LazyImport'>
+sage: type(maxima_calculus)
+<type 'sage.misc.lazy_import.LazyImport'>
+sage: hash(maxima_calculus)
+-7971541566211231133
+sage: type(sage.calculus.calculus.maxima)
+<class 'sage.interfaces.maxima_lib.MaximaLib'>
+sage: type(maxima_calculus)
+<type 'sage.misc.lazy_import.LazyImport'>
+```
+The binding of `maxima_calculus` in the global namespace (and the one in `calculus.all` too) remains to the `LazyImport` proxy and upon each access this object will rebind `sage.calculus.calculus.maxima`. Thus, not only do we suffer from indirection overhead, we're even suffering extraneous dictionary modifications.
+
+If instead we do:
+
+```
+sage: lazy_import('sage.interfaces.maxima_lib','maxima','maxima_calculus')
+```
+we see that things do resolve:
+
+```
+sage: type(maxima_calculus)
+<type 'sage.misc.lazy_import.LazyImport'>
+sage: hash(maxima_calculus)
+-7971541566211231133
+sage: type(maxima_calculus)
+<class 'sage.interfaces.maxima_lib.MaximaLib'>
+```
+Other bindings need their own chance to resolve, but do:
+
+```
+sage: type(sage.calculus.calculus.maxima)
+<type 'sage.misc.lazy_import.LazyImport'>
+sage: hash(sage.calculus.calculus.maxima)
+-7971541566211231133
+sage: type(sage.calculus.calculus.maxima)
+<class 'sage.interfaces.maxima_lib.MaximaLib'>
+```
+The obvious fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus` only kicks the can further, since in `sage.all` we have `from sage.calculus.all import *` (which I think is where it really gets placed in the global sage namespace).
 
 Comment: 1
 
``````




---

archive/issue_comments_226971.json:
```json
{
    "body": "<a id='comment:12'></a>Replying to [comment:10 vdelecroix]:\n> What is the actual problem? The first lines of the ticket description are very cryptic.\n\nI tried to decrypt it.",
    "created_at": "2021-04-21T03:17:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226971",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:12'></a>Replying to [comment:10 vdelecroix]:
> What is the actual problem? The first lines of the ticket description are very cryptic.

I tried to decrypt it.



---

archive/issue_events_048527.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-18T18:13:43Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "milestone": "sage-feature",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16522#event-48527"
}
```



---

archive/issue_events_048528.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-18T18:13:43Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16522#event-48528"
}
```



---

archive/issue_comments_226972.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2022-09-18T19:14:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226972",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_226973.json:
```json
{
    "body": "<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-18T19:42:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226973",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_226974.json:
```json
{
    "body": "<a id='comment:16'></a>rebased branch; now we just introduce the requisite helper routines in lazy_import and implement cleaning of `sage.all` and `user_globals` upon initialization. I think these are the two places where it's really hard to mandate that lazy_imports are done explicitly.\n\nSimilar cleaning operations could be placed in the construction of other namespaces too, but with a bit diminishing returns.",
    "created_at": "2022-09-18T19:46:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226974",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:16'></a>rebased branch; now we just introduce the requisite helper routines in lazy_import and implement cleaning of `sage.all` and `user_globals` upon initialization. I think these are the two places where it's really hard to mandate that lazy_imports are done explicitly.

Similar cleaning operations could be placed in the construction of other namespaces too, but with a bit diminishing returns.



---

archive/issue_comments_226975.json:
```json
{
    "body": "<a id='comment:17'></a>On 9.7.rc2 I get with:\n\n```\nfrom sage.misc.lazy_import import LazyImport,attributes #that's the helper\n function\ndef misbound_lazies(S):\n    return [k for k,v in S.items() if type(v) is LazyImport\n        and attributes(v)['_namespace'] is not S\n        and attributes(v)['_namespace'] is not None]\n\nM=[(k,len(misbound_lazies(m.__dict__))) for k,m in sys.modules.items() if m is not None]\n```\nthe following result:\n\n```\nsage: [m for m in M if m[1] > 0]\n[('sage.categories.groups', 1),\n ('sage.misc.all', 1),\n ('sage.combinat.integer_vector', 1),\n ('sage.rings.all', 15),\n ('sage.categories.all__sagemath_objects', 1),\n ('sage.categories.all', 1),\n ('sage.algebras.all', 7),\n ('sage.combinat.composition', 1),\n ('sage.graphs.path_enumeration', 1),\n ('sage.modular.arithgroup.congroup_generic', 1),\n ('sage.modular.all', 4),\n ('sage.schemes.all', 16),\n ('sage.groups.all', 9),\n ('sage.calculus.all', 1),\n ('sage.combinat.partition_tuple', 1),\n ('sage.combinat.partition', 1),\n ('sage.combinat.non_decreasing_parking_function', 1),\n ('sage.combinat.set_partition_ordered', 1),\n ('sage.combinat.integer_vectors_mod_permgroup', 1),\n ('sage.combinat.all', 33),\n ('sage.geometry.all', 4),\n ('sage.dynamics.all', 8),\n ('sage.tensor.all', 1),\n ('sage.all_cmdline', 426)]\n```\nThat's not that bad! perhaps a lot of these can be resolved. On `sage.all_cmdline` we have the result of a `from sage.all import *`, but I think that dict only gets used for a `initialize_globals`, which may be a better place to fix this. We could clean `sage.all_cmdline` too, but if that namespace is never accessed, then the state of the shims isn't even relevant.\n\nThe other objects are perhaps worth investigating further. (Note that, for instance, `structure/sage_object.pyx` has some objects that have a `None` namespace. In that case, the shim wouldn't try to remove itself, so we shouldn't rewrite it either. `clean_namespace` already handles that properly)",
    "created_at": "2022-09-18T20:18:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226975",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:17'></a>On 9.7.rc2 I get with:

```
from sage.misc.lazy_import import LazyImport,attributes #that's the helper
 function
def misbound_lazies(S):
    return [k for k,v in S.items() if type(v) is LazyImport
        and attributes(v)['_namespace'] is not S
        and attributes(v)['_namespace'] is not None]

M=[(k,len(misbound_lazies(m.__dict__))) for k,m in sys.modules.items() if m is not None]
```
the following result:

```
sage: [m for m in M if m[1] > 0]
[('sage.categories.groups', 1),
 ('sage.misc.all', 1),
 ('sage.combinat.integer_vector', 1),
 ('sage.rings.all', 15),
 ('sage.categories.all__sagemath_objects', 1),
 ('sage.categories.all', 1),
 ('sage.algebras.all', 7),
 ('sage.combinat.composition', 1),
 ('sage.graphs.path_enumeration', 1),
 ('sage.modular.arithgroup.congroup_generic', 1),
 ('sage.modular.all', 4),
 ('sage.schemes.all', 16),
 ('sage.groups.all', 9),
 ('sage.calculus.all', 1),
 ('sage.combinat.partition_tuple', 1),
 ('sage.combinat.partition', 1),
 ('sage.combinat.non_decreasing_parking_function', 1),
 ('sage.combinat.set_partition_ordered', 1),
 ('sage.combinat.integer_vectors_mod_permgroup', 1),
 ('sage.combinat.all', 33),
 ('sage.geometry.all', 4),
 ('sage.dynamics.all', 8),
 ('sage.tensor.all', 1),
 ('sage.all_cmdline', 426)]
```
That's not that bad! perhaps a lot of these can be resolved. On `sage.all_cmdline` we have the result of a `from sage.all import *`, but I think that dict only gets used for a `initialize_globals`, which may be a better place to fix this. We could clean `sage.all_cmdline` too, but if that namespace is never accessed, then the state of the shims isn't even relevant.

The other objects are perhaps worth investigating further. (Note that, for instance, `structure/sage_object.pyx` has some objects that have a `None` namespace. In that case, the shim wouldn't try to remove itself, so we shouldn't rewrite it either. `clean_namespace` already handles that properly)



---

archive/issue_comments_226976.json:
```json
{
    "body": "<a id='comment:18'></a>The Build & Test run shows some failures related to `NN` (which IIRC has a strange lazy-import status) https://github.com/sagemath/sagetrac-mirror/actions/runs/3078385872/jobs/4973904579\n\nOther than that, it looks good to me",
    "created_at": "2022-09-18T23:47:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226976",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:18'></a>The Build & Test run shows some failures related to `NN` (which IIRC has a strange lazy-import status) https://github.com/sagemath/sagetrac-mirror/actions/runs/3078385872/jobs/4973904579

Other than that, it looks good to me



---

archive/issue_comments_226977.json:
```json
{
    "body": "<a id='comment:19'></a>I think we can add this call to `clean_namespace` to all the `.all*` modules. Not sure about the other modules that your script found",
    "created_at": "2022-09-19T00:20:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226977",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:19'></a>I think we can add this call to `clean_namespace` to all the `.all*` modules. Not sure about the other modules that your script found



---

archive/issue_comments_226978.json:
```json
{
    "body": "<a id='comment:20'></a>Replying to [comment:18 Matthias K\u00f6ppe]:\n> The Build & Test run shows some failures related to `NN` (which IIRC has a strange lazy-import status) https://github.com/sagemath/sagetrac-mirror/actions/runs/3078385872/jobs/4973904579\n> \n> Other than that, it looks good to me\n\nOh cool! That's a textbook example of why `LazyImport` of anything else than a function is bound to cause trouble. See this line:\n\n```\nfrom sage.rings.semirings.all import NN\n```\nand then later the test:\n\n```\n        if n is None or n is NN or n is NonNegativeIntegers():\n```\nso `NN` is a very specific `LazyImport` shim (that will not be resolved, not even if it gets used properly, because only its identity is used: attribute lookups never happen on it) and this code only ever worked because the global namespace had *that exact shim*. It never actually tested for the actual `NN` object.\n\nSo this is actually a separate bug of something that has never worked.\n\n(I think `NN` was originally lazy_imported because it plays a lot of category shenanigans, which is very expensive for startup. Hence, it was felt its initialization should be delayed. But that means you end up with an object that has a meaningful identity, but that identity can change. In fact, if people feel it should have a `LazyImport` shim around it that delays its initialization, it should probably be one with `namespace==None`. Then at least its `id` will be consistent (but its type info will be wrong, and one would have to mandate that people only use the shim if they want to test for identity ...)\n\nThat's why we need `NaturalNumbers()` instead of `NN` [```EDIT:``` scratch that! 0 is in NN in sage, apparently. Must be the french influence. The thing is actually called `NonNegativeIntegerSemiring()`. I guess \"NN\" for \"NonNegative\" is not a bad abbreviation :-)] if delayed init is important ... or custom-write the delayed init for NN so that identity and type info is correct(ish) from the start.\n\nThe current use in `partitions` is absolutely garbage.",
    "created_at": "2022-09-19T04:34:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226978",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:20'></a>Replying to [comment:18 Matthias KÃ¶ppe]:
> The Build & Test run shows some failures related to `NN` (which IIRC has a strange lazy-import status) https://github.com/sagemath/sagetrac-mirror/actions/runs/3078385872/jobs/4973904579
> 
> Other than that, it looks good to me

Oh cool! That's a textbook example of why `LazyImport` of anything else than a function is bound to cause trouble. See this line:

```
from sage.rings.semirings.all import NN
```
and then later the test:

```
        if n is None or n is NN or n is NonNegativeIntegers():
```
so `NN` is a very specific `LazyImport` shim (that will not be resolved, not even if it gets used properly, because only its identity is used: attribute lookups never happen on it) and this code only ever worked because the global namespace had *that exact shim*. It never actually tested for the actual `NN` object.

So this is actually a separate bug of something that has never worked.

(I think `NN` was originally lazy_imported because it plays a lot of category shenanigans, which is very expensive for startup. Hence, it was felt its initialization should be delayed. But that means you end up with an object that has a meaningful identity, but that identity can change. In fact, if people feel it should have a `LazyImport` shim around it that delays its initialization, it should probably be one with `namespace==None`. Then at least its `id` will be consistent (but its type info will be wrong, and one would have to mandate that people only use the shim if they want to test for identity ...)

That's why we need `NaturalNumbers()` instead of `NN` [```EDIT:``` scratch that! 0 is in NN in sage, apparently. Must be the french influence. The thing is actually called `NonNegativeIntegerSemiring()`. I guess "NN" for "NonNegative" is not a bad abbreviation :-)] if delayed init is important ... or custom-write the delayed init for NN so that identity and type info is correct(ish) from the start.

The current use in `partitions` is absolutely garbage.



---

archive/issue_comments_226979.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-19T05:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226979",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_226980.json:
```json
{
    "body": "<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-19T05:11:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226980",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:22'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_226981.json:
```json
{
    "body": "<a id='comment:23'></a>I think I don't understand the subtleties here. In `partition.py`, why not just `from sage.rings.semirings.non_negative_integer_semiring import NN`?",
    "created_at": "2022-09-19T05:29:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226981",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:23'></a>I think I don't understand the subtleties here. In `partition.py`, why not just `from sage.rings.semirings.non_negative_integer_semiring import NN`?



---

archive/issue_comments_226982.json:
```json
{
    "body": "<a id='comment:24'></a>Replying to [comment:23 John Palmieri]:\n> I think I don't understand the subtleties here. In `partition.py`, why not just `from sage.rings.semirings.non_negative_integer_semiring import NN`?\n\n\nThat would be fine semantically, but it incurs the cost of importing `NN` at startup. As I recall, the reason why this is undesirable is because the facade shenanigans played is super-heavy on the category framework and costs a lot of initialization time. In order to avoid that import at startup, we can instead lazy import a constructor function. Calling the function will trigger the import, so `n is NonNegativeIntegerSemiring()` triggers the import, whereas `n is NN` with a lazily imported NN does not.\n\nAlternatively, we could do a runtime import when `NN` is needed, but imports do have (had?) a measurable cost. I don't know if `Partition` needs to be efficient on construction.\n\nI tried to localize the change as much as possible, fixing the original erroneous behaviour.",
    "created_at": "2022-09-19T06:00:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226982",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:24'></a>Replying to [comment:23 John Palmieri]:
> I think I don't understand the subtleties here. In `partition.py`, why not just `from sage.rings.semirings.non_negative_integer_semiring import NN`?


That would be fine semantically, but it incurs the cost of importing `NN` at startup. As I recall, the reason why this is undesirable is because the facade shenanigans played is super-heavy on the category framework and costs a lot of initialization time. In order to avoid that import at startup, we can instead lazy import a constructor function. Calling the function will trigger the import, so `n is NonNegativeIntegerSemiring()` triggers the import, whereas `n is NN` with a lazily imported NN does not.

Alternatively, we could do a runtime import when `NN` is needed, but imports do have (had?) a measurable cost. I don't know if `Partition` needs to be efficient on construction.

I tried to localize the change as much as possible, fixing the original erroneous behaviour.



---

archive/issue_comments_226983.json:
```json
{
    "body": "<a id='comment:25'></a>That makes sense, but maybe partitions should be lazily imported instead?",
    "created_at": "2022-09-19T16:00:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226983",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:25'></a>That makes sense, but maybe partitions should be lazily imported instead?



---

archive/issue_comments_226984.json:
```json
{
    "body": "<a id='comment:26'></a>Replying to [comment:25 John Palmieri]:\n> That makes sense, but maybe partitions should be lazily imported instead?\n\n\nI'd say that's not the worst issue here. The problem is people apparently want NN in the top-level namespace without paying the price at startup time. But that means that NN starts out as a `LazyImport` shim. But the shim cannot be fully transparent: `type(NN)` and `id(NN)` will be wrong.\nSo routines that may get NN passed will have to be prepared to unpack the shim. That's a much more invasive change than the use of `NonNegativeIntegerSemiring()` to get a hold of a reference object in `partitions.py` itself, and it does not get alleviated by lazily importing `Partitions`.\n\nOther solutions I see:\n- incur the startup penalty and just have NN as a fully formed object\n- customize NN to a class that has the right identity and type, but defers the expensive parts of its initialization until needed. At least for a while, things like matrices deferred the construction of their parents for efficiency reasons (the parents may never be needed and are expensive to construct!) so there's a precedent for optimizing this way\n- do away with NN and have people call `NonNegativeIntegerSemiring()` or some nicer-sounding alias if they need it. (apparently ZZ is way cheaper to construct)\n\nTo get an idea of the cost of initializing `NN`:\n\n```\nsage: %time NN(1)\nCPU times: user 5.99 ms, sys: 11 \u00b5s, total: 6 ms\nWall time: 5.42 ms\n1\nsage: %time NN(1)\nCPU times: user 22 \u00b5s, sys: 2 \u00b5s, total: 24 \u00b5s\nWall time: 27.7 \u00b5s\n1\n```\nCan we spend something on the order `6ms` (probably more on older machines) to remove a major headache? Just NOT making NN lazy would be by far the lowest effort solution. Then the singleton can just be available everywhere. One of the drawbacks: NN is hardly ever used, so we're losing `6ms` to a rare scenario.\n\n**EDIT**: it's not `6ms` just for importing `NN`. This must be measuring a lot of initialization of the coercion framework as well. `%time c=NN._get_object()` triggers just the import and seems to take a little less than `2ms` on this machine. See comment:30 below for more info\n\nNormally that would definitely get the answer \"No you can't have your constant premade. Construct it with a constructor when you need it.\" But given how fundamental NN is to the foundations of mathematics, I could see how people would be partial to having it available, in apparent analogy to ZZ, QQ that really do get used everywhere.",
    "created_at": "2022-09-19T16:50:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226984",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:26'></a>Replying to [comment:25 John Palmieri]:
> That makes sense, but maybe partitions should be lazily imported instead?


I'd say that's not the worst issue here. The problem is people apparently want NN in the top-level namespace without paying the price at startup time. But that means that NN starts out as a `LazyImport` shim. But the shim cannot be fully transparent: `type(NN)` and `id(NN)` will be wrong.
So routines that may get NN passed will have to be prepared to unpack the shim. That's a much more invasive change than the use of `NonNegativeIntegerSemiring()` to get a hold of a reference object in `partitions.py` itself, and it does not get alleviated by lazily importing `Partitions`.

Other solutions I see:
- incur the startup penalty and just have NN as a fully formed object
- customize NN to a class that has the right identity and type, but defers the expensive parts of its initialization until needed. At least for a while, things like matrices deferred the construction of their parents for efficiency reasons (the parents may never be needed and are expensive to construct!) so there's a precedent for optimizing this way
- do away with NN and have people call `NonNegativeIntegerSemiring()` or some nicer-sounding alias if they need it. (apparently ZZ is way cheaper to construct)

To get an idea of the cost of initializing `NN`:

```
sage: %time NN(1)
CPU times: user 5.99 ms, sys: 11 Âµs, total: 6 ms
Wall time: 5.42 ms
1
sage: %time NN(1)
CPU times: user 22 Âµs, sys: 2 Âµs, total: 24 Âµs
Wall time: 27.7 Âµs
1
```
Can we spend something on the order `6ms` (probably more on older machines) to remove a major headache? Just NOT making NN lazy would be by far the lowest effort solution. Then the singleton can just be available everywhere. One of the drawbacks: NN is hardly ever used, so we're losing `6ms` to a rare scenario.

**EDIT**: it's not `6ms` just for importing `NN`. This must be measuring a lot of initialization of the coercion framework as well. `%time c=NN._get_object()` triggers just the import and seems to take a little less than `2ms` on this machine. See comment:30 below for more info

Normally that would definitely get the answer "No you can't have your constant premade. Construct it with a constructor when you need it." But given how fundamental NN is to the foundations of mathematics, I could see how people would be partial to having it available, in apparent analogy to ZZ, QQ that really do get used everywhere.



---

archive/issue_comments_226985.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,54 @@\n+We have several places where lazy_import objects are used in a way that prevents them from behaving as designed.\n \n+The original idea of `LazyImport` proxies is that they have a pointer to the namespace in which they are bound, so that once the import gets triggered, the proxy object redirects the binding in the namespace to point straight to the proxied object. Once this redirection has happened, the proxy object should not play a role anymore and no performance impact should happen at all.\n+\n+The problem occurs from statements such as:\n+\n+```\n+calculus/all.py:1:from calculus import maxima as maxima_calculus\n+```\n+This doesn't work, because this is a `LazyImport` proxy, which needs to know the namespace in which it is bound to do the proper replacement. This one is tied to `sage.calculus.calculus.maxima`, so it can't rebind the global `maxima_calculus`. Indeed:\n+\n+```\n+sage: type(sage.calculus.calculus.maxima)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+sage: type(maxima_calculus)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+sage: hash(maxima_calculus)\n+-7971541566211231133\n+sage: type(sage.calculus.calculus.maxima)\n+<class 'sage.interfaces.maxima_lib.MaximaLib'>\n+sage: type(maxima_calculus)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+```\n+The binding of `maxima_calculus` in the global namespace (and the one in `calculus.all` too) remains to the `LazyImport` proxy. Thus we suffer from indirection overhead [one might worry we'd suffer repeated extraneous dictionary modifications, but `LazyImport` is smart enough to only attempt to rebind `sage.calculus.calculus.maxima` only on the first access] as well as problems that things like `id(LazyImportShim)` and `type(LazyImportShim)` are not what they're supposed to model.\n+\n+If instead we do:\n+\n+```\n+sage: lazy_import('sage.interfaces.maxima_lib','maxima','maxima_calculus')\n+```\n+we see that things do resolve:\n+\n+```\n+sage: type(maxima_calculus)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+sage: hash(maxima_calculus)\n+-7971541566211231133\n+sage: type(maxima_calculus)\n+<class 'sage.interfaces.maxima_lib.MaximaLib'>\n+```\n+Other bindings need their own chance to resolve, but do:\n+\n+```\n+sage: type(sage.calculus.calculus.maxima)\n+<type 'sage.misc.lazy_import.LazyImport'>\n+sage: hash(sage.calculus.calculus.maxima)\n+-7971541566211231133\n+sage: type(sage.calculus.calculus.maxima)\n+<class 'sage.interfaces.maxima_lib.MaximaLib'>\n+```\n+The obvious fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus` only kicks the can further, since in `sage.all` we have `from sage.calculus.all import *` (which I think is where it really gets placed in the global sage namespace).\n \n Comment: 1\n \n``````\n",
    "created_at": "2022-09-19T16:59:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226985",
    "user": "https://github.com/nbruin"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,54 @@
+We have several places where lazy_import objects are used in a way that prevents them from behaving as designed.
 
+The original idea of `LazyImport` proxies is that they have a pointer to the namespace in which they are bound, so that once the import gets triggered, the proxy object redirects the binding in the namespace to point straight to the proxied object. Once this redirection has happened, the proxy object should not play a role anymore and no performance impact should happen at all.
+
+The problem occurs from statements such as:
+
+```
+calculus/all.py:1:from calculus import maxima as maxima_calculus
+```
+This doesn't work, because this is a `LazyImport` proxy, which needs to know the namespace in which it is bound to do the proper replacement. This one is tied to `sage.calculus.calculus.maxima`, so it can't rebind the global `maxima_calculus`. Indeed:
+
+```
+sage: type(sage.calculus.calculus.maxima)
+<type 'sage.misc.lazy_import.LazyImport'>
+sage: type(maxima_calculus)
+<type 'sage.misc.lazy_import.LazyImport'>
+sage: hash(maxima_calculus)
+-7971541566211231133
+sage: type(sage.calculus.calculus.maxima)
+<class 'sage.interfaces.maxima_lib.MaximaLib'>
+sage: type(maxima_calculus)
+<type 'sage.misc.lazy_import.LazyImport'>
+```
+The binding of `maxima_calculus` in the global namespace (and the one in `calculus.all` too) remains to the `LazyImport` proxy. Thus we suffer from indirection overhead [one might worry we'd suffer repeated extraneous dictionary modifications, but `LazyImport` is smart enough to only attempt to rebind `sage.calculus.calculus.maxima` only on the first access] as well as problems that things like `id(LazyImportShim)` and `type(LazyImportShim)` are not what they're supposed to model.
+
+If instead we do:
+
+```
+sage: lazy_import('sage.interfaces.maxima_lib','maxima','maxima_calculus')
+```
+we see that things do resolve:
+
+```
+sage: type(maxima_calculus)
+<type 'sage.misc.lazy_import.LazyImport'>
+sage: hash(maxima_calculus)
+-7971541566211231133
+sage: type(maxima_calculus)
+<class 'sage.interfaces.maxima_lib.MaximaLib'>
+```
+Other bindings need their own chance to resolve, but do:
+
+```
+sage: type(sage.calculus.calculus.maxima)
+<type 'sage.misc.lazy_import.LazyImport'>
+sage: hash(sage.calculus.calculus.maxima)
+-7971541566211231133
+sage: type(sage.calculus.calculus.maxima)
+<class 'sage.interfaces.maxima_lib.MaximaLib'>
+```
+The obvious fix: in `calculus.all`, import `maximalib` directly and lazily, rather than indirectly from `sage.calculus.calculus` only kicks the can further, since in `sage.all` we have `from sage.calculus.all import *` (which I think is where it really gets placed in the global sage namespace).
 
 Comment: 1
 
``````




---

archive/issue_comments_226986.json:
```json
{
    "body": "<a id='comment:28'></a>It makes sense to me to just honestly import `NN` at the start, especially as you say, since it is so foundational to mathematics. Then it also makes sense to lazily import lots of other things, like the interfaces to various optional packages or other rarely used items \u2014\u00a0the more specialized or rarely used, the more we should try to avoid initializing them at startup. I would hope that the savings from lazily importing other things would outweigh the added costs of initializing `NN`.",
    "created_at": "2022-09-19T17:39:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226986",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:28'></a>It makes sense to me to just honestly import `NN` at the start, especially as you say, since it is so foundational to mathematics. Then it also makes sense to lazily import lots of other things, like the interfaces to various optional packages or other rarely used items âÂ the more specialized or rarely used, the more we should try to avoid initializing them at startup. I would hope that the savings from lazily importing other things would outweigh the added costs of initializing `NN`.



---

archive/issue_comments_226987.json:
```json
{
    "body": "<a id='comment:29'></a>Replying to [comment:28 John Palmieri]:\n> It makes sense to me to just honestly import `NN` at the start\n\n\n+1",
    "created_at": "2022-09-19T17:53:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226987",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:29'></a>Replying to [comment:28 John Palmieri]:
> It makes sense to me to just honestly import `NN` at the start


+1



---

archive/issue_comments_226988.json:
```json
{
    "body": "<a id='comment:30'></a>I think changing NN to be initialized (and hence normally imported everywhere rather than lazily) deserves its own ticket, because it has a whole bunch of performance assessment it will need. Once that and/or this ticket is closer to merge, we can figure out which one will be based on which (since the fix to `Partitions` here should probably be done differently if NN never comes in a `LazyImport` shim -- although the code proposed now would still be correct and probably doesn't cause much overhead compared to what `Partitions` is already doing).\n\nTo get a bit of an idea of the costs involved in `Partitions` (the following are each done in a fresh session):\n\nIt looks like NN isn't actually used by bare `Partitions`:\n\n```\nsage: NN\nNon negative integer semiring\nsage: %time _=Partitions()\nCPU times: user 22 \u00b5s, sys: 2 \u00b5s, total: 24 \u00b5s\nWall time: 28.4 \u00b5s\n```\n\n```\nsage: %time _=Partitions()\nCPU times: user 24 \u00b5s, sys: 2 \u00b5s, total: 26 \u00b5s\nWall time: 29.6 \u00b5s\n```\nSo it's actually crazy that `Partitions(NN)` is even supported. It's just slower, with the same result:\n\n```\nsage: %time c=Partitions(NN)\nCPU times: user 1.85 ms, sys: 0 ns, total: 1.85 ms\nWall time: 1.62 ms\n```\n\n```\nsage: NN\nNon negative integer semiring\nsage: %time c=Partitions(NN)\nCPU times: user 171 \u00b5s, sys: 0 ns, total: 171 \u00b5s\nWall time: 185 \u00b5s\n```\nAn argument forces its construction of NN to compare the argument to it:\n\n```\nsage: %time c=Partitions(4)\nCPU times: user 2.01 ms, sys: 2 \u00b5s, total: 2.01 ms\nWall time: 1.98 ms\n```\n\n```\nsage: NN\nNon negative integer semiring\nsage: %time c=Partitions(4)\nCPU times: user 448 \u00b5s, sys: 47 \u00b5s, total: 495 \u00b5s\nWall time: 498 \u00b5s\nsage: %time c=Partitions(5)\nCPU times: user 156 \u00b5s, sys: 16 \u00b5s, total: 172 \u00b5s\nWall time: 175 \u00b5s\nsage: %time c=Partitions(7)\nCPU times: user 81 \u00b5s, sys: 8 \u00b5s, total: 89 \u00b5s\n```\n(and as you can see, there's a lot of other overhead as well on the first call -- but NN is pretty noticeable!)\nIn fact, the pure init of `NN` doesn't seem as expensive as `6ms` quoted above. That must have a lot of coercion discovery on it too. It varies quite wildly (and you can't put it in a `%timeit`):\n\n```\nsage: type(NN)\n<class 'sage.misc.lazy_import.LazyImport'>\nsage: %time _=NN._get_object()\nCPU times: user 730 \u00b5s, sys: 982 \u00b5s, total: 1.71 ms\nWall time: 1.56 ms\nsage: type(NN)\n<class 'sage.rings.semirings.non_negative_integer_semiring.NonNegativeIntegerSemiring_with_category'>\n```\n\n```\nsage: type(NN)\n<class 'sage.misc.lazy_import.LazyImport'>\nsage: %time _=NN._get_object()\nCPU times: user 1.8 ms, sys: 0 ns, total: 1.8 ms\nWall time: 1.66 ms\n```\nso it's probably more like 2ms than 6ms.\n\nBut a big take-away: supporting `Partitions(NN)` is just a way of having a slower way of constructing the same thing and generating more errors. The routine should just NOT take a parent as first argument: `None` works much better. As you can see, allowing `n=NN` as well as `n=None` (the default value) is actually very expensive. So not only is this causing a major headache, it's also a bad idea to have `NN` referenced in `Partitions` at all.",
    "created_at": "2022-09-19T18:00:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226988",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:30'></a>I think changing NN to be initialized (and hence normally imported everywhere rather than lazily) deserves its own ticket, because it has a whole bunch of performance assessment it will need. Once that and/or this ticket is closer to merge, we can figure out which one will be based on which (since the fix to `Partitions` here should probably be done differently if NN never comes in a `LazyImport` shim -- although the code proposed now would still be correct and probably doesn't cause much overhead compared to what `Partitions` is already doing).

To get a bit of an idea of the costs involved in `Partitions` (the following are each done in a fresh session):

It looks like NN isn't actually used by bare `Partitions`:

```
sage: NN
Non negative integer semiring
sage: %time _=Partitions()
CPU times: user 22 Âµs, sys: 2 Âµs, total: 24 Âµs
Wall time: 28.4 Âµs
```

```
sage: %time _=Partitions()
CPU times: user 24 Âµs, sys: 2 Âµs, total: 26 Âµs
Wall time: 29.6 Âµs
```
So it's actually crazy that `Partitions(NN)` is even supported. It's just slower, with the same result:

```
sage: %time c=Partitions(NN)
CPU times: user 1.85 ms, sys: 0 ns, total: 1.85 ms
Wall time: 1.62 ms
```

```
sage: NN
Non negative integer semiring
sage: %time c=Partitions(NN)
CPU times: user 171 Âµs, sys: 0 ns, total: 171 Âµs
Wall time: 185 Âµs
```
An argument forces its construction of NN to compare the argument to it:

```
sage: %time c=Partitions(4)
CPU times: user 2.01 ms, sys: 2 Âµs, total: 2.01 ms
Wall time: 1.98 ms
```

```
sage: NN
Non negative integer semiring
sage: %time c=Partitions(4)
CPU times: user 448 Âµs, sys: 47 Âµs, total: 495 Âµs
Wall time: 498 Âµs
sage: %time c=Partitions(5)
CPU times: user 156 Âµs, sys: 16 Âµs, total: 172 Âµs
Wall time: 175 Âµs
sage: %time c=Partitions(7)
CPU times: user 81 Âµs, sys: 8 Âµs, total: 89 Âµs
```
(and as you can see, there's a lot of other overhead as well on the first call -- but NN is pretty noticeable!)
In fact, the pure init of `NN` doesn't seem as expensive as `6ms` quoted above. That must have a lot of coercion discovery on it too. It varies quite wildly (and you can't put it in a `%timeit`):

```
sage: type(NN)
<class 'sage.misc.lazy_import.LazyImport'>
sage: %time _=NN._get_object()
CPU times: user 730 Âµs, sys: 982 Âµs, total: 1.71 ms
Wall time: 1.56 ms
sage: type(NN)
<class 'sage.rings.semirings.non_negative_integer_semiring.NonNegativeIntegerSemiring_with_category'>
```

```
sage: type(NN)
<class 'sage.misc.lazy_import.LazyImport'>
sage: %time _=NN._get_object()
CPU times: user 1.8 ms, sys: 0 ns, total: 1.8 ms
Wall time: 1.66 ms
```
so it's probably more like 2ms than 6ms.

But a big take-away: supporting `Partitions(NN)` is just a way of having a slower way of constructing the same thing and generating more errors. The routine should just NOT take a parent as first argument: `None` works much better. As you can see, allowing `n=NN` as well as `n=None` (the default value) is actually very expensive. So not only is this causing a major headache, it's also a bad idea to have `NN` referenced in `Partitions` at all.



---

archive/issue_comments_226989.json:
```json
{
    "body": "<a id='comment:31'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-09-19T19:54:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226989",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:31'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_226990.json:
```json
{
    "body": "<a id='comment:32'></a>By changing the order of testing in Partitions, we're at least ONLY triggering the import and construction of `NN` if it's likely necessary (i.e., only if `n` is not an integer AND not `None` -- thanks to shortcut evaluation for `or`.",
    "created_at": "2022-09-19T19:56:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226990",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:32'></a>By changing the order of testing in Partitions, we're at least ONLY triggering the import and construction of `NN` if it's likely necessary (i.e., only if `n` is not an integer AND not `None` -- thanks to shortcut evaluation for `or`.



---

archive/issue_comments_226991.json:
```json
{
    "body": "<a id='comment:34'></a># Analysis of misbound lazies\n\n## In sage.categories.groups:\n\n```\nfrom sage.categories.cartesian_product import CartesianProductsCategory, cartesian_product\n```\nand the definition there:\n\n```\n# Moved to avoid circular imports\nlazy_import('sage.categories.sets_cat', 'cartesian_product')\n```\nso perhaps we can just change it to\n\n```\nfrom sage.categories.sets_cat import cartesian_product\n```\n\n## sage.combinat.integer_vector : NN\n\n##  sage.combinat.composition :\n\n```\nfrom sage.categories.cartesian_product import cartesian_product\n```\n\n##  sage.combinat.path_enumeration :\n\n```\nfrom sage.categories.cartesian_product import cartesian_product\n```\n\n## sage.modular.arithgroup.congroup_generic :\n\n```\nfrom sage.groups.matrix_gps.all import MatrixGroup\n```\nwhere it is:\n\n```\nlazy_import('sage.groups.matrix_gps.finitely_generated', 'MatrixGroup')\n```\n\n## sage.combinat.partition_tuple : NN\n\n## sage.combinat.partition : NN\n\n## sage.combinat.non_decreasing_parking_function : NN\n\n## sage.combinat.set_partition_ordered : cartesian_product\n\n## sage.combinat.integer_vectors_mod_permgroup : NN",
    "created_at": "2022-09-20T06:21:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226991",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:34'></a># Analysis of misbound lazies

## In sage.categories.groups:

```
from sage.categories.cartesian_product import CartesianProductsCategory, cartesian_product
```
and the definition there:

```
# Moved to avoid circular imports
lazy_import('sage.categories.sets_cat', 'cartesian_product')
```
so perhaps we can just change it to

```
from sage.categories.sets_cat import cartesian_product
```

## sage.combinat.integer_vector : NN

##  sage.combinat.composition :

```
from sage.categories.cartesian_product import cartesian_product
```

##  sage.combinat.path_enumeration :

```
from sage.categories.cartesian_product import cartesian_product
```

## sage.modular.arithgroup.congroup_generic :

```
from sage.groups.matrix_gps.all import MatrixGroup
```
where it is:

```
lazy_import('sage.groups.matrix_gps.finitely_generated', 'MatrixGroup')
```

## sage.combinat.partition_tuple : NN

## sage.combinat.partition : NN

## sage.combinat.non_decreasing_parking_function : NN

## sage.combinat.set_partition_ordered : cartesian_product

## sage.combinat.integer_vectors_mod_permgroup : NN



---

archive/issue_comments_226992.json:
```json
{
    "body": "<a id='comment:35'></a>Replying to [comment:30 Nils Bruin]:\n> I think changing NN to be initialized (and hence normally imported everywhere rather than lazily) deserves its own ticket, because it has a whole bunch of performance assessment it will need.\n\n\nIs there a ticket for this yet?",
    "created_at": "2022-10-12T19:43:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226992",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:35'></a>Replying to [comment:30 Nils Bruin]:
> I think changing NN to be initialized (and hence normally imported everywhere rather than lazily) deserves its own ticket, because it has a whole bunch of performance assessment it will need.


Is there a ticket for this yet?



---

archive/issue_comments_226993.json:
```json
{
    "body": "<a id='comment:36'></a>Replying to [comment:35 John Palmieri]:\n> Is there a ticket for this yet?\n\n\nNo! Go ahead and make one! comment:34 is probably a good starting point. It looks like it's a relatively manageable problem (in the sense that it's not *that* many cases where lazy NN wrappers get sticky. However, it could still be that, as in partitions previously, some code uses the NN wrappers in such a way they don't get resolved (e.g., looking at their Id).",
    "created_at": "2022-10-12T20:23:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226993",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:36'></a>Replying to [comment:35 John Palmieri]:
> Is there a ticket for this yet?


No! Go ahead and make one! comment:34 is probably a good starting point. It looks like it's a relatively manageable problem (in the sense that it's not *that* many cases where lazy NN wrappers get sticky. However, it could still be that, as in partitions previously, some code uses the NN wrappers in such a way they don't get resolved (e.g., looking at their Id).



---

archive/issue_comments_226994.json:
```json
{
    "body": "<a id='comment:37'></a>Okay, it's #34652.",
    "created_at": "2022-10-12T22:22:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226994",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:37'></a>Okay, it's #34652.



---

archive/issue_comments_226995.json:
```json
{
    "body": "<a id='comment:39'></a>Rebased\n\n---\nNew commits:",
    "created_at": "2022-12-18T19:49:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226995",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:39'></a>Rebased

---
New commits:



---

archive/issue_comments_226996.json:
```json
{
    "body": "<a id='comment:40'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2022-12-18T19:51:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226996",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:40'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_226997.json:
```json
{
    "body": "<a id='comment:41'></a>Dropped workarounds for NN in partitions",
    "created_at": "2022-12-18T19:51:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226997",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:41'></a>Dropped workarounds for NN in partitions



---

archive/issue_comments_226998.json:
```json
{
    "body": "<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-12-18T20:18:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226998",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:42'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_226999.json:
```json
{
    "body": "<a id='comment:43'></a>I think handling the more common cases like `Partitions(3)` first makes sense anyway. Calls to `Partitions()` are less likely, and `Partitions(NN)` even less common than that. Prioritizing more common call patterns in case determination of input is generally good. So I think the change to `Partitions` in [406e6f8](https://git.sagemath.org/sage.git/commit?id=406e6f86f049110229c46b52042984f02d6592ac) makes sense regardless of the import problems on `NN`.",
    "created_at": "2022-12-18T20:24:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-226999",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:43'></a>I think handling the more common cases like `Partitions(3)` first makes sense anyway. Calls to `Partitions()` are less likely, and `Partitions(NN)` even less common than that. Prioritizing more common call patterns in case determination of input is generally good. So I think the change to `Partitions` in [406e6f8](https://git.sagemath.org/sage.git/commit?id=406e6f86f049110229c46b52042984f02d6592ac) makes sense regardless of the import problems on `NN`.



---

archive/issue_comments_227000.json:
```json
{
    "body": "<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-12-18T20:26:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-227000",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:44'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_227001.json:
```json
{
    "body": "<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-12-18T20:29:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-227001",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:45'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_227002.json:
```json
{
    "body": "<a id='comment:46'></a>Replying to [comment:43 Nils Bruin]:\n> I think the change to `Partitions` in [406e6f8](https://git.sagemath.org/sage.git/commit?id=406e6f86f049110229c46b52042984f02d6592ac) makes sense regardless of the import problems on `NN`.\n\n\nDone",
    "created_at": "2022-12-18T20:30:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-227002",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:46'></a>Replying to [comment:43 Nils Bruin]:
> I think the change to `Partitions` in [406e6f8](https://git.sagemath.org/sage.git/commit?id=406e6f86f049110229c46b52042984f02d6592ac) makes sense regardless of the import problems on `NN`.


Done



---

archive/issue_comments_227003.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2022-12-18T20:30:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-227003",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_227004.json:
```json
{
    "body": "<a id='comment:50'></a>+1 from me, but I think someone else than me should give a positive review: the changes here affect start-up procedures for sage, so it is a rather invasive change.",
    "created_at": "2022-12-18T23:35:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-227004",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:50'></a>+1 from me, but I think someone else than me should give a positive review: the changes here affect start-up procedures for sage, so it is a rather invasive change.



---

archive/issue_comments_227005.json:
```json
{
    "body": "<a id='comment:51'></a>Yes, I have already reviewed your changes.",
    "created_at": "2022-12-18T23:37:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-227005",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:51'></a>Yes, I have already reviewed your changes.



---

archive/issue_comments_227006.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2022-12-19T18:56:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16522",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16522#issuecomment-227006",
    "user": "https://github.com/nbruin"
}
```

Changing status from needs_review to positive_review.
