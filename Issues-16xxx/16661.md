# Issue 16661: conversion from maxima buggy

archive/issues_016661.json:
```json
{
    "body": "CC:  @kcrisman\n\nKeywords: maxima, conversion, variable\n\n```\nOn Wed, Aug 27, 2014 at 2:46 PM, Peter Mueller <ypf...@googlemail.com> wrote: \n> My understanding of Sage is that var('e') declares e as a symbolic variable, \n> no matter that it was the Euler number before. The last line leaves me \n> clueless what goes wrong ... \n> \n> sage: var('e') \n> e \n> sage: matrix.diagonal([e,1,1]).det() \n> e \n> sage: matrix.diagonal([e,1,1,1]).det() \n> _e \n \nOn Wednesday, August 27, 2014 3:13:58 PM UTC+2, Stein William wrote:\nThe real bug is in conversion from Maxima to Sage.  Observe: \n\n~/wstein/sage-6.4.beta1$ ./sage \nsage: maxima('_SAGE_VAR_e')._sage_() \n_e \n```\nThe same, as suspected, with `i`, so #6882 is the culprit.\n\nIssue created by migration from https://trac.sagemath.org/ticket/16898\n\n",
    "closed_at": "2015-03-10T23:26:14Z",
    "created_at": "2014-08-28T14:58:24Z",
    "labels": [
        "component: interfaces",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.6",
    "title": "conversion from maxima buggy",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16661",
    "user": "https://github.com/rwst"
}
```
CC:  @kcrisman

Keywords: maxima, conversion, variable

```
On Wed, Aug 27, 2014 at 2:46 PM, Peter Mueller <ypf...@googlemail.com> wrote: 
> My understanding of Sage is that var('e') declares e as a symbolic variable, 
> no matter that it was the Euler number before. The last line leaves me 
> clueless what goes wrong ... 
> 
> sage: var('e') 
> e 
> sage: matrix.diagonal([e,1,1]).det() 
> e 
> sage: matrix.diagonal([e,1,1,1]).det() 
> _e 
 
On Wednesday, August 27, 2014 3:13:58 PM UTC+2, Stein William wrote:
The real bug is in conversion from Maxima to Sage.  Observe: 

~/wstein/sage-6.4.beta1$ ./sage 
sage: maxima('_SAGE_VAR_e')._sage_() 
_e 
```
The same, as suspected, with `i`, so #6882 is the culprit.

Issue created by migration from https://trac.sagemath.org/ticket/16898





---

archive/issue_comments_219678.json:
```json
{
    "body": "Well, so `sefms` should know about existing Sage variables and prepend the underscore only if the variable doesn't exist:\n\n```\nsage: sefms('e')\n_e\nsage: e = var('e')\nsage: sefms('e')\ne\n```\n\nTo recall, some marking is needed because removal of `_SAGE_VAR_` has already happened before `sefms`, and `e` could well be a Maxima variable. We just didn't think that someone could use such Sage variables.",
    "created_at": "2014-08-28T15:30:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219678",
    "user": "https://github.com/rwst"
}
```

Well, so `sefms` should know about existing Sage variables and prepend the underscore only if the variable doesn't exist:

```
sage: sefms('e')
_e
sage: e = var('e')
sage: sefms('e')
e
```

To recall, some marking is needed because removal of `_SAGE_VAR_` has already happened before `sefms`, and `e` could well be a Maxima variable. We just didn't think that someone could use such Sage variables.



---

archive/issue_comments_219679.json:
```json
{
    "body": "Aargh!!!  But checking variables is often a nightmare, and there are other things that could be used for `e` too.",
    "created_at": "2014-08-28T16:10:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219679",
    "user": "https://github.com/kcrisman"
}
```

Aargh!!!  But checking variables is often a nightmare, and there are other things that could be used for `e` too.



---

archive/issue_comments_219680.json:
```json
{
    "body": "But the other things are not shoved to Maxima and back, are they?",
    "created_at": "2014-08-28T16:16:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219680",
    "user": "https://github.com/rwst"
}
```

But the other things are not shoved to Maxima and back, are they?



---

archive/issue_comments_219681.json:
```json
{
    "body": "Well, anything in a symbolic matrix (or a symbolic integral, or limit) gets sent to Maxima and back.  But maybe just raw variables are the only worry here.\n\nThe following would be the thing to fix.\n\n```\nsage: e = var('e')\nsage: e == maxima(e)._sage_()\ne == _e\n```\nwhereas\n\n```\nsage: reset()\nsage: e == maxima(e)._sage_()\ne == e\n```",
    "created_at": "2014-08-28T17:19:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219681",
    "user": "https://github.com/kcrisman"
}
```

Well, anything in a symbolic matrix (or a symbolic integral, or limit) gets sent to Maxima and back.  But maybe just raw variables are the only worry here.

The following would be the thing to fix.

```
sage: e = var('e')
sage: e == maxima(e)._sage_()
e == _e
```
whereas

```
sage: reset()
sage: e == maxima(e)._sage_()
e == e
```



---

archive/issue_comments_219682.json:
```json
{
    "body": "Replying to [comment:5 kcrisman]:\n> The following would be the thing to fix.\n> \n> ```\n> sage: e = var('e')\n> sage: e == maxima(e)._sage_()\n> e == _e\n> ```\n> whereas\n> \n> ```\n> sage: reset()\n> sage: e == maxima(e)._sage_()\n> e == e\n> ```\n\nI don't think so. It should both be `e == e` because the first time you're giving the variable as argument, and the second time the constant. Rather:\n\n```\nsage: e = var('e')\nsage: e == maxima(e)._sage_()\ne == e\nsage: reset()\nsage: e == maxima(e)._sage_()\ne == e\nsage: e == maxima('e')._sage_()\ne == _e\n```\n\nFix proposal following.",
    "created_at": "2014-08-29T15:00:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219682",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:5 kcrisman]:
> The following would be the thing to fix.
> 
> ```
> sage: e = var('e')
> sage: e == maxima(e)._sage_()
> e == _e
> ```
> whereas
> 
> ```
> sage: reset()
> sage: e == maxima(e)._sage_()
> e == e
> ```

I don't think so. It should both be `e == e` because the first time you're giving the variable as argument, and the second time the constant. Rather:

```
sage: e = var('e')
sage: e == maxima(e)._sage_()
e == e
sage: reset()
sage: e == maxima(e)._sage_()
e == e
sage: e == maxima('e')._sage_()
e == _e
```

Fix proposal following.



---

archive/issue_comments_219683.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-08-29T15:26:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219683",
    "user": "https://github.com/rwst"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_219684.json:
```json
{
    "body": "It was much easier than feared because we could get to the string before removal of `_SAGE_VAR_`. The method is to mark specific maxima vars in the string with underscore. Note: this or a different prefix could be given to all maxima vars.\n\n---\nNew commits:",
    "created_at": "2014-08-29T15:26:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219684",
    "user": "https://github.com/rwst"
}
```

It was much easier than feared because we could get to the string before removal of `_SAGE_VAR_`. The method is to mark specific maxima vars in the string with underscore. Note: this or a different prefix could be given to all maxima vars.

---
New commits:



---

archive/issue_comments_219685.json:
```json
{
    "body": "> > The following would be the thing to fix.\n\n> I don't think so. It should both be `e == e` because the first time you're giving the variable as argument, and the second time the constant. Rather:\nI was actually agreeing with you - it was the thing to FIX.  :-)\n\n> Fix proposal following.\n\n\nOkay, I'll look at this.",
    "created_at": "2014-08-29T16:15:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219685",
    "user": "https://github.com/kcrisman"
}
```

> > The following would be the thing to fix.

> I don't think so. It should both be `e == e` because the first time you're giving the variable as argument, and the second time the constant. Rather:
I was actually agreeing with you - it was the thing to FIX.  :-)

> Fix proposal following.


Okay, I'll look at this.



---

archive/issue_comments_219686.json:
```json
{
    "body": "```\ns[:m.start()-1] + '_' + s[m.start()]\n```\nshould that maybe just be \n\n```\ns[:m.start()] + '_' + s[m.start()]\n```\nwe're not getting rid of anything, are we?  Just putting in an underscore?  The [documentation](https://docs.python.org/2/library/re.html#re.MatchObject.start) seems to suggest this, since Python slices have \"the end always excluded\".  I don't think any of your examples catch that, since they just have `e`.  But `foo+bar+e` might get turned to `foo+bar_e`?  (Sorry for not trying this out quite yet, I don't have an easy-access branch just now.)",
    "created_at": "2014-08-29T16:22:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219686",
    "user": "https://github.com/kcrisman"
}
```

```
s[:m.start()-1] + '_' + s[m.start()]
```
should that maybe just be 

```
s[:m.start()] + '_' + s[m.start()]
```
we're not getting rid of anything, are we?  Just putting in an underscore?  The [documentation](https://docs.python.org/2/library/re.html#re.MatchObject.start) seems to suggest this, since Python slices have "the end always excluded".  I don't think any of your examples catch that, since they just have `e`.  But `foo+bar+e` might get turned to `foo+bar_e`?  (Sorry for not trying this out quite yet, I don't have an easy-access branch just now.)



---

archive/issue_comments_219687.json:
```json
{
    "body": "Would it be possible to fix this properly? It should really be *easier* to do the conversion properly now that *variables* get converted to something with a `_SAGE_VAR_` prefix.\n\nFrom sage to maxima: At this point you know whether an object is a symbolic variable or a (predefined) symbolic constant. In one case you convert it to the string `_SAGE_VAR_e`, in the other case you convert it to `%e`.\n\nFrom maxima to sage: This is the trickier one, because the strings-based interface needs to try to tell everything from string representations. However, since we're either seeing `%e` or `_SAGE_VAR_e`, there's not really any confusion. Whether a variable \"e\" exists doesn't even matter. Indeed, we have\n\n```\nsage: var('e')\ne\nsage: e==exp(1)\ne == e\nsage: bool(e==exp(1))\nFalse\nsage: (e==exp(1))._maxima_init_()\n'_SAGE_VAR_e = exp(1)'\n```\nso we should make sure that `%e` gets converted back to `sage.functions.log.exp(1)` and that that `_SAGE_VAR_e` gets converted to `SR.var('e')`.\n\nThe round trip currently goes horribly wrong:\n\n```\nsage: A=e==exp(1)\nsage: A\nsage: maxima_calculus(A) # this is fine\n_SAGE_VAR_e=%e\nsage: A_roundtrip=maxima_calculus(A)._sage_()\nsage: A_roundtrip.lhs() #a new symbol got invented!\n_e\nsage: bool(A_roundtrip.rhs() == exp(1)) #and the right hand side is now a symbolic variable!\nFalse\nsage: bool(maxima_calculus(A)._sage_())\nFalse\nsage: bool(maxima_calculus(maxima_calculus(A)._sage_())._sage_()) #fun all the way.\nTrue\n```\n\nIf confusion arises, then this is probably due to inappropriate string substitutions. It may well be that sefms is up for a major refactoring.\n\nI was a little surprised that `max_to_sr` and `sr_to_max` get this wrong too:\n\n```\nsage: max_to_sr(maxima_calculus(sr_to_max(A)).ecl())\ne == e\nsage: bool(max_to_sr(maxima_calculus(sr_to_max(A)).ecl()))\nTrue\n```\n\nbut this may be because currently, sr_to_max/max_to_sr get their initial translations from string-based. Certainly the infrastructure for these routines fully allows to distinguish objects regardless of their printed representation. These could be fixed by handling \"symbolic variables\" and \"_SAGE_VAR_...\" symbols (on the lisp side) separately (in sr_to_max/max_to_sr). That would reduce chances that we mess up the translation tables. In fact, objects of type `sage.symbolic.function_factory.NewSymbolicFunction` should probably be translated to `_SAGE_FUNC_...` in maxima for similar reasons.",
    "created_at": "2014-08-29T18:19:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219687",
    "user": "https://github.com/nbruin"
}
```

Would it be possible to fix this properly? It should really be *easier* to do the conversion properly now that *variables* get converted to something with a `_SAGE_VAR_` prefix.

From sage to maxima: At this point you know whether an object is a symbolic variable or a (predefined) symbolic constant. In one case you convert it to the string `_SAGE_VAR_e`, in the other case you convert it to `%e`.

From maxima to sage: This is the trickier one, because the strings-based interface needs to try to tell everything from string representations. However, since we're either seeing `%e` or `_SAGE_VAR_e`, there's not really any confusion. Whether a variable "e" exists doesn't even matter. Indeed, we have

```
sage: var('e')
e
sage: e==exp(1)
e == e
sage: bool(e==exp(1))
False
sage: (e==exp(1))._maxima_init_()
'_SAGE_VAR_e = exp(1)'
```
so we should make sure that `%e` gets converted back to `sage.functions.log.exp(1)` and that that `_SAGE_VAR_e` gets converted to `SR.var('e')`.

The round trip currently goes horribly wrong:

```
sage: A=e==exp(1)
sage: A
sage: maxima_calculus(A) # this is fine
_SAGE_VAR_e=%e
sage: A_roundtrip=maxima_calculus(A)._sage_()
sage: A_roundtrip.lhs() #a new symbol got invented!
_e
sage: bool(A_roundtrip.rhs() == exp(1)) #and the right hand side is now a symbolic variable!
False
sage: bool(maxima_calculus(A)._sage_())
False
sage: bool(maxima_calculus(maxima_calculus(A)._sage_())._sage_()) #fun all the way.
True
```

If confusion arises, then this is probably due to inappropriate string substitutions. It may well be that sefms is up for a major refactoring.

I was a little surprised that `max_to_sr` and `sr_to_max` get this wrong too:

```
sage: max_to_sr(maxima_calculus(sr_to_max(A)).ecl())
e == e
sage: bool(max_to_sr(maxima_calculus(sr_to_max(A)).ecl()))
True
```

but this may be because currently, sr_to_max/max_to_sr get their initial translations from string-based. Certainly the infrastructure for these routines fully allows to distinguish objects regardless of their printed representation. These could be fixed by handling "symbolic variables" and "_SAGE_VAR_..." symbols (on the lisp side) separately (in sr_to_max/max_to_sr). That would reduce chances that we mess up the translation tables. In fact, objects of type `sage.symbolic.function_factory.NewSymbolicFunction` should probably be translated to `_SAGE_FUNC_...` in maxima for similar reasons.



---

archive/issue_comments_219688.json:
```json
{
    "body": "perhaps check out `_find_var` and `_find_func`, used in `symbolic_expression_from_string` (in the same file) rather than `symbolic_expression_from_maxima_string`. Those work on string tokens once the expression is actually parsed. Conversion there should be much more straightforward than by string-based preprocessing using regular expressions, which is what happens in `symbolic_expression_from_maxima_string`. Probably, anything we can do there rather than by dumb string manipulations will be much better and easier to maintain than the mess we have now. Certainly, making `_find_var` aware of `_SAGE_VAR_...` rather than just stripping out this valuable marker will lead to a much more efficient and reliable conversion process. I don't have the time to dive into the peculiarities of the relevant routines, but the code looks pretty straightforward, so hopefully someone is willing to invest a little time in refactoring this code. It will make working on strings-based maxima-to-sage conversions much more pleasurable.",
    "created_at": "2014-08-30T03:44:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219688",
    "user": "https://github.com/nbruin"
}
```

perhaps check out `_find_var` and `_find_func`, used in `symbolic_expression_from_string` (in the same file) rather than `symbolic_expression_from_maxima_string`. Those work on string tokens once the expression is actually parsed. Conversion there should be much more straightforward than by string-based preprocessing using regular expressions, which is what happens in `symbolic_expression_from_maxima_string`. Probably, anything we can do there rather than by dumb string manipulations will be much better and easier to maintain than the mess we have now. Certainly, making `_find_var` aware of `_SAGE_VAR_...` rather than just stripping out this valuable marker will lead to a much more efficient and reliable conversion process. I don't have the time to dive into the peculiarities of the relevant routines, but the code looks pretty straightforward, so hopefully someone is willing to invest a little time in refactoring this code. It will make working on strings-based maxima-to-sage conversions much more pleasurable.



---

archive/issue_comments_219689.json:
```json
{
    "body": "Well, I think it's better to apply this quick fix and work towards abandoning of the expect interface.",
    "created_at": "2014-08-30T10:24:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219689",
    "user": "https://github.com/rwst"
}
```

Well, I think it's better to apply this quick fix and work towards abandoning of the expect interface.



---

archive/issue_comments_219690.json:
```json
{
    "body": "Replying to [comment:13 rws]:\n> Well, I think it's better to apply this quick fix and work towards abandoning of the expect interface.\n\n\nThe proposed fix doesn't solve the issue, though. I've tried the branch here and I get this:\n\n```\nsage: A = SR.var('e')==exp(1)\nsage: A # the printing of this may be confusing but the meaning to sage is clear\ne == e\nsage: bool(A)\nFalse\nsage: bool(SR(maxima_calculus(A))) #the distinction doesn't survive the round-trip.\nTrue\nsage: A.rhs().is_symbol()\nFalse\nsage: SR(maxima_calculus(A)).rhs().is_symbol()\nTrue\n```\nso it seems that the existence of a variable `e` in pynac causes maxima's `%e` to be translated to `SR.var('e')`. Illustrating this directly:\n\n```\nsage: from sage.calculus.calculus import symbolic_expression_from_maxima_string as sefms\nsage: sefms('%e').is_symbol()\nFalse\nsage: SR.var('e') #apparently this affects the translation\ne\nsage: sefms('%e').is_symbol()\nTrue\n```\nIt seems that changing the entry for `symtable['%e']` to `'exp(1)'` sort-of fixes this, but obviously, for `%i` and `%I` we have the same problem.\n\nThis won't be quite bulletproof either, due to:\n\n```\nsage: function('log')\nlog\nsage: sage.functions.log.log(x) == log(x)\n```\nbut that currently won't even make it *to* maxima (that would need a `_SAGE_FUNCTION_log` encoding)",
    "created_at": "2014-08-31T19:10:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219690",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:13 rws]:
> Well, I think it's better to apply this quick fix and work towards abandoning of the expect interface.


The proposed fix doesn't solve the issue, though. I've tried the branch here and I get this:

```
sage: A = SR.var('e')==exp(1)
sage: A # the printing of this may be confusing but the meaning to sage is clear
e == e
sage: bool(A)
False
sage: bool(SR(maxima_calculus(A))) #the distinction doesn't survive the round-trip.
True
sage: A.rhs().is_symbol()
False
sage: SR(maxima_calculus(A)).rhs().is_symbol()
True
```
so it seems that the existence of a variable `e` in pynac causes maxima's `%e` to be translated to `SR.var('e')`. Illustrating this directly:

```
sage: from sage.calculus.calculus import symbolic_expression_from_maxima_string as sefms
sage: sefms('%e').is_symbol()
False
sage: SR.var('e') #apparently this affects the translation
e
sage: sefms('%e').is_symbol()
True
```
It seems that changing the entry for `symtable['%e']` to `'exp(1)'` sort-of fixes this, but obviously, for `%i` and `%I` we have the same problem.

This won't be quite bulletproof either, due to:

```
sage: function('log')
log
sage: sage.functions.log.log(x) == log(x)
```
but that currently won't even make it *to* maxima (that would need a `_SAGE_FUNCTION_log` encoding)



---

archive/issue_comments_219691.json:
```json
{
    "body": "New branch, based on doing more at parser level rather than at string mangling level. Previous branch was:\n\nu/rws/conversion_from_maxima_buggy \n\nI think the present branch is already more in the direction. Important obstacle to using Bradshaw's parser straight on maxima output: It can't handle % characters as part of identifiers (it's an operator in python after all!), I think the current branch solves at least the problem stated in the ticket without creating new problems.",
    "created_at": "2014-09-03T07:39:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219691",
    "user": "https://github.com/nbruin"
}
```

New branch, based on doing more at parser level rather than at string mangling level. Previous branch was:

u/rws/conversion_from_maxima_buggy 

I think the present branch is already more in the direction. Important obstacle to using Bradshaw's parser straight on maxima output: It can't handle % characters as part of identifiers (it's an operator in python after all!), I think the current branch solves at least the problem stated in the ticket without creating new problems.



---

archive/issue_comments_219692.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-09-03T07:45:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219692",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_219693.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2014-09-04T06:50:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219693",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_219694.json:
```json
{
    "body": "Buildbot reports some order changes in doctests of `src/sage/matrix/matrix2.pyx`. Also, I'm not sure if it fits the ticket, I found the following:\n\n```\nsage: pari.pollegendre(4,e)\n35/8*e^4 - 15/4*e^2 + 3/8\nsage: SR(_)\n35/8*e^4 - 15/4*e^2 + 3/8\nsage: _.simplify_full()\n35/8*_e^4 - 15/4*_e^2 + 3/8\n```",
    "created_at": "2014-09-04T06:50:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219694",
    "user": "https://github.com/rwst"
}
```

Buildbot reports some order changes in doctests of `src/sage/matrix/matrix2.pyx`. Also, I'm not sure if it fits the ticket, I found the following:

```
sage: pari.pollegendre(4,e)
35/8*e^4 - 15/4*e^2 + 3/8
sage: SR(_)
35/8*e^4 - 15/4*e^2 + 3/8
sage: _.simplify_full()
35/8*_e^4 - 15/4*_e^2 + 3/8
```



---

archive/issue_comments_219695.json:
```json
{
    "body": "Replying to [comment:17 rws]:\n> {{{\n> sage: pari.pollegendre(4,e)\n> 35/8*e^4 - 15/4*e^2 + 3/8\n> sage: SR(_)\n> 35/8*e^4 - 15/4*e^2 + 3/8\n> sage: _.simplify_full()\n> 35/8*_e^4 - 15/4*_e^2 + 3/8\n> }}}\n\nNice one. That's a separate ticket, I think, though:\n\n```\nsage: f=pari.pollegendre(4,e)\nsage: g=SR(f)\nsage: g.operator()\nsage: g.operands()\n[]\nsage: g.pyobject() is f\nTrue\n```\nApparently pari \"polynomials\" don't get properly converted to SR, but just get stuffed in. Consequently, the sage-to-maxima conversion just sees if maxima can make sense of the string representation. For instance (and that's what you see) variables don't get properly converted:\n\n```\nsage: maxima_calculus(g) #note no _SAGE_VAR_ prefixes\n35*e^4/8-15*e^2/4+3/8\n```\nOther paths lead to errors:\n\n```\nsage: QQ['e'](g)\nTypeError: Unable to coerce PARI 35/8*e^4 - 15/4*e^2 + 3/8 to an Integer\n```\nThe truth is, almost everything can be stuffed in SR and, as a result, not everything in SR can be translated to maxima:\n\n```\nsage: M=pari.matrix(2,2)\nsage: M\n[0, 0; 0, 0]\nsage: M.simplify_full()\nAttributeError: 'MaximaLibElement' object has no attribute '_name'\nsage: maxima_calculus(M) #maxima's reader chokes on [0,0;0,0] because it's ungrammatical in maximan\nTypeError: ECL says: THROW: The catch MACSYMA-QUIT is undefined.\n```\nWe can hide the bad behaviour in the particular example you gave by folding both `_SAGE_VAR_e` and `e` back onto `e` but you'd still get wrong answers:\n\n```\nsage: integrate(g,e)\nintegrate(35/8*e^4 - 15/4*e^2 + 3/8, e)\nsage: integrate(g,e).simplify()\n1/8*(35*_e^4 - 30*_e^2 + 3)*e\n```\nIn the latter one, at least we now see something funny has happened. If it were to multiply out, it's truly confusing.",
    "created_at": "2014-09-04T15:47:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219695",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:17 rws]:
> {{{
> sage: pari.pollegendre(4,e)
> 35/8*e^4 - 15/4*e^2 + 3/8
> sage: SR(_)
> 35/8*e^4 - 15/4*e^2 + 3/8
> sage: _.simplify_full()
> 35/8*_e^4 - 15/4*_e^2 + 3/8
> }}}

Nice one. That's a separate ticket, I think, though:

```
sage: f=pari.pollegendre(4,e)
sage: g=SR(f)
sage: g.operator()
sage: g.operands()
[]
sage: g.pyobject() is f
True
```
Apparently pari "polynomials" don't get properly converted to SR, but just get stuffed in. Consequently, the sage-to-maxima conversion just sees if maxima can make sense of the string representation. For instance (and that's what you see) variables don't get properly converted:

```
sage: maxima_calculus(g) #note no _SAGE_VAR_ prefixes
35*e^4/8-15*e^2/4+3/8
```
Other paths lead to errors:

```
sage: QQ['e'](g)
TypeError: Unable to coerce PARI 35/8*e^4 - 15/4*e^2 + 3/8 to an Integer
```
The truth is, almost everything can be stuffed in SR and, as a result, not everything in SR can be translated to maxima:

```
sage: M=pari.matrix(2,2)
sage: M
[0, 0; 0, 0]
sage: M.simplify_full()
AttributeError: 'MaximaLibElement' object has no attribute '_name'
sage: maxima_calculus(M) #maxima's reader chokes on [0,0;0,0] because it's ungrammatical in maximan
TypeError: ECL says: THROW: The catch MACSYMA-QUIT is undefined.
```
We can hide the bad behaviour in the particular example you gave by folding both `_SAGE_VAR_e` and `e` back onto `e` but you'd still get wrong answers:

```
sage: integrate(g,e)
integrate(35/8*e^4 - 15/4*e^2 + 3/8, e)
sage: integrate(g,e).simplify()
1/8*(35*_e^4 - 30*_e^2 + 3)*e
```
In the latter one, at least we now see something funny has happened. If it were to multiply out, it's truly confusing.



---

archive/issue_comments_219696.json:
```json
{
    "body": "This was reported again at #17187.",
    "created_at": "2014-10-21T21:29:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219696",
    "user": "https://github.com/jdemeyer"
}
```

This was reported again at #17187.



---

archive/issue_comments_219697.json:
```json
{
    "body": "Thanks, Jeroen.  So what needs fixing here is just some doctests?",
    "created_at": "2014-10-22T00:07:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219697",
    "user": "https://github.com/kcrisman"
}
```

Thanks, Jeroen.  So what needs fixing here is just some doctests?



---

archive/issue_comments_219698.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2014-11-01T16:31:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219698",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_219699.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-11-01T16:31:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219699",
    "user": "https://github.com/rwst"
}
```

New commits:



---

archive/issue_comments_219700.json:
```json
{
    "body": "I'm OK with the amended doctests, so if someone else is happy with the other changes, this ticket can be set to positive review.",
    "created_at": "2014-11-01T18:45:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219700",
    "user": "https://github.com/nbruin"
}
```

I'm OK with the amended doctests, so if someone else is happy with the other changes, this ticket can be set to positive review.



---

archive/issue_comments_219701.json:
```json
{
    "body": "Replying to [comment:23 nbruin]:\n> I'm OK with the amended doctests, so if someone else is happy with the other changes, this ticket can be set to positive review.\n\nCompletely forgot about this. Your part is fine, and patchbot is happy.",
    "created_at": "2015-03-08T13:54:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219701",
    "user": "https://github.com/rwst"
}
```

Replying to [comment:23 nbruin]:
> I'm OK with the amended doctests, so if someone else is happy with the other changes, this ticket can be set to positive review.

Completely forgot about this. Your part is fine, and patchbot is happy.



---

archive/issue_events_049364.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2015-03-08T13:54:44Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "milestone": "sage-6.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16661#event-49364"
}
```



---

archive/issue_comments_219702.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-03-08T13:54:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219702",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_219703.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-03-10T23:26:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219703",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_049365.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-03-10T23:26:14Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16661#event-49365"
}
```



---

archive/issue_comments_219704.json:
```json
{
    "body": "See http://ask.sagemath.org/question/26489/compute-the-determinant-of-a-symbolic-5x5-matrix/ though I assume that is exactly what is fixed here.",
    "created_at": "2015-04-11T01:11:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16661",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16661#issuecomment-219704",
    "user": "https://github.com/kcrisman"
}
```

See http://ask.sagemath.org/question/26489/compute-the-determinant-of-a-symbolic-5x5-matrix/ though I assume that is exactly what is fixed here.
