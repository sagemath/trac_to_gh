# Issue 16520: circular import in maxima_lib.py

archive/issues_016283.json:
```json
{
    "body": "The lazy import in #2516 uncovered bad imports in `interfaces/maxima_lib.py`. To enable fixing it independently of a review of that ticket a separate ticket is created.\n\nKeywords: maxima, cleanup\n\nAuthor: Ralf Stephan\n\nBranch: u/rws/circular_import_in_maxima_lib_py\n\nCommit: a3bc86c0855155e2755f9174f95f8dd578827d92\n\nResolution: duplicate\n\nIssue created by migration from https://trac.sagemath.org/ticket/16520\n\n",
    "closed_at": "2014-06-24T14:14:27Z",
    "created_at": "2014-06-23T15:42:35Z",
    "labels": [
        "component: interfaces",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "circular import in maxima_lib.py",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16520",
    "user": "https://github.com/rwst"
}
```
The lazy import in #2516 uncovered bad imports in `interfaces/maxima_lib.py`. To enable fixing it independently of a review of that ticket a separate ticket is created.

Keywords: maxima, cleanup

Author: Ralf Stephan

Branch: u/rws/circular_import_in_maxima_lib_py

Commit: a3bc86c0855155e2755f9174f95f8dd578827d92

Resolution: duplicate

Issue created by migration from https://trac.sagemath.org/ticket/16520





---

archive/issue_comments_212814.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-06-23T15:48:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16520",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16520#issuecomment-212814",
    "user": "https://github.com/rwst"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_212815.json:
```json
{
    "body": "<a id='comment:2'></a>New commits:",
    "created_at": "2014-06-23T15:48:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16520",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16520#issuecomment-212815",
    "user": "https://github.com/rwst"
}
```

<a id='comment:2'></a>New commits:



---

archive/issue_comments_212816.json:
```json
{
    "body": "<a id='comment:3'></a>Just out of curiosity, do you have a theory why using `from ... import ...` works better than `import ...`? I would normally expect that `from ... import ...` constructions are more fragile (although it probably doesn't matter if the imported symbols are accessed in the module initialization code anyway)",
    "created_at": "2014-06-23T17:31:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16520",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16520#issuecomment-212816",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:3'></a>Just out of curiosity, do you have a theory why using `from ... import ...` works better than `import ...`? I would normally expect that `from ... import ...` constructions are more fragile (although it probably doesn't matter if the imported symbols are accessed in the module initialization code anyway)



---

archive/issue_comments_212817.json:
```json
{
    "body": "<a id='comment:4'></a>I noticed these executed at runtime (as opposed to module initialization time):\n\n```\n+ from sage.rings.rational import Rational\n+ from sage.rings.number_field.number_field_element_quadratic import NumberFieldElement_quadratic\n+ if isinstance(obj, Rational):\n```\nThat's bad, because these are global assignments. You don't want to do those\nagain and again. Also, I find it hard to believe that those two modules somehow\nrefer back to `maxima_lib`.\n\nThe following runs at module initialization time anyway. I don't see how `from\n...` makes this better than `import sage.symbolic.pynac`. It's not critical, so\nI don't really care, apart from the fact that the namespace gets an extra\nunnecessary symbol `symbol_table`.\n\n```\n+from sage.symbolic.pynac import symbol_table\n+max_to_pynac_table = symbol_table['maxima']\n```\n\nIn general, I have trouble seeing how `maxima_lib` can lead to circular imports,\nbecause `maxima_lib` is an interface and as such gets referenced by virtually\nno-one. The only place is `sage.calculus.calculus` and I've very carefully made\nsure we don't reference that. Furthermore, even there it's imported lazily, and\nfor very good reason: Importing `maxima_lib` initializes `ecl` with `maxima`\nwhich takes considerable time.\n\nSo I suspect it's not so much a circular import but a bad interaction between\nthe lazy import of `maxima_lib` and the attempted lazy import of\n`hypergeometric`. The proper solution is probably to *not* lazily import\nhypergeometric into maxima_lib, but import it plainly there. By the time you're\nimporting maxima_lib you're already committed to significant initialization\ntime, so unless hypergeometric does something really strange, I don't expect it\nwill have a significant effect.\n\nTL;DR: I'm not convinced that this ticket is actually solving a real problem.\n\n*addition:* I think the following gives a strong indication that `maxima_lib` does not have a circular import. The following is supposed to be a complete list of the imports done in `maxima_lib`. A circular import would imply that one of those imports leads to importing `maxima_lib`, which means the `LazyImport` should resolve:\n\n```\nsage: from sage.symbolic.ring import SR, var\nsage: from sage.interfaces.maxima_abstract import (MaximaAbstract, MaximaAbstractFunction,\n....:   MaximaAbstractElement, MaximaAbstractFunctionElement,\n....:   MaximaAbstractElementFunction)\nsage: import sage.rings.real_double\nsage: import sage.symbolic.expression\nsage: import sage.functions.trig\nsage: import sage.functions.log\nsage: import sage.functions.other\nsage: import sage.symbolic.integration.integral\nsage: from sage.symbolic.operators import FDerivativeOperator\nsage: from sage.symbolic.ring import is_SymbolicVariable\nsage: type(sage.calculus.calculus.maxima)\n<type 'sage.misc.lazy_import.LazyImport'>\n```\nThis could just be a stale `LazyImport` proxy, but it's not. Note the runtime needed to compute the hash for the first time. This is indicating the ecl initialization is only run then.\n\n```\nsage: %time hash(sage.calculus.calculus.maxima)\nCPU times: user 0.77 s, sys: 0.02 s, total: 0.79 s\nWall time: 0.80 s\n-7971541566211231133\n```\nThe symbol is now resolved and indeed, hash is instantaneous:\n\n```\nsage: type(sage.calculus.calculus.maxima)\n<class 'sage.interfaces.maxima_lib.MaximaLib'>\nsage: %time hash(sage.calculus.calculus.maxima)\nCPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s\nWall time: 0.00 s\n-7971541566211231133\n```\nThere are stale lazyimport proxies lying around:\n\n```\nsage: type(maxima_calculus)\n<type 'sage.misc.lazy_import.LazyImport'>\nsage: hash(maxima_calculus)\n-7971541566211231133\nsage: type(maxima_calculus)\n<type 'sage.misc.lazy_import.LazyImport'>\n```\nThat's now #16522",
    "created_at": "2014-06-23T22:29:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16520",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16520#issuecomment-212817",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:4'></a>I noticed these executed at runtime (as opposed to module initialization time):

```
+ from sage.rings.rational import Rational
+ from sage.rings.number_field.number_field_element_quadratic import NumberFieldElement_quadratic
+ if isinstance(obj, Rational):
```
That's bad, because these are global assignments. You don't want to do those
again and again. Also, I find it hard to believe that those two modules somehow
refer back to `maxima_lib`.

The following runs at module initialization time anyway. I don't see how `from
...` makes this better than `import sage.symbolic.pynac`. It's not critical, so
I don't really care, apart from the fact that the namespace gets an extra
unnecessary symbol `symbol_table`.

```
+from sage.symbolic.pynac import symbol_table
+max_to_pynac_table = symbol_table['maxima']
```

In general, I have trouble seeing how `maxima_lib` can lead to circular imports,
because `maxima_lib` is an interface and as such gets referenced by virtually
no-one. The only place is `sage.calculus.calculus` and I've very carefully made
sure we don't reference that. Furthermore, even there it's imported lazily, and
for very good reason: Importing `maxima_lib` initializes `ecl` with `maxima`
which takes considerable time.

So I suspect it's not so much a circular import but a bad interaction between
the lazy import of `maxima_lib` and the attempted lazy import of
`hypergeometric`. The proper solution is probably to *not* lazily import
hypergeometric into maxima_lib, but import it plainly there. By the time you're
importing maxima_lib you're already committed to significant initialization
time, so unless hypergeometric does something really strange, I don't expect it
will have a significant effect.

TL;DR: I'm not convinced that this ticket is actually solving a real problem.

*addition:* I think the following gives a strong indication that `maxima_lib` does not have a circular import. The following is supposed to be a complete list of the imports done in `maxima_lib`. A circular import would imply that one of those imports leads to importing `maxima_lib`, which means the `LazyImport` should resolve:

```
sage: from sage.symbolic.ring import SR, var
sage: from sage.interfaces.maxima_abstract import (MaximaAbstract, MaximaAbstractFunction,
....:   MaximaAbstractElement, MaximaAbstractFunctionElement,
....:   MaximaAbstractElementFunction)
sage: import sage.rings.real_double
sage: import sage.symbolic.expression
sage: import sage.functions.trig
sage: import sage.functions.log
sage: import sage.functions.other
sage: import sage.symbolic.integration.integral
sage: from sage.symbolic.operators import FDerivativeOperator
sage: from sage.symbolic.ring import is_SymbolicVariable
sage: type(sage.calculus.calculus.maxima)
<type 'sage.misc.lazy_import.LazyImport'>
```
This could just be a stale `LazyImport` proxy, but it's not. Note the runtime needed to compute the hash for the first time. This is indicating the ecl initialization is only run then.

```
sage: %time hash(sage.calculus.calculus.maxima)
CPU times: user 0.77 s, sys: 0.02 s, total: 0.79 s
Wall time: 0.80 s
-7971541566211231133
```
The symbol is now resolved and indeed, hash is instantaneous:

```
sage: type(sage.calculus.calculus.maxima)
<class 'sage.interfaces.maxima_lib.MaximaLib'>
sage: %time hash(sage.calculus.calculus.maxima)
CPU times: user 0.00 s, sys: 0.00 s, total: 0.00 s
Wall time: 0.00 s
-7971541566211231133
```
There are stale lazyimport proxies lying around:

```
sage: type(maxima_calculus)
<type 'sage.misc.lazy_import.LazyImport'>
sage: hash(maxima_calculus)
-7971541566211231133
sage: type(maxima_calculus)
<type 'sage.misc.lazy_import.LazyImport'>
```
That's now #16522



---

archive/issue_comments_212818.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-06-24T09:00:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16520",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16520#issuecomment-212818",
    "user": "https://github.com/rwst"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_212819.json:
```json
{
    "body": "<a id='comment:5'></a>Thanks for your thorough review. I assume this one can be closed as invalid then.",
    "created_at": "2014-06-24T09:00:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16520",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16520#issuecomment-212819",
    "user": "https://github.com/rwst"
}
```

<a id='comment:5'></a>Thanks for your thorough review. I assume this one can be closed as invalid then.



---

archive/issue_events_048521.json:
```json
{
    "actor": "https://github.com/rwst",
    "created_at": "2014-06-24T09:00:21Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16520",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16520#event-48521"
}
```



---

archive/issue_events_048522.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-06-24T14:14:27Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/16520",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16520#event-48522"
}
```



---

archive/issue_comments_212820.json:
```json
{
    "body": "Resolution: duplicate",
    "created_at": "2014-06-24T14:14:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16520",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16520#issuecomment-212820",
    "user": "https://github.com/vbraun"
}
```

Resolution: duplicate
