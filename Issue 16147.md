# Issue 16147: Multiplication of additive semigroup elements by integers

Issue created by migration from Trac.

Original creator: nthiery

Original creation time: 2014-05-21 10:18:28

CC:  sage-combinat ncohen jdemeyer




---

Comment by kcrisman created at 2014-05-22 02:05:28

Congratulations on ticket `2^14`!


---

Comment by nthiery created at 2014-05-23 22:31:56

The current implementation more or less works. However, given the usage of an action and the current implementation of actions, this will probably leak memory if a lot additive semigroups are temporarily constructed. There are also some failing tests.

Still, reviewing the rest can start.
----
Last 10 new commits:


---

Comment by nthiery created at 2014-05-23 22:39:27

Replying to [comment:2 kcrisman]:
> Congratulations on ticket `2^14`!

Yippee :-)


---

Comment by vdelecroix created at 2014-05-28 09:33:54

Hi there,

how much time before ticket `2^15` ?

Why `__mul__` and `__rmul__` are implemented in the category and not in `element.pyx` like it is done for `ModuleElement` ? It is confusing and moreover, it is the kind of methods that must be fast.

Vincent


---

Comment by nthiery created at 2014-05-28 15:39:24

Replying to [comment:7 vdelecroix]:
> how much time before ticket `2^15` ?

Given the acceleration, it might not be that long :-)

> Why `__mul__` and `__rmul__` are implemented in the category and not in `element.pyx` like it is done for `ModuleElement` ? It is confusing and moreover, it is the kind of methods that must be fast.

Because, due to the single inheritance limitation of Cython classes,
the hierarchy of element classes in element.pyx is extremely limited,
and will ever be. For example, there can be no class for elements of
an additive magma. Well, there could be one, but RingElement could not
inherit from it and from MonoidElement at the same time.

The `*Element` hierarchy of classes is really only there to cover a
few very common cases (elements of rings, ...) where speed can be
critical. And we should only put there those methods where speed is
critical. Note that the `__mul__` method implemented there take
precedence over there counterparts in the categories.

That being said, thanks to relatively recent progress in Cython, it's
now possible to define a cython function and make it a method of a
Python class/category by assigning it there (example courtesy of
Robert Bradshaw):


```
%cython

import cython
`@`cython.binding
def foo(*args):
    print args

class A:
    x = foo
a = A()
print a.x(1, 2, 3)
```


With this, we still pay the price of a method call, but the execution
of the method itself is fast. We could explore the use of this for the
critical methods of categories.

Cheers,
                                 Nicolas
