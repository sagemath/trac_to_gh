# Issue 16147: Multiplication of additive semigroup elements by integers

archive/issues_016147.json:
```json
{
    "body": "CC:  sage-combinat ncohen jdemeyer\n\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/16384\n\n",
    "created_at": "2014-05-21T10:18:28Z",
    "labels": [
        "categories",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.4",
    "title": "Multiplication of additive semigroup elements by integers",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16147",
    "user": "nthiery"
}
```
CC:  sage-combinat ncohen jdemeyer



Issue created by migration from https://trac.sagemath.org/ticket/16384





---

archive/issue_comments_210797.json:
```json
{
    "body": "Congratulations on ticket `2^14`!",
    "created_at": "2014-05-22T02:05:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16147",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16147#issuecomment-210797",
    "user": "kcrisman"
}
```

Congratulations on ticket `2^14`!



---

archive/issue_comments_210798.json:
```json
{
    "body": "The current implementation more or less works. However, given the usage of an action and the current implementation of actions, this will probably leak memory if a lot additive semigroups are temporarily constructed. There are also some failing tests.\n\nStill, reviewing the rest can start.\n----\nLast 10 new commits:",
    "created_at": "2014-05-23T22:31:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16147",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16147#issuecomment-210798",
    "user": "nthiery"
}
```

The current implementation more or less works. However, given the usage of an action and the current implementation of actions, this will probably leak memory if a lot additive semigroups are temporarily constructed. There are also some failing tests.

Still, reviewing the rest can start.
----
Last 10 new commits:



---

archive/issue_comments_210799.json:
```json
{
    "body": "Replying to [comment:2 kcrisman]:\n> Congratulations on ticket `2^14`!\n\nYippee :-)",
    "created_at": "2014-05-23T22:39:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16147",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16147#issuecomment-210799",
    "user": "nthiery"
}
```

Replying to [comment:2 kcrisman]:
> Congratulations on ticket `2^14`!

Yippee :-)



---

archive/issue_comments_210800.json:
```json
{
    "body": "Hi there,\n\nhow much time before ticket `2^15` ?\n\nWhy `__mul__` and `__rmul__` are implemented in the category and not in `element.pyx` like it is done for `ModuleElement` ? It is confusing and moreover, it is the kind of methods that must be fast.\n\nVincent",
    "created_at": "2014-05-28T09:33:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16147",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16147#issuecomment-210800",
    "user": "vdelecroix"
}
```

Hi there,

how much time before ticket `2^15` ?

Why `__mul__` and `__rmul__` are implemented in the category and not in `element.pyx` like it is done for `ModuleElement` ? It is confusing and moreover, it is the kind of methods that must be fast.

Vincent



---

archive/issue_comments_210801.json:
```json
{
    "body": "Replying to [comment:7 vdelecroix]:\n> how much time before ticket `2^15` ?\n\nGiven the acceleration, it might not be that long :-)\n\n> Why `__mul__` and `__rmul__` are implemented in the category and not in `element.pyx` like it is done for `ModuleElement` ? It is confusing and moreover, it is the kind of methods that must be fast.\n\nBecause, due to the single inheritance limitation of Cython classes,\nthe hierarchy of element classes in element.pyx is extremely limited,\nand will ever be. For example, there can be no class for elements of\nan additive magma. Well, there could be one, but RingElement could not\ninherit from it and from MonoidElement at the same time.\n\nThe `*Element` hierarchy of classes is really only there to cover a\nfew very common cases (elements of rings, ...) where speed can be\ncritical. And we should only put there those methods where speed is\ncritical. Note that the `__mul__` method implemented there take\nprecedence over there counterparts in the categories.\n\nThat being said, thanks to relatively recent progress in Cython, it's\nnow possible to define a cython function and make it a method of a\nPython class/category by assigning it there (example courtesy of\nRobert Bradshaw):\n\n\n```\n%cython\n\nimport cython\n@cython.binding\ndef foo(*args):\n    print args\n\nclass A:\n    x = foo\na = A()\nprint a.x(1, 2, 3)\n```\n\n\nWith this, we still pay the price of a method call, but the execution\nof the method itself is fast. We could explore the use of this for the\ncritical methods of categories.\n\nCheers,\n                                 Nicolas",
    "created_at": "2014-05-28T15:39:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16147",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16147#issuecomment-210801",
    "user": "nthiery"
}
```

Replying to [comment:7 vdelecroix]:
> how much time before ticket `2^15` ?

Given the acceleration, it might not be that long :-)

> Why `__mul__` and `__rmul__` are implemented in the category and not in `element.pyx` like it is done for `ModuleElement` ? It is confusing and moreover, it is the kind of methods that must be fast.

Because, due to the single inheritance limitation of Cython classes,
the hierarchy of element classes in element.pyx is extremely limited,
and will ever be. For example, there can be no class for elements of
an additive magma. Well, there could be one, but RingElement could not
inherit from it and from MonoidElement at the same time.

The `*Element` hierarchy of classes is really only there to cover a
few very common cases (elements of rings, ...) where speed can be
critical. And we should only put there those methods where speed is
critical. Note that the `__mul__` method implemented there take
precedence over there counterparts in the categories.

That being said, thanks to relatively recent progress in Cython, it's
now possible to define a cython function and make it a method of a
Python class/category by assigning it there (example courtesy of
Robert Bradshaw):


```
%cython

import cython
@cython.binding
def foo(*args):
    print args

class A:
    x = foo
a = A()
print a.x(1, 2, 3)
```


With this, we still pay the price of a method call, but the execution
of the method itself is fast. We could explore the use of this for the
critical methods of categories.

Cheers,
                                 Nicolas
