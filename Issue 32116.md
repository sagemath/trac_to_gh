# Issue 32116: Guide for parents with mutable elements

Issue created by migration from https://trac.sagemath.org/ticket/32353

Original creator: klee

Original creation time: 2021-08-10 02:00:44

CC:  @kliem @mjungmath tscrim egourgoulhon

This ticket aims to solve the issue that arose in the thread

https://groups.google.com/g/sage-devel/c/DNrbtItMVmQ

by implementing parents with mutable elements, which exist side by side with their immutable twin parents. 

The following table serves as a guide for the implementation:

In the table, elements on the left belongs to V; elements on the right to W.
|V=VectorSpace(R, 2, mutable=True)|new element  | W=VectorSpace(R, 2, mutable=False)| new element |
|:---------------------------------:|:-------------:|:-----------------------------------:|:-------------:|
| v, v                             |             | w, w'                              |             |
| v+v'                             | O           | w+w'                               |             |
| v+w, w+v                         | O           |                                    |             |
| V(v)                             | O           | W(w)                               | X           |
| V(w)                             | O           | W(v)                               | O           |
| V(0)                             | O           | W(0)                               | X           |
| V.zero()                         | O           | W.zero()                           | X           |
| V([2,3])                         | O           | W([2,3])                           | O           |
| vector(v)                        | O           | vector(w)                          | X           |
| vector(w)                        | O           | vector(v)                          | O           |
| vector(R, 2)                     | O           |                                    |             |
| vector(R, [2,3])                 | O           | vector(R, [2,3])                   | O           |
| copy(v)                          | O           | copy(w)                            | O           |
| v.mutable()                      | X           | w.immutable()                      | X           |
| w.mutable()                      | O           | v.immutable()                      | O           |
Most parents in Sage have immutable elements and hence don't accept `mutable` argument. Parents that accept `mutable` argument defaults to `mutable=True`.

Parents that accept `mutable` argument are: VectorSpace, MatrixSpace, FreeModule, Graph


---

Comment by klee created at 2021-08-10 02:03:55

Changing component from PLEASE CHANGE to algebra.


---

Comment by klee created at 2021-08-10 02:03:55

Changing type from PLEASE CHANGE to enhancement.


---

Comment by klee created at 2021-08-10 02:09:36

Feel free to modify the table as needed.


---

Comment by klee created at 2021-08-10 02:13:48

`mutable_elements` would be better?


---

Comment by klee created at 2021-08-10 02:29:52

Perhaps we don't need `vector(R, [2,3], mutable=False)` if we can get the same vector by `vector(R, [2,3]).immutable()`.


---

Comment by nbruin created at 2021-08-10 02:50:58

Nice chart! Thanks. A few comments:
 - I'd be hesitant using `mutable` as an attribute on the parent for this. It can be mistaken for referring to the parent itself (which must be immutable in most cases). It's nice that it corresponds with the keyword on `vector`, though (where `mutable` is definitely fine), so perhaps we can live with it. Alternatives like `mutable_elements` or `mutable_vectors` look verbose and painful.
 - I'd expect `vector(R,[2,3]).immutable()` to return an immutable copy. The keyword on the constructor is to imply that `set_immutable()` is called on it. A passthrough function like

```
def imm(v):
    v.setImmutable()
    return v
```

would do the trick, but at the expense of violating the (soft) principle that routines with side-effects should normally return `None`.


---

Comment by klee created at 2021-08-10 04:16:00

Replying to [comment:12 nbruin]:
> I'd be hesitant using `mutable` as an attribute on the parent for this. It can be mistaken for referring to the parent itself (which must be immutable in most cases). It's nice that it corresponds with the keyword on `vector`, though (where `mutable` is definitely fine), so perhaps we can live with it. Alternatives like `mutable_elements` or `mutable_vectors` look verbose and painful.

So your conclusion is ... to live with `mutable`? `mutable_vectors` is not an alternative since we want one consistent keyword for both VectorSpace and MatrixSpace. `mutable_elts` is a bit shorter alternative. 


>  - I'd expect `vector(R,[2,3]).immutable()` to return an immutable copy. 

Yes.

> The keyword on the constructor is to imply that `set_immutable()` is called on it. 

You are referring to `vector(R, [2,3], mutable=False)`? I think this first retrieves W and then construct an element of W. So this would be more efficient than `vector(R, [2,3]).immutable()`, which first constructs a vector in V and then convert it to an element of W. 

Here I am getting confused between switching immutability flag for a vector and changing its parent between V and W...

> A passthrough function like
> {{{
> def imm(v):
>     v.setImmutable()
>     return v
> }}}
> would do the trick, but at the expense of violating the (soft) principle that routines with side-effects should normally return `None`.

If you want, perhaps we can have both (method and function).


---

Comment by nbruin created at 2021-08-10 04:49:51

Replying to [comment:13 klee]:
> You are referring to `vector(R, [2,3], mutable=False)`? I think this first retrieves W and then construct an element of W. So this would be more efficient than `vector(R, [2,3]).immutable()`, which first constructs a vector in V and then convert it to an element of W. 
> 
> Here I am getting confused between switching immutability flag for a vector and changing its parent between V and W...

I don't think the proposal (up to now) included switching parents based on whether an element is immutable or not. The way I understand it, `V` can have elements that are mutable as well as elements that are immutable. That's the state of affairs now, and I don't think we'd want to change that without a good reason.

As far as I'm concerned, `W` can also have elements of either mutability state. However, elements in W would by default be immutable, and then they cannot change. However, `W._element_constructor([1,2,3],mutable=True)` could just return a mutable element. I think we're just trying to specify the behaviour of `W.element_constructor` if a `mutable` optional parameter is not given. In that case, the "default" setting should take effect, and that is where V and W and different.

I'm pretty sure we should not be changing the parent of `v` when executing `v.set_immutable()`.


---

Comment by klee created at 2021-08-10 05:16:46

Replying to [comment:14 nbruin]:
> However, `W._element_constructor([1,2,3],mutable=True)` could just return a mutable element. 

So the returned vector is a mutable element of `W`? Then the last line of the chart is wrong. 

How about the third? How would `v+w` or `w+v` behave?


---

Comment by nbruin created at 2021-08-10 06:40:50

Replying to [comment:15 klee]:
> Replying to [comment:14 nbruin]:
> > However, `W._element_constructor([1,2,3],mutable=True)` could just return a mutable element. 
> 
> So the returned vector is a mutable element of `W`? Then the last line of the chart is wrong. 

Yes, or an error, depending on whether "immutable_elt" parents still allow mutable elements as well. It would be strange to get an element with parent V if you just explicitly asked for an element with parent W. So I'd say the last line in the chart is indeed wrong.

What the parent of `vector(R, [2,3])` should be is really up for grabs. Perhaps indeed take as cue that whatever the "mutable" flag says should be the default on the parent (so that, say, a scalar multiple of the vector again has the property as prescribed)

> How about the third? How would `v+w` or `w+v` behave?

That's the stickiest. This is for the coercion system to decide. Ideally, there is a coercion arrow in only one direction (so: mutable coerces into immutable or vice versa, but not both). Then there is only one choice that the coercion system can come up with.


---

Comment by klee created at 2021-08-10 08:02:31

Replying to [comment:16 nbruin]:
> That's the stickiest. This is for the coercion system to decide. Ideally, there is a coercion arrow in only one direction (so: mutable coerces into immutable or vice versa, but not both). Then there is only one choice that the coercion system can come up with.

I feel that this mutable/immutable dual parents idea will not mix well with the current immutability flags for individual vectors.  

To work out the idea of this ticket, I would rather redefine `set_immutable()` as a method that changes the parent from V to W, and I would define a coercion map from W to V. I guess this may be implemented without serious performance penalty.


---

Comment by nbruin created at 2021-08-10 16:13:55

Replying to [comment:17 klee]:
> I feel that this mutable/immutable dual parents idea will not mix well with the current immutability flags for individual vectors.  
> 
> To work out the idea of this ticket, I would rather redefine `set_immutable()` as a method that changes the parent from V to W, and I would define a coercion map from W to V. I guess this may be implemented without serious performance penalty.

You can definitely do this, but it would be a much more comprehensive rewrite and one with much more serious impact on the rest of sage (and on existing code). If elements being mutable or not is a property of the parent rather than of the element, and the changing of mutability status is accomplished by changing the parent on the object itself, then it would seem the most natural arrow would exist from V to W. It would mean that for v in V and w in W, the result v+w would lie in W and (as a side effect!) that afterwards v now lies in w too. This makes it quite efficient to add mutable and immutable vectors, but makes immutability quite infectious.

One could also stipulate that coercion goes from V to W but that coercion does make a copy. In that case computing v+w is more expensive, the result lies in W, and afterwards v still lies in V. In that case, `v.set_immutable()` can be defined to "mutate" the vector into an element of W.

If coercion goes from W to V then the expensive route is the only option. "Expensive" here really means "a cost that is fully expected". Normally, coercion does make a copy. It's just that we have more vector spaces with the proposal here.

I think the reality is that the practical proposal of "immutability on demand" -- set an element to immutable when it is requested, for instance if its hash is asked -- will win out because it's easier to implement and less disruptive to existing code: it only changes behaviour in cases that are currently an error (although, with pervasive try/except clauses in python, changing when an error is raised can be more disruptive than you think)


---

Comment by klee created at 2021-08-11 01:39:40

Replying to [comment:18 nbruin]:

> Normally, coercion does make a copy. It's just that we have more vector spaces with the proposal here.

Currently V is the default. Hence to make coercion less frequent, I think the coercion should go from W to V. Why is it natural going from V to W?

> I think the reality is that the practical proposal of "immutability on demand" -- set an element to immutable when it is requested, for instance if its hash is asked -- will win out because it's easier to implement and less disruptive to existing code: it only changes behaviour in cases that are currently an error (although, with pervasive try/except clauses in python, changing when an error is raised can be more disruptive than you think)

I am ok, actually prefer to live with one mutable vector space and just to have `vector.immutable()` to explicitly demand v set immutable.


---

Comment by @mjungmath created at 2021-08-11 10:25:43

Notice that the tensor/manifolds module usually provides mutable elements by default. That is because bases (frames) can be added dynamically and give different expressions.
