# Issue 24694: py3: get rid of __cmp__ in real_mpfr.pyx

Issue created by migration from Trac.

Original creator: chapoton

Original creation time: 2018-03-08 19:50:01

Keywords: python3, richcmp

part of #16537


---

Comment by chapoton created at 2018-03-08 19:50:35

Changing status from new to needs_review.


---

Comment by chapoton created at 2018-03-08 19:50:35

New commits:


---

Comment by tscrim created at 2018-03-08 23:16:04

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2018-03-08 23:16:04

LGTM.


---

Comment by chapoton created at 2018-03-09 07:34:36

Changing status from positive_review to needs_work.


---

Comment by chapoton created at 2018-03-09 07:34:36

Hmm, I suspect that one doctest is failing...


---

Comment by jdemeyer created at 2018-03-09 09:23:15

Some comments from #24930 apply here too.

And it seems that the `__richcmp__` is really only meant to check for equality, so I would add

```
if op != Py_EQ and op != Py_NE:
    return NotImplemented
```



---

Comment by embray created at 2018-03-09 10:49:23

Indeed. I don't think you even need the full `__richcmp__`.  I implemented this just as an `__eq__`, but for that to work requires Cython 0.28 or a patched Cython.


---

Comment by embray created at 2018-03-09 10:50:25

I have:


```diff
diff --git a/src/sage/rings/real_mpfr.pyx b/src/sage/rings/real_mpfr.pyx
index 91d8ad1..e13efa0 100644
--- a/src/sage/rings/real_mpfr.pyx
+++ b/src/sage/rings/real_mpfr.pyx
`@``@` -737,7 +738,7 `@``@` cdef class RealField_class(sage.rings.ring.Field):
             return self.convert_method_map(S, "_mpfr_")
         return self._coerce_map_via([RLF], S)

-    def __cmp__(self, other):
+    def __eq__(self, other):
         """
         Compare two real fields, returning ``True`` if they are equivalent
         and ``False`` if they are not.
`@``@` -748,13 +749,13 `@``@` cdef class RealField_class(sage.rings.ring.Field):
             False
             sage: RealField(10) == RealField(10)
             True
-            sage: RealField(10,rnd='RNDN') == RealField(10,rnd='RNDZ')
+            sage: RealField(10, rnd='RNDN') == RealField(10, rnd='RNDZ')
             False

         Scientific notation affects only printing, not mathematically how
         the field works, so this does not affect equality testing::

-            sage: RealField(10,sci_not=True) == RealField(10,sci_not=False)
+            sage: RealField(10, sci_not=True) == RealField(10, sci_not=False)
             True
             sage: RealField(10) == IntegerRing()
             False
`@``@` -769,13 +770,11 `@``@` cdef class RealField_class(sage.rings.ring.Field):
             True
         """
         if not isinstance(other, RealField_class):
-            return -1
+            return False
+
         cdef RealField_class _other
         _other = other  # to access C structure
-        if self.__prec == _other.__prec and self.rnd == _other.rnd: \
-               #and self.sci_not == _other.sci_not:
-            return 0
-        return 1
+        return self.__prec == _other.__prec and self.rnd == _other.rnd
```



---

Comment by jdemeyer created at 2018-03-09 10:52:24

Replying to [comment:5 embray]:
> Indeed. I don't think you even need the full `__richcmp__`.  I implemented this just as an `__eq__`, but for that to work requires Cython 0.28 or a patched Cython.

FYI: Cython 0.28 is in beta now (#24111).


---

Comment by git created at 2018-03-09 18:30:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2018-03-09 18:31:34

Changing status from needs_work to needs_review.


---

Comment by embray created at 2018-03-12 15:32:07

Changing status from needs_review to needs_work.


---

Comment by embray created at 2018-03-12 15:32:07

It doesn't make sense to use `rich_to_bool` here at all.  All you need is 
`return (self.__prec == _other.__prec and self.rnd == _other.rnd) == (op == Py_EQ)`


---

Comment by git created at 2018-03-13 07:21:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2018-03-13 07:40:47

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2018-03-13 07:40:47

thanks, done


---

Comment by embray created at 2018-03-13 11:48:55

Right now you have:


```python
if not isinstance(other, RealField_class):
    return NotImplemented
```


which I think was Jeroen's suggestion.  The reason for this is that it will delegate comparison to the class of the right-side object if it is not an instance of `RealField_class`.  So that sort of makes sense.  But I'm concerned about making that the general approach.  

For example, the tests contain:


```
    sage: RealField(10) == IntegerRing()
    False
```


which currently will work.  But why, then, isn't the same logic applied in `IntegerRing`?  Currently its `__richcmp__` is (somewhat arbitrarily?) implemented rather differently:


```python
    def __richcmp__(left, right, int op):
        """
        Rich comparison of ``left`` and ``right``.

        TESTS::

            sage: from sage.rings.integer_ring import IntegerRing_class
            sage: ZZ == ZZ
            True
            sage: ZZ != QQ
            True
        """
        if left is right:
            return rich_to_bool(op, 0)

        if isinstance(right, IntegerRing_class):
            return rich_to_bool(op, 0)

        if isinstance(right, sage.rings.rational_field.RationalField):
            return rich_to_bool(op, -1)

        return op == Py_NE
```


That sort of grew out of the old implementation of `IntegerRing_class._cmp_`, but I don't think this is really right either.  Just as in the case of `RealField_class`, this seems to mostly just care about equality (though it seems it should also return less than `RationalField`? What's that about?).

If `IntegerRing_class.__richcmp__` also contained something like `if not isinstance(right, IntegerRing_class): return NotImplemented`, and then you attempted the aforementioned comparison, instead of a boolean result you'll get a `TypeError` exception.

So my question becomes, should a class always delegate rich comparison to the other object, and if not when should it and when shouldn't it?


---

Comment by embray created at 2018-03-13 12:35:25

Replying to [comment:13 embray]: 
> If `IntegerRing_class.__richcmp__` also contained something like `if not isinstance(right, IntegerRing_class): return NotImplemented`, and then you attempted the aforementioned comparison, instead of a boolean result you'll get a `TypeError` exception.


I'm sorry, I was wrong here (though I cannot for the life of me find where this is actually documented).  If both `a.__eq__(b)` and `b.__eq__(a)` return `NotImplemented`, then Python falls back on the default comparison which is by `id()`.  I think that's also the case (in reverse) for `__ne__`.  It's only in the case of the ordering operators where it raises `TypeError`.

I think that clarifies things for me then.  We should probably change `IntegerRing_class.__richcmp__` to be more consistent, but this is fine as is.

Every time I think I understand Python's rich comparison it turns out I've forgotten half of what I'd learned.


---

Comment by chapoton created at 2018-03-13 12:49:19

so, positive review ?


---

Comment by jdemeyer created at 2018-03-13 13:04:02

Replying to [comment:14 embray]:
> Every time I think I understand Python's rich comparison it turns out I've forgotten half of what I'd learned.

Maybe it's also because it works quite different in Python 2 and Python 3?


---

Comment by jdemeyer created at 2018-03-13 13:05:27

Changing status from needs_review to positive_review.


---

Comment by embray created at 2018-03-13 13:43:49

Replying to [comment:16 jdemeyer]:
> Replying to [comment:14 embray]:
> > Every time I think I understand Python's rich comparison it turns out I've forgotten half of what I'd learned.
> 
> Maybe it's also because it works quite different in Python 2 and Python 3?

It does, and it's hard to keep straight.  I thought the fallback behavior for equality, for example, was only on Python 2 (when in fact I was probably just thinking about the fallback for ordered comparisons).


---

Comment by vbraun created at 2018-03-22 19:23:33

Resolution: fixed
