# Issue 14589: Unique representation for homsets

archive/issues_014589.json:
```json
{
    "body": "Assignee: @nthiery\n\nCC:  sage-combinat simonking jpflori\n\nThe unique representation of homsets is taken care of by ``Hom``. What's missing is:\n\n- Fast hash and comparison by id. This can be implemented by having Homset inherit from WithEqualityById \n- Pickling by construction, calling back Hom(domain, codomain, category)\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/14793\n\n",
    "closed_at": "2014-03-03T18:55:31Z",
    "created_at": "2013-06-21T09:04:00Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.2",
    "title": "Unique representation for homsets",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14589",
    "user": "https://github.com/nthiery"
}
```
Assignee: @nthiery

CC:  sage-combinat simonking jpflori

The unique representation of homsets is taken care of by ``Hom``. What's missing is:

- Fast hash and comparison by id. This can be implemented by having Homset inherit from WithEqualityById 
- Pickling by construction, calling back Hom(domain, codomain, category)


Issue created by migration from https://trac.sagemath.org/ticket/14793





---

archive/issue_comments_185163.json:
```json
{
    "body": "To discuss: the exact semantic for homsets of non unique parents",
    "created_at": "2013-06-21T09:06:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185163",
    "user": "https://github.com/nthiery"
}
```

To discuss: the exact semantic for homsets of non unique parents



---

archive/issue_comments_185164.json:
```json
{
    "body": "Observation: If one uses `WithEqualityById`, many tests in sage.modular and sage.schemes fail with unprintable assertion errors.\n\nWe need to discuss whether we \"simply\" fix them, or better continue to compare homsets by *equality* (not identity) of domain and codomain.\n\nIn other words, we might end up with just providing a default pickling for homsets, which is currently missing.",
    "created_at": "2013-06-21T09:29:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185164",
    "user": "https://github.com/simon-king-jena"
}
```

Observation: If one uses `WithEqualityById`, many tests in sage.modular and sage.schemes fail with unprintable assertion errors.

We need to discuss whether we "simply" fix them, or better continue to compare homsets by *equality* (not identity) of domain and codomain.

In other words, we might end up with just providing a default pickling for homsets, which is currently missing.



---

archive/issue_comments_185165.json:
```json
{
    "body": "When using `WithEqualityByid` and a default `__reduce__` method, we'd get (sorted by \"section\"):\n\nSchemes:\n\n```\nsage -t sage/schemes/elliptic_curves/padic_lseries.py  # 1 doctest failed\nsage -t sage/schemes/elliptic_curves/ell_curve_isogeny.py  # 18 doctests failed\nsage -t sage/schemes/elliptic_curves/ell_point.py  # 8 doctests failed\nsage -t sage/schemes/elliptic_curves/ell_finite_field.py  # 1 doctest failed\nsage -t sage/schemes/projective/projective_space.py  # 2 doctests failed\nsage -t sage/schemes/elliptic_curves/isogeny_class.py  # 1 doctest failed\nsage -t sage/schemes/affine/affine_space.py  # 1 doctest failed\nsage -t sage/schemes/generic/homset.py  # 2 doctests failed\n```\n\nModular:\n\n```\nsage -t sage/modular/local_comp/local_comp.py  # 5 doctests failed\nsage -t sage/modular/abvar/abvar.py  # 2 doctests failed\nsage -t sage/modular/hecke/submodule.py  # 1 doctest failed\nsage -t sage/modular/abvar/homspace.py  # 1 doctest failed\nsage -t sage/modular/modsym/subspace.py  # 2 doctests failed\nsage -t sage/modular/hecke/ambient_module.py  # 1 doctest failed\nsage -t sage/modular/abvar/finite_subgroup.py  # 2 doctests failed\nsage -t sage/modular/modform/cuspidal_submodule.py  # 1 doctest failed\nsage -t sage/modular/abvar/homology.py  # 2 doctests failed\nsage -t sage/modular/abvar/abvar_newform.py  # 1 doctest failed\nsage -t sage/modular/abvar/cuspidal_subgroup.py  # 2 doctests failed\nsage -t sage/modular/hecke/degenmap.py  # 1 doctest failed\nsage -t sage/modular/modsym/element.py  # 1 doctest failed\nsage -t sage/modular/hecke/homspace.py  # 1 doctest failed\nsage -t sage/modular/abvar/lseries.py  # 2 doctests failed\nsage -t sage/modular/hecke/morphism.py  # 1 doctest failed\n```\n\nRings:\n\n```\nsage -t sage/rings/morphism.pyx  # 7 doctests failed\nsage -t sage/rings/quotient_ring.py  # 1 doctest failed\nsage -t sage/rings/finite_rings/homset.py  # 3 doctests failed\nsage -t sage/rings/number_field/morphism.py  # 4 doctests failed\nsage -t sage/rings/homset.py  # 2 doctests failed\n```\n\nModules\n\n```\nsage -t sage/modules/fg_pid/fgp_morphism.py  # 4 doctests failed\nsage -t sage/modules/quotient_module.py  # 2 doctests failed\nsage -t sage/modules/vector_space_homspace.py  # 1 doctest failed\n```\n\nOthers:\n\n```\nsage -t sage/doctest/forker.py  # 1 doctest failed\nsage -t sage/doctest/control.py  # 1 doctest failed\nsage -t sage/structure/parent.pyx  # 1 doctest failed\nsage -t sage/categories/hecke_modules.py  # 1 doctest failed\nsage -t sage/homology/simplicial_complex_homset.py  # 1 doctest failed\n```\n\nGetting failures in sage/doctest seems amazing.\n\nWhat to do?",
    "created_at": "2013-06-21T10:08:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185165",
    "user": "https://github.com/simon-king-jena"
}
```

When using `WithEqualityByid` and a default `__reduce__` method, we'd get (sorted by "section"):

Schemes:

```
sage -t sage/schemes/elliptic_curves/padic_lseries.py  # 1 doctest failed
sage -t sage/schemes/elliptic_curves/ell_curve_isogeny.py  # 18 doctests failed
sage -t sage/schemes/elliptic_curves/ell_point.py  # 8 doctests failed
sage -t sage/schemes/elliptic_curves/ell_finite_field.py  # 1 doctest failed
sage -t sage/schemes/projective/projective_space.py  # 2 doctests failed
sage -t sage/schemes/elliptic_curves/isogeny_class.py  # 1 doctest failed
sage -t sage/schemes/affine/affine_space.py  # 1 doctest failed
sage -t sage/schemes/generic/homset.py  # 2 doctests failed
```

Modular:

```
sage -t sage/modular/local_comp/local_comp.py  # 5 doctests failed
sage -t sage/modular/abvar/abvar.py  # 2 doctests failed
sage -t sage/modular/hecke/submodule.py  # 1 doctest failed
sage -t sage/modular/abvar/homspace.py  # 1 doctest failed
sage -t sage/modular/modsym/subspace.py  # 2 doctests failed
sage -t sage/modular/hecke/ambient_module.py  # 1 doctest failed
sage -t sage/modular/abvar/finite_subgroup.py  # 2 doctests failed
sage -t sage/modular/modform/cuspidal_submodule.py  # 1 doctest failed
sage -t sage/modular/abvar/homology.py  # 2 doctests failed
sage -t sage/modular/abvar/abvar_newform.py  # 1 doctest failed
sage -t sage/modular/abvar/cuspidal_subgroup.py  # 2 doctests failed
sage -t sage/modular/hecke/degenmap.py  # 1 doctest failed
sage -t sage/modular/modsym/element.py  # 1 doctest failed
sage -t sage/modular/hecke/homspace.py  # 1 doctest failed
sage -t sage/modular/abvar/lseries.py  # 2 doctests failed
sage -t sage/modular/hecke/morphism.py  # 1 doctest failed
```

Rings:

```
sage -t sage/rings/morphism.pyx  # 7 doctests failed
sage -t sage/rings/quotient_ring.py  # 1 doctest failed
sage -t sage/rings/finite_rings/homset.py  # 3 doctests failed
sage -t sage/rings/number_field/morphism.py  # 4 doctests failed
sage -t sage/rings/homset.py  # 2 doctests failed
```

Modules

```
sage -t sage/modules/fg_pid/fgp_morphism.py  # 4 doctests failed
sage -t sage/modules/quotient_module.py  # 2 doctests failed
sage -t sage/modules/vector_space_homspace.py  # 1 doctest failed
```

Others:

```
sage -t sage/doctest/forker.py  # 1 doctest failed
sage -t sage/doctest/control.py  # 1 doctest failed
sage -t sage/structure/parent.pyx  # 1 doctest failed
sage -t sage/categories/hecke_modules.py  # 1 doctest failed
sage -t sage/homology/simplicial_complex_homset.py  # 1 doctest failed
```

Getting failures in sage/doctest seems amazing.

What to do?



---

archive/issue_comments_185166.json:
```json
{
    "body": "Just a crazy idea (brain storm):\n\nWe do not want `WithEqualityById` by default, because it makes no sense to have Homset be a unique parent, if domain and codomain are no unique parents.\n\nHowever, if both domain and codomain are unique parents, it *is* a good idea to use `WithEqualityById`.\n\nSo, we could check whether both domain and codomain inherit from `UniqueRepresentation`. If they do, then they are unique parents, and then we could create a dynamic class out of `WithEqualityById` and the class of the homset, and overload the `__class__` of the homset.\n\nIn that way, we would automatically have fast homset comparison and hash, for those parts of sage that use unique representation.\n\nI am running tests with an according patch now...",
    "created_at": "2013-06-21T10:41:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185166",
    "user": "https://github.com/simon-king-jena"
}
```

Just a crazy idea (brain storm):

We do not want `WithEqualityById` by default, because it makes no sense to have Homset be a unique parent, if domain and codomain are no unique parents.

However, if both domain and codomain are unique parents, it *is* a good idea to use `WithEqualityById`.

So, we could check whether both domain and codomain inherit from `UniqueRepresentation`. If they do, then they are unique parents, and then we could create a dynamic class out of `WithEqualityById` and the class of the homset, and overload the `__class__` of the homset.

In that way, we would automatically have fast homset comparison and hash, for those parts of sage that use unique representation.

I am running tests with an according patch now...



---

archive/issue_comments_185167.json:
```json
{
    "body": "With what I described in my previous post, I get these errors.\n\n\n```\nsage -t sage/schemes/elliptic_curves/padic_lseries.py  # 1 doctest failed\nsage -t sage/schemes/elliptic_curves/ell_point.py  # 8 doctests failed\nsage -t sage/schemes/generic/homset.py  # 1 doctest failed\nsage -t sage/schemes/elliptic_curves/ell_curve_isogeny.py  # 8 doctests failed\nsage -t sage/schemes/elliptic_curves/ell_finite_field.py  # 1 doctest failed\nsage -t sage/schemes/elliptic_curves/isogeny_class.py  # 1 doctest failed\nsage -t sage/schemes/projective/projective_space.py  # 2 doctests failed\nsage -t sage/schemes/affine/affine_space.py  # 1 doctest failed\n```\n\nModular:\n\n```\nsage -t sage/modular/hecke/morphism.py  # 1 doctest failed\nsage -t sage/modular/modsym/element.py  # 1 doctest failed\nsage -t sage/modules/quotient_module.py  # 2 doctests failed\nsage -t sage/modular/abvar/lseries.py  # 2 doctests failed\nsage -t sage/modular/abvar/homology.py  # 2 doctests failed\nsage -t sage/modular/abvar/abvar_newform.py  # 1 doctest failed\nsage -t sage/modular/abvar/cuspidal_subgroup.py  # 2 doctests failed\nsage -t sage/modular/abvar/finite_subgroup.py  # 2 doctests failed\nsage -t sage/modular/modform/cuspidal_submodule.py  # 1 doctest failed\nsage -t sage/modular/abvar/abvar.py  # 2 doctests failed\nsage -t sage/modular/local_comp/local_comp.py  # 5 doctests failed\nsage -t sage/modular/hecke/submodule.py  # 1 doctest failed\nsage -t sage/modular/abvar/homspace.py  # 1 doctest failed\nsage -t sage/modular/modsym/subspace.py  # 2 doctests failed\nsage -t sage/modular/hecke/ambient_module.py  # 1 doctest failed\nsage -t sage/modular/hecke/degenmap.py  # 1 doctest failed\n```\n\nand others:\n\n```\nsage -t sage/structure/parent.pyx  # 1 doctest failed\nsage -t sage/rings/quotient_ring.py  # 1 doctest failed\nsage -t sage/modules/fg_pid/fgp_morphism.py  # 3 doctests failed\nsage -t sage/rings/morphism.pyx  # 3 doctests failed\nsage -t sage/rings/homset.py  # 1 doctest failed\n```\n\nAre these less than before?",
    "created_at": "2013-06-21T12:09:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185167",
    "user": "https://github.com/simon-king-jena"
}
```

With what I described in my previous post, I get these errors.


```
sage -t sage/schemes/elliptic_curves/padic_lseries.py  # 1 doctest failed
sage -t sage/schemes/elliptic_curves/ell_point.py  # 8 doctests failed
sage -t sage/schemes/generic/homset.py  # 1 doctest failed
sage -t sage/schemes/elliptic_curves/ell_curve_isogeny.py  # 8 doctests failed
sage -t sage/schemes/elliptic_curves/ell_finite_field.py  # 1 doctest failed
sage -t sage/schemes/elliptic_curves/isogeny_class.py  # 1 doctest failed
sage -t sage/schemes/projective/projective_space.py  # 2 doctests failed
sage -t sage/schemes/affine/affine_space.py  # 1 doctest failed
```

Modular:

```
sage -t sage/modular/hecke/morphism.py  # 1 doctest failed
sage -t sage/modular/modsym/element.py  # 1 doctest failed
sage -t sage/modules/quotient_module.py  # 2 doctests failed
sage -t sage/modular/abvar/lseries.py  # 2 doctests failed
sage -t sage/modular/abvar/homology.py  # 2 doctests failed
sage -t sage/modular/abvar/abvar_newform.py  # 1 doctest failed
sage -t sage/modular/abvar/cuspidal_subgroup.py  # 2 doctests failed
sage -t sage/modular/abvar/finite_subgroup.py  # 2 doctests failed
sage -t sage/modular/modform/cuspidal_submodule.py  # 1 doctest failed
sage -t sage/modular/abvar/abvar.py  # 2 doctests failed
sage -t sage/modular/local_comp/local_comp.py  # 5 doctests failed
sage -t sage/modular/hecke/submodule.py  # 1 doctest failed
sage -t sage/modular/abvar/homspace.py  # 1 doctest failed
sage -t sage/modular/modsym/subspace.py  # 2 doctests failed
sage -t sage/modular/hecke/ambient_module.py  # 1 doctest failed
sage -t sage/modular/hecke/degenmap.py  # 1 doctest failed
```

and others:

```
sage -t sage/structure/parent.pyx  # 1 doctest failed
sage -t sage/rings/quotient_ring.py  # 1 doctest failed
sage -t sage/modules/fg_pid/fgp_morphism.py  # 3 doctests failed
sage -t sage/rings/morphism.pyx  # 3 doctests failed
sage -t sage/rings/homset.py  # 1 doctest failed
```

Are these less than before?



---

archive/issue_comments_185168.json:
```json
{
    "body": "Let's look at the errors more closely:\n\n```\nsage -t sage/modular/hecke/morphism.py\n**********************************************************************\nFile \"sage/modular/hecke/morphism.py\", line 110, in sage.modular.hecke.morphism.HeckeModuleMorphism_matrix.__init__\nFailed example:\n    t == loads(dumps(t))\nException raised:\n    Traceback (most recent call last):\n      File \"/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 486, in _run\n        self.execute(example, compiled, test.globs)\n      File \"/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 845, in execute\n        exec compiled in globs\n      File \"<doctest sage.modular.hecke.morphism.HeckeModuleMorphism_matrix.__init__[2]>\", line 1, in <module>\n        t == loads(dumps(t))\n      File \"sage_object.pyx\", line 1236, in sage.structure.sage_object.loads (build/cythonized/sage/structure/sage_object.c:11044)\n      File \"/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/homset.py\", line 291, in Hom\n        cat_X = X.category()\n      File \"module.pyx\", line 45, in sage.modules.module.Module_old.category (build/cythonized/sage/modules/module.c:1501)\n      File \"classcall_metaclass.pyx\", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1224)\n      File \"/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/modules.py\", line 108, in __classcall_private__\n        result = super(Modules, cls).__classcall__(cls, base_ring)\n      File \"/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category.py\", line 468, in __classcall__\n        return super(Category, cls).__classcall__(cls, *args, **options)\n      File \"cachefunc.pyx\", line 992, in sage.misc.cachefunc.WeakCachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5394)\n      File \"/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/unique_representation.py\", line 447, in __classcall__\n        instance = typecall(cls, *args, **options)\n      File \"classcall_metaclass.pyx\", line 518, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:1586)\n      File \"/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category_types.py\", line 326, in __init__\n        assert base in Rings(), \"base must be a ring\"\n    AssertionError: <unprintable AssertionError object>\n**********************************************************************\n1 item had failures:\n   1 of   4 in sage.modular.hecke.morphism.HeckeModuleMorphism_matrix.__init__\n    [19 tests, 1 failure, 0.23 s]\n----------------------------------------------------------------------\nsage -t sage/modular/hecke/morphism.py  # 1 doctest failed\n----------------------------------------------------------------------\nTotal time for all tests: 0.3 seconds\n    cpu time: 0.2 seconds\n    cumulative wall time: 0.2 seconds\n```\nand this actually looks like it is due to the `__reduce__` method, not due to the `WithEqualityById`.",
    "created_at": "2013-06-21T12:18:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185168",
    "user": "https://github.com/simon-king-jena"
}
```

Let's look at the errors more closely:

```
sage -t sage/modular/hecke/morphism.py
**********************************************************************
File "sage/modular/hecke/morphism.py", line 110, in sage.modular.hecke.morphism.HeckeModuleMorphism_matrix.__init__
Failed example:
    t == loads(dumps(t))
Exception raised:
    Traceback (most recent call last):
      File "/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 486, in _run
        self.execute(example, compiled, test.globs)
      File "/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 845, in execute
        exec compiled in globs
      File "<doctest sage.modular.hecke.morphism.HeckeModuleMorphism_matrix.__init__[2]>", line 1, in <module>
        t == loads(dumps(t))
      File "sage_object.pyx", line 1236, in sage.structure.sage_object.loads (build/cythonized/sage/structure/sage_object.c:11044)
      File "/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/homset.py", line 291, in Hom
        cat_X = X.category()
      File "module.pyx", line 45, in sage.modules.module.Module_old.category (build/cythonized/sage/modules/module.c:1501)
      File "classcall_metaclass.pyx", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1224)
      File "/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/modules.py", line 108, in __classcall_private__
        result = super(Modules, cls).__classcall__(cls, base_ring)
      File "/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category.py", line 468, in __classcall__
        return super(Category, cls).__classcall__(cls, *args, **options)
      File "cachefunc.pyx", line 992, in sage.misc.cachefunc.WeakCachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5394)
      File "/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/unique_representation.py", line 447, in __classcall__
        instance = typecall(cls, *args, **options)
      File "classcall_metaclass.pyx", line 518, in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:1586)
      File "/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category_types.py", line 326, in __init__
        assert base in Rings(), "base must be a ring"
    AssertionError: <unprintable AssertionError object>
**********************************************************************
1 item had failures:
   1 of   4 in sage.modular.hecke.morphism.HeckeModuleMorphism_matrix.__init__
    [19 tests, 1 failure, 0.23 s]
----------------------------------------------------------------------
sage -t sage/modular/hecke/morphism.py  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 0.3 seconds
    cpu time: 0.2 seconds
    cumulative wall time: 0.2 seconds
```
and this actually looks like it is due to the `__reduce__` method, not due to the `WithEqualityById`.



---

archive/issue_comments_185169.json:
```json
{
    "body": "Interesting! This\n\n```\n            sage: M = ModularSymbols(6)\n            sage: t = M.Hom(M)(matrix(QQ,3,3,srange(9)), name=\"spam\"); t\n            Hecke module morphism spam defined by the matrix\n            [0 1 2]\n            [3 4 5]\n            [6 7 8]\n            Domain: Modular Symbols space of dimension 3 for Gamma_0(6) of weight ...\n            Codomain: Modular Symbols space of dimension 3 for Gamma_0(6) of weight ...\n            sage: t == loads(dumps(t))\n            True\n```\nworks on the command line, but fails in a doctest. :-/",
    "created_at": "2013-06-21T12:22:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185169",
    "user": "https://github.com/simon-king-jena"
}
```

Interesting! This

```
            sage: M = ModularSymbols(6)
            sage: t = M.Hom(M)(matrix(QQ,3,3,srange(9)), name="spam"); t
            Hecke module morphism spam defined by the matrix
            [0 1 2]
            [3 4 5]
            [6 7 8]
            Domain: Modular Symbols space of dimension 3 for Gamma_0(6) of weight ...
            Codomain: Modular Symbols space of dimension 3 for Gamma_0(6) of weight ...
            sage: t == loads(dumps(t))
            True
```
works on the command line, but fails in a doctest. :-/



---

archive/issue_comments_185170.json:
```json
{
    "body": "I think I've hit this one before when working on homsets. Perhaps I'll find my old solution somewhere.",
    "created_at": "2013-06-21T12:26:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185170",
    "user": "https://github.com/simon-king-jena"
}
```

I think I've hit this one before when working on homsets. Perhaps I'll find my old solution somewhere.



---

archive/issue_comments_185171.json:
```json
{
    "body": "No, I did not find the solution.\n\nThe problem seems to be that the modular symbols space M is pickled the *OLD* python way, hence, its `__dict__` is pickled. When M is unpickled, some homspace accessible from an attribute of M is unpickled. Codomain and domain of this homspace happen to be M --- and if the Hom function is called with an uninitialised version of M, then stuff fails.\n\nSolution: Provide a \"proper\" pickling for modular symbols.\nProblem: I don't understand the modular symbols code.",
    "created_at": "2013-06-21T13:08:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185171",
    "user": "https://github.com/simon-king-jena"
}
```

No, I did not find the solution.

The problem seems to be that the modular symbols space M is pickled the *OLD* python way, hence, its `__dict__` is pickled. When M is unpickled, some homspace accessible from an attribute of M is unpickled. Codomain and domain of this homspace happen to be M --- and if the Hom function is called with an uninitialised version of M, then stuff fails.

Solution: Provide a "proper" pickling for modular symbols.
Problem: I don't understand the modular symbols code.



---

archive/issue_comments_185172.json:
```json
{
    "body": "If I recall correctly, people do explicitly not want to use a cache (such as: `UniqueRepresentation`) on modular symbols. They have some cache, but make a point of being able to disable it.\n\nHere is a minimal example, that fails when using a proper `__reduce__` method for homsets:\n\n```\n            sage: sage.modular.hecke.morphism.is_HeckeModuleMorphism_matrix(ModularSymbols(6).hecke_operator(7).matrix_form().hecke_module_morphism())\n            True\n            sage: M = ModularSymbols(6)\n            sage: t = M.Hom(M)(matrix(QQ,3,3,srange(9)), name=\"spam\"); t\n            Hecke module morphism spam defined by the matrix\n            [0 1 2]\n            [3 4 5]\n            [6 7 8]\n            Domain: Modular Symbols space of dimension 3 for Gamma_0(6) of weight ...\n            Codomain: Modular Symbols space of dimension 3 for Gamma_0(6) of weight ...\n            sage: t == loads(dumps(t))\n            True\n```\nThe first line actually is important. With the first line, we get this error in the last line:\n\n```\nTraceback (most recent call last)\n<ipython-input-11-a4f55210dece> in <module>()\n----> 1 t == loads(dumps(t))\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/sage_object.so in sage.structure.sage_object.loads (build/cythonized/sage/structure/sage_object.c:11044)()\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/homset.pyc in Hom(X, Y, category)\n    289 \n    290     # Determines the category\n--> 291     cat_X = X.category()\n    292     cat_Y = Y.category()\n    293     if category is None:\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/modules/module.so in sage.modules.module.Module_old.category (build/cythonized/sage/modules/module.c:1501)()\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1224)()                                                                                                                                                                                 \n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/modules.pyc in __classcall_private__(cls, base_ring, dispatch)\n    106             if base_ring in _Fields:\n    107                 return VectorSpaces(base_ring, check=False)\n--> 108         result = super(Modules, cls).__classcall__(cls, base_ring)\n    109         result._reduction[2]['dispatch'] = False\n    110         return result\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category.pyc in __classcall__(cls, *args, **options)\n    466         if isinstance(cls, DynamicMetaclass):\n    467             cls = cls.__base__\n--> 468         return super(Category, cls).__classcall__(cls, *args, **options)\n    469 \n    470     def __init__(self, s=None):\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/cachefunc.so in sage.misc.cachefunc.WeakCachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5394)()\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/unique_representation.pyc in __classcall__(cls, *args, **options)\n    445 \n    446         \"\"\"\n--> 447         instance = typecall(cls, *args, **options)\n    448         assert isinstance( instance, cls )\n    449         if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:1586)()                                                                                                                                                                                                    \n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category_types.pyc in __init__(self, base, name)\n    324     def __init__(self, base, name=None):\n    325         from sage.categories.rings import Rings\n--> 326         assert base in Rings(), \"base must be a ring\"\n    327         Category_over_base.__init__(self, base, name)\n    328 \n\n<type 'str'>: (<type 'exceptions.AttributeError'>, AttributeError('ModularSymbolsAmbient_wt2_g0_with_category' object has no attribute '_HeckeModule_generic__level',))\n```\n\nHooray, we have a reproducible failure.",
    "created_at": "2013-06-21T16:45:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185172",
    "user": "https://github.com/simon-king-jena"
}
```

If I recall correctly, people do explicitly not want to use a cache (such as: `UniqueRepresentation`) on modular symbols. They have some cache, but make a point of being able to disable it.

Here is a minimal example, that fails when using a proper `__reduce__` method for homsets:

```
            sage: sage.modular.hecke.morphism.is_HeckeModuleMorphism_matrix(ModularSymbols(6).hecke_operator(7).matrix_form().hecke_module_morphism())
            True
            sage: M = ModularSymbols(6)
            sage: t = M.Hom(M)(matrix(QQ,3,3,srange(9)), name="spam"); t
            Hecke module morphism spam defined by the matrix
            [0 1 2]
            [3 4 5]
            [6 7 8]
            Domain: Modular Symbols space of dimension 3 for Gamma_0(6) of weight ...
            Codomain: Modular Symbols space of dimension 3 for Gamma_0(6) of weight ...
            sage: t == loads(dumps(t))
            True
```
The first line actually is important. With the first line, we get this error in the last line:

```
Traceback (most recent call last)
<ipython-input-11-a4f55210dece> in <module>()
----> 1 t == loads(dumps(t))

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/sage_object.so in sage.structure.sage_object.loads (build/cythonized/sage/structure/sage_object.c:11044)()

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/homset.pyc in Hom(X, Y, category)
    289 
    290     # Determines the category
--> 291     cat_X = X.category()
    292     cat_Y = Y.category()
    293     if category is None:

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/modules/module.so in sage.modules.module.Module_old.category (build/cythonized/sage/modules/module.c:1501)()

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1224)()                                                                                                                                                                                 

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/modules.pyc in __classcall_private__(cls, base_ring, dispatch)
    106             if base_ring in _Fields:
    107                 return VectorSpaces(base_ring, check=False)
--> 108         result = super(Modules, cls).__classcall__(cls, base_ring)
    109         result._reduction[2]['dispatch'] = False
    110         return result

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category.pyc in __classcall__(cls, *args, **options)
    466         if isinstance(cls, DynamicMetaclass):
    467             cls = cls.__base__
--> 468         return super(Category, cls).__classcall__(cls, *args, **options)
    469 
    470     def __init__(self, s=None):

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/cachefunc.so in sage.misc.cachefunc.WeakCachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5394)()

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/unique_representation.pyc in __classcall__(cls, *args, **options)
    445 
    446         """
--> 447         instance = typecall(cls, *args, **options)
    448         assert isinstance( instance, cls )
    449         if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:1586)()                                                                                                                                                                                                    

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category_types.pyc in __init__(self, base, name)
    324     def __init__(self, base, name=None):
    325         from sage.categories.rings import Rings
--> 326         assert base in Rings(), "base must be a ring"
    327         Category_over_base.__init__(self, base, name)
    328 

<type 'str'>: (<type 'exceptions.AttributeError'>, AttributeError('ModularSymbolsAmbient_wt2_g0_with_category' object has no attribute '_HeckeModule_generic__level',))
```

Hooray, we have a reproducible failure.



---

archive/issue_comments_185173.json:
```json
{
    "body": "Better:\n\n```\nsage: sage.modular.hecke.morphism.is_HeckeModuleMorphism_matrix(ModularSymbols(6).hecke_operator(7).matrix_form().hecke_module_morphism())\nTrue\nsage: M = ModularSymbols(6)\nsage: loads(dumps(M)) is M\nTraceback (most recent call last)\n<ipython-input-3-7b45a005bcab> in <module>()\n----> 1 loads(dumps(M)) is M\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/sage_object.so in sage.structure.sage_object.loads (build/cythonized/sage/structure/sage_object.c:11044)()\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/homset.pyc in Hom(X, Y, category)\n    289 \n    290     # Determines the category\n--> 291     cat_X = X.category()\n    292     cat_Y = Y.category()\n    293     if category is None:\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/modules/module.so in sage.modules.module.Module_old.category (build/cythonized/sage/modules/module.c:1501)()\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1224)()                                                                                                                                                                                 \n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/modules.pyc in __classcall_private__(cls, base_ring, dispatch)\n    106             if base_ring in _Fields:\n    107                 return VectorSpaces(base_ring, check=False)\n--> 108         result = super(Modules, cls).__classcall__(cls, base_ring)\n    109         result._reduction[2]['dispatch'] = False\n    110         return result\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category.pyc in __classcall__(cls, *args, **options)\n    466         if isinstance(cls, DynamicMetaclass):\n    467             cls = cls.__base__\n--> 468         return super(Category, cls).__classcall__(cls, *args, **options)\n    469 \n    470     def __init__(self, s=None):\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/cachefunc.so in sage.misc.cachefunc.WeakCachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5394)()\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/unique_representation.pyc in __classcall__(cls, *args, **options)\n    445 \n    446         \"\"\"\n--> 447         instance = typecall(cls, *args, **options)\n    448         assert isinstance( instance, cls )\n    449         if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:\n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:1586)()                                                                                                                                                                                                    \n\n/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category_types.pyc in __init__(self, base, name)\n    324     def __init__(self, base, name=None):\n    325         from sage.categories.rings import Rings\n--> 326         assert base in Rings(), \"base must be a ring\"\n    327         Category_over_base.__init__(self, base, name)\n    328 \n\n<type 'str'>: (<type 'exceptions.AttributeError'>, AttributeError('ModularSymbolsAmbient_wt2_g0_with_category' object has no attribute '_HeckeModule_generic__level',))\n```\n\nSo, this should be analysable.",
    "created_at": "2013-06-21T16:49:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185173",
    "user": "https://github.com/simon-king-jena"
}
```

Better:

```
sage: sage.modular.hecke.morphism.is_HeckeModuleMorphism_matrix(ModularSymbols(6).hecke_operator(7).matrix_form().hecke_module_morphism())
True
sage: M = ModularSymbols(6)
sage: loads(dumps(M)) is M
Traceback (most recent call last)
<ipython-input-3-7b45a005bcab> in <module>()
----> 1 loads(dumps(M)) is M

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/sage_object.so in sage.structure.sage_object.loads (build/cythonized/sage/structure/sage_object.c:11044)()

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/homset.pyc in Hom(X, Y, category)
    289 
    290     # Determines the category
--> 291     cat_X = X.category()
    292     cat_Y = Y.category()
    293     if category is None:

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/modules/module.so in sage.modules.module.Module_old.category (build/cythonized/sage/modules/module.c:1501)()

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (build/cythonized/sage/misc/classcall_metaclass.c:1224)()                                                                                                                                                                                 

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/modules.pyc in __classcall_private__(cls, base_ring, dispatch)
    106             if base_ring in _Fields:
    107                 return VectorSpaces(base_ring, check=False)
--> 108         result = super(Modules, cls).__classcall__(cls, base_ring)
    109         result._reduction[2]['dispatch'] = False
    110         return result

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category.pyc in __classcall__(cls, *args, **options)
    466         if isinstance(cls, DynamicMetaclass):
    467             cls = cls.__base__
--> 468         return super(Category, cls).__classcall__(cls, *args, **options)
    469 
    470     def __init__(self, s=None):

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/cachefunc.so in sage.misc.cachefunc.WeakCachedFunction.__call__ (build/cythonized/sage/misc/cachefunc.c:5394)()

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/structure/unique_representation.pyc in __classcall__(cls, *args, **options)
    445 
    446         """
--> 447         instance = typecall(cls, *args, **options)
    448         assert isinstance( instance, cls )
    449         if instance.__class__.__reduce__ == CachedRepresentation.__reduce__:

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/misc/classcall_metaclass.so in sage.misc.classcall_metaclass.typecall (build/cythonized/sage/misc/classcall_metaclass.c:1586)()                                                                                                                                                                                                    

/home/simon/SAGE/prerelease/sage-5.10.rc1/local/lib/python2.7/site-packages/sage/categories/category_types.pyc in __init__(self, base, name)
    324     def __init__(self, base, name=None):
    325         from sage.categories.rings import Rings
--> 326         assert base in Rings(), "base must be a ring"
    327         Category_over_base.__init__(self, base, name)
    328 

<type 'str'>: (<type 'exceptions.AttributeError'>, AttributeError('ModularSymbolsAmbient_wt2_g0_with_category' object has no attribute '_HeckeModule_generic__level',))
```

So, this should be analysable.



---

archive/issue_comments_185174.json:
```json
{
    "body": "Here is the problem and a potential solution.\n\nWhile unpickling of the modular symbols M, we need to construct a homset with domain and codomain M. At this point, calling M.category() results in an error, since M.base() returns None and M.category() wants to return Modules(M.base()).\n\nHence, in the code of the Hom function from sage.categories.homset, the lines\n\n```python\n            cat_X = X.category()\n            cat_Y = Y.category()\n```\ncrash.\n\nThe point is: When Hom is called in the process of unpickling a homset, then the correct category is supplied. Hence, the argument \"category\" of Hom is not None. And I think if in this situation `X.category()` raises an error then we can simply ignore the error and skip the consistency check `cat_X.is_subcategory(category)`.\n\nHence, I'd do:\n\n```\n    if category is None:\n        category = X.category()._meet_(Y.category())\n        # Recurse to make sure that Hom(X, Y) and Hom(X, Y, category) are identical\n        H = Hom(X, Y, category)\n    else:\n        # while unpickling, it is possible that the\n        # categories of X and Y are not initialised\n        # and a default category can't be determined.\n        # Since cat_X/Y.is_subcategory(category) is just\n        # a sanity check anyway, we will ignore an error\n        # that is raised when determining cat_X/cat_Y\n        if not isinstance(category, Category):\n            raise TypeError, \"Argument category (= %s) must be a category.\"%category\n        try:\n            cat_X = X.category()\n        except BaseException:\n            cat_X = category\n        try:\n            cat_Y = Y.category()\n        except BaseException:\n            cat_Y = category\n        if not cat_X.is_subcategory(category):\n            raise TypeError, \"%s is not in %s\"%(X, category)\n        if not cat_Y.is_subcategory(category):\n            raise TypeError, \"%s is not in %s\"%(Y, category)\n\n        # Construct H\n        try: # _Hom_ hook from the parent\n            H = X._Hom_(Y, category)\n...\n```\n\nDo you think this is a feasible idea?",
    "created_at": "2013-06-21T21:11:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185174",
    "user": "https://github.com/simon-king-jena"
}
```

Here is the problem and a potential solution.

While unpickling of the modular symbols M, we need to construct a homset with domain and codomain M. At this point, calling M.category() results in an error, since M.base() returns None and M.category() wants to return Modules(M.base()).

Hence, in the code of the Hom function from sage.categories.homset, the lines

```python
            cat_X = X.category()
            cat_Y = Y.category()
```
crash.

The point is: When Hom is called in the process of unpickling a homset, then the correct category is supplied. Hence, the argument "category" of Hom is not None. And I think if in this situation `X.category()` raises an error then we can simply ignore the error and skip the consistency check `cat_X.is_subcategory(category)`.

Hence, I'd do:

```
    if category is None:
        category = X.category()._meet_(Y.category())
        # Recurse to make sure that Hom(X, Y) and Hom(X, Y, category) are identical
        H = Hom(X, Y, category)
    else:
        # while unpickling, it is possible that the
        # categories of X and Y are not initialised
        # and a default category can't be determined.
        # Since cat_X/Y.is_subcategory(category) is just
        # a sanity check anyway, we will ignore an error
        # that is raised when determining cat_X/cat_Y
        if not isinstance(category, Category):
            raise TypeError, "Argument category (= %s) must be a category."%category
        try:
            cat_X = X.category()
        except BaseException:
            cat_X = category
        try:
            cat_Y = Y.category()
        except BaseException:
            cat_Y = category
        if not cat_X.is_subcategory(category):
            raise TypeError, "%s is not in %s"%(X, category)
        if not cat_Y.is_subcategory(category):
            raise TypeError, "%s is not in %s"%(Y, category)

        # Construct H
        try: # _Hom_ hook from the parent
            H = X._Hom_(Y, category)
...
```

Do you think this is a feasible idea?



---

archive/issue_comments_185175.json:
```json
{
    "body": "Replying to [comment:12 SimonKing]:\n> Here is the problem and a potential solution.\n> \n> While unpickling of the modular symbols M, we need to construct a homset with domain and codomain M. At this point, calling M.category() results in an error, since M.base() returns None and M.category() wants to return Modules(M.base()).\n\n\nIs `None` ever a valid value for `M.base()`? At this point, is there enough information available on `M` to derive what `base()` should return? In that case, I'd think the cleanest way would be to make `base()` a caching routine: return a stored value if available and otherwise derive the correct value, store it, and return that. Whenever someone asks for `base` they're probably not interested in an invalid value. Or is computing `base` possibly expensive and not really necessary for the unpickling?\n\n[...]\n> Do you think this is a feasible idea?\n\nIf you can't easily fix the category determination then, yes. However, what you're proposing is a hack, so solving it properly should really be preferred. (Other people more knowledgeable on category stuff will probably have a more informed opinion than this generic remark)",
    "created_at": "2013-06-22T09:28:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185175",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:12 SimonKing]:
> Here is the problem and a potential solution.
> 
> While unpickling of the modular symbols M, we need to construct a homset with domain and codomain M. At this point, calling M.category() results in an error, since M.base() returns None and M.category() wants to return Modules(M.base()).


Is `None` ever a valid value for `M.base()`? At this point, is there enough information available on `M` to derive what `base()` should return? In that case, I'd think the cleanest way would be to make `base()` a caching routine: return a stored value if available and otherwise derive the correct value, store it, and return that. Whenever someone asks for `base` they're probably not interested in an invalid value. Or is computing `base` possibly expensive and not really necessary for the unpickling?

[...]
> Do you think this is a feasible idea?

If you can't easily fix the category determination then, yes. However, what you're proposing is a hack, so solving it properly should really be preferred. (Other people more knowledgeable on category stuff will probably have a more informed opinion than this generic remark)



---

archive/issue_comments_185176.json:
```json
{
    "body": "Replying to [comment:13 nbruin]:\n> > While unpickling of the modular symbols M, we need to construct a homset with domain and codomain M. At this point, calling M.category() results in an error, since M.base() returns None and M.category() wants to return Modules(M.base()).\n\n> \n> Is `None` ever a valid value for `M.base()`?\n\n\nI don't know if it is valid, but at least it is easily possible to get None:\n\n```\nsage: Parent().base() is None\nTrue\n```\n\n> At this point, is there enough information available on `M` to derive what `base()` should return?\n\n\nI don't think so---unless modular symbols are *always* defined over the rationals. That's not my field of mathematical expertise.\n\n> In that case, I'd think the cleanest way would be to make `base()` a caching routine: return a stored value if available and otherwise derive the correct value, store it, and return that. Whenever someone asks for `base` they're probably not interested in an invalid value. Or is computing `base` possibly expensive and not really necessary for the unpickling?\n\n\n`base` is usually set when you call `Parent.__init__`.\n\nAnyway. If it is really the case that the base of modular symbols will always be the rational field, then it is fine.\n\nBest regards,\nSimon",
    "created_at": "2013-06-22T09:56:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185176",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:13 nbruin]:
> > While unpickling of the modular symbols M, we need to construct a homset with domain and codomain M. At this point, calling M.category() results in an error, since M.base() returns None and M.category() wants to return Modules(M.base()).

> 
> Is `None` ever a valid value for `M.base()`?


I don't know if it is valid, but at least it is easily possible to get None:

```
sage: Parent().base() is None
True
```

> At this point, is there enough information available on `M` to derive what `base()` should return?


I don't think so---unless modular symbols are *always* defined over the rationals. That's not my field of mathematical expertise.

> In that case, I'd think the cleanest way would be to make `base()` a caching routine: return a stored value if available and otherwise derive the correct value, store it, and return that. Whenever someone asks for `base` they're probably not interested in an invalid value. Or is computing `base` possibly expensive and not really necessary for the unpickling?


`base` is usually set when you call `Parent.__init__`.

Anyway. If it is really the case that the base of modular symbols will always be the rational field, then it is fine.

Best regards,
Simon



---

archive/issue_comments_185177.json:
```json
{
    "body": "Not good. The documentation states:\n\n```\n    - ``base_ring`` - the base ring. Defaults to `\\QQ` if no character\n      is given, or to the minimal extension of `\\QQ` containing the\n      values of the character.\n```\n\nI guess the *proper* solution would be to provide a `__reduce__` method for modular symbols. Since modular symbols come in many different flavours, this might be a bit awkward.",
    "created_at": "2013-06-22T10:10:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185177",
    "user": "https://github.com/simon-king-jena"
}
```

Not good. The documentation states:

```
    - ``base_ring`` - the base ring. Defaults to `\QQ` if no character
      is given, or to the minimal extension of `\QQ` containing the
      values of the character.
```

I guess the *proper* solution would be to provide a `__reduce__` method for modular symbols. Since modular symbols come in many different flavours, this might be a bit awkward.



---

archive/issue_comments_185178.json:
```json
{
    "body": "Perhaps the following idea works and is clean.\n\nWhat does Python currently do when unpickling a modular symbol? Well, it creates a new instance of the underlying class, and fills its `__dict__`.\n\nI guess it is possible to compute the base ring from the contents of the `__dict__` (need to find out how, but I am sure it is encoded there somewhere. Indeed, we have\n\n```\nsage: M = ModularSymbols(6)\nsage: M._ModularSymbolsSpace__character.base_ring()\nRational Field\nsage: M.base()\nRational Field\n```\n\nAnd that means, we could create an unpickling function doing the following, where dct is the `__dict__` and cls is the class of the modular symbol to be unpickled:\n\n```python\n    M = cls.__new__(cls)\n    ParentWithAdditiveAbelianGens.__init__(M,base=dct['_ModularSymbolsSpace__character'].base_ring(), category=Modules(dct['_ModularSymbolsSpace__character'].base_ring()))\n    M.__dict__ = copy(dct)\n    return M\n```\n\nWell, I will try it later...",
    "created_at": "2013-06-22T10:33:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185178",
    "user": "https://github.com/simon-king-jena"
}
```

Perhaps the following idea works and is clean.

What does Python currently do when unpickling a modular symbol? Well, it creates a new instance of the underlying class, and fills its `__dict__`.

I guess it is possible to compute the base ring from the contents of the `__dict__` (need to find out how, but I am sure it is encoded there somewhere. Indeed, we have

```
sage: M = ModularSymbols(6)
sage: M._ModularSymbolsSpace__character.base_ring()
Rational Field
sage: M.base()
Rational Field
```

And that means, we could create an unpickling function doing the following, where dct is the `__dict__` and cls is the class of the modular symbol to be unpickled:

```python
    M = cls.__new__(cls)
    ParentWithAdditiveAbelianGens.__init__(M,base=dct['_ModularSymbolsSpace__character'].base_ring(), category=Modules(dct['_ModularSymbolsSpace__character'].base_ring()))
    M.__dict__ = copy(dct)
    return M
```

Well, I will try it later...



---

archive/issue_comments_185179.json:
```json
{
    "body": "Replying to [comment:15 SimonKing]:\n\nAn example in the documentation:\n\n```\nsage: G = DirichletGroup(13,GF(4,'a'));\nsage: e = G.list()[2];\nsage: M = ModularSymbols(e,4);\nsage: M.base()\nFinite Field in a of size 2^2\nsage: M._ModularSymbolsSpace__character.base_ring()\nFinite Field in a of size 2^2\n```\nThe base ring can (in principle at least) be pretty much anything, and the way you're proposing to retrieve it seems to work OK (it seems the character is always there)",
    "created_at": "2013-06-22T21:13:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185179",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:15 SimonKing]:

An example in the documentation:

```
sage: G = DirichletGroup(13,GF(4,'a'));
sage: e = G.list()[2];
sage: M = ModularSymbols(e,4);
sage: M.base()
Finite Field in a of size 2^2
sage: M._ModularSymbolsSpace__character.base_ring()
Finite Field in a of size 2^2
```
The base ring can (in principle at least) be pretty much anything, and the way you're proposing to retrieve it seems to work OK (it seems the character is always there)



---

archive/issue_comments_185180.json:
```json
{
    "body": "Replying to [comment:17 nbruin]:\n> The base ring can (in principle at least) be pretty much anything, and the way you're proposing to retrieve it seems to work OK (it seems the character is always there)\n\n\nI'm afraid it does not work. The problem is: We need the homset to finish initialisation of the parent, and Python decides to try and create the homset rather early in the reconstruction of the parent. Hence, when we need the character or the base ring or any other information, it is simply not available yet.\n\nI tried to provide a `__reduce__` method for `HeckeModule_generic`, which solved the problem of pickling modular symbols. But then, a different problem arose: An infinite loop when pickling an abelian variety (to be precise: of `ModularAbelianVariety_modsym`). And it is not clear to me how to write a `__reduce__` method for abelian varieties such that the loop does not occur.\n\nProbable I should provide the code that I have so far. In about 24 hours, I guess...\n\nAnd a different approach: We should try to understand why\n\n```\nsage: M = ModularSymbols(6)\nsage: loads(dumps(M)) == M\nTrue\n```\nworks, while\n\n```\nsage: sage.modular.hecke.morphism.is_HeckeModuleMorphism_matrix(ModularSymbols(6).hecke_operator(7).matrix_form().hecke_module_morphism())\nTrue\nsage: M = ModularSymbols(6)\nsage: loads(dumps(M)) == M\nTrue\n```\ncrashes.",
    "created_at": "2013-06-22T22:29:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185180",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:17 nbruin]:
> The base ring can (in principle at least) be pretty much anything, and the way you're proposing to retrieve it seems to work OK (it seems the character is always there)


I'm afraid it does not work. The problem is: We need the homset to finish initialisation of the parent, and Python decides to try and create the homset rather early in the reconstruction of the parent. Hence, when we need the character or the base ring or any other information, it is simply not available yet.

I tried to provide a `__reduce__` method for `HeckeModule_generic`, which solved the problem of pickling modular symbols. But then, a different problem arose: An infinite loop when pickling an abelian variety (to be precise: of `ModularAbelianVariety_modsym`). And it is not clear to me how to write a `__reduce__` method for abelian varieties such that the loop does not occur.

Probable I should provide the code that I have so far. In about 24 hours, I guess...

And a different approach: We should try to understand why

```
sage: M = ModularSymbols(6)
sage: loads(dumps(M)) == M
True
```
works, while

```
sage: sage.modular.hecke.morphism.is_HeckeModuleMorphism_matrix(ModularSymbols(6).hecke_operator(7).matrix_form().hecke_module_morphism())
True
sage: M = ModularSymbols(6)
sage: loads(dumps(M)) == M
True
```
crashes.



---

archive/issue_comments_185181.json:
```json
{
    "body": "This works:\n\n```\nsage: M = ModularSymbols(6)\nsage: f = M.hecke_operator(7).matrix_form()\nsage: loads(dumps(M)) == M\nTrue\n```\nContinuing the example, this makes it fail:\n\n```\nsage: phi = f.hecke_module_morphism()\nsage: loads(dumps(M)) == M\nTraceback (most recent call last):\n...\n<type 'str'>: (<type 'exceptions.AttributeError'>, AttributeError('ModularSymbolsAmbient_wt2_g0_with_category' object has no attribute '_HeckeModule_generic__level',))\n```\nContinuing the example, this makes it work again:\n\n```\nsage: del M._HeckeModule_generic__hecke_algebra\nsage: loads(dumps(M)) == M\nTrue\n```\n\nHence, I think the following happens.\n\n- `s = dumps(M)` pickles the content of `M.__dict__`. `loads(s)` then starts with unpickling the stored content of `M.__dict__`, after creating a would-be-copy N of M, which is not initialised at this point (this is what Python does in those cases). The unpickled content of M.__dict__ would later be assigned to N.__dict__\n- The Hecke algebra of M is stored as an attribute of M. `Hom(M,M)` somehow becomes stored as an attribute of `M.hecke_algebra()` when calling `.hecke_module_morphism()`. Hence, when deleting the attribute containing `M.hecke_algebra()`, all is good.\n- When unpickling the content of `M.__dict__`, Python eventually tries to unpickle `Hom(M,M)`, but replaces M with its would-be-copy N. But since N is not initialised, `Hom(N,N)` fails.\n\nThis suggests a way out: We could implement \"proper\" unpickling of `M.hecke_algebra()`, so that `Hom(M,M)` will not be called prematurely.\n\nIt might also be a good idea to use `@`cached_method when a method is cached. Namely, I often see stuff like\n\n```python\n    def free_module(self):\n        \"\"\"\n        Return the free module underlying this ambient Hecke module (the\n        forgetful functor from Hecke modules to modules over the base ring)\n\n        EXAMPLE::\n\n            sage: ModularForms(59, 2).free_module()\n            Vector space of dimension 6 over Rational Field\n        \"\"\"\n        try:\n            return self.__free_module\n        except AttributeError:\n            M = sage.modules.all.FreeModule(self.base_ring(), self.rank())\n            self.__free_module = M\n            return M\n```\nwhich uses `__dict__` and hence will result in errors during unpickling.",
    "created_at": "2013-06-24T13:09:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185181",
    "user": "https://github.com/simon-king-jena"
}
```

This works:

```
sage: M = ModularSymbols(6)
sage: f = M.hecke_operator(7).matrix_form()
sage: loads(dumps(M)) == M
True
```
Continuing the example, this makes it fail:

```
sage: phi = f.hecke_module_morphism()
sage: loads(dumps(M)) == M
Traceback (most recent call last):
...
<type 'str'>: (<type 'exceptions.AttributeError'>, AttributeError('ModularSymbolsAmbient_wt2_g0_with_category' object has no attribute '_HeckeModule_generic__level',))
```
Continuing the example, this makes it work again:

```
sage: del M._HeckeModule_generic__hecke_algebra
sage: loads(dumps(M)) == M
True
```

Hence, I think the following happens.

- `s = dumps(M)` pickles the content of `M.__dict__`. `loads(s)` then starts with unpickling the stored content of `M.__dict__`, after creating a would-be-copy N of M, which is not initialised at this point (this is what Python does in those cases). The unpickled content of M.__dict__ would later be assigned to N.__dict__
- The Hecke algebra of M is stored as an attribute of M. `Hom(M,M)` somehow becomes stored as an attribute of `M.hecke_algebra()` when calling `.hecke_module_morphism()`. Hence, when deleting the attribute containing `M.hecke_algebra()`, all is good.
- When unpickling the content of `M.__dict__`, Python eventually tries to unpickle `Hom(M,M)`, but replaces M with its would-be-copy N. But since N is not initialised, `Hom(N,N)` fails.

This suggests a way out: We could implement "proper" unpickling of `M.hecke_algebra()`, so that `Hom(M,M)` will not be called prematurely.

It might also be a good idea to use `@`cached_method when a method is cached. Namely, I often see stuff like

```python
    def free_module(self):
        """
        Return the free module underlying this ambient Hecke module (the
        forgetful functor from Hecke modules to modules over the base ring)

        EXAMPLE::

            sage: ModularForms(59, 2).free_module()
            Vector space of dimension 6 over Rational Field
        """
        try:
            return self.__free_module
        except AttributeError:
            M = sage.modules.all.FreeModule(self.base_ring(), self.rank())
            self.__free_module = M
            return M
```
which uses `__dict__` and hence will result in errors during unpickling.



---

archive/issue_comments_185182.json:
```json
{
    "body": "Arrgh. The obvious approach\n\n```python\nclass HeckeAlgebra_base(sage.rings.commutative_algebra.CommutativeAlgebra):\n...\n    def __reduce__(self):\n        return HeckeAlgebra, (self.__M,)\n```\nfails, because again for unpickling the Hecke algebra, one needs that M is sufficiently initialised, because otherwise `HeckeAlgebra(M)` fails.",
    "created_at": "2013-06-24T13:14:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185182",
    "user": "https://github.com/simon-king-jena"
}
```

Arrgh. The obvious approach

```python
class HeckeAlgebra_base(sage.rings.commutative_algebra.CommutativeAlgebra):
...
    def __reduce__(self):
        return HeckeAlgebra, (self.__M,)
```
fails, because again for unpickling the Hecke algebra, one needs that M is sufficiently initialised, because otherwise `HeckeAlgebra(M)` fails.



---

archive/issue_comments_185183.json:
```json
{
    "body": "It is a can of worms. The problem will always arise under the following conditions:\n\n- We have `Homset.__reduce__` returning `Hom, (self._domain, self._codomain, self.__category)`\n- We have a parent X whose pickling is done via pickling `__dict__` using the default Python way\n- `Hom(X,X)` (or any other homset involving X) is stored in `X.__dict__`.\n\nIn this situation, unpickling X means that we have an uninitialised copy Y of X and want to call Hom(Y,Y).\n\nMy previous suggestion was: \"In Hom(X,Y,cat), if X.category() fails and cat is given, then trust that X will eventually become sufficiently initialised to see that X is in cat\".\n\nPerhaps a modified suggestion is better: \"In `Hom(X,Y,cat)`, if `X.category()` fails, then at least test `isinstance(X, cat.parent_class)`.\" This test is almost as good as `X in cat`, since the two tests are actually equivalent, unless a base ring is involved. **IF** a base ring is involved, then X is in cat up to a change of the base ring.\n\nDo you have a better suggestion? I really would not like to implement `__reduce__` methods everywhere in sage.schemes and sage.modular.",
    "created_at": "2013-06-24T15:20:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185183",
    "user": "https://github.com/simon-king-jena"
}
```

It is a can of worms. The problem will always arise under the following conditions:

- We have `Homset.__reduce__` returning `Hom, (self._domain, self._codomain, self.__category)`
- We have a parent X whose pickling is done via pickling `__dict__` using the default Python way
- `Hom(X,X)` (or any other homset involving X) is stored in `X.__dict__`.

In this situation, unpickling X means that we have an uninitialised copy Y of X and want to call Hom(Y,Y).

My previous suggestion was: "In Hom(X,Y,cat), if X.category() fails and cat is given, then trust that X will eventually become sufficiently initialised to see that X is in cat".

Perhaps a modified suggestion is better: "In `Hom(X,Y,cat)`, if `X.category()` fails, then at least test `isinstance(X, cat.parent_class)`." This test is almost as good as `X in cat`, since the two tests are actually equivalent, unless a base ring is involved. **IF** a base ring is involved, then X is in cat up to a change of the base ring.

Do you have a better suggestion? I really would not like to implement `__reduce__` methods everywhere in sage.schemes and sage.modular.



---

archive/issue_comments_185184.json:
```json
{
    "body": "PS: With the idea exposed in the previous post, the following previously failing examples would work:\n\n```\nage: M = ModularSymbols(6)\nsage: sage.modular.hecke.morphism.is_HeckeModuleMorphism_matrix(ModularSymbols(6).hecke_operator(7).matrix_form().hecke_module_morphism())\nTrue\nsage: loads(dumps(M)) == M\nTrue\nsage: A = J0(33)\nsage: D = A.decomposition(); D\n[\nSimple abelian subvariety 11a(1,33) of dimension 1 of J0(33),\nSimple abelian subvariety 11a(3,33) of dimension 1 of J0(33),\nSimple abelian subvariety 33a(1,33) of dimension 1 of J0(33)\n]\nsage: loads(dumps(D))\n[\nSimple abelian subvariety 11a(1,33) of dimension 1 of J0(33),\nSimple abelian subvariety 11a(3,33) of dimension 1 of J0(33),\nSimple abelian subvariety 33a(1,33) of dimension 1 of J0(33)\n]\n```",
    "created_at": "2013-06-24T15:32:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185184",
    "user": "https://github.com/simon-king-jena"
}
```

PS: With the idea exposed in the previous post, the following previously failing examples would work:

```
age: M = ModularSymbols(6)
sage: sage.modular.hecke.morphism.is_HeckeModuleMorphism_matrix(ModularSymbols(6).hecke_operator(7).matrix_form().hecke_module_morphism())
True
sage: loads(dumps(M)) == M
True
sage: A = J0(33)
sage: D = A.decomposition(); D
[
Simple abelian subvariety 11a(1,33) of dimension 1 of J0(33),
Simple abelian subvariety 11a(3,33) of dimension 1 of J0(33),
Simple abelian subvariety 33a(1,33) of dimension 1 of J0(33)
]
sage: loads(dumps(D))
[
Simple abelian subvariety 11a(1,33) of dimension 1 of J0(33),
Simple abelian subvariety 11a(3,33) of dimension 1 of J0(33),
Simple abelian subvariety 33a(1,33) of dimension 1 of J0(33)
]
```



---

archive/issue_comments_185185.json:
```json
{
    "body": "Some thoughts:\n\n- Another plus of my suggestion is that it would encourage people to *properly* initialise the category (since otherwise X.__class__ would not be a subclass of the category's parent class).\n\n- The negative of my suggestion: If one programs in Cython, then `X.__class__` will not become a sub-class of the category's parent class, even if initialisation of the category was done properly.\n\n- The positive in the negative of my suggestion: If one programs in Cython, then the problem is not relevant anyway. The problem I'm addressing will only appear if one relies on Python's way of pickling, without implementing `__reduce__`.",
    "created_at": "2013-06-24T15:41:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185185",
    "user": "https://github.com/simon-king-jena"
}
```

Some thoughts:

- Another plus of my suggestion is that it would encourage people to *properly* initialise the category (since otherwise X.__class__ would not be a subclass of the category's parent class).

- The negative of my suggestion: If one programs in Cython, then `X.__class__` will not become a sub-class of the category's parent class, even if initialisation of the category was done properly.

- The positive in the negative of my suggestion: If one programs in Cython, then the problem is not relevant anyway. The problem I'm addressing will only appear if one relies on Python's way of pickling, without implementing `__reduce__`.



---

archive/issue_comments_185186.json:
```json
{
    "body": "I have attached an experimental patch that implements the new suggestion. With it, the only error in sage.modular is:\n\n```\nsage -t sage/modular/abvar/homspace.py  # 1 doctest failed\n```\nwhich is some automatic test suite.\n\nThe situation in sage.schemes is still not good, as we get:\n\n```\nsage -t sage/schemes/elliptic_curves/ell_curve_isogeny.py  # 8 doctests failed\nsage -t sage/schemes/elliptic_curves/ell_point.py  # 8 doctests failed\nsage -t sage/schemes/elliptic_curves/ell_finite_field.py  # 1 doctest failed\nsage -t sage/schemes/elliptic_curves/isogeny_class.py  # 1 doctest failed\nsage -t sage/schemes/projective/projective_space.py  # 2 doctests failed\nsage -t sage/schemes/affine/affine_space.py  # 1 doctest failed\nsage -t sage/schemes/generic/homset.py  # 1 doctest failed\n```\n\nIf we are lucky, this boils down to an improper initialisation of the category of some schemes.",
    "created_at": "2013-06-24T15:49:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185186",
    "user": "https://github.com/simon-king-jena"
}
```

I have attached an experimental patch that implements the new suggestion. With it, the only error in sage.modular is:

```
sage -t sage/modular/abvar/homspace.py  # 1 doctest failed
```
which is some automatic test suite.

The situation in sage.schemes is still not good, as we get:

```
sage -t sage/schemes/elliptic_curves/ell_curve_isogeny.py  # 8 doctests failed
sage -t sage/schemes/elliptic_curves/ell_point.py  # 8 doctests failed
sage -t sage/schemes/elliptic_curves/ell_finite_field.py  # 1 doctest failed
sage -t sage/schemes/elliptic_curves/isogeny_class.py  # 1 doctest failed
sage -t sage/schemes/projective/projective_space.py  # 2 doctests failed
sage -t sage/schemes/affine/affine_space.py  # 1 doctest failed
sage -t sage/schemes/generic/homset.py  # 1 doctest failed
```

If we are lucky, this boils down to an improper initialisation of the category of some schemes.



---

archive/issue_comments_185187.json:
```json
{
    "body": "Indeed:\n\n```\nsimon@linux-sqwp:~/SAGE/prerelease/sage-5.10.rc1/devel/sage> grep \"def category\" -R sage/schemes/\nsage/schemes/generic/morphism.py:    def category(self):\n```\nOverloading `CategoryObject.category` smells like an improper use of the category framework in sage.schemes.",
    "created_at": "2013-06-24T15:52:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185187",
    "user": "https://github.com/simon-king-jena"
}
```

Indeed:

```
simon@linux-sqwp:~/SAGE/prerelease/sage-5.10.rc1/devel/sage> grep "def category" -R sage/schemes/
sage/schemes/generic/morphism.py:    def category(self):
```
Overloading `CategoryObject.category` smells like an improper use of the category framework in sage.schemes.



---

archive/issue_comments_185188.json:
```json
{
    "body": "No, it turns out that the reason was different. Schemes create their homsets without using `sage.categories.homset.Hom` (instead, a `UniqueFactory` is used), and thus one has to overload `Homset.__reduce__` to something that uses the custom `UniqueFactory`---unless someone has the energy to remove this unique factory :)",
    "created_at": "2013-06-24T16:53:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185188",
    "user": "https://github.com/simon-king-jena"
}
```

No, it turns out that the reason was different. Schemes create their homsets without using `sage.categories.homset.Hom` (instead, a `UniqueFactory` is used), and thus one has to overload `Homset.__reduce__` to something that uses the custom `UniqueFactory`---unless someone has the energy to remove this unique factory :)



---

archive/issue_comments_185189.json:
```json
{
    "body": "Hooray! With the updated patch, all tests in sage.schemes pass!!\n\nSo, now I am confident that the general approach will work.",
    "created_at": "2013-06-24T17:00:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185189",
    "user": "https://github.com/simon-king-jena"
}
```

Hooray! With the updated patch, all tests in sage.schemes pass!!

So, now I am confident that the general approach will work.



---

archive/issue_comments_185190.json:
```json
{
    "body": "The only failing test of sage/modular boils down to\n\n```\nsage: E = J0(11).endomorphism_ring()\nsage: loads(dumps(E))\n```\nwhere again Hom is called on a not sufficiently initialised parent.\n\nHere, the problem is that during unpickling, `J0(11).category()` does *not* raise an error, but returns the category of sets, which is the wrong to do in this situation.",
    "created_at": "2013-06-24T17:35:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185190",
    "user": "https://github.com/simon-king-jena"
}
```

The only failing test of sage/modular boils down to

```
sage: E = J0(11).endomorphism_ring()
sage: loads(dumps(E))
```
where again Hom is called on a not sufficiently initialised parent.

Here, the problem is that during unpickling, `J0(11).category()` does *not* raise an error, but returns the category of sets, which is the wrong to do in this situation.



---

archive/issue_comments_185191.json:
```json
{
    "body": "Attachment [homset_default_pickling.patch](tarball://root/attachments/some-uuid/ticket14793/homset_default_pickling.patch) by @simon-king-jena created at 2013-06-25 13:43:46\n\nExperimental patch",
    "created_at": "2013-06-25T13:43:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185191",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [homset_default_pickling.patch](tarball://root/attachments/some-uuid/ticket14793/homset_default_pickling.patch) by @simon-king-jena created at 2013-06-25 13:43:46

Experimental patch



---

archive/issue_comments_185192.json:
```json
{
    "body": "The patch has been updated again. Now, make ptest almost works:\n\n```\nsage -t devel/sage/sage/categories/homset.py  # 1 doctest failed\nsage -t devel/sage/sage/modules/fg_pid/fgp_morphism.py  # 1 doctest failed\n```\n\nThe one failure in homset.py is actually a typo that I introduced in the patch. Hence, trivial to fix.\n\nAnd the only *real* error:\n\n```\nsage -t sage/modules/fg_pid/fgp_morphism.py\n**********************************************************************\nFile \"sage/modules/fg_pid/fgp_morphism.py\", line 499, in sage.modules.fg_pid.fgp_morphism.FGP_Homset_class._coerce_map_from_\nFailed example:\n    phi.parent()._coerce_map_from_(psi.parent())\nExpected:\n    True\nGot:\n    False\n```\nTo be investigated.",
    "created_at": "2013-06-25T13:47:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185192",
    "user": "https://github.com/simon-king-jena"
}
```

The patch has been updated again. Now, make ptest almost works:

```
sage -t devel/sage/sage/categories/homset.py  # 1 doctest failed
sage -t devel/sage/sage/modules/fg_pid/fgp_morphism.py  # 1 doctest failed
```

The one failure in homset.py is actually a typo that I introduced in the patch. Hence, trivial to fix.

And the only *real* error:

```
sage -t sage/modules/fg_pid/fgp_morphism.py
**********************************************************************
File "sage/modules/fg_pid/fgp_morphism.py", line 499, in sage.modules.fg_pid.fgp_morphism.FGP_Homset_class._coerce_map_from_
Failed example:
    phi.parent()._coerce_map_from_(psi.parent())
Expected:
    True
Got:
    False
```
To be investigated.



---

archive/issue_comments_185193.json:
```json
{
    "body": "I just notice that the other one is a real error, too. We want that `Hom(X,Y)` is identical with `Hom(X1,Y1)` only if `X is X1` and `Y is Y1`. But in this example, the homsets are identical even though domain and codomain are equal but not identical.",
    "created_at": "2013-06-25T13:52:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185193",
    "user": "https://github.com/simon-king-jena"
}
```

I just notice that the other one is a real error, too. We want that `Hom(X,Y)` is identical with `Hom(X1,Y1)` only if `X is X1` and `Y is Y1`. But in this example, the homsets are identical even though domain and codomain are equal but not identical.



---

archive/issue_comments_185194.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-06-25T14:59:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185194",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_185195.json:
```json
{
    "body": "I think I have solved all remaining problems. I needed to modify the suggested logic of \"relaxing the category test when there is reason to believe that Hom is called on a domain that is in the process of being unpickled\".\n\nIt now reads like this:\n\n```python\n    # Determines the category\n    if category is None:\n        category = X.category()._meet_(Y.category())\n        # Recurse to make sure that Hom(X, Y) and Hom(X, Y, category) are identical\n        H = Hom(X, Y, category)\n    else:\n        if not isinstance(category, Category):\n            raise TypeError, \"Argument category (= %s) must be a category.\"%category\n        # See trac #14793: It can happen, that Hom(X,X) is called during\n        # unpickling of an instance X of a Python class at a time when\n        # X.__dict__ is empty.  In some of these cases, X.category() would\n        # raise a error or would return a too large category (Sets(), for\n        # example) and (worse!) would assign this larger category to the\n        # X._category cdef attribute, so that it would subsequently seem that\n        # X's category was properly initialised.\n\n        # However, if the above scenario happens, then *before* calling\n        # X.category(), X._is_category_initialised() will correctly say that\n        # it is not initialised. Moreover, since X.__class__ is a Python\n        # class, we will find that `isinstance(X, category.parent_class)`. If\n        # this is the case, then we trust that we indeed are in the process of\n        # unpickling X.  Hence, we will trust that `category` has the correct\n        # value, and we will thus skip the test whether `X in category`.\n        try:\n            unpickle_X = (not X._is_category_initialized()) and isinstance(X,category.parent_class)\n        except AttributeError: # this happens for simplicial complexes\n            unpickle_X = False\n        try:\n            unpickle_Y = (not Y._is_category_initialized()) and isinstance(Y,category.parent_class)\n        except AttributeError:\n            unpickle_Y = False\n        if unpickle_X:\n            cat_X = category\n        else:\n            try:\n                cat_X = X.category()\n            except BaseException:\n                raise TypeError, \"%s is not in %s\"%(X, category)\n        if unpickle_Y:\n            cat_Y = category\n        else:\n            try:\n                cat_Y = Y.category()\n            except BaseException:\n                raise TypeError, \"%s is not in %s\"%(Y, category)\n```\n\nNote the comment on simplicial complexes: They do have a `.category()` method, but they do not derive from `CategoryObject` and thus have no `._is_category_initialized()` method. Shame on them.\n\nIn addition, some changes needed to be done for `SchemeHomsets` and the like. I think one can now start with reviewing.\n\nApply trac14793-homset_default_pickling.patch",
    "created_at": "2013-06-25T14:59:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185195",
    "user": "https://github.com/simon-king-jena"
}
```

I think I have solved all remaining problems. I needed to modify the suggested logic of "relaxing the category test when there is reason to believe that Hom is called on a domain that is in the process of being unpickled".

It now reads like this:

```python
    # Determines the category
    if category is None:
        category = X.category()._meet_(Y.category())
        # Recurse to make sure that Hom(X, Y) and Hom(X, Y, category) are identical
        H = Hom(X, Y, category)
    else:
        if not isinstance(category, Category):
            raise TypeError, "Argument category (= %s) must be a category."%category
        # See trac #14793: It can happen, that Hom(X,X) is called during
        # unpickling of an instance X of a Python class at a time when
        # X.__dict__ is empty.  In some of these cases, X.category() would
        # raise a error or would return a too large category (Sets(), for
        # example) and (worse!) would assign this larger category to the
        # X._category cdef attribute, so that it would subsequently seem that
        # X's category was properly initialised.

        # However, if the above scenario happens, then *before* calling
        # X.category(), X._is_category_initialised() will correctly say that
        # it is not initialised. Moreover, since X.__class__ is a Python
        # class, we will find that `isinstance(X, category.parent_class)`. If
        # this is the case, then we trust that we indeed are in the process of
        # unpickling X.  Hence, we will trust that `category` has the correct
        # value, and we will thus skip the test whether `X in category`.
        try:
            unpickle_X = (not X._is_category_initialized()) and isinstance(X,category.parent_class)
        except AttributeError: # this happens for simplicial complexes
            unpickle_X = False
        try:
            unpickle_Y = (not Y._is_category_initialized()) and isinstance(Y,category.parent_class)
        except AttributeError:
            unpickle_Y = False
        if unpickle_X:
            cat_X = category
        else:
            try:
                cat_X = X.category()
            except BaseException:
                raise TypeError, "%s is not in %s"%(X, category)
        if unpickle_Y:
            cat_Y = category
        else:
            try:
                cat_Y = Y.category()
            except BaseException:
                raise TypeError, "%s is not in %s"%(Y, category)
```

Note the comment on simplicial complexes: They do have a `.category()` method, but they do not derive from `CategoryObject` and thus have no `._is_category_initialized()` method. Shame on them.

In addition, some changes needed to be done for `SchemeHomsets` and the like. I think one can now start with reviewing.

Apply trac14793-homset_default_pickling.patch



---

archive/issue_comments_185196.json:
```json
{
    "body": "I'm just thinking: Perhaps one should rather define\n\n```\n    unpickle_X = hasattr(X, '_is_category_initialized') and (not X._is_category_initialized()) and isinstance(X,category.parent_class)\n```",
    "created_at": "2013-06-25T15:01:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185196",
    "user": "https://github.com/simon-king-jena"
}
```

I'm just thinking: Perhaps one should rather define

```
    unpickle_X = hasattr(X, '_is_category_initialized') and (not X._is_category_initialized()) and isinstance(X,category.parent_class)
```



---

archive/issue_comments_185197.json:
```json
{
    "body": "Attachment [trac14793-homset_default_pickling.patch](tarball://root/attachments/some-uuid/ticket14793/trac14793-homset_default_pickling.patch) by @simon-king-jena created at 2013-06-25 16:16:13\n\nI needed to replace the old `Hom()` method of `FGP_Modules` by a `_Hom_()` method. While I was at it, I provided their homsets with an element class. However, I did not fix it to the extent that `TestSuite(...).run()` would pass.\n\nApply trac14793-homset_default_pickling.patch",
    "created_at": "2013-06-25T16:16:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185197",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac14793-homset_default_pickling.patch](tarball://root/attachments/some-uuid/ticket14793/trac14793-homset_default_pickling.patch) by @simon-king-jena created at 2013-06-25 16:16:13

I needed to replace the old `Hom()` method of `FGP_Modules` by a `_Hom_()` method. While I was at it, I provided their homsets with an element class. However, I did not fix it to the extent that `TestSuite(...).run()` would pass.

Apply trac14793-homset_default_pickling.patch



---

archive/issue_comments_185198.json:
```json
{
    "body": "Here is an overview of my patch, to facilitate reviewing.\n\n__sage.categories.homset__\n\n- A homset is provided with inheritance from `WithEqualityById` (which means: Faster comparison), provided that the type of domain and codomain shows that domain and codomain and thus the homset are unique parents.\n- It must be tested in some way whether domain and codomain of the to-be-created homset belong to the given category. This can fail on parents that are not completely initialised during unpickling. If this parent is an instance of a Python class, then *by virtue of the category framework* its class tells whether it belongs to the correct category, up to the choice of a base ring. I think that in this case we can assume that the parent will be fine as soon as its reconstruction/unpickling is complete.\n- Homsets should be pickled using the `Hom` function, hence, with a cache.\n\n__sage.modular.abvar.abvar__\n\n- A category should be accepted when creating an endomorphism ring of a variety X. Previously, the correct category was read off of X.category(). However, during unpickling, X.category() might not work, and thus the category should be explicit part of the pickle data (and must hence be passed to the construction of the endomorphism ring).\n\n__sage.modular.abvar.homspace__\n\n- Pass the category parameter to the construction of homspaces (see above)\n- Provide homspaces with an element class\n- Use the element class for constructing its elements.\n- The `_matrix_space` attribute used to be defined during initialisation, with information obtained from domain and codomain. Again, during unpickling, domain and codomain may be unable to provide such information. Hence, I turn `_matrix_space` into a lazy attribute, that will only be called *after* initialisation, hence, *after* finishing unpickling of domain and codomain.\n\n__sage.modules.fg_pid.fgp_module__\n\n- The modules should better rely on the default implementation of the `.Hom()` method. Hence, I renamed `.Hom()` into `._Hom_()`.\n\n__sage.modules.fg_pid.fgp_morphism__\n\n- The category should be passed when calling `Homset.__init__`\n- I provided the homsets with an element class\n\n__sage.modules.matrix_morphism__\n\n- The constructor of a matrix morphism should accept another matrix morphism as an input. This is to make conversion of matrix morphisms (between distinct but equal homsets) possible. Aim: Let `TestSuite` pass to greater extent.\n- **TODO**: To make `TestSuite` fully pass, it would be needed that the morphisms have a `_mul_` (single underscore) method. Currently, they only have a `__mul__` (double underscore) method. This shall be topic of a ticket that implements the coercion framework for homsets (I created such ticket already, but don't recall the number).\n\n__sage.schemes.generic.homset__\n\n- I believe that `SchemeHomset` should not rely on a `UniqueFactory`, but should rather rely on the cache of the `Hom` function. However, I did not remove the factory. Instead, I overload the `__reduce__` method inherited from `Homset` and use the `SchemeHomset` factory for pickling.\n\nI hope this explanation makes the reviewer happy!",
    "created_at": "2013-06-26T12:39:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185198",
    "user": "https://github.com/simon-king-jena"
}
```

Here is an overview of my patch, to facilitate reviewing.

__sage.categories.homset__

- A homset is provided with inheritance from `WithEqualityById` (which means: Faster comparison), provided that the type of domain and codomain shows that domain and codomain and thus the homset are unique parents.
- It must be tested in some way whether domain and codomain of the to-be-created homset belong to the given category. This can fail on parents that are not completely initialised during unpickling. If this parent is an instance of a Python class, then *by virtue of the category framework* its class tells whether it belongs to the correct category, up to the choice of a base ring. I think that in this case we can assume that the parent will be fine as soon as its reconstruction/unpickling is complete.
- Homsets should be pickled using the `Hom` function, hence, with a cache.

__sage.modular.abvar.abvar__

- A category should be accepted when creating an endomorphism ring of a variety X. Previously, the correct category was read off of X.category(). However, during unpickling, X.category() might not work, and thus the category should be explicit part of the pickle data (and must hence be passed to the construction of the endomorphism ring).

__sage.modular.abvar.homspace__

- Pass the category parameter to the construction of homspaces (see above)
- Provide homspaces with an element class
- Use the element class for constructing its elements.
- The `_matrix_space` attribute used to be defined during initialisation, with information obtained from domain and codomain. Again, during unpickling, domain and codomain may be unable to provide such information. Hence, I turn `_matrix_space` into a lazy attribute, that will only be called *after* initialisation, hence, *after* finishing unpickling of domain and codomain.

__sage.modules.fg_pid.fgp_module__

- The modules should better rely on the default implementation of the `.Hom()` method. Hence, I renamed `.Hom()` into `._Hom_()`.

__sage.modules.fg_pid.fgp_morphism__

- The category should be passed when calling `Homset.__init__`
- I provided the homsets with an element class

__sage.modules.matrix_morphism__

- The constructor of a matrix morphism should accept another matrix morphism as an input. This is to make conversion of matrix morphisms (between distinct but equal homsets) possible. Aim: Let `TestSuite` pass to greater extent.
- **TODO**: To make `TestSuite` fully pass, it would be needed that the morphisms have a `_mul_` (single underscore) method. Currently, they only have a `__mul__` (double underscore) method. This shall be topic of a ticket that implements the coercion framework for homsets (I created such ticket already, but don't recall the number).

__sage.schemes.generic.homset__

- I believe that `SchemeHomset` should not rely on a `UniqueFactory`, but should rather rely on the cache of the `Hom` function. However, I did not remove the factory. Instead, I overload the `__reduce__` method inherited from `Homset` and use the `SchemeHomset` factory for pickling.

I hope this explanation makes the reviewer happy!



---

archive/issue_comments_185199.json:
```json
{
    "body": "Made this into a branch and added doctests to added functions and some other misc review changes. If you're happy with my changes Simon, then this is a positive review.\n\n---\nNew commits:",
    "created_at": "2013-12-27T18:49:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185199",
    "user": "https://github.com/tscrim"
}
```

Made this into a branch and added doctests to added functions and some other misc review changes. If you're happy with my changes Simon, then this is a positive review.

---
New commits:



---

archive/issue_comments_185200.json:
```json
{
    "body": "Travis, how difficult has it been to apply the old patch? Certainly there have been a bunch of conflicts.",
    "created_at": "2013-12-27T20:11:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185200",
    "user": "https://github.com/simon-king-jena"
}
```

Travis, how difficult has it been to apply the old patch? Certainly there have been a bunch of conflicts.



---

archive/issue_comments_185201.json:
```json
{
    "body": "For the record: I am happy with your changes, Travis. To be on the safe side, I am running tests on my laptop now, but after all *you* are the reviewer... And sorry that I forgot to add tests for some new methods.",
    "created_at": "2013-12-27T21:44:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185201",
    "user": "https://github.com/simon-king-jena"
}
```

For the record: I am happy with your changes, Travis. To be on the safe side, I am running tests on my laptop now, but after all *you* are the reviewer... And sorry that I forgot to add tests for some new methods.



---

archive/issue_comments_185202.json:
```json
{
    "body": "Replying to [comment:37 SimonKing]:\n> Travis, how difficult has it been to apply the old patch? Certainly there have been a bunch of conflicts.\n\n\nNone; there were no conflicts. Although it might conflict with #10963..... *gulp*\n\nActually, I noticed that I missed an added `__reduce__()` in `categories/homset.py` -- it has a docstring but no doctests. Could you add one since I won't have access to a computer with Sage for another 6-8 hours (I will do it then if you haven't done it)? Thanks.",
    "created_at": "2013-12-27T23:23:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185202",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:37 SimonKing]:
> Travis, how difficult has it been to apply the old patch? Certainly there have been a bunch of conflicts.


None; there were no conflicts. Although it might conflict with #10963..... *gulp*

Actually, I noticed that I missed an added `__reduce__()` in `categories/homset.py` -- it has a docstring but no doctests. Could you add one since I won't have access to a computer with Sage for another 6-8 hours (I will do it then if you haven't done it)? Thanks.



---

archive/issue_comments_185203.json:
```json
{
    "body": "Replying to [comment:39 tscrim]:\n> Actually, I noticed that I missed an added `__reduce__()` in `categories/homset.py` -- it has a docstring but no doctests. Could you add one since I won't have access to a computer with Sage for another 6-8 hours (I will do it then if you haven't done it)? Thanks.\n\n\nI see your post only now---and 8 hours are past `:-)`\n\nAnyway, I am adding a test for the `__reduce__` method now. We should then have another look at the \"patch\" and see what hasn't been tested.",
    "created_at": "2013-12-28T07:10:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185203",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:39 tscrim]:
> Actually, I noticed that I missed an added `__reduce__()` in `categories/homset.py` -- it has a docstring but no doctests. Could you add one since I won't have access to a computer with Sage for another 6-8 hours (I will do it then if you haven't done it)? Thanks.


I see your post only now---and 8 hours are past `:-)`

Anyway, I am adding a test for the `__reduce__` method now. We should then have another look at the "patch" and see what hasn't been tested.



---

archive/issue_comments_185204.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2013-12-28T07:24:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185204",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_185205.json:
```json
{
    "body": "Test added.",
    "created_at": "2013-12-28T07:25:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185205",
    "user": "https://github.com/simon-king-jena"
}
```

Test added.



---

archive/issue_comments_185206.json:
```json
{
    "body": "PS: I verified that the homsets in the test really use *this* and no other method for pickling.",
    "created_at": "2013-12-28T07:27:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185206",
    "user": "https://github.com/simon-king-jena"
}
```

PS: I verified that the homsets in the test really use *this* and no other method for pickling.



---

archive/issue_comments_185207.json:
```json
{
    "body": "Good news: #10963 merges cleanly.",
    "created_at": "2013-12-28T09:08:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185207",
    "user": "https://github.com/simon-king-jena"
}
```

Good news: #10963 merges cleanly.



---

archive/issue_comments_185208.json:
```json
{
    "body": "I put sleep > sage last night, so `:p` and thanks for adding that. It's also good to know that there are no conflicts with #10963. I've gone through your changes, tests pass, and everything is documented. The `TestSuite` and things is #14279. What else is left here to review?",
    "created_at": "2013-12-28T17:17:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185208",
    "user": "https://github.com/tscrim"
}
```

I put sleep > sage last night, so `:p` and thanks for adding that. It's also good to know that there are no conflicts with #10963. I've gone through your changes, tests pass, and everything is documented. The `TestSuite` and things is #14279. What else is left here to review?



---

archive/issue_comments_185209.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2014-01-02T05:29:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185209",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_185210.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:",
    "created_at": "2014-01-02T05:31:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185210",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:



---

archive/issue_comments_185211.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:",
    "created_at": "2014-01-02T05:33:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185211",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. Recent commits:



---

archive/issue_comments_185212.json:
```json
{
    "body": "I'm an idiot and merged the wrong branches...",
    "created_at": "2014-01-02T05:34:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185212",
    "user": "https://github.com/tscrim"
}
```

I'm an idiot and merged the wrong branches...



---

archive/issue_comments_185213.json:
```json
{
    "body": "Replying to [comment:49 tscrim]:\n> I'm an idiot and merged the wrong branches...\n\n\nDoesn't this qualify as \"changing history\"? You bad boy `;-)`",
    "created_at": "2014-01-02T09:57:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185213",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:49 tscrim]:
> I'm an idiot and merged the wrong branches...


Doesn't this qualify as "changing history"? You bad boy `;-)`



---

archive/issue_comments_185214.json:
```json
{
    "body": "It's not changing history, just taking a different path `:p`.",
    "created_at": "2014-01-02T17:22:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185214",
    "user": "https://github.com/tscrim"
}
```

It's not changing history, just taking a different path `:p`.



---

archive/issue_comments_185215.json:
```json
{
    "body": "I think we're good to go here unless there's something else you can see or think of?",
    "created_at": "2014-01-09T02:41:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185215",
    "user": "https://github.com/tscrim"
}
```

I think we're good to go here unless there's something else you can see or think of?



---

archive/issue_comments_185216.json:
```json
{
    "body": "Replying to [comment:52 tscrim]:\n> I think we're good to go here unless there's something else you can see or think of?\n\n\nJust to make sure: We have three commits, namely one that corresponds to the original patch, your review changes, and then my commit adding one doctest?\n\nFor the record, I agree with your review changes. But after all, you are the reviewer, not I. If you think the code is fine and if all tests pass after merging the develop branch, I'd not oppose to let this be positively reviewed.",
    "created_at": "2014-01-09T10:17:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185216",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:52 tscrim]:
> I think we're good to go here unless there's something else you can see or think of?


Just to make sure: We have three commits, namely one that corresponds to the original patch, your review changes, and then my commit adding one doctest?

For the record, I agree with your review changes. But after all, you are the reviewer, not I. If you think the code is fine and if all tests pass after merging the develop branch, I'd not oppose to let this be positively reviewed.



---

archive/issue_comments_185217.json:
```json
{
    "body": "Replying to [comment:53 SimonKing]:\n> Just to make sure: We have three commits, namely one that corresponds to the original patch, your review changes, and then my commit adding one doctest?\n\n\nCorrect.\n\n> For the record, I agree with your review changes. But after all, you are the reviewer, not I. If you think the code is fine and if all tests pass after merging the develop branch, I'd not oppose to let this be positively reviewed.\n\n\nI think everything is good, so positive review. Thank you for your work on this Simon. Now #14279 and its dependency (after we finish #10963 and the weak coercions).",
    "created_at": "2014-01-09T16:19:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185217",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:53 SimonKing]:
> Just to make sure: We have three commits, namely one that corresponds to the original patch, your review changes, and then my commit adding one doctest?


Correct.

> For the record, I agree with your review changes. But after all, you are the reviewer, not I. If you think the code is fine and if all tests pass after merging the develop branch, I'd not oppose to let this be positively reviewed.


I think everything is good, so positive review. Thank you for your work on this Simon. Now #14279 and its dependency (after we finish #10963 and the weak coercions).



---

archive/issue_comments_185218.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-01-09T16:20:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185218",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_042435.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14589#event-42435"
}
```



---

archive/issue_events_042436.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-03-03T18:55:31Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14589#event-42436"
}
```



---

archive/issue_comments_185219.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-03-03T18:55:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14589#issuecomment-185219",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
