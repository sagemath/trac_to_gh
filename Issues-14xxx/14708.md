# Issue 14708: UniqueRepresentation tutorial could use more love

archive/issues_014708.json:
```json
{
    "body": "CC:  simonking @tscrim\n\nKeywords: documentation, structure\n\nSadly not my love, unless someone teaches me enough of the stuff that I understand it myself.\n\nhttp://www.sagemath.org/doc/reference/structure/sage/structure/unique_representation.html\n\nOne thing I don't understand is:\n\n```\nthe preprocessing on the arguments should be idempotent. Namely, If MyClass2.__classcall__ calls CachedRepresentation.__classcall__(<some_arguments>), then it should accept <some_arguments> as its own input, and pass it down unmodified to CachedRepresentation.__classcall__().\n```\nWhat is meant by \"accept <some_arguments> as its own input\"?\n\nSomething that possibly should be added is some explanation of the difference between `__classcall__` and `__classcall_private__`. Maybe it doesn't belong there, but then again I have no idea where it belongs as it seems not documented at all...\n\nAlso there seems to be a typo:\n\n```\nThe UniqueRepresentation and UniqueFactory classes provide two alternative implementations of this design pattern. Both implementations have their own merits. UniqueRepresentation is very easy to use: a class just needs to derive from it, or make sure some of its super classes does. Also, it groups together the class and the factory in a single gadget; in the example above, one would want to do:\n```\n\nI think it's UniqueFactory, not UniqueRepresentation, which is easy to use etc.\n\nApply:\n\n* [attachment:trac14912-unique_doc.patch]\n* [attachment:trac_14912-comments-dg.patch]\n* [attachment:trac_14912-more-ts-dg.patch]\n* [attachment:trac_14912-doc-fixes-sk.patch]\n* [attachment:trac_14912-fix_leaking_print-ts.patch\u200b]\n\nIssue created by migration from https://trac.sagemath.org/ticket/14912\n\n",
    "closed_at": "2013-12-18T14:55:39Z",
    "created_at": "2013-07-19T22:38:58Z",
    "labels": [
        "component: documentation",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.1",
    "title": "UniqueRepresentation tutorial could use more love",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14708",
    "user": "https://github.com/darijgr"
}
```
CC:  simonking @tscrim

Keywords: documentation, structure

Sadly not my love, unless someone teaches me enough of the stuff that I understand it myself.

http://www.sagemath.org/doc/reference/structure/sage/structure/unique_representation.html

One thing I don't understand is:

```
the preprocessing on the arguments should be idempotent. Namely, If MyClass2.__classcall__ calls CachedRepresentation.__classcall__(<some_arguments>), then it should accept <some_arguments> as its own input, and pass it down unmodified to CachedRepresentation.__classcall__().
```
What is meant by "accept <some_arguments> as its own input"?

Something that possibly should be added is some explanation of the difference between `__classcall__` and `__classcall_private__`. Maybe it doesn't belong there, but then again I have no idea where it belongs as it seems not documented at all...

Also there seems to be a typo:

```
The UniqueRepresentation and UniqueFactory classes provide two alternative implementations of this design pattern. Both implementations have their own merits. UniqueRepresentation is very easy to use: a class just needs to derive from it, or make sure some of its super classes does. Also, it groups together the class and the factory in a single gadget; in the example above, one would want to do:
```

I think it's UniqueFactory, not UniqueRepresentation, which is easy to use etc.

Apply:

* [attachment:trac14912-unique_doc.patch]
* [attachment:trac_14912-comments-dg.patch]
* [attachment:trac_14912-more-ts-dg.patch]
* [attachment:trac_14912-doc-fixes-sk.patch]
* [attachment:trac_14912-fix_leaking_print-ts.patch​]

Issue created by migration from https://trac.sagemath.org/ticket/14912





---

archive/issue_comments_187144.json:
```json
{
    "body": "Replying to [ticket:14912 darij]:\n> I think it's UniqueFactory, not UniqueRepresentation, which is easy to use etc.\n\n\nYou couldn't be more mistaken, I think. In the wast majority of cases, if you have defined a class C,\n\n```\nclass C(base1, base2):\n    code\n```\nthen you only need to change it into\n\n```\nclass C(UniqueRepresentation, base1, base2):\n    code\n```\nand have caching *and* pickling for free. Setting up a `UniqueFactory` is a lot more work.",
    "created_at": "2013-07-19T23:03:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187144",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [ticket:14912 darij]:
> I think it's UniqueFactory, not UniqueRepresentation, which is easy to use etc.


You couldn't be more mistaken, I think. In the wast majority of cases, if you have defined a class C,

```
class C(base1, base2):
    code
```
then you only need to change it into

```
class C(UniqueRepresentation, base1, base2):
    code
```
and have caching *and* pickling for free. Setting up a `UniqueFactory` is a lot more work.



---

archive/issue_comments_187145.json:
```json
{
    "body": "Something else is wrong then, because the example directly under the paragraph I quoted is about GF, which is a UniqueFactory.",
    "created_at": "2013-07-19T23:14:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187145",
    "user": "https://github.com/darijgr"
}
```

Something else is wrong then, because the example directly under the paragraph I quoted is about GF, which is a UniqueFactory.



---

archive/issue_comments_187146.json:
```json
{
    "body": "Replying to [comment:4 darij]:\n> Something else is wrong then, because the example directly under the paragraph I quoted is about GF, which is a UniqueFactory.\n\n\nOK, if this is the case, then indeed it is a bad example.\n\nOne question, though: What do you mean by `UniqueRepresentation` tutorial? Is there a separate tutorial, or is it just the pages for sage.structure.factory and sage.structure.unique_representation, respectively?",
    "created_at": "2013-07-20T09:27:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187146",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:4 darij]:
> Something else is wrong then, because the example directly under the paragraph I quoted is about GF, which is a UniqueFactory.


OK, if this is the case, then indeed it is a bad example.

One question, though: What do you mean by `UniqueRepresentation` tutorial? Is there a separate tutorial, or is it just the pages for sage.structure.factory and sage.structure.unique_representation, respectively?



---

archive/issue_comments_187147.json:
```json
{
    "body": "Oops, what I meant is really just the docstring for `UniqueRepresentation` in `sage/structure/unique_representation.py`.",
    "created_at": "2013-07-20T09:31:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187147",
    "user": "https://github.com/darijgr"
}
```

Oops, what I meant is really just the docstring for `UniqueRepresentation` in `sage/structure/unique_representation.py`.



---

archive/issue_comments_187148.json:
```json
{
    "body": "I think both `sage.structure.unique_representation` and `sage.structure.factory` need more care.\n\nCertainly it is a severe fault that `GF(...)` appears as example of `UniqueRepresentation`.\n\nAnd I think both parts of the documentation should give hints on when to use `UniqueRepresentation` and when to use `UniqueFactory`.\n\nFor example, a `UniqueFactory` can return different implementations of the same algebraic structure, depending on the input data. This would be impossible (or at least not so easily possible) with `UniqueRepresentation`. And you would not be able to use `UniqueRepresentation` with a cdef class---you can define your class in a pyx file, but it has to be `class Foo(UniqueRepresentation, ...)`, not `cdef class Foo(UniqueRepresentation, ...)`, simply since `UniqueRepresentation` uses meta-classes, which is not possible in a cdef class, if I am not mistaken (and of course, multiple inheritance does not work yet in Cython, and after all `UniqueRepresentation` is a python class.\n\nThese are reasons for using a factory.\n\nOn the other hand, using `UniqueRepresentation` would automatically provide your class with very fast hash and comparison methods implemented in Cython (`UniqueRepresentation` is a Python class, but also inherits from the Cython class `sage.misc.fast_methods.WithEqualityById`). If you use a factory instead, you'd need to take care of hash and comparison all by yourself---and this means: It is possible that a `UniqueFactory` returns objects that are *not* unique parents!! And moreover, using `UniqueRepresentation` is very easy---in most cases, it is enough to take an existing class and add `UniqueRepresentation` as base.\n\nSo, these are reasons for using a unique representation.",
    "created_at": "2013-07-23T14:37:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187148",
    "user": "https://github.com/simon-king-jena"
}
```

I think both `sage.structure.unique_representation` and `sage.structure.factory` need more care.

Certainly it is a severe fault that `GF(...)` appears as example of `UniqueRepresentation`.

And I think both parts of the documentation should give hints on when to use `UniqueRepresentation` and when to use `UniqueFactory`.

For example, a `UniqueFactory` can return different implementations of the same algebraic structure, depending on the input data. This would be impossible (or at least not so easily possible) with `UniqueRepresentation`. And you would not be able to use `UniqueRepresentation` with a cdef class---you can define your class in a pyx file, but it has to be `class Foo(UniqueRepresentation, ...)`, not `cdef class Foo(UniqueRepresentation, ...)`, simply since `UniqueRepresentation` uses meta-classes, which is not possible in a cdef class, if I am not mistaken (and of course, multiple inheritance does not work yet in Cython, and after all `UniqueRepresentation` is a python class.

These are reasons for using a factory.

On the other hand, using `UniqueRepresentation` would automatically provide your class with very fast hash and comparison methods implemented in Cython (`UniqueRepresentation` is a Python class, but also inherits from the Cython class `sage.misc.fast_methods.WithEqualityById`). If you use a factory instead, you'd need to take care of hash and comparison all by yourself---and this means: It is possible that a `UniqueFactory` returns objects that are *not* unique parents!! And moreover, using `UniqueRepresentation` is very easy---in most cases, it is enough to take an existing class and add `UniqueRepresentation` as base.

So, these are reasons for using a unique representation.



---

archive/issue_comments_187149.json:
```json
{
    "body": "Replying to [comment:7 SimonKing]:\n> Certainly it is a severe fault that `GF(...)` appears as example of `UniqueRepresentation`.\n\n\nOr not? I now see that `GF(...)` appears in order to demonstrate the design pattern that is common to both unique representation and unique factory. And it is clearly stated that one would like to have something like\n\n```\nisinstance(GF(p), GF)\n```\nwhich is *not* possible with a unique factory but is the case for `UniqueRepresentation`.",
    "created_at": "2013-07-23T15:14:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187149",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:7 SimonKing]:
> Certainly it is a severe fault that `GF(...)` appears as example of `UniqueRepresentation`.


Or not? I now see that `GF(...)` appears in order to demonstrate the design pattern that is common to both unique representation and unique factory. And it is clearly stated that one would like to have something like

```
isinstance(GF(p), GF)
```
which is *not* possible with a unique factory but is the case for `UniqueRepresentation`.



---

archive/issue_comments_187150.json:
```json
{
    "body": "I think it is a good idea to have GF mentioned *both* in the documentation of unique representation and unique factory, since it explains one detail one can base one's choice on.\n\nNamely, as an example of a behaviour one can not get with `UniqueRepresentation`:\n\n```\nsage: type(GF(5))\n<class 'sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category'>\nsage: type(GF(25,'x'))\n<class 'sage.rings.finite_rings.finite_field_givaro.FiniteField_givaro_with_category'>\nsage: type(GF(5^10,'x'))\n<class 'sage.rings.finite_rings.finite_field_ext_pari.FiniteField_ext_pari_with_category'>\nsage: type(GF(2^20,'x'))\n<class 'sage.rings.finite_rings.finite_field_ntl_gf2e.FiniteField_ntl_gf2e_with_category'>\n```",
    "created_at": "2013-07-23T15:25:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187150",
    "user": "https://github.com/simon-king-jena"
}
```

I think it is a good idea to have GF mentioned *both* in the documentation of unique representation and unique factory, since it explains one detail one can base one's choice on.

Namely, as an example of a behaviour one can not get with `UniqueRepresentation`:

```
sage: type(GF(5))
<class 'sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category'>
sage: type(GF(25,'x'))
<class 'sage.rings.finite_rings.finite_field_givaro.FiniteField_givaro_with_category'>
sage: type(GF(5^10,'x'))
<class 'sage.rings.finite_rings.finite_field_ext_pari.FiniteField_ext_pari_with_category'>
sage: type(GF(2^20,'x'))
<class 'sage.rings.finite_rings.finite_field_ntl_gf2e.FiniteField_ntl_gf2e_with_category'>
```



---

archive/issue_comments_187151.json:
```json
{
    "body": "Questions:\n\n- Neither `sage.structure.factory` nor `sage.structure.unique_representation` have a meaningful documentation at module level. Would it make sense to give documentation at module level that helps for choosing among the two models of creating a unique parent behaviour? Or should this be only provided by `CachedRepresentation` and `UniqueRepresentation` resp. by `UniqueFactory`?\n- You mentioned that you find the distinction between `__classcall__` and `__classcall_private__` unclear. There is an example clarifying the distinction, but it is hidden in the documentation of `_clear_cache_()`, which is an underscore method and is thus not visible in the reference manual. Do you think that the example from `_clear_cache_()` is clear? Then we could promote it (or a similar example) to a visible place.",
    "created_at": "2013-07-25T14:18:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187151",
    "user": "https://github.com/simon-king-jena"
}
```

Questions:

- Neither `sage.structure.factory` nor `sage.structure.unique_representation` have a meaningful documentation at module level. Would it make sense to give documentation at module level that helps for choosing among the two models of creating a unique parent behaviour? Or should this be only provided by `CachedRepresentation` and `UniqueRepresentation` resp. by `UniqueFactory`?
- You mentioned that you find the distinction between `__classcall__` and `__classcall_private__` unclear. There is an example clarifying the distinction, but it is hidden in the documentation of `_clear_cache_()`, which is an underscore method and is thus not visible in the reference manual. Do you think that the example from `_clear_cache_()` is clear? Then we could promote it (or a similar example) to a visible place.



---

archive/issue_comments_187152.json:
```json
{
    "body": "I fear the doc of `_clear_cache_()` is beyound my comprehension... Is the difference just in the fact that a `__classcall_private__` method will not be inherited by subclasses while a `__classcall__` will be? (But I thought all methods would be inherited by subclasses?)",
    "created_at": "2013-07-27T01:50:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187152",
    "user": "https://github.com/darijgr"
}
```

I fear the doc of `_clear_cache_()` is beyound my comprehension... Is the difference just in the fact that a `__classcall_private__` method will not be inherited by subclasses while a `__classcall__` will be? (But I thought all methods would be inherited by subclasses?)



---

archive/issue_comments_187153.json:
```json
{
    "body": "Replying to [comment:11 darij]:\n> I fear the doc of `_clear_cache_()` is beyound my comprehension... Is the difference just in the fact that a `__classcall_private__` method will not be inherited by subclasses while a `__classcall__` will be? (But I thought all methods would be inherited by subclasses?)\n\n\nYour question really is about `sage.misc.classcall_metaclass.ClasscallMetaclass`, which is where methods such as `__classcall__`, `__classget__`, `__classcontains__` and `__classcall_private__` take effect.\n\nHere, we look at `sage.misc.classcall_metaclass.ClasscallMetaclass.__call__`, which implements the creation of instances of a class. Of course, if a class C defines `__classcall_private__` and a class D inherits from C, then D also has a `__classcall_private__` method. However, you can find this method in `C.__dict__` but not in `D.__dict__`.\n\nAnd the rule is: If an instance of a class (here: C or D) is created by calling `ClasscallMetaclass.__class__`, then\n* it will be checked whether the class has a `__classcall_private__` in its own `__dict__`. If this is the case, then `__classcall_private__` will be called. Otherwise,\n* it is checked whether the class has a `__classcall__` method (which is not necessarily in `__dict__`, as it could be inherited from a base class). If this is the case, then `__classcall__` will be called.\n\nI just said \"we look at `ClasscallMetaclass.__call__`\". Well, in fact we look at `CLasscallMetaclass.__cinit__`, because this is where the choice between `__classcall__` and `__classcall_private__` is made.\n\nWhat does all this mean for this ticket?\n\nQuestion: Do you think it would be enough to state in the documentation of `CachedRepresentation` that it has the `ClasscallMetaclass` and that it provides a `__classcall__` implementing the cache, and that one can use `__classcall_private__` or `__classcall__` as explained in the docs of `ClasscallMetaclass` to overload the default way of caching?\n\nOr I guess it would still be a good idea to have examples in place, without the need to read the `ClasscallMetaclass` docs...",
    "created_at": "2013-07-27T08:27:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187153",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:11 darij]:
> I fear the doc of `_clear_cache_()` is beyound my comprehension... Is the difference just in the fact that a `__classcall_private__` method will not be inherited by subclasses while a `__classcall__` will be? (But I thought all methods would be inherited by subclasses?)


Your question really is about `sage.misc.classcall_metaclass.ClasscallMetaclass`, which is where methods such as `__classcall__`, `__classget__`, `__classcontains__` and `__classcall_private__` take effect.

Here, we look at `sage.misc.classcall_metaclass.ClasscallMetaclass.__call__`, which implements the creation of instances of a class. Of course, if a class C defines `__classcall_private__` and a class D inherits from C, then D also has a `__classcall_private__` method. However, you can find this method in `C.__dict__` but not in `D.__dict__`.

And the rule is: If an instance of a class (here: C or D) is created by calling `ClasscallMetaclass.__class__`, then
* it will be checked whether the class has a `__classcall_private__` in its own `__dict__`. If this is the case, then `__classcall_private__` will be called. Otherwise,
* it is checked whether the class has a `__classcall__` method (which is not necessarily in `__dict__`, as it could be inherited from a base class). If this is the case, then `__classcall__` will be called.

I just said "we look at `ClasscallMetaclass.__call__`". Well, in fact we look at `CLasscallMetaclass.__cinit__`, because this is where the choice between `__classcall__` and `__classcall_private__` is made.

What does all this mean for this ticket?

Question: Do you think it would be enough to state in the documentation of `CachedRepresentation` that it has the `ClasscallMetaclass` and that it provides a `__classcall__` implementing the cache, and that one can use `__classcall_private__` or `__classcall__` as explained in the docs of `ClasscallMetaclass` to overload the default way of caching?

Or I guess it would still be a good idea to have examples in place, without the need to read the `ClasscallMetaclass` docs...



---

archive/issue_comments_187154.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2013-08-10T08:46:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187154",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_187155.json:
```json
{
    "body": "I have attached a patch. Do you like the new documentation better? What points would you suggest to improve further?\n\nNote that I added documentation to both sage.structure.factory and sage.structure.unique_representation, also adding new tests.",
    "created_at": "2013-08-10T08:46:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187155",
    "user": "https://github.com/simon-king-jena"
}
```

I have attached a patch. Do you like the new documentation better? What points would you suggest to improve further?

Note that I added documentation to both sage.structure.factory and sage.structure.unique_representation, also adding new tests.



---

archive/issue_comments_187156.json:
```json
{
    "body": "I have replaced my patch by an updated version. The new patch version addresses your complaint about \"idempotent preprocessing\", elaborating a bit more and adding an example that shows what goes wrong if the pre-processing is not idempotent.",
    "created_at": "2013-08-10T10:21:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187156",
    "user": "https://github.com/simon-king-jena"
}
```

I have replaced my patch by an updated version. The new patch version addresses your complaint about "idempotent preprocessing", elaborating a bit more and adding an example that shows what goes wrong if the pre-processing is not idempotent.



---

archive/issue_comments_187157.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-08-10T16:49:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187157",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_187158.json:
```json
{
    "body": "I am just re-reading my patch. I find several typos/wrong grammar. In addition, in one of my examples I have a non-idempotent pre-processing. I should change it. Also, by mistake, in one of my examples one finds the version number of my Sage installation---this should of course replaced by \"...\".",
    "created_at": "2013-08-10T16:49:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187158",
    "user": "https://github.com/simon-king-jena"
}
```

I am just re-reading my patch. I find several typos/wrong grammar. In addition, in one of my examples I have a non-idempotent pre-processing. I should change it. Also, by mistake, in one of my examples one finds the version number of my Sage installation---this should of course replaced by "...".



---

archive/issue_comments_187159.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-08-10T19:06:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187159",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_187160.json:
```json
{
    "body": "I hope all problems are solved with the new patch version...",
    "created_at": "2013-08-10T19:06:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187160",
    "user": "https://github.com/simon-king-jena"
}
```

I hope all problems are solved with the new patch version...



---

archive/issue_comments_187161.json:
```json
{
    "body": "Just a couple typos fixed. Feel free to qfold into your patch. This is not a review, sorry (I don't have the competence to do it; I barely understood the UniqueRepresentation part and I know about nothing on Python's OOP).",
    "created_at": "2013-08-11T14:20:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187161",
    "user": "https://github.com/darijgr"
}
```

Just a couple typos fixed. Feel free to qfold into your patch. This is not a review, sorry (I don't have the competence to do it; I barely understood the UniqueRepresentation part and I know about nothing on Python's OOP).



---

archive/issue_comments_187162.json:
```json
{
    "body": "Attachment [trac_14912-typos-dg.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-typos-dg.patch) by @darijgr created at 2013-08-11 14:22:44\n\nThanks for the patch, which made several things clear to me (probably not enough to be able to decide whether to use factories or unique rep -- but at least a good idea how to). I fear somebody who actually knows some OOP will have to review it. The above attachment fixes a couple typos.",
    "created_at": "2013-08-11T14:22:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187162",
    "user": "https://github.com/darijgr"
}
```

Attachment [trac_14912-typos-dg.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-typos-dg.patch) by @darijgr created at 2013-08-11 14:22:44

Thanks for the patch, which made several things clear to me (probably not enough to be able to decide whether to use factories or unique rep -- but at least a good idea how to). I fear somebody who actually knows some OOP will have to review it. The above attachment fixes a couple typos.



---

archive/issue_comments_187163.json:
```json
{
    "body": "Hi Darij,\n\nThank you for fixing the typos!\n\nReplying to [comment:17 darij]:\n> Thanks for the patch, which made several things clear to me (probably not enough to be able to decide whether to use factories or unique rep -- but at least a good idea how to).\n> ... I don't have the competence to do it; I barely understood the `UniqueRepresentation` part and I know about nothing on Python's OOP\n\n\n\nIn a way, this means that you are fully qualified as a reviewer. This is about documentation, and thus if you think that some points are still not addressed then you should speak up! What information do you find missing? Is it\n- the definition of cached/unique representation?\n- the design pattern: Why should one want to have cached/unique representation?\n- how to implement a cached/unique representation?\n- Python background: What is a metaclass? What happens during instantiation of a class?\n- how to avoid pitfalls?\n- else?",
    "created_at": "2013-08-12T13:23:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187163",
    "user": "https://github.com/simon-king-jena"
}
```

Hi Darij,

Thank you for fixing the typos!

Replying to [comment:17 darij]:
> Thanks for the patch, which made several things clear to me (probably not enough to be able to decide whether to use factories or unique rep -- but at least a good idea how to).
> ... I don't have the competence to do it; I barely understood the `UniqueRepresentation` part and I know about nothing on Python's OOP



In a way, this means that you are fully qualified as a reviewer. This is about documentation, and thus if you think that some points are still not addressed then you should speak up! What information do you find missing? Is it
- the definition of cached/unique representation?
- the design pattern: Why should one want to have cached/unique representation?
- how to implement a cached/unique representation?
- Python background: What is a metaclass? What happens during instantiation of a class?
- how to avoid pitfalls?
- else?



---

archive/issue_comments_187164.json:
```json
{
    "body": "One thing I'd be happy to know is what a staticmethod is -- but that's hardly a question for this patch.\n\nAnd yes, some doc on metaclasses and the instantiation process (I'm confused about what goes in __new__, what in __init__ and what in __classcall__) would be great.\n\nAs for the \"why\" of cached/unique representation, for me it's pretty clear already, and I think the definition in your doc is very readable.\n\nThanks a lot for the patience!",
    "created_at": "2013-08-12T13:35:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187164",
    "user": "https://github.com/darijgr"
}
```

One thing I'd be happy to know is what a staticmethod is -- but that's hardly a question for this patch.

And yes, some doc on metaclasses and the instantiation process (I'm confused about what goes in __new__, what in __init__ and what in __classcall__) would be great.

As for the "why" of cached/unique representation, for me it's pretty clear already, and I think the definition in your doc is very readable.

Thanks a lot for the patience!



---

archive/issue_comments_187165.json:
```json
{
    "body": "Attachment [trac14912-unique_doc.patch](tarball://root/attachments/some-uuid/ticket14912/trac14912-unique_doc.patch) by @simon-king-jena created at 2013-08-19 16:16:47\n\nCombined patch, including Darij's fixes",
    "created_at": "2013-08-19T16:16:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187165",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac14912-unique_doc.patch](tarball://root/attachments/some-uuid/ticket14912/trac14912-unique_doc.patch) by @simon-king-jena created at 2013-08-19 16:16:47

Combined patch, including Darij's fixes



---

archive/issue_comments_187166.json:
```json
{
    "body": "I have folded the two patches, and I have added a note on \"static methods\", including a link to the Python docs.\n\nI did not elaborate on `__new__` versus `__init__` versus `__classcall__`, yet.\n\nApply trac14912-unique_doc.patch",
    "created_at": "2013-08-19T16:20:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187166",
    "user": "https://github.com/simon-king-jena"
}
```

I have folded the two patches, and I have added a note on "static methods", including a link to the Python docs.

I did not elaborate on `__new__` versus `__init__` versus `__classcall__`, yet.

Apply trac14912-unique_doc.patch



---

archive/issue_comments_187167.json:
```json
{
    "body": "Replying to [comment:20 SimonKing]:\n> I have folded the two patches, and I have added a note on \"static methods\", including a link to the Python docs.\n\n\n... which was supposed to imply the question whether you find this helpful.",
    "created_at": "2013-08-19T16:20:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187167",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:20 SimonKing]:
> I have folded the two patches, and I have added a note on "static methods", including a link to the Python docs.


... which was supposed to imply the question whether you find this helpful.



---

archive/issue_comments_187168.json:
```json
{
    "body": "Hey Darij,\n\nThis is primarily a **ping** message asking Darij if he's happy with this ticket, but...\n\nThe ``@`staticmethod` is a python thing, which makes a method accessible via `ClassName.foo` and doesn't take a first argument of a type as opposed to ``@`classmethod`. If anything, this should belong with the `ClasscallMetaclass` documentation, but that's outside the scope of this ticket.\n\nBest,\n\nTravis",
    "created_at": "2013-08-30T00:55:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187168",
    "user": "https://github.com/tscrim"
}
```

Hey Darij,

This is primarily a **ping** message asking Darij if he's happy with this ticket, but...

The ``@`staticmethod` is a python thing, which makes a method accessible via `ClassName.foo` and doesn't take a first argument of a type as opposed to ``@`classmethod`. If anything, this should belong with the `ClasscallMetaclass` documentation, but that's outside the scope of this ticket.

Best,

Travis



---

archive/issue_comments_187169.json:
```json
{
    "body": "Sorry for letting this slip off my to-do list!\n\nI'm pretty sure that I've understood the important points of the doc now except for some that concern pickling (I don't know how it works and frankly I didn't plan on learning that). I'd feel better if I knew what exactly `__classcall__` does and (as I said) how it is distinguished from `__new__` and `__init__` (and if it calls them, in which order), but that might as well be a different patch.\n\nIs the comment I've added correct and is it relevant?\n\nI've replaced \"extension class\" by \"Cython extension-type class\", since they seem to be called either \"extension types\" or \"cdef classes\" but never \"extension classes\".\n\nI'd like more details on this:\n\n```\n104\t    In addition, it is required that a unique factory instance is provided \n105\t    with a name that allows to find its definition.\n```\nI assume this refers to the string parameter, e. g., in `F = MyFactory(\"__main__.F\")`; but what kind of path should it contain if it is to be used somewhere in a .py file rather than in a doctest? Just `F = MyFactory(\"F\")` ? What if it is defined inside a class?\n\nNot sure about this:\n\n```\nAnd \n \t408\twith a factory, it is possible to create the resulting instance by arguments \n \t409\tthat are different from the key used for caching.\n```\nDoesn't that also work with CachedRepresentation if one preprocesses by declaring `__classcall_private__`?\n\n`@`Travis: thank you, too.",
    "created_at": "2013-08-30T04:02:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187169",
    "user": "https://github.com/darijgr"
}
```

Sorry for letting this slip off my to-do list!

I'm pretty sure that I've understood the important points of the doc now except for some that concern pickling (I don't know how it works and frankly I didn't plan on learning that). I'd feel better if I knew what exactly `__classcall__` does and (as I said) how it is distinguished from `__new__` and `__init__` (and if it calls them, in which order), but that might as well be a different patch.

Is the comment I've added correct and is it relevant?

I've replaced "extension class" by "Cython extension-type class", since they seem to be called either "extension types" or "cdef classes" but never "extension classes".

I'd like more details on this:

```
104	    In addition, it is required that a unique factory instance is provided 
105	    with a name that allows to find its definition.
```
I assume this refers to the string parameter, e. g., in `F = MyFactory("__main__.F")`; but what kind of path should it contain if it is to be used somewhere in a .py file rather than in a doctest? Just `F = MyFactory("F")` ? What if it is defined inside a class?

Not sure about this:

```
And 
 	408	with a factory, it is possible to create the resulting instance by arguments 
 	409	that are different from the key used for caching.
```
Doesn't that also work with CachedRepresentation if one preprocesses by declaring `__classcall_private__`?

`@`Travis: thank you, too.



---

archive/issue_comments_187170.json:
```json
{
    "body": "Attachment [trac_14912-comments-dg.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-comments-dg.patch) by @darijgr created at 2013-11-08 22:54:24\n\nalmost a review",
    "created_at": "2013-11-08T22:54:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187170",
    "user": "https://github.com/darijgr"
}
```

Attachment [trac_14912-comments-dg.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-comments-dg.patch) by @darijgr created at 2013-11-08 22:54:24

almost a review



---

archive/issue_events_042891.json:
```json
{
    "actor": "https://github.com/darijgr",
    "created_at": "2013-11-08T22:57:32Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "milestone": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14708#event-42891"
}
```



---

archive/issue_comments_187171.json:
```json
{
    "body": "Thanks to Travis's insistence and also his help, I've more or less reviewed this one at last. The only part I wasn't able to understand is:\n\n```\n.. NOTE::\n\n    For technical reasons, it is needed that ``__classcall__`` respectively\n    ``__classcall_private__`` are \"static methods\", i.e., they are callable\n    objects that do not bind to an instance or class. For example, a\n    :class:`~sage.misc.cachefunc.cached_function` can be used here, because it\n    is callable, but does not bind to an instance or class, because it has no\n    ``__get__()`` method. A usual Python function, however, has a\n    ``__get__()`` method and would thus under normal circumstances bind to an\n    instance or class, and thus the instance or class would be passed to the\n    function as the first argument. To prevent a callable object from being\n    bound to the instance or class, one can prepend the ``@staticmethod``\n    decorator to the definition; see :class:`staticmethod`.\n```\nWell, maybe it's just that I have no idea what `__get__` methods do.\n\nfor the **patchbot**:\n\napply trac14912-unique_doc.patch\u200b trac_14912-comments-dg.patch",
    "created_at": "2013-11-08T22:57:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187171",
    "user": "https://github.com/darijgr"
}
```

Thanks to Travis's insistence and also his help, I've more or less reviewed this one at last. The only part I wasn't able to understand is:

```
.. NOTE::

    For technical reasons, it is needed that ``__classcall__`` respectively
    ``__classcall_private__`` are "static methods", i.e., they are callable
    objects that do not bind to an instance or class. For example, a
    :class:`~sage.misc.cachefunc.cached_function` can be used here, because it
    is callable, but does not bind to an instance or class, because it has no
    ``__get__()`` method. A usual Python function, however, has a
    ``__get__()`` method and would thus under normal circumstances bind to an
    instance or class, and thus the instance or class would be passed to the
    function as the first argument. To prevent a callable object from being
    bound to the instance or class, one can prepend the ``@staticmethod``
    decorator to the definition; see :class:`staticmethod`.
```
Well, maybe it's just that I have no idea what `__get__` methods do.

for the **patchbot**:

apply trac14912-unique_doc.patch​ trac_14912-comments-dg.patch



---

archive/issue_comments_187172.json:
```json
{
    "body": "Replying to [comment:23 darij]:\n> Sorry for letting this slip off my to-do list!\n\n\nSame here...\n\n> I'm pretty sure that I've understood the important points of the doc now except for some that concern pickling (I don't know how it works and frankly I didn't plan on learning that). I'd feel better if I knew what exactly `__classcall__` does and (as I said) how it is distinguished from `__new__` and `__init__` (and if it calls them, in which order), but that might as well be a different patch.\n\n\nIn a nutshell: If `C` is a class with `ClasscallMetaclass`, then `__classcall__` (or `__classcall_private__`) is what is executed when you do `C(*args, **kwds)`.\n\nYour `__classcall__` can do *anything*. Really. It could return an instance of `C`, but it could also return something totally different.\n\nConsequence: `__new__` or `__init__` are *only* called if you did not forget to call them inside of your `__classcall__`. If you look at what `CachedRepresentation.__classcall__` does, you see that indeed `__new__` and `__init__` are called explicitly.\n\n> I'd like more details on this:\n> \n> ```\n> 104\t    In addition, it is required that a unique factory instance is provided \n> 105\t    with a name that allows to find its definition.\n> ```\n> I assume this refers to the string parameter, e. g., in `F = MyFactory(\"__main__.F\")`;\n\n\nExactly.\n\n> but what kind of path should it contain if it is to be used somewhere in a .py file rather than in a doctest? Just `F = MyFactory(\"F\")` ?\n\n\nIt is exactly as it is stated: A name is needed that allows to find the factory's definition. Hence, if you put `F` into the global name space, then `F = MyFactory(\"F\")` is fine. If `F` is in a module `sage.foo.bar`, then it is `F = MyFactory(\"sage.foo.bar.F\")`.\n\n> What if it is defined inside a class?\n\n\nIf the class is `sage.bar.foo.MyClass` and you want to use a factory for the attribute `F` of this class, then I guess it is `F = MyFactory(\"sage.bar.foo.MyClass.F\"). Not tested, though.\n\n> Not sure about this:\n> \n> ```\n> And \n>  \t408\twith a factory, it is possible to create the resulting instance by arguments \n>  \t409\tthat are different from the key used for caching.\n> ```\n> Doesn't that also work with CachedRepresentation if one preprocesses by declaring `__classcall_private__`?\n\n\nYes. This could be clarified.",
    "created_at": "2013-11-09T08:17:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187172",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:23 darij]:
> Sorry for letting this slip off my to-do list!


Same here...

> I'm pretty sure that I've understood the important points of the doc now except for some that concern pickling (I don't know how it works and frankly I didn't plan on learning that). I'd feel better if I knew what exactly `__classcall__` does and (as I said) how it is distinguished from `__new__` and `__init__` (and if it calls them, in which order), but that might as well be a different patch.


In a nutshell: If `C` is a class with `ClasscallMetaclass`, then `__classcall__` (or `__classcall_private__`) is what is executed when you do `C(*args, **kwds)`.

Your `__classcall__` can do *anything*. Really. It could return an instance of `C`, but it could also return something totally different.

Consequence: `__new__` or `__init__` are *only* called if you did not forget to call them inside of your `__classcall__`. If you look at what `CachedRepresentation.__classcall__` does, you see that indeed `__new__` and `__init__` are called explicitly.

> I'd like more details on this:
> 
> ```
> 104	    In addition, it is required that a unique factory instance is provided 
> 105	    with a name that allows to find its definition.
> ```
> I assume this refers to the string parameter, e. g., in `F = MyFactory("__main__.F")`;


Exactly.

> but what kind of path should it contain if it is to be used somewhere in a .py file rather than in a doctest? Just `F = MyFactory("F")` ?


It is exactly as it is stated: A name is needed that allows to find the factory's definition. Hence, if you put `F` into the global name space, then `F = MyFactory("F")` is fine. If `F` is in a module `sage.foo.bar`, then it is `F = MyFactory("sage.foo.bar.F")`.

> What if it is defined inside a class?


If the class is `sage.bar.foo.MyClass` and you want to use a factory for the attribute `F` of this class, then I guess it is `F = MyFactory("sage.bar.foo.MyClass.F"). Not tested, though.

> Not sure about this:
> 
> ```
> And 
>  	408	with a factory, it is possible to create the resulting instance by arguments 
>  	409	that are different from the key used for caching.
> ```
> Doesn't that also work with CachedRepresentation if one preprocesses by declaring `__classcall_private__`?


Yes. This could be clarified.



---

archive/issue_comments_187173.json:
```json
{
    "body": "Hi Darij,\n\nthe review patch looks fine. Disclaimer: I did not test whether the documentation builds fine after the changes introduced by the review patch. IIRC, it *did* build (and look) fine with my patch.\n\nReplying to [comment:24 darij]:\n> Thanks to Travis's insistence and also his help, I've more or less reviewed this one at last. The only part I wasn't able to understand is:\n> \n> ```\n> .. NOTE::\n> \n>     For technical reasons, it is needed that ``__classcall__`` respectively\n>     ``__classcall_private__`` are \"static methods\", i.e., they are callable\n>     objects that do not bind to an instance or class. For example, a\n>     :class:`~sage.misc.cachefunc.cached_function` can be used here, because it\n>     is callable, but does not bind to an instance or class, because it has no\n>     ``__get__()`` method. A usual Python function, however, has a\n>     ``__get__()`` method and would thus under normal circumstances bind to an\n>     instance or class, and thus the instance or class would be passed to the\n>     function as the first argument. To prevent a callable object from being\n>     bound to the instance or class, one can prepend the ``@staticmethod``\n>     decorator to the definition; see :class:`staticmethod`.\n> ```\n> Well, maybe it's just that I have no idea what `__get__` methods do.\n\n\nOK. Then one should add a pointer to the Python references. Travis, Do you have an idea what page to point to?",
    "created_at": "2013-11-09T08:21:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187173",
    "user": "https://github.com/simon-king-jena"
}
```

Hi Darij,

the review patch looks fine. Disclaimer: I did not test whether the documentation builds fine after the changes introduced by the review patch. IIRC, it *did* build (and look) fine with my patch.

Replying to [comment:24 darij]:
> Thanks to Travis's insistence and also his help, I've more or less reviewed this one at last. The only part I wasn't able to understand is:
> 
> ```
> .. NOTE::
> 
>     For technical reasons, it is needed that ``__classcall__`` respectively
>     ``__classcall_private__`` are "static methods", i.e., they are callable
>     objects that do not bind to an instance or class. For example, a
>     :class:`~sage.misc.cachefunc.cached_function` can be used here, because it
>     is callable, but does not bind to an instance or class, because it has no
>     ``__get__()`` method. A usual Python function, however, has a
>     ``__get__()`` method and would thus under normal circumstances bind to an
>     instance or class, and thus the instance or class would be passed to the
>     function as the first argument. To prevent a callable object from being
>     bound to the instance or class, one can prepend the ``@staticmethod``
>     decorator to the definition; see :class:`staticmethod`.
> ```
> Well, maybe it's just that I have no idea what `__get__` methods do.


OK. Then one should add a pointer to the Python references. Travis, Do you have an idea what page to point to?



---

archive/issue_comments_187174.json:
```json
{
    "body": "Thanks for these clarifications!\n\nReplying to [comment:25 SimonKing]:\n> Replying to [comment:23 darij]:\n> > I'd like more details on this:\n> > \n> > ```\n> > 104\t    In addition, it is required that a unique factory instance is provided \n> > 105\t    with a name that allows to find its definition.\n> > ```\n> > I assume this refers to the string parameter, e. g., in `F = MyFactory(\"__main__.F\")`;\n\n> \n> Exactly.\n> \n> > but what kind of path should it contain if it is to be used somewhere in a .py file rather than in a doctest? Just `F = MyFactory(\"F\")` ?\n\n> \n> It is exactly as it is stated: A name is needed that allows to find the factory's definition. Hence, if you put `F` into the global name space, then `F = MyFactory(\"F\")` is fine. If `F` is in a module `sage.foo.bar`, then it is `F = MyFactory(\"sage.foo.bar.F\")`.\n> \n> > What if it is defined inside a class?\n\n> \n> If the class is `sage.bar.foo.MyClass` and you want to use a factory for the attribute `F` of this class, then I guess it is `F = MyFactory(\"sage.bar.foo.MyClass.F\"). Not tested, though.\n\n\nYeah, these things could very well be explained in the doc itself.\n\n> > Not sure about this:\n> > \n> > ```\n> > And \n> >  \t408\twith a factory, it is possible to create the resulting instance by arguments \n> >  \t409\tthat are different from the key used for caching.\n> > ```\n> > Doesn't that also work with CachedRepresentation if one preprocesses by declaring `__classcall_private__`?\n\n> \n> Yes. This could be clarified.\n\n\nKind-of; on the other hand, the preprocessing probably needs to be idempotent for pickling to work well, so we have a serious restriction...",
    "created_at": "2013-11-09T08:21:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187174",
    "user": "https://github.com/darijgr"
}
```

Thanks for these clarifications!

Replying to [comment:25 SimonKing]:
> Replying to [comment:23 darij]:
> > I'd like more details on this:
> > 
> > ```
> > 104	    In addition, it is required that a unique factory instance is provided 
> > 105	    with a name that allows to find its definition.
> > ```
> > I assume this refers to the string parameter, e. g., in `F = MyFactory("__main__.F")`;

> 
> Exactly.
> 
> > but what kind of path should it contain if it is to be used somewhere in a .py file rather than in a doctest? Just `F = MyFactory("F")` ?

> 
> It is exactly as it is stated: A name is needed that allows to find the factory's definition. Hence, if you put `F` into the global name space, then `F = MyFactory("F")` is fine. If `F` is in a module `sage.foo.bar`, then it is `F = MyFactory("sage.foo.bar.F")`.
> 
> > What if it is defined inside a class?

> 
> If the class is `sage.bar.foo.MyClass` and you want to use a factory for the attribute `F` of this class, then I guess it is `F = MyFactory("sage.bar.foo.MyClass.F"). Not tested, though.


Yeah, these things could very well be explained in the doc itself.

> > Not sure about this:
> > 
> > ```
> > And 
> >  	408	with a factory, it is possible to create the resulting instance by arguments 
> >  	409	that are different from the key used for caching.
> > ```
> > Doesn't that also work with CachedRepresentation if one preprocesses by declaring `__classcall_private__`?

> 
> Yes. This could be clarified.


Kind-of; on the other hand, the preprocessing probably needs to be idempotent for pickling to work well, so we have a serious restriction...



---

archive/issue_comments_187175.json:
```json
{
    "body": "Replying to [comment:26 SimonKing]:\n> > Well, maybe it's just that I have no idea what `__get__` methods do.\n\n> \n> OK. Then one should add a pointer to the Python references. Travis, Do you have an idea what page to point to?\n\n\nHey Simon,\n\nMy thought would be this: http://docs.python.org/2/howto/descriptor.html (I showed this to Darij the other day).",
    "created_at": "2013-11-09T23:49:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187175",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:26 SimonKing]:
> > Well, maybe it's just that I have no idea what `__get__` methods do.

> 
> OK. Then one should add a pointer to the Python references. Travis, Do you have an idea what page to point to?


Hey Simon,

My thought would be this: http://docs.python.org/2/howto/descriptor.html (I showed this to Darij the other day).



---

archive/issue_comments_187176.json:
```json
{
    "body": "Attachment [trac_14912-link_tweaks-ts.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-link_tweaks-ts.patch) by @tscrim created at 2013-11-23 07:04:28",
    "created_at": "2013-11-23T07:04:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187176",
    "user": "https://github.com/tscrim"
}
```

Attachment [trac_14912-link_tweaks-ts.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-link_tweaks-ts.patch) by @tscrim created at 2013-11-23 07:04:28



---

archive/issue_comments_187177.json:
```json
{
    "body": "I'm prepared to set this to positive review (barring my tweaks being review), but I'd like to know what else is desired to be added and where (if anything).\n\nFor patchbot;\n\nApply: trac14912-unique_doc.patch\u200b, trac_14912-comments-dg.patch\u200b, trac_14912-link_tweaks-ts.patch\u200b",
    "created_at": "2013-11-23T07:20:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187177",
    "user": "https://github.com/tscrim"
}
```

I'm prepared to set this to positive review (barring my tweaks being review), but I'd like to know what else is desired to be added and where (if anything).

For patchbot;

Apply: trac14912-unique_doc.patch​, trac_14912-comments-dg.patch​, trac_14912-link_tweaks-ts.patch​



---

archive/issue_comments_187178.json:
```json
{
    "body": "Oops, I've just edited Travis's patch instead of qnewing my own. So glad I soon won't have the hg workflow anymore to trip over...\n\nAnyway, here is my \"review patch\". It is not so much as a review but a more informative documentation of what exactly to do with `UniqueFactory`. Now, \"more informative\" does not necessarily mean \"correct\", so I'd much prefer someone more experienced than me to look this through (particularly, but not only, checking my interpretation of `other_keys`).\n\nI still don't grok the note about the `__classcall__` method being static in the unique representation doc, but I didn't really have the time to RTFM about descriptors. If the note is clear to you, Travis, just say so and it will plug this hole in my review.\n\nfor the **patchbot**:\n\napply trac14912-unique_doc.patch\u200b trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch",
    "created_at": "2013-11-26T05:39:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187178",
    "user": "https://github.com/darijgr"
}
```

Oops, I've just edited Travis's patch instead of qnewing my own. So glad I soon won't have the hg workflow anymore to trip over...

Anyway, here is my "review patch". It is not so much as a review but a more informative documentation of what exactly to do with `UniqueFactory`. Now, "more informative" does not necessarily mean "correct", so I'd much prefer someone more experienced than me to look this through (particularly, but not only, checking my interpretation of `other_keys`).

I still don't grok the note about the `__classcall__` method being static in the unique representation doc, but I didn't really have the time to RTFM about descriptors. If the note is clear to you, Travis, just say so and it will plug this hole in my review.

for the **patchbot**:

apply trac14912-unique_doc.patch​ trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch



---

archive/issue_comments_187179.json:
```json
{
    "body": "beware of unvisible characters ! \n\napply trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch",
    "created_at": "2013-11-26T09:01:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187179",
    "user": "https://github.com/fchapoton"
}
```

beware of unvisible characters ! 

apply trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch



---

archive/issue_comments_187180.json:
```json
{
    "body": "Replying to [comment:31 chapoton]:\n> beware of unvisible characters ! \n\n\nIndeed. The third patch introduces some blank space.\n\n```\nNotice that the objects created by the factory inherit neither from \nthe factory class, nor from the factory instance (which is not even a \nclass). In fact, they don't even know about the factory that created \nthem! \n```\nApart from the blank space after the \"!\" (AFAIK, there is no blank space *before* \"!\", \":\" and \";\", in contrast to French), I am not happy with the statement that the instances don't even know about the factory that created them:\n\n```\nsage: F = GF(5)\nsage: F._factory_data\n(<class 'sage.rings.finite_rings.constructor.FiniteFieldFactory'>,\n (5, 13, 'beta3'),\n (5, None, None, 'modn', '{}', 5, 1, True),\n {})\nsage: _[0] is GF\nTrue\n```\nThis actually is how pickling is implemented (namely: By keeping a reference to the creating factory, plus the arguments used to call the factory).",
    "created_at": "2013-11-26T09:35:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187180",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:31 chapoton]:
> beware of unvisible characters ! 


Indeed. The third patch introduces some blank space.

```
Notice that the objects created by the factory inherit neither from 
the factory class, nor from the factory instance (which is not even a 
class). In fact, they don't even know about the factory that created 
them! 
```
Apart from the blank space after the "!" (AFAIK, there is no blank space *before* "!", ":" and ";", in contrast to French), I am not happy with the statement that the instances don't even know about the factory that created them:

```
sage: F = GF(5)
sage: F._factory_data
(<class 'sage.rings.finite_rings.constructor.FiniteFieldFactory'>,
 (5, 13, 'beta3'),
 (5, None, None, 'modn', '{}', 5, 1, True),
 {})
sage: _[0] is GF
True
```
This actually is how pickling is implemented (namely: By keeping a reference to the creating factory, plus the arguments used to call the factory).



---

archive/issue_comments_187181.json:
```json
{
    "body": "The docbuild gives warnings:\n\n```\ndochtml.log:[structure] /scratch/release/merger/sage-5.13.beta5/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:docstring of sage.structure.unique_representation:127: WARNING: Block quote ends without a blank line; unexpected unindent.\ndochtml.log:[structure] /scratch/release/merger/sage-5.13.beta5/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:docstring of sage.structure.unique_representation:129: ERROR: Unexpected indentation.\n```",
    "created_at": "2013-11-26T16:27:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187181",
    "user": "https://github.com/jdemeyer"
}
```

The docbuild gives warnings:

```
dochtml.log:[structure] /scratch/release/merger/sage-5.13.beta5/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:docstring of sage.structure.unique_representation:127: WARNING: Block quote ends without a blank line; unexpected unindent.
dochtml.log:[structure] /scratch/release/merger/sage-5.13.beta5/local/lib/python2.7/site-packages/sage/structure/unique_representation.py:docstring of sage.structure.unique_representation:129: ERROR: Unexpected indentation.
```



---

archive/issue_comments_187182.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2013-11-26T16:27:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187182",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_187183.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-11-26T18:25:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187183",
    "user": "https://github.com/darijgr"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_187184.json:
```json
{
    "body": "Fixed false claim about factory-created objects being oblivious of their making (thanks Simon!). Couldn't find the blank space after \"!\" claimed by Simon, but removed some other useless whitespaces. HOPEFULLY fixed Jeroen's docbuild warnings. Made some mini-fixes to unique_representation, including changing \"argument\" to \"arguments\" in the `__reduce__` docstring.\n\nThanks Frederic! (I'd be happier if I new where those symbols are coming from in the first place. Copypasting the names of the attachments from html maybe?)\n\nfor the **patchbot**:\n\napply trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch",
    "created_at": "2013-11-26T18:25:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187184",
    "user": "https://github.com/darijgr"
}
```

Fixed false claim about factory-created objects being oblivious of their making (thanks Simon!). Couldn't find the blank space after "!" claimed by Simon, but removed some other useless whitespaces. HOPEFULLY fixed Jeroen's docbuild warnings. Made some mini-fixes to unique_representation, including changing "argument" to "arguments" in the `__reduce__` docstring.

Thanks Frederic! (I'd be happier if I new where those symbols are coming from in the first place. Copypasting the names of the attachments from html maybe?)

for the **patchbot**:

apply trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch



---

archive/issue_comments_187185.json:
```json
{
    "body": "Attachment [trac_14912-more-ts-dg.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-more-ts-dg.patch) by @darijgr created at 2013-11-29 23:16:25\n\nincludes Travis' link tweaks. proofread by Travis",
    "created_at": "2013-11-29T23:16:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187185",
    "user": "https://github.com/darijgr"
}
```

Attachment [trac_14912-more-ts-dg.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-more-ts-dg.patch) by @darijgr created at 2013-11-29 23:16:25

includes Travis' link tweaks. proofread by Travis



---

archive/issue_comments_187186.json:
```json
{
    "body": "Everything looks good to me, so I'm going to set this to positive review. However feel free to object.\n\nFor patchbot:\n\nApply: trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch",
    "created_at": "2013-11-29T23:57:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187186",
    "user": "https://github.com/tscrim"
}
```

Everything looks good to me, so I'm going to set this to positive review. However feel free to object.

For patchbot:

Apply: trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch



---

archive/issue_comments_187187.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-11-29T23:58:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187187",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_187188.json:
```json
{
    "body": "Thank you Simon and Darij for your work on this!",
    "created_at": "2013-11-29T23:58:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187188",
    "user": "https://github.com/tscrim"
}
```

Thank you Simon and Darij for your work on this!



---

archive/issue_comments_187189.json:
```json
{
    "body": "```\nsage -t devel/sage/sage/structure/unique_representation.py\n**********************************************************************\nFile \"devel/sage/sage/structure/unique_representation.py\", line 455, in sage.structure.unique_representation\nFailed example:\n    type(Kp)\nExpected:\n    <class 'sage.rings.finite_rings.finite_field_ext_pari.FiniteField_ext_pari_with_category'>\nGot:\n    <class 'sage.rings.finite_rings.finite_field_pari_ffelt.FiniteField_pari_ffelt_with_category'>\n**********************************************************************\nFile \"devel/sage/sage/structure/unique_representation.py\", line 814, in sage.structure.unique_representation.CachedRepresentation\nFailed example:\n    n == id(SymmetricGroup(17))\nExpected:\n    False\nGot:\n    True\n**********************************************************************\n```",
    "created_at": "2013-12-02T09:48:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187189",
    "user": "https://github.com/jdemeyer"
}
```

```
sage -t devel/sage/sage/structure/unique_representation.py
**********************************************************************
File "devel/sage/sage/structure/unique_representation.py", line 455, in sage.structure.unique_representation
Failed example:
    type(Kp)
Expected:
    <class 'sage.rings.finite_rings.finite_field_ext_pari.FiniteField_ext_pari_with_category'>
Got:
    <class 'sage.rings.finite_rings.finite_field_pari_ffelt.FiniteField_pari_ffelt_with_category'>
**********************************************************************
File "devel/sage/sage/structure/unique_representation.py", line 814, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    n == id(SymmetricGroup(17))
Expected:
    False
Got:
    True
**********************************************************************
```



---

archive/issue_comments_187190.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2013-12-02T09:48:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187190",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_187191.json:
```json
{
    "body": "The first \"error\" is due to #14888.",
    "created_at": "2013-12-02T09:51:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187191",
    "user": "https://github.com/jdemeyer"
}
```

The first "error" is due to #14888.



---

archive/issue_comments_187192.json:
```json
{
    "body": "The second error happens even with a clean version of Sage 5.12.",
    "created_at": "2013-12-02T10:36:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187192",
    "user": "https://github.com/jdemeyer"
}
```

The second error happens even with a clean version of Sage 5.12.



---

archive/issue_comments_187193.json:
```json
{
    "body": "Hm. In a freshly build sage-5.13.b4, I get\n\n```\n        sage: n = id(SymmetricGroup(17))\n        sage: import gc\n        sage: _ = gc.collect()\n        sage: n == id(SymmetricGroup(17))\n        False\n```\nbut I get \"True\" if the same is done as a doc test.\n\nSo, rather than relying on the id, I will create a test that demonstrates that this group becomes garbage collected.",
    "created_at": "2013-12-02T14:13:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187193",
    "user": "https://github.com/simon-king-jena"
}
```

Hm. In a freshly build sage-5.13.b4, I get

```
        sage: n = id(SymmetricGroup(17))
        sage: import gc
        sage: _ = gc.collect()
        sage: n == id(SymmetricGroup(17))
        False
```
but I get "True" if the same is done as a doc test.

So, rather than relying on the id, I will create a test that demonstrates that this group becomes garbage collected.



---

archive/issue_comments_187194.json:
```json
{
    "body": "For example:\n\n```\nsage: S = SymmetricGroup(17)\nsage: n = id(S)\nsage: import gc\nsage: _ = gc.collect()\nsage: n in [id(x) for x in gc.get_objects()]\nTrue\nsage: del S\nsage: _ = gc.collect()\nsage: n in [id(x) for x in gc.get_objects()]\nFalse\n```\nThat's a better test.",
    "created_at": "2013-12-02T14:14:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187194",
    "user": "https://github.com/simon-king-jena"
}
```

For example:

```
sage: S = SymmetricGroup(17)
sage: n = id(S)
sage: import gc
sage: _ = gc.collect()
sage: n in [id(x) for x in gc.get_objects()]
True
sage: del S
sage: _ = gc.collect()
sage: n in [id(x) for x in gc.get_objects()]
False
```
That's a better test.



---

archive/issue_comments_187195.json:
```json
{
    "body": "WTF??\n\nAgain, if I run the same thing as doctest, then the answer in the last line is \"True\", not \"False\". Hence, the symmetric group gets collected in an interactive session, but not in a test!",
    "created_at": "2013-12-02T14:16:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187195",
    "user": "https://github.com/simon-king-jena"
}
```

WTF??

Again, if I run the same thing as doctest, then the answer in the last line is "True", not "False". Hence, the symmetric group gets collected in an interactive session, but not in a test!



---

archive/issue_comments_187196.json:
```json
{
    "body": "I am still shocked that garbage collection works differently in doc tests than in an interactive session, but anyway: Here is an example that works both interactively in in a doc test.\n\n```\n        sage: class SomeClass(UniqueRepresentation):\n        ....:     def __init__(self, i):\n        ....:         print \"creating new instance for argument %s\"%i\n        ....:         self.i = i\n        ....:     def __del__(self):\n        ....:         print \"deleting instance for argument %s\"%self.i\n        ....:         \n        sage: O = SomeClass(1)\n        creating new instance for argument 1\n        sage: O is SomeClass(1)\n        True\n        sage: O is SomeClass(2)\n        creating new instance for argument 2\n        deleting instance for argument 2\n        False\n        sage: del O\n        deleting instance for argument 1\n        sage: O = SomeClass(1)\n        creating new instance for argument 1\n```",
    "created_at": "2013-12-02T14:22:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187196",
    "user": "https://github.com/simon-king-jena"
}
```

I am still shocked that garbage collection works differently in doc tests than in an interactive session, but anyway: Here is an example that works both interactively in in a doc test.

```
        sage: class SomeClass(UniqueRepresentation):
        ....:     def __init__(self, i):
        ....:         print "creating new instance for argument %s"%i
        ....:         self.i = i
        ....:     def __del__(self):
        ....:         print "deleting instance for argument %s"%self.i
        ....:         
        sage: O = SomeClass(1)
        creating new instance for argument 1
        sage: O is SomeClass(1)
        True
        sage: O is SomeClass(2)
        creating new instance for argument 2
        deleting instance for argument 2
        False
        sage: del O
        deleting instance for argument 1
        sage: O = SomeClass(1)
        creating new instance for argument 1
```



---

archive/issue_comments_187197.json:
```json
{
    "body": "Attachment [trac_14912-doc-fixes-sk.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-doc-fixes-sk.patch) by @simon-king-jena created at 2013-12-02 14:27:31",
    "created_at": "2013-12-02T14:27:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187197",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac_14912-doc-fixes-sk.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-doc-fixes-sk.patch) by @simon-king-jena created at 2013-12-02 14:27:31



---

archive/issue_comments_187198.json:
```json
{
    "body": "Fixed! Please review!\n\nApply trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch trac_14912-doc-fixes-sk.patch",
    "created_at": "2013-12-02T14:28:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187198",
    "user": "https://github.com/simon-king-jena"
}
```

Fixed! Please review!

Apply trac14912-unique_doc.patch trac_14912-comments-dg.patch trac_14912-more-ts-dg.patch trac_14912-doc-fixes-sk.patch



---

archive/issue_comments_187199.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2013-12-02T14:28:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187199",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_187200.json:
```json
{
    "body": "Replying to [comment:34 darij]:\n> Couldn't find the blank space after \"!\" claimed by Simon,\n\n\nSorry, my mistake. In order to find trailing whitespace, I went to the html page of the patch and marked some lines, thus highlighting all characters. And it did look like a highlighted blank spaces after the exclamation mark. But when I looked at the patch itself, it was fine.\n\nBest regards,\nSimon",
    "created_at": "2013-12-02T14:51:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187200",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:34 darij]:
> Couldn't find the blank space after "!" claimed by Simon,


Sorry, my mistake. In order to find trailing whitespace, I went to the html page of the patch and marked some lines, thus highlighting all characters. And it did look like a highlighted blank spaces after the exclamation mark. But when I looked at the patch itself, it was fine.

Best regards,
Simon



---

archive/issue_comments_187201.json:
```json
{
    "body": "I will not review the patch, but at least doctests pass now.",
    "created_at": "2013-12-02T22:03:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187201",
    "user": "https://github.com/jdemeyer"
}
```

I will not review the patch, but at least doctests pass now.



---

archive/issue_comments_187202.json:
```json
{
    "body": "I like how your new doctest showcases automatic garbage collection, but what do you think about keeping the old doctest in with a `# not tested` and a comment on how it usually works in the console and demonstrates the non-invariance of the id?\n\n(In my very limited understanding, the doctest environment tries hard at replacing all kind of randomness by determinism, so I'm not surprised that two `id`s end up being the same even if they are created differently.)",
    "created_at": "2013-12-03T01:56:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187202",
    "user": "https://github.com/darijgr"
}
```

I like how your new doctest showcases automatic garbage collection, but what do you think about keeping the old doctest in with a `# not tested` and a comment on how it usually works in the console and demonstrates the non-invariance of the id?

(In my very limited understanding, the doctest environment tries hard at replacing all kind of randomness by determinism, so I'm not surprised that two `id`s end up being the same even if they are created differently.)



---

archive/issue_comments_187203.json:
```json
{
    "body": "Replying to [comment:48 darij]:\n> (In my very limited understanding, the doctest environment tries hard at replacing all kind of randomness by determinism, so I'm not surprised that two `id`s end up being the same even if they are created differently.)\n\nNobody has any control on the memory locations of allocated objects. The doctests do use `set_random_seed()`, but I very much doubt that this has any influence on `id`.",
    "created_at": "2013-12-03T07:51:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187203",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:48 darij]:
> (In my very limited understanding, the doctest environment tries hard at replacing all kind of randomness by determinism, so I'm not surprised that two `id`s end up being the same even if they are created differently.)

Nobody has any control on the memory locations of allocated objects. The doctests do use `set_random_seed()`, but I very much doubt that this has any influence on `id`.



---

archive/issue_comments_187204.json:
```json
{
    "body": "I would recommend against using my old suggestion --- \"id\" is an implementation detail and depends on randomness, beyond anything that is controllable by random seeds. So, even when it is marked as `# not tested`, I think it would not be very helpful to show a test against \"id\".",
    "created_at": "2013-12-03T11:29:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187204",
    "user": "https://github.com/simon-king-jena"
}
```

I would recommend against using my old suggestion --- "id" is an implementation detail and depends on randomness, beyond anything that is controllable by random seeds. So, even when it is marked as `# not tested`, I think it would not be very helpful to show a test against "id".



---

archive/issue_comments_187205.json:
```json
{
    "body": "The unpredictability of `id` boils down to the unpredictability of `malloc()`: if one does\n\n```\nchar *a = malloc(s);\nfree(a);\nchar *b = malloc(s);\nfree(b);\n```\nit is impossible to say whether `a` and `b` will be equal.",
    "created_at": "2013-12-03T12:18:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187205",
    "user": "https://github.com/jdemeyer"
}
```

The unpredictability of `id` boils down to the unpredictability of `malloc()`: if one does

```
char *a = malloc(s);
free(a);
char *b = malloc(s);
free(b);
```
it is impossible to say whether `a` and `b` will be equal.



---

archive/issue_comments_187206.json:
```json
{
    "body": "Any chance for a final review? It would be nice to get this into Sage 5.13.",
    "created_at": "2013-12-06T10:46:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187206",
    "user": "https://github.com/jdemeyer"
}
```

Any chance for a final review? It would be nice to get this into Sage 5.13.



---

archive/issue_comments_187207.json:
```json
{
    "body": "Hey Simon,\n\nWith `sage-5.13.beta2`, I get:\n\n```\nsage -t unique_representation.py\n**********************************************************************\nFile \"unique_representation.py\", line 822, in sage.structure.unique_representation.CachedRepresentation\nFailed example:\n    O is SomeClass(2)\nExpected:\n    creating new instance for argument 2\n    deleting instance for argument 2\n    False\nGot:\n    creating new instance for argument 2\n    False\n**********************************************************************\nFile \"unique_representation.py\", line 826, in sage.structure.unique_representation.CachedRepresentation\nFailed example:\n    del O\nExpected:\n    deleting instance for argument 1\nGot:\n    <BLANKLINE>\n**********************************************************************\nFile \"unique_representation.py\", line 828, in sage.structure.unique_representation.CachedRepresentation\nFailed example:\n    O = SomeClass(1)\nExpected:\n    creating new instance for argument 1\nGot:\n    <BLANKLINE>\n**********************************************************************\n1 item had failures:\n   3 of  89 in sage.structure.unique_representation.CachedRepresentation\n    [229 tests, 3 failures, 4.18 s]\n----------------------------------------------------------------------\nsage -t unique_representation.py  # 3 doctests failed\n----------------------------------------------------------------------\n```\nwith the following patches applied:\n\n```\ntrac_15327-qfold-dg.patch\ntrac_15327-fixes-dg.patch\ntrac_15305-coercion_tensor_products-ts.patch\ntrac13394-weak_value_dictionary.patch\ntrac_15311-hall_algebras-ts.patch\ntrac_10963-more_functorial_constructions-nt.patch\ntrac_10963-more_functorial_constructions-graded-modules-fix-nt.patch\ntrac_10963_doctest_correction-fc.patch\ntrac_14102-nonsymmetric-macdonald.patch\ntrac9107_nesting_nested_classes.patch\ntrac_9107_fix_cross_reference.patch\ntrac_14685_bug_aorder_lazypowerseries.patch\ntrac_15150-ncsym-ts.patch\ntrac_15174-qfold1.patch\ntrac_15174-final-touches-dg.patch\ntrac_15174-review-ts.patch\ntrac14912-unique_doc.patch\ntrac_14912-comments-dg.patch\ntrac_14912-more-ts-dg.patch\ntrac_14912-doc-fixes-sk.patch\n```\nI don't think there's anything from the other patches which would cause this to fail... Can someone check this on a later version of Sage?",
    "created_at": "2013-12-09T01:15:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187207",
    "user": "https://github.com/tscrim"
}
```

Hey Simon,

With `sage-5.13.beta2`, I get:

```
sage -t unique_representation.py
**********************************************************************
File "unique_representation.py", line 822, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    O is SomeClass(2)
Expected:
    creating new instance for argument 2
    deleting instance for argument 2
    False
Got:
    creating new instance for argument 2
    False
**********************************************************************
File "unique_representation.py", line 826, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    del O
Expected:
    deleting instance for argument 1
Got:
    <BLANKLINE>
**********************************************************************
File "unique_representation.py", line 828, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    O = SomeClass(1)
Expected:
    creating new instance for argument 1
Got:
    <BLANKLINE>
**********************************************************************
1 item had failures:
   3 of  89 in sage.structure.unique_representation.CachedRepresentation
    [229 tests, 3 failures, 4.18 s]
----------------------------------------------------------------------
sage -t unique_representation.py  # 3 doctests failed
----------------------------------------------------------------------
```
with the following patches applied:

```
trac_15327-qfold-dg.patch
trac_15327-fixes-dg.patch
trac_15305-coercion_tensor_products-ts.patch
trac13394-weak_value_dictionary.patch
trac_15311-hall_algebras-ts.patch
trac_10963-more_functorial_constructions-nt.patch
trac_10963-more_functorial_constructions-graded-modules-fix-nt.patch
trac_10963_doctest_correction-fc.patch
trac_14102-nonsymmetric-macdonald.patch
trac9107_nesting_nested_classes.patch
trac_9107_fix_cross_reference.patch
trac_14685_bug_aorder_lazypowerseries.patch
trac_15150-ncsym-ts.patch
trac_15174-qfold1.patch
trac_15174-final-touches-dg.patch
trac_15174-review-ts.patch
trac14912-unique_doc.patch
trac_14912-comments-dg.patch
trac_14912-more-ts-dg.patch
trac_14912-doc-fixes-sk.patch
```
I don't think there's anything from the other patches which would cause this to fail... Can someone check this on a later version of Sage?



---

archive/issue_comments_187208.json:
```json
{
    "body": "With the git version of beta5, I get:\n\n```\nsage -t src/sage/structure/unique_representation.py\ndeleting instance for argument 1\n    [229 tests, 0.45 s]\n```\nWeird but supposedly OK?\n\nCould this be the garbage collector triggering `__del__` *after* the doctest? If so, one could easily fix this by explicitly trashing all instances in the doctest.",
    "created_at": "2013-12-09T01:43:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187208",
    "user": "https://github.com/darijgr"
}
```

With the git version of beta5, I get:

```
sage -t src/sage/structure/unique_representation.py
deleting instance for argument 1
    [229 tests, 0.45 s]
```
Weird but supposedly OK?

Could this be the garbage collector triggering `__del__` *after* the doctest? If so, one could easily fix this by explicitly trashing all instances in the doctest.



---

archive/issue_comments_187209.json:
```json
{
    "body": "Doctests also pass for me.",
    "created_at": "2013-12-09T09:56:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187209",
    "user": "https://github.com/jdemeyer"
}
```

Doctests also pass for me.



---

archive/issue_comments_187210.json:
```json
{
    "body": "Replying to [comment:54 darij]:\n> Could this be the garbage collector triggering `__del__` *after* the doctest? If so, one could easily fix this by explicitly trashing all instances in the doctest.\n\n\nIsn't deletion of this instance supposed to be *immediate*? After all, Python's cyclic garbage is not involved in this example, since the to-be-deleted objects are not part of any reference cycle.\n\nWeird. Any idea about (1) the reason and (2) how to fix it?",
    "created_at": "2013-12-09T10:15:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187210",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:54 darij]:
> Could this be the garbage collector triggering `__del__` *after* the doctest? If so, one could easily fix this by explicitly trashing all instances in the doctest.


Isn't deletion of this instance supposed to be *immediate*? After all, Python's cyclic garbage is not involved in this example, since the to-be-deleted objects are not part of any reference cycle.

Weird. Any idea about (1) the reason and (2) how to fix it?



---

archive/issue_comments_187211.json:
```json
{
    "body": "I'm talking about the instance which is *not explicitly* deleted in the doctest, but just left around to dangle.",
    "created_at": "2013-12-09T15:43:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187211",
    "user": "https://github.com/darijgr"
}
```

I'm talking about the instance which is *not explicitly* deleted in the doctest, but just left around to dangle.



---

archive/issue_comments_187212.json:
```json
{
    "body": "Replying to [comment:57 darij]:\n> I'm talking about the instance which is *not explicitly* deleted in the doctest, but just left around to dangle.\n\n\nOK, but I am also talking about the failure reported by travis:\n\n```\nFile \"unique_representation.py\", line 826, in sage.structure.unique_representation.CachedRepresentation\nFailed example:\n    del O\nExpected:\n    deleting instance for argument 1\nGot:\n    <BLANKLINE>\n**********************************************************************\nFile \"unique_representation.py\", line 828, in sage.structure.unique_representation.CachedRepresentation\nFailed example:\n    O = SomeClass(1)\nExpected:\n    creating new instance for argument 1\nGot:\n    <BLANKLINE>\n```\nHere, the instance *is* explicitly deleted, but nonetheless it stays in cache. No idea why.",
    "created_at": "2013-12-09T16:01:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187212",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:57 darij]:
> I'm talking about the instance which is *not explicitly* deleted in the doctest, but just left around to dangle.


OK, but I am also talking about the failure reported by travis:

```
File "unique_representation.py", line 826, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    del O
Expected:
    deleting instance for argument 1
Got:
    <BLANKLINE>
**********************************************************************
File "unique_representation.py", line 828, in sage.structure.unique_representation.CachedRepresentation
Failed example:
    O = SomeClass(1)
Expected:
    creating new instance for argument 1
Got:
    <BLANKLINE>
```
Here, the instance *is* explicitly deleted, but nonetheless it stays in cache. No idea why.



---

archive/issue_comments_187213.json:
```json
{
    "body": "Hey Darij,\n\nCould you push your branch to trac so I can look at it? I can't seem to import Hg patches currently. This way we can see if it's something that's been taken care of by a beta version bump.\n\nThanks,\n\nTravis",
    "created_at": "2013-12-09T17:01:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187213",
    "user": "https://github.com/tscrim"
}
```

Hey Darij,

Could you push your branch to trac so I can look at it? I can't seem to import Hg patches currently. This way we can see if it's something that's been taken care of by a beta version bump.

Thanks,

Travis



---

archive/issue_comments_187214.json:
```json
{
    "body": "Hi Travis,\n\nit's on branch `u/darij/do-not-fork/14912` now. I don't want to put this into public namespace so as not to confuse this ticket; I am not sure if it's a good idea right now to turn #14912 into a git patch.\n\nGreets,\\\\\nDarij",
    "created_at": "2013-12-10T03:29:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187214",
    "user": "https://github.com/darijgr"
}
```

Hi Travis,

it's on branch `u/darij/do-not-fork/14912` now. I don't want to put this into public namespace so as not to confuse this ticket; I am not sure if it's a good idea right now to turn #14912 into a git patch.

Greets,\\
Darij



---

archive/issue_comments_187215.json:
```json
{
    "body": "Hmmm... with the branch, I get the same output. I'm thinking we shouldn't have a print statement displaying like that.\n\nJeroen, do you also get the print statement when running doctests on the file? I'm building `5.13.beta5` now and can test tonight.",
    "created_at": "2013-12-10T16:50:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187215",
    "user": "https://github.com/tscrim"
}
```

Hmmm... with the branch, I get the same output. I'm thinking we shouldn't have a print statement displaying like that.

Jeroen, do you also get the print statement when running doctests on the file? I'm building `5.13.beta5` now and can test tonight.



---

archive/issue_comments_187216.json:
```json
{
    "body": "I get\n\n```\nDoctesting 1 file.\nsage -t --long devel/sage/sage/structure/unique_representation.py\ndeleting instance for argument 1\n    [229 tests, 6.90 s]\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 7.1 seconds\n    cpu time: 1.1 seconds\n    cumulative wall time: 6.9 seconds\n```",
    "created_at": "2013-12-10T17:25:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187216",
    "user": "https://github.com/jdemeyer"
}
```

I get

```
Doctesting 1 file.
sage -t --long devel/sage/sage/structure/unique_representation.py
deleting instance for argument 1
    [229 tests, 6.90 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 7.1 seconds
    cpu time: 1.1 seconds
    cumulative wall time: 6.9 seconds
```



---

archive/issue_comments_187217.json:
```json
{
    "body": "Attachment [trac_14912-fix_leaking_print-ts.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-fix_leaking_print-ts.patch) by @tscrim created at 2013-12-10 20:16:39\n\nOkay, I fixed the leaking print statement by explicitly deleting the object in the doctest. It's a slight hack fix, but since this is only for testing/illustrative purposed, I think its okay.\n\nFor patchbot:\n\nApply: trac14912-unique_doc.patch, trac_14912-comments-dg.patch, trac_14912-more-ts-dg.patch, trac_14912-doc-fixes-sk.patch, trac_14912-fix_leaking_print-ts.patch\u200b",
    "created_at": "2013-12-10T20:16:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187217",
    "user": "https://github.com/tscrim"
}
```

Attachment [trac_14912-fix_leaking_print-ts.patch](tarball://root/attachments/some-uuid/ticket14912/trac_14912-fix_leaking_print-ts.patch) by @tscrim created at 2013-12-10 20:16:39

Okay, I fixed the leaking print statement by explicitly deleting the object in the doctest. It's a slight hack fix, but since this is only for testing/illustrative purposed, I think its okay.

For patchbot:

Apply: trac14912-unique_doc.patch, trac_14912-comments-dg.patch, trac_14912-more-ts-dg.patch, trac_14912-doc-fixes-sk.patch, trac_14912-fix_leaking_print-ts.patch​



---

archive/issue_comments_187218.json:
```json
{
    "body": "If the patchbot says that it is fine, then it is fine with me as well. But I am not a reviewer...",
    "created_at": "2013-12-10T21:52:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187218",
    "user": "https://github.com/simon-king-jena"
}
```

If the patchbot says that it is fine, then it is fine with me as well. But I am not a reviewer...



---

archive/issue_comments_187219.json:
```json
{
    "body": "The patchbot has not come around, but can someone just double-check that with my latest patch, the statement isn't printed anymore after running the doctest? With that I think it's positive review (at least for me). Thanks.",
    "created_at": "2013-12-11T19:22:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187219",
    "user": "https://github.com/tscrim"
}
```

The patchbot has not come around, but can someone just double-check that with my latest patch, the statement isn't printed anymore after running the doctest? With that I think it's positive review (at least for me). Thanks.



---

archive/issue_comments_187220.json:
```json
{
    "body": "*ping* It's a simple double-check to make sure the print statement isn't shown when running `sage -t` on the file. That's all I've changed.",
    "created_at": "2013-12-16T16:50:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187220",
    "user": "https://github.com/tscrim"
}
```

*ping* It's a simple double-check to make sure the print statement isn't shown when running `sage -t` on the file. That's all I've changed.



---

archive/issue_comments_187221.json:
```json
{
    "body": "The patches apply fine on 6.0rc0, and the print no longer leaks.\n\nBut I've got another question on this paragraph:\n\n```\n.. NOTE::\n\n    For technical reasons, it is needed that ``__classcall__`` respectively\n    ``__classcall_private__`` are \"static methods\", i.e., they are callable\n    objects that do not bind to an instance or class. For example, a\n    :class:`~sage.misc.cachefunc.cached_function` can be used here, because it\n    is callable, but does not bind to an instance or class, because it has no\n    ``__get__()`` method. A usual Python function, however, has a\n    ``__get__()`` method and would thus under normal circumstances bind to an\n    instance or class, and thus the instance or class would be passed to the\n    function as the first argument. To prevent a callable object from being\n    bound to the instance or class, one can prepend the ``@staticmethod``\n    decorator to the definition; see :class:`staticmethod`.\n\n    For more on Python's ``__get__()`` method, see:\n    http://docs.python.org/2/howto/descriptor.html\n```\nIn `src/sage/groups/perm_gps.py`, I see:\n\n```\n    @weak_cached_function\n    def __classcall__(cls, *args, **kwds):\n        \"\"\"\n        This makes sure that domain is a FiniteEnumeratedSet before it gets passed\n        on to the __init__ method.\n\n        EXAMPLES::\n\n            sage: SymmetricGroup(['a','b']).domain() #indirect doctest\n            {'a', 'b'}\n        \"\"\"\n        domain = kwds.pop('domain', None)\n        if domain is not None:\n            if domain not in FiniteEnumeratedSets():\n                domain = FiniteEnumeratedSet(domain)\n            kwds['domain'] = domain\n        return super(PermutationGroup_unique, cls).__classcall__(cls, *args, **kwds)\n```\nThis is NOT decorated with ``@`staticmethod`. Isn't this contradictory to the NOTE above?",
    "created_at": "2013-12-17T04:52:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187221",
    "user": "https://github.com/darijgr"
}
```

The patches apply fine on 6.0rc0, and the print no longer leaks.

But I've got another question on this paragraph:

```
.. NOTE::

    For technical reasons, it is needed that ``__classcall__`` respectively
    ``__classcall_private__`` are "static methods", i.e., they are callable
    objects that do not bind to an instance or class. For example, a
    :class:`~sage.misc.cachefunc.cached_function` can be used here, because it
    is callable, but does not bind to an instance or class, because it has no
    ``__get__()`` method. A usual Python function, however, has a
    ``__get__()`` method and would thus under normal circumstances bind to an
    instance or class, and thus the instance or class would be passed to the
    function as the first argument. To prevent a callable object from being
    bound to the instance or class, one can prepend the ``@staticmethod``
    decorator to the definition; see :class:`staticmethod`.

    For more on Python's ``__get__()`` method, see:
    http://docs.python.org/2/howto/descriptor.html
```
In `src/sage/groups/perm_gps.py`, I see:

```
    @weak_cached_function
    def __classcall__(cls, *args, **kwds):
        """
        This makes sure that domain is a FiniteEnumeratedSet before it gets passed
        on to the __init__ method.

        EXAMPLES::

            sage: SymmetricGroup(['a','b']).domain() #indirect doctest
            {'a', 'b'}
        """
        domain = kwds.pop('domain', None)
        if domain is not None:
            if domain not in FiniteEnumeratedSets():
                domain = FiniteEnumeratedSet(domain)
            kwds['domain'] = domain
        return super(PermutationGroup_unique, cls).__classcall__(cls, *args, **kwds)
```
This is NOT decorated with ``@`staticmethod`. Isn't this contradictory to the NOTE above?



---

archive/issue_comments_187222.json:
```json
{
    "body": "There's this line in `unique_representation.py`:\n\n```\n    @weak_cached_function # automatically a staticmethod\n    def __classcall__(cls, *args, **options):\n```\nso apparently it's not a contradiction. Although I don't specifically know why it's used (in `src/sage/groups/perm_gps/permgroup_named.py`) instead of a ``@`staticmethod`.",
    "created_at": "2013-12-17T06:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187222",
    "user": "https://github.com/tscrim"
}
```

There's this line in `unique_representation.py`:

```
    @weak_cached_function # automatically a staticmethod
    def __classcall__(cls, *args, **options):
```
so apparently it's not a contradiction. Although I don't specifically know why it's used (in `src/sage/groups/perm_gps/permgroup_named.py`) instead of a ``@`staticmethod`.



---

archive/issue_comments_187223.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2013-12-17T06:27:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187223",
    "user": "https://github.com/darijgr"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_187224.json:
```json
{
    "body": "Ah, that clears things up; thanks a lot.\n\nPositive_review!!!1111",
    "created_at": "2013-12-17T06:27:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187224",
    "user": "https://github.com/darijgr"
}
```

Ah, that clears things up; thanks a lot.

Positive_review!!!1111



---

archive/issue_comments_187225.json:
```json
{
    "body": "Replying to [comment:68 tscrim]:\n> There's this line in `unique_representation.py`:\n> \n> ```\n>     @weak_cached_function # automatically a staticmethod\n>     def __classcall__(cls, *args, **options):\n> ```\n> so apparently it's not a contradiction. Although I don't specifically know why it's used (in `src/sage/groups/perm_gps/permgroup_named.py`) instead of a ``@`staticmethod`.\n\n\nThere is some argument pre-processing: `kwds['domain']` might change. And this *changed* argument is used as a cache key when calling `super(PermutationGroup_unique, cls).__classcall__(cls, *args, **kwds)`. Apparently the author of this `__classcall__` found it desirable that the instance is pulled from the cache when the original value of `kwds['domain']` is provided next time, *without* losing time by the preprocessing.",
    "created_at": "2013-12-17T10:26:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187225",
    "user": "https://github.com/simon-king-jena"
}
```

Replying to [comment:68 tscrim]:
> There's this line in `unique_representation.py`:
> 
> ```
>     @weak_cached_function # automatically a staticmethod
>     def __classcall__(cls, *args, **options):
> ```
> so apparently it's not a contradiction. Although I don't specifically know why it's used (in `src/sage/groups/perm_gps/permgroup_named.py`) instead of a ``@`staticmethod`.


There is some argument pre-processing: `kwds['domain']` might change. And this *changed* argument is used as a cache key when calling `super(PermutationGroup_unique, cls).__classcall__(cls, *args, **kwds)`. Apparently the author of this `__classcall__` found it desirable that the instance is pulled from the cache when the original value of `kwds['domain']` is provided next time, *without* losing time by the preprocessing.



---

archive/issue_comments_187226.json:
```json
{
    "body": "Replying to [comment:70 SimonKing]:\n> There is some argument pre-processing: `kwds['domain']` might change. And this *changed* argument is used as a cache key when calling `super(PermutationGroup_unique, cls).__classcall__(cls, *args, **kwds)`. Apparently the author of this `__classcall__` found it desirable that the instance is pulled from the cache when the original value of `kwds['domain']` is provided next time, *without* losing time by the preprocessing.\n\n\nAh I see. Thanks for clarifying and for your work on this.\n\nThanks to Darij and Jeroen for help in reviewing.",
    "created_at": "2013-12-17T20:43:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187226",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:70 SimonKing]:
> There is some argument pre-processing: `kwds['domain']` might change. And this *changed* argument is used as a cache key when calling `super(PermutationGroup_unique, cls).__classcall__(cls, *args, **kwds)`. Apparently the author of this `__classcall__` found it desirable that the instance is pulled from the cache when the original value of `kwds['domain']` is provided next time, *without* losing time by the preprocessing.


Ah I see. Thanks for clarifying and for your work on this.

Thanks to Darij and Jeroen for help in reviewing.



---

archive/issue_comments_187227.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2013-12-18T14:55:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14708#issuecomment-187227",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_042892.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-12-18T14:55:39Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/14708",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14708#event-42892"
}
```
