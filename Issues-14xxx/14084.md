# Issue 14084: Wrong domain of the fraction field construction functor

archive/issues_013880.json:
```json
{
    "body": "The construction functor for fraction fields pretends that it takes any ring as input:\n\n```\nsage: Fract,R = QQ.construction()\nsage: Fract.domain()\nCategory of rings\nsage: Fract.codomain()\nCategory of fields\n```\n\nBut of course that's wrong:\n\n```\nsage: Fract(ZZ.quo(15))\nTraceback (most recent call last):\n...\nTypeError: self must be an integral domain.\n```\n\nHence, it would be better to declare right away that its domain is the category of integral domains.\n\n**Assignee:** @roed314\n\n**Reviewer:** Julian Rueth\n\n**Author:** Simon King\n\n**Merged:** sage-5.8.beta0\n\n**Resolution:** fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/14084\n\n",
    "closed_at": "2013-02-19T06:48:46Z",
    "created_at": "2013-02-08T19:51:22Z",
    "labels": [
        "component: padics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.8",
    "title": "Wrong domain of the fraction field construction functor",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14084",
    "user": "https://github.com/simon-king-jena"
}
```
The construction functor for fraction fields pretends that it takes any ring as input:

```
sage: Fract,R = QQ.construction()
sage: Fract.domain()
Category of rings
sage: Fract.codomain()
Category of fields
```

But of course that's wrong:

```
sage: Fract(ZZ.quo(15))
Traceback (most recent call last):
...
TypeError: self must be an integral domain.
```

Hence, it would be better to declare right away that its domain is the category of integral domains.

**Assignee:** @roed314

**Reviewer:** Julian Rueth

**Author:** Simon King

**Merged:** sage-5.8.beta0

**Resolution:** fixed

Issue created by migration from https://trac.sagemath.org/ticket/14084





---

archive/issue_comments_220659.json:
```json
{
    "body": "<a id='comment:1'></a>\nFirst two problems:\n\n```\nsage: Zp(7) in IntegralDomains()\nFalse\nsage: ZZ[['x']] in IntegralDomains()\nFalse\n```",
    "created_at": "2013-02-08T20:13:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220659",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
First two problems:

```
sage: Zp(7) in IntegralDomains()
False
sage: ZZ[['x']] in IntegralDomains()
False
```



---

archive/issue_comments_220660.json:
```json
{
    "body": "<a id='comment:2'></a>\nAnd similarly:\n\n```\nsage: Qp(7).category()\nCategory of commutative rings\nsage: Qp(7).is_field()\nTrue\n```",
    "created_at": "2013-02-08T20:15:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220660",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
And similarly:

```
sage: Qp(7).category()
Category of commutative rings
sage: Qp(7).is_field()
True
```



---

archive/issue_comments_220661.json:
```json
{
    "body": "<a id='comment:3'></a>\n... but\n\n```\nsage: k=Qp(7)\nsage: k.category()\nCategory of commutative rings\nsage: k in Fields()\nTrue\nsage: k.category()\nCategory of fields\n```\nwhich is a little uncomfortable in its own right. You'd think that a category is part of the defining properties of the parent, so changing it seems to fly into the face of immutability of parents.\n\nIf we have to keep it like this, we'd have to be very clear that one should only test if a parent is IN a given category; never rely on the category reported by \"<parent>.category()\". It certainly flies in the face of what I thought sage did: I thought specifying a parent implied specifying the category in which you want to consider it, and that if you want to consider a number field as a `QQ`-vector space instead, one should explicitly apply a functor and use a map (or perhaps conversion if you want to be implicit about it) to go between the two.",
    "created_at": "2013-02-08T20:41:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220661",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:3'></a>
... but

```
sage: k=Qp(7)
sage: k.category()
Category of commutative rings
sage: k in Fields()
True
sage: k.category()
Category of fields
```
which is a little uncomfortable in its own right. You'd think that a category is part of the defining properties of the parent, so changing it seems to fly into the face of immutability of parents.

If we have to keep it like this, we'd have to be very clear that one should only test if a parent is IN a given category; never rely on the category reported by "<parent>.category()". It certainly flies in the face of what I thought sage did: I thought specifying a parent implied specifying the category in which you want to consider it, and that if you want to consider a number field as a `QQ`-vector space instead, one should explicitly apply a functor and use a map (or perhaps conversion if you want to be implicit about it) to go between the two.



---

archive/issue_comments_220662.json:
```json
{
    "body": "<a id='comment:4'></a>\nReplying to [nbruin](#comment%3A3):\n> ... but\n> \n> ```\n> sage: k=Qp(7)\n> sage: k.category()\n> Category of commutative rings\n> sage: k in Fields()\n> True\n> sage: k.category()\n> Category of fields\n> ```\n> which is a little uncomfortable in its own right.\n\n\nNo, this is very important for making the test `k in Fields()` fast without caching.\n\n> You'd think that a category is part of the defining properties of the parent, so changing it seems to fly into the face of immutability of parents.\n\n\nNo. It is just \"learning more and more about immutable properties of the parent\".\n \n> If we have to keep it like this, we'd have to be very clear that one should only test if a parent is IN a given category; never rely on the category reported by \"<parent>.category()\".\n\n\nSure. It could always be that the reported category is a subcategory of what one wants to have. `R in C` is recommended, but `R.category() is C` is not.\n\n> It certainly flies in the face of what I thought sage did: I thought specifying a parent implied specifying the category in which you want to consider it, and that if you want to consider a number field as a `QQ`-vector space instead, one should explicitly apply a functor and use a map (or perhaps conversion if you want to be implicit about it) to go between the two.\n\n\nI think this is currently not supported.",
    "created_at": "2013-02-08T20:48:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220662",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
Replying to [nbruin](#comment%3A3):
> ... but
> 
> ```
> sage: k=Qp(7)
> sage: k.category()
> Category of commutative rings
> sage: k in Fields()
> True
> sage: k.category()
> Category of fields
> ```
> which is a little uncomfortable in its own right.


No, this is very important for making the test `k in Fields()` fast without caching.

> You'd think that a category is part of the defining properties of the parent, so changing it seems to fly into the face of immutability of parents.


No. It is just "learning more and more about immutable properties of the parent".
 
> If we have to keep it like this, we'd have to be very clear that one should only test if a parent is IN a given category; never rely on the category reported by "<parent>.category()".


Sure. It could always be that the reported category is a subcategory of what one wants to have. `R in C` is recommended, but `R.category() is C` is not.

> It certainly flies in the face of what I thought sage did: I thought specifying a parent implied specifying the category in which you want to consider it, and that if you want to consider a number field as a `QQ`-vector space instead, one should explicitly apply a functor and use a map (or perhaps conversion if you want to be implicit about it) to go between the two.


I think this is currently not supported.



---

archive/issue_comments_220663.json:
```json
{
    "body": "<a id='comment:5'></a>\nReplying to [nbruin](#comment%3A3):\n> ... but\n> \n> ```\n> sage: k=Qp(7)\n> sage: k.category()\n> Category of commutative rings\n> sage: k in Fields()\n> True\n> sage: k.category()\n> Category of fields\n> ```\n> which is a little uncomfortable in its own right. You'd think that a category is part of the defining properties of the parent, so changing it seems to fly into the face of immutability of parents.\n> \n\n\n> If we have to keep it like this, we'd have to be very clear that one should only test if a parent is IN a given category; never rely on the category reported by \"<parent>.category()\". It certainly flies in the face of what I thought sage did: I thought specifying a parent implied specifying the category in which you want to consider it, and that if you want to consider a number field as a `QQ`-vector space instead, one should explicitly apply a functor and use a map (or perhaps conversion if you want to be implicit about it) to go between the two.\n\n\nThe above is in fact alright because Fields is a full subcategory of\nRings. So by going from one to the other, one don't change the\nstructure under consideration. One is just learning more properties of\nthis structure.\n\nI certainly agree that I would not want the category of my parent to\nchange from Vector Space to Ring, because then I am adding a new\nstructure (the multiplication).\n\nFull subcategories are not yet modeled in Sage, but this is in the\nplans, because that's what we want to go further with homsets.\n\nCheers,\n                      Nicolas",
    "created_at": "2013-02-08T21:01:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220663",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:5'></a>
Replying to [nbruin](#comment%3A3):
> ... but
> 
> ```
> sage: k=Qp(7)
> sage: k.category()
> Category of commutative rings
> sage: k in Fields()
> True
> sage: k.category()
> Category of fields
> ```
> which is a little uncomfortable in its own right. You'd think that a category is part of the defining properties of the parent, so changing it seems to fly into the face of immutability of parents.
> 


> If we have to keep it like this, we'd have to be very clear that one should only test if a parent is IN a given category; never rely on the category reported by "<parent>.category()". It certainly flies in the face of what I thought sage did: I thought specifying a parent implied specifying the category in which you want to consider it, and that if you want to consider a number field as a `QQ`-vector space instead, one should explicitly apply a functor and use a map (or perhaps conversion if you want to be implicit about it) to go between the two.


The above is in fact alright because Fields is a full subcategory of
Rings. So by going from one to the other, one don't change the
structure under consideration. One is just learning more properties of
this structure.

I certainly agree that I would not want the category of my parent to
change from Vector Space to Ring, because then I am adding a new
structure (the multiplication).

Full subcategories are not yet modeled in Sage, but this is in the
plans, because that's what we want to go further with homsets.

Cheers,
                      Nicolas



---

archive/issue_comments_220664.json:
```json
{
    "body": "<a id='comment:6'></a>\nAt first glance, changing the categories of Zp(p) and Qp(p) seems not totally easy, simply because the code base is formed by a lot of slightly differently sounding base classes. But, as it says in sage.rings.padic.local_generic:\n\n```\nLocal Generic\n\nSuperclass for `p`-adic and power series rings.\n```\n\nSo, if we are lucky, both Zp, Qp and power series rings can be fixed at the same time.",
    "created_at": "2013-02-08T23:08:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220664",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
At first glance, changing the categories of Zp(p) and Qp(p) seems not totally easy, simply because the code base is formed by a lot of slightly differently sounding base classes. But, as it says in sage.rings.padic.local_generic:

```
Local Generic

Superclass for `p`-adic and power series rings.
```

So, if we are lucky, both Zp, Qp and power series rings can be fixed at the same time.



---

archive/issue_comments_220665.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [SimonKing](#comment%3A6):\n> \n> ```\n> Local Generic\n> \n> Superclass for `p`-adic and power series rings.\n> ```\n> \n> So, if we are lucky, both Zp, Qp and power series rings can be fixed at the same time.\n\n\nWe are not lucky.\n\n```\nsage: P = QQ[['x']]\nsage: isinstance(P,sage.rings.padics.local_generic.LocalGeneric)\nFalse\n```",
    "created_at": "2013-02-08T23:19:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220665",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Replying to [SimonKing](#comment%3A6):
> 
> ```
> Local Generic
> 
> Superclass for `p`-adic and power series rings.
> ```
> 
> So, if we are lucky, both Zp, Qp and power series rings can be fixed at the same time.


We are not lucky.

```
sage: P = QQ[['x']]
sage: isinstance(P,sage.rings.padics.local_generic.LocalGeneric)
False
```



---

archive/issue_comments_220666.json:
```json
{
    "body": "<a id='comment:8'></a>\nPart of the problem is that the padic rings and fields inherit from sage.rings.ring.Ring, but they never call ring initialisation.\n\nThere are cases in which calling `__init__` of the super-classes is a bad idea, as it gives a speed regression. Question to users of padics: Are there cases in which one needs to create very many different padic rings and fields? If \"yes\", then shortcutting `__init__` makes sense. If not, it would be cleaner to call `__init__` of the base classes.",
    "created_at": "2013-02-09T10:36:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220666",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Part of the problem is that the padic rings and fields inherit from sage.rings.ring.Ring, but they never call ring initialisation.

There are cases in which calling `__init__` of the super-classes is a bad idea, as it gives a speed regression. Question to users of padics: Are there cases in which one needs to create very many different padic rings and fields? If "yes", then shortcutting `__init__` makes sense. If not, it would be cleaner to call `__init__` of the base classes.



---

archive/issue_comments_220667.json:
```json
{
    "body": "**Changing assignee** from @nthiery to @roed314.",
    "created_at": "2013-02-09T10:36:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220667",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing assignee** from @nthiery to @roed314.



---

archive/issue_comments_220668.json:
```json
{
    "body": "<a id='comment:9'></a>\nPS: Part of the problem is that `sage.padics.local_generic.LocalGeneric` inherits from `CommutativeRing`, but calls ` Parent.__init__(self, base, element_constructor=element_class, names=(names,), normalize=False, category=category or _CommutativeRings)`.\n\nWhere is the problem? Well, `CommutativeRing.__init__` does not know about the argument `element_constructor`...",
    "created_at": "2013-02-09T10:39:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220668",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
PS: Part of the problem is that `sage.padics.local_generic.LocalGeneric` inherits from `CommutativeRing`, but calls ` Parent.__init__(self, base, element_constructor=element_class, names=(names,), normalize=False, category=category or _CommutativeRings)`.

Where is the problem? Well, `CommutativeRing.__init__` does not know about the argument `element_constructor`...



---

archive/issue_comments_220669.json:
```json
{
    "body": "<a id='comment:10'></a>\nAha! Instead of passing the element_class to `Parent.__init__`, one can simply assign it to `self.Element`! Then, the category framework can be initialised as usual, namely by calling `CommutativeRing.__init__`.",
    "created_at": "2013-02-09T10:44:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220669",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:10'></a>
Aha! Instead of passing the element_class to `Parent.__init__`, one can simply assign it to `self.Element`! Then, the category framework can be initialised as usual, namely by calling `CommutativeRing.__init__`.



---

archive/issue_comments_220670.json:
```json
{
    "body": "<a id='comment:11'></a>\nIt is becoming odder and odder.\n\n```\nsage: P = Zp(15, check=False)\nsage: P.__class__.mro()\n[sage.rings.padics.padic_base_leaves.pAdicRingCappedRelative_with_category,\n sage.rings.padics.padic_base_leaves.pAdicRingCappedRelative,\n sage.rings.padics.generic_nodes.pAdicRingBaseGeneric,\n sage.rings.padics.padic_base_generic.pAdicBaseGeneric,\n sage.rings.padics.generic_nodes.pAdicCappedRelativeRingGeneric,\n sage.rings.padics.generic_nodes.pAdicRingGeneric,\n sage.rings.padics.padic_generic.pAdicGeneric,\n sage.rings.ring.EuclideanDomain,\n sage.rings.ring.PrincipalIdealDomain,\n sage.rings.ring.IntegralDomain,\nsage: P.is_integral_domain()\nTrue\n```\n\nSo, if one creates a p-adic ring where p is not prime, then it still inherits from `EuclideanDomain`, and is convinced that it is an integral domain. That makes me wonder whether we could actually *always* initialise a p-adic ring in the category of Euclidean domains, regardless whether check=True or check=False is used.",
    "created_at": "2013-02-09T15:07:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220670",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'></a>
It is becoming odder and odder.

```
sage: P = Zp(15, check=False)
sage: P.__class__.mro()
[sage.rings.padics.padic_base_leaves.pAdicRingCappedRelative_with_category,
 sage.rings.padics.padic_base_leaves.pAdicRingCappedRelative,
 sage.rings.padics.generic_nodes.pAdicRingBaseGeneric,
 sage.rings.padics.padic_base_generic.pAdicBaseGeneric,
 sage.rings.padics.generic_nodes.pAdicCappedRelativeRingGeneric,
 sage.rings.padics.generic_nodes.pAdicRingGeneric,
 sage.rings.padics.padic_generic.pAdicGeneric,
 sage.rings.ring.EuclideanDomain,
 sage.rings.ring.PrincipalIdealDomain,
 sage.rings.ring.IntegralDomain,
sage: P.is_integral_domain()
True
```

So, if one creates a p-adic ring where p is not prime, then it still inherits from `EuclideanDomain`, and is convinced that it is an integral domain. That makes me wonder whether we could actually *always* initialise a p-adic ring in the category of Euclidean domains, regardless whether check=True or check=False is used.



---

archive/issue_comments_220671.json:
```json
{
    "body": "<a id='comment:12'></a>\nAha!! Finally, the old ways of programming are helpful! The old base classes have an attribute `_default_category`. Hence, in `LocalGeneric`, one can simply do\n\n```\n        self.Element = element_class\n        Parent.__init__(self, base, names=(names,), normalize=False, category=getattr(self,'_default_category',None))\n```\nand then one immediately gets\n\n```\nsage: P = Zp(5)\nsage: TestSuite(P).run()\nsage: K = Qp(7)\nsage: TestSuite(K).run()\n```\n\nSince (in spite of the comment in the doc string of `sage.rings.padics.local_generic`) power series rings do not inherit from that class, they need to be dealt with independently.",
    "created_at": "2013-02-09T15:30:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220671",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:12'></a>
Aha!! Finally, the old ways of programming are helpful! The old base classes have an attribute `_default_category`. Hence, in `LocalGeneric`, one can simply do

```
        self.Element = element_class
        Parent.__init__(self, base, names=(names,), normalize=False, category=getattr(self,'_default_category',None))
```
and then one immediately gets

```
sage: P = Zp(5)
sage: TestSuite(P).run()
sage: K = Qp(7)
sage: TestSuite(K).run()
```

Since (in spite of the comment in the doc string of `sage.rings.padics.local_generic`) power series rings do not inherit from that class, they need to be dealt with independently.



---

archive/issue_comments_220672.json:
```json
{
    "body": "<a id='comment:13'></a>\nGood!\n\n```\nsage: P = ZZ[['x']]\nsage: P._default_category\nCategory of integral domains\nsage: P._is_category_initialized()\nTrue\nsage: P.category()\nCategory of commutative rings\n```\n\nSo, again, one should be able to simply use `self._default_category` when initialising the power series ring.",
    "created_at": "2013-02-09T15:34:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220672",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:13'></a>
Good!

```
sage: P = ZZ[['x']]
sage: P._default_category
Category of integral domains
sage: P._is_category_initialized()
True
sage: P.category()
Category of commutative rings
```

So, again, one should be able to simply use `self._default_category` when initialising the power series ring.



---

archive/issue_comments_220673.json:
```json
{
    "body": "<a id='comment:14'></a>\nArgh. Multivariate power series rings appear to not have an attribute `_default_category`. So, they need to be provided with it.",
    "created_at": "2013-02-09T17:01:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220673",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>
Argh. Multivariate power series rings appear to not have an attribute `_default_category`. So, they need to be provided with it.



---

archive/issue_comments_220674.json:
```json
{
    "body": "<a id='comment:15'></a>\nReplying to [nthiery](#comment%3A5):\n> The above is in fact alright because Fields is a full subcategory of\n> Rings. So by going from one to the other, one don't change the\n> structure under consideration. One is just learning more properties of\n> this structure.\n\n\nFor the most part I probably agree with that. However, how does this relate to additional concepts such as \"finitely generated\"?\n\nThe following is probably not entirely kosher in terms of mathematical categories, but it may affect the colloquial use of them in computer algebra:\n\nThe Gaussian field `QQ(i)` would generally be considered a finitely generated field, but as a ring it would not be finitely generated (no characteristic 0 field is). Of course one should specify over what object they are finitely generated, and the discrepancy comes from the different default choices for fields and rings: The prime fields `QQ` and `GF(p)` for fields versus `ZZ` for commutative rings.\n\nI would love to see that we can use the \"category\" field as a dynamic attribute as suggested, because it does make these `is_field` tests wonderfully fast without requiring complicated additional caching. But I am concerned that phenomena (or misconceptions) as above might come back and bite us if we're coming to depend on such tricks extensively. Can you ease that concern?",
    "created_at": "2013-02-09T21:25:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220674",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:15'></a>
Replying to [nthiery](#comment%3A5):
> The above is in fact alright because Fields is a full subcategory of
> Rings. So by going from one to the other, one don't change the
> structure under consideration. One is just learning more properties of
> this structure.


For the most part I probably agree with that. However, how does this relate to additional concepts such as "finitely generated"?

The following is probably not entirely kosher in terms of mathematical categories, but it may affect the colloquial use of them in computer algebra:

The Gaussian field `QQ(i)` would generally be considered a finitely generated field, but as a ring it would not be finitely generated (no characteristic 0 field is). Of course one should specify over what object they are finitely generated, and the discrepancy comes from the different default choices for fields and rings: The prime fields `QQ` and `GF(p)` for fields versus `ZZ` for commutative rings.

I would love to see that we can use the "category" field as a dynamic attribute as suggested, because it does make these `is_field` tests wonderfully fast without requiring complicated additional caching. But I am concerned that phenomena (or misconceptions) as above might come back and bite us if we're coming to depend on such tricks extensively. Can you ease that concern?



---

archive/issue_comments_220675.json:
```json
{
    "body": "**Changing status** from new to needs_review.",
    "created_at": "2013-02-09T23:18:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220675",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from new to needs_review.



---

archive/issue_comments_220676.json:
```json
{
    "body": "<a id='comment:16'></a>\nI think I made it work. See attachment.\n\nImplementing the category can result in a slow-down in the creation of parents. Let's see what happens here. Without the patch:\n\n```\nsage: %time L = [Zp(p) for p in prime_range(2,10^4)]\nCPU times: user 2.00 s, sys: 0.09 s, total: 2.09 s\nWall time: 2.09 s\n```\nWith the patch:\n\n```\nsage: %time L = [Zp(p) for p in prime_range(2,10^4)]\nCPU times: user 2.10 s, sys: 0.05 s, total: 2.15 s\nWall time: 2.15 s\n```\n\nI hope that's acceptable.",
    "created_at": "2013-02-09T23:18:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220676",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:16'></a>
I think I made it work. See attachment.

Implementing the category can result in a slow-down in the creation of parents. Let's see what happens here. Without the patch:

```
sage: %time L = [Zp(p) for p in prime_range(2,10^4)]
CPU times: user 2.00 s, sys: 0.09 s, total: 2.09 s
Wall time: 2.09 s
```
With the patch:

```
sage: %time L = [Zp(p) for p in prime_range(2,10^4)]
CPU times: user 2.10 s, sys: 0.05 s, total: 2.15 s
Wall time: 2.15 s
```

I hope that's acceptable.



---

archive/issue_comments_220677.json:
```json
{
    "body": "**Author:** Simon King",
    "created_at": "2013-02-09T23:18:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220677",
    "user": "https://github.com/simon-king-jena"
}
```

**Author:** Simon King



---

archive/issue_comments_220678.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [nbruin](#comment%3A15):\n> Replying to [nthiery](#comment%3A5):\n> > The above is in fact alright because Fields is a full subcategory of\n> > Rings. So by going from one to the other, one don't change the\n> > structure under consideration. One is just learning more properties of\n> > this structure.\n\n> \n> For the most part I probably agree with that. However, how does this relate to additional concepts such as \"finitely generated\"?\n> \n> The following is probably not entirely kosher in terms of mathematical categories, but it may affect the colloquial use of them in computer algebra:\n> \n> The Gaussian field `QQ(i)` would generally be considered a finitely generated field, but as a ring it would not be finitely generated (no characteristic 0 field is). Of course one should specify over what object they are finitely generated, and the discrepancy comes from the different default choices for fields and rings: The prime fields `QQ` and `GF(p)` for fields versus `ZZ` for commutative rings.\n> \n> I would love to see that we can use the \"category\" field as a dynamic attribute as suggested, because it does make these `is_field` tests wonderfully fast without requiring complicated additional caching. But I am concerned that phenomena (or misconceptions) as above might come back and bite us if we're coming to depend on such tricks extensively. Can you ease that concern?\n\n\nI guess you pointed the key fact above: one can have some shortcuts\nfor the users convenience, but for a robust answer one should always\nspecify for which category the thing is finitely generated. For the\nsame reason .gens should only be a shortcut. For robust results, one\nshould always specify the category. Which is my motivation for\npromoting the use of semigroup_generators / monoid_generators /\nalgebra_generators / ...  Luckily, in some cases we have nice names\n(finite dimensional, basis,...) for those.\n\nCheers,\n                           Nicolas",
    "created_at": "2013-02-10T00:17:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220678",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:17'></a>
Replying to [nbruin](#comment%3A15):
> Replying to [nthiery](#comment%3A5):
> > The above is in fact alright because Fields is a full subcategory of
> > Rings. So by going from one to the other, one don't change the
> > structure under consideration. One is just learning more properties of
> > this structure.

> 
> For the most part I probably agree with that. However, how does this relate to additional concepts such as "finitely generated"?
> 
> The following is probably not entirely kosher in terms of mathematical categories, but it may affect the colloquial use of them in computer algebra:
> 
> The Gaussian field `QQ(i)` would generally be considered a finitely generated field, but as a ring it would not be finitely generated (no characteristic 0 field is). Of course one should specify over what object they are finitely generated, and the discrepancy comes from the different default choices for fields and rings: The prime fields `QQ` and `GF(p)` for fields versus `ZZ` for commutative rings.
> 
> I would love to see that we can use the "category" field as a dynamic attribute as suggested, because it does make these `is_field` tests wonderfully fast without requiring complicated additional caching. But I am concerned that phenomena (or misconceptions) as above might come back and bite us if we're coming to depend on such tricks extensively. Can you ease that concern?


I guess you pointed the key fact above: one can have some shortcuts
for the users convenience, but for a robust answer one should always
specify for which category the thing is finitely generated. For the
same reason .gens should only be a shortcut. For robust results, one
should always specify the category. Which is my motivation for
promoting the use of semigroup_generators / monoid_generators /
algebra_generators / ...  Luckily, in some cases we have nice names
(finite dimensional, basis,...) for those.

Cheers,
                           Nicolas



---

archive/issue_comments_220679.json:
```json
{
    "body": "<a id='comment:18'></a>\nReplying to [nthiery](#comment%3A17):\n> For robust results, one should always specify the category.\n\nBut that's the issue: The category *is* specified:\n\nHypothetical dialogue (I'm sorry it has to be this academic--I don't presently have an actual example).\n\n```\nsage: QQ.category()\nCategory of Commutative Rings\nsage: QQ.is_finitely_generated()\nFalse\n```\nSage confirms that at this point, it's considering `QQ` as a commutative ring and as such is not finitely generated.\n\n```\nsage: QQ in Fields()\nTrue\nsage: QQ.category()\nCategory of Fields\nsage: QQ.is_finitely_generated()\nTrue\n```\nSince the category here is `Fields` the question about finite generation should be considered there. Since it's a prime field I don't see how any other answer than `True` could be considered there.\n\nThis suggests to me that the concept of finite generation is not well-behaved w.r.t. restricting to *full subcategories*. I don't think that disqualifies it as a reasonable thing to ask. Instead, it suggests to me that it's not safe to implicitly change categories to full subcategories, since that change can affect what the answers to certain perfectly reasonable questions are.\n\nIt's important to keep in mind that by insisting on unique parents, sage is deviating from what most computer algebra systems choose to do. It makes the immutability of parents extremely important, because mutations can have extremely non-local consequences. Hence, every time immutability is violated one has to argue extremely carefully that the effect is immaterial. Changing categories sounds like a very dangerous thing to me.\n\nNormally I'm not a fan of discussions about hypothetical code. However, here I think this issue is worth serious thinking because we're touching on fundamental infrastructure in sage:\n\nThe parent you get back when you ask for its construction can either be a fresh one, or one that is already referenced somewhere, or one that was already deleted but not yet found by the garbage collector (perhaps because it got trapped in a permanent cache somewhere), depending on what happened before.",
    "created_at": "2013-02-10T02:07:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220679",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:18'></a>
Replying to [nthiery](#comment%3A17):
> For robust results, one should always specify the category.

But that's the issue: The category *is* specified:

Hypothetical dialogue (I'm sorry it has to be this academic--I don't presently have an actual example).

```
sage: QQ.category()
Category of Commutative Rings
sage: QQ.is_finitely_generated()
False
```
Sage confirms that at this point, it's considering `QQ` as a commutative ring and as such is not finitely generated.

```
sage: QQ in Fields()
True
sage: QQ.category()
Category of Fields
sage: QQ.is_finitely_generated()
True
```
Since the category here is `Fields` the question about finite generation should be considered there. Since it's a prime field I don't see how any other answer than `True` could be considered there.

This suggests to me that the concept of finite generation is not well-behaved w.r.t. restricting to *full subcategories*. I don't think that disqualifies it as a reasonable thing to ask. Instead, it suggests to me that it's not safe to implicitly change categories to full subcategories, since that change can affect what the answers to certain perfectly reasonable questions are.

It's important to keep in mind that by insisting on unique parents, sage is deviating from what most computer algebra systems choose to do. It makes the immutability of parents extremely important, because mutations can have extremely non-local consequences. Hence, every time immutability is violated one has to argue extremely carefully that the effect is immaterial. Changing categories sounds like a very dangerous thing to me.

Normally I'm not a fan of discussions about hypothetical code. However, here I think this issue is worth serious thinking because we're touching on fundamental infrastructure in sage:

The parent you get back when you ask for its construction can either be a fresh one, or one that is already referenced somewhere, or one that was already deleted but not yet found by the garbage collector (perhaps because it got trapped in a permanent cache somewhere), depending on what happened before.



---

archive/issue_comments_220680.json:
```json
{
    "body": "<a id='comment:19'></a>\nI do agree that changing the category on the fly looks suspicious. The true reason for originally implementing it in that way was speed: There were many fields that have not been initialised as fields, but had a method `is_field`; hence, the test `K in Fields()` used to first check the category and then the answer of `is_field` (similar to what is done now). Repeating this test used to be incredibly slow, which was quite visible in some examples.\n\nNote that this change of class and category---changing from (the parent class of) one category to (the parent class of) the join of this category with the category of fields---is not a regression. Actually, it fixes a bug. Namely, in the good old times, one could very well have `P in Fields()` return true and `P in IntegralDomains()` return false. Now, `P in IntegralDomains()` would return true---at least when it is called after `P in Fields()`.\n\nIf all fields would be initialised as fields right away, we could certainly avoid this dangerous game. But the original rationale for working with the is_field methods is still valid: Sometimes the test of something really is a field is very expensive (primality tests, etc). So, one should avoid the expensive test as long as possible.",
    "created_at": "2013-02-10T11:43:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220680",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'></a>
I do agree that changing the category on the fly looks suspicious. The true reason for originally implementing it in that way was speed: There were many fields that have not been initialised as fields, but had a method `is_field`; hence, the test `K in Fields()` used to first check the category and then the answer of `is_field` (similar to what is done now). Repeating this test used to be incredibly slow, which was quite visible in some examples.

Note that this change of class and category---changing from (the parent class of) one category to (the parent class of) the join of this category with the category of fields---is not a regression. Actually, it fixes a bug. Namely, in the good old times, one could very well have `P in Fields()` return true and `P in IntegralDomains()` return false. Now, `P in IntegralDomains()` would return true---at least when it is called after `P in Fields()`.

If all fields would be initialised as fields right away, we could certainly avoid this dangerous game. But the original rationale for working with the is_field methods is still valid: Sometimes the test of something really is a field is very expensive (primality tests, etc). So, one should avoid the expensive test as long as possible.



---

archive/issue_comments_220681.json:
```json
{
    "body": "<a id='comment:20'></a>\nI think we really need another way to cache whether a ring is a field then. What you describe is indeed the case:\n\n```\nsage: R=ZZ.quo(7)\nsage: R in IntegralDomains() ##1\nFalse\nsage: R in Fields()\nTrue\nsage: R in IntegralDomains() ##2\nTrue\n```\nyou can see that the call `R in Fields()` has mutated the parent in an essential way. The kind of call that people HAVE to use to look at the category field because it is not trustworthy by itself even can change depending on what happens with the parent elsewhere!\n\nWhether `##1` is a bug or not depends on how you interpret the question: Are we asking the mathematical truth (which in general might be undecidable) or are we asking what sage knows about the object by construction? The first would of course be nicer, but computer algebra systems often settle for the second.\n\nThe important thing here is to illustrate how easy it is to mutate parents in a significant way if you start mucking with their category.\n\nPersonally I think it's fine if `ZZ.quo(7)` doesn't advertise itself as a `field by construction`. People can ask for `GF(7)` instead, which luckily does give back a non-identical parent:\n\n```\nsage: R=ZZ.quo(7)\nsage: R2=GF(7)\nsage: id(R)\n85206256\nsage: id(R2)\n17095856\n```\nBy the way:\n\n```\nsage: R.category()\nJoin of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets\nsage: R2.category()\nJoin of Category of subquotients of monoids and Category of quotients of semigroups and Category of finite fields\n```\nI have to say those values do a good job of dissuading people from ever looking at them!\n\nAlso, this discussion is not of direct relevance to this ticket, so perhaps we should take the discussion to sage-devel instead.",
    "created_at": "2013-02-10T18:52:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220681",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:20'></a>
I think we really need another way to cache whether a ring is a field then. What you describe is indeed the case:

```
sage: R=ZZ.quo(7)
sage: R in IntegralDomains() ##1
False
sage: R in Fields()
True
sage: R in IntegralDomains() ##2
True
```
you can see that the call `R in Fields()` has mutated the parent in an essential way. The kind of call that people HAVE to use to look at the category field because it is not trustworthy by itself even can change depending on what happens with the parent elsewhere!

Whether `##1` is a bug or not depends on how you interpret the question: Are we asking the mathematical truth (which in general might be undecidable) or are we asking what sage knows about the object by construction? The first would of course be nicer, but computer algebra systems often settle for the second.

The important thing here is to illustrate how easy it is to mutate parents in a significant way if you start mucking with their category.

Personally I think it's fine if `ZZ.quo(7)` doesn't advertise itself as a `field by construction`. People can ask for `GF(7)` instead, which luckily does give back a non-identical parent:

```
sage: R=ZZ.quo(7)
sage: R2=GF(7)
sage: id(R)
85206256
sage: id(R2)
17095856
```
By the way:

```
sage: R.category()
Join of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets
sage: R2.category()
Join of Category of subquotients of monoids and Category of quotients of semigroups and Category of finite fields
```
I have to say those values do a good job of dissuading people from ever looking at them!

Also, this discussion is not of direct relevance to this ticket, so perhaps we should take the discussion to sage-devel instead.



---

archive/issue_comments_220682.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [nbruin](#comment%3A20):\n> I think we really need another way to cache whether a ring is a field then.\n\n\nAnother instance of a weak cache perhaps? But if I recall correctly, I played with weak caches of the \"is_Field\" function -- and the speed was not competitive.\n\nAlso note that changing the category of the ring has indirect advantages: There may be more parent and element methods become available when passing to a sub-category.\n\nI would say the change of category is allowed when one could have chosen that category during initialisation, and if the only reason for *not* doing so during initialisation is efficiency: I have seen applications involving matrix spaces, for which it really did not matter whether the matrix space is a vector space or an algebra or just a set -- I just don't remember the ticket number. Hence, in these applications, one would *postpone* the initialisation of the category of a matrix space, and only do it when necessary.\n\nAnd in the case of ring versus field, I could imagine that there are examples in which one just needs to know that a given parent is a ring. In these applications, it would be a waste of time to determine during creation of the parent whether it actually is a field or not (which may involve primality tests). Hence, for efficiency, one should postpone the test of \"being a field\" until it is really needed.\n\n> Also, this discussion is not of direct relevance to this ticket, so perhaps we should take the discussion to sage-devel instead.\n\n\n+1.\n\nThe \"change of category\" has not been introduced here, and not in #13370 either. In fact, in the good old times, it was possible to have `P in Fields()` and `P not in IntegralDomains()`. Hence, I think of the refinement of categories as a progress.\n\nI therefore suggest to use a new ticket, if someone finds a more satisfying solution of the \"speed versus immutability problem\".",
    "created_at": "2013-02-10T22:24:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220682",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:21'></a>
Replying to [nbruin](#comment%3A20):
> I think we really need another way to cache whether a ring is a field then.


Another instance of a weak cache perhaps? But if I recall correctly, I played with weak caches of the "is_Field" function -- and the speed was not competitive.

Also note that changing the category of the ring has indirect advantages: There may be more parent and element methods become available when passing to a sub-category.

I would say the change of category is allowed when one could have chosen that category during initialisation, and if the only reason for *not* doing so during initialisation is efficiency: I have seen applications involving matrix spaces, for which it really did not matter whether the matrix space is a vector space or an algebra or just a set -- I just don't remember the ticket number. Hence, in these applications, one would *postpone* the initialisation of the category of a matrix space, and only do it when necessary.

And in the case of ring versus field, I could imagine that there are examples in which one just needs to know that a given parent is a ring. In these applications, it would be a waste of time to determine during creation of the parent whether it actually is a field or not (which may involve primality tests). Hence, for efficiency, one should postpone the test of "being a field" until it is really needed.

> Also, this discussion is not of direct relevance to this ticket, so perhaps we should take the discussion to sage-devel instead.


+1.

The "change of category" has not been introduced here, and not in #13370 either. In fact, in the good old times, it was possible to have `P in Fields()` and `P not in IntegralDomains()`. Hence, I think of the refinement of categories as a progress.

I therefore suggest to use a new ticket, if someone finds a more satisfying solution of the "speed versus immutability problem".



---

archive/issue_comments_220683.json:
```json
{
    "body": "<a id='comment:22'></a>\nReplying to [nbruin](#comment%3A18):\n> Replying to [nthiery](#comment%3A17):\n> > For robust results, one should always specify the category.\n\n> But that's the issue: The category *is* specified:\n> \n> Hypothetical dialogue (I'm sorry it has to be this academic--I don't presently have an actual example).\n> \n> ```\n> sage: QQ.category()\n> Category of Commutative Rings\n> sage: QQ.is_finitely_generated()\n> False\n> ```\n> Sage confirms that at this point, it's considering `QQ` as a commutative ring and as such is not finitely generated.\n> \n> ```\n> sage: QQ in Fields()\n> True\n> sage: QQ.category()\n> Category of Fields\n> sage: QQ.is_finitely_generated()\n> True\n> ```\n> Since the category here is `Fields` the question about finite generation should be considered there. Since it's a prime field I don't see how any other answer than `True` could be considered there.\n\n\nSorry, I have been ambiguous. What I mean is that, for the answer to\nbe well defined, one should specify the category at the time one asks\nwhether the object is finitely generated. Something like:\n\n```\n     sage: Q.is_finitely_generated(Fields())\n```\nor\n\n```\n     sage: Q.is_finitely_generated_field()\n```\n\nThen,\n\n```\n     sage: Q.is_finitely_generated()\n```\nwould return the answer for the current category of Q; but that's just\na lousy syntactic sugar, for the user convenience, when there is no\nambiguity.\n\n> This suggests to me that the concept of finite generation is not\n> well-behaved w.r.t. restricting to *full subcategories*.\n\n\nIt's just not well defined if you don't specify explicitly for which\ncategory you are asking the question.\n\nCheers,\n                                     Nicolas",
    "created_at": "2013-02-11T18:38:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220683",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:22'></a>
Replying to [nbruin](#comment%3A18):
> Replying to [nthiery](#comment%3A17):
> > For robust results, one should always specify the category.

> But that's the issue: The category *is* specified:
> 
> Hypothetical dialogue (I'm sorry it has to be this academic--I don't presently have an actual example).
> 
> ```
> sage: QQ.category()
> Category of Commutative Rings
> sage: QQ.is_finitely_generated()
> False
> ```
> Sage confirms that at this point, it's considering `QQ` as a commutative ring and as such is not finitely generated.
> 
> ```
> sage: QQ in Fields()
> True
> sage: QQ.category()
> Category of Fields
> sage: QQ.is_finitely_generated()
> True
> ```
> Since the category here is `Fields` the question about finite generation should be considered there. Since it's a prime field I don't see how any other answer than `True` could be considered there.


Sorry, I have been ambiguous. What I mean is that, for the answer to
be well defined, one should specify the category at the time one asks
whether the object is finitely generated. Something like:

```
     sage: Q.is_finitely_generated(Fields())
```
or

```
     sage: Q.is_finitely_generated_field()
```

Then,

```
     sage: Q.is_finitely_generated()
```
would return the answer for the current category of Q; but that's just
a lousy syntactic sugar, for the user convenience, when there is no
ambiguity.

> This suggests to me that the concept of finite generation is not
> well-behaved w.r.t. restricting to *full subcategories*.


It's just not well defined if you don't specify explicitly for which
category you are asking the question.

Cheers,
                                     Nicolas



---

archive/issue_comments_220684.json:
```json
{
    "body": "<a id='comment:23'></a>\nReplying to [nthiery](#comment%3A22):\n[...]\nWould you take this discussion to sage-devel, please? These are very important points that will need good thought and solutions, so there are likely more people interested in them. Also, these issues are not really directly relevant to this ticket.",
    "created_at": "2013-02-11T18:53:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220684",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:23'></a>
Replying to [nthiery](#comment%3A22):
[...]
Would you take this discussion to sage-devel, please? These are very important points that will need good thought and solutions, so there are likely more people interested in them. Also, these issues are not really directly relevant to this ticket.



---

archive/issue_comments_220685.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [nbruin](#comment%3A20):\n> I think we really need another way to cache whether a ring is a field then. What you describe is indeed the case:\n> \n> ```\n> sage: R=ZZ.quo(7)\n> sage: R in IntegralDomains() ##1\n> False\n> sage: R in Fields()\n> True\n> sage: R in IntegralDomains() ##2\n> True\n> ```\n> you can see that the call `R in Fields()` has mutated the parent in an essential way. The kind of call that people HAVE to use to look at the category field because it is not trustworthy by itself even can change depending on what happens with the parent elsewhere!\n> \n> Whether `##1` is a bug or not depends on how you interpret the question: Are we asking the mathematical truth (which in general might be undecidable) or are we asking what sage knows about the object by construction? The first would of course be nicer, but computer algebra systems often settle for the second.\n\n\nBy design, the category of an object in Sage describes:\n\n(a) It's \"operations\" (additive structure, multiplicative\nstructure). This conditions what the morphisms are in the category.\n\n(b) The properties of the operations that Sage is aware of at this\n    point in time (either because they were specified by the user or\n    discovered during some computation).\n\nNote that the distinction between (a) and (b) will be made clearer\nwith the upcoming functorial construction patch #10963 which\nintroduces an infrastructure for \"axioms\" for (b).\n\nI totally agree that (a) should not change over the lifetime of an\nobject. But I consider it a very important feature that (b) can change\nover time: when we discover new properties of an object, we want to\nexploit them to use better algorithms. And we might as well have every\nreference to that object in the current Sage session benefit from the\nimprovement.\n\nOf course, for that to make sense, changing (b) should only influence\nefficiency, and not change the *semantic* of questions; for that the\nquestions should be unambiguous.\n\nNote that GAP is doing (b) intensively for precisely that reason\n(although they use a different mechanism, through method selection\nrather than object orientation).\n\n> By the way:\n> \n> ```\n> sage: R.category()\n> Join of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets\n> sage: R2.category()\n> Join of Category of subquotients of monoids and Category of quotients of semigroups and Category of finite fields\n> ```\n> I have to say those values do a good job of dissuading people from ever looking at them!\n\n\nWorking on that :-) With my current functorial patch, this should be\nroughly \"Category of finite commutative quotient fields.\"\n\nCheers,\n                                 Nicolas",
    "created_at": "2013-02-11T19:14:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220685",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:24'></a>
Replying to [nbruin](#comment%3A20):
> I think we really need another way to cache whether a ring is a field then. What you describe is indeed the case:
> 
> ```
> sage: R=ZZ.quo(7)
> sage: R in IntegralDomains() ##1
> False
> sage: R in Fields()
> True
> sage: R in IntegralDomains() ##2
> True
> ```
> you can see that the call `R in Fields()` has mutated the parent in an essential way. The kind of call that people HAVE to use to look at the category field because it is not trustworthy by itself even can change depending on what happens with the parent elsewhere!
> 
> Whether `##1` is a bug or not depends on how you interpret the question: Are we asking the mathematical truth (which in general might be undecidable) or are we asking what sage knows about the object by construction? The first would of course be nicer, but computer algebra systems often settle for the second.


By design, the category of an object in Sage describes:

(a) It's "operations" (additive structure, multiplicative
structure). This conditions what the morphisms are in the category.

(b) The properties of the operations that Sage is aware of at this
    point in time (either because they were specified by the user or
    discovered during some computation).

Note that the distinction between (a) and (b) will be made clearer
with the upcoming functorial construction patch #10963 which
introduces an infrastructure for "axioms" for (b).

I totally agree that (a) should not change over the lifetime of an
object. But I consider it a very important feature that (b) can change
over time: when we discover new properties of an object, we want to
exploit them to use better algorithms. And we might as well have every
reference to that object in the current Sage session benefit from the
improvement.

Of course, for that to make sense, changing (b) should only influence
efficiency, and not change the *semantic* of questions; for that the
questions should be unambiguous.

Note that GAP is doing (b) intensively for precisely that reason
(although they use a different mechanism, through method selection
rather than object orientation).

> By the way:
> 
> ```
> sage: R.category()
> Join of Category of commutative rings and Category of subquotients of monoids and Category of quotients of semigroups and Category of finite enumerated sets
> sage: R2.category()
> Join of Category of subquotients of monoids and Category of quotients of semigroups and Category of finite fields
> ```
> I have to say those values do a good job of dissuading people from ever looking at them!


Working on that :-) With my current functorial patch, this should be
roughly "Category of finite commutative quotient fields."

Cheers,
                                 Nicolas



---

archive/issue_comments_220686.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [nbruin](#comment%3A23):\n> Replying to [nthiery](#comment%3A22):\n> [...]\n> Would you take this discussion to sage-devel, please? These are very important points that will need good thought and solutions, so there are likely more people interested in them. Also, these issues are not really directly relevant to this ticket.\n\n\nI totally agree. Now to start a constructive discussion on sage-devel one would need to write a short synthesis of the above discussion. With Sage Days 45 just starting, I just don't have the time now for that. But please proceed if you can!",
    "created_at": "2013-02-11T19:16:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220686",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:25'></a>
Replying to [nbruin](#comment%3A23):
> Replying to [nthiery](#comment%3A22):
> [...]
> Would you take this discussion to sage-devel, please? These are very important points that will need good thought and solutions, so there are likely more people interested in them. Also, these issues are not really directly relevant to this ticket.


I totally agree. Now to start a constructive discussion on sage-devel one would need to write a short synthesis of the above discussion. With Sage Days 45 just starting, I just don't have the time now for that. But please proceed if you can!



---

archive/issue_comments_220687.json:
```json
{
    "body": "<a id='comment:26'></a>\nSorry I had missed the thread you had already created ...",
    "created_at": "2013-02-11T19:16:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220687",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:26'></a>
Sorry I had missed the thread you had already created ...



---

archive/issue_comments_220688.json:
```json
{
    "body": "**Changing status** from needs_review to needs_info.",
    "created_at": "2013-02-14T15:01:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220688",
    "user": "https://github.com/saraedum"
}
```

**Changing status** from needs_review to needs_info.



---

archive/issue_comments_220689.json:
```json
{
    "body": "**Reviewer:** Julian Rueth",
    "created_at": "2013-02-14T15:01:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220689",
    "user": "https://github.com/saraedum"
}
```

**Reviewer:** Julian Rueth



---

archive/issue_comments_220690.json:
```json
{
    "body": "<a id='comment:27'></a>\nSimon, in `local_generic.py` you add a category parameter but seem to ignore it. Was that intended?",
    "created_at": "2013-02-14T15:01:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220690",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:27'></a>
Simon, in `local_generic.py` you add a category parameter but seem to ignore it. Was that intended?



---

archive/issue_comments_220691.json:
```json
{
    "body": "**Changing status** from needs_info to needs_review.",
    "created_at": "2013-02-14T17:40:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220691",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from needs_info to needs_review.



---

archive/issue_comments_220692.json:
```json
{
    "body": "<a id='comment:28'></a>\nAttachment [trac14084_integral_domains.patch](tarball://root/attachments/some-uuid/ticket14084/trac14084_integral_domains.patch) by @simon-king-jena created at 2013-02-14 17:40:06\n\nReplying to [saraedum](#comment%3A27):\n> Simon, in `local_generic.py` you add a category parameter but seem to ignore it. Was that intended?\n\n\nNo. Originally I thought of a different way to initialise stuff, because I thought that `LocalGeneric` is the base class of *both* power series rings and p-adic rings. So, I expected that the sub-classes would eventually like to pass a `category` to the init method of `LocalGeneric`.\n\nBut since it is only used for p-adic rings, it isn't needed.\n\nThe questions remain:\n\n- *Should* power series inherit from `LocalGeneric`? This would be for a different ticket.\n- Since power series do not inherit from `LocalGeneric`, shouldn't the documentation of local_generic.py be corrected accordingly?\n\nAnyway. I have updated the patch.",
    "created_at": "2013-02-14T17:40:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220692",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:28'></a>
Attachment [trac14084_integral_domains.patch](tarball://root/attachments/some-uuid/ticket14084/trac14084_integral_domains.patch) by @simon-king-jena created at 2013-02-14 17:40:06

Replying to [saraedum](#comment%3A27):
> Simon, in `local_generic.py` you add a category parameter but seem to ignore it. Was that intended?


No. Originally I thought of a different way to initialise stuff, because I thought that `LocalGeneric` is the base class of *both* power series rings and p-adic rings. So, I expected that the sub-classes would eventually like to pass a `category` to the init method of `LocalGeneric`.

But since it is only used for p-adic rings, it isn't needed.

The questions remain:

- *Should* power series inherit from `LocalGeneric`? This would be for a different ticket.
- Since power series do not inherit from `LocalGeneric`, shouldn't the documentation of local_generic.py be corrected accordingly?

Anyway. I have updated the patch.



---

archive/issue_comments_220693.json:
```json
{
    "body": "<a id='comment:29'></a>\nReplying to [SimonKing](#comment%3A28):\n> The questions remain:\n> \n> - *Should* power series inherit from `LocalGeneric`? This would be for a different ticket.\n \nIn theory they should. Otherwise we would not need the distinction of `pAdicGeneric` and `LocalGeneric`. I guess we should open a new ticket and see if anything bad happens if they do.\n \n> Anyway. I have updated the patch.\n  \nGreat. I'll wait for the patchbot to test this, and then I'll set it to positive review.",
    "created_at": "2013-02-14T18:01:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220693",
    "user": "https://github.com/saraedum"
}
```

<a id='comment:29'></a>
Replying to [SimonKing](#comment%3A28):
> The questions remain:
> 
> - *Should* power series inherit from `LocalGeneric`? This would be for a different ticket.
 
In theory they should. Otherwise we would not need the distinction of `pAdicGeneric` and `LocalGeneric`. I guess we should open a new ticket and see if anything bad happens if they do.
 
> Anyway. I have updated the patch.
  
Great. I'll wait for the patchbot to test this, and then I'll set it to positive review.



---

archive/issue_comments_220694.json:
```json
{
    "body": "<a id='comment:30'></a>\nThe patchbot seems to like it...",
    "created_at": "2013-02-15T16:12:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220694",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:30'></a>
The patchbot seems to like it...



---

archive/issue_comments_220695.json:
```json
{
    "body": "**Changing status** from needs_review to positive_review.",
    "created_at": "2013-02-17T16:46:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220695",
    "user": "https://github.com/saraedum"
}
```

**Changing status** from needs_review to positive_review.



---

archive/issue_events_045846.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-02-17T19:08:26Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "milestone": "sage-5.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14084#event-45846"
}
```



---

archive/issue_comments_220696.json:
```json
{
    "body": "**Merged:** sage-5.8.beta0",
    "created_at": "2013-02-19T06:48:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220696",
    "user": "https://github.com/jdemeyer"
}
```

**Merged:** sage-5.8.beta0



---

archive/issue_comments_220697.json:
```json
{
    "body": "**Resolution:** fixed",
    "created_at": "2013-02-19T06:48:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14084#issuecomment-220697",
    "user": "https://github.com/jdemeyer"
}
```

**Resolution:** fixed



---

archive/issue_events_045847.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-02-19T06:48:46Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/14084",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14084#event-45847"
}
```
