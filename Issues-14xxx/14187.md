# Issue 14187: Check that lazy imports are not resolved during startup

archive/issues_013983.json:
```json
{
    "assignees": [],
    "body": "Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap.\n\nApply: [attachment: trac_14187_lazy_import_test.patch](https://github.com/sagemath/sage/files/ticket14187/trac_14187_lazy_import_test.patch.gz)\n\nDepends on #12543\n\nCC:  @nthiery @robertwb\n\nReviewer: **Nicolas M. Thi\u00e9ry, Travis Scrimshaw**\n\nAuthor: **Volker Braun**\n\nMerged: **sage-5.10.beta1**\n\nComponent: **performance**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/14187_\n\n",
    "closed_at": "2013-04-30T09:38:59Z",
    "created_at": "2013-02-26T17:49:53Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/performance",
        "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-5.10",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Check that lazy imports are not resolved during startup",
    "type": "issue",
    "updated_at": "2013-04-30T09:38:59Z",
    "url": "https://github.com/sagemath/sage/issues/14187",
    "user": "https://github.com/vbraun"
}
```
Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap.

Apply: [attachment: trac_14187_lazy_import_test.patch](https://github.com/sagemath/sage/files/ticket14187/trac_14187_lazy_import_test.patch.gz)

Depends on #12543

CC:  @nthiery @robertwb

Reviewer: **Nicolas M. Thi√©ry, Travis Scrimshaw**

Author: **Volker Braun**

Merged: **sage-5.10.beta1**

Component: **performance**

_Issue created by migration from https://trac.sagemath.org/ticket/14187_





---

archive/issue_events_200619.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-02-26T17:49:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "milestone_number": null,
    "milestone_title": "sage-5.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200619"
}
```



---

archive/issue_events_200620.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-02-26T17:49:53Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p: 3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200620"
}
```



---

archive/issue_events_200621.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-02-26T17:52:12Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200621"
}
```



---

archive/issue_comments_169240.json:
```json
{
    "body": "Author: **Volker Braun**",
    "created_at": "2013-02-26T17:52:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169240",
    "user": "https://github.com/vbraun"
}
```

Author: **Volker Braun**



---

archive/issue_comments_169241.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,5 +1,17 @@\n-With the ticket:\n+Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap. With the ticket:\n \n ```\n-\n+----------------------------------------------------------------------\n+| Sage Version 5.8.beta1, Release Date: 2013-02-24                   |\n+| Type \"notebook()\" for the browser-based notebook interface.        |\n+| Type \"help()\" for help.                                            |\n+----------------------------------------------------------------------\n+**********************************************************************\n+*                                                                    *\n+* Warning: this is a prerelease version, and it may be unstable.     *\n+*                                                                    *\n+**********************************************************************\n+/home/vbraun/opt/sage-5.8.beta1/local/lib/python2.7/site-packages/sage/sets/non_negative_integers.py:83: UserWarning: resolving lazy import FacadeSets during startup\n+  Parent.__init__(self, facade = ZZ, category = InfiniteEnumeratedSets().or_subcategory(category) )\n+sage: \n ```\n``````\n",
    "created_at": "2013-02-26T17:52:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169241",
    "user": "https://github.com/vbraun"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,5 +1,17 @@
-With the ticket:
+Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap. With the ticket:
 
 ```
-
+----------------------------------------------------------------------
+| Sage Version 5.8.beta1, Release Date: 2013-02-24                   |
+| Type "notebook()" for the browser-based notebook interface.        |
+| Type "help()" for help.                                            |
+----------------------------------------------------------------------
+**********************************************************************
+*                                                                    *
+* Warning: this is a prerelease version, and it may be unstable.     *
+*                                                                    *
+**********************************************************************
+/home/vbraun/opt/sage-5.8.beta1/local/lib/python2.7/site-packages/sage/sets/non_negative_integers.py:83: UserWarning: resolving lazy import FacadeSets during startup
+  Parent.__init__(self, facade = ZZ, category = InfiniteEnumeratedSets().or_subcategory(category) )
+sage: 
 ```
``````




---

archive/issue_events_200622.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-02-26T17:52:12Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/performance",
    "label_color": "696969",
    "label_name": "performance",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200622"
}
```



---

archive/issue_comments_169242.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nOh, I like this feature!!!\n\nCould we add a quick test to it? Maybe something like (not tested):\n\n```\n    sage: sage.misc.lazy_import.startup_guard = True\n    sage: lazy_import(something)\n    sage: something\n    warning ...\n    sage: sage.misc.lazy_import.finish_startup()\n    sage: sage.misc.lazy_import.finish_startup()\n    Assertion failed finish_startup() must be called exactly once\n```\n\nOnce done, and assuming that the patch bot goes green, you can put a positive review on my behalf!\n\nCheers,\n                            Nicolas",
    "created_at": "2013-02-26T18:36:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169242",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:3" align="right">comment:3</div>

Oh, I like this feature!!!

Could we add a quick test to it? Maybe something like (not tested):

```
    sage: sage.misc.lazy_import.startup_guard = True
    sage: lazy_import(something)
    sage: something
    warning ...
    sage: sage.misc.lazy_import.finish_startup()
    sage: sage.misc.lazy_import.finish_startup()
    Assertion failed finish_startup() must be called exactly once
```

Once done, and assuming that the patch bot goes green, you can put a positive review on my behalf!

Cheers,
                            Nicolas



---

archive/issue_comments_169243.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nWe still need to fix the warning about the FacadeSets, I thought you'd know what goes wrong.",
    "created_at": "2013-02-26T18:43:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169243",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:4" align="right">comment:4</div>

We still need to fix the warning about the FacadeSets, I thought you'd know what goes wrong.



---

archive/issue_comments_169244.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nReplying to [@vbraun](#comment:4):\n> We still need to fix the warning about the FacadeSets, I thought you'd know what goes wrong.\n\nI must have missed something. Which ticket is this about?\n\nNever mind; I missed the ticket description ...",
    "created_at": "2013-02-26T18:50:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169244",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:5" align="right">comment:5</div>

Replying to [@vbraun](#comment:4):
> We still need to fix the warning about the FacadeSets, I thought you'd know what goes wrong.

I must have missed something. Which ticket is this about?

Never mind; I missed the ticket description ...



---

archive/issue_comments_169245.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nOk, I investigated that, and the issue is as follow:\n\n- On Sage's startup, one create NN which is a facade set (in Sets().Facade())\n- Sets lazily imports FacadeSets to avoid an import loop: FacadeSets uses Sets,\n  but we want a reference Sets.Facades -> FacadeSets\n\n  Note that with the upcoming functorial construction that will be a\n  very common idiom even for low level categories like\n  Magma().Commutative() that we certainly will load on startup.\n\nSo the problem we are having is that LazyImport serves to purposes:\n- avoiding to load stuff on Sage's startup\n- break import loops.\n\nGranted, it's not soo nice to setup a safety guard and immediately\nprovide a way to work around it ... but what about adding an explicit\noption so that one could explicitly disable the warning when we know\nthat the lazy import is really just about breaking an import loop?\n\n      LazyImport('sage.categories.facade_sets', 'FacadeSets', dont_warn_on_startup=True)\n\nor\n\n      LazyImport('sage.categories.facade_sets', 'FacadeSets', can_be_evaluated_on_startup=True)\n\nCheers,\n                       Nicolas",
    "created_at": "2013-02-26T19:23:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169245",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:6" align="right">comment:6</div>

Ok, I investigated that, and the issue is as follow:

- On Sage's startup, one create NN which is a facade set (in Sets().Facade())
- Sets lazily imports FacadeSets to avoid an import loop: FacadeSets uses Sets,
  but we want a reference Sets.Facades -> FacadeSets

  Note that with the upcoming functorial construction that will be a
  very common idiom even for low level categories like
  Magma().Commutative() that we certainly will load on startup.

So the problem we are having is that LazyImport serves to purposes:
- avoiding to load stuff on Sage's startup
- break import loops.

Granted, it's not soo nice to setup a safety guard and immediately
provide a way to work around it ... but what about adding an explicit
option so that one could explicitly disable the warning when we know
that the lazy import is really just about breaking an import loop?

      LazyImport('sage.categories.facade_sets', 'FacadeSets', dont_warn_on_startup=True)

or

      LazyImport('sage.categories.facade_sets', 'FacadeSets', can_be_evaluated_on_startup=True)

Cheers,
                       Nicolas



---

archive/issue_comments_169246.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nHow about we just use lazy import for `NN`?",
    "created_at": "2013-02-26T20:03:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169246",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:7" align="right">comment:7</div>

How about we just use lazy import for `NN`?



---

archive/issue_comments_169247.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nReplying to [@vbraun](#comment:7):\n> How about we just use lazy import for `NN`?\n\nFair enough. Yeah, if that's easily done, go ahead. And then I'll add this option for #10963 if I really need it.\n\nCheers,",
    "created_at": "2013-02-26T20:32:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169247",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:8" align="right">comment:8</div>

Replying to [@vbraun](#comment:7):
> How about we just use lazy import for `NN`?

Fair enough. Yeah, if that's easily done, go ahead. And then I'll add this option for #10963 if I really need it.

Cheers,



---

archive/issue_comments_169248.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nI've fixed NN to only lazily import on startup. Also, I changed the user feedback from a warning to printing a traceback, otherwise its hard to figure out where exactly the undesirable import comes from.",
    "created_at": "2013-02-28T20:03:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169248",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:9" align="right">comment:9</div>

I've fixed NN to only lazily import on startup. Also, I changed the user feedback from a warning to printing a traceback, otherwise its hard to figure out where exactly the undesirable import comes from.



---

archive/issue_events_200623.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-02-28T20:03:00Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200623"
}
```



---

archive/issue_comments_169249.json:
```json
{
    "body": "Reviewer: **Nicolas M. Thi\u00e9ry**",
    "created_at": "2013-02-28T20:03:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169249",
    "user": "https://github.com/vbraun"
}
```

Reviewer: **Nicolas M. Thi√©ry**



---

archive/issue_comments_169250.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,17 +1 @@\n-Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap. With the ticket:\n-\n-```\n-----------------------------------------------------------------------\n-| Sage Version 5.8.beta1, Release Date: 2013-02-24                   |\n-| Type \"notebook()\" for the browser-based notebook interface.        |\n-| Type \"help()\" for help.                                            |\n-----------------------------------------------------------------------\n-**********************************************************************\n-*                                                                    *\n-* Warning: this is a prerelease version, and it may be unstable.     *\n-*                                                                    *\n-**********************************************************************\n-/home/vbraun/opt/sage-5.8.beta1/local/lib/python2.7/site-packages/sage/sets/non_negative_integers.py:83: UserWarning: resolving lazy import FacadeSets during startup\n-  Parent.__init__(self, facade = ZZ, category = InfiniteEnumeratedSets().or_subcategory(category) )\n-sage: \n-```\n+Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap.\n``````\n",
    "created_at": "2013-02-28T20:25:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169250",
    "user": "https://github.com/vbraun"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,17 +1 @@
-Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap. With the ticket:
-
-```
-----------------------------------------------------------------------
-| Sage Version 5.8.beta1, Release Date: 2013-02-24                   |
-| Type "notebook()" for the browser-based notebook interface.        |
-| Type "help()" for help.                                            |
-----------------------------------------------------------------------
-**********************************************************************
-*                                                                    *
-* Warning: this is a prerelease version, and it may be unstable.     *
-*                                                                    *
-**********************************************************************
-/home/vbraun/opt/sage-5.8.beta1/local/lib/python2.7/site-packages/sage/sets/non_negative_integers.py:83: UserWarning: resolving lazy import FacadeSets during startup
-  Parent.__init__(self, facade = ZZ, category = InfiniteEnumeratedSets().or_subcategory(category) )
-sage: 
-```
+Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap.
``````




---

archive/issue_comments_169251.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nAll doctests pass now...",
    "created_at": "2013-02-28T22:03:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169251",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:11" align="right">comment:11</div>

All doctests pass now...



---

archive/issue_comments_169252.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nI've added a Python function to access the value of the `startup_guard` Cython variable.",
    "created_at": "2013-02-28T22:45:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169252",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:12" align="right">comment:12</div>

I've added a Python function to access the value of the `startup_guard` Cython variable.



---

archive/issue_comments_169253.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nHi Volker!\n\nThanks for the updated patch! I am almost ready to put it a positive\nreview. Just one thing about the import of NN in\nsage/combinat/integer_vectors_mod_permgroup.py: I think one should\nrepeat the lazy import there rather than importing from `all`\nwhere it's lazy imported. Otherwise, lazy import misses information to\ncomplete its job.\n\nQuick example: in a file all.py, put:\n\n```\nfrom sage.misc.lazy_import import lazy_import\nlazy_import('sage.rings.semirings.non_negative_integer_semiring', 'NN')\n```\n\nand in blah.py:\n\n```\nimport all\nfrom all import NN\n\nprint type(all.NN)\nprint type(NN)\n\nNN(1)\n\nprint type(all.NN)\nprint type(NN)\n```\n\nWith those we get:\n\n```\nsage: import blah\n<type 'sage.misc.lazy_import.LazyImport'>\n<type 'sage.misc.lazy_import.LazyImport'>\n<class 'sage.rings.semirings.non_negative_integer_semiring.NonNegativeIntegerSemiring_with_category'>\n<type 'sage.misc.lazy_import.LazyImport'>\n```\n\nInterpretation: upon using NN, lazy import substitutes the lazy import\nobject by NN in the module where it was lazy imported. But not in\nblah! And that won't happen either if use explicitly the NN from blah:\n\n```\nsage: blah.NN\nNon negative integer semiring\nsage: type(blah.NN)\nsage.misc.lazy_import.LazyImport\nsage: blah.NN(1)\n1\nsage: type(blah.NN)\nsage.misc.lazy_import.LazyImport\n```\n\nBtw, you may want to write the output description in is_during_startup\nas `OUTPUT: a boolean`, but that's more a question of taste.\n\nCheers,",
    "created_at": "2013-03-01T17:27:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169253",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:13" align="right">comment:13</div>

Hi Volker!

Thanks for the updated patch! I am almost ready to put it a positive
review. Just one thing about the import of NN in
sage/combinat/integer_vectors_mod_permgroup.py: I think one should
repeat the lazy import there rather than importing from `all`
where it's lazy imported. Otherwise, lazy import misses information to
complete its job.

Quick example: in a file all.py, put:

```
from sage.misc.lazy_import import lazy_import
lazy_import('sage.rings.semirings.non_negative_integer_semiring', 'NN')
```

and in blah.py:

```
import all
from all import NN

print type(all.NN)
print type(NN)

NN(1)

print type(all.NN)
print type(NN)
```

With those we get:

```
sage: import blah
<type 'sage.misc.lazy_import.LazyImport'>
<type 'sage.misc.lazy_import.LazyImport'>
<class 'sage.rings.semirings.non_negative_integer_semiring.NonNegativeIntegerSemiring_with_category'>
<type 'sage.misc.lazy_import.LazyImport'>
```

Interpretation: upon using NN, lazy import substitutes the lazy import
object by NN in the module where it was lazy imported. But not in
blah! And that won't happen either if use explicitly the NN from blah:

```
sage: blah.NN
Non negative integer semiring
sage: type(blah.NN)
sage.misc.lazy_import.LazyImport
sage: blah.NN(1)
1
sage: type(blah.NN)
sage.misc.lazy_import.LazyImport
```

Btw, you may want to write the output description in is_during_startup
as `OUTPUT: a boolean`, but that's more a question of taste.

Cheers,



---

archive/issue_comments_169254.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nIsn't that just a bug in `lazy_import`? It should figure out all modules where it is currently imported and replace all occurrences.",
    "created_at": "2013-03-01T17:51:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169254",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:14" align="right">comment:14</div>

Isn't that just a bug in `lazy_import`? It should figure out all modules where it is currently imported and replace all occurrences.



---

archive/issue_comments_169255.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nReplying to [@vbraun](#comment:14):\n> Isn't that just a bug in `lazy_import`? It should figure out all modules where it is currently imported and replace all occurrences.\n\nI agree, this certainly is a missing feature. But I would not be surprised if figuring out all modules where it's imported could get tricky. I don't remember seeing any hook for an object to take some action when it's imported somewhere.\n\nAnyway, for the problem at hand, let's just do the lazy import explicitly.\n\nCheers,\n                         Nicolas",
    "created_at": "2013-03-01T19:47:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169255",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:16" align="right">comment:16</div>

Replying to [@vbraun](#comment:14):
> Isn't that just a bug in `lazy_import`? It should figure out all modules where it is currently imported and replace all occurrences.

I agree, this certainly is a missing feature. But I would not be surprised if figuring out all modules where it's imported could get tricky. I don't remember seeing any hook for an object to take some action when it's imported somewhere.

Anyway, for the problem at hand, let's just do the lazy import explicitly.

Cheers,
                         Nicolas



---

archive/issue_comments_169256.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nI disagree, imports are much more legible without the lazy_import call. And being easy to read is more important than a nanosecond saved by avoiding the lazy_import redirect. IMHO only the imports from `all.py` should use lazy imports, and the not the internal implementation of the Sage library.",
    "created_at": "2013-03-01T20:00:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169256",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:17" align="right">comment:17</div>

I disagree, imports are much more legible without the lazy_import call. And being easy to read is more important than a nanosecond saved by avoiding the lazy_import redirect. IMHO only the imports from `all.py` should use lazy imports, and the not the internal implementation of the Sage library.



---

archive/issue_comments_169257.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nReplying to [@vbraun](#comment:17):\n> I disagree, imports are much more legible without the lazy_import call. And being easy to read is more important than a nanosecond saved by avoiding the lazy_import redirect.\n\nA nanosecond multiplied by the number of times the object is used. Here it's for example used in is_canonical which is a fairly low level method. Also as much as I highly value readibility of code, as much I don't care so much about the readibility of imports (but it's a pain that pyflakes does not handle lazy imports).\n\nWell, just my personal opinion; go ahead in either way you feel better.",
    "created_at": "2013-03-01T20:20:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169257",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:18" align="right">comment:18</div>

Replying to [@vbraun](#comment:17):
> I disagree, imports are much more legible without the lazy_import call. And being easy to read is more important than a nanosecond saved by avoiding the lazy_import redirect.

A nanosecond multiplied by the number of times the object is used. Here it's for example used in is_canonical which is a fairly low level method. Also as much as I highly value readibility of code, as much I don't care so much about the readibility of imports (but it's a pain that pyflakes does not handle lazy imports).

Well, just my personal opinion; go ahead in either way you feel better.



---

archive/issue_comments_169258.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nReplying to [@vbraun](#comment:17):\n> I disagree, imports are much more legible without the lazy_import call.\n\nWould we even have a hook to do this? The problem is that `lazy_import` must register the `globals` dictionary in which to change the binding. It can do that when `lazy_import` gets called explicitly, because `globals()` gives you the appropriate dictionary then.\n\nWhen you do `from all import NN`, you get that `blah.NN` gets bound to the then current binding of `all.NN`, which is a `LazyImport` object. I don't think that at any point that `LazyImport` object gets notified that it is getting bound to an entry in a different `globals` dictionary, though. So how would `LazyImport` even know which other dictionaries to mess with in order to resolve the lazy loading? You'd have to reach quite deep into Python's import mechanism.\n\nThe \"hack-free\" solution is to avoid `from ... import` and, in time critical pieces of code, load \"all.NN\" into a local variable at runtime (which is faster anyway). Of course, that doesn't solve the readability problem ...",
    "created_at": "2013-03-01T20:54:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169258",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:19" align="right">comment:19</div>

Replying to [@vbraun](#comment:17):
> I disagree, imports are much more legible without the lazy_import call.

Would we even have a hook to do this? The problem is that `lazy_import` must register the `globals` dictionary in which to change the binding. It can do that when `lazy_import` gets called explicitly, because `globals()` gives you the appropriate dictionary then.

When you do `from all import NN`, you get that `blah.NN` gets bound to the then current binding of `all.NN`, which is a `LazyImport` object. I don't think that at any point that `LazyImport` object gets notified that it is getting bound to an entry in a different `globals` dictionary, though. So how would `LazyImport` even know which other dictionaries to mess with in order to resolve the lazy loading? You'd have to reach quite deep into Python's import mechanism.

The "hack-free" solution is to avoid `from ... import` and, in time critical pieces of code, load "all.NN" into a local variable at runtime (which is faster anyway). Of course, that doesn't solve the readability problem ...



---

archive/issue_comments_169259.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nJust query the referrers to the lazy import, should be easy.",
    "created_at": "2013-03-01T21:22:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169259",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:20" align="right">comment:20</div>

Just query the referrers to the lazy import, should be easy.



---

archive/issue_comments_169260.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nReplying to [@vbraun](#comment:20):\n> Just query the referrers to the lazy import, should be easy.\n\nDo you mean `gc.get_referrers`? That should mainly get you a list of dictionaries, indeed. You'd propose to just assume that those are `globals` dictionaries and change the bindings? That sounds horribly hacky and dangerous to me. Robert can probably comment on the wisdom of this.\n\nThere's also the question of how to change the referrers once you've found them. This is not even straightforward for a `dict`. The reference you're finding should be as a value in the dict. You don't know under which key. You'll have to query the dict for that. That's not going to be cheap (but at least only happens once).\n\nWhat if you're finding a tuple referring to it? Or a homomorphism instance? What if you're finding a module that has decided to customize itself and has a frozendict as namespace?",
    "created_at": "2013-03-01T21:45:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169260",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:21" align="right">comment:21</div>

Replying to [@vbraun](#comment:20):
> Just query the referrers to the lazy import, should be easy.

Do you mean `gc.get_referrers`? That should mainly get you a list of dictionaries, indeed. You'd propose to just assume that those are `globals` dictionaries and change the bindings? That sounds horribly hacky and dangerous to me. Robert can probably comment on the wisdom of this.

There's also the question of how to change the referrers once you've found them. This is not even straightforward for a `dict`. The reference you're finding should be as a value in the dict. You don't know under which key. You'll have to query the dict for that. That's not going to be cheap (but at least only happens once).

What if you're finding a tuple referring to it? Or a homomorphism instance? What if you're finding a module that has decided to customize itself and has a frozendict as namespace?



---

archive/issue_comments_169261.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nJust do the replacement for dicts; if your customized module wants to freeze the lazy_import in place then it should be allowed to.",
    "created_at": "2013-03-01T21:49:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169261",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:22" align="right">comment:22</div>

Just do the replacement for dicts; if your customized module wants to freeze the lazy_import in place then it should be allowed to.



---

archive/issue_comments_169262.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\ngc.get_referrers, clever. I don't see any reason why this shouldn't be fine to use (for dicts, which is the common and important case).  More powerful and less hacky than what's there.",
    "created_at": "2013-03-05T19:10:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169262",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:23" align="right">comment:23</div>

gc.get_referrers, clever. I don't see any reason why this shouldn't be fine to use (for dicts, which is the common and important case).  More powerful and less hacky than what's there.



---

archive/issue_comments_169263.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nWow, it actually works! When I quickly hacked together a trial it resulted in a failure to start up. Some funny dicts showed up, which made me a little worried about this replacement. I see you're disabling gc during the replacement, which I didn't do. Perhaps that's the key.\n\nAnyway, the dictionaries you get back on referrers can be quite big, so `ref.items()` can be a rather costly construction. If you make it\n\n```\nfor k in [k for k,v in ref.iteritems() if v is self]:\n    ref[k]=obj\n```\nyou should end up allocating a much shorter list (note that the key list needs to be made before iterating over it because you should be done iterating over the dict itself prior to modifying it, as you did).\n\nAnyway, if Robert thinks this is less evil than what was happening before, I won't complain either.",
    "created_at": "2013-03-05T20:33:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169263",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:24" align="right">comment:24</div>

Wow, it actually works! When I quickly hacked together a trial it resulted in a failure to start up. Some funny dicts showed up, which made me a little worried about this replacement. I see you're disabling gc during the replacement, which I didn't do. Perhaps that's the key.

Anyway, the dictionaries you get back on referrers can be quite big, so `ref.items()` can be a rather costly construction. If you make it

```
for k in [k for k,v in ref.iteritems() if v is self]:
    ref[k]=obj
```
you should end up allocating a much shorter list (note that the key list needs to be made before iterating over it because you should be done iterating over the dict itself prior to modifying it, as you did).

Anyway, if Robert thinks this is less evil than what was happening before, I won't complain either.



---

archive/issue_comments_169264.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nJust being curious: what's the complexity of the gc.getreferers operation?\n\nAlso, should we be put of by the following comment on http://docs.python.org/2/library/gc.html:\n\n\"Avoid using get_referrers() for any purpose other than debugging\"?",
    "created_at": "2013-03-06T03:15:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169264",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:25" align="right">comment:25</div>

Just being curious: what's the complexity of the gc.getreferers operation?

Also, should we be put of by the following comment on http://docs.python.org/2/library/gc.html:

"Avoid using get_referrers() for any purpose other than debugging"?



---

archive/issue_comments_169265.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nReplying to [@nthiery](#comment:25):\n> \"Avoid using get_referrers() for any purpose other than debugging\"?\n\nGood catch! I think we should take that very seriously. I think I read that at some point and that's probably why I felt uneasy about it. I think that idea can go out the window then.",
    "created_at": "2013-03-06T04:38:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169265",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:26" align="right">comment:26</div>

Replying to [@nthiery](#comment:25):
> "Avoid using get_referrers() for any purpose other than debugging"?

Good catch! I think we should take that very seriously. I think I read that at some point and that's probably why I felt uneasy about it. I think that idea can go out the window then.



---

archive/issue_comments_169266.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nFor the record, we are using `gc.get_referrers()` already in the Sage library.\n\nThe alternative is to walk `sys.modules` for lazy imports into modules and fall back to what we have for class-level lazy imports.\n\nBut at the end of the day lazy imports are a hack so why not have the garbage collector do the work for us?",
    "created_at": "2013-03-06T07:22:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169266",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:27" align="right">comment:27</div>

For the record, we are using `gc.get_referrers()` already in the Sage library.

The alternative is to walk `sys.modules` for lazy imports into modules and fall back to what we have for class-level lazy imports.

But at the end of the day lazy imports are a hack so why not have the garbage collector do the work for us?



---

archive/issue_comments_169267.json:
```json
{
    "body": "<div id=\"comment:28\" align=\"right\">comment:28</div>\n\nSee [this python bug](http://bugs.python.org/issue793822). The following code segfaults:\n\n```\nfrom gc import get_referrers\n\ndef iter():\n        tag = object()\n        yield tag   # 'tag' gets stored in the result tuple\n        lst = [x for x in get_referrers(tag)\n               if isinstance(x, tuple)]\n        t = lst[0]  # this *is* the result tuple\n        print t[3]  # full of nulls !\n    \ntuple(iter())\n```\nBefore we use `get_referrers` in production code you'd need to understand what goes wrong in the above example and guarantee this won't happen for the dictionaries we do replacements on.\n\nI'd think that looming segfaults are a high price to pay for the convenience of writing `NN=module.NN` rather than `lazy_import(\"other_module\",NN)`.",
    "created_at": "2013-03-06T08:06:58Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169267",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:28" align="right">comment:28</div>

See [this python bug](http://bugs.python.org/issue793822). The following code segfaults:

```
from gc import get_referrers

def iter():
        tag = object()
        yield tag   # 'tag' gets stored in the result tuple
        lst = [x for x in get_referrers(tag)
               if isinstance(x, tuple)]
        t = lst[0]  # this *is* the result tuple
        print t[3]  # full of nulls !
    
tuple(iter())
```
Before we use `get_referrers` in production code you'd need to understand what goes wrong in the above example and guarantee this won't happen for the dictionaries we do replacements on.

I'd think that looming segfaults are a high price to pay for the convenience of writing `NN=module.NN` rather than `lazy_import("other_module",NN)`.



---

archive/issue_comments_169268.json:
```json
{
    "body": "<div id=\"comment:29\" align=\"right\">comment:29</div>\n\nReplying to [@vbraun](#comment:27):\n> For the record, we are using `gc.get_referrers()` already in the Sage library.\n> \n> The alternative is to walk `sys.modules` for lazy imports into modules and fall back to what we have for class-level lazy imports.\n> \n> But at the end of the day lazy imports are a hack so why not have the garbage collector do the work for us?\n\n+1, I see this as a \"best effort\" kind of a thing anyways.\n\nIn terms of efficiency, I think it might make sense to try to attempt a lookup before iterating over the (potentially very large) dict.",
    "created_at": "2013-03-06T08:59:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169268",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:29" align="right">comment:29</div>

Replying to [@vbraun](#comment:27):
> For the record, we are using `gc.get_referrers()` already in the Sage library.
> 
> The alternative is to walk `sys.modules` for lazy imports into modules and fall back to what we have for class-level lazy imports.
> 
> But at the end of the day lazy imports are a hack so why not have the garbage collector do the work for us?

+1, I see this as a "best effort" kind of a thing anyways.

In terms of efficiency, I think it might make sense to try to attempt a lookup before iterating over the (potentially very large) dict.



---

archive/issue_comments_169269.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nReplying to [@nbruin](#comment:28):\n> See [this python bug](http://bugs.python.org/issue793822). The following code segfaults:\n> \n> ```\n> from gc import get_referrers\n> \n> def iter():\n>         tag = object()\n>         yield tag   # 'tag' gets stored in the result tuple\n>         lst = [x for x in get_referrers(tag)\n>                if isinstance(x, tuple)]\n>         t = lst[0]  # this *is* the result tuple\n>         print t[3]  # full of nulls !\n>     \n> tuple(iter())\n> ```\n> Before we use `get_referrers` in production code you'd need to understand what goes wrong in the above example and guarantee this won't happen for the dictionaries we do replacements on.\n\nThis is intentionally creating a partially-constructed tuple and using the fact that  get_referrers() can refer to it. \"partially-constructed\" dicts are safe, if we ever run across one. \n\n> I'd think that looming segfaults are a high price to pay for the convenience of writing `NN=module.NN` rather than `lazy_import(\"other_module\",NN)`.\n\nThe convenience is in being abel to write \"from sage.foo.all import X\" and not worry about whether X was (possibly transitively) lazily imported. I think that's a big win.",
    "created_at": "2013-03-06T09:04:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169269",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:30" align="right">comment:30</div>

Replying to [@nbruin](#comment:28):
> See [this python bug](http://bugs.python.org/issue793822). The following code segfaults:
> 
> ```
> from gc import get_referrers
> 
> def iter():
>         tag = object()
>         yield tag   # 'tag' gets stored in the result tuple
>         lst = [x for x in get_referrers(tag)
>                if isinstance(x, tuple)]
>         t = lst[0]  # this *is* the result tuple
>         print t[3]  # full of nulls !
>     
> tuple(iter())
> ```
> Before we use `get_referrers` in production code you'd need to understand what goes wrong in the above example and guarantee this won't happen for the dictionaries we do replacements on.

This is intentionally creating a partially-constructed tuple and using the fact that  get_referrers() can refer to it. "partially-constructed" dicts are safe, if we ever run across one. 

> I'd think that looming segfaults are a high price to pay for the convenience of writing `NN=module.NN` rather than `lazy_import("other_module",NN)`.

The convenience is in being abel to write "from sage.foo.all import X" and not worry about whether X was (possibly transitively) lazily imported. I think that's a big win.



---

archive/issue_comments_169270.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">comment:31</div>\n\nReplying to [@robertwb](#comment:30):\n> This is intentionally creating a partially-constructed tuple and using the fact that  get_referrers() can refer to it.\n\nAgreed. It's intentionally exposing one of the dangers. That's the point of an example. We need to convince ourselves that this will never happen with a dictionary. And then probably only do replacements when `type(ref) is dict` rather than `isinstance(ref,dict)` and document that lazy imports only work in conventional `globals()` (one never knows what comes of subclassing).\n> \"partially-constructed\" dicts are safe, if we ever run across one. \n\nDo you have a reference that they are? Are you sure it's just partially constructed ones? Note that as soon as a value in a `dict` we iterate over is `NULL`, we're done for, since the value fetch will cause an `INCREF` on that `NULL` pointer. Lazy imports can be triggered to resolve at funny times, quite possibly when a class definition is being processed. At that time, the `dict` of that class has not been given out yet, so it would be under construction and I don't immediately see why it should abstain from putting a key with a null value in there already.\n\nFor infrastructure like this I'd be rather reluctant to just rely on \"it seems to work in all the cases we've tried\", especially because it would be nice if this code were robust in the face of python upgrades.\n\n(Concerning cost: the call basically requires a full `GC` sweep, so it's very expensive. If you can make sure that there are very few `lazyimport` instances then the cost may be acceptable, because the resolution of any single such instance will trigger a GC)\n\nNote that in sage, a GC can trigger the callback of a `WeakValueDict`, which can trigger an `__eq__` on an arbitrary object, which can possibly trigger the resolution of a `LazyImport`. Are you still sure `dict`s are safe to examine under those conditions?",
    "created_at": "2013-03-06T17:07:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169270",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:31" align="right">comment:31</div>

Replying to [@robertwb](#comment:30):
> This is intentionally creating a partially-constructed tuple and using the fact that  get_referrers() can refer to it.

Agreed. It's intentionally exposing one of the dangers. That's the point of an example. We need to convince ourselves that this will never happen with a dictionary. And then probably only do replacements when `type(ref) is dict` rather than `isinstance(ref,dict)` and document that lazy imports only work in conventional `globals()` (one never knows what comes of subclassing).
> "partially-constructed" dicts are safe, if we ever run across one. 

Do you have a reference that they are? Are you sure it's just partially constructed ones? Note that as soon as a value in a `dict` we iterate over is `NULL`, we're done for, since the value fetch will cause an `INCREF` on that `NULL` pointer. Lazy imports can be triggered to resolve at funny times, quite possibly when a class definition is being processed. At that time, the `dict` of that class has not been given out yet, so it would be under construction and I don't immediately see why it should abstain from putting a key with a null value in there already.

For infrastructure like this I'd be rather reluctant to just rely on "it seems to work in all the cases we've tried", especially because it would be nice if this code were robust in the face of python upgrades.

(Concerning cost: the call basically requires a full `GC` sweep, so it's very expensive. If you can make sure that there are very few `lazyimport` instances then the cost may be acceptable, because the resolution of any single such instance will trigger a GC)

Note that in sage, a GC can trigger the callback of a `WeakValueDict`, which can trigger an `__eq__` on an arbitrary object, which can possibly trigger the resolution of a `LazyImport`. Are you still sure `dict`s are safe to examine under those conditions?



---

archive/issue_comments_169271.json:
```json
{
    "body": "<div id=\"comment:32\" align=\"right\">comment:32</div>\n\nReplying to [@nbruin](#comment:31):\n> Replying to [@robertwb](#comment:30):\n> > This is intentionally creating a partially-constructed tuple and using the fact that  get_referrers() can refer to it.\n\n> Agreed. It's intentionally exposing one of the dangers. That's the point of an example. We need to convince ourselves that this will never happen with a dictionary. And then probably only do replacements when `type(ref) is dict` rather than `isinstance(ref,dict)` and document that lazy imports only work in conventional `globals()` (one never knows what comes of subclassing).\n\nTotally fine with that.\n\n> > \"partially-constructed\" dicts are safe, if we ever run across one. \n\n> Do you have a reference that they are? Are you sure it's just partially constructed ones? Note that as soon as a value in a `dict` we iterate over is `NULL`, we're done for, since the value fetch will cause an `INCREF` on that `NULL` pointer. Lazy imports can be triggered to resolve at funny times, quite possibly when a class definition is being processed. At that time, the `dict` of that class has not been given out yet, so it would be under construction and I don't immediately see why it should abstain from putting a key with a null value in there already.\n\nThere's neither an API nor motivation to insert key with a NULL value. \n\n> For infrastructure like this I'd be rather reluctant to just rely on \"it seems to work in all the cases we've tried\", especially because it would be nice if this code were robust in the face of python upgrades.\n\nAgreed. \n\n> (Concerning cost: the call basically requires a full `GC` sweep, so it's very expensive. If you can make sure that there are very few `lazyimport` instances then the cost may be acceptable, because the resolution of any single such instance will trigger a GC)\n\nFair enough. I don't think this is a huge problem, it's basically deferred startup. It could be interesting to have the ability to force all lazy imports to be resolved (perhaps even in the background...) but that could be trickier.\n\n> Note that in sage, a GC can trigger the callback of a `WeakValueDict`, which can trigger an `__eq__` on an arbitrary object, which can possibly trigger the resolution of a `LazyImport`. Are you still sure `dict`s are safe to examine under those conditions?\n\nI don't see why not. For instance, `dicts` follow the GC protocol of removing themselves from the loop when they're being destructed.",
    "created_at": "2013-03-06T19:03:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169271",
    "user": "https://github.com/robertwb"
}
```

<div id="comment:32" align="right">comment:32</div>

Replying to [@nbruin](#comment:31):
> Replying to [@robertwb](#comment:30):
> > This is intentionally creating a partially-constructed tuple and using the fact that  get_referrers() can refer to it.

> Agreed. It's intentionally exposing one of the dangers. That's the point of an example. We need to convince ourselves that this will never happen with a dictionary. And then probably only do replacements when `type(ref) is dict` rather than `isinstance(ref,dict)` and document that lazy imports only work in conventional `globals()` (one never knows what comes of subclassing).

Totally fine with that.

> > "partially-constructed" dicts are safe, if we ever run across one. 

> Do you have a reference that they are? Are you sure it's just partially constructed ones? Note that as soon as a value in a `dict` we iterate over is `NULL`, we're done for, since the value fetch will cause an `INCREF` on that `NULL` pointer. Lazy imports can be triggered to resolve at funny times, quite possibly when a class definition is being processed. At that time, the `dict` of that class has not been given out yet, so it would be under construction and I don't immediately see why it should abstain from putting a key with a null value in there already.

There's neither an API nor motivation to insert key with a NULL value. 

> For infrastructure like this I'd be rather reluctant to just rely on "it seems to work in all the cases we've tried", especially because it would be nice if this code were robust in the face of python upgrades.

Agreed. 

> (Concerning cost: the call basically requires a full `GC` sweep, so it's very expensive. If you can make sure that there are very few `lazyimport` instances then the cost may be acceptable, because the resolution of any single such instance will trigger a GC)

Fair enough. I don't think this is a huge problem, it's basically deferred startup. It could be interesting to have the ability to force all lazy imports to be resolved (perhaps even in the background...) but that could be trickier.

> Note that in sage, a GC can trigger the callback of a `WeakValueDict`, which can trigger an `__eq__` on an arbitrary object, which can possibly trigger the resolution of a `LazyImport`. Are you still sure `dict`s are safe to examine under those conditions?

I don't see why not. For instance, `dicts` follow the GC protocol of removing themselves from the loop when they're being destructed.



---

archive/issue_comments_169272.json:
```json
{
    "body": "<div id=\"comment:33\" align=\"right\">comment:33</div>\n\nI've tightened the dictionary type check and implemented the optimization where first a list of all relevant keys is created. Also rebased the patch on sage-5.8.beta4.",
    "created_at": "2013-03-11T02:42:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169272",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:33" align="right">comment:33</div>

I've tightened the dictionary type check and implemented the optimization where first a list of all relevant keys is created. Also rebased the patch on sage-5.8.beta4.



---

archive/issue_comments_169273.json:
```json
{
    "body": "Dependencies: **#12543**",
    "created_at": "2013-03-11T02:42:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169273",
    "user": "https://github.com/vbraun"
}
```

Dependencies: **#12543**



---

archive/issue_comments_169274.json:
```json
{
    "body": "<div id=\"comment:34\" align=\"right\">comment:34</div>\n\nPerformance information? In particular, it would be interesting to see:\n\n```\nsage: lazy_import(\"lazily_imported_module\",\"A\",_as=\"A1\")\nsage: lazy_import(\"lazily_imported_module\",\"A\",_as=\"A2\")\nsage: %time A1\nsage: %time A2\n```\nIt's the second lazy import resolution that's interesting: The module is already imported so in principle it's cheap, but we trigger a GC, so it's not. This is something that could happen a lot with objects that are used all around the place and yet in each place it's decided to do a lazy import (essentially the approach *required* now). Of course with the proposed approach it would be *better* to do `A2=A1` instead, or in general, only lazily import in one eagerly imported module, from where other modules import the lazy import eagerly.\n\nIt's important to know what kind of speed penalties are involved with using `lazy_import` because it's a speed optimization to begin with.",
    "created_at": "2013-03-11T16:33:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169274",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:34" align="right">comment:34</div>

Performance information? In particular, it would be interesting to see:

```
sage: lazy_import("lazily_imported_module","A",_as="A1")
sage: lazy_import("lazily_imported_module","A",_as="A2")
sage: %time A1
sage: %time A2
```
It's the second lazy import resolution that's interesting: The module is already imported so in principle it's cheap, but we trigger a GC, so it's not. This is something that could happen a lot with objects that are used all around the place and yet in each place it's decided to do a lazy import (essentially the approach *required* now). Of course with the proposed approach it would be *better* to do `A2=A1` instead, or in general, only lazily import in one eagerly imported module, from where other modules import the lazy import eagerly.

It's important to know what kind of speed penalties are involved with using `lazy_import` because it's a speed optimization to begin with.



---

archive/issue_comments_169275.json:
```json
{
    "body": "<div id=\"comment:35\" align=\"right\">comment:35</div>\n\nAs you already said, time is about the time for a gc run:\n\n```\nsage: def lazy_test():\n....:         ns = dict()\n....:         lazy_import(\"sage.rings.semirings.all\", \"NN\", \"foo\", namespace=ns)\n....:         ns['foo']._get_object()\nsage: \nsage: %timeit lazy_test()\n10 loops, best of 3: 54.1 ms per loop\n```\nI don't think we actually need the gc call, I just stuck it in there for reproducability.",
    "created_at": "2013-03-11T19:15:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169275",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:35" align="right">comment:35</div>

As you already said, time is about the time for a gc run:

```
sage: def lazy_test():
....:         ns = dict()
....:         lazy_import("sage.rings.semirings.all", "NN", "foo", namespace=ns)
....:         ns['foo']._get_object()
sage: 
sage: %timeit lazy_test()
10 loops, best of 3: 54.1 ms per loop
```
I don't think we actually need the gc call, I just stuck it in there for reproducability.



---

archive/issue_comments_169276.json:
```json
{
    "body": "<div id=\"comment:36\" align=\"right\">comment:36</div>\n\nWithout the `gc.collect()` call:\n\n```\nsage: %timeit lazy_test()\n100 loops, best of 3: 13.8 ms per loop\n```\nSo the time to figure out the referrers is non-negligible compared to the full GC run.",
    "created_at": "2013-03-11T19:44:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169276",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:36" align="right">comment:36</div>

Without the `gc.collect()` call:

```
sage: %timeit lazy_test()
100 loops, best of 3: 13.8 ms per loop
```
So the time to figure out the referrers is non-negligible compared to the full GC run.



---

archive/issue_comments_169277.json:
```json
{
    "body": "Version without the gc.collect() call",
    "created_at": "2013-03-11T19:45:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169277",
    "user": "https://github.com/vbraun"
}
```

Version without the gc.collect() call



---

archive/issue_comments_169278.json:
```json
{
    "body": "<div id=\"comment:37\" align=\"right\">comment:37</div>\n\nAttachment: **[trac_14187_lazy_everywhere.patch.gz](https://github.com/sagemath/sage/files/ticket14187/trac_14187_lazy_everywhere.patch.gz)**\n\nThe second patch doesn't work with the new doctesting framework that was recently introduced. I'm moving it into #14357 so we can at least resolve the original issue.",
    "created_at": "2013-03-26T11:10:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169278",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:37" align="right">comment:37</div>

Attachment: **[trac_14187_lazy_everywhere.patch.gz](https://github.com/sagemath/sage/files/ticket14187/trac_14187_lazy_everywhere.patch.gz)**

The second patch doesn't work with the new doctesting framework that was recently introduced. I'm moving it into #14357 so we can at least resolve the original issue.



---

archive/issue_comments_169279.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1 +1,3 @@\n Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap.\n+\n+Apply trac_14187_lazy_import_test.patch\n``````\n",
    "created_at": "2013-03-26T11:10:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169279",
    "user": "https://github.com/vbraun"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1 +1,3 @@
 Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap.
+
+Apply trac_14187_lazy_import_test.patch
``````




---

archive/issue_comments_169280.json:
```json
{
    "body": "<div id=\"comment:38\" align=\"right\">comment:38</div>\n\nThe updated patch adds support for copy() and deepcopy() to lazy imports, which is used in `backtrack.py` doctests and causes it to fail in `Family(NN, ...)`. This was not triggered before because NN was accidentally resolved during startup.",
    "created_at": "2013-03-26T11:56:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169280",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:38" align="right">comment:38</div>

The updated patch adds support for copy() and deepcopy() to lazy imports, which is used in `backtrack.py` doctests and causes it to fail in `Family(NN, ...)`. This was not triggered before because NN was accidentally resolved during startup.



---

archive/issue_comments_169281.json:
```json
{
    "body": "<div id=\"comment:39\" align=\"right\">comment:39</div>\n\nStill needs review...",
    "created_at": "2013-04-17T19:44:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169281",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:39" align="right">comment:39</div>

Still needs review...



---

archive/issue_comments_169282.json:
```json
{
    "body": "Changed reviewer from **Nicolas M. Thi\u00e9ry** to **Nicolas M. Thi\u00e9ry, Travis Scrimshaw**",
    "created_at": "2013-04-17T21:50:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169282",
    "user": "https://github.com/tscrim"
}
```

Changed reviewer from **Nicolas M. Thi√©ry** to **Nicolas M. Thi√©ry, Travis Scrimshaw**



---

archive/issue_comments_169283.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,3 +1,3 @@\n Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap.\n \n-Apply trac_14187_lazy_import_test.patch\n+Apply: [attachment: trac_14187_lazy_import_test.patch](https://github.com/sagemath/sage/files/ticket14187/trac_14187_lazy_import_test.patch.gz)\n``````\n",
    "created_at": "2013-04-17T21:50:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169283",
    "user": "https://github.com/tscrim"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,3 +1,3 @@
 Print a warning if, during startup, any lazy imports are being resolved. This beats the purpose of lazy imports so we should have a mechanism to prevent us from stepping into that trap.
 
-Apply trac_14187_lazy_import_test.patch
+Apply: [attachment: trac_14187_lazy_import_test.patch](https://github.com/sagemath/sage/files/ticket14187/trac_14187_lazy_import_test.patch.gz)
``````




---

archive/issue_events_200624.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2013-04-17T21:50:47Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200624"
}
```



---

archive/issue_events_200625.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2013-04-17T21:50:47Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200625"
}
```



---

archive/issue_comments_169284.json:
```json
{
    "body": "<div id=\"comment:40\" align=\"right\">comment:40</div>\n\nLooks good to me. I also think this is a good feature to have.\n\n(For those who don't want to read/understand the above discussion: most of it pertains to the now separate ticket #14357.)",
    "created_at": "2013-04-17T21:50:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169284",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:40" align="right">comment:40</div>

Looks good to me. I also think this is a good feature to have.

(For those who don't want to read/understand the above discussion: most of it pertains to the now separate ticket #14357.)



---

archive/issue_events_200626.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-04-18T08:14:05Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "milestone_number": null,
    "milestone_title": "sage-5.9",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200626"
}
```



---

archive/issue_events_200627.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-04-18T08:14:05Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "milestone_number": null,
    "milestone_title": "sage-5.10",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200627"
}
```



---

archive/issue_events_200628.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-04-24T07:02:48Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200628"
}
```



---

archive/issue_events_200629.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-04-24T07:02:48Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200629"
}
```



---

archive/issue_comments_169285.json:
```json
{
    "body": "<div id=\"comment:42\" align=\"right\">comment:42</div>\n\n\n```\nsage -t devel/sage/sage/misc/dev_tools.py\n**********************************************************************\nFile \"devel/sage/sage/misc/dev_tools.py\", line 142, in sage.misc.dev_tools.import_statements\nFailed example:\n    import_statements(NN)\nExpected:\n    from sage.rings.semirings.non_negative_integer_semiring import NN\nGot:\n      ** Warning **: several modules for that object: sage.all, sage.all_cmdline, sage.combinat.integer_vectors_mod_permgroup, sage.combinat.partition ...\n    from sage.rings.semirings.all import NN\n**********************************************************************\n```",
    "created_at": "2013-04-24T07:02:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169285",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:42" align="right">comment:42</div>


```
sage -t devel/sage/sage/misc/dev_tools.py
**********************************************************************
File "devel/sage/sage/misc/dev_tools.py", line 142, in sage.misc.dev_tools.import_statements
Failed example:
    import_statements(NN)
Expected:
    from sage.rings.semirings.non_negative_integer_semiring import NN
Got:
      ** Warning **: several modules for that object: sage.all, sage.all_cmdline, sage.combinat.integer_vectors_mod_permgroup, sage.combinat.partition ...
    from sage.rings.semirings.all import NN
**********************************************************************
```



---

archive/issue_comments_169286.json:
```json
{
    "body": "Attachment: **[trac_14187_lazy_import_test.patch.gz](https://github.com/sagemath/sage/files/ticket14187/trac_14187_lazy_import_test.patch.gz)**\n\nUpdated patch",
    "created_at": "2013-04-24T09:09:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169286",
    "user": "https://github.com/vbraun"
}
```

Attachment: **[trac_14187_lazy_import_test.patch.gz](https://github.com/sagemath/sage/files/ticket14187/trac_14187_lazy_import_test.patch.gz)**

Updated patch



---

archive/issue_comments_169287.json:
```json
{
    "body": "<div id=\"comment:43\" align=\"right\">comment:43</div>\n\nOops, that was part of the other patch that I split off into #14357. Fixed.",
    "created_at": "2013-04-24T09:10:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169287",
    "user": "https://github.com/vbraun"
}
```

<div id="comment:43" align="right">comment:43</div>

Oops, that was part of the other patch that I split off into #14357. Fixed.



---

archive/issue_events_200630.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-04-24T09:10:35Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200630"
}
```



---

archive/issue_events_200631.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-04-24T09:10:35Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200631"
}
```



---

archive/issue_events_200632.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-04-30T09:38:59Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200632"
}
```



---

archive/issue_events_200633.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-04-30T09:38:59Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14187#event-200633"
}
```



---

archive/issue_comments_169288.json:
```json
{
    "body": "Merged: **sage-5.10.beta1**",
    "created_at": "2013-04-30T09:38:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/14187",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14187#issuecomment-169288",
    "user": "https://github.com/jdemeyer"
}
```

Merged: **sage-5.10.beta1**
