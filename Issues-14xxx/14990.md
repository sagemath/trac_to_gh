# Issue 14990: Implement algebraic closures of finite fields

archive/issues_014753.json:
```json
{
    "body": "The goal of this ticket is a basic implementation of algebraic closures of finite fields.  Most importantly, it provides the following:\n\n- class `AlgebraicClosureFiniteField_generic` (abstract base class)\n  - method `subfield(n)` returning a tuple consisting of the subfield of order *p<sup>n</sup>* and a `RingHomomorphism_im_gens` giving the canonical embedding into the algebraic closure\n- class `AlgebraicClosureFiniteField_pseudo_conway` (implements the specific defining polynomials of the finite subfields and the relations between the generators of these subfields)\n- class `AlgebraicClosureFiniteFieldElement`\n  (mostly a wrapper around `FiniteFieldElement`, so actually an element of a finite subfield, but having the algebraic closure as its parent and taking care of coercion into larger subfields)\n- factory class `AlgebraicClosureFiniteField` (to get unique parents)\n- method `FiniteField.algebraic_closure()` (invokes the factory class)\n\nAn example using the new functionality is the following analogue of the example from #8335:\n\n```\nsage: Fbar = GF(3).algebraic_closure('z')\nsage: Fbar\nAlgebraic closure of Finite Field of size 3\nsage: F2, e2 = Fbar.subfield(2)\nsage: F3, e3 = Fbar.subfield(3)\nsage: F2\nFinite Field in z2 of size 3^2\n```\nTo add, we first embed into `Fbar`:\n\n```\nsage: x2 = e2(F2.gen())\nsage: x3 = e3(F3.gen())\nsage: x = x2 + x3\nsage: x\nz6^5 + 2*z6^4 + 2*z6^3 + z6^2 + 2*z6 + 1\nsage: x.parent() is Fbar\nTrue\n```\nOne can also do this without explicitly invoking the embeddings; as a shortcut, `Fbar` has a method `gen(n)` returning the fixed generator of the subfield of degree *n*, but as an element of `Fbar`:\n\n```\nsage: x2 == Fbar.gen(2)\nTrue\nsage: x == Fbar.gen(2) + Fbar.gen(3)\nTrue\n```\n\nIt is conceivable that there will be different coexisting implementations (deriving from `AlgebraicClosureFiniteField_generic`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.\n\n**CC:**  @roed314 jpflori jcooley dfesti @defeo @videlec erousseau\n\n**Keywords:** finite field algebraic closure\n\n**Branch:** [b0e1539b899af271fb16dcc6dadfaa7e567620b9](https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9)\n\n**Reviewer:** Vincent Delecroix\n\n**Author:** Peter Bruin\n\n**Dependencies:** #14958, #13214\n\n**Resolution:** fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/14990\n\n",
    "closed_at": "2014-05-15T17:18:32Z",
    "created_at": "2013-07-31T16:22:09Z",
    "labels": [
        "component: algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.3",
    "title": "Implement algebraic closures of finite fields",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14990",
    "user": "https://github.com/pjbruin"
}
```
The goal of this ticket is a basic implementation of algebraic closures of finite fields.  Most importantly, it provides the following:

- class `AlgebraicClosureFiniteField_generic` (abstract base class)
  - method `subfield(n)` returning a tuple consisting of the subfield of order *p<sup>n</sup>* and a `RingHomomorphism_im_gens` giving the canonical embedding into the algebraic closure
- class `AlgebraicClosureFiniteField_pseudo_conway` (implements the specific defining polynomials of the finite subfields and the relations between the generators of these subfields)
- class `AlgebraicClosureFiniteFieldElement`
  (mostly a wrapper around `FiniteFieldElement`, so actually an element of a finite subfield, but having the algebraic closure as its parent and taking care of coercion into larger subfields)
- factory class `AlgebraicClosureFiniteField` (to get unique parents)
- method `FiniteField.algebraic_closure()` (invokes the factory class)

An example using the new functionality is the following analogue of the example from #8335:

```
sage: Fbar = GF(3).algebraic_closure('z')
sage: Fbar
Algebraic closure of Finite Field of size 3
sage: F2, e2 = Fbar.subfield(2)
sage: F3, e3 = Fbar.subfield(3)
sage: F2
Finite Field in z2 of size 3^2
```
To add, we first embed into `Fbar`:

```
sage: x2 = e2(F2.gen())
sage: x3 = e3(F3.gen())
sage: x = x2 + x3
sage: x
z6^5 + 2*z6^4 + 2*z6^3 + z6^2 + 2*z6 + 1
sage: x.parent() is Fbar
True
```
One can also do this without explicitly invoking the embeddings; as a shortcut, `Fbar` has a method `gen(n)` returning the fixed generator of the subfield of degree *n*, but as an element of `Fbar`:

```
sage: x2 == Fbar.gen(2)
True
sage: x == Fbar.gen(2) + Fbar.gen(3)
True
```

It is conceivable that there will be different coexisting implementations (deriving from `AlgebraicClosureFiniteField_generic`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.

**CC:**  @roed314 jpflori jcooley dfesti @defeo @videlec erousseau

**Keywords:** finite field algebraic closure

**Branch:** [b0e1539b899af271fb16dcc6dadfaa7e567620b9](https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9)

**Reviewer:** Vincent Delecroix

**Author:** Peter Bruin

**Dependencies:** #14958, #13214

**Resolution:** fixed

Issue created by migration from https://trac.sagemath.org/ticket/14990





---

archive/issue_comments_240725.json:
```json
{
    "body": "<a id='comment:1'></a>\nAnother important question is to know what the AlgebraicClosure structure should cache.\nIf its possible not to store all data that was previously cmputed when some finite fields aren't used anymore, then it can make sense to discard it (imagine working with pseudo-Conway polynomials and only going up and up, at some point you won't care about polynomials used for small finite fields).\nThis is really arguable, but we (or I at least) had several problems before (and we still have) because pieces of Sage tend to cache too much.",
    "created_at": "2013-07-31T17:13:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240725",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:1'></a>
Another important question is to know what the AlgebraicClosure structure should cache.
If its possible not to store all data that was previously cmputed when some finite fields aren't used anymore, then it can make sense to discard it (imagine working with pseudo-Conway polynomials and only going up and up, at some point you won't care about polynomials used for small finite fields).
This is really arguable, but we (or I at least) had several problems before (and we still have) because pieces of Sage tend to cache too much.



---

archive/issue_comments_240726.json:
```json
{
    "body": "<a id='comment:2'></a>\nReplying to [jpflori](#comment%3A1):\n> Another important question is to know what the AlgebraicClosure structure should cache.\n> If its possible not to store all data that was previously cmputed when some finite fields aren't used anymore, then it can make sense to discard it (imagine working with pseudo-Conway polynomials and only going up and up, at some point you won't care about polynomials used for small finite fields).\n> This is really arguable, but we (or I at least) had several problems before (and we still have) because pieces of Sage tend to cache too much.\n\n\nYes, this is something to keep in mind.  As a first step, I imagine simply storing the polynomials for all fields that we encounter.  This could become problematic, especially when working with fields whose degree over the prime field is highly composite.  There are at least two solutions:\n- convert references to fields (polynomials) that are not maximal elements in the lattice (w.r.t. divisiblity of degrees) into weak references, so the can be garbage-collected and reconstructed from the maximal elements as needed;\n- generalise the algorithms for generating pseudo-Conway polynomials in such a way that in order to generate a pseudo-Conway polynomial of degree *n*, it doesn't need to generate pseudo-Conway polynomials for all degrees dividing *n*, but just uses a small set of polynomials that suffices to guarantee compatibility.  For example, when you have compatible fields of degrees 30 and 200 and you want to construct a field of degree 600 containing both of them, it is of course better to use only the given polynomials of degree 30 and 200, and avoid implicitly creating subfields of degrees 300, 150, 120 etc.",
    "created_at": "2013-08-01T14:36:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240726",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:2'></a>
Replying to [jpflori](#comment%3A1):
> Another important question is to know what the AlgebraicClosure structure should cache.
> If its possible not to store all data that was previously cmputed when some finite fields aren't used anymore, then it can make sense to discard it (imagine working with pseudo-Conway polynomials and only going up and up, at some point you won't care about polynomials used for small finite fields).
> This is really arguable, but we (or I at least) had several problems before (and we still have) because pieces of Sage tend to cache too much.


Yes, this is something to keep in mind.  As a first step, I imagine simply storing the polynomials for all fields that we encounter.  This could become problematic, especially when working with fields whose degree over the prime field is highly composite.  There are at least two solutions:
- convert references to fields (polynomials) that are not maximal elements in the lattice (w.r.t. divisiblity of degrees) into weak references, so the can be garbage-collected and reconstructed from the maximal elements as needed;
- generalise the algorithms for generating pseudo-Conway polynomials in such a way that in order to generate a pseudo-Conway polynomial of degree *n*, it doesn't need to generate pseudo-Conway polynomials for all degrees dividing *n*, but just uses a small set of polynomials that suffices to guarantee compatibility.  For example, when you have compatible fields of degrees 30 and 200 and you want to construct a field of degree 600 containing both of them, it is of course better to use only the given polynomials of degree 30 and 200, and avoid implicitly creating subfields of degrees 300, 150, 120 etc.



---

archive/issue_comments_240727.json:
```json
{
    "body": "**Author:** Peter Bruin",
    "created_at": "2013-08-15T14:38:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240727",
    "user": "https://github.com/pjbruin"
}
```

**Author:** Peter Bruin



---

archive/issue_comments_240728.json:
```json
{
    "body": "**Changing status** from new to needs_review.",
    "created_at": "2013-08-15T14:38:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240728",
    "user": "https://github.com/pjbruin"
}
```

**Changing status** from new to needs_review.



---

archive/issue_comments_240729.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,14 +1,14 @@\n-Algebraic closures of finite fields should be implemented.  Most importantly, we will need the following:\n+The goal of this ticket is a basic implementation of algebraic closures of finite fields.  Most importantly, it provides the following:\n \n - class `AlgebraicClosureFiniteField`\n   - method `subfield(n)` returning a tuple consisting of the subfield of order *p<sup>n</sup>* and a `RingHomomorphism_im_gens` giving the canonical embedding into the algebraic closure\n - class `AlgebraicClosureFiniteFieldElement`\n-  (should mostly be a wrapper around `FiniteFieldElement`, so actually an element of a finite subfield, but having the algebraic closure as its parent and taking care of coercion into larger subfields)\n+  (mostly a wrapper around `FiniteFieldElement`, so actually an element of a finite subfield, but having the algebraic closure as its parent and taking care of coercion into larger subfields)\n - method `FiniteField.algebraic_closure()`\n \n (Alternative names: `FiniteFieldAlgebraicClosure`, `FiniteFieldAlgebraicClosureElement`, maybe with aliases `FFpbar`, `FFpbarElement`?)\n \n-An example using the new functionality would be the following analogue of the example from #8335:\n+An example using the new functionality is the following analogue of the example from #8335:\n \n ```\n sage: Fbar = GF(3).algebraic_closure('z')\n@@ -30,7 +30,7 @@\n sage: x.parent() is Fbar\n True\n ```\n-It would be nice to do this without explicitly invoking the embeddings; as a shortcut, `Fbar` should have a method `gen(n)` returning the fixed generator of the subfield of degree *n*, but as an element of `Fbar`:\n+One can also do this without explicitly invoking the embeddings; as a shortcut, `Fbar` has a method `gen(n)` returning the fixed generator of the subfield of degree *n*, but as an element of `Fbar`:\n \n ```\n sage: x2 == Fbar.gen(2)\n@@ -39,6 +39,6 @@\n True\n ```\n \n-(The above example assumes that an `AlgebraicClosureFiniteFieldElement` is printed in the same way as the underlying `FiniteFieldElement`; we do not necessarily have to do this.)\n+(The above example shows that `AlgebraicClosureFiniteFieldElement` is printed in the same way as the underlying `FiniteFieldElement`.)\n \n-It is conceivable that there will be different coexisting implementations (classes deriving from an abstract `AlgebraicClosureFiniteField`).  The first (and easiest) to implement should use Conway polynomials and the pseudo-Conway polynomials from #14958, probably using some of the code from #8335.\n+It is conceivable that there will be different coexisting implementations (classes deriving from an abstract `AlgebraicClosureFiniteField`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.\n``````\n",
    "created_at": "2013-08-15T14:38:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240729",
    "user": "https://github.com/pjbruin"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,14 +1,14 @@
-Algebraic closures of finite fields should be implemented.  Most importantly, we will need the following:
+The goal of this ticket is a basic implementation of algebraic closures of finite fields.  Most importantly, it provides the following:
 
 - class `AlgebraicClosureFiniteField`
   - method `subfield(n)` returning a tuple consisting of the subfield of order *p<sup>n</sup>* and a `RingHomomorphism_im_gens` giving the canonical embedding into the algebraic closure
 - class `AlgebraicClosureFiniteFieldElement`
-  (should mostly be a wrapper around `FiniteFieldElement`, so actually an element of a finite subfield, but having the algebraic closure as its parent and taking care of coercion into larger subfields)
+  (mostly a wrapper around `FiniteFieldElement`, so actually an element of a finite subfield, but having the algebraic closure as its parent and taking care of coercion into larger subfields)
 - method `FiniteField.algebraic_closure()`
 
 (Alternative names: `FiniteFieldAlgebraicClosure`, `FiniteFieldAlgebraicClosureElement`, maybe with aliases `FFpbar`, `FFpbarElement`?)
 
-An example using the new functionality would be the following analogue of the example from #8335:
+An example using the new functionality is the following analogue of the example from #8335:
 
 ```
 sage: Fbar = GF(3).algebraic_closure('z')
@@ -30,7 +30,7 @@
 sage: x.parent() is Fbar
 True
 ```
-It would be nice to do this without explicitly invoking the embeddings; as a shortcut, `Fbar` should have a method `gen(n)` returning the fixed generator of the subfield of degree *n*, but as an element of `Fbar`:
+One can also do this without explicitly invoking the embeddings; as a shortcut, `Fbar` has a method `gen(n)` returning the fixed generator of the subfield of degree *n*, but as an element of `Fbar`:
 
 ```
 sage: x2 == Fbar.gen(2)
@@ -39,6 +39,6 @@
 True
 ```
 
-(The above example assumes that an `AlgebraicClosureFiniteFieldElement` is printed in the same way as the underlying `FiniteFieldElement`; we do not necessarily have to do this.)
+(The above example shows that `AlgebraicClosureFiniteFieldElement` is printed in the same way as the underlying `FiniteFieldElement`.)
 
-It is conceivable that there will be different coexisting implementations (classes deriving from an abstract `AlgebraicClosureFiniteField`).  The first (and easiest) to implement should use Conway polynomials and the pseudo-Conway polynomials from #14958, probably using some of the code from #8335.
+It is conceivable that there will be different coexisting implementations (classes deriving from an abstract `AlgebraicClosureFiniteField`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.
``````




---

archive/issue_comments_240730.json:
```json
{
    "body": "<a id='comment:3'></a>\nHere is a first implementation.  The examples in the ticket description work exactly as written.  It doesn't have a huge amount of functionality yet; for example, it would be nice to be able to factor polynomials over an algebraic closure of **F**<sub>*p*</sub>.  But this can probably wait until another ticket.",
    "created_at": "2013-08-15T14:38:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240730",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:3'></a>
Here is a first implementation.  The examples in the ticket description work exactly as written.  It doesn't have a huge amount of functionality yet; for example, it would be nice to be able to factor polynomials over an algebraic closure of **F**<sub>*p*</sub>.  But this can probably wait until another ticket.



---

archive/issue_comments_240731.json:
```json
{
    "body": "**Changing dependencies** from \"#14958\" to \"#14958, #13214\".",
    "created_at": "2013-08-15T14:38:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240731",
    "user": "https://github.com/pjbruin"
}
```

**Changing dependencies** from "#14958" to "#14958, #13214".



---

archive/issue_comments_240732.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,12 +1,12 @@\n The goal of this ticket is a basic implementation of algebraic closures of finite fields.  Most importantly, it provides the following:\n \n-- class `AlgebraicClosureFiniteField`\n+- class `AlgebraicClosureFiniteField_generic` (abstract base class)\n   - method `subfield(n)` returning a tuple consisting of the subfield of order *p<sup>n</sup>* and a `RingHomomorphism_im_gens` giving the canonical embedding into the algebraic closure\n+- class `AlgebraicClosureFiniteField_pseudo_conway` (implements the specific defining polynomials of the finite subfields and the relations between the generators of these subfields)\n - class `AlgebraicClosureFiniteFieldElement`\n   (mostly a wrapper around `FiniteFieldElement`, so actually an element of a finite subfield, but having the algebraic closure as its parent and taking care of coercion into larger subfields)\n-- method `FiniteField.algebraic_closure()`\n-\n-(Alternative names: `FiniteFieldAlgebraicClosure`, `FiniteFieldAlgebraicClosureElement`, maybe with aliases `FFpbar`, `FFpbarElement`?)\n+- factory class `AlgebraicClosureFiniteField` (to get unique parents)\n+- method `FiniteField.algebraic_closure()` (invokes the factory class)\n \n An example using the new functionality is the following analogue of the example from #8335:\n \n@@ -39,6 +39,7 @@\n True\n ```\n \n-(The above example shows that `AlgebraicClosureFiniteFieldElement` is printed in the same way as the underlying `FiniteFieldElement`.)\n+It is conceivable that there will be different coexisting implementations (deriving from `AlgebraicClosureFiniteField_generic`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.\n \n-It is conceivable that there will be different coexisting implementations (classes deriving from an abstract `AlgebraicClosureFiniteField`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.\n+Apply: [attachment:trac_14990-algebraic_closure_finite_field.patch]\n+\n``````\n",
    "created_at": "2013-08-15T15:17:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240732",
    "user": "https://github.com/pjbruin"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,12 +1,12 @@
 The goal of this ticket is a basic implementation of algebraic closures of finite fields.  Most importantly, it provides the following:
 
-- class `AlgebraicClosureFiniteField`
+- class `AlgebraicClosureFiniteField_generic` (abstract base class)
   - method `subfield(n)` returning a tuple consisting of the subfield of order *p<sup>n</sup>* and a `RingHomomorphism_im_gens` giving the canonical embedding into the algebraic closure
+- class `AlgebraicClosureFiniteField_pseudo_conway` (implements the specific defining polynomials of the finite subfields and the relations between the generators of these subfields)
 - class `AlgebraicClosureFiniteFieldElement`
   (mostly a wrapper around `FiniteFieldElement`, so actually an element of a finite subfield, but having the algebraic closure as its parent and taking care of coercion into larger subfields)
-- method `FiniteField.algebraic_closure()`
-
-(Alternative names: `FiniteFieldAlgebraicClosure`, `FiniteFieldAlgebraicClosureElement`, maybe with aliases `FFpbar`, `FFpbarElement`?)
+- factory class `AlgebraicClosureFiniteField` (to get unique parents)
+- method `FiniteField.algebraic_closure()` (invokes the factory class)
 
 An example using the new functionality is the following analogue of the example from #8335:
 
@@ -39,6 +39,7 @@
 True
 ```
 
-(The above example shows that `AlgebraicClosureFiniteFieldElement` is printed in the same way as the underlying `FiniteFieldElement`.)
+It is conceivable that there will be different coexisting implementations (deriving from `AlgebraicClosureFiniteField_generic`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.
 
-It is conceivable that there will be different coexisting implementations (classes deriving from an abstract `AlgebraicClosureFiniteField`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.
+Apply: [attachment:trac_14990-algebraic_closure_finite_field.patch]
+
``````




---

archive/issue_events_049444.json:
```json
{
    "actor": "https://github.com/pjbruin",
    "created_at": "2013-09-06T09:12:10Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "milestone": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14990#event-49444"
}
```



---

archive/issue_comments_240733.json:
```json
{
    "body": "<a id='comment:6'></a>\nPatch updated; now also implements `is_square()` and `sqrt()`, and makes doctests pass again.",
    "created_at": "2013-11-03T00:14:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240733",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:6'></a>
Patch updated; now also implements `is_square()` and `sqrt()`, and makes doctests pass again.



---

archive/attachments_020112.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "trac_14990-algebraic_closure_finite_field.patch",
    "asset_url": "tarball://root/attachments/some-uuid/ticket14990/trac_14990-algebraic_closure_finite_field.patch",
    "created_at": "2013-11-03T16:50:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "attachment",
    "url": "https://github.com/assets/some-id/some-uuid.patch",
    "user": "https://github.com/pjbruin"
}
```



---

archive/issue_comments_240734.json:
```json
{
    "body": "update (doctest coverage)",
    "created_at": "2013-11-03T16:50:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240734",
    "user": "https://github.com/pjbruin"
}
```

update (doctest coverage)



---

archive/issue_comments_240735.json:
```json
{
    "body": "<a id='comment:7'></a>\nNice work. I agree this is the way to go for Fp-bar. Here's some thoughts.\n\n1. It'd be nice to implement a `_latex_` method in the elements.\n\n2. There's a quote problem in the first paragraph of the docstring:\n\n  ```\n  '[\\Bold{F}_n:\\Bold{F}]=1`\n   ```\n\n3. I'm perplexed about the `_cmp_` function in `conway_polynomials.py`:\n\n  ```\n  sage: PCL3 = PseudoConwayLattice(3, use_database=False)\n  sage: PCL5 = PseudoConwayLattice(5, use_database=False)\n  sage: PCL3 == PCL5\n  True\n   ```\n\n   Is this the intended result?\n\n4. `F.inclusion(1, a).section()` is `None` for any `a`, this makes `_change_level` fail.\n\n5. I wonder: wouldn't it be more efficient if `_coerce_2` had a shortcut for when `x` and `y` are in the same level? (I really don't know, just wondering)\n\n6. This patch lacks some obvious coercions, for example, `F._subfield(2)(F.gen(2))`. Should this wait for another ticket, or should this ticket do it?\n\nI'd like to play around with different implementations of Fp-bar. This would help understand if the abstract class `AlgebraicClosureFiniteField_generic` is abstract enough, or if we need to think more carefully about its interface.\n\nI don't know what's best: make this ticket enter 5.13, then start experimenting? Or, rather, keep experimenting and wait the different implementations to have settled before giving positive review?\n\nIf you want to go for the first, I'd be happy to give positive review as soon as the minor problems mentioned above are solved. If you prefer the second option, would you mind switching to git, so to ease collaboration?",
    "created_at": "2013-11-07T23:07:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240735",
    "user": "https://github.com/defeo"
}
```

<a id='comment:7'></a>
Nice work. I agree this is the way to go for Fp-bar. Here's some thoughts.

1. It'd be nice to implement a `_latex_` method in the elements.

2. There's a quote problem in the first paragraph of the docstring:

  ```
  '[\Bold{F}_n:\Bold{F}]=1`
   ```

3. I'm perplexed about the `_cmp_` function in `conway_polynomials.py`:

  ```
  sage: PCL3 = PseudoConwayLattice(3, use_database=False)
  sage: PCL5 = PseudoConwayLattice(5, use_database=False)
  sage: PCL3 == PCL5
  True
   ```

   Is this the intended result?

4. `F.inclusion(1, a).section()` is `None` for any `a`, this makes `_change_level` fail.

5. I wonder: wouldn't it be more efficient if `_coerce_2` had a shortcut for when `x` and `y` are in the same level? (I really don't know, just wondering)

6. This patch lacks some obvious coercions, for example, `F._subfield(2)(F.gen(2))`. Should this wait for another ticket, or should this ticket do it?

I'd like to play around with different implementations of Fp-bar. This would help understand if the abstract class `AlgebraicClosureFiniteField_generic` is abstract enough, or if we need to think more carefully about its interface.

I don't know what's best: make this ticket enter 5.13, then start experimenting? Or, rather, keep experimenting and wait the different implementations to have settled before giving positive review?

If you want to go for the first, I'd be happy to give positive review as soon as the minor problems mentioned above are solved. If you prefer the second option, would you mind switching to git, so to ease collaboration?



---

archive/issue_comments_240736.json:
```json
{
    "body": "<a id='comment:8'></a>\nReplying to [defeo](#comment%3A7):\n> Nice work. I agree this is the way to go for Fp-bar. Here's some thoughts.\n> \n> 1. It'd be nice to implement a `_latex_` method in the elements.\n  \nSure.\n> \n> 2. There's a quote problem in the first paragraph of the docstring:\n> \n>   ```\n>   '[\\Bold{F}_n:\\Bold{F}]=1`\n>    ```\n> \n> 3. I'm perplexed about the `_cmp_` function in `conway_polynomials.py`:\n> \n>   ```\n>   sage: PCL3 = PseudoConwayLattice(3, use_database=False)\n>   sage: PCL5 = PseudoConwayLattice(5, use_database=False)\n>   sage: PCL3 == PCL5\n>   True\n>    ```\n> \n>    Is this the intended result?\n> \n  \nThis looks wrong to me.\n> 4. `F.inclusion(1, a).section()` is `None` for any `a`, this makes `_change_level` fail.\n> \n> 5. I wonder: wouldn't it be more efficient if `_coerce_2` had a shortcut for when `x` and `y` are in the same level? (I really don't know, just wondering)\n  \nStupid rant: I don' like the name _coerce_2, I don't think it really fits with our current naming scheme, nor that it really suggests what the function does (I first thought of coerce_to... of course it is two, not to).\n\nAbout the shortcut, why not, but it does not seem that urgent.\nMaybe we should do some timings.\n> \n> 6. This patch lacks some obvious coercions, for example, `F._subfield(2)(F.gen(2))`. Should this wait for another ticket, or should this ticket do it?\n> \n  \nDepends on the difficulty? :)\n> I'd like to play around with different implementations of Fp-bar. This would help understand if the abstract class `AlgebraicClosureFiniteField_generic` is abstract enough, or if we need to think more carefully about its interface.\n> \n> I don't know what's best: make this ticket enter 5.13, then start experimenting? Or, rather, keep experimenting and wait the different implementations to have settled before giving positive review?\n> \n> If you want to go for the first, I'd be happy to give positive review as soon as the minor problems mentioned above are solved. If you prefer the second option, would you mind switching to git, so to ease collaboration?\n\nI don't really know.\nI'm usually for fast inclusion.\nBut for this one I might be inclined to wait for 6.0 to give it a little more testing.\n\nIn particular, I'd like to make sure that this gets well with #715, #11521, #14711, #15303 and other coercion related stuff, though there should be no problems from what I currently see.\nWe should also to check that when the user deletes an algebraic closure objects, everything gets garbage collected.\n\nMaybe it needs some more thinking on the category framework integration with more general algebraic closures (not even sure it would make sense though)?\nI see the Factory currently sets it to Fields().\nAdditional question: how does it interact with the AlgebraicClosureFunctor from sage.categories.pushout?\nNot sure how harmful it would be to modify that after the current ticket is merged.",
    "created_at": "2013-11-08T09:37:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240736",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:8'></a>
Replying to [defeo](#comment%3A7):
> Nice work. I agree this is the way to go for Fp-bar. Here's some thoughts.
> 
> 1. It'd be nice to implement a `_latex_` method in the elements.
  
Sure.
> 
> 2. There's a quote problem in the first paragraph of the docstring:
> 
>   ```
>   '[\Bold{F}_n:\Bold{F}]=1`
>    ```
> 
> 3. I'm perplexed about the `_cmp_` function in `conway_polynomials.py`:
> 
>   ```
>   sage: PCL3 = PseudoConwayLattice(3, use_database=False)
>   sage: PCL5 = PseudoConwayLattice(5, use_database=False)
>   sage: PCL3 == PCL5
>   True
>    ```
> 
>    Is this the intended result?
> 
  
This looks wrong to me.
> 4. `F.inclusion(1, a).section()` is `None` for any `a`, this makes `_change_level` fail.
> 
> 5. I wonder: wouldn't it be more efficient if `_coerce_2` had a shortcut for when `x` and `y` are in the same level? (I really don't know, just wondering)
  
Stupid rant: I don' like the name _coerce_2, I don't think it really fits with our current naming scheme, nor that it really suggests what the function does (I first thought of coerce_to... of course it is two, not to).

About the shortcut, why not, but it does not seem that urgent.
Maybe we should do some timings.
> 
> 6. This patch lacks some obvious coercions, for example, `F._subfield(2)(F.gen(2))`. Should this wait for another ticket, or should this ticket do it?
> 
  
Depends on the difficulty? :)
> I'd like to play around with different implementations of Fp-bar. This would help understand if the abstract class `AlgebraicClosureFiniteField_generic` is abstract enough, or if we need to think more carefully about its interface.
> 
> I don't know what's best: make this ticket enter 5.13, then start experimenting? Or, rather, keep experimenting and wait the different implementations to have settled before giving positive review?
> 
> If you want to go for the first, I'd be happy to give positive review as soon as the minor problems mentioned above are solved. If you prefer the second option, would you mind switching to git, so to ease collaboration?

I don't really know.
I'm usually for fast inclusion.
But for this one I might be inclined to wait for 6.0 to give it a little more testing.

In particular, I'd like to make sure that this gets well with #715, #11521, #14711, #15303 and other coercion related stuff, though there should be no problems from what I currently see.
We should also to check that when the user deletes an algebraic closure objects, everything gets garbage collected.

Maybe it needs some more thinking on the category framework integration with more general algebraic closures (not even sure it would make sense though)?
I see the Factory currently sets it to Fields().
Additional question: how does it interact with the AlgebraicClosureFunctor from sage.categories.pushout?
Not sure how harmful it would be to modify that after the current ticket is merged.



---

archive/issue_comments_240737.json:
```json
{
    "body": "<a id='comment:9'></a>\nHi,\n\nThanks for the nice patch! I played a little bit with the patch and here are few comments (from a user point of vue).\n\nFor the `FiniteFieldAlgebraicClosure`\n\n- the method .cardinality() fails\n- .some_elements() returns a very stupid list\n- .gens() is not happy. I guess we can return a `Family`. The problem is that in the specification it is written that the method should return a tuple.\n\nFor elements\n\n- many methods can be implemented in two lines as\n\n```\n   def my_method(self):\n       return self._value.my_method()\n```\n   this concerns `minimal_polynomial`, `trace`, `norm`, `multiplicative_order`, ...\n- in a similar way (calling apropriate method of _value and applying a morphism) it is straightforward to implement `frobenius`, `pth_power`, `pth_root`, ...\n- to mimic AA or QQbar I would like a method ``as_finite_field_element(self, minimal=False)`` which return a triple (finite_field, value, homomorphism)\n\nVincent",
    "created_at": "2013-11-08T13:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240737",
    "user": "https://github.com/videlec"
}
```

<a id='comment:9'></a>
Hi,

Thanks for the nice patch! I played a little bit with the patch and here are few comments (from a user point of vue).

For the `FiniteFieldAlgebraicClosure`

- the method .cardinality() fails
- .some_elements() returns a very stupid list
- .gens() is not happy. I guess we can return a `Family`. The problem is that in the specification it is written that the method should return a tuple.

For elements

- many methods can be implemented in two lines as

```
   def my_method(self):
       return self._value.my_method()
```
   this concerns `minimal_polynomial`, `trace`, `norm`, `multiplicative_order`, ...
- in a similar way (calling apropriate method of _value and applying a morphism) it is straightforward to implement `frobenius`, `pth_power`, `pth_root`, ...
- to mimic AA or QQbar I would like a method ``as_finite_field_element(self, minimal=False)`` which return a triple (finite_field, value, homomorphism)

Vincent



---

archive/issue_comments_240738.json:
```json
{
    "body": "<a id='comment:11'></a>\nThanks to you all for the comments.  I haven't got a lot of time at the moment, but hope to get back to this ticket soon.  In the meantime, feel free to continue suggesting improvements or implementing them yourselves. 8-)",
    "created_at": "2013-11-08T13:43:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240738",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:11'></a>
Thanks to you all for the comments.  I haven't got a lot of time at the moment, but hope to get back to this ticket soon.  In the meantime, feel free to continue suggesting improvements or implementing them yourselves. 8-)



---

archive/issue_comments_240739.json:
```json
{
    "body": "<a id='comment:12'></a>\nReplying to [pbruin](#comment%3A11):\n> Thanks to you all for the comments.  I haven't got a lot of time at the moment, but hope to get back to this ticket soon.  In the meantime, feel free to continue suggesting improvements or implementing them yourselves. 8-)\n\n\nThanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?",
    "created_at": "2013-11-08T19:53:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240739",
    "user": "https://github.com/videlec"
}
```

<a id='comment:12'></a>
Replying to [pbruin](#comment%3A11):
> Thanks to you all for the comments.  I haven't got a lot of time at the moment, but hope to get back to this ticket soon.  In the meantime, feel free to continue suggesting improvements or implementing them yourselves. 8-)


Thanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?



---

archive/issue_comments_240740.json:
```json
{
    "body": "<a id='comment:13'></a>\nReplying to [vdelecroix](#comment%3A12):\n> Thanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?\n\n\nEven if this ticket doesn't switch to the git workflow, I'd be happy to pull from your branch and start experimenting. Do you mind sharing it in a comment?",
    "created_at": "2013-11-09T09:59:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240740",
    "user": "https://github.com/defeo"
}
```

<a id='comment:13'></a>
Replying to [vdelecroix](#comment%3A12):
> Thanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?


Even if this ticket doesn't switch to the git workflow, I'd be happy to pull from your branch and start experimenting. Do you mind sharing it in a comment?



---

archive/issue_comments_240741.json:
```json
{
    "body": "<a id='comment:14'></a>\nReplying to [defeo](#comment%3A13):\n> Replying to [vdelecroix](#comment%3A12):\n> > Thanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?\n  \n> \n> Even if this ticket doesn't switch to the git workflow, I'd be happy to pull from your branch and start experimenting. Do you mind sharing it in a comment?\n\n\nThis is: u/vdelecroix/14990",
    "created_at": "2013-11-09T16:17:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240741",
    "user": "https://github.com/videlec"
}
```

<a id='comment:14'></a>
Replying to [defeo](#comment%3A13):
> Replying to [vdelecroix](#comment%3A12):
> > Thanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?
  
> 
> Even if this ticket doesn't switch to the git workflow, I'd be happy to pull from your branch and start experimenting. Do you mind sharing it in a comment?


This is: u/vdelecroix/14990



---

archive/issue_comments_240742.json:
```json
{
    "body": "<a id='comment:15'></a>\nReplying to [vdelecroix](#comment%3A12):\n> Replying to [pbruin](#comment%3A11):\n> > Thanks to you all for the comments.  I haven't got a lot of time at the moment, but hope to get back to this ticket soon.  In the meantime, feel free to continue suggesting improvements or implementing them yourselves. 8-)\n\n> \n> Thanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?\n  \nI haven't done any development with Sage+Git before (only uploaded an SSH key and installed Sage using Git), but I'll start trying it out.  Once I get some facility in using it, I won't mind if this will become a Git ticket.",
    "created_at": "2013-11-09T18:57:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240742",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:15'></a>
Replying to [vdelecroix](#comment%3A12):
> Replying to [pbruin](#comment%3A11):
> > Thanks to you all for the comments.  I haven't got a lot of time at the moment, but hope to get back to this ticket soon.  In the meantime, feel free to continue suggesting improvements or implementing them yourselves. 8-)

> 
> Thanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?
  
I haven't done any development with Sage+Git before (only uploaded an SSH key and installed Sage using Git), but I'll start trying it out.  Once I get some facility in using it, I won't mind if this will become a Git ticket.



---

archive/issue_comments_240743.json:
```json
{
    "body": "<a id='comment:16'></a>\nReplying to [pbruin](#comment%3A15):\n> Replying to [vdelecroix](#comment%3A12):\n> > Replying to [pbruin](#comment%3A11):\n> > > Thanks to you all for the comments.  I haven't got a lot of time at the moment, but hope to get back to this ticket soon.  In the meantime, feel free to continue suggesting improvements or implementing them yourselves. 8-)\n\n> > \n> > Thanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?\n  \n> I haven't done any development with Sage+Git before (only uploaded an SSH key and installed Sage using Git), but I'll start trying it out.  Once I get some facility in using it, I won't mind if this will become a Git ticket.\n\nHi Peter,\n\nI switch to git only recently and it is not easy to go from git to patches (the other way around is quite easy using the sage dev scripts). I modified several things from your patch, in particular: algebraic_closure now works without argument (the name is 'z' by default). I think that I will modify the following two problems\n- .is_finite() fails on GF(3).algebraic_closure() (raise a NotImplementedError). On the other hand it will be fixed with the new category schemes which allows Field().infinite())\n- Zmod(3) does not support algebraic_closure()\n\nFrom the last version #15390 (roots of polynomial and eigenvalues) works nicely !\n\nYour work is really nice!\n\nCheers,\nVincent",
    "created_at": "2013-11-09T23:47:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240743",
    "user": "https://github.com/videlec"
}
```

<a id='comment:16'></a>
Replying to [pbruin](#comment%3A15):
> Replying to [vdelecroix](#comment%3A12):
> > Replying to [pbruin](#comment%3A11):
> > > Thanks to you all for the comments.  I haven't got a lot of time at the moment, but hope to get back to this ticket soon.  In the meantime, feel free to continue suggesting improvements or implementing them yourselves. 8-)

> > 
> > Thanks. I am happy to work on this (I already implements the remarks I made). Is that ok if I switch to the git workflow ?
  
> I haven't done any development with Sage+Git before (only uploaded an SSH key and installed Sage using Git), but I'll start trying it out.  Once I get some facility in using it, I won't mind if this will become a Git ticket.

Hi Peter,

I switch to git only recently and it is not easy to go from git to patches (the other way around is quite easy using the sage dev scripts). I modified several things from your patch, in particular: algebraic_closure now works without argument (the name is 'z' by default). I think that I will modify the following two problems
- .is_finite() fails on GF(3).algebraic_closure() (raise a NotImplementedError). On the other hand it will be fixed with the new category schemes which allows Field().infinite())
- Zmod(3) does not support algebraic_closure()

From the last version #15390 (roots of polynomial and eigenvalues) works nicely !

Your work is really nice!

Cheers,
Vincent



---

archive/issue_comments_240744.json:
```json
{
    "body": "<a id='comment:17'></a>\nNow experimenting with Git.  I made some changes to Vincent's branch and will now try to create my own branch on Trac.  You can ignore this for the moment...",
    "created_at": "2013-11-13T14:10:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240744",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:17'></a>
Now experimenting with Git.  I made some changes to Vincent's branch and will now try to create my own branch on Trac.  You can ignore this for the moment...



---

archive/issue_comments_240745.json:
```json
{
    "body": "**Branch:** [u/pbruin/14990](https://github.com/sagemath/sagetrac-mirror/tree/u/pbruin/14990)",
    "created_at": "2013-11-13T14:37:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240745",
    "user": "https://github.com/pjbruin"
}
```

**Branch:** [u/pbruin/14990](https://github.com/sagemath/sagetrac-mirror/tree/u/pbruin/14990)



---

archive/issue_comments_240746.json:
```json
{
    "body": "<a id='comment:19'></a>\nHi,\n\nIn order to speed up a bit, you could add the following lines at the very begining of the method _to_common_subfield(self, x, y) (lines 561-580)\n\n```\nif x._level == y._level:\n    return x._value, y._value\n```\n(when the level is the same I go from 3ms to 0.8ms)\n\nWhat do you think about what I suggest in [comment:15](#comment%3A15) namely, implementing .is_finite() (returning False) and do something for Zmod(3) ?\n\n---\n**Last 10 new commits:**\n<table><tr><td>[dbc331b](https://github.com/sagemath/sagetrac-mirror/commit/dbc331b)</td><td><code>rename _coerce_2 to _to_common_subfield; cosmetic changes</code></td></tr><tr><td>[ac93a01](https://github.com/sagemath/sagetrac-mirror/commit/ac93a01)</td><td><code>remove the optional name from algebraic_closure examples</code></td></tr><tr><td>[2432102](https://github.com/sagemath/sagetrac-mirror/commit/2432102)</td><td><code>allow no argument for .algebraic_closure()</code></td></tr><tr><td>[a197d0d](https://github.com/sagemath/sagetrac-mirror/commit/a197d0d)</td><td><code>Merge branch 'u/vdelecroix/14990' of ssh://trac.sagemath.org:2222/sage into 14990</code></td></tr><tr><td>[f232993](https://github.com/sagemath/sagetrac-mirror/commit/f232993)</td><td><code>fix the parent in pth_root and pth_power</code></td></tr><tr><td>[0f4b895](https://github.com/sagemath/sagetrac-mirror/commit/0f4b895)</td><td><code>add examples to .cardinality()</code></td></tr><tr><td>[d95f57f](https://github.com/sagemath/sagetrac-mirror/commit/d95f57f)</td><td><code>more methods to algebraic elements</code></td></tr><tr><td>[081c096](https://github.com/sagemath/sagetrac-mirror/commit/081c096)</td><td><code>Trac 14990: implement algebraic closures of finite fields</code></td></tr><tr><td>[31045f7](https://github.com/sagemath/sagetrac-mirror/commit/31045f7)</td><td><code>fix the parent in pth_root and pth_power</code></td></tr><tr><td>[3d88af6](https://github.com/sagemath/sagetrac-mirror/commit/3d88af6)</td><td><code>add examples to .cardinality()</code></td></tr></table>\n",
    "created_at": "2013-11-13T15:19:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240746",
    "user": "https://github.com/videlec"
}
```

<a id='comment:19'></a>
Hi,

In order to speed up a bit, you could add the following lines at the very begining of the method _to_common_subfield(self, x, y) (lines 561-580)

```
if x._level == y._level:
    return x._value, y._value
```
(when the level is the same I go from 3ms to 0.8ms)

What do you think about what I suggest in [comment:15](#comment%3A15) namely, implementing .is_finite() (returning False) and do something for Zmod(3) ?

---
**Last 10 new commits:**
<table><tr><td>[dbc331b](https://github.com/sagemath/sagetrac-mirror/commit/dbc331b)</td><td><code>rename _coerce_2 to _to_common_subfield; cosmetic changes</code></td></tr><tr><td>[ac93a01](https://github.com/sagemath/sagetrac-mirror/commit/ac93a01)</td><td><code>remove the optional name from algebraic_closure examples</code></td></tr><tr><td>[2432102](https://github.com/sagemath/sagetrac-mirror/commit/2432102)</td><td><code>allow no argument for .algebraic_closure()</code></td></tr><tr><td>[a197d0d](https://github.com/sagemath/sagetrac-mirror/commit/a197d0d)</td><td><code>Merge branch 'u/vdelecroix/14990' of ssh://trac.sagemath.org:2222/sage into 14990</code></td></tr><tr><td>[f232993](https://github.com/sagemath/sagetrac-mirror/commit/f232993)</td><td><code>fix the parent in pth_root and pth_power</code></td></tr><tr><td>[0f4b895](https://github.com/sagemath/sagetrac-mirror/commit/0f4b895)</td><td><code>add examples to .cardinality()</code></td></tr><tr><td>[d95f57f](https://github.com/sagemath/sagetrac-mirror/commit/d95f57f)</td><td><code>more methods to algebraic elements</code></td></tr><tr><td>[081c096](https://github.com/sagemath/sagetrac-mirror/commit/081c096)</td><td><code>Trac 14990: implement algebraic closures of finite fields</code></td></tr><tr><td>[31045f7](https://github.com/sagemath/sagetrac-mirror/commit/31045f7)</td><td><code>fix the parent in pth_root and pth_power</code></td></tr><tr><td>[3d88af6](https://github.com/sagemath/sagetrac-mirror/commit/3d88af6)</td><td><code>add examples to .cardinality()</code></td></tr></table>




---

archive/issue_comments_240747.json:
```json
{
    "body": "**Commit:** [dbc331bb85d634cb9cb6c75ad8dd82764c066f39](https://github.com/sagemath/sagetrac-mirror/commit/dbc331bb85d634cb9cb6c75ad8dd82764c066f39)",
    "created_at": "2013-11-13T15:19:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240747",
    "user": "https://github.com/videlec"
}
```

**Commit:** [dbc331bb85d634cb9cb6c75ad8dd82764c066f39](https://github.com/sagemath/sagetrac-mirror/commit/dbc331bb85d634cb9cb6c75ad8dd82764c066f39)



---

archive/issue_comments_240748.json:
```json
{
    "body": "<a id='comment:20'></a>\nReplying to [vdelecroix](#comment%3A19):\n> In order to speed up a bit, you could add the following lines at the very begining of the method _to_common_subfield(self, x, y) (lines 561-580)\n\nI guess I could, but would you mind doing this yourself?  (First because it's your change, but also so that I can get an idea about what this causes Git to do.  If this kind of thing works smoothly, I'd be happy to definitively make this a Git ticket.)  Or do I have to somehow change permissions on my branch for that?",
    "created_at": "2013-11-13T15:38:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240748",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:20'></a>
Replying to [vdelecroix](#comment%3A19):
> In order to speed up a bit, you could add the following lines at the very begining of the method _to_common_subfield(self, x, y) (lines 561-580)

I guess I could, but would you mind doing this yourself?  (First because it's your change, but also so that I can get an idea about what this causes Git to do.  If this kind of thing works smoothly, I'd be happy to definitively make this a Git ticket.)  Or do I have to somehow change permissions on my branch for that?



---

archive/issue_comments_240749.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [pbruin](#comment%3A20):\n> Replying to [vdelecroix](#comment%3A19):\n> > In order to speed up a bit, you could add the following lines at the very begining of the method _to_common_subfield(self, x, y) (lines 561-580)\n\n> I guess I could, but would you mind doing this yourself?  (First because it's your change, but also so that I can get an idea about what this causes Git to do.  If this kind of thing works smoothly, I'd be happy to definitively make this a Git ticket.)  Or do I have to somehow change permissions on my branch for that?\n\nI can not have write access to your branch on trac. But nevertheless it is still possible to synchronize our works. I will do the modification inside my branch u/vdelecroix/14990 and then you can update the changes to your local branch with\n\n```\n$ git checkout THE_NAME_OF_MY_LOCAL_BRANCH_FOR_14990\n$ git pull trac u/vdelecroix/14990\n$ git reset --merge\n```\nOnce it is done you can just push the changes to your branch u/pruin/14990 on trac. The second command above pull the changes but do not reset the HEAD. The third one is precisely here for that purpose: it reset the head to the current FETCH_HEAD obtained from pull.\n\nI will tell you when I am done.",
    "created_at": "2013-11-13T15:51:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240749",
    "user": "https://github.com/videlec"
}
```

<a id='comment:21'></a>
Replying to [pbruin](#comment%3A20):
> Replying to [vdelecroix](#comment%3A19):
> > In order to speed up a bit, you could add the following lines at the very begining of the method _to_common_subfield(self, x, y) (lines 561-580)

> I guess I could, but would you mind doing this yourself?  (First because it's your change, but also so that I can get an idea about what this causes Git to do.  If this kind of thing works smoothly, I'd be happy to definitively make this a Git ticket.)  Or do I have to somehow change permissions on my branch for that?

I can not have write access to your branch on trac. But nevertheless it is still possible to synchronize our works. I will do the modification inside my branch u/vdelecroix/14990 and then you can update the changes to your local branch with

```
$ git checkout THE_NAME_OF_MY_LOCAL_BRANCH_FOR_14990
$ git pull trac u/vdelecroix/14990
$ git reset --merge
```
Once it is done you can just push the changes to your branch u/pruin/14990 on trac. The second command above pull the changes but do not reset the HEAD. The third one is precisely here for that purpose: it reset the head to the current FETCH_HEAD obtained from pull.

I will tell you when I am done.



---

archive/issue_comments_240750.json:
```json
{
    "body": "<a id='comment:22'></a>\nHey,\nI'm not sure using pull/reset is the safer and best way to share your work together.\nWhat I would do, but I might be wrong, is to track the other one branch as a remote.\nThen go to my local branch and merge the other one latest changes.\n* \"git fetch --all\" (or just the remote name if you don't want --all) to update the remote branch.\n* \"git checkout my_local_branch\" to go to my branch.\n* \"git merge remote_name\" to merge the remote change locally.\nBest,\nJP",
    "created_at": "2013-11-13T15:56:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240750",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:22'></a>
Hey,
I'm not sure using pull/reset is the safer and best way to share your work together.
What I would do, but I might be wrong, is to track the other one branch as a remote.
Then go to my local branch and merge the other one latest changes.
* "git fetch --all" (or just the remote name if you don't want --all) to update the remote branch.
* "git checkout my_local_branch" to go to my branch.
* "git merge remote_name" to merge the remote change locally.
Best,
JP



---

archive/issue_comments_240751.json:
```json
{
    "body": "<a id='comment:23'></a>\nHey,\n\nThanks Jean-Pierre for the suggestion. My method is what is described in the [developer guide](http://sagemath.github.io/git-developer-guide/manual_git.html#getting_changes). Anyway, how should I do to declare u/pbruin/14990 on trac has a remote ?\n\nBest,\nVincent",
    "created_at": "2013-11-13T16:09:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240751",
    "user": "https://github.com/videlec"
}
```

<a id='comment:23'></a>
Hey,

Thanks Jean-Pierre for the suggestion. My method is what is described in the [developer guide](http://sagemath.github.io/git-developer-guide/manual_git.html#getting_changes). Anyway, how should I do to declare u/pbruin/14990 on trac has a remote ?

Best,
Vincent



---

archive/issue_comments_240752.json:
```json
{
    "body": "<a id='comment:24'></a>\nHi,\n\nI push my changes to u/vdelecroix/14990. For the Zmod(p) suggestion it is actually possible to obtain the algebraic closure with\n\n```\nsage: Zmod(3).field().algebraic_closure()\nAlgebraic closure of Finite Field of size 3\n```\nSo I think there is nothing to change here.\n\nV.",
    "created_at": "2013-11-13T16:18:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240752",
    "user": "https://github.com/videlec"
}
```

<a id='comment:24'></a>
Hi,

I push my changes to u/vdelecroix/14990. For the Zmod(p) suggestion it is actually possible to obtain the algebraic closure with

```
sage: Zmod(3).field().algebraic_closure()
Algebraic closure of Finite Field of size 3
```
So I think there is nothing to change here.

V.



---

archive/issue_comments_240753.json:
```json
{
    "body": "**Changing commit** from \"[dbc331bb85d634cb9cb6c75ad8dd82764c066f39](https://github.com/sagemath/sagetrac-mirror/commit/dbc331bb85d634cb9cb6c75ad8dd82764c066f39)\" to \"[f8540ae3547c28c717c41a44b7791f86d596427e](https://github.com/sagemath/sagetrac-mirror/commit/f8540ae3547c28c717c41a44b7791f86d596427e)\".",
    "created_at": "2013-11-13T17:25:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240753",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[dbc331bb85d634cb9cb6c75ad8dd82764c066f39](https://github.com/sagemath/sagetrac-mirror/commit/dbc331bb85d634cb9cb6c75ad8dd82764c066f39)" to "[f8540ae3547c28c717c41a44b7791f86d596427e](https://github.com/sagemath/sagetrac-mirror/commit/f8540ae3547c28c717c41a44b7791f86d596427e)".



---

archive/issue_comments_240754.json:
```json
{
    "body": "<a id='comment:25'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[f8540ae](https://github.com/sagemath/sagetrac-mirror/commit/f8540ae)</td><td><code>fix comparison of pseudo-Conway polynomial trees</code></td></tr><tr><td>[d6cf8d6](https://github.com/sagemath/sagetrac-mirror/commit/d6cf8d6)</td><td><code>tiny optimization for _to_common_subfield and implementation of is_finite.</code></td></tr></table>\n",
    "created_at": "2013-11-13T17:25:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240754",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:25'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[f8540ae](https://github.com/sagemath/sagetrac-mirror/commit/f8540ae)</td><td><code>fix comparison of pseudo-Conway polynomial trees</code></td></tr><tr><td>[d6cf8d6](https://github.com/sagemath/sagetrac-mirror/commit/d6cf8d6)</td><td><code>tiny optimization for _to_common_subfield and implementation of is_finite.</code></td></tr></table>




---

archive/issue_comments_240755.json:
```json
{
    "body": "<a id='comment:26'></a>\nReplying to [vdelecroix](#comment%3A23):\n> Hey,\n> \n> Thanks Jean-Pierre for the suggestion. My method is what is described in the [developer guide](http://sagemath.github.io/git-developer-guide/manual_git.html#getting_changes). Anyway, how should I do to declare u/pbruin/14990 on trac has a remote ?\n\n\nIn fact, doing \"pull\" is the same thing as doing \"fetch+merge\" at once in your local branch.\nIt's just I find it nicer to have a bunch of remotes synchronized locally to be able to have a look at them, make local branch from them for experimentation and so on, before merging them into actual working branches.\nThen you don't need the \"reset --merge\" trick (that I didn't know!).\n\n\nTo add a branch to an existing remote (as trac already exist and you surely want to track all branches coming from the trac server in the same remote), you can issue:\n* git remote set-branches trac --add u/pbruin/14990",
    "created_at": "2013-11-13T17:27:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240755",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:26'></a>
Replying to [vdelecroix](#comment%3A23):
> Hey,
> 
> Thanks Jean-Pierre for the suggestion. My method is what is described in the [developer guide](http://sagemath.github.io/git-developer-guide/manual_git.html#getting_changes). Anyway, how should I do to declare u/pbruin/14990 on trac has a remote ?


In fact, doing "pull" is the same thing as doing "fetch+merge" at once in your local branch.
It's just I find it nicer to have a bunch of remotes synchronized locally to be able to have a look at them, make local branch from them for experimentation and so on, before merging them into actual working branches.
Then you don't need the "reset --merge" trick (that I didn't know!).


To add a branch to an existing remote (as trac already exist and you surely want to track all branches coming from the trac server in the same remote), you can issue:
* git remote set-branches trac --add u/pbruin/14990



---

archive/issue_comments_240756.json:
```json
{
    "body": "<a id='comment:27'></a>\nHi Vincent,\n\nReplying to [vdelecroix](#comment%3A16):\n\n>  - .is_finite() fails on GF(3).algebraic_closure() (raise a NotImplementedError). On the other hand it will be fixed with the new category schemes which allows Field().infinite())\n\n\nAre you sure we should remove `is_finite()` and `cardinality()` after #10963 is done?  Maybe a user wants to pass a custom category to `__init__()` (say `Ring()` or `Fields()`); then the magic wouldn't work anymore, it seems.",
    "created_at": "2013-11-13T17:49:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240756",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:27'></a>
Hi Vincent,

Replying to [vdelecroix](#comment%3A16):

>  - .is_finite() fails on GF(3).algebraic_closure() (raise a NotImplementedError). On the other hand it will be fixed with the new category schemes which allows Field().infinite())


Are you sure we should remove `is_finite()` and `cardinality()` after #10963 is done?  Maybe a user wants to pass a custom category to `__init__()` (say `Ring()` or `Fields()`); then the magic wouldn't work anymore, it seems.



---

archive/issue_comments_240757.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -41,5 +41,3 @@\n \n It is conceivable that there will be different coexisting implementations (deriving from `AlgebraicClosureFiniteField_generic`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.\n \n-Apply: [attachment:trac_14990-algebraic_closure_finite_field.patch]\n-\n``````\n",
    "created_at": "2013-11-13T17:53:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240757",
    "user": "https://github.com/pjbruin"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -41,5 +41,3 @@
 
 It is conceivable that there will be different coexisting implementations (deriving from `AlgebraicClosureFiniteField_generic`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.
 
-Apply: [attachment:trac_14990-algebraic_closure_finite_field.patch]
-
``````




---

archive/issue_comments_240758.json:
```json
{
    "body": "<a id='comment:28'></a>\nFor me Git seems to work fine now; I propose we continue with this.\n\nAfter a combination of Git commands and editing `.git/config` by hand, it looks as follows:\n\n```\n[core]\n        repositoryformatversion = 0\n        filemode = true\n        bare = false\n        logallrefupdates = true\n[remote \"origin\"]\n        fetch = +refs/heads/*:refs/remotes/origin/*\n        url = git://github.com/sagemath/sage.git\n[branch \"master\"]\n        remote = origin\n        merge = refs/heads/master\n[remote \"trac\"]\n        url = git://trac.sagemath.org/sage.git\n        fetch = +refs/heads/master:refs/remotes/trac/master\n        fetch = +refs/heads/u/pbruin/14990:refs/remotes/trac/u/pbruin/14990\n        fetch = +refs/heads/u/vdelecroix/14990:refs/remotes/trac/u/vdelecroix/14990\n[branch \"ticket/14990\"]\n        remote = trac\n        merge = refs/heads/u/pbruin/14990\n```\nDoes this look correct to the more experienced Git users?",
    "created_at": "2013-11-13T17:53:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240758",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:28'></a>
For me Git seems to work fine now; I propose we continue with this.

After a combination of Git commands and editing `.git/config` by hand, it looks as follows:

```
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "origin"]
        fetch = +refs/heads/*:refs/remotes/origin/*
        url = git://github.com/sagemath/sage.git
[branch "master"]
        remote = origin
        merge = refs/heads/master
[remote "trac"]
        url = git://trac.sagemath.org/sage.git
        fetch = +refs/heads/master:refs/remotes/trac/master
        fetch = +refs/heads/u/pbruin/14990:refs/remotes/trac/u/pbruin/14990
        fetch = +refs/heads/u/vdelecroix/14990:refs/remotes/trac/u/vdelecroix/14990
[branch "ticket/14990"]
        remote = trac
        merge = refs/heads/u/pbruin/14990
```
Does this look correct to the more experienced Git users?



---

archive/issue_comments_240759.json:
```json
{
    "body": "<a id='comment:29'></a>\nThe following problems observed by Luca in [comment:7](#comment%3A7) still need to be fixed:\n\n1. It'd be nice to implement a _latex_ method in the elements. \n\n4. F.inclusion(1, a).section() is None for any a, this makes _change_level fail. \n\n6. This patch lacks some obvious coercions, for example, F._subfield(2)(F.gen(2)). Should this wait for another ticket, or should this ticket do it?",
    "created_at": "2013-11-13T18:13:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240759",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:29'></a>
The following problems observed by Luca in [comment:7](#comment%3A7) still need to be fixed:

1. It'd be nice to implement a _latex_ method in the elements. 

4. F.inclusion(1, a).section() is None for any a, this makes _change_level fail. 

6. This patch lacks some obvious coercions, for example, F._subfield(2)(F.gen(2)). Should this wait for another ticket, or should this ticket do it?



---

archive/issue_comments_240760.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2013-11-13T18:13:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240760",
    "user": "https://github.com/pjbruin"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_240761.json:
```json
{
    "body": "**Work_Issues:** see comment 29",
    "created_at": "2013-11-13T18:13:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240761",
    "user": "https://github.com/pjbruin"
}
```

**Work_Issues:** see comment 29



---

archive/issue_comments_240762.json:
```json
{
    "body": "<a id='comment:30'></a>\nReplying to [pbruin](#comment%3A29):\n> The following problems observed by Luca in [comment:7](#comment%3A7) still need to be fixed:\n> \n> 1. It'd be nice to implement a _latex_ method in the elements. \n> \n> 4. F.inclusion(1, a).section() is None for any a, this makes _change_level fail. \n> \n> 6. This patch lacks some obvious coercions, for example, F._subfield(2)(F.gen(2)). Should this wait for another ticket, or should this ticket do it?\n\n\nI implemented 1 using self._value._latex_().\n\nFor 4, why is there a method _change_level, it is nowhere used ? Anyway, what do you expect as a section ? It needs to be compatible with embeddings of subfields.\n\nFor 6, it is definitely not a coercion but rather a conversion. It would be nice to have it but I am in favor of having it for a next ticket.",
    "created_at": "2013-11-15T15:41:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240762",
    "user": "https://github.com/videlec"
}
```

<a id='comment:30'></a>
Replying to [pbruin](#comment%3A29):
> The following problems observed by Luca in [comment:7](#comment%3A7) still need to be fixed:
> 
> 1. It'd be nice to implement a _latex_ method in the elements. 
> 
> 4. F.inclusion(1, a).section() is None for any a, this makes _change_level fail. 
> 
> 6. This patch lacks some obvious coercions, for example, F._subfield(2)(F.gen(2)). Should this wait for another ticket, or should this ticket do it?


I implemented 1 using self._value._latex_().

For 4, why is there a method _change_level, it is nowhere used ? Anyway, what do you expect as a section ? It needs to be compatible with embeddings of subfields.

For 6, it is definitely not a coercion but rather a conversion. It would be nice to have it but I am in favor of having it for a next ticket.



---

archive/issue_comments_240763.json:
```json
{
    "body": "<a id='comment:31'></a>\nReplying to [vdelecroix](#comment%3A30):\n> Replying to [pbruin](#comment%3A29):\n> > The following problems observed by Luca in [comment:7](#comment%3A7) still need to be fixed:\n> > \n> > 1. It'd be nice to implement a _latex_ method in the elements. \n> > \n> > 4. F.inclusion(1, a).section() is None for any a, this makes _change_level fail. \n> > \n> > 6. This patch lacks some obvious coercions, for example, F._subfield(2)(F.gen(2)). Should this wait for another ticket, or should this ticket do it?\n  \n> \n> I implemented 1 using self._value._latex_().\n\n\nThat seems like the right solution.  The last doctest was wrong, at least on my system; this will be fixed in my next commit.\n\n> For 4, why is there a method _change_level, it is nowhere used ? Anyway, what do you expect as a section ? It needs to be compatible with embeddings of subfields.\n\n\nThe bug involving the prime subfield has been fixed.  The section of the embedding between two subfields is just the map that sends an element of the larger subfield to the unique preimage in the smaller one if it exists, and raises a `ValueError` otherwise.\n\nThe reason for `_change_level()` is just that it would be nice to be able to change to a smaller internal representation of the same element, for example if one knows in advance that the result of a computation is going to be in a smaller subfield.  Probably the function shouldn't have a leading underscore, though; I'm changing this.\n\n> For 6, it is definitely not a coercion but rather a conversion. It would be nice to have it but I am in favor of having it for a next ticket.\n\n\nIn principle we could register a conversion map from our algebraic closure to any finite subfield at the moment we construct this subfield, but this feels somewhat like a waste.  Alternatively, we could create a class for embeddings of a finite field into an algebraic closure, and equip that with a `section()` method, or we could (less elegantly) teach the element constructors of the various finite field classes to accept elements of an algebraic closure.",
    "created_at": "2013-11-15T18:21:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240763",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:31'></a>
Replying to [vdelecroix](#comment%3A30):
> Replying to [pbruin](#comment%3A29):
> > The following problems observed by Luca in [comment:7](#comment%3A7) still need to be fixed:
> > 
> > 1. It'd be nice to implement a _latex_ method in the elements. 
> > 
> > 4. F.inclusion(1, a).section() is None for any a, this makes _change_level fail. 
> > 
> > 6. This patch lacks some obvious coercions, for example, F._subfield(2)(F.gen(2)). Should this wait for another ticket, or should this ticket do it?
  
> 
> I implemented 1 using self._value._latex_().


That seems like the right solution.  The last doctest was wrong, at least on my system; this will be fixed in my next commit.

> For 4, why is there a method _change_level, it is nowhere used ? Anyway, what do you expect as a section ? It needs to be compatible with embeddings of subfields.


The bug involving the prime subfield has been fixed.  The section of the embedding between two subfields is just the map that sends an element of the larger subfield to the unique preimage in the smaller one if it exists, and raises a `ValueError` otherwise.

The reason for `_change_level()` is just that it would be nice to be able to change to a smaller internal representation of the same element, for example if one knows in advance that the result of a computation is going to be in a smaller subfield.  Probably the function shouldn't have a leading underscore, though; I'm changing this.

> For 6, it is definitely not a coercion but rather a conversion. It would be nice to have it but I am in favor of having it for a next ticket.


In principle we could register a conversion map from our algebraic closure to any finite subfield at the moment we construct this subfield, but this feels somewhat like a waste.  Alternatively, we could create a class for embeddings of a finite field into an algebraic closure, and equip that with a `section()` method, or we could (less elegantly) teach the element constructors of the various finite field classes to accept elements of an algebraic closure.



---

archive/issue_comments_240764.json:
```json
{
    "body": "<a id='comment:32'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[6325b20](https://github.com/sagemath/sagetrac-mirror/commit/6325b20)</td><td><code>rename/fix change_level(); new doctests</code></td></tr><tr><td>[27cc628](https://github.com/sagemath/sagetrac-mirror/commit/27cc628)</td><td><code>add a _latex_ method to the elements</code></td></tr></table>\n",
    "created_at": "2013-11-15T18:28:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240764",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:32'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[6325b20](https://github.com/sagemath/sagetrac-mirror/commit/6325b20)</td><td><code>rename/fix change_level(); new doctests</code></td></tr><tr><td>[27cc628](https://github.com/sagemath/sagetrac-mirror/commit/27cc628)</td><td><code>add a _latex_ method to the elements</code></td></tr></table>




---

archive/issue_comments_240765.json:
```json
{
    "body": "**Changing commit** from \"[f8540ae3547c28c717c41a44b7791f86d596427e](https://github.com/sagemath/sagetrac-mirror/commit/f8540ae3547c28c717c41a44b7791f86d596427e)\" to \"[6325b20ee46837e1d700a9df41a4582966406068](https://github.com/sagemath/sagetrac-mirror/commit/6325b20ee46837e1d700a9df41a4582966406068)\".",
    "created_at": "2013-11-15T18:28:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240765",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f8540ae3547c28c717c41a44b7791f86d596427e](https://github.com/sagemath/sagetrac-mirror/commit/f8540ae3547c28c717c41a44b7791f86d596427e)" to "[6325b20ee46837e1d700a9df41a4582966406068](https://github.com/sagemath/sagetrac-mirror/commit/6325b20ee46837e1d700a9df41a4582966406068)".



---

archive/issue_comments_240766.json:
```json
{
    "body": "<a id='comment:33'></a>\nOne issue I have some doubts about is whether the `name` argument of `FiniteField.algebraic_closure(self, name='z')` should be optional.  We require the user to specify a name in most cases (finite fields, number fields, polynomial rings, Hecke eigenforms, etc.), so allowing a default here seems to go against the convention.\n\nAn exception is `CyclotomicField()`, which generates names starting with `zeta`; but in this case one could argue that this naming convention is practically universal.  In the case of `AA` and `QQbar`, the name `a` is used for the generator in `as_number_field_element()`, and here one cannot even specify a name; this seems to go against the convention as well.",
    "created_at": "2013-11-15T18:45:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240766",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:33'></a>
One issue I have some doubts about is whether the `name` argument of `FiniteField.algebraic_closure(self, name='z')` should be optional.  We require the user to specify a name in most cases (finite fields, number fields, polynomial rings, Hecke eigenforms, etc.), so allowing a default here seems to go against the convention.

An exception is `CyclotomicField()`, which generates names starting with `zeta`; but in this case one could argue that this naming convention is practically universal.  In the case of `AA` and `QQbar`, the name `a` is used for the generator in `as_number_field_element()`, and here one cannot even specify a name; this seems to go against the convention as well.



---

archive/issue_comments_240767.json:
```json
{
    "body": "<a id='comment:34'></a>\nReplying to [pbruin](#comment%3A33):\n> One issue I have some doubts about is whether the `name` argument of `FiniteField.algebraic_closure(self, name='z')` should be optional.  We require the user to specify a name in most cases (finite fields, number fields, polynomial rings, Hecke eigenforms, etc.), so allowing a default here seems to go against the convention.\n\n\nOn the other hand, QQ.algebraic_closure() works and if you want a generic method for roots of polynomials and eigenvalues of matrices (have a look at #15390) then you do not want to guess about what kind of argument the algebraic closure needs. More precisely, you do\n\n```\nP.change_ring(P.base_ring().algebraic_closure()).roots()\n```\n\nI would not be in trouble if we have a default for the generator of finite field, polynomial ring, etc. Actually, `GF(9)` looks more natural to me than `GF(9, 'a')` as there is only one field of cardinality 9.\n\n> An exception is `CyclotomicField()`, which generates names starting with `zeta`; but in this case one could argue that this naming convention is practically universal.  In the case of `AA` and `QQbar`, the name `a` is used for the generator in `as_number_field_element()`, and here one cannot even specify a name; this seems to go against the convention as well.\n",
    "created_at": "2013-11-15T20:09:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240767",
    "user": "https://github.com/videlec"
}
```

<a id='comment:34'></a>
Replying to [pbruin](#comment%3A33):
> One issue I have some doubts about is whether the `name` argument of `FiniteField.algebraic_closure(self, name='z')` should be optional.  We require the user to specify a name in most cases (finite fields, number fields, polynomial rings, Hecke eigenforms, etc.), so allowing a default here seems to go against the convention.


On the other hand, QQ.algebraic_closure() works and if you want a generic method for roots of polynomials and eigenvalues of matrices (have a look at #15390) then you do not want to guess about what kind of argument the algebraic closure needs. More precisely, you do

```
P.change_ring(P.base_ring().algebraic_closure()).roots()
```

I would not be in trouble if we have a default for the generator of finite field, polynomial ring, etc. Actually, `GF(9)` looks more natural to me than `GF(9, 'a')` as there is only one field of cardinality 9.

> An exception is `CyclotomicField()`, which generates names starting with `zeta`; but in this case one could argue that this naming convention is practically universal.  In the case of `AA` and `QQbar`, the name `a` is used for the generator in `as_number_field_element()`, and here one cannot even specify a name; this seems to go against the convention as well.




---

archive/issue_comments_240768.json:
```json
{
    "body": "<a id='comment:35'></a>\n> > For 4, why is there a method _change_level, it is nowhere used ? Anyway, what do you expect as a section ? It needs to be compatible with embeddings of subfields.\n\n> \n> The bug involving the prime subfield has been fixed.  The section of the embedding between two subfields is just the map that sends an element of the larger subfield to the unique preimage in the smaller one if it exists, and raises a `ValueError` otherwise.\n> \n> The reason for `_change_level()` is just that it would be nice to be able to change to a smaller internal representation of the same element, for example if one knows in advance that the result of a computation is going to be in a smaller subfield.  Probably the function shouldn't have a leading underscore, though; I'm changing this.\n\n\nI see. But then, as a user, you do not want to guess what should be the level. If you have a look at `.as_finite_field_element()` there is a `minimal` option if set to True make the method returns the \"optimal\" level. If you compare with AA and QQbar the methods is called `exactify` or `simplify` (I do not understand the subtle difference between those two methods). The two latter do not accept arguments.",
    "created_at": "2013-11-15T20:18:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240768",
    "user": "https://github.com/videlec"
}
```

<a id='comment:35'></a>
> > For 4, why is there a method _change_level, it is nowhere used ? Anyway, what do you expect as a section ? It needs to be compatible with embeddings of subfields.

> 
> The bug involving the prime subfield has been fixed.  The section of the embedding between two subfields is just the map that sends an element of the larger subfield to the unique preimage in the smaller one if it exists, and raises a `ValueError` otherwise.
> 
> The reason for `_change_level()` is just that it would be nice to be able to change to a smaller internal representation of the same element, for example if one knows in advance that the result of a computation is going to be in a smaller subfield.  Probably the function shouldn't have a leading underscore, though; I'm changing this.


I see. But then, as a user, you do not want to guess what should be the level. If you have a look at `.as_finite_field_element()` there is a `minimal` option if set to True make the method returns the "optimal" level. If you compare with AA and QQbar the methods is called `exactify` or `simplify` (I do not understand the subtle difference between those two methods). The two latter do not accept arguments.



---

archive/issue_comments_240769.json:
```json
{
    "body": "<a id='comment:36'></a>\nReplying to [vdelecroix](#comment%3A34):\n> On the other hand, QQ.algebraic_closure() works and if you want a generic method for roots of polynomials and eigenvalues of matrices (have a look at #15390) then you do not want to guess about what kind of argument the algebraic closure needs.\n\nFair point; as far as I am concerned, this is the main argument for allowing a default argument in `FiniteField.algebraic_closure()`.\n> I would not be in trouble if we have a default for the generator of finite field, polynomial ring, etc. Actually, `GF(9)` looks more natural to me than `GF(9, 'a')` as there is only one field of cardinality 9.\n\nThat is true, but it is only unique up to non-canonical isomorphism, unlike **Z**/9**Z**, for example.  To me the notation `GF(9)` looks too much like it is canonical, and insisting on a variable name is a good way to remind the user that a choice of a defining polynomial is being made.\n\nFor algebraic closures, I am inclined to say that the current status is not bad: keep `'z'` as the default name for `FiniteField.algebraic_closure()`, but don't extend this to a default name for the `AlgebraicClosureFiniteField` constructor.",
    "created_at": "2013-11-19T14:00:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240769",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:36'></a>
Replying to [vdelecroix](#comment%3A34):
> On the other hand, QQ.algebraic_closure() works and if you want a generic method for roots of polynomials and eigenvalues of matrices (have a look at #15390) then you do not want to guess about what kind of argument the algebraic closure needs.

Fair point; as far as I am concerned, this is the main argument for allowing a default argument in `FiniteField.algebraic_closure()`.
> I would not be in trouble if we have a default for the generator of finite field, polynomial ring, etc. Actually, `GF(9)` looks more natural to me than `GF(9, 'a')` as there is only one field of cardinality 9.

That is true, but it is only unique up to non-canonical isomorphism, unlike **Z**/9**Z**, for example.  To me the notation `GF(9)` looks too much like it is canonical, and insisting on a variable name is a good way to remind the user that a choice of a defining polynomial is being made.

For algebraic closures, I am inclined to say that the current status is not bad: keep `'z'` as the default name for `FiniteField.algebraic_closure()`, but don't extend this to a default name for the `AlgebraicClosureFiniteField` constructor.



---

archive/issue_comments_240770.json:
```json
{
    "body": "<a id='comment:37'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[5fe4189](https://github.com/sagemath/sagetrac-mirror/commit/5fe4189)</td><td><code>matrix2.pyx: no special case for finite fields in F.algebraic_closure()</code></td></tr></table>\n",
    "created_at": "2013-11-21T20:38:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240770",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:37'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[5fe4189](https://github.com/sagemath/sagetrac-mirror/commit/5fe4189)</td><td><code>matrix2.pyx: no special case for finite fields in F.algebraic_closure()</code></td></tr></table>




---

archive/issue_comments_240771.json:
```json
{
    "body": "**Changing commit** from \"[6325b20ee46837e1d700a9df41a4582966406068](https://github.com/sagemath/sagetrac-mirror/commit/6325b20ee46837e1d700a9df41a4582966406068)\" to \"[5fe4189d600b3bd56a663f6155831ce949e846f5](https://github.com/sagemath/sagetrac-mirror/commit/5fe4189d600b3bd56a663f6155831ce949e846f5)\".",
    "created_at": "2013-11-21T20:38:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240771",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[6325b20ee46837e1d700a9df41a4582966406068](https://github.com/sagemath/sagetrac-mirror/commit/6325b20ee46837e1d700a9df41a4582966406068)" to "[5fe4189d600b3bd56a663f6155831ce949e846f5](https://github.com/sagemath/sagetrac-mirror/commit/5fe4189d600b3bd56a663f6155831ce949e846f5)".



---

archive/issue_comments_240772.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -40,4 +40,3 @@\n ```\n \n It is conceivable that there will be different coexisting implementations (deriving from `AlgebraicClosureFiniteField_generic`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.\n-\n``````\n",
    "created_at": "2013-11-21T20:40:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240772",
    "user": "https://github.com/pjbruin"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -40,4 +40,3 @@
 ```
 
 It is conceivable that there will be different coexisting implementations (deriving from `AlgebraicClosureFiniteField_generic`).  The current implementation uses Conway polynomials and the pseudo-Conway polynomials from #14958, as well as the functionality for finite field homomorphisms provided by #13214.
-
``````




---

archive/issue_comments_240773.json:
```json
{
    "body": "**Changing work_issues** from \"see comment 29\" to \"\".",
    "created_at": "2013-11-21T20:40:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240773",
    "user": "https://github.com/pjbruin"
}
```

**Changing work_issues** from "see comment 29" to "".



---

archive/issue_comments_240774.json:
```json
{
    "body": "<a id='comment:39'></a>\nHi,\n\nI'm still baking my own experimental version of Fp-bar on top of this ticket. I have a question: shouldn't `_subfield()` use `check_irreducible=False` in the `FiniteField` constructor? It looks like a waste to check twice for irreducibility.",
    "created_at": "2013-12-05T23:11:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240774",
    "user": "https://github.com/defeo"
}
```

<a id='comment:39'></a>
Hi,

I'm still baking my own experimental version of Fp-bar on top of this ticket. I have a question: shouldn't `_subfield()` use `check_irreducible=False` in the `FiniteField` constructor? It looks like a waste to check twice for irreducibility.



---

archive/issue_comments_240775.json:
```json
{
    "body": "<a id='comment:40'></a>\nReplying to [defeo](#comment%3A39):\n> I'm still baking my own experimental version of Fp-bar on top of this ticket. I have a question: shouldn't `_subfield()` use `check_irreducible=False` in the `FiniteField` constructor? It looks like a waste to check twice for irreducibility.\n\nGood idea, I'll rebase this ticket and then disable the check.",
    "created_at": "2013-12-11T16:07:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240775",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:40'></a>
Replying to [defeo](#comment%3A39):
> I'm still baking my own experimental version of Fp-bar on top of this ticket. I have a question: shouldn't `_subfield()` use `check_irreducible=False` in the `FiniteField` constructor? It looks like a waste to check twice for irreducibility.

Good idea, I'll rebase this ticket and then disable the check.



---

archive/issue_comments_240776.json:
```json
{
    "body": "<a id='comment:41'></a>\nReplying to [pbruin](#comment%3A40):\n> Good idea, I'll rebase this ticket and then disable the check.\n\n\nWhy \"rebase\"? Maybe you meant \"merge master\"?",
    "created_at": "2013-12-11T16:19:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240776",
    "user": "https://github.com/defeo"
}
```

<a id='comment:41'></a>
Replying to [pbruin](#comment%3A40):
> Good idea, I'll rebase this ticket and then disable the check.


Why "rebase"? Maybe you meant "merge master"?



---

archive/issue_comments_240777.json:
```json
{
    "body": "<a id='comment:42'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** Recent commits:\n|                                                                                                         |                                     |\n|---------------------------------------------------------------------------------------------------------|-------------------------------------|\n|[4265b4f](https://github.com/sagemath/sagetrac-mirror/commit/4265b4f)|do not check twice for irreducibility|\n|[555055b](https://github.com/sagemath/sagetrac-mirror/commit/555055b)|matrix2.pyx: no special case for finite fields in F.algebraic_closure()|\n|[7f7ed5b](https://github.com/sagemath/sagetrac-mirror/commit/7f7ed5b)|rename/fix change_level(); new doctests|\n|[2de16f2](https://github.com/sagemath/sagetrac-mirror/commit/2de16f2)|add a _latex_ method to the elements|\n|[4455c84](https://github.com/sagemath/sagetrac-mirror/commit/4455c84)|fix comparison of pseudo-Conway polynomial trees|",
    "created_at": "2013-12-11T16:22:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240777",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:42'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** Recent commits:
|                                                                                                         |                                     |
|---------------------------------------------------------------------------------------------------------|-------------------------------------|
|[4265b4f](https://github.com/sagemath/sagetrac-mirror/commit/4265b4f)|do not check twice for irreducibility|
|[555055b](https://github.com/sagemath/sagetrac-mirror/commit/555055b)|matrix2.pyx: no special case for finite fields in F.algebraic_closure()|
|[7f7ed5b](https://github.com/sagemath/sagetrac-mirror/commit/7f7ed5b)|rename/fix change_level(); new doctests|
|[2de16f2](https://github.com/sagemath/sagetrac-mirror/commit/2de16f2)|add a _latex_ method to the elements|
|[4455c84](https://github.com/sagemath/sagetrac-mirror/commit/4455c84)|fix comparison of pseudo-Conway polynomial trees|



---

archive/issue_comments_240778.json:
```json
{
    "body": "**Changing commit** from \"[5fe4189d600b3bd56a663f6155831ce949e846f5](https://github.com/sagemath/sagetrac-mirror/commit/5fe4189d600b3bd56a663f6155831ce949e846f5)\" to \"[4265b4fe176d32b3bc7cbc616f8f0964e273ecdb](https://github.com/sagemath/sagetrac-mirror/commit/4265b4fe176d32b3bc7cbc616f8f0964e273ecdb)\".",
    "created_at": "2013-12-11T16:22:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240778",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[5fe4189d600b3bd56a663f6155831ce949e846f5](https://github.com/sagemath/sagetrac-mirror/commit/5fe4189d600b3bd56a663f6155831ce949e846f5)" to "[4265b4fe176d32b3bc7cbc616f8f0964e273ecdb](https://github.com/sagemath/sagetrac-mirror/commit/4265b4fe176d32b3bc7cbc616f8f0964e273ecdb)".



---

archive/issue_comments_240779.json:
```json
{
    "body": "<a id='comment:43'></a>\nReplying to [defeo](#comment%3A41):\n> Replying to [pbruin](#comment%3A40):\n> > Good idea, I'll rebase this ticket and then disable the check.\n\n> \n> Why \"rebase\"? Maybe you meant \"merge master\"?\n\nI saw your comment only after the above Git operation; I may just have commited the sin of rewriting history and/or have messed things up for you.  I'm still more used to Mercurial, which is why rebasing sounded like the obvious thing to do.  Besides, it turned out to remove some duplicate commits which were in the previous version of the branch (I noticed this before).",
    "created_at": "2013-12-11T16:29:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240779",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:43'></a>
Replying to [defeo](#comment%3A41):
> Replying to [pbruin](#comment%3A40):
> > Good idea, I'll rebase this ticket and then disable the check.

> 
> Why "rebase"? Maybe you meant "merge master"?

I saw your comment only after the above Git operation; I may just have commited the sin of rewriting history and/or have messed things up for you.  I'm still more used to Mercurial, which is why rebasing sounded like the obvious thing to do.  Besides, it turned out to remove some duplicate commits which were in the previous version of the branch (I noticed this before).



---

archive/issue_comments_240780.json:
```json
{
    "body": "<a id='comment:44'></a>\nReplying to [pbruin](#comment%3A43):\n> it turned out to remove some duplicate commits which were in the previous version of the branch (I noticed this before).\n\nAlthough if I read the `git-rebase` man page correctly, merging our branches will now create even more duplicates because of my `rebase`.  What is the best solution for this?",
    "created_at": "2013-12-11T16:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240780",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:44'></a>
Replying to [pbruin](#comment%3A43):
> it turned out to remove some duplicate commits which were in the previous version of the branch (I noticed this before).

Although if I read the `git-rebase` man page correctly, merging our branches will now create even more duplicates because of my `rebase`.  What is the best solution for this?



---

archive/issue_comments_240781.json:
```json
{
    "body": "<a id='comment:45'></a>\n> Although if I read the `git-rebase` man page correctly, merging our branches will now create even more duplicates because of my `rebase`.  What is the best solution for this?\n\n\nWhat do you mean by \"duplicate commits\"?\n\nIt's not a big deal for me, I can easily rebase my branch on yours. It's not meant to enter Sage anyway: it's just some experiments.\n\nBut it might be a problem for Vincent, if you still want to share work. If you want to go back in time, you can do something like this (make sure you have no uncommited work)\n\n```\ngit reset --hard \u200b5fe4189\ngit cherry-pick \u200b4265b4f\ngit merge master\ngit push -f\n```\n\nassuming the only commit that really did something was the last one, \u200b4265b4f.\n\nAnyway, as I said, I don't care. If this history is better for you, it's ok for me. I'll just rebase on top of your new history. Just try this if Vincent needs it.",
    "created_at": "2013-12-11T17:21:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240781",
    "user": "https://github.com/defeo"
}
```

<a id='comment:45'></a>
> Although if I read the `git-rebase` man page correctly, merging our branches will now create even more duplicates because of my `rebase`.  What is the best solution for this?


What do you mean by "duplicate commits"?

It's not a big deal for me, I can easily rebase my branch on yours. It's not meant to enter Sage anyway: it's just some experiments.

But it might be a problem for Vincent, if you still want to share work. If you want to go back in time, you can do something like this (make sure you have no uncommited work)

```
git reset --hard 5fe4189
git cherry-pick 4265b4f
git merge master
git push -f
```

assuming the only commit that really did something was the last one, 4265b4f.

Anyway, as I said, I don't care. If this history is better for you, it's ok for me. I'll just rebase on top of your new history. Just try this if Vincent needs it.



---

archive/issue_comments_240782.json:
```json
{
    "body": "<a id='comment:46'></a>\nReplying to [defeo](#comment%3A45):\n> What do you mean by \"duplicate commits\"?\n\n\nThe previous branch looked (on the Trac \"commits\" page) like two parallel and unconnected linear \"chains\" of commits, with all commits in the first also appearing in the other.  When I was rebasing this, Git spit out several messages saying something to the effect that the patch had already been applied (in some cases I had to resolve a conflict first).  After the rebasing, there was only one chain of commits left.\n\n> It's not a big deal for me, I can easily rebase my branch on yours. It's not meant to enter Sage anyway: it's just some experiments.\n> \n> But it might be a problem for Vincent, if you still want to share work.\n\n\nOK, let's leave it as is unless it creates trouble for Vincent (or someone else who might have been using this branch).",
    "created_at": "2013-12-11T22:06:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240782",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:46'></a>
Replying to [defeo](#comment%3A45):
> What do you mean by "duplicate commits"?


The previous branch looked (on the Trac "commits" page) like two parallel and unconnected linear "chains" of commits, with all commits in the first also appearing in the other.  When I was rebasing this, Git spit out several messages saying something to the effect that the patch had already been applied (in some cases I had to resolve a conflict first).  After the rebasing, there was only one chain of commits left.

> It's not a big deal for me, I can easily rebase my branch on yours. It's not meant to enter Sage anyway: it's just some experiments.
> 
> But it might be a problem for Vincent, if you still want to share work.


OK, let's leave it as is unless it creates trouble for Vincent (or someone else who might have been using this branch).



---

archive/issue_comments_240783.json:
```json
{
    "body": "<a id='comment:47'></a>\nReplying to [pbruin](#comment%3A46):\n> The previous branch looked (on the Trac \"commits\" page) like two parallel and unconnected linear \"chains\" of commits, with all commits in the first also appearing in the other.  When I was rebasing this, Git spit out several messages saying something to the effect that the patch had already been applied (in some cases I had to resolve a conflict first).  After the rebasing, there was only one chain of commits left.\n\n\nYes, you are right. There has been a little bit of a mess before the merge commit a197d0d79. Probably the mercurial patch was imported once by you and once by Vincent. No big deal, but since now you have rebased, there's no point in going back (unless someone was depending on the old commits).",
    "created_at": "2013-12-11T23:19:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240783",
    "user": "https://github.com/defeo"
}
```

<a id='comment:47'></a>
Replying to [pbruin](#comment%3A46):
> The previous branch looked (on the Trac "commits" page) like two parallel and unconnected linear "chains" of commits, with all commits in the first also appearing in the other.  When I was rebasing this, Git spit out several messages saying something to the effect that the patch had already been applied (in some cases I had to resolve a conflict first).  After the rebasing, there was only one chain of commits left.


Yes, you are right. There has been a little bit of a mess before the merge commit a197d0d79. Probably the mercurial patch was imported once by you and once by Vincent. No big deal, but since now you have rebased, there's no point in going back (unless someone was depending on the old commits).



---

archive/issue_comments_240784.json:
```json
{
    "body": "<a id='comment:48'></a>\nActually, there is #15390 which depends on the old branch; I'm not sure whether it is better for me to go back or for Vincent to rebase his branch at #15390 onto this one.",
    "created_at": "2013-12-11T23:37:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240784",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:48'></a>
Actually, there is #15390 which depends on the old branch; I'm not sure whether it is better for me to go back or for Vincent to rebase his branch at #15390 onto this one.



---

archive/issue_comments_240785.json:
```json
{
    "body": "<a id='comment:49'></a>\nJust to get an idea of what would be good to do before setting this to \"needs-review\", here is the status of the items from Vincent's list (comment:9):\n\n>  - .some_elements() returns a very stupid list\n\n\nThis can be made less stupid by implementing `_an_element_()` to return `self.gen(2)`.\n\n>  - .gens() is not happy. I guess we can return a `Family`. The problem is that in the specification it is written that the method should return a tuple.\n\n\nI think returning a `Family` is acceptable given that there is no finite set of generators.\n\n>  - many methods can be implemented in two lines as\n \n> {{{\n>    def my_method(self):\n>        return self._value.my_method()\n\n> }}}\n>    this concerns `minimal_polynomial`, `trace`, `norm`, `multiplicative_order`, ...\n\n\nI agree for `minimal_polynomial` and `multiplicative_order`; the latter was implemented by Vincent.\n\nThe trace and norm, on the other hand, are not well-defined since the definition requires a *finite* extension, for which there is no canical choice.\n\nIt remains to implement `minimal_polynomial`, which can of course be done in two lines as above.\n\n>  - in a similar way (calling apropriate method of _value and applying a morphism) it is straightforward to implement `frobenius`, `pth_power`, `pth_root`, ...\n\n\nWe now have `pth_power` and `pth_root`, again thanks to Vincent, and the field itself has `frobenius`.  I don't think an additional `frobenius` on elements would be useful.",
    "created_at": "2013-12-14T22:54:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240785",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:49'></a>
Just to get an idea of what would be good to do before setting this to "needs-review", here is the status of the items from Vincent's list (comment:9):

>  - .some_elements() returns a very stupid list


This can be made less stupid by implementing `_an_element_()` to return `self.gen(2)`.

>  - .gens() is not happy. I guess we can return a `Family`. The problem is that in the specification it is written that the method should return a tuple.


I think returning a `Family` is acceptable given that there is no finite set of generators.

>  - many methods can be implemented in two lines as
 
> {{{
>    def my_method(self):
>        return self._value.my_method()

> }}}
>    this concerns `minimal_polynomial`, `trace`, `norm`, `multiplicative_order`, ...


I agree for `minimal_polynomial` and `multiplicative_order`; the latter was implemented by Vincent.

The trace and norm, on the other hand, are not well-defined since the definition requires a *finite* extension, for which there is no canical choice.

It remains to implement `minimal_polynomial`, which can of course be done in two lines as above.

>  - in a similar way (calling apropriate method of _value and applying a morphism) it is straightforward to implement `frobenius`, `pth_power`, `pth_root`, ...


We now have `pth_power` and `pth_root`, again thanks to Vincent, and the field itself has `frobenius`.  I don't think an additional `frobenius` on elements would be useful.



---

archive/issue_comments_240786.json:
```json
{
    "body": "<a id='comment:50'></a>\nSomething else: I would prefer if the implementation of `nth_root()` could be improved before getting this ticket merged.  The basic difficulty is figuring out in which subfield we have to look.  Rather than trying extensions of degrees dividing *n* (is it true/clear that the degree has to divide *n*?), I think we should either factor *x<sup>n</sup>* - *a* (where *a* is the element whose *n*-th root we want) and look at the smallest degree of a factor, or we should compute the multiplicative order of *a*.  Also, before doing anything else, we should take all factors *p* out of *n* and use `pth_root()`.\n\nI hope to have an update soon, at least for the remaining things mentioned in the previous comment.",
    "created_at": "2013-12-14T23:24:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240786",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:50'></a>
Something else: I would prefer if the implementation of `nth_root()` could be improved before getting this ticket merged.  The basic difficulty is figuring out in which subfield we have to look.  Rather than trying extensions of degrees dividing *n* (is it true/clear that the degree has to divide *n*?), I think we should either factor *x<sup>n</sup>* - *a* (where *a* is the element whose *n*-th root we want) and look at the smallest degree of a factor, or we should compute the multiplicative order of *a*.  Also, before doing anything else, we should take all factors *p* out of *n* and use `pth_root()`.

I hope to have an update soon, at least for the remaining things mentioned in the previous comment.



---

archive/issue_comments_240787.json:
```json
{
    "body": "**Changing commit** from \"[4265b4fe176d32b3bc7cbc616f8f0964e273ecdb](https://github.com/sagemath/sagetrac-mirror/commit/4265b4fe176d32b3bc7cbc616f8f0964e273ecdb)\" to \"[70f07cafc62f0fdf6d3f3897973fd33400168d40](https://github.com/sagemath/sagetrac-mirror/commit/70f07cafc62f0fdf6d3f3897973fd33400168d40)\".",
    "created_at": "2013-12-15T00:14:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240787",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[4265b4fe176d32b3bc7cbc616f8f0964e273ecdb](https://github.com/sagemath/sagetrac-mirror/commit/4265b4fe176d32b3bc7cbc616f8f0964e273ecdb)" to "[70f07cafc62f0fdf6d3f3897973fd33400168d40](https://github.com/sagemath/sagetrac-mirror/commit/70f07cafc62f0fdf6d3f3897973fd33400168d40)".



---

archive/issue_comments_240788.json:
```json
{
    "body": "<a id='comment:51'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[70f07ca](https://github.com/sagemath/sagetrac-mirror/commit/70f07ca)</td><td><code>implement three more methods</code></td></tr></table>\n",
    "created_at": "2013-12-15T00:14:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240788",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:51'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[70f07ca](https://github.com/sagemath/sagetrac-mirror/commit/70f07ca)</td><td><code>implement three more methods</code></td></tr></table>




---

archive/issue_comments_240789.json:
```json
{
    "body": "<a id='comment:52'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7b3d68a\">7b3d68a</a></td><td><code>cosmetic improvement to nth_root()</code></td></tr></table>\n",
    "created_at": "2013-12-21T23:38:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240789",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:52'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7b3d68a">7b3d68a</a></td><td><code>cosmetic improvement to nth_root()</code></td></tr></table>




---

archive/issue_comments_240790.json:
```json
{
    "body": "**Changing commit** from \"[70f07cafc62f0fdf6d3f3897973fd33400168d40](https://github.com/sagemath/sagetrac-mirror/commit/70f07cafc62f0fdf6d3f3897973fd33400168d40)\" to \"[7b3d68a49b460e336f98c46c7f219fc2f2fbd78f](https://github.com/sagemath/sagetrac-mirror/commit/7b3d68a49b460e336f98c46c7f219fc2f2fbd78f)\".",
    "created_at": "2013-12-21T23:38:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240790",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[70f07cafc62f0fdf6d3f3897973fd33400168d40](https://github.com/sagemath/sagetrac-mirror/commit/70f07cafc62f0fdf6d3f3897973fd33400168d40)" to "[7b3d68a49b460e336f98c46c7f219fc2f2fbd78f](https://github.com/sagemath/sagetrac-mirror/commit/7b3d68a49b460e336f98c46c7f219fc2f2fbd78f)".



---

archive/issue_comments_240791.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2013-12-21T23:45:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240791",
    "user": "https://github.com/pjbruin"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_240792.json:
```json
{
    "body": "<a id='comment:53'></a>\nI thought a bit about `nth_root()` but couldn't easily make it faster.  Hence I just made two very minor fixes: raise an `AssertionError` instead of a `ValueError` if we don't find the root (since this should never happen) and move the TODO to the docstring.\n\nSince the basic functionality of the ticket is usable, I'm setting it to `needs_review`.",
    "created_at": "2013-12-21T23:45:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240792",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:53'></a>
I thought a bit about `nth_root()` but couldn't easily make it faster.  Hence I just made two very minor fixes: raise an `AssertionError` instead of a `ValueError` if we don't find the root (since this should never happen) and move the TODO to the docstring.

Since the basic functionality of the ticket is usable, I'm setting it to `needs_review`.



---

archive/issue_comments_240793.json:
```json
{
    "body": "**Changing commit** from \"[7b3d68a49b460e336f98c46c7f219fc2f2fbd78f](https://github.com/sagemath/sagetrac-mirror/commit/7b3d68a49b460e336f98c46c7f219fc2f2fbd78f)\" to \"[ff35daa8828581bb74f929131dd352204a6f8cb1](https://github.com/sagemath/sagetrac-mirror/commit/ff35daa8828581bb74f929131dd352204a6f8cb1)\".",
    "created_at": "2014-01-04T21:07:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240793",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7b3d68a49b460e336f98c46c7f219fc2f2fbd78f](https://github.com/sagemath/sagetrac-mirror/commit/7b3d68a49b460e336f98c46c7f219fc2f2fbd78f)" to "[ff35daa8828581bb74f929131dd352204a6f8cb1](https://github.com/sagemath/sagetrac-mirror/commit/ff35daa8828581bb74f929131dd352204a6f8cb1)".



---

archive/issue_comments_240794.json:
```json
{
    "body": "<a id='comment:54'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ff35daa\">ff35daa</a></td><td><code>Merge branch 'develop' into ticket/14990</code></td></tr></table>\n",
    "created_at": "2014-01-04T21:07:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240794",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:54'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ff35daa">ff35daa</a></td><td><code>Merge branch 'develop' into ticket/14990</code></td></tr></table>




---

archive/issue_events_049445.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "milestone": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14990#event-49445"
}
```



---

archive/issue_events_049446.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14990#event-49446"
}
```



---

archive/issue_comments_240795.json:
```json
{
    "body": "**Changing commit** from \"[ff35daa8828581bb74f929131dd352204a6f8cb1](https://github.com/sagemath/sagetrac-mirror/commit/ff35daa8828581bb74f929131dd352204a6f8cb1)\" to \"[785c7b90031db8fc32b5a271e5bca538027bcfc1](https://github.com/sagemath/sagetrac-mirror/commit/785c7b90031db8fc32b5a271e5bca538027bcfc1)\".",
    "created_at": "2014-04-15T08:18:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240795",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ff35daa8828581bb74f929131dd352204a6f8cb1](https://github.com/sagemath/sagetrac-mirror/commit/ff35daa8828581bb74f929131dd352204a6f8cb1)" to "[785c7b90031db8fc32b5a271e5bca538027bcfc1](https://github.com/sagemath/sagetrac-mirror/commit/785c7b90031db8fc32b5a271e5bca538027bcfc1)".



---

archive/issue_comments_240796.json:
```json
{
    "body": "<a id='comment:56'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d45b9b65527a5a4f299db060b3a642ff10da33f7\">d45b9b6</a></td><td><code>Merge branch 'develop' into ticket/14990</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/785c7b90031db8fc32b5a271e5bca538027bcfc1\">785c7b9</a></td><td><code>fix doctest: finite field homset now has unique representation</code></td></tr></table>\n",
    "created_at": "2014-04-15T08:18:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240796",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:56'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d45b9b65527a5a4f299db060b3a642ff10da33f7">d45b9b6</a></td><td><code>Merge branch 'develop' into ticket/14990</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/785c7b90031db8fc32b5a271e5bca538027bcfc1">785c7b9</a></td><td><code>fix doctest: finite field homset now has unique representation</code></td></tr></table>




---

archive/issue_comments_240797.json:
```json
{
    "body": "**Changing status** from needs_review to needs_info.",
    "created_at": "2014-04-23T21:42:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240797",
    "user": "https://github.com/videlec"
}
```

**Changing status** from needs_review to needs_info.



---

archive/issue_comments_240798.json:
```json
{
    "body": "<a id='comment:57'></a>\nHello,\n\nSorry, the story started already long time ago. I would be happy to finish the review of this ticket and work again on #15390 (no trouble about the possible rebase, I will try the cherry-pick proposed by Luca).\n\nIn case you do not want to recompile your Sage over the 6.2.rc0, I put a version that merge the develop release at u/vdelecroix/14990 (with some extra, see below).\n\nI am in trouble because of the `UniqueFactory`. Firstly, in some doctests there is a direct call to `AlgebraicClosureFiniteField_pseudo_conway` but in practice this should be avoided as we have\n\n```\nsage: F = AlgebraicClosureFiniteField_pseudo_conway(GF(5),'z')\nsage: z = F.an_element()\nsage: z == loads(dumps(z))\nFalse\n```\nI had no idea how to make it clear. On the other hand, what it the purpose of a factory if there is only one implementation? Note that there will be a problem with the generic `__reduce__` when there will be several implementations and I am pretty sure that many others trouble will show up.\n\nMinor issues that I solved in a commit on my branch:\n\n- the doctest must be in an `EXAMPLES` bloc and not an `EXAMPLE` bloc.\n\n- I was wondering what was the point of `__getstate__` (line 473) and `__setstate__` (line 487) in the base class. It becomes clear after reading the code for the pseudo_conway class. Please, put some specification (better than \"used for pickling\") in `__getstate__` and `__setstate__` that would be useful to anybody who wants to implement their own algebraic closure (all right, there should not be a lot of them, but at least it will help people, like me, who are reading the code).\n\n- Add optional keywords to `FiniteField.algebraic_closure` that are sent to the factory in order to be able to do\n\n```\nsage: GF(5).algebraic_closure(implementation='pseudo_conway')\n```\n\n- for `_get_polynomial` and `_get_im_gen` we could use the decorator `@abstract_method` (from `sage.misc.abstract_method`). That way, their existence become part of the `TestSuite` and there is no need for the `NotImplementedError`. There are many example of its usage in `sage/categories`.\n\n- It would be better to move the test lines 41-44 inside the constructor of `AlgebraicClosure` and rather use `AlgebraicClosureFiniteField_pseudo_conway` directly. That way we are sure that the good class is tested.\n\n- Implement `some_elements`: this is important for having better automatic tests\n\nFeel free to reuse the merge commit or the extra one from my branch. As soon as the situation of the factory is clear to me, the branch is good to go.\n\nThanks\nVincent",
    "created_at": "2014-04-23T21:42:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240798",
    "user": "https://github.com/videlec"
}
```

<a id='comment:57'></a>
Hello,

Sorry, the story started already long time ago. I would be happy to finish the review of this ticket and work again on #15390 (no trouble about the possible rebase, I will try the cherry-pick proposed by Luca).

In case you do not want to recompile your Sage over the 6.2.rc0, I put a version that merge the develop release at u/vdelecroix/14990 (with some extra, see below).

I am in trouble because of the `UniqueFactory`. Firstly, in some doctests there is a direct call to `AlgebraicClosureFiniteField_pseudo_conway` but in practice this should be avoided as we have

```
sage: F = AlgebraicClosureFiniteField_pseudo_conway(GF(5),'z')
sage: z = F.an_element()
sage: z == loads(dumps(z))
False
```
I had no idea how to make it clear. On the other hand, what it the purpose of a factory if there is only one implementation? Note that there will be a problem with the generic `__reduce__` when there will be several implementations and I am pretty sure that many others trouble will show up.

Minor issues that I solved in a commit on my branch:

- the doctest must be in an `EXAMPLES` bloc and not an `EXAMPLE` bloc.

- I was wondering what was the point of `__getstate__` (line 473) and `__setstate__` (line 487) in the base class. It becomes clear after reading the code for the pseudo_conway class. Please, put some specification (better than "used for pickling") in `__getstate__` and `__setstate__` that would be useful to anybody who wants to implement their own algebraic closure (all right, there should not be a lot of them, but at least it will help people, like me, who are reading the code).

- Add optional keywords to `FiniteField.algebraic_closure` that are sent to the factory in order to be able to do

```
sage: GF(5).algebraic_closure(implementation='pseudo_conway')
```

- for `_get_polynomial` and `_get_im_gen` we could use the decorator `@abstract_method` (from `sage.misc.abstract_method`). That way, their existence become part of the `TestSuite` and there is no need for the `NotImplementedError`. There are many example of its usage in `sage/categories`.

- It would be better to move the test lines 41-44 inside the constructor of `AlgebraicClosure` and rather use `AlgebraicClosureFiniteField_pseudo_conway` directly. That way we are sure that the good class is tested.

- Implement `some_elements`: this is important for having better automatic tests

Feel free to reuse the merge commit or the extra one from my branch. As soon as the situation of the factory is clear to me, the branch is good to go.

Thanks
Vincent



---

archive/issue_comments_240799.json:
```json
{
    "body": "<a id='comment:58'></a>\nHello Vincent,\n> Sorry, the story started already long time ago. I would be happy to finish the review of this ticket and work again on #15390 (no trouble about the possible rebase, I will try the cherry-pick proposed by Luca).\n\nGreat!\n> In case you do not want to recompile your Sage over the 6.2.rc0, I put a version that merge the develop release at u/vdelecroix/14990 (with some extra, see below).\n\nOK, we should probably switch to that branch (although merging the latest development branch is only necessary in case of conflicts, and it clutters the history).\n> I am in trouble because of the `UniqueFactory`. Firstly, in some doctests there is a direct call to `AlgebraicClosureFiniteField_pseudo_conway` but in practice this should be avoided as we have\n> \n> ```\n> sage: F = AlgebraicClosureFiniteField_pseudo_conway(GF(5),'z')\n> sage: z = F.an_element()\n> sage: z == loads(dumps(z))\n> False\n> ```\n> I had no idea how to make it clear.\n\nIt is hopefully clear from the general structure, and the fact that these classes are not in the global namespace, that they are not meant to be called directly.  I do not find it too important, but we can add a remark if you think it is useful.  The above behaviour is quite bad, though...\n> On the other hand, what it the purpose of a factory if there is only one implementation? Note that there will be a problem with the generic `__reduce__` when there will be several implementations and I am pretty sure that many others trouble will show up.\n\nThere are indeed problems here.  First, looking at the code again, I think that in the current implementation, the interaction between the factory and the pickling code is flawed.  Second, I have been thinking about unique representation in other contexts (e.g. number fields and elliptic curves), and there seems to be something more fundamentally problematic.\n\nFrom my perspective, the guiding philosophy should be that you can use `UniqueRepresentation` or `UniqueFactory` for objects that are defined *up to unique isomorphism* by a certain amount of \"defining data\", which corresponds to the arguments of the `__init__()` method of an object derived from `UniqueRepresentation`, resp. to the `key` used by a `UniqueFactory`.\n\nThe problem with of algebraic closures of finite fields is that in principle they are *not* defined up to unique isomorphism by a finite amount of defining data.  This is exactly the reason why Conway polynomials were invented, and we could have unique representation if we only used Conway polynomials.  However, the idea of this implementation was to use *pseudo*-Conway polynomials, which do not have the same uniqueness property.\n\nIt is not clear to me at the moment that trying to get unique representation at all in this case is the right thing to do.  Especially with the current implementation, given that pseudo-Conway polynomials are not unique, it may be better to just (1) ensure that pickling works and (2) put some warnings in place that algebraic closures are not globally unique and that users should be careful if they want to ensure all elements live in the same algebraic closure.",
    "created_at": "2014-04-23T23:12:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240799",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:58'></a>
Hello Vincent,
> Sorry, the story started already long time ago. I would be happy to finish the review of this ticket and work again on #15390 (no trouble about the possible rebase, I will try the cherry-pick proposed by Luca).

Great!
> In case you do not want to recompile your Sage over the 6.2.rc0, I put a version that merge the develop release at u/vdelecroix/14990 (with some extra, see below).

OK, we should probably switch to that branch (although merging the latest development branch is only necessary in case of conflicts, and it clutters the history).
> I am in trouble because of the `UniqueFactory`. Firstly, in some doctests there is a direct call to `AlgebraicClosureFiniteField_pseudo_conway` but in practice this should be avoided as we have
> 
> ```
> sage: F = AlgebraicClosureFiniteField_pseudo_conway(GF(5),'z')
> sage: z = F.an_element()
> sage: z == loads(dumps(z))
> False
> ```
> I had no idea how to make it clear.

It is hopefully clear from the general structure, and the fact that these classes are not in the global namespace, that they are not meant to be called directly.  I do not find it too important, but we can add a remark if you think it is useful.  The above behaviour is quite bad, though...
> On the other hand, what it the purpose of a factory if there is only one implementation? Note that there will be a problem with the generic `__reduce__` when there will be several implementations and I am pretty sure that many others trouble will show up.

There are indeed problems here.  First, looking at the code again, I think that in the current implementation, the interaction between the factory and the pickling code is flawed.  Second, I have been thinking about unique representation in other contexts (e.g. number fields and elliptic curves), and there seems to be something more fundamentally problematic.

From my perspective, the guiding philosophy should be that you can use `UniqueRepresentation` or `UniqueFactory` for objects that are defined *up to unique isomorphism* by a certain amount of "defining data", which corresponds to the arguments of the `__init__()` method of an object derived from `UniqueRepresentation`, resp. to the `key` used by a `UniqueFactory`.

The problem with of algebraic closures of finite fields is that in principle they are *not* defined up to unique isomorphism by a finite amount of defining data.  This is exactly the reason why Conway polynomials were invented, and we could have unique representation if we only used Conway polynomials.  However, the idea of this implementation was to use *pseudo*-Conway polynomials, which do not have the same uniqueness property.

It is not clear to me at the moment that trying to get unique representation at all in this case is the right thing to do.  Especially with the current implementation, given that pseudo-Conway polynomials are not unique, it may be better to just (1) ensure that pickling works and (2) put some warnings in place that algebraic closures are not globally unique and that users should be careful if they want to ensure all elements live in the same algebraic closure.



---

archive/issue_comments_240800.json:
```json
{
    "body": "<a id='comment:59'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/02d152003815d6711582b7bcd11054e8069043bb\">02d1520</a></td><td><code>Merge branch 'develop' into 14990-closure_finite_field</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c14a9034fb23279406c2e373bc9dc343eff1f072\">c14a903</a></td><td><code>Minor improvements to algebraic closure of finite fields</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/96bf62ddaf624edceaf4a597437757e363593dee\">96bf62d</a></td><td><code>Trac 14990: do not try to get unique representation</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/14e18af76afe6092dd2002f2359856daaf9087d4\">14e18af</a></td><td><code>Trac 14990: remove pickling code</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/48e0ffed9690ba9614f7a1655bc2f02465cff4b0\">48e0ffe</a></td><td><code>Trac 14990: fix comparison of elements</code></td></tr></table>\n",
    "created_at": "2014-04-24T17:12:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240800",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:59'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/02d152003815d6711582b7bcd11054e8069043bb">02d1520</a></td><td><code>Merge branch 'develop' into 14990-closure_finite_field</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c14a9034fb23279406c2e373bc9dc343eff1f072">c14a903</a></td><td><code>Minor improvements to algebraic closure of finite fields</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/96bf62ddaf624edceaf4a597437757e363593dee">96bf62d</a></td><td><code>Trac 14990: do not try to get unique representation</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/14e18af76afe6092dd2002f2359856daaf9087d4">14e18af</a></td><td><code>Trac 14990: remove pickling code</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/48e0ffed9690ba9614f7a1655bc2f02465cff4b0">48e0ffe</a></td><td><code>Trac 14990: fix comparison of elements</code></td></tr></table>




---

archive/issue_comments_240801.json:
```json
{
    "body": "**Changing commit** from \"[785c7b90031db8fc32b5a271e5bca538027bcfc1](https://github.com/sagemath/sagetrac-mirror/commit/785c7b90031db8fc32b5a271e5bca538027bcfc1)\" to \"[48e0ffed9690ba9614f7a1655bc2f02465cff4b0](https://github.com/sagemath/sagetrac-mirror/commit/48e0ffed9690ba9614f7a1655bc2f02465cff4b0)\".",
    "created_at": "2014-04-24T17:12:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240801",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[785c7b90031db8fc32b5a271e5bca538027bcfc1](https://github.com/sagemath/sagetrac-mirror/commit/785c7b90031db8fc32b5a271e5bca538027bcfc1)" to "[48e0ffed9690ba9614f7a1655bc2f02465cff4b0](https://github.com/sagemath/sagetrac-mirror/commit/48e0ffed9690ba9614f7a1655bc2f02465cff4b0)".



---

archive/issue_comments_240802.json:
```json
{
    "body": "<a id='comment:60'></a>\nI decided to remove both the `UniqueRepresentation code` and the pickling methods.  The code is much clearer now.  It was surprisingly easy to get everything (mainly comparison of elements) to work again; one just has to be careful in the case where two parents are equal but not identical.\n\n(The branch is based on `u/vdelecroix/14990`.)",
    "created_at": "2014-04-24T17:17:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240802",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:60'></a>
I decided to remove both the `UniqueRepresentation code` and the pickling methods.  The code is much clearer now.  It was surprisingly easy to get everything (mainly comparison of elements) to work again; one just has to be careful in the case where two parents are equal but not identical.

(The branch is based on `u/vdelecroix/14990`.)



---

archive/issue_comments_240803.json:
```json
{
    "body": "**Changing status** from needs_info to needs_review.",
    "created_at": "2014-04-24T17:17:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240803",
    "user": "https://github.com/pjbruin"
}
```

**Changing status** from needs_info to needs_review.



---

archive/issue_comments_240804.json:
```json
{
    "body": "**Changing commit** from \"[48e0ffed9690ba9614f7a1655bc2f02465cff4b0](https://github.com/sagemath/sagetrac-mirror/commit/48e0ffed9690ba9614f7a1655bc2f02465cff4b0)\" to \"[33f982f1acbf61cf08897e6a46ee23bb14e78e1e](https://github.com/sagemath/sagetrac-mirror/commit/33f982f1acbf61cf08897e6a46ee23bb14e78e1e)\".",
    "created_at": "2014-04-24T17:47:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240804",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[48e0ffed9690ba9614f7a1655bc2f02465cff4b0](https://github.com/sagemath/sagetrac-mirror/commit/48e0ffed9690ba9614f7a1655bc2f02465cff4b0)" to "[33f982f1acbf61cf08897e6a46ee23bb14e78e1e](https://github.com/sagemath/sagetrac-mirror/commit/33f982f1acbf61cf08897e6a46ee23bb14e78e1e)".



---

archive/issue_comments_240805.json:
```json
{
    "body": "<a id='comment:61'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/33f982f1acbf61cf08897e6a46ee23bb14e78e1e\">33f982f</a></td><td><code>Trac 14990: small documentation improvements</code></td></tr></table>\n",
    "created_at": "2014-04-24T17:47:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240805",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:61'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/33f982f1acbf61cf08897e6a46ee23bb14e78e1e">33f982f</a></td><td><code>Trac 14990: small documentation improvements</code></td></tr></table>




---

archive/issue_comments_240806.json:
```json
{
    "body": "<a id='comment:62'></a>\nHello Peter,\n\nI do not like\n\n```\nsage: GF(5).algebraic_closure() is GF(5).algebraic_closure()\nFalse\n```\n\nAs far as I understand, a pseudo Conway polynomial is not uniquely defined. But nevertheless, the implementation of `PseudoConwayLattice.polynomial` is, no? The only thing that today prevents the uniqueness is the use of the database as shown in the following example:\n\n```\nsage: P1 = PseudoConwayLattice(5,use_database=True)\nsage: P2 = PseudoConwayLattice(5,use_database=False)\nsage: P1.polynomial(2)\nx^2 + 4*x + 2\nsage: P2.polynomial(2)\nx^2 + x + 2\n```\nMaybe I am wrong and there is more than that.\n\nSo, I propose to restore some kind of unique representation based on the lattice. More precisely (if you agree)\n- Make `AlgebraicClosureFiniteField_pseudo_conway` inherit from `UniqueRepresentation`\n- add a non optional argument `lattice` in the constructor of `AlgebraicClosureFiniteField_pseudo_conway` that can also be used from something like\n\n```\nGF(5).algebraic_closure(implementation='pseudo_conway',lattice=MyFunnyLattice())\n```\n  (that way we would have two **different** implementations of the algebraic closure depending if we use or not the database)\n- possibly restore a `__reduce__` in `AlgebraicClosureFiniteField_pseudo_conway` that avoid the factory (but I guess that it should be taken care by the `UniqueRepresentation`)\n\nAnd then, it remains to find a nice way to avoid rebuilding new lattices each time a user asks for\n\n```\nsage: GF(5).algebraic_closure()\n```\n\nWhat do you think?\n\nVincent",
    "created_at": "2014-04-24T19:43:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240806",
    "user": "https://github.com/videlec"
}
```

<a id='comment:62'></a>
Hello Peter,

I do not like

```
sage: GF(5).algebraic_closure() is GF(5).algebraic_closure()
False
```

As far as I understand, a pseudo Conway polynomial is not uniquely defined. But nevertheless, the implementation of `PseudoConwayLattice.polynomial` is, no? The only thing that today prevents the uniqueness is the use of the database as shown in the following example:

```
sage: P1 = PseudoConwayLattice(5,use_database=True)
sage: P2 = PseudoConwayLattice(5,use_database=False)
sage: P1.polynomial(2)
x^2 + 4*x + 2
sage: P2.polynomial(2)
x^2 + x + 2
```
Maybe I am wrong and there is more than that.

So, I propose to restore some kind of unique representation based on the lattice. More precisely (if you agree)
- Make `AlgebraicClosureFiniteField_pseudo_conway` inherit from `UniqueRepresentation`
- add a non optional argument `lattice` in the constructor of `AlgebraicClosureFiniteField_pseudo_conway` that can also be used from something like

```
GF(5).algebraic_closure(implementation='pseudo_conway',lattice=MyFunnyLattice())
```
  (that way we would have two **different** implementations of the algebraic closure depending if we use or not the database)
- possibly restore a `__reduce__` in `AlgebraicClosureFiniteField_pseudo_conway` that avoid the factory (but I guess that it should be taken care by the `UniqueRepresentation`)

And then, it remains to find a nice way to avoid rebuilding new lattices each time a user asks for

```
sage: GF(5).algebraic_closure()
```

What do you think?

Vincent



---

archive/issue_comments_240807.json:
```json
{
    "body": "<a id='comment:63'></a>\nHello Vincent,\n> I do not like\n> \n> ```\n> sage: GF(5).algebraic_closure() is GF(5).algebraic_closure()\n> False\n> ```\n\nWould you be happier if `FiniteField.algebraic_closure()` were a `cached_method`?\n\nI see your point, but I really don't like the idea that constructing two algebraic closures of the same field can be expected to give identical objects.  (Except if there are \"trivial\" reasons why it should, like caching the result in the above example, or if you use a mathematically well-defined construction like (non-pseudo) Conway polynomials.)",
    "created_at": "2014-04-24T20:00:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240807",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:63'></a>
Hello Vincent,
> I do not like
> 
> ```
> sage: GF(5).algebraic_closure() is GF(5).algebraic_closure()
> False
> ```

Would you be happier if `FiniteField.algebraic_closure()` were a `cached_method`?

I see your point, but I really don't like the idea that constructing two algebraic closures of the same field can be expected to give identical objects.  (Except if there are "trivial" reasons why it should, like caching the result in the above example, or if you use a mathematically well-defined construction like (non-pseudo) Conway polynomials.)



---

archive/issue_comments_240808.json:
```json
{
    "body": "<a id='comment:64'></a>\nHi,\n\n> As far as I understand, a pseudo Conway polynomial is not uniquely defined. But nevertheless, the implementation of `PseudoConwayLattice.polynomial` is, no? The only thing that today prevents the uniqueness is the use of the database\n\n\nI think there are some random choices of roots in the pseudo-Conway algorithm. Am I wrong? And even then, in practice a pseudo-Conway lattice can never be computed completely, and when you are given a partial pseudo-Conway lattice, there are many different ways of completing it.\n\nAnyway, I agree with Peter. This ticket is not only about pseudo-Conway polynomials. There's plenty of algorithmic ways of constructing the algebraic closure of GF(p), each with its pros and cons. None of them is canonical: even the famous \"canonically embedded lattices\" of Lenstra and De Smit, use an arbitrary lexicographic order at some point to make things canonical. So my opinion is that even for those \"canonical\" constructions, it is arguable whether they should be unique representations.",
    "created_at": "2014-04-24T20:45:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240808",
    "user": "https://github.com/defeo"
}
```

<a id='comment:64'></a>
Hi,

> As far as I understand, a pseudo Conway polynomial is not uniquely defined. But nevertheless, the implementation of `PseudoConwayLattice.polynomial` is, no? The only thing that today prevents the uniqueness is the use of the database


I think there are some random choices of roots in the pseudo-Conway algorithm. Am I wrong? And even then, in practice a pseudo-Conway lattice can never be computed completely, and when you are given a partial pseudo-Conway lattice, there are many different ways of completing it.

Anyway, I agree with Peter. This ticket is not only about pseudo-Conway polynomials. There's plenty of algorithmic ways of constructing the algebraic closure of GF(p), each with its pros and cons. None of them is canonical: even the famous "canonically embedded lattices" of Lenstra and De Smit, use an arbitrary lexicographic order at some point to make things canonical. So my opinion is that even for those "canonical" constructions, it is arguable whether they should be unique representations.



---

archive/issue_comments_240809.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2014-04-25T08:19:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240809",
    "user": "https://github.com/videlec"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_240810.json:
```json
{
    "body": "<a id='comment:65'></a>\nHello,\n\nThanks Peter and Luca for the lights.\n\n1) For the comparison of `AlgebraicClosureFiniteField` you rely on the equality in `PseudoConwayLattice`... which is not exactly what you want. It compares the nodes which is something dynamical by definition. We have for example\n\n```\nsage: P1 = PseudoConwayLattice(5, use_database=False)\nsage: P2 = PseudoConwayLattice(5, use_database=False)\nsage: P1 == P2\nTrue\nsage: _ = P1.polynomial(1)\nsage: P1 == P2     # hum!?\nFalse\nsage: _ = P2.polynomial(1)\nsage: P1 == P2     # hum hum!!??\nTrue\n```\nIt is fine for the lattices but not for the fields. The simplest fix would be\n\n```\nclass AlgebraicClosureFiniteField_pseudo_conway:\n   ...\n   def __cmp___(self, other):\n      ...\n      return self._pseudo_conway_lattice is other._pseudo_conway_lattice\n```\n\n2) It makes sense to have something more flexible like\n\n```\nsage: AC = AlgebraicClosureFiniteField_pseudo_conway\nsage: AC(GF(3), lattice=my_pc_lattice)\n```\nwhere \"my_pc_lattice\" is an instance of a subclass or `PseudoConwayLattice` or something with the same specifications (i.e. at least a method `polynomial`). That way we can already have two implementations of the algebraic closure (calling `PseudoConwayLattice` with the option `use_database=True` or `use_database=False`).\n\n3) In the example above, there is some redundancy as the pseudo-Conway lattice already knows the finite field... so it would be nice if the pseudo-Conway lattice implements a method `base_ring` that returns the finite field it is based on.\n\n4) It would also make sense in `PseudoConwayLattice` to have a method `associated_finite_field_algebraic_closure` (with a better name if possible).\n\nVincent\n\nPS: will see later for the unique representation problems.",
    "created_at": "2014-04-25T08:19:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240810",
    "user": "https://github.com/videlec"
}
```

<a id='comment:65'></a>
Hello,

Thanks Peter and Luca for the lights.

1) For the comparison of `AlgebraicClosureFiniteField` you rely on the equality in `PseudoConwayLattice`... which is not exactly what you want. It compares the nodes which is something dynamical by definition. We have for example

```
sage: P1 = PseudoConwayLattice(5, use_database=False)
sage: P2 = PseudoConwayLattice(5, use_database=False)
sage: P1 == P2
True
sage: _ = P1.polynomial(1)
sage: P1 == P2     # hum!?
False
sage: _ = P2.polynomial(1)
sage: P1 == P2     # hum hum!!??
True
```
It is fine for the lattices but not for the fields. The simplest fix would be

```
class AlgebraicClosureFiniteField_pseudo_conway:
   ...
   def __cmp___(self, other):
      ...
      return self._pseudo_conway_lattice is other._pseudo_conway_lattice
```

2) It makes sense to have something more flexible like

```
sage: AC = AlgebraicClosureFiniteField_pseudo_conway
sage: AC(GF(3), lattice=my_pc_lattice)
```
where "my_pc_lattice" is an instance of a subclass or `PseudoConwayLattice` or something with the same specifications (i.e. at least a method `polynomial`). That way we can already have two implementations of the algebraic closure (calling `PseudoConwayLattice` with the option `use_database=True` or `use_database=False`).

3) In the example above, there is some redundancy as the pseudo-Conway lattice already knows the finite field... so it would be nice if the pseudo-Conway lattice implements a method `base_ring` that returns the finite field it is based on.

4) It would also make sense in `PseudoConwayLattice` to have a method `associated_finite_field_algebraic_closure` (with a better name if possible).

Vincent

PS: will see later for the unique representation problems.



---

archive/issue_comments_240811.json:
```json
{
    "body": "<a id='comment:66'></a>\nReplying to [vdelecroix](#comment%3A65):\n> Hello,\n> \n> Thanks Peter and Luca for the lights.\n> \n> 1) For the comparison of `AlgebraicClosureFiniteField` you rely on the equality in `PseudoConwayLattice`... which is not exactly what you want. It compares the nodes which is something dynamical by definition. We have for example\n> \n> ```\n> sage: P1 = PseudoConwayLattice(5, use_database=False)\n> sage: P2 = PseudoConwayLattice(5, use_database=False)\n> sage: P1 == P2\n> True\n> sage: _ = P1.polynomial(1)\n> sage: P1 == P2     # hum!?\n> False\n> sage: _ = P2.polynomial(1)\n> sage: P1 == P2     # hum hum!!??\n> True\n> ```\n> It is fine for the lattices but not for the fields. The simplest fix would be\n\nIs it really fine for lattices?\nI would say lattices with different polynomials shouldn't evaluate equal.\n> \n> ```\n> class AlgebraicClosureFiniteField_pseudo_conway:\n>    ...\n>    def __cmp___(self, other):\n>       ...\n>       return self._pseudo_conway_lattice is other._pseudo_conway_lattice\n> ```\n> \n> 2) It makes sense to have something more flexible like\n> \n> ```\n> sage: AC = AlgebraicClosureFiniteField_pseudo_conway\n> sage: AC(GF(3), lattice=my_pc_lattice)\n> ```\n> where \"my_pc_lattice\" is an instance of a subclass or `PseudoConwayLattice` or something with the same specifications (i.e. at least a method `polynomial`). That way we can already have two implementations of the algebraic closure (calling `PseudoConwayLattice` with the option `use_database=True` or `use_database=False`).\n\n>\nThat sounds like a good idea. \n> 3) In the example above, there is some redundancy as the pseudo-Conway lattice already knows the finite field... so it would be nice if the pseudo-Conway lattice implements a method `base_ring` that returns the finite field it is based on.\n> \n\n+1\n> 4) It would also make sense in `PseudoConwayLattice` to have a method `associated_finite_field_algebraic_closure` (with a better name if possible).\n> \n\nWould that be really useful?\nThat does not really make sense, but one might want to create a lattice without the corresponding algebraic closure :)",
    "created_at": "2014-04-25T08:57:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240811",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:66'></a>
Replying to [vdelecroix](#comment%3A65):
> Hello,
> 
> Thanks Peter and Luca for the lights.
> 
> 1) For the comparison of `AlgebraicClosureFiniteField` you rely on the equality in `PseudoConwayLattice`... which is not exactly what you want. It compares the nodes which is something dynamical by definition. We have for example
> 
> ```
> sage: P1 = PseudoConwayLattice(5, use_database=False)
> sage: P2 = PseudoConwayLattice(5, use_database=False)
> sage: P1 == P2
> True
> sage: _ = P1.polynomial(1)
> sage: P1 == P2     # hum!?
> False
> sage: _ = P2.polynomial(1)
> sage: P1 == P2     # hum hum!!??
> True
> ```
> It is fine for the lattices but not for the fields. The simplest fix would be

Is it really fine for lattices?
I would say lattices with different polynomials shouldn't evaluate equal.
> 
> ```
> class AlgebraicClosureFiniteField_pseudo_conway:
>    ...
>    def __cmp___(self, other):
>       ...
>       return self._pseudo_conway_lattice is other._pseudo_conway_lattice
> ```
> 
> 2) It makes sense to have something more flexible like
> 
> ```
> sage: AC = AlgebraicClosureFiniteField_pseudo_conway
> sage: AC(GF(3), lattice=my_pc_lattice)
> ```
> where "my_pc_lattice" is an instance of a subclass or `PseudoConwayLattice` or something with the same specifications (i.e. at least a method `polynomial`). That way we can already have two implementations of the algebraic closure (calling `PseudoConwayLattice` with the option `use_database=True` or `use_database=False`).

>
That sounds like a good idea. 
> 3) In the example above, there is some redundancy as the pseudo-Conway lattice already knows the finite field... so it would be nice if the pseudo-Conway lattice implements a method `base_ring` that returns the finite field it is based on.
> 

+1
> 4) It would also make sense in `PseudoConwayLattice` to have a method `associated_finite_field_algebraic_closure` (with a better name if possible).
> 

Would that be really useful?
That does not really make sense, but one might want to create a lattice without the corresponding algebraic closure :)



---

archive/issue_comments_240812.json:
```json
{
    "body": "<a id='comment:67'></a>\nReplying to [jpflori](#comment%3A66):\n> Replying to [vdelecroix](#comment%3A65):\n> > Hello,\n> > \n> > Thanks Peter and Luca for the lights.\n> > \n> > 1) For the comparison of `AlgebraicClosureFiniteField` you rely on the equality in `PseudoConwayLattice`... which is not exactly what you want. It compares the nodes which is something dynamical by definition. We have for example\n> > \n> > ```\n> > sage: P1 = PseudoConwayLattice(5, use_database=False)\n> > sage: P2 = PseudoConwayLattice(5, use_database=False)\n> > sage: P1 == P2\n> > True\n> > sage: _ = P1.polynomial(1)\n> > sage: P1 == P2     # hum!?\n> > False\n> > sage: _ = P2.polynomial(1)\n> > sage: P1 == P2     # hum hum!!??\n> > True\n> > ```\n> > It is fine for the lattices but not for the fields. The simplest fix would be\n\n> Is it really fine for lattices?\n> I would say lattices with different polynomials shouldn't evaluate equal.\n\nOk, I answered too quickly here.\nThe problem is that polynomials are added to the lattices but not at the same time.\n\nIn this case, the fact that when the polynomials of the same degree added to the two lattices are actually the same is pure luck.\nAs Luca remarked, there is some randomness (ok, maybe not so random if you look at what is actually happenning, but it is designed in a way it should be random), and the polynomials may be different.\n\nAnyway, I do agree with the fact that the lattice are once equal, then different and then equal again.\nThe only sensible thing to do to compare the lattices is to chek they have the same polynomials at every degree.\nMaybe in the case where `database=True` or conway polynomials are used we could make the lattice unique or consider two lattices with different degrees computed equal (but then we should also forbid lattices with `database=True` to overflow the database limits) and whatsoever that's not really the issue here.\nIn the case of algebraic closure, I feel the same is enough. We don't really need identity of the underlying lattices.\nIt's dynamical indeed, but there's no other way to do that (except for construction where you have something canonical or at least unique, let's say with Conway polynomials).\nBut if we have that's even better (and would be easier to test: only a pointers comparison).",
    "created_at": "2014-04-25T12:05:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240812",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:67'></a>
Replying to [jpflori](#comment%3A66):
> Replying to [vdelecroix](#comment%3A65):
> > Hello,
> > 
> > Thanks Peter and Luca for the lights.
> > 
> > 1) For the comparison of `AlgebraicClosureFiniteField` you rely on the equality in `PseudoConwayLattice`... which is not exactly what you want. It compares the nodes which is something dynamical by definition. We have for example
> > 
> > ```
> > sage: P1 = PseudoConwayLattice(5, use_database=False)
> > sage: P2 = PseudoConwayLattice(5, use_database=False)
> > sage: P1 == P2
> > True
> > sage: _ = P1.polynomial(1)
> > sage: P1 == P2     # hum!?
> > False
> > sage: _ = P2.polynomial(1)
> > sage: P1 == P2     # hum hum!!??
> > True
> > ```
> > It is fine for the lattices but not for the fields. The simplest fix would be

> Is it really fine for lattices?
> I would say lattices with different polynomials shouldn't evaluate equal.

Ok, I answered too quickly here.
The problem is that polynomials are added to the lattices but not at the same time.

In this case, the fact that when the polynomials of the same degree added to the two lattices are actually the same is pure luck.
As Luca remarked, there is some randomness (ok, maybe not so random if you look at what is actually happenning, but it is designed in a way it should be random), and the polynomials may be different.

Anyway, I do agree with the fact that the lattice are once equal, then different and then equal again.
The only sensible thing to do to compare the lattices is to chek they have the same polynomials at every degree.
Maybe in the case where `database=True` or conway polynomials are used we could make the lattice unique or consider two lattices with different degrees computed equal (but then we should also forbid lattices with `database=True` to overflow the database limits) and whatsoever that's not really the issue here.
In the case of algebraic closure, I feel the same is enough. We don't really need identity of the underlying lattices.
It's dynamical indeed, but there's no other way to do that (except for construction where you have something canonical or at least unique, let's say with Conway polynomials).
But if we have that's even better (and would be easier to test: only a pointers comparison).



---

archive/issue_comments_240813.json:
```json
{
    "body": "<a id='comment:68'></a>\nI agree with Jean-Pierre's analysis.  Let me just add that one shouldn't read too much mathematical meaning into equality (`==`) of parents.  The main use for it is in deciding whether to allow coercion from one `AlgebraicClosureFiniteField` to another.  For that, the only thing that make sense is to check if the PCPL's are the same.  Here we do definitely want to check \"only\" equality, not identity.  If we did anything less than checking equality, say only checking if one lattice is equal to a sublattice of the other, then we would be asking for trouble.  For example, if we had an element *x* in the subfield of degree *n* in one of the two, then we would have no guarantee that the subfield of degree *n* that would have to be constructed in the other instance (where we want to coerce *x*) would be the same.",
    "created_at": "2014-04-25T23:42:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240813",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:68'></a>
I agree with Jean-Pierre's analysis.  Let me just add that one shouldn't read too much mathematical meaning into equality (`==`) of parents.  The main use for it is in deciding whether to allow coercion from one `AlgebraicClosureFiniteField` to another.  For that, the only thing that make sense is to check if the PCPL's are the same.  Here we do definitely want to check "only" equality, not identity.  If we did anything less than checking equality, say only checking if one lattice is equal to a sublattice of the other, then we would be asking for trouble.  For example, if we had an element *x* in the subfield of degree *n* in one of the two, then we would have no guarantee that the subfield of degree *n* that would have to be constructed in the other instance (where we want to coerce *x*) would be the same.



---

archive/issue_comments_240814.json:
```json
{
    "body": "<a id='comment:69'></a>\nHi Peter,\n\nEither I badly explained something or there is something contradictory in your argument. First of all you said\n\n> The main use for it [the equality] is in deciding whether\n> to allow coercion from one `AlgebraicClosureFiniteField`\n> to another.\n\n\nFine. But that was my point, equality is broken as we currently have with your branch applied\n\n```\nsage: p = next_prime(100000)\nsage: K = GF(p)\nsage: F1 = K.algebraic_closure()\nsage: F2 = K.algebraic_closure()\nsage: F1 == F2\nTrue\nsage: _ = F1.gen(3)   # force computation in PCL 1\nsage: F1 == F2\nFalse\nsage: _ = F2.gen(3)   # same computation in PCL 2\nsage: F1 == F2\nTrue\n```\nSo depending in which stage of the computation you are, there will or will not be a coercion between your fields! Do you agree that there is a problem here? \n\n> we do definitely want to check \"only\" equality, not identity [of PCL].\n\n\nHere it depends on what you mean by \"equality\". If it is equality as mathematical object I do agree if it is equality as Python comparison I strongly disagree. The Python equality of PCL currently is: \"two PCL are equal if they agree on their already made computations\". And, as Jean-Pierre mentioned, it is not the purpose of that ticket to improve that.\n\nVincent",
    "created_at": "2014-04-26T06:55:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240814",
    "user": "https://github.com/videlec"
}
```

<a id='comment:69'></a>
Hi Peter,

Either I badly explained something or there is something contradictory in your argument. First of all you said

> The main use for it [the equality] is in deciding whether
> to allow coercion from one `AlgebraicClosureFiniteField`
> to another.


Fine. But that was my point, equality is broken as we currently have with your branch applied

```
sage: p = next_prime(100000)
sage: K = GF(p)
sage: F1 = K.algebraic_closure()
sage: F2 = K.algebraic_closure()
sage: F1 == F2
True
sage: _ = F1.gen(3)   # force computation in PCL 1
sage: F1 == F2
False
sage: _ = F2.gen(3)   # same computation in PCL 2
sage: F1 == F2
True
```
So depending in which stage of the computation you are, there will or will not be a coercion between your fields! Do you agree that there is a problem here? 

> we do definitely want to check "only" equality, not identity [of PCL].


Here it depends on what you mean by "equality". If it is equality as mathematical object I do agree if it is equality as Python comparison I strongly disagree. The Python equality of PCL currently is: "two PCL are equal if they agree on their already made computations". And, as Jean-Pierre mentioned, it is not the purpose of that ticket to improve that.

Vincent



---

archive/issue_comments_240815.json:
```json
{
    "body": "<a id='comment:70'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a585d4a99ac7e2a3bad1bb32ef2229eccea1f0ff\">a585d4a</a></td><td><code>Trac 14990: make AlgebraicClosureFiniteField_pseudo_conway accept more arguments</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f9162dbae92551a67aea7a489d96591141fdebc8\">f9162db</a></td><td><code>Trac 14990: make FiniteField.algebraic_closure() a cached method</code></td></tr></table>\n",
    "created_at": "2014-04-26T10:43:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240815",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:70'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a585d4a99ac7e2a3bad1bb32ef2229eccea1f0ff">a585d4a</a></td><td><code>Trac 14990: make AlgebraicClosureFiniteField_pseudo_conway accept more arguments</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f9162dbae92551a67aea7a489d96591141fdebc8">f9162db</a></td><td><code>Trac 14990: make FiniteField.algebraic_closure() a cached method</code></td></tr></table>




---

archive/issue_comments_240816.json:
```json
{
    "body": "**Changing commit** from \"[33f982f1acbf61cf08897e6a46ee23bb14e78e1e](https://github.com/sagemath/sagetrac-mirror/commit/33f982f1acbf61cf08897e6a46ee23bb14e78e1e)\" to \"[f9162dbae92551a67aea7a489d96591141fdebc8](https://github.com/sagemath/sagetrac-mirror/commit/f9162dbae92551a67aea7a489d96591141fdebc8)\".",
    "created_at": "2014-04-26T10:43:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240816",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[33f982f1acbf61cf08897e6a46ee23bb14e78e1e](https://github.com/sagemath/sagetrac-mirror/commit/33f982f1acbf61cf08897e6a46ee23bb14e78e1e)" to "[f9162dbae92551a67aea7a489d96591141fdebc8](https://github.com/sagemath/sagetrac-mirror/commit/f9162dbae92551a67aea7a489d96591141fdebc8)".



---

archive/issue_comments_240817.json:
```json
{
    "body": "<a id='comment:71'></a>\nHi Vincent,\n> 2) It makes sense to have something more flexible like\n> \n> ```\n> sage: AC = AlgebraicClosureFiniteField_pseudo_conway\n> sage: AC(GF(3), lattice=my_pc_lattice)\n> ```\n> where \"my_pc_lattice\" is an instance of a subclass or `PseudoConwayLattice` or something with the same specifications (i.e. at least a method `polynomial`). That way we can already have two implementations of the algebraic closure (calling `PseudoConwayLattice` with the option `use_database=True` or `use_database=False`).\n\nThis is implemented in one of the two new commits; one can now pass a `lattice` argument, and the `use_database` flag is now accepted here as well.\n> 3) In the example above, there is some redundancy as the pseudo-Conway lattice already knows the finite field... so it would be nice if the pseudo-Conway lattice implements a method `base_ring` that returns the finite field it is based on.\n\nIt already has a public attribute `p` for the characteristic; since the PCL is not really meant to be used directly anyway, I think it is redundant to also add a `base_ring()` method.\n> 4) It would also make sense in `PseudoConwayLattice` to have a method `associated_finite_field_algebraic_closure` (with a better name if possible).\n\nI agree with Jean-Pierre here; this doesn't seem to be useful.  To compare, we don't have (and don't need) a method `associated_finite_field()` for polynomials over **F**<sub>*p*</sub> either.",
    "created_at": "2014-04-26T10:49:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240817",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:71'></a>
Hi Vincent,
> 2) It makes sense to have something more flexible like
> 
> ```
> sage: AC = AlgebraicClosureFiniteField_pseudo_conway
> sage: AC(GF(3), lattice=my_pc_lattice)
> ```
> where "my_pc_lattice" is an instance of a subclass or `PseudoConwayLattice` or something with the same specifications (i.e. at least a method `polynomial`). That way we can already have two implementations of the algebraic closure (calling `PseudoConwayLattice` with the option `use_database=True` or `use_database=False`).

This is implemented in one of the two new commits; one can now pass a `lattice` argument, and the `use_database` flag is now accepted here as well.
> 3) In the example above, there is some redundancy as the pseudo-Conway lattice already knows the finite field... so it would be nice if the pseudo-Conway lattice implements a method `base_ring` that returns the finite field it is based on.

It already has a public attribute `p` for the characteristic; since the PCL is not really meant to be used directly anyway, I think it is redundant to also add a `base_ring()` method.
> 4) It would also make sense in `PseudoConwayLattice` to have a method `associated_finite_field_algebraic_closure` (with a better name if possible).

I agree with Jean-Pierre here; this doesn't seem to be useful.  To compare, we don't have (and don't need) a method `associated_finite_field()` for polynomials over **F**<sub>*p*</sub> either.



---

archive/issue_comments_240818.json:
```json
{
    "body": "<a id='comment:72'></a>\nHi Vincent,\n> Either I badly explained something or there is something contradictory in your argument.\n\nOr I badly explained something...\n> First of all you said\n> \n> > The main use for it [the equality] is in deciding whether\n> > to allow coercion from one `AlgebraicClosureFiniteField`\n> > to another.\n\n> \n> Fine. But that was my point, equality is broken \n  \nI don't see in what sense you can really say that equality is broken, since it is not designed to be a mathematically meaningful property in this case.  I think we should use the most restrictive notion possible that still allows non-identical fields to compare equal.  (In this way we stay as close to unique representation as possible, in the sense that two non-identical objects only compare equal under very precise circumstances.)\n> So depending in which stage of the computation you are, there will or will not be a coercion between your fields! Do you agree that there is a problem here? \n\nNo, I don't think there is a problem.  Nobody forces us to have all kinds of coercions that could possibly make sense.  We should encourage the user to do all computations in the *same* field; making `algebraic_closure()` a cached method (as in one of the two new commits) is meant to help with this.  As far as I'm concerned, coercion between equal but non-identical fields is only useful to make the \"sanity check\" `loads(dumps(x)) == x` work.  I think it would be a mistake to make efforts to make different instances \"synchronized\" in some way, e.g. by keeping coercion once the underlying pseudo-Conway lattices of two instances start to diverge.\n> > we do definitely want to check \"only\" equality, not identity [of PCL].\n\n> \n> Here it depends on what you mean by \"equality\". If it is equality as mathematical object I do agree if it is equality as Python comparison I strongly disagree.\n\nIn this context I really think that the only sensible notion of equality is to compare the finite sublattices that have already been computed.  I understand that this does not fit the idea of \"equality as mathematical object\", but this is out of necessity, because an `AlgebraicClosureFiniteField_pseudo_conway` object simply doesn't define a unique mathematical object.  There is no guarantee that two partially computed PCL's will evolve in the same way.  Think of a situation where the user pickles one instance, loads it in a newer Sage version where the algorithm for computing pseudo-Conway polynomials has changed, and computes another instance of \"the same\" field in that Sage version.  Then as a consequence of the non-uniqueness of pseudo-Conway polynomials, the results may disagree even if the commands used to create them were exactly the same.\n> The Python equality of PCL currently is: \"two PCL are equal if they agree on their already made computations\". And, as Jean-Pierre mentioned, it is not the purpose of that ticket to improve that.\n\nI think it is not even desirable in principle to improve this, because PCL's are non-unique by design.  If you want a mathematically well-defined notion of equality (that is preserved under future extension of the lattices), you have to stick to (non-pseudo) Conway polynomials or use other canonical lattices of finite fields.",
    "created_at": "2014-04-26T11:19:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240818",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:72'></a>
Hi Vincent,
> Either I badly explained something or there is something contradictory in your argument.

Or I badly explained something...
> First of all you said
> 
> > The main use for it [the equality] is in deciding whether
> > to allow coercion from one `AlgebraicClosureFiniteField`
> > to another.

> 
> Fine. But that was my point, equality is broken 
  
I don't see in what sense you can really say that equality is broken, since it is not designed to be a mathematically meaningful property in this case.  I think we should use the most restrictive notion possible that still allows non-identical fields to compare equal.  (In this way we stay as close to unique representation as possible, in the sense that two non-identical objects only compare equal under very precise circumstances.)
> So depending in which stage of the computation you are, there will or will not be a coercion between your fields! Do you agree that there is a problem here? 

No, I don't think there is a problem.  Nobody forces us to have all kinds of coercions that could possibly make sense.  We should encourage the user to do all computations in the *same* field; making `algebraic_closure()` a cached method (as in one of the two new commits) is meant to help with this.  As far as I'm concerned, coercion between equal but non-identical fields is only useful to make the "sanity check" `loads(dumps(x)) == x` work.  I think it would be a mistake to make efforts to make different instances "synchronized" in some way, e.g. by keeping coercion once the underlying pseudo-Conway lattices of two instances start to diverge.
> > we do definitely want to check "only" equality, not identity [of PCL].

> 
> Here it depends on what you mean by "equality". If it is equality as mathematical object I do agree if it is equality as Python comparison I strongly disagree.

In this context I really think that the only sensible notion of equality is to compare the finite sublattices that have already been computed.  I understand that this does not fit the idea of "equality as mathematical object", but this is out of necessity, because an `AlgebraicClosureFiniteField_pseudo_conway` object simply doesn't define a unique mathematical object.  There is no guarantee that two partially computed PCL's will evolve in the same way.  Think of a situation where the user pickles one instance, loads it in a newer Sage version where the algorithm for computing pseudo-Conway polynomials has changed, and computes another instance of "the same" field in that Sage version.  Then as a consequence of the non-uniqueness of pseudo-Conway polynomials, the results may disagree even if the commands used to create them were exactly the same.
> The Python equality of PCL currently is: "two PCL are equal if they agree on their already made computations". And, as Jean-Pierre mentioned, it is not the purpose of that ticket to improve that.

I think it is not even desirable in principle to improve this, because PCL's are non-unique by design.  If you want a mathematically well-defined notion of equality (that is preserved under future extension of the lattices), you have to stick to (non-pseudo) Conway polynomials or use other canonical lattices of finite fields.



---

archive/issue_comments_240819.json:
```json
{
    "body": "<a id='comment:73'></a>\nReplying to [pbruin](#comment%3A71):\n> Hi Vincent,\n> > 2) It makes sense to have something more flexible like\n> > \n> > ```\n> > sage: AC = AlgebraicClosureFiniteField_pseudo_conway\n> > sage: AC(GF(3), lattice=my_pc_lattice)\n> > ```\n> > where \"my_pc_lattice\" is an instance of a subclass or `PseudoConwayLattice` or something with the same specifications (i.e. at least a method `polynomial`). That way we can already have two implementations of the algebraic closure (calling `PseudoConwayLattice` with the option `use_database=True` or `use_database=False`).\n\n> This is implemented in one of the two new commits; one can now pass a `lattice` argument, and the `use_database` flag is now accepted here as well.\n\nGreat. Thanks.\n\n> > 3) In the example above, there is some redundancy as the pseudo-Conway lattice already knows the finite field... so it would be nice if the pseudo-Conway lattice implements a method `base_ring` that returns the finite field it is based on.\n\n> It already has a public attribute `p` for the characteristic; since the PCL is not really meant to be used directly anyway, I think it is redundant to also add a `base_ring()` method.\n\nHere I am not sure I agree. But anyway it would be better not to touch `PseudoConwayLattice` anyway.\n\n> > 4) It would also make sense in `PseudoConwayLattice` to have a method `associated_finite_field_algebraic_closure` (with a better name if possible).\n\n> I agree with Jean-Pierre here; this doesn't seem to be useful.  To compare, we don't have (and don't need) a method `associated_finite_field()` for polynomials over **F**<sub>*p*</sub> either.\n\nAgreed.",
    "created_at": "2014-04-26T13:12:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240819",
    "user": "https://github.com/videlec"
}
```

<a id='comment:73'></a>
Replying to [pbruin](#comment%3A71):
> Hi Vincent,
> > 2) It makes sense to have something more flexible like
> > 
> > ```
> > sage: AC = AlgebraicClosureFiniteField_pseudo_conway
> > sage: AC(GF(3), lattice=my_pc_lattice)
> > ```
> > where "my_pc_lattice" is an instance of a subclass or `PseudoConwayLattice` or something with the same specifications (i.e. at least a method `polynomial`). That way we can already have two implementations of the algebraic closure (calling `PseudoConwayLattice` with the option `use_database=True` or `use_database=False`).

> This is implemented in one of the two new commits; one can now pass a `lattice` argument, and the `use_database` flag is now accepted here as well.

Great. Thanks.

> > 3) In the example above, there is some redundancy as the pseudo-Conway lattice already knows the finite field... so it would be nice if the pseudo-Conway lattice implements a method `base_ring` that returns the finite field it is based on.

> It already has a public attribute `p` for the characteristic; since the PCL is not really meant to be used directly anyway, I think it is redundant to also add a `base_ring()` method.

Here I am not sure I agree. But anyway it would be better not to touch `PseudoConwayLattice` anyway.

> > 4) It would also make sense in `PseudoConwayLattice` to have a method `associated_finite_field_algebraic_closure` (with a better name if possible).

> I agree with Jean-Pierre here; this doesn't seem to be useful.  To compare, we don't have (and don't need) a method `associated_finite_field()` for polynomials over **F**<sub>*p*</sub> either.

Agreed.



---

archive/issue_comments_240820.json:
```json
{
    "body": "<a id='comment:74'></a>\nHi Peter,\n\nI still think that the equality of algebraic closures is broken for several reasons. I think (please correct me if you do not agree) that\n- we do not want that the equality between unmutable objects changes: if two unmutable objects are equal at a given time they still should be equal a minute later (this is true for parents and elements)\n- comparisons with == and != may never raise an error.\nThis is why the example I gave you before is a bug (see the other one below if you are not convinced). I am in favour of a **more** restrictive equality for fields based on identity of the pseudo conway lattice. It will allow less coercion but at least it will be consistent with the two things above.\n\nWithin your branch\n\n```\nsage: p = next_prime(100000)\nsage: K = GF(p).algebraic_closure()\nsage: x = K.gen(2)\nsage: y = loads(dumps(x))\nsage: x == y        # sanity check\nTrue\nsage: _ = K.gen(5)  # force computation\nsage: x.parent() == y.parent()\nFalse\nsage: x == y\nTraceback (most recent call last):\n...\nRuntimeError: BUG in map ...\n```\nIn principle we could hope for a False above but the coercion system has a cache. This is the reason for the `RuntimeError`.",
    "created_at": "2014-04-26T14:10:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240820",
    "user": "https://github.com/videlec"
}
```

<a id='comment:74'></a>
Hi Peter,

I still think that the equality of algebraic closures is broken for several reasons. I think (please correct me if you do not agree) that
- we do not want that the equality between unmutable objects changes: if two unmutable objects are equal at a given time they still should be equal a minute later (this is true for parents and elements)
- comparisons with == and != may never raise an error.
This is why the example I gave you before is a bug (see the other one below if you are not convinced). I am in favour of a **more** restrictive equality for fields based on identity of the pseudo conway lattice. It will allow less coercion but at least it will be consistent with the two things above.

Within your branch

```
sage: p = next_prime(100000)
sage: K = GF(p).algebraic_closure()
sage: x = K.gen(2)
sage: y = loads(dumps(x))
sage: x == y        # sanity check
True
sage: _ = K.gen(5)  # force computation
sage: x.parent() == y.parent()
False
sage: x == y
Traceback (most recent call last):
...
RuntimeError: BUG in map ...
```
In principle we could hope for a False above but the coercion system has a cache. This is the reason for the `RuntimeError`.



---

archive/issue_comments_240821.json:
```json
{
    "body": "<a id='comment:75'></a>\nThis is not an easy problem.  First of all, I have to say I don't understand precisely what it means for an object to be immutable.  Roughly speaking it is supposed to mean that \"its value cannot change\", but that doesn't seem to be a completely well-defined notion either.\n\nIt seems to me that in the case of `AlgebraicClosureFiniteField_pseudo_conway`, the indeterminacy of pseudo-Conway lattices forces us to say that (1) the \"value\" of an instance has to include the set of subfields that have been computed, and (2) the only way to guarantee immutability is to define equality using identity of the lattices.\n\nIf this reasoning is correct, *and* we accept that parents should be immutable (which does sound like a reasonable condition, although I'm not immediately convinced that it should hold in this situation), then we have to accept Vincent's opinion that for two instances to compare equal it is a necessary condition that the lattices be identical.  In that case I guess we may as well go all the way back to comparing by identity of the fields themselves.\n\nIt is a bit annoying, and I do not see how to easily avoid breaking the sanity check `loads(dumps(x)) == x` if we take this approach.  Maybe we should just capitulate on this point and disable this check in the `TestSuite`, or explicitly give the error as the expected result of the `TestSuite`.",
    "created_at": "2014-04-26T18:51:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240821",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:75'></a>
This is not an easy problem.  First of all, I have to say I don't understand precisely what it means for an object to be immutable.  Roughly speaking it is supposed to mean that "its value cannot change", but that doesn't seem to be a completely well-defined notion either.

It seems to me that in the case of `AlgebraicClosureFiniteField_pseudo_conway`, the indeterminacy of pseudo-Conway lattices forces us to say that (1) the "value" of an instance has to include the set of subfields that have been computed, and (2) the only way to guarantee immutability is to define equality using identity of the lattices.

If this reasoning is correct, *and* we accept that parents should be immutable (which does sound like a reasonable condition, although I'm not immediately convinced that it should hold in this situation), then we have to accept Vincent's opinion that for two instances to compare equal it is a necessary condition that the lattices be identical.  In that case I guess we may as well go all the way back to comparing by identity of the fields themselves.

It is a bit annoying, and I do not see how to easily avoid breaking the sanity check `loads(dumps(x)) == x` if we take this approach.  Maybe we should just capitulate on this point and disable this check in the `TestSuite`, or explicitly give the error as the expected result of the `TestSuite`.



---

archive/issue_comments_240822.json:
```json
{
    "body": "<a id='comment:76'></a>\nHi,\n\nGiven that `PseudoConwayLattice` is what it is, I agree to (1) and (2) in your [comment:75](#comment%3A75).\n\nCoercion are cached and I guess it forbids to have a mutable `Parent` (unless they coerce with nothing).\n\nAnd you are right, we have a big trouble as we can not loads/dumps `PseudoConwayLattice` in the way we would like them to be. It seems reasonable to me to keep the error on `x == loads(dumps(x))` and document it.\n\nNevertheless, we can fix it for most use cases by avoiding calling loads/dumps on the lattice. More precisely, when the user does not provide directly a lattice argument to the algebraic closure, we might cache the pseudo conway lattice used. In other words do something along the lines of\n\n```\n@cached_function\ndef cached_pseudo_conway_lattice(p, use_database):\n    return PseudoConwayLattice(p, use_database)\n\ndef AlgebraicClosureFiniteField(p, implementation='pseudo_conway', **kwds):\n    if implementation == 'pseudo_conway':\n        lattice = kwds.get('lattice')\n        use_database = kwds.get('use_database', True)\n        if lattice is None:\n            lattice = cached_pseudo_conway_lattice(p, use_database)\n        ...\n```\nAnd then the pickling must be adapted by calling `AlgebraicClosureFiniteField`. I am sure that it can work but I am not sure at all it is reasonable.",
    "created_at": "2014-04-26T22:29:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240822",
    "user": "https://github.com/videlec"
}
```

<a id='comment:76'></a>
Hi,

Given that `PseudoConwayLattice` is what it is, I agree to (1) and (2) in your [comment:75](#comment%3A75).

Coercion are cached and I guess it forbids to have a mutable `Parent` (unless they coerce with nothing).

And you are right, we have a big trouble as we can not loads/dumps `PseudoConwayLattice` in the way we would like them to be. It seems reasonable to me to keep the error on `x == loads(dumps(x))` and document it.

Nevertheless, we can fix it for most use cases by avoiding calling loads/dumps on the lattice. More precisely, when the user does not provide directly a lattice argument to the algebraic closure, we might cache the pseudo conway lattice used. In other words do something along the lines of

```
@cached_function
def cached_pseudo_conway_lattice(p, use_database):
    return PseudoConwayLattice(p, use_database)

def AlgebraicClosureFiniteField(p, implementation='pseudo_conway', **kwds):
    if implementation == 'pseudo_conway':
        lattice = kwds.get('lattice')
        use_database = kwds.get('use_database', True)
        if lattice is None:
            lattice = cached_pseudo_conway_lattice(p, use_database)
        ...
```
And then the pickling must be adapted by calling `AlgebraicClosureFiniteField`. I am sure that it can work but I am not sure at all it is reasonable.



---

archive/issue_comments_240823.json:
```json
{
    "body": "<a id='comment:77'></a>\n**ping**\n\nDo you want that I give it a try?\n\nVincent",
    "created_at": "2014-05-02T10:16:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240823",
    "user": "https://github.com/videlec"
}
```

<a id='comment:77'></a>
**ping**

Do you want that I give it a try?

Vincent



---

archive/issue_comments_240824.json:
```json
{
    "body": "<a id='comment:78'></a>\nHi Vincent,\n> And you are right, we have a big trouble as we can not loads/dumps `PseudoConwayLattice` in the way we would like them to be. It seems reasonable to me to keep the error on `x == loads(dumps(x))` and document it.\n\nI think this is the best solution.  Caching the pseudo-Conway lattice just moves the problem but does not fundamentally solve it, since PCL have the same property of not being determined up to unique isomorphism by their defining parameters.\n\nIf you want to implement this approach, go ahead.  You can try to simply do `git revert 48e0ffed` and fix the ensuing doctest failures.",
    "created_at": "2014-05-02T10:28:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240824",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:78'></a>
Hi Vincent,
> And you are right, we have a big trouble as we can not loads/dumps `PseudoConwayLattice` in the way we would like them to be. It seems reasonable to me to keep the error on `x == loads(dumps(x))` and document it.

I think this is the best solution.  Caching the pseudo-Conway lattice just moves the problem but does not fundamentally solve it, since PCL have the same property of not being determined up to unique isomorphism by their defining parameters.

If you want to implement this approach, go ahead.  You can try to simply do `git revert 48e0ffed` and fix the ensuing doctest failures.



---

archive/issue_events_049447.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14990#event-49447"
}
```



---

archive/issue_events_049448.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14990#event-49448"
}
```



---

archive/issue_comments_240825.json:
```json
{
    "body": "**Changing commit** from \"[f9162dbae92551a67aea7a489d96591141fdebc8](https://github.com/sagemath/sagetrac-mirror/commit/f9162dbae92551a67aea7a489d96591141fdebc8)\" to \"[fdd883792076e8cdb2b1ae7a15cfe28b36d653ca](https://github.com/sagemath/sagetrac-mirror/commit/fdd883792076e8cdb2b1ae7a15cfe28b36d653ca)\".",
    "created_at": "2014-05-12T13:56:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240825",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f9162dbae92551a67aea7a489d96591141fdebc8](https://github.com/sagemath/sagetrac-mirror/commit/f9162dbae92551a67aea7a489d96591141fdebc8)" to "[fdd883792076e8cdb2b1ae7a15cfe28b36d653ca](https://github.com/sagemath/sagetrac-mirror/commit/fdd883792076e8cdb2b1ae7a15cfe28b36d653ca)".



---

archive/issue_comments_240826.json:
```json
{
    "body": "<a id='comment:80'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ffd377f31b43ecb094863eef44a2936c9d28722d\">ffd377f</a></td><td><code>Revert \"Trac 14990: fix comparison of elements\"</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fdd883792076e8cdb2b1ae7a15cfe28b36d653ca\">fdd8837</a></td><td><code>Trac 14990: do not check pickling of elements in TestSuite, with explanation</code></td></tr></table>\n",
    "created_at": "2014-05-12T13:56:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240826",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:80'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ffd377f31b43ecb094863eef44a2936c9d28722d">ffd377f</a></td><td><code>Revert "Trac 14990: fix comparison of elements"</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fdd883792076e8cdb2b1ae7a15cfe28b36d653ca">fdd8837</a></td><td><code>Trac 14990: do not check pickling of elements in TestSuite, with explanation</code></td></tr></table>




---

archive/issue_comments_240827.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2014-05-12T14:01:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240827",
    "user": "https://github.com/pjbruin"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_240828.json:
```json
{
    "body": "<a id='comment:81'></a>\nSomeone asked me about this today, so I tried my suggestion from [comment:78](#comment%3A78).  At this moment the only thing that I'm not too sure about is if non-identical parents should be allowed to compare equal.  At this moment they compare equal if and only if their PCLs compare equal.  There is something to be said for the convention that two instances should be equal if and only if they are identical, but the current state of affairs does not seem to break anything, so we can also decide to leave it like it is.",
    "created_at": "2014-05-12T14:01:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240828",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:81'></a>
Someone asked me about this today, so I tried my suggestion from [comment:78](#comment%3A78).  At this moment the only thing that I'm not too sure about is if non-identical parents should be allowed to compare equal.  At this moment they compare equal if and only if their PCLs compare equal.  There is something to be said for the convention that two instances should be equal if and only if they are identical, but the current state of affairs does not seem to break anything, so we can also decide to leave it like it is.



---

archive/issue_comments_240829.json:
```json
{
    "body": "<a id='comment:82'></a>\nHi Peter,\n\nThank you.\n\n1) I found that your explanation is rather vague: it is not clear if you speak about mathematics or the Sage implementation. Moreover, this weirdness only concerns pseudo-Conway implementation (which is right now the only one). In a future, we might implement Jean-Pierre idea: deal with Conway polynomial or have a certified- non-random version of pseudo-Conway.\n\n2) It must absolutely be clear in the documentation of `.algebraic_closure` that the pickling is broken! This is the main entry point for users.\n\n3) Do you agree to add to the documentation the different weirdnesses I described in my comments ? (possibly in a TODO section)\n\nBest\nVincent",
    "created_at": "2014-05-12T15:40:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240829",
    "user": "https://github.com/videlec"
}
```

<a id='comment:82'></a>
Hi Peter,

Thank you.

1) I found that your explanation is rather vague: it is not clear if you speak about mathematics or the Sage implementation. Moreover, this weirdness only concerns pseudo-Conway implementation (which is right now the only one). In a future, we might implement Jean-Pierre idea: deal with Conway polynomial or have a certified- non-random version of pseudo-Conway.

2) It must absolutely be clear in the documentation of `.algebraic_closure` that the pickling is broken! This is the main entry point for users.

3) Do you agree to add to the documentation the different weirdnesses I described in my comments ? (possibly in a TODO section)

Best
Vincent



---

archive/issue_comments_240830.json:
```json
{
    "body": "<a id='comment:83'></a>\nHi Vincent,\n> 1) I found that your explanation is rather vague: it is not clear if you speak about mathematics or the Sage implementation.\n\nBoth: mathematically speaking, algebraic closures are not unique up to unique isomorphism unless you fix some standard model, and therefore we necessarily have a similar non-uniqueness in Sage reflecting this mathematical fact.  I tried to make clear how the mathematical fact influences the Sage implementation, but let me know if you have a concrete idea for improving this paragraph.\n> Moreover, this weirdness only concerns pseudo-Conway implementation (which is right now the only one).\n\nCertainly, that is why the new paragraph starts with \"In the current implementation\".\n> In a future, we might implement Jean-Pierre idea: deal with Conway polynomial or have a certified- non-random version of pseudo-Conway.\n\nOf course, but we are still in the present... 8-)\n\n(Actually, I'm sceptical about the possibility of defining \"certified-non-random version of pseudo-Conway\" in a way that would improve on the original Conway polynomials.  Besides, I would say that the \"idea\" of using Conway polynomials should be attributed to Conway!)\n> 2) It must absolutely be clear in the documentation of `.algebraic_closure` that the pickling is broken! This is the main entry point for users.\n\nOK, I'll add some explanation there too.  But I am against phrasing it as \"pickling is broken\"; we should really say that this is an inherent \"feature\" of the non-unicity of algebraic closures, at least until we support any standard model.\n> 3) Do you agree to add to the documentation the different weirdnesses I described in my comments ? (possibly in a TODO section)\n\nI don't see quickly which \"weirdnesses\" are still remaining, could you give me a list?",
    "created_at": "2014-05-12T16:21:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240830",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:83'></a>
Hi Vincent,
> 1) I found that your explanation is rather vague: it is not clear if you speak about mathematics or the Sage implementation.

Both: mathematically speaking, algebraic closures are not unique up to unique isomorphism unless you fix some standard model, and therefore we necessarily have a similar non-uniqueness in Sage reflecting this mathematical fact.  I tried to make clear how the mathematical fact influences the Sage implementation, but let me know if you have a concrete idea for improving this paragraph.
> Moreover, this weirdness only concerns pseudo-Conway implementation (which is right now the only one).

Certainly, that is why the new paragraph starts with "In the current implementation".
> In a future, we might implement Jean-Pierre idea: deal with Conway polynomial or have a certified- non-random version of pseudo-Conway.

Of course, but we are still in the present... 8-)

(Actually, I'm sceptical about the possibility of defining "certified-non-random version of pseudo-Conway" in a way that would improve on the original Conway polynomials.  Besides, I would say that the "idea" of using Conway polynomials should be attributed to Conway!)
> 2) It must absolutely be clear in the documentation of `.algebraic_closure` that the pickling is broken! This is the main entry point for users.

OK, I'll add some explanation there too.  But I am against phrasing it as "pickling is broken"; we should really say that this is an inherent "feature" of the non-unicity of algebraic closures, at least until we support any standard model.
> 3) Do you agree to add to the documentation the different weirdnesses I described in my comments ? (possibly in a TODO section)

I don't see quickly which "weirdnesses" are still remaining, could you give me a list?



---

archive/issue_comments_240831.json:
```json
{
    "body": "<a id='comment:84'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b1d4424ec179f4975a54a14993e4c842b3fb39f5\">b1d4424</a></td><td><code>Trac 14990: expand documentation of FiniteField_base.algebraic_closure()</code></td></tr></table>\n",
    "created_at": "2014-05-12T17:06:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240831",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:84'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b1d4424ec179f4975a54a14993e4c842b3fb39f5">b1d4424</a></td><td><code>Trac 14990: expand documentation of FiniteField_base.algebraic_closure()</code></td></tr></table>




---

archive/issue_comments_240832.json:
```json
{
    "body": "**Changing commit** from \"[fdd883792076e8cdb2b1ae7a15cfe28b36d653ca](https://github.com/sagemath/sagetrac-mirror/commit/fdd883792076e8cdb2b1ae7a15cfe28b36d653ca)\" to \"[b1d4424ec179f4975a54a14993e4c842b3fb39f5](https://github.com/sagemath/sagetrac-mirror/commit/b1d4424ec179f4975a54a14993e4c842b3fb39f5)\".",
    "created_at": "2014-05-12T17:06:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240832",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[fdd883792076e8cdb2b1ae7a15cfe28b36d653ca](https://github.com/sagemath/sagetrac-mirror/commit/fdd883792076e8cdb2b1ae7a15cfe28b36d653ca)" to "[b1d4424ec179f4975a54a14993e4c842b3fb39f5](https://github.com/sagemath/sagetrac-mirror/commit/b1d4424ec179f4975a54a14993e4c842b3fb39f5)".



---

archive/issue_comments_240833.json:
```json
{
    "body": "<a id='comment:85'></a>\nDear Peter,\n\nI like very much the documentation in `algebraic_closure`. Thank you.\n\nFor each problem below, I think we need to find a solution which might be: either write specifications in the documentation or provide a fix that change the behaviour.\n\n1) Equality among algebraic closures is not constant over time:\n\n```\nsage: F1 = AlgebraicClosureFiniteField(GF(3), 'z', use_database=False)\nsage: F2 = AlgebraicClosureFiniteField(GF(3), 'z', use_database=False)\nsage: F1 == F2\nTrue\nsage: F1.gen(3)\nz3\nsage: F1 == F2\nFalse\nsage: F2.gen(3)\nz3\nsage: F1 == F2\nTrue\n```\nIt becomes really weird when we play with pickling\n\n```\nsage: p = 100003\nsage: K = GF(p).algebraic_closure()\nsage: K2 = loads(dumps(K))\nsage: K.gen(3)\nz3\nsage: K == K2\nFalse\n```\nOne fix is to use identity in comparisons of the parent themselves as I suggested in previous comments. The only drawback I see is that `K == loads(dumps(K))` will be `False`. I think it would be safer that way.\n\n2) Get a very strange error from conversions between different algebraic closures that can be fixed introducing more type checking in the methods.\n\n```\nsage: from sage.rings.algebraic_closure_finite_field import AlgebraicClosureFiniteField\nsage: F1 = AlgebraicClosureFiniteField(GF(3), 'z')\nsage: F2 = AlgebraicClosureFiniteField(GF(3), 'z')\nsage: F1(F2.gen(1))\nTraceback (most recent call last):\n...\nTypeError: no canonical coercion from Algebraic closure of Finite Field of size 3 to Finite Field of size 3\n```\n\n3) (minor) The cache in `algebraic_closure` does not take into account the default arguments.\n\n```\nsage: K1 = GF(5).algebraic_closure(implementation='pseudo_conway', use_database=True)\nsage: K2 = GF(5).algebraic_closure(implementation='pseudo_conway')\nsage: K4 = GF(5).algebraic_closure()\nsage: K1 is K2 or K1 is K3 or K2 is K3\nFalse\n```\nOne fix is to move the cache at the level of `AlgebraicClosureFiniteField`, but on the other hand it is good to have the cache at a Cython level.\n\nThat's all\nVincent",
    "created_at": "2014-05-13T11:50:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240833",
    "user": "https://github.com/videlec"
}
```

<a id='comment:85'></a>
Dear Peter,

I like very much the documentation in `algebraic_closure`. Thank you.

For each problem below, I think we need to find a solution which might be: either write specifications in the documentation or provide a fix that change the behaviour.

1) Equality among algebraic closures is not constant over time:

```
sage: F1 = AlgebraicClosureFiniteField(GF(3), 'z', use_database=False)
sage: F2 = AlgebraicClosureFiniteField(GF(3), 'z', use_database=False)
sage: F1 == F2
True
sage: F1.gen(3)
z3
sage: F1 == F2
False
sage: F2.gen(3)
z3
sage: F1 == F2
True
```
It becomes really weird when we play with pickling

```
sage: p = 100003
sage: K = GF(p).algebraic_closure()
sage: K2 = loads(dumps(K))
sage: K.gen(3)
z3
sage: K == K2
False
```
One fix is to use identity in comparisons of the parent themselves as I suggested in previous comments. The only drawback I see is that `K == loads(dumps(K))` will be `False`. I think it would be safer that way.

2) Get a very strange error from conversions between different algebraic closures that can be fixed introducing more type checking in the methods.

```
sage: from sage.rings.algebraic_closure_finite_field import AlgebraicClosureFiniteField
sage: F1 = AlgebraicClosureFiniteField(GF(3), 'z')
sage: F2 = AlgebraicClosureFiniteField(GF(3), 'z')
sage: F1(F2.gen(1))
Traceback (most recent call last):
...
TypeError: no canonical coercion from Algebraic closure of Finite Field of size 3 to Finite Field of size 3
```

3) (minor) The cache in `algebraic_closure` does not take into account the default arguments.

```
sage: K1 = GF(5).algebraic_closure(implementation='pseudo_conway', use_database=True)
sage: K2 = GF(5).algebraic_closure(implementation='pseudo_conway')
sage: K4 = GF(5).algebraic_closure()
sage: K1 is K2 or K1 is K3 or K2 is K3
False
```
One fix is to move the cache at the level of `AlgebraicClosureFiniteField`, but on the other hand it is good to have the cache at a Cython level.

That's all
Vincent



---

archive/issue_comments_240834.json:
```json
{
    "body": "<a id='comment:86'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4ac10fb0702a315e64755fd9df0e929e1d26ac1a\">4ac10fb</a></td><td><code>Trac 14990: compare pseudo-Conway algebraic closures by ID</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/63bc7aa3b23e6d7dc4db54de76c60b24134e7895\">63bc7aa</a></td><td><code>Trac 14990: more informative error message in _element_constructor_()</code></td></tr></table>\n",
    "created_at": "2014-05-13T13:43:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240834",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:86'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4ac10fb0702a315e64755fd9df0e929e1d26ac1a">4ac10fb</a></td><td><code>Trac 14990: compare pseudo-Conway algebraic closures by ID</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/63bc7aa3b23e6d7dc4db54de76c60b24134e7895">63bc7aa</a></td><td><code>Trac 14990: more informative error message in _element_constructor_()</code></td></tr></table>




---

archive/issue_comments_240835.json:
```json
{
    "body": "**Changing commit** from \"[b1d4424ec179f4975a54a14993e4c842b3fb39f5](https://github.com/sagemath/sagetrac-mirror/commit/b1d4424ec179f4975a54a14993e4c842b3fb39f5)\" to \"[63bc7aa3b23e6d7dc4db54de76c60b24134e7895](https://github.com/sagemath/sagetrac-mirror/commit/63bc7aa3b23e6d7dc4db54de76c60b24134e7895)\".",
    "created_at": "2014-05-13T13:43:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240835",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[b1d4424ec179f4975a54a14993e4c842b3fb39f5](https://github.com/sagemath/sagetrac-mirror/commit/b1d4424ec179f4975a54a14993e4c842b3fb39f5)" to "[63bc7aa3b23e6d7dc4db54de76c60b24134e7895](https://github.com/sagemath/sagetrac-mirror/commit/63bc7aa3b23e6d7dc4db54de76c60b24134e7895)".



---

archive/issue_comments_240836.json:
```json
{
    "body": "<a id='comment:87'></a>\nThanks for your feedback, Vincent!  The two new commits should address your points (1) and (2), respectively.  As for (3), I thought about moving the cache to `AlgebraicClosureFiniteField`, but then we would have to be very careful with weak references to make sure we don't store every algebraic closure forever.  Another (ugly) solution would be to duplicate the same default arguments everywhere.  I think it is not really worth the trouble, especially because the following does work:\n\n```\nsage: GF(5).algebraic_closure('z') is GF(5).algebraic_closure()\nTrue\n```\nI expect it is much more likely that users switch between specifying the 'z' or not than that they switch between specifying keyword arguments or not.",
    "created_at": "2014-05-13T13:49:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240836",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:87'></a>
Thanks for your feedback, Vincent!  The two new commits should address your points (1) and (2), respectively.  As for (3), I thought about moving the cache to `AlgebraicClosureFiniteField`, but then we would have to be very careful with weak references to make sure we don't store every algebraic closure forever.  Another (ugly) solution would be to duplicate the same default arguments everywhere.  I think it is not really worth the trouble, especially because the following does work:

```
sage: GF(5).algebraic_closure('z') is GF(5).algebraic_closure()
True
```
I expect it is much more likely that users switch between specifying the 'z' or not than that they switch between specifying keyword arguments or not.



---

archive/issue_comments_240837.json:
```json
{
    "body": "<a id='comment:88'></a>\nHi Peter,\n\nI agree with your analysis of (3).\n\nAll test pass and the documentation builds.\n\nThere is a typo which becomes ugly in the compiled documentation. At line 960 of `algebraic_closure_finite_field.py` you wrote <code>\\`:meth:~sage.rings.finite_rings.finite_field_base.FiniteField.algebraic_closure\\`</code> instead of <code>:meth:\\`~sage.rings.finite_rings.finite_field_base.FiniteField.algebraic_closure\\`</code>.\n\nOnce the change done, you can set to positive review.\n\nVincent",
    "created_at": "2014-05-14T05:14:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240837",
    "user": "https://github.com/videlec"
}
```

<a id='comment:88'></a>
Hi Peter,

I agree with your analysis of (3).

All test pass and the documentation builds.

There is a typo which becomes ugly in the compiled documentation. At line 960 of `algebraic_closure_finite_field.py` you wrote <code>\`:meth:~sage.rings.finite_rings.finite_field_base.FiniteField.algebraic_closure\`</code> instead of <code>:meth:\`~sage.rings.finite_rings.finite_field_base.FiniteField.algebraic_closure\`</code>.

Once the change done, you can set to positive review.

Vincent



---

archive/issue_comments_240838.json:
```json
{
    "body": "**Changing commit** from \"[63bc7aa3b23e6d7dc4db54de76c60b24134e7895](https://github.com/sagemath/sagetrac-mirror/commit/63bc7aa3b23e6d7dc4db54de76c60b24134e7895)\" to \"[b0e1539b899af271fb16dcc6dadfaa7e567620b9](https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9)\".",
    "created_at": "2014-05-14T07:58:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240838",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[63bc7aa3b23e6d7dc4db54de76c60b24134e7895](https://github.com/sagemath/sagetrac-mirror/commit/63bc7aa3b23e6d7dc4db54de76c60b24134e7895)" to "[b0e1539b899af271fb16dcc6dadfaa7e567620b9](https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9)".



---

archive/issue_comments_240839.json:
```json
{
    "body": "<a id='comment:89'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9\">b0e1539</a></td><td><code>Trac 14990: fix typo in documentation</code></td></tr></table>\n",
    "created_at": "2014-05-14T07:58:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240839",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:89'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9">b0e1539</a></td><td><code>Trac 14990: fix typo in documentation</code></td></tr></table>




---

archive/issue_comments_240840.json:
```json
{
    "body": "**Reviewer:** Vincent Delecroix",
    "created_at": "2014-05-14T08:01:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240840",
    "user": "https://github.com/pjbruin"
}
```

**Reviewer:** Vincent Delecroix



---

archive/issue_comments_240841.json:
```json
{
    "body": "**Changing status** from needs_review to positive_review.",
    "created_at": "2014-05-14T08:01:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240841",
    "user": "https://github.com/pjbruin"
}
```

**Changing status** from needs_review to positive_review.



---

archive/issue_comments_240842.json:
```json
{
    "body": "<a id='comment:90'></a>\nDone.  Thanks a lot for your thorough review!",
    "created_at": "2014-05-14T08:01:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240842",
    "user": "https://github.com/pjbruin"
}
```

<a id='comment:90'></a>
Done.  Thanks a lot for your thorough review!



---

archive/issue_events_049449.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-05-15T17:18:32Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14990#event-49449"
}
```



---

archive/issue_comments_240843.json:
```json
{
    "body": "**Changing branch** from \"[u/pbruin/14990](https://github.com/sagemath/sagetrac-mirror/tree/u/pbruin/14990)\" to \"[b0e1539b899af271fb16dcc6dadfaa7e567620b9](https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9)\".",
    "created_at": "2014-05-15T17:18:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240843",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[u/pbruin/14990](https://github.com/sagemath/sagetrac-mirror/tree/u/pbruin/14990)" to "[b0e1539b899af271fb16dcc6dadfaa7e567620b9](https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9)".



---

archive/issue_comments_240844.json:
```json
{
    "body": "**Resolution:** fixed",
    "created_at": "2014-05-15T17:18:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240844",
    "user": "https://github.com/vbraun"
}
```

**Resolution:** fixed



---

archive/issue_comments_240845.json:
```json
{
    "body": "**Changing commit** from \"[b0e1539b899af271fb16dcc6dadfaa7e567620b9](https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9)\" to \"\".",
    "created_at": "2014-09-16T17:23:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240845",
    "user": "https://github.com/slel"
}
```

**Changing commit** from "[b0e1539b899af271fb16dcc6dadfaa7e567620b9](https://github.com/sagemath/sagetrac-mirror/commit/b0e1539b899af271fb16dcc6dadfaa7e567620b9)" to "".



---

archive/issue_comments_240846.json:
```json
{
    "body": "<a id='comment:92'></a>\nSome change introduced by this ticket is being discussed in [this sage-devel thread](https://groups.google.com/d/topic/sage-devel/JgB6p9eu970/discussion).",
    "created_at": "2014-09-16T17:23:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240846",
    "user": "https://github.com/slel"
}
```

<a id='comment:92'></a>
Some change introduced by this ticket is being discussed in [this sage-devel thread](https://groups.google.com/d/topic/sage-devel/JgB6p9eu970/discussion).



---

archive/issue_comments_240847.json:
```json
{
    "body": "<a id='comment:93'></a>\nfor information, Pari/GP 2.10 implements finite field embeddings.\nSee http://pari.math.u-bordeaux.fr/Events/PARI2018/talks/features.pdf",
    "created_at": "2018-01-15T09:57:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240847",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:93'></a>
for information, Pari/GP 2.10 implements finite field embeddings.
See http://pari.math.u-bordeaux.fr/Events/PARI2018/talks/features.pdf



---

archive/issue_comments_240848.json:
```json
{
    "body": "<a id='comment:94'></a>\nFlint will soon have them too. See https://github.com/wbhart/flint2/pull/351.\n\nAre the embeddings in PARI/GP compatible?",
    "created_at": "2018-01-15T10:15:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240848",
    "user": "https://github.com/defeo"
}
```

<a id='comment:94'></a>
Flint will soon have them too. See https://github.com/wbhart/flint2/pull/351.

Are the embeddings in PARI/GP compatible?



---

archive/issue_comments_240849.json:
```json
{
    "body": "<a id='comment:95'></a>\nWould be nice to have both of them interfaced in Sage together with the version that is already there!",
    "created_at": "2018-01-15T16:08:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240849",
    "user": "https://github.com/videlec"
}
```

<a id='comment:95'></a>
Would be nice to have both of them interfaced in Sage together with the version that is already there!



---

archive/issue_comments_240850.json:
```json
{
    "body": "<a id='comment:96'></a>\nReplying to [vdelecroix](#comment%3A95):\n> Would be nice to have both of them interfaced in Sage together with the version that is already there!\n\n\nThat's part of our plans. Not immediately, though.",
    "created_at": "2018-01-15T16:15:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14990",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14990#issuecomment-240850",
    "user": "https://github.com/defeo"
}
```

<a id='comment:96'></a>
Replying to [vdelecroix](#comment%3A95):
> Would be nice to have both of them interfaced in Sage together with the version that is already there!


That's part of our plans. Not immediately, though.
