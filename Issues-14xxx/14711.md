# Issue 14711: Weak references in the coercion graph

archive/issues_014507.json:
```json
{
    "body": "The following quickly eats up memory:\n\n```\nsage: for D in xrange(2,2**32):\n....:     QuadraticField(-D);\n....:\n```\n(This is with 5.10.rc0)\n\n__Problem analysis__\n\nThe quadratic field is created with a coerce embedding into `CLF`. At the same\ntime, this coerce embedding is stored in `CLF._coerce_from_hash`:\n\n```\nsage: phi = CLF.coerce_map_from(Q)\nsage: phi is Q.coerce_embedding()\nTrue\nsage: Q in CLF._introspect_coerce()['_coerce_from_hash']\nTrue\n```\nThe \"coerce_from_hash\" is a `MonoDict`, hence, has only a weak reference to the key\n(Q, in this case). However, there still is a *strong* reference from\nCLF to the coerce map phi. And phi has a strong reference to its\ndomain, thus, to Q. Hence, the existence of CLF prevents garbage collection of\nQ.\n\nAnd there is a second chain of strong references from CLF to Q: From CLF to\nphi to the parent of phi (i.e., a homset) to the domain Q of this homset.\n\n__Suggested solution__\n\nWe can not turn the reference from CLF to phi into a weak reference, because\nthen even a strong reference to Q would not prevent phi from garbage\ncollection. Hence, we need to break the above mentioned reference chains in\ntwo points. In the attached branch, maps generally keep a strong reference to\nthe codomain (this is important in composite maps and actions), but those used\n*in the coercion system* (and *only* there!!) will only have a weak\nreference to the domain, and they set the cdef `._parent` attribute to `None`\n(hence, we also override `.parent()`, so that it reconstructs the homset if\nthe weak reference to the domain is still valid).\n\nTo preserve the `domain()/codomain()` interface, I have removed the method\n`domain()` and have replaced it by a cdef public attribute that will either\nhold a weak reference (which returns the domain when called, hence, the\ninterface does not change) or a `ConstantFunction` (which should actually be\nfaster to call than a method). Since accessing a cdef attribute is still\nfaster, the cdef attribute `_codomain` is kept (since this will always be a\nstrong reference), but `_domain` has been removed.\n\nThis \"weakening of references\" is done for the coercions found by\n`discover_coerce_map_from()` stored into `_coerce_from_hash`. So, this mainly\nhappens for things done with `_coerce_map_from_()` and with composite\nmaps. Similarly for `_convert_from_hash`.\n\nWeakening is *not* used on the maps that are explicitly registered by\n`.register_embedding()` and `.register_coercion()`. This is in order to\npreserve the connectivity of the coercion graph. The `register_*` methods\nare only used on selected maps, that are of particular importance for the\nbacktrack search in `discover_coerce_map_from()`. These *strong*\nregistrations do not propagate: Compositions of strongly registered\ncoercions found by `discover_coerce_map_from()` will be weakened.\n\nSince weakened maps should not be used outside of the coercion system, its\nstring representation shows a warning to replace them by a copy. The attached\nbranch implements copying of maps in some additional cases.\n\n`SchemeMorphism` can not inherit from `Morphism`, because of a bug with\nmultiple inheritance of a Python class from Cython extension classes. But once\nthis bug is fixed, we surely want to make `SchemeMorphism` inherit from\n`Morphism`. This transition is prepared here.\n\nWeakened maps should only be used in the coercion system: A weakened map can become invalid by garbage collection, and the coercion system has the job to remove a map from the coercion cache as soon as it becomes invalid.\n\nMaps outside of the coercion system should be safe against invalidation. Hence, when we take a coerce map, then we should better create a non-weakened copy. The branch also provides copying (and pickling) for *all* kinds of maps and morphisms (hopefully no map/morphism class went unnoticed).\n\nIn any case, the commit messages should give a concise description of what has\nbeen done.\n\n**__TODO in future tickets__**\n\n- Provide a documentation of the use of weak references in coercion, and of\n  different ways of registering coercions, with their different impacts on\n  garbage collecion.\n- Provide a version of `.register_coercion()` that weakens the coercion\n  map. It would hence have the same effect as returning a map by\n  `._coerce_map_from_()`, but of course `._coerce_map_from()` could not easily\n  be changed in an interactive session.\n\n**__Effects on the overall functioning of Sage__**\n\nIt is conceivable that some parts of Sage still suppose implicitly that stuff\ncached with `UniqueRepresentation` is *permanently* cached, even though the\nseemingly permanent cache was not more than a consequence of a memory leak in\nthe coercion system. With the attached branch, garbage collection of parent\nstructures will much more often become possible. Hence, code that relied on a\nfake-permanent cache would now need to create the same parent repeatedly.\n\nI (Simon) have tested how many additional parent creations occur with the\nattached branch when running `sage -t --all`. The findings are summarised in\ncomment:107: The number of additional parent creations increased by not more\nthan 1% for all but two parent classes (both related with tableaux). I also\nfound that the time to run the tests did not significantly increase.\n\nJean-Pierre has occasionally stated that some of his computations have been\ninfeasible with the memory leak in the above example. I hope that his\ncomputations will now succeed.\n\n\n**Assignee:** @loefflerd\n\n**CC:**  @simon-king-jena @nbruin @nthiery @anneschilling @zabrocki\n\n**Keywords:** memleak, number field, QuadraticField\n\n**Branch:** [00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7](https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7)\n\n**Reviewer:** Nils Bruin, Jean-Pierre Flori\n\n**Author:** Simon King, Travis Scrimshaw, Jean-Pierre Flori\n\nIssue created by migration from https://trac.sagemath.org/ticket/14711\n\n",
    "closed_at": "2014-04-05T10:43:50Z",
    "created_at": "2013-06-10T09:49:00Z",
    "labels": [
        "component: number fields",
        "critical",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.2",
    "title": "Weak references in the coercion graph",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/14711",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```
The following quickly eats up memory:

```
sage: for D in xrange(2,2**32):
....:     QuadraticField(-D);
....:
```
(This is with 5.10.rc0)

__Problem analysis__

The quadratic field is created with a coerce embedding into `CLF`. At the same
time, this coerce embedding is stored in `CLF._coerce_from_hash`:

```
sage: phi = CLF.coerce_map_from(Q)
sage: phi is Q.coerce_embedding()
True
sage: Q in CLF._introspect_coerce()['_coerce_from_hash']
True
```
The "coerce_from_hash" is a `MonoDict`, hence, has only a weak reference to the key
(Q, in this case). However, there still is a *strong* reference from
CLF to the coerce map phi. And phi has a strong reference to its
domain, thus, to Q. Hence, the existence of CLF prevents garbage collection of
Q.

And there is a second chain of strong references from CLF to Q: From CLF to
phi to the parent of phi (i.e., a homset) to the domain Q of this homset.

__Suggested solution__

We can not turn the reference from CLF to phi into a weak reference, because
then even a strong reference to Q would not prevent phi from garbage
collection. Hence, we need to break the above mentioned reference chains in
two points. In the attached branch, maps generally keep a strong reference to
the codomain (this is important in composite maps and actions), but those used
*in the coercion system* (and *only* there!!) will only have a weak
reference to the domain, and they set the cdef `._parent` attribute to `None`
(hence, we also override `.parent()`, so that it reconstructs the homset if
the weak reference to the domain is still valid).

To preserve the `domain()/codomain()` interface, I have removed the method
`domain()` and have replaced it by a cdef public attribute that will either
hold a weak reference (which returns the domain when called, hence, the
interface does not change) or a `ConstantFunction` (which should actually be
faster to call than a method). Since accessing a cdef attribute is still
faster, the cdef attribute `_codomain` is kept (since this will always be a
strong reference), but `_domain` has been removed.

This "weakening of references" is done for the coercions found by
`discover_coerce_map_from()` stored into `_coerce_from_hash`. So, this mainly
happens for things done with `_coerce_map_from_()` and with composite
maps. Similarly for `_convert_from_hash`.

Weakening is *not* used on the maps that are explicitly registered by
`.register_embedding()` and `.register_coercion()`. This is in order to
preserve the connectivity of the coercion graph. The `register_*` methods
are only used on selected maps, that are of particular importance for the
backtrack search in `discover_coerce_map_from()`. These *strong*
registrations do not propagate: Compositions of strongly registered
coercions found by `discover_coerce_map_from()` will be weakened.

Since weakened maps should not be used outside of the coercion system, its
string representation shows a warning to replace them by a copy. The attached
branch implements copying of maps in some additional cases.

`SchemeMorphism` can not inherit from `Morphism`, because of a bug with
multiple inheritance of a Python class from Cython extension classes. But once
this bug is fixed, we surely want to make `SchemeMorphism` inherit from
`Morphism`. This transition is prepared here.

Weakened maps should only be used in the coercion system: A weakened map can become invalid by garbage collection, and the coercion system has the job to remove a map from the coercion cache as soon as it becomes invalid.

Maps outside of the coercion system should be safe against invalidation. Hence, when we take a coerce map, then we should better create a non-weakened copy. The branch also provides copying (and pickling) for *all* kinds of maps and morphisms (hopefully no map/morphism class went unnoticed).

In any case, the commit messages should give a concise description of what has
been done.

**__TODO in future tickets__**

- Provide a documentation of the use of weak references in coercion, and of
  different ways of registering coercions, with their different impacts on
  garbage collecion.
- Provide a version of `.register_coercion()` that weakens the coercion
  map. It would hence have the same effect as returning a map by
  `._coerce_map_from_()`, but of course `._coerce_map_from()` could not easily
  be changed in an interactive session.

**__Effects on the overall functioning of Sage__**

It is conceivable that some parts of Sage still suppose implicitly that stuff
cached with `UniqueRepresentation` is *permanently* cached, even though the
seemingly permanent cache was not more than a consequence of a memory leak in
the coercion system. With the attached branch, garbage collection of parent
structures will much more often become possible. Hence, code that relied on a
fake-permanent cache would now need to create the same parent repeatedly.

I (Simon) have tested how many additional parent creations occur with the
attached branch when running `sage -t --all`. The findings are summarised in
comment:107: The number of additional parent creations increased by not more
than 1% for all but two parent classes (both related with tableaux). I also
found that the time to run the tests did not significantly increase.

Jean-Pierre has occasionally stated that some of his computations have been
infeasible with the memory leak in the above example. I hope that his
computations will now succeed.


**Assignee:** @loefflerd

**CC:**  @simon-king-jena @nbruin @nthiery @anneschilling @zabrocki

**Keywords:** memleak, number field, QuadraticField

**Branch:** [00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7](https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7)

**Reviewer:** Nils Bruin, Jean-Pierre Flori

**Author:** Simon King, Travis Scrimshaw, Jean-Pierre Flori

Issue created by migration from https://trac.sagemath.org/ticket/14711





---

archive/issue_comments_181409.json:
```json
{
    "body": "<a id='comment:1'></a>\nIn number_field.py:\n\n```\nQuadratic number fields are cached::\n```\nI guess they should be only weakly cached.",
    "created_at": "2013-06-10T09:52:41Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181409",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:1'></a>
In number_field.py:

```
Quadratic number fields are cached::
```
I guess they should be only weakly cached.



---

archive/issue_comments_181410.json:
```json
{
    "body": "<a id='comment:2'></a>\nI think at some point I tried to use `UniqueRepresentation` for the quadratic number fields (which would be enough to have a weak cache). However, this turned out to open a can of worms in all the number theory and elliptic curve code, if I recall correctly.",
    "created_at": "2013-06-10T09:58:34Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181410",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
I think at some point I tried to use `UniqueRepresentation` for the quadratic number fields (which would be enough to have a weak cache). However, this turned out to open a can of worms in all the number theory and elliptic curve code, if I recall correctly.



---

archive/issue_comments_181411.json:
```json
{
    "body": "<a id='comment:3'></a>\nThere is a cache option to the NumberField constructor, maybe I can live with that, not sure it is a good default behavior though.",
    "created_at": "2013-06-10T09:59:56Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181411",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:3'></a>
There is a cache option to the NumberField constructor, maybe I can live with that, not sure it is a good default behavior though.



---

archive/issue_comments_181412.json:
```json
{
    "body": "<a id='comment:4'></a>\nAnd trying\n\n```\nQuadraticField(-D, cache=False)\n```\ndoes not solve the problem anyway.",
    "created_at": "2013-06-10T10:04:35Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181412",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:4'></a>
And trying

```
QuadraticField(-D, cache=False)
```
does not solve the problem anyway.



---

archive/issue_comments_181413.json:
```json
{
    "body": "<a id='comment:5'></a>\nAfter a quick look (and apart from _nf_cache and _cyclo_cache in number_field.py), the culprit might be ComplexDoubleField doing too much caching of embeddings.",
    "created_at": "2013-06-10T10:13:16Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181413",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:5'></a>
After a quick look (and apart from _nf_cache and _cyclo_cache in number_field.py), the culprit might be ComplexDoubleField doing too much caching of embeddings.



---

archive/issue_comments_181414.json:
```json
{
    "body": "<a id='comment:6'></a>\nIndeed, there is a map created at initialization and stored in CDF/RDF's \"_convert_from_list\" which is a Python list so gives in the end a strong ref to the number field.",
    "created_at": "2013-06-10T16:03:41Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181414",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:6'></a>
Indeed, there is a map created at initialization and stored in CDF/RDF's "_convert_from_list" which is a Python list so gives in the end a strong ref to the number field.



---

archive/issue_comments_181415.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [jpflori](#comment%3A6):\n> Indeed, there is a map created at initialization and stored in CDF/RDF's \"_convert_from_list\" which is a Python list so gives in the end a strong ref to the number field.\n\nAh, yes, that's bad. If I recall correctly, default embeddings are (currently) stored by strong reference via an attribute of the codomain, and if this codomain is immortal, the domain will be immortal as well.\n\nI am afraid that this week I will have no capacity to work on it or do reviews. There might be a chance during the upcoming Sage days in Orsay.",
    "created_at": "2013-06-11T09:55:26Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181415",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Replying to [jpflori](#comment%3A6):
> Indeed, there is a map created at initialization and stored in CDF/RDF's "_convert_from_list" which is a Python list so gives in the end a strong ref to the number field.

Ah, yes, that's bad. If I recall correctly, default embeddings are (currently) stored by strong reference via an attribute of the codomain, and if this codomain is immortal, the domain will be immortal as well.

I am afraid that this week I will have no capacity to work on it or do reviews. There might be a chance during the upcoming Sage days in Orsay.



---

archive/issue_comments_181416.json:
```json
{
    "body": "<a id='comment:8'></a>\nIn the coercion model, a first step is to remove the addition of the newly created morphism to _convert_from_list, and only add it to _convert_from_hash (except in the register_conversion function).\n(Note that this is the current behavior for \"coerce\" maps, they are only added to _coerce_from_hash, not _coerce_from_list, except within the register_coercion function).\n\nNot sure if these two *_from_list lists have any real use?\n\nBut that's not enough anyway (although it removes one eternal strong reference), surely something like what you just posted.\n\nI'll try to attend something like one to three half days of the Sage Days, first guess is Wednesday afternoon, surely another half day on Tuesday.\nHopefully we can tackle this together.",
    "created_at": "2013-06-11T10:01:29Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181416",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:8'></a>
In the coercion model, a first step is to remove the addition of the newly created morphism to _convert_from_list, and only add it to _convert_from_hash (except in the register_conversion function).
(Note that this is the current behavior for "coerce" maps, they are only added to _coerce_from_hash, not _coerce_from_list, except within the register_coercion function).

Not sure if these two *_from_list lists have any real use?

But that's not enough anyway (although it removes one eternal strong reference), surely something like what you just posted.

I'll try to attend something like one to three half days of the Sage Days, first guess is Wednesday afternoon, surely another half day on Tuesday.
Hopefully we can tackle this together.



---

archive/issue_comments_181417.json:
```json
{
    "body": "<a id='comment:9'></a>\nSee https://github.com/sagemath/sage/issues/8335#comment:69 for another incarnation of this problem but with finite fields.",
    "created_at": "2013-06-20T17:25:51Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181417",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:9'></a>
See https://github.com/sagemath/sage/issues/8335#comment:69 for another incarnation of this problem but with finite fields.



---

archive/issue_events_128583.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:34:36Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "milestone": "sage-5.11",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128583"
}
```



---

archive/issue_events_128584.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:34:36Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128584"
}
```



---

archive/issue_comments_181418.json:
```json
{
    "body": "<a id='comment:11'></a>\nBumping Simon as requested.",
    "created_at": "2013-09-24T11:42:42Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181418",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:11'></a>
Bumping Simon as requested.



---

archive/issue_comments_181419.json:
```json
{
    "body": "<a id='comment:12'></a>\nI really wonder why the quadratic number field is put into `CDF._convert_from_list`. Is it perhaps in `Parent.convert_map_from()`?\n\nNamely, if a look-up in `_convert_from_hash` fails, then not only the `_convert_from_hash` gets updated, but also `_convert_from_list`:\n\n```\n        try:\n            return self._convert_from_hash.get(S)\n        except KeyError:\n            mor = self.discover_convert_map_from(S)\n            self._convert_from_list.append(mor)\n            self._convert_from_hash.set(S, mor)\n            return mor\n```\n\nBut why would this be done? Note that `_coerce_from_list` is *not* updated when calling `Parent.coerce_map_from()`!!! So, this looks like an oversight to me. I hope it is, because then we would not need to mess around with yet another weak reference game.",
    "created_at": "2013-09-28T21:37:13Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181419",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:12'></a>
I really wonder why the quadratic number field is put into `CDF._convert_from_list`. Is it perhaps in `Parent.convert_map_from()`?

Namely, if a look-up in `_convert_from_hash` fails, then not only the `_convert_from_hash` gets updated, but also `_convert_from_list`:

```
        try:
            return self._convert_from_hash.get(S)
        except KeyError:
            mor = self.discover_convert_map_from(S)
            self._convert_from_list.append(mor)
            self._convert_from_hash.set(S, mor)
            return mor
```

But why would this be done? Note that `_coerce_from_list` is *not* updated when calling `Parent.coerce_map_from()`!!! So, this looks like an oversight to me. I hope it is, because then we would not need to mess around with yet another weak reference game.



---

archive/issue_comments_181420.json:
```json
{
    "body": "<a id='comment:13'></a>\nI always thought of `_coerce_from_list` as a way to store *some* coercions (namely those explicitly registered during `__init__`) permanently, but all other coercions should only be weakly cached, in `_coerce_from_hash`.\n\nAnd I think `_convert_from_list` should have exactly the same r\u00f4le. I suggest to use `_convert_from_list` only in `Parent.register_conversion()` and nowhere else. This would be analogous to how we deal with `_coerce_from_list`.",
    "created_at": "2013-09-28T21:43:40Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181420",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:13'></a>
I always thought of `_coerce_from_list` as a way to store *some* coercions (namely those explicitly registered during `__init__`) permanently, but all other coercions should only be weakly cached, in `_coerce_from_hash`.

And I think `_convert_from_list` should have exactly the same rôle. I suggest to use `_convert_from_list` only in `Parent.register_conversion()` and nowhere else. This would be analogous to how we deal with `_coerce_from_list`.



---

archive/issue_comments_181421.json:
```json
{
    "body": "<a id='comment:14'></a>\nUnfortunately, this easy change is not enough. I still get\n\n```\nsage: Q = QuadraticField(-3)\nsage: import gc\nsage: gc.collect()\n524\nsage: C = Q.__class__.__base__\nsage: len([x for x in gc.get_objects() if isinstance(x, C)])\n3\nsage: del Q\nsage: gc.collect()\n0\nsage: len([x for x in gc.get_objects() if isinstance(x, C)])\n3\nsage: Q = QuadraticField(-5)\nsage: len([x for x in gc.get_objects() if isinstance(x, C)])\n4\nsage: del Q\nsage: gc.collect()\n398\nsage: len([x for x in gc.get_objects() if isinstance(x, C)])\n4\n```\n\nBut if I recall correctly, there is further strong caching done for number fields.",
    "created_at": "2013-09-28T21:47:58Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181421",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>
Unfortunately, this easy change is not enough. I still get

```
sage: Q = QuadraticField(-3)
sage: import gc
sage: gc.collect()
524
sage: C = Q.__class__.__base__
sage: len([x for x in gc.get_objects() if isinstance(x, C)])
3
sage: del Q
sage: gc.collect()
0
sage: len([x for x in gc.get_objects() if isinstance(x, C)])
3
sage: Q = QuadraticField(-5)
sage: len([x for x in gc.get_objects() if isinstance(x, C)])
4
sage: del Q
sage: gc.collect()
398
sage: len([x for x in gc.get_objects() if isinstance(x, C)])
4
```

But if I recall correctly, there is further strong caching done for number fields.



---

archive/issue_comments_181422.json:
```json
{
    "body": "<a id='comment:15'></a>\nSure, there is.\nSee [#14711 comment:4](https://github.com/sagemath/sage/issues/14711#comment:4), though I don't really remember if that was enough to disable all the number field caching stuff.",
    "created_at": "2013-09-28T21:51:00Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181422",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:15'></a>
Sure, there is.
See [#14711 comment:4](https://github.com/sagemath/sage/issues/14711#comment:4), though I don't really remember if that was enough to disable all the number field caching stuff.



---

archive/issue_comments_181423.json:
```json
{
    "body": "<a id='comment:16'></a>\nReplying to [SimonKing](#comment%3A14):\n> But if I recall correctly, there is further strong caching done for number fields.\n\nI stand corrected. There is `sage.rings.number_field.number_field._nf_cache`, which is a dictionary. But apparently it does use weak references to the values.\n\nHowever, I don't see why one shouldn't use a `WeakValueDictionary` instead.",
    "created_at": "2013-09-28T21:54:23Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181423",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:16'></a>
Replying to [SimonKing](#comment%3A14):
> But if I recall correctly, there is further strong caching done for number fields.

I stand corrected. There is `sage.rings.number_field.number_field._nf_cache`, which is a dictionary. But apparently it does use weak references to the values.

However, I don't see why one shouldn't use a `WeakValueDictionary` instead.



---

archive/issue_comments_181424.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [SimonKing](#comment%3A16):\n> Replying to [SimonKing](#comment%3A14):\n> > But if I recall correctly, there is further strong caching done for number fields.\n\n> \n> I stand corrected. There is `sage.rings.number_field.number_field._nf_cache`, which is a dictionary. But apparently it does use weak references to the values.\n> \n> However, I don't see why one shouldn't use a `WeakValueDictionary` instead.\n\nMe neither, unless someone has the habit to play frequently with the same number field but without keeping any of its elements alive between different uses, personally I don't and would not really see the point.\n\nIf we switch to a weak value dict, we could also get rid of the cache argument of the constructor then which won't be that useful/sensible anymore.",
    "created_at": "2013-09-28T21:58:28Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181424",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:17'></a>
Replying to [SimonKing](#comment%3A16):
> Replying to [SimonKing](#comment%3A14):
> > But if I recall correctly, there is further strong caching done for number fields.

> 
> I stand corrected. There is `sage.rings.number_field.number_field._nf_cache`, which is a dictionary. But apparently it does use weak references to the values.
> 
> However, I don't see why one shouldn't use a `WeakValueDictionary` instead.

Me neither, unless someone has the habit to play frequently with the same number field but without keeping any of its elements alive between different uses, personally I don't and would not really see the point.

If we switch to a weak value dict, we could also get rid of the cache argument of the constructor then which won't be that useful/sensible anymore.



---

archive/issue_comments_181425.json:
```json
{
    "body": "<a id='comment:18'></a>\nClearing this cache doesn't help anyway:\n\n```\nsage: Q = QuadraticField(-3)\nsage: import weakref\nsage: import gc\nsage: gc.collect()\n524\nsage: C = Q.__class__.__base__\nsage: len([x for x in gc.get_objects() if isinstance(x, C)])\n3\nsage: del Q\nsage: gc.collect()\n0\nsage: len([x for x in gc.get_objects() if isinstance(x, C)])\n3\nsage: sage.rings.number_field.number_field._nf_cache.clear()\nsage: gc.collect()\n0\nsage: len([x for x in gc.get_objects() if isinstance(x, C)])\n3\n```\nEven worse, with the change proposed above, one actually has an empty `_convert_from_list` for CDF, but nevertheless the quadratic number field does not want to die:\n\n```\nsage: CDF._introspect_coerce()\n{'_action_hash': <sage.structure.coerce_dict.TripleDict at 0x95264c4>,\n '_action_list': [],\n '_coerce_from_hash': <sage.structure.coerce_dict.MonoDict at 0x952656c>,\n '_coerce_from_list': [],\n '_convert_from_hash': <sage.structure.coerce_dict.MonoDict at 0x9526534>,\n '_convert_from_list': [],\n '_element_init_pass_parent': False,\n '_embedding': None,\n '_initial_action_list': [],\n '_initial_coerce_list': [],\n '_initial_convert_list': []}\n```\n\nHence, there must be another strong reference somewhere.",
    "created_at": "2013-09-28T21:58:47Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181425",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'></a>
Clearing this cache doesn't help anyway:

```
sage: Q = QuadraticField(-3)
sage: import weakref
sage: import gc
sage: gc.collect()
524
sage: C = Q.__class__.__base__
sage: len([x for x in gc.get_objects() if isinstance(x, C)])
3
sage: del Q
sage: gc.collect()
0
sage: len([x for x in gc.get_objects() if isinstance(x, C)])
3
sage: sage.rings.number_field.number_field._nf_cache.clear()
sage: gc.collect()
0
sage: len([x for x in gc.get_objects() if isinstance(x, C)])
3
```
Even worse, with the change proposed above, one actually has an empty `_convert_from_list` for CDF, but nevertheless the quadratic number field does not want to die:

```
sage: CDF._introspect_coerce()
{'_action_hash': <sage.structure.coerce_dict.TripleDict at 0x95264c4>,
 '_action_list': [],
 '_coerce_from_hash': <sage.structure.coerce_dict.MonoDict at 0x952656c>,
 '_coerce_from_list': [],
 '_convert_from_hash': <sage.structure.coerce_dict.MonoDict at 0x9526534>,
 '_convert_from_list': [],
 '_element_init_pass_parent': False,
 '_embedding': None,
 '_initial_action_list': [],
 '_initial_coerce_list': [],
 '_initial_convert_list': []}
```

Hence, there must be another strong reference somewhere.



---

archive/issue_comments_181426.json:
```json
{
    "body": "<a id='comment:19'></a>\nReplying to [jpflori](#comment%3A17):\n> > However, I don't see why one shouldn't use a `WeakValueDictionary` instead.\n\n> Me neither, unless someone has the habit to play frequently with the same number field but without keeping any of its elements alive between different uses, personally I don't and would not really see the point.\n> \n> If we switch to a weak value dict, we could also get rid of the cache argument of the constructor then which won't be that useful/sensible anymore.\n\nI think it isn't sensible anyway. But that's not the point. We first need to find out what keeps the fields alive, when using the branch that I am now about to push. Wait a minute...",
    "created_at": "2013-09-28T22:00:48Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181426",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'></a>
Replying to [jpflori](#comment%3A17):
> > However, I don't see why one shouldn't use a `WeakValueDictionary` instead.

> Me neither, unless someone has the habit to play frequently with the same number field but without keeping any of its elements alive between different uses, personally I don't and would not really see the point.
> 
> If we switch to a weak value dict, we could also get rid of the cache argument of the constructor then which won't be that useful/sensible anymore.

I think it isn't sensible anyway. But that's not the point. We first need to find out what keeps the fields alive, when using the branch that I am now about to push. Wait a minute...



---

archive/issue_comments_181427.json:
```json
{
    "body": "**Branch:** [u/SimonKing/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/14711)",
    "created_at": "2013-09-28T22:02:31Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181427",
    "user": "https://github.com/simon-king-jena"
}
```

**Branch:** [u/SimonKing/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/14711)



---

archive/issue_comments_181428.json:
```json
{
    "body": "<a id='comment:21'></a>\nIsn't there some tool that is able to show the reference graph? objgraph or so?",
    "created_at": "2013-09-28T22:03:34Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181428",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:21'></a>
Isn't there some tool that is able to show the reference graph? objgraph or so?



---

archive/attachments_020475.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "chain.png",
    "asset_url": "tarball://root/attachments/ticket14711/chain.png",
    "created_at": "2013-09-28T22:16:12Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket14711/chain.png",
    "user": "https://github.com/simon-king-jena"
}
```



---

archive/issue_comments_181429.json:
```json
{
    "body": "**Attachment:** [chain.png](https://github.com/sagemath/sage/files/ticket14711/chain.png)\n\nA reference chain that apparently keeps quadratic fields alive.",
    "created_at": "2013-09-28T22:16:12Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181429",
    "user": "https://github.com/simon-king-jena"
}
```

**Attachment:** [chain.png](https://github.com/sagemath/sage/files/ticket14711/chain.png)

A reference chain that apparently keeps quadratic fields alive.



---

archive/issue_comments_181430.json:
```json
{
    "body": "<a id='comment:22'></a>\nReplying to [SimonKing](#comment%3A21):\n> Isn't there some tool that is able to show the reference graph? objgraph or so?\n\nYes, see [#11521 comment:8](https://github.com/sagemath/sage/issues/11521#comment:8)",
    "created_at": "2013-09-28T22:19:56Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181430",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:22'></a>
Replying to [SimonKing](#comment%3A21):
> Isn't there some tool that is able to show the reference graph? objgraph or so?

Yes, see [#11521 comment:8](https://github.com/sagemath/sage/issues/11521#comment:8)



---

archive/issue_comments_181431.json:
```json
{
    "body": "<a id='comment:23'></a>\n\n```\nsage: objgraph.show_chain(objgraph.find_backref_chain(random.choice(objgraph.by_type('NumberField_quadratic_with_category')),inspect.ismodule), filename='chain.png')\n```\nshows me the file chain.png in the attachment (of course, subject to some random choice).\n\nWhat is happening there? If I am not mistaken, objgraph only shows strong references. The quadratic field Q is used as key for the `MonoDict` which stores conversions into `CDF`. This monodict has a weak reference to the key Q, but a strong reference to the value, which is a morphism. The morphism of course points to both domain and codomain, and there is your problem.\n\nSo, how can we break this chain?",
    "created_at": "2013-09-28T22:20:48Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181431",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:23'></a>

```
sage: objgraph.show_chain(objgraph.find_backref_chain(random.choice(objgraph.by_type('NumberField_quadratic_with_category')),inspect.ismodule), filename='chain.png')
```
shows me the file chain.png in the attachment (of course, subject to some random choice).

What is happening there? If I am not mistaken, objgraph only shows strong references. The quadratic field Q is used as key for the `MonoDict` which stores conversions into `CDF`. This monodict has a weak reference to the key Q, but a strong reference to the value, which is a morphism. The morphism of course points to both domain and codomain, and there is your problem.

So, how can we break this chain?



---

archive/issue_comments_181432.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [jpflori](#comment%3A22):\n> Replying to [SimonKing](#comment%3A21):\n> > Isn't there some tool that is able to show the reference graph? objgraph or so?\n\n> Yes, see [#11521 comment:8](https://github.com/sagemath/sage/issues/11521#comment:8)\n\nThanks, but google was faster than you `:-P`",
    "created_at": "2013-09-28T22:21:22Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181432",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:24'></a>
Replying to [jpflori](#comment%3A22):
> Replying to [SimonKing](#comment%3A21):
> > Isn't there some tool that is able to show the reference graph? objgraph or so?

> Yes, see [#11521 comment:8](https://github.com/sagemath/sage/issues/11521#comment:8)

Thanks, but google was faster than you `:-P`



---

archive/issue_comments_181433.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [SimonKing](#comment%3A23):\n> \n> ```\n> sage: objgraph.show_chain(objgraph.find_backref_chain(random.choice(objgraph.by_type('NumberField_quadratic_with_category')),inspect.ismodule), filename='chain.png')\n> ```\n> shows me the file chain.png in the attachment (of course, subject to some random choice).\n> \n> What is happening there? If I am not mistaken, objgraph only shows strong references. The quadratic field Q is used as key for the `MonoDict` which stores conversions into `CDF`. This monodict has a weak reference to the key Q, but a strong reference to the value, which is a morphism. The morphism of course points to both domain and codomain, and there is your problem.\n> \n> So, how can we break this chain?\n\nWeakcaching the domain?\nIn such a situation it would make sense as in the monodict this domain is already only weakcached, in contrast to the codomain which stays alive anyway.\nDidn't we do something similar for Action?\n\nNot sure about the other uses of morphism though, a morphism could then survive when its parent dies.\nBut whats the point of keeping a morphism alive if you don't use its parent?",
    "created_at": "2013-09-28T22:30:26Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181433",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:25'></a>
Replying to [SimonKing](#comment%3A23):
> 
> ```
> sage: objgraph.show_chain(objgraph.find_backref_chain(random.choice(objgraph.by_type('NumberField_quadratic_with_category')),inspect.ismodule), filename='chain.png')
> ```
> shows me the file chain.png in the attachment (of course, subject to some random choice).
> 
> What is happening there? If I am not mistaken, objgraph only shows strong references. The quadratic field Q is used as key for the `MonoDict` which stores conversions into `CDF`. This monodict has a weak reference to the key Q, but a strong reference to the value, which is a morphism. The morphism of course points to both domain and codomain, and there is your problem.
> 
> So, how can we break this chain?

Weakcaching the domain?
In such a situation it would make sense as in the monodict this domain is already only weakcached, in contrast to the codomain which stays alive anyway.
Didn't we do something similar for Action?

Not sure about the other uses of morphism though, a morphism could then survive when its parent dies.
But whats the point of keeping a morphism alive if you don't use its parent?



---

archive/issue_comments_181434.json:
```json
{
    "body": "<a id='comment:26'></a>\nI had a similar problem (don't remember the ticket) with actions. I had to create a weak reference to the set that is being acted on. And spontaneously I only see one way to break the reference chain: Have a *weak* reference to the domain of maps.\n\nAnd I doubt that this would be any reasonable. Normally, we do want to be able to access the domain when we have a map. So, how can we protect the domain?",
    "created_at": "2013-09-28T22:31:14Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181434",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:26'></a>
I had a similar problem (don't remember the ticket) with actions. I had to create a weak reference to the set that is being acted on. And spontaneously I only see one way to break the reference chain: Have a *weak* reference to the domain of maps.

And I doubt that this would be any reasonable. Normally, we do want to be able to access the domain when we have a map. So, how can we protect the domain?



---

archive/issue_comments_181435.json:
```json
{
    "body": "<a id='comment:27'></a>\nReplying to [jpflori](#comment%3A25):\n> Not sure about the other uses of morphism though, a morphism could then survive when its parent dies.\n\nIsn't the homset containing the morphism keeping a strong reference to domain and codomain, too? Or did I change this somewhere? So, would having a weak reference to the domain actually help?\n\n> But whats the point of keeping a morphism alive if you don't use its parent?\n\nWell, imagine a method that returns a morphism. You have constructed the domain and the codomain inside of the method. It would be awkward to return `domain, codomain, morphism` instead of only one item, `morphism`. But if the morphism only keeps a weak reference to the domain, and if you only return the morphism, then the domain might be garbage collected during return, and this would make the morphism useless.",
    "created_at": "2013-09-28T22:36:25Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181435",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:27'></a>
Replying to [jpflori](#comment%3A25):
> Not sure about the other uses of morphism though, a morphism could then survive when its parent dies.

Isn't the homset containing the morphism keeping a strong reference to domain and codomain, too? Or did I change this somewhere? So, would having a weak reference to the domain actually help?

> But whats the point of keeping a morphism alive if you don't use its parent?

Well, imagine a method that returns a morphism. You have constructed the domain and the codomain inside of the method. It would be awkward to return `domain, codomain, morphism` instead of only one item, `morphism`. But if the morphism only keeps a weak reference to the domain, and if you only return the morphism, then the domain might be garbage collected during return, and this would make the morphism useless.



---

archive/issue_comments_181436.json:
```json
{
    "body": "<a id='comment:28'></a>\nYes, we have run into these things repeatedly. We're storing maps as `_coerce_from` and `_convert_from` on the codomain because for those maps, the codomain needs the domain to exist anyway (a polynomial ring will be holding a reference to its coefficient ring, a quotient ring needs the ring it was quotiented from).\n\nThis goes very wrong when we have maps into LARGER rings that exist independently. Indeed, as soon as you're coercing/converting/embedding a number field into Qbar, into SR, or into CC, your ring has been damned with virtually eternal life (SR is one ring to forever in the darkness bind them...).\n\nA nasty solution is to ALSO have _coerce_to and _convert_to, store each map in only one, and in the discovery process look on both the domain and the codomain. One can then choose whether the map should be cached on the domain or the codomain (depending on which one is expected to have the longer natural line). We'd end up mostly using the `_*_from` variants as we have now, but for things like QQbar etc. we'd choose the other one.\n\nThis might reduce the number of times where we'll get a leak this way, but I suspect that it'll be possible to get strong reference cycles via this process nonetheless.",
    "created_at": "2013-09-28T22:50:53Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181436",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:28'></a>
Yes, we have run into these things repeatedly. We're storing maps as `_coerce_from` and `_convert_from` on the codomain because for those maps, the codomain needs the domain to exist anyway (a polynomial ring will be holding a reference to its coefficient ring, a quotient ring needs the ring it was quotiented from).

This goes very wrong when we have maps into LARGER rings that exist independently. Indeed, as soon as you're coercing/converting/embedding a number field into Qbar, into SR, or into CC, your ring has been damned with virtually eternal life (SR is one ring to forever in the darkness bind them...).

A nasty solution is to ALSO have _coerce_to and _convert_to, store each map in only one, and in the discovery process look on both the domain and the codomain. One can then choose whether the map should be cached on the domain or the codomain (depending on which one is expected to have the longer natural line). We'd end up mostly using the `_*_from` variants as we have now, but for things like QQbar etc. we'd choose the other one.

This might reduce the number of times where we'll get a leak this way, but I suspect that it'll be possible to get strong reference cycles via this process nonetheless.



---

archive/issue_comments_181437.json:
```json
{
    "body": "<a id='comment:29'></a>\nReplying to [SimonKing](#comment%3A27):\n> Replying to [jpflori](#comment%3A25):\n> > Not sure about the other uses of morphism though, a morphism could then survive when its parent dies.\n\n> \n> Isn't the homset containing the morphism keeping a strong reference to domain and codomain, too? Or did I change this somewhere? So, would having a weak reference to the domain actually help?\n\nDon't know, we'll have to check.\n> \n> > But whats the point of keeping a morphism alive if you don't use its parent?\n\n> \n> Well, imagine a method that returns a morphism. You have constructed the domain and the codomain inside of the method. It would be awkward to return `domain, codomain, morphism` instead of only one item, `morphism`. But if the morphism only keeps a weak reference to the domain, and if you only return the morphism, then the domain might be garbage collected during return, and this would make the morphism useless.\n\nYeah I got that if you don't store an outside refernce to the domain, then it will get gc'ed.\n\nBut I don't really see what kind of method would return just such a morphism, internally constructing the domain without you providing it (or having other references ot it somehow), do you have actual examples in mind?\n\nAnyway, another solution would be to add an option to Action/Morphism and so on to only use weakref optionally.",
    "created_at": "2013-09-28T22:52:13Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181437",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:29'></a>
Replying to [SimonKing](#comment%3A27):
> Replying to [jpflori](#comment%3A25):
> > Not sure about the other uses of morphism though, a morphism could then survive when its parent dies.

> 
> Isn't the homset containing the morphism keeping a strong reference to domain and codomain, too? Or did I change this somewhere? So, would having a weak reference to the domain actually help?

Don't know, we'll have to check.
> 
> > But whats the point of keeping a morphism alive if you don't use its parent?

> 
> Well, imagine a method that returns a morphism. You have constructed the domain and the codomain inside of the method. It would be awkward to return `domain, codomain, morphism` instead of only one item, `morphism`. But if the morphism only keeps a weak reference to the domain, and if you only return the morphism, then the domain might be garbage collected during return, and this would make the morphism useless.

Yeah I got that if you don't store an outside refernce to the domain, then it will get gc'ed.

But I don't really see what kind of method would return just such a morphism, internally constructing the domain without you providing it (or having other references ot it somehow), do you have actual examples in mind?

Anyway, another solution would be to add an option to Action/Morphism and so on to only use weakref optionally.



---

archive/issue_comments_181438.json:
```json
{
    "body": "<a id='comment:30'></a>\nReplying to [nbruin](#comment%3A28):\n> Yes, we have run into these things repeatedly. We're storing maps as `_coerce_from` and `_convert_from` on the codomain because for those maps, the codomain needs the domain to exist anyway (a polynomial ring will be holding a reference to its coefficient ring, a quotient ring needs the ring it was quotiented from).\n> \n> This goes very wrong when we have maps into LARGER rings that exist independently. Indeed, as soon as you're coercing/converting/embedding a number field into Qbar, into SR, or into CC, your ring has been damned with virtually eternal life (SR is one ring to forever in the darkness bind them...).\n\nI think weak caching the domain should solve this problem (unless some homset as Simon mentioned comes into play).",
    "created_at": "2013-09-28T22:55:03Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181438",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:30'></a>
Replying to [nbruin](#comment%3A28):
> Yes, we have run into these things repeatedly. We're storing maps as `_coerce_from` and `_convert_from` on the codomain because for those maps, the codomain needs the domain to exist anyway (a polynomial ring will be holding a reference to its coefficient ring, a quotient ring needs the ring it was quotiented from).
> 
> This goes very wrong when we have maps into LARGER rings that exist independently. Indeed, as soon as you're coercing/converting/embedding a number field into Qbar, into SR, or into CC, your ring has been damned with virtually eternal life (SR is one ring to forever in the darkness bind them...).

I think weak caching the domain should solve this problem (unless some homset as Simon mentioned comes into play).



---

archive/issue_comments_181439.json:
```json
{
    "body": "<a id='comment:31'></a>\nLast idea, before I go to sleep:\n\nWe could\n- only have a *weak* reference to the values (here: a morphism, say, phi) of the `MonoDict` in `_convert_from_hash` (here: `CDF._convert_from_hash`),\n- keep a strong reference from the morphism to the domain (here: from Q to phi)\n- add a *strong* reference from the domain (Q) to the morphism (phi).\n\nWould this save us?\n\nWe want that a strong reference [edit: I mean an external strong reference] to Q keeps phi alive. Well, it does, since we added a strong reference Q->phi.\n\nWe want that phi can be collected, if no external strong reference to Q [edit: or to phi] exists. Well, there only are weak references from the `MonoDict` to phi and to Q. Hence, the only strong reference to phi comes from Q, and the only strong reference to Q comes from phi. This is a circle, that Python's cyclic garbage collector can deal with. Both Q and phi would be collected, and removed from the `MonoDict`.\n\n[edit:] And finally: An external strong reference to phi will keep Q alive, since we have a strong reference from phi to its domain Q.\n\nI find this solution by far more appealing than introducing a weak reference to the domain of a map. Good night.",
    "created_at": "2013-09-28T22:57:30Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181439",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:31'></a>
Last idea, before I go to sleep:

We could
- only have a *weak* reference to the values (here: a morphism, say, phi) of the `MonoDict` in `_convert_from_hash` (here: `CDF._convert_from_hash`),
- keep a strong reference from the morphism to the domain (here: from Q to phi)
- add a *strong* reference from the domain (Q) to the morphism (phi).

Would this save us?

We want that a strong reference [edit: I mean an external strong reference] to Q keeps phi alive. Well, it does, since we added a strong reference Q->phi.

We want that phi can be collected, if no external strong reference to Q [edit: or to phi] exists. Well, there only are weak references from the `MonoDict` to phi and to Q. Hence, the only strong reference to phi comes from Q, and the only strong reference to Q comes from phi. This is a circle, that Python's cyclic garbage collector can deal with. Both Q and phi would be collected, and removed from the `MonoDict`.

[edit:] And finally: An external strong reference to phi will keep Q alive, since we have a strong reference from phi to its domain Q.

I find this solution by far more appealing than introducing a weak reference to the domain of a map. Good night.



---

archive/issue_comments_181440.json:
```json
{
    "body": "<a id='comment:32'></a>\nReplying to [SimonKing](#comment%3A31):\n> Last idea, before I go to sleep:\n> \n> We could\n> - only have a *weak* reference to the values (here: a morphism, say, phi) of the `MonoDict` in `_convert_from_hash` (here: `CDF._convert_from_hash`),\n> - keep a strong reference from the morphism to the domain (here: from Q to phi)\n> - add a *strong* reference from the domain (Q) to the morphism (phi).\n> \n> Would this save us?\n> \n> We want that a strong reference [edit: I mean an external strong reference] to Q keeps phi alive. Well, it does, since we added a strong reference Q->phi.\n> \n> We want that phi can be collected, if no external strong reference to Q [edit: or to phi] exists. Well, there only are weak references from the `MonoDict` to phi and to Q. Hence, the only strong reference to phi comes from Q, and the only strong reference to Q comes from phi. This is a circle, that Python's cyclic garbage collector can deal with. Both Q and phi would be collected, and removed from the `MonoDict`.\n> \n> [edit:] And finally: An external strong reference to phi will keep Q alive, since we have a strong reference from phi to its domain Q.\n> \n\nThat would suit as well I guess and sounds kind of like the coerce_to solution nils suggested.\nIf we go this way, I guess we should do the same for actions.",
    "created_at": "2013-09-28T23:04:56Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181440",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:32'></a>
Replying to [SimonKing](#comment%3A31):
> Last idea, before I go to sleep:
> 
> We could
> - only have a *weak* reference to the values (here: a morphism, say, phi) of the `MonoDict` in `_convert_from_hash` (here: `CDF._convert_from_hash`),
> - keep a strong reference from the morphism to the domain (here: from Q to phi)
> - add a *strong* reference from the domain (Q) to the morphism (phi).
> 
> Would this save us?
> 
> We want that a strong reference [edit: I mean an external strong reference] to Q keeps phi alive. Well, it does, since we added a strong reference Q->phi.
> 
> We want that phi can be collected, if no external strong reference to Q [edit: or to phi] exists. Well, there only are weak references from the `MonoDict` to phi and to Q. Hence, the only strong reference to phi comes from Q, and the only strong reference to Q comes from phi. This is a circle, that Python's cyclic garbage collector can deal with. Both Q and phi would be collected, and removed from the `MonoDict`.
> 
> [edit:] And finally: An external strong reference to phi will keep Q alive, since we have a strong reference from phi to its domain Q.
> 

That would suit as well I guess and sounds kind of like the coerce_to solution nils suggested.
If we go this way, I guess we should do the same for actions.



---

archive/issue_comments_181441.json:
```json
{
    "body": "<a id='comment:33'></a>\nReplying to [jpflori](#comment%3A32):\n> That would suit as well I guess and sounds kind of like the coerce_to solution nils suggested.\n> If we go this way, I guess we should do the same for actions.\n\nYes, it strikes me as similar. In fact, because when you're trying to figure out a coercion or conversion you usually have both the domain and the codomain already, there's no need for weak references.\n\nSee also [[#11521 comment:152](https://github.com/sagemath/sage/issues/11521#comment:152)]\n\nNote that a map and a homset really do need strong references to domain and codomain, because they need both to stay sane. If you want maps with weak references to one or the other, you'd have to make a special class specifically for use in the coercion system. Note that such maps would often essentially reference elements (at least in the codomain), so a strong reference to to codomain is probably unavoidable in almost all cases.\n\nOnce a coercion or a conversion is discovered, how do we decide where to cache it? Do domain and codomain need a ranking and store the map on the domain only if it's ranks strictly higher? We'd have\n`ZZ, QQ, SR` of rank 0. Different float rings rank 1, polynomial rings of rank (base) + 1 etc. something like that? Perhaps the coercion \"construction\" hierarchy is of use for this?",
    "created_at": "2013-09-28T23:18:25Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181441",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:33'></a>
Replying to [jpflori](#comment%3A32):
> That would suit as well I guess and sounds kind of like the coerce_to solution nils suggested.
> If we go this way, I guess we should do the same for actions.

Yes, it strikes me as similar. In fact, because when you're trying to figure out a coercion or conversion you usually have both the domain and the codomain already, there's no need for weak references.

See also [[#11521 comment:152](https://github.com/sagemath/sage/issues/11521#comment:152)]

Note that a map and a homset really do need strong references to domain and codomain, because they need both to stay sane. If you want maps with weak references to one or the other, you'd have to make a special class specifically for use in the coercion system. Note that such maps would often essentially reference elements (at least in the codomain), so a strong reference to to codomain is probably unavoidable in almost all cases.

Once a coercion or a conversion is discovered, how do we decide where to cache it? Do domain and codomain need a ranking and store the map on the domain only if it's ranks strictly higher? We'd have
`ZZ, QQ, SR` of rank 0. Different float rings rank 1, polynomial rings of rank (base) + 1 etc. something like that? Perhaps the coercion "construction" hierarchy is of use for this?



---

archive/issue_comments_181442.json:
```json
{
    "body": "<a id='comment:34'></a>\nWhen we would do as I have suggested (strong reference from Q to phi, weak reference from CDF to phi) then we have of course the problem what happens if Q is immortal and we want to get rid of CDF, because then we have a strong reference from phi to the codomain CDF, keeping CDF alive.\n\nSo, in both approaches we are discussing here, sooner or later have to decide: Do we want that the domain of a coercion/conversion can be removed even if the codomain survives? Or do we want that the codomain of a coercion/conversion can be removed even if the domain survives?\n\nIsn't there any way to achieve both at the same time?",
    "created_at": "2013-09-29T08:17:14Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181442",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:34'></a>
When we would do as I have suggested (strong reference from Q to phi, weak reference from CDF to phi) then we have of course the problem what happens if Q is immortal and we want to get rid of CDF, because then we have a strong reference from phi to the codomain CDF, keeping CDF alive.

So, in both approaches we are discussing here, sooner or later have to decide: Do we want that the domain of a coercion/conversion can be removed even if the codomain survives? Or do we want that the codomain of a coercion/conversion can be removed even if the domain survives?

Isn't there any way to achieve both at the same time?



---

archive/issue_comments_181443.json:
```json
{
    "body": "<a id='comment:35'></a>\nPS: It might be doable to guess from the construction of an object whether it will be immortal or not, and then decide whether we store the coercion in the domain or in the codomain. But note that this may slow down the whole coercion system, because when searching a coercion it would always be needed to look both at the domain and the codomain: Two searches where we currently have only one.\n\nAnd when the construction shall guide us what to do, then we always need to compute the construction first---and actually not all parents are currently provided with a construction.",
    "created_at": "2013-09-29T08:23:50Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181443",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:35'></a>
PS: It might be doable to guess from the construction of an object whether it will be immortal or not, and then decide whether we store the coercion in the domain or in the codomain. But note that this may slow down the whole coercion system, because when searching a coercion it would always be needed to look both at the domain and the codomain: Two searches where we currently have only one.

And when the construction shall guide us what to do, then we always need to compute the construction first---and actually not all parents are currently provided with a construction.



---

archive/issue_comments_181444.json:
```json
{
    "body": "<a id='comment:36'></a>\nReplying to [SimonKing](#comment%3A35):\n> Two searches where we currently have only one.\n\nHmm. This may be not the case, actually. We could continue to only do the search in `codomain._coerce_from_hash`, which would still be a `MonoDict`, hence, with weak references to the key (i.e., to the domain). So, the search would only happen there. But then, depending on the immortality of the domain resp. the codomain, what we find as value of `codomain._coerce_from_hash` will be a strong respectively a weak reference to a map, and then we would have no reference respectively a strong reference back from the domain to the map.\n\nBut still, I fear this will slow down things.",
    "created_at": "2013-09-29T08:35:07Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181444",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:36'></a>
Replying to [SimonKing](#comment%3A35):
> Two searches where we currently have only one.

Hmm. This may be not the case, actually. We could continue to only do the search in `codomain._coerce_from_hash`, which would still be a `MonoDict`, hence, with weak references to the key (i.e., to the domain). So, the search would only happen there. But then, depending on the immortality of the domain resp. the codomain, what we find as value of `codomain._coerce_from_hash` will be a strong respectively a weak reference to a map, and then we would have no reference respectively a strong reference back from the domain to the map.

But still, I fear this will slow down things.



---

archive/issue_comments_181445.json:
```json
{
    "body": "<a id='comment:37'></a>\nHow about that?\n\nLet D, C be domain and codomain of a coerce map phi. Let us store strong references from `MonoDict`s `domain._coerce_into_hash` and `codomain._coerce_from_hash`. Let us create a method of `phi._make_weak_references()` that turns the default strong references from phi to its domain and codomain into weak references.\n\nThat's to say: We could still use the current backtracking algorithm to detect coercions (this is since we keep having `codomain._coerce_from_hash`). We would call `phi._make_weak_references()` only when registering the coercion. So, I guess the additional overhead would be small, and the default behaviour of maps would still be safe.\n\nWould this solve our problem? I think so. Assume that there are no external strong references to C, but there are external strong references to D. Hence, there is a strong reference from D to phi, but phi (because we have called `phi._make_weak_references()` only has a *weak* reference to C. Hence, C can be deallocated, and this would trigger the callback for `D._coerce_into_hash[C]=phi`. \n\nIn other words, phi would be removed from the `MonoDict` assigned to `D`. As a result, C and phi can be collected, but D will survive (because of the external strong reference).\n\nAnd you may note that this picture is completely symmetric. Hence, an external strong reference to C would not be enough to keep phi and D alive.\n\nIsn't this exactly what we want?",
    "created_at": "2013-09-29T09:00:42Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181445",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:37'></a>
How about that?

Let D, C be domain and codomain of a coerce map phi. Let us store strong references from `MonoDict`s `domain._coerce_into_hash` and `codomain._coerce_from_hash`. Let us create a method of `phi._make_weak_references()` that turns the default strong references from phi to its domain and codomain into weak references.

That's to say: We could still use the current backtracking algorithm to detect coercions (this is since we keep having `codomain._coerce_from_hash`). We would call `phi._make_weak_references()` only when registering the coercion. So, I guess the additional overhead would be small, and the default behaviour of maps would still be safe.

Would this solve our problem? I think so. Assume that there are no external strong references to C, but there are external strong references to D. Hence, there is a strong reference from D to phi, but phi (because we have called `phi._make_weak_references()` only has a *weak* reference to C. Hence, C can be deallocated, and this would trigger the callback for `D._coerce_into_hash[C]=phi`. 

In other words, phi would be removed from the `MonoDict` assigned to `D`. As a result, C and phi can be collected, but D will survive (because of the external strong reference).

And you may note that this picture is completely symmetric. Hence, an external strong reference to C would not be enough to keep phi and D alive.

Isn't this exactly what we want?



---

archive/issue_comments_181446.json:
```json
{
    "body": "<a id='comment:38'></a>\nI think we'd need to do more: phi has a strong reference to the homset `phi.parent()`, which also has strong references to both D and C.\n\nPerhaps we could make it so that homsets *always* only keep weak references to domain and codomain, whereas maps (such as phi) by default keep *strong* references to domain and codomain, but have a method 'phi._make_references_weak()` that makes them have weak references to domain and codomain?\n\nRationale: I hope it is very unlikely that we have a homset, but don't created an element of it and don't keep references to domain or codomain. Hence, I hope it is acceptable that in such situation the domain and codomain of the homset may be garbage collected. But if we have a morphism, then this morphism will keep the domain and codomain alive, and thus weak references of the homset don't hurt. And the exception is: If this morphism is used for coercion, then we can call `_make_references_weak()` on it, so that domain and/or codomain need an external reference to prevent garbage collection.\n\nHmm. I guess it isn't very clear yet. Perhaps it is best to try and provide a proof of concept, sometimes in the next days.",
    "created_at": "2013-09-29T19:52:55Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181446",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:38'></a>
I think we'd need to do more: phi has a strong reference to the homset `phi.parent()`, which also has strong references to both D and C.

Perhaps we could make it so that homsets *always* only keep weak references to domain and codomain, whereas maps (such as phi) by default keep *strong* references to domain and codomain, but have a method 'phi._make_references_weak()` that makes them have weak references to domain and codomain?

Rationale: I hope it is very unlikely that we have a homset, but don't created an element of it and don't keep references to domain or codomain. Hence, I hope it is acceptable that in such situation the domain and codomain of the homset may be garbage collected. But if we have a morphism, then this morphism will keep the domain and codomain alive, and thus weak references of the homset don't hurt. And the exception is: If this morphism is used for coercion, then we can call `_make_references_weak()` on it, so that domain and/or codomain need an external reference to prevent garbage collection.

Hmm. I guess it isn't very clear yet. Perhaps it is best to try and provide a proof of concept, sometimes in the next days.



---

archive/issue_comments_181447.json:
```json
{
    "body": "<a id='comment:39'></a>\nReplying to [SimonKing](#comment%3A38):\n> Hmm. I guess it isn't very clear yet. Perhaps it is best to try and provide a proof of concept, sometimes in the next days.\n\nI'm pretty sure you'll find it to be incredibly painful. A homset and a homomorphism are only healthy if their domains and codomains exist. They should therefore have strong references to them. The protocols required to correctly handle homsets and homomorphisms without those strong references will be very painful. What's worse, those homomorphisms will often still work correctly if the proper protocol isn't followed, because domain and codomain will usually not be very quickly reclaimed by GC. So you'll very likely have very hard to find bugs.\n\nMaps in the coercion system are a little different: We'd only be looking up the map if we HAVE domain and codomain (in fact, the lookup would be keyed on them). One way of dealing with this is not to have full-blown maps as mathematical objects, but just have a \"premap\" ... the minimal data to define the coercion map. I think it's a mistake to allow our full-blown maps to also stand in for such \"premaps\". Note that a premap will usually need strong references to the codomain anyway. Most of the time, a premap is just a sequence of images of the generators of the domain.\n\nCertainly, \"premaps\" don't need to have a reference to a homset.\n\nI think the easier solution is to devise a strategy to store coercions on either domain or codomain.\nAny complication in lookup from these could be alleviated by having a global, fully weak, triple dict keyed on domain and codomain, containing the coercion map (weakly referenced). That way, it's not important whether the coercion is stored in `_coerce_from` or in `_coerce_to`. Those list would only be responsible for keeping a strong reference. The lookup could happen in a global, fully weak, associative lookup. I think you ended up with a similar structure around actions or homsets somewhere.\n\nThe main thing this gets us is flexibility in WHO is keeping the strong refs to our coercion maps (usually either domain or codomain; are there other possibilities?). I'm not sure it fully solves our problems. It does if we can make a \"mortality hierarchy\", and store the ref on the more mortal one (preferring the codomain in case of a draw).",
    "created_at": "2013-09-30T03:04:09Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181447",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:39'></a>
Replying to [SimonKing](#comment%3A38):
> Hmm. I guess it isn't very clear yet. Perhaps it is best to try and provide a proof of concept, sometimes in the next days.

I'm pretty sure you'll find it to be incredibly painful. A homset and a homomorphism are only healthy if their domains and codomains exist. They should therefore have strong references to them. The protocols required to correctly handle homsets and homomorphisms without those strong references will be very painful. What's worse, those homomorphisms will often still work correctly if the proper protocol isn't followed, because domain and codomain will usually not be very quickly reclaimed by GC. So you'll very likely have very hard to find bugs.

Maps in the coercion system are a little different: We'd only be looking up the map if we HAVE domain and codomain (in fact, the lookup would be keyed on them). One way of dealing with this is not to have full-blown maps as mathematical objects, but just have a "premap" ... the minimal data to define the coercion map. I think it's a mistake to allow our full-blown maps to also stand in for such "premaps". Note that a premap will usually need strong references to the codomain anyway. Most of the time, a premap is just a sequence of images of the generators of the domain.

Certainly, "premaps" don't need to have a reference to a homset.

I think the easier solution is to devise a strategy to store coercions on either domain or codomain.
Any complication in lookup from these could be alleviated by having a global, fully weak, triple dict keyed on domain and codomain, containing the coercion map (weakly referenced). That way, it's not important whether the coercion is stored in `_coerce_from` or in `_coerce_to`. Those list would only be responsible for keeping a strong reference. The lookup could happen in a global, fully weak, associative lookup. I think you ended up with a similar structure around actions or homsets somewhere.

The main thing this gets us is flexibility in WHO is keeping the strong refs to our coercion maps (usually either domain or codomain; are there other possibilities?). I'm not sure it fully solves our problems. It does if we can make a "mortality hierarchy", and store the ref on the more mortal one (preferring the codomain in case of a draw).



---

archive/issue_comments_181448.json:
```json
{
    "body": "<a id='comment:40'></a>\nReplying to [nbruin](#comment%3A39):\n> Replying to [SimonKing](#comment%3A38):\n> > Hmm. I guess it isn't very clear yet. Perhaps it is best to try and provide a proof of concept, sometimes in the next days.\n\n> \n> I'm pretty sure you'll find it to be incredibly painful.\n\nNot at all. Admittedly I had no time yet to run all tests. But Sage starts and the memleak is fixed. I'll update the branch shortly.\n\n> A homset and a homomorphism are only healthy if their domains and codomains exist.\n\nCorrect.\n\n> They should therefore have strong references to them.\n\nNo. If there is no external strong reference to domain/codomain and no element of the homset exists that is stored outside of the coercion model, then I think there is no reason to keep the homset valid. The domain/codomain together with the coerce maps *and* together with the homset should be garbage collected.\n\n> The protocols required to correctly handle homsets and homomorphisms without those strong references will be very painful.\n\nNo idea what you are talking about here. \"Protocol\" in the sense of \"interface\"? Well, the interface will be the same. There is a callable attribute \".domain()\" of homsets and of maps. Currently, these callable attributes are methods. With my patch, they are either `ConstantFunction` or `weakref.ref`. At least for maps, there will be methods `_make_weak_references()` and `_make_strong_references()` to choose between the two.\n\n> What's worse, those homomorphisms will often still work correctly if the proper protocol isn't followed, because domain and codomain will usually not be very quickly reclaimed by GC.\n\nIf you have a homomorphism outside of the coercion framework, then the domain and codomain will be kept alive, unless you call `_make_weak_references()` on the map (which the user shouldn't do---it is an underscore method after all).\n\nOtherwise, if you have no external strong reference to, say, the domain of a coerce map, then there will be no supported way to access the coerce map (namely, for `codomain.coerce_map_from(domain)` you'd need a reference to the domain). So, I don't think there is a problem here.\n\n> Maps in the coercion system are a little different: We'd only be looking up the map if we HAVE domain and codomain\n\nExactly. And all other maps will keep the domain and codomain alive and will thus keep the homset valid.\n\n> Any complication in lookup from these could be alleviated by having a global, fully weak, triple dict keyed on domain and codomain, containing the coercion map (weakly referenced).\n\nProblem: If this is a global object, then you will have a strong reference to it, hence, you will have a strong reference to all the coerce maps, and thus (at least when you have strong references to domain and codomain) *all* parents that are *ever* involved in a coercion or conversion *either* as domain or codomain will be immortal.\n\n> That way, it's not important whether the coercion is stored in `_coerce_from` or in `_coerce_to`.\n\nBy the way, in the branch that I am preparing there is still only `_coerce_from`. As it has turned out, a `_coerce_to` is not needed.\n\nI am confident that my branch will have the following property: If a map from P1 to P2 is cached in the coercion model, and you don't keep a strong external reference to P1 (or P2), then P1 (or P2) can be garbage collected. But if you keep a strong external reference to both P1 and P2, then the map will stay in the cache.",
    "created_at": "2013-09-30T17:20:42Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181448",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:40'></a>
Replying to [nbruin](#comment%3A39):
> Replying to [SimonKing](#comment%3A38):
> > Hmm. I guess it isn't very clear yet. Perhaps it is best to try and provide a proof of concept, sometimes in the next days.

> 
> I'm pretty sure you'll find it to be incredibly painful.

Not at all. Admittedly I had no time yet to run all tests. But Sage starts and the memleak is fixed. I'll update the branch shortly.

> A homset and a homomorphism are only healthy if their domains and codomains exist.

Correct.

> They should therefore have strong references to them.

No. If there is no external strong reference to domain/codomain and no element of the homset exists that is stored outside of the coercion model, then I think there is no reason to keep the homset valid. The domain/codomain together with the coerce maps *and* together with the homset should be garbage collected.

> The protocols required to correctly handle homsets and homomorphisms without those strong references will be very painful.

No idea what you are talking about here. "Protocol" in the sense of "interface"? Well, the interface will be the same. There is a callable attribute ".domain()" of homsets and of maps. Currently, these callable attributes are methods. With my patch, they are either `ConstantFunction` or `weakref.ref`. At least for maps, there will be methods `_make_weak_references()` and `_make_strong_references()` to choose between the two.

> What's worse, those homomorphisms will often still work correctly if the proper protocol isn't followed, because domain and codomain will usually not be very quickly reclaimed by GC.

If you have a homomorphism outside of the coercion framework, then the domain and codomain will be kept alive, unless you call `_make_weak_references()` on the map (which the user shouldn't do---it is an underscore method after all).

Otherwise, if you have no external strong reference to, say, the domain of a coerce map, then there will be no supported way to access the coerce map (namely, for `codomain.coerce_map_from(domain)` you'd need a reference to the domain). So, I don't think there is a problem here.

> Maps in the coercion system are a little different: We'd only be looking up the map if we HAVE domain and codomain

Exactly. And all other maps will keep the domain and codomain alive and will thus keep the homset valid.

> Any complication in lookup from these could be alleviated by having a global, fully weak, triple dict keyed on domain and codomain, containing the coercion map (weakly referenced).

Problem: If this is a global object, then you will have a strong reference to it, hence, you will have a strong reference to all the coerce maps, and thus (at least when you have strong references to domain and codomain) *all* parents that are *ever* involved in a coercion or conversion *either* as domain or codomain will be immortal.

> That way, it's not important whether the coercion is stored in `_coerce_from` or in `_coerce_to`.

By the way, in the branch that I am preparing there is still only `_coerce_from`. As it has turned out, a `_coerce_to` is not needed.

I am confident that my branch will have the following property: If a map from P1 to P2 is cached in the coercion model, and you don't keep a strong external reference to P1 (or P2), then P1 (or P2) can be garbage collected. But if you keep a strong external reference to both P1 and P2, then the map will stay in the cache.



---

archive/issue_comments_181449.json:
```json
{
    "body": "<a id='comment:41'></a>\nReplying to [SimonKing](#comment%3A40):\n> > The protocols required to correctly handle homsets and homomorphisms without those strong references will be very painful.\n\n> \n> No idea what you are talking about here. \"Protocol\" in the sense of \"interface\"?\n\nProtocol as in \"how to use the interface properly\". In this case the protocol would include: keep strong references to domain and codomain for as long as you're keeping a reference to the the map.\n\n> If you have a homomorphism outside of the coercion framework, then the domain and codomain will be kept alive, unless you call `_make_weak_references()` on the map (which the user shouldn't do---it is an underscore method after all).\n\nThe problem is, homomorphisms constructed by the coercion framework might leak into user space:\n\n```\nsage: QQ.coerce_map_from(ZZ)\nNatural morphism:\n  From: Integer Ring\n  To:   Rational Field\n```\nAre you always going to return a copy of the morphism held in the coercion framework with strong references to domain and codomain, and mandate that the only supported interface is accessing the coercion maps via that interface? You'd better check the current code base for compliance with that specification. Especially: do all maps know how to create a copy of themselves? Do map compositions know how to recurse into their components for making copies and ensure that domain/codomain references are made strong again?\n\n> Problem: If this is a global object, then you will have a strong reference to it, hence, you will have a strong reference to all the coerce maps, and thus (at least when you have strong references to domain and codomain) *all* parents that are *ever* involved in a coercion or conversion *either* as domain or codomain will be immortal.\n\nNo, I said \"fully weak\", i.e., also with weak values. You already have one of those global associative caches in the `Homset` constructor. (in fact, that's the only use and the reason why `TripleDict` grew a `weakvalues=true` parameter)\n\n> By the way, in the branch that I am preparing there is still only `_coerce_from`. As it has turned out, a `_coerce_to` is not needed.\n\nIndeed, if you can make you idea work. But I think it needs some pretty invasive changes in how one can extract and use maps found by the coercion framework.\n\nYour idea would mean we'd have multiple versions of maps around, some with weak references (which shouldn't leave the coercion framework) and some with strong references. Which should be equal? which should be identical?\n\nCompare with now:\n\n```\nsage: a1=QQ.coerce_map_from(ZZ)\nsage: a2=QQ.coerce_map_from(ZZ)\nsage: b=sage.rings.rational.Z_to_Q()\nsage: c=sage.rings.rational.Z_to_Q()\nsage: [a1 is a2, a1 is b, b is c]\n[True, False, False]\nsage: [a1 == a2, a1 == b, b == c]\n[True, False, False]\n```\nYour approach will have to break `a1 is a2`. How will you deal with equality?\n\nI think getting some of these references weak within the coercion framework would be great. It should be a little more robust that a `_coerce_to` and `_coerce_from` solution (except for maps that internally end up keeping a strong reference to their domain; how do map compositions fare in this respect?).",
    "created_at": "2013-09-30T18:13:54Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181449",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:41'></a>
Replying to [SimonKing](#comment%3A40):
> > The protocols required to correctly handle homsets and homomorphisms without those strong references will be very painful.

> 
> No idea what you are talking about here. "Protocol" in the sense of "interface"?

Protocol as in "how to use the interface properly". In this case the protocol would include: keep strong references to domain and codomain for as long as you're keeping a reference to the the map.

> If you have a homomorphism outside of the coercion framework, then the domain and codomain will be kept alive, unless you call `_make_weak_references()` on the map (which the user shouldn't do---it is an underscore method after all).

The problem is, homomorphisms constructed by the coercion framework might leak into user space:

```
sage: QQ.coerce_map_from(ZZ)
Natural morphism:
  From: Integer Ring
  To:   Rational Field
```
Are you always going to return a copy of the morphism held in the coercion framework with strong references to domain and codomain, and mandate that the only supported interface is accessing the coercion maps via that interface? You'd better check the current code base for compliance with that specification. Especially: do all maps know how to create a copy of themselves? Do map compositions know how to recurse into their components for making copies and ensure that domain/codomain references are made strong again?

> Problem: If this is a global object, then you will have a strong reference to it, hence, you will have a strong reference to all the coerce maps, and thus (at least when you have strong references to domain and codomain) *all* parents that are *ever* involved in a coercion or conversion *either* as domain or codomain will be immortal.

No, I said "fully weak", i.e., also with weak values. You already have one of those global associative caches in the `Homset` constructor. (in fact, that's the only use and the reason why `TripleDict` grew a `weakvalues=true` parameter)

> By the way, in the branch that I am preparing there is still only `_coerce_from`. As it has turned out, a `_coerce_to` is not needed.

Indeed, if you can make you idea work. But I think it needs some pretty invasive changes in how one can extract and use maps found by the coercion framework.

Your idea would mean we'd have multiple versions of maps around, some with weak references (which shouldn't leave the coercion framework) and some with strong references. Which should be equal? which should be identical?

Compare with now:

```
sage: a1=QQ.coerce_map_from(ZZ)
sage: a2=QQ.coerce_map_from(ZZ)
sage: b=sage.rings.rational.Z_to_Q()
sage: c=sage.rings.rational.Z_to_Q()
sage: [a1 is a2, a1 is b, b is c]
[True, False, False]
sage: [a1 == a2, a1 == b, b == c]
[True, False, False]
```
Your approach will have to break `a1 is a2`. How will you deal with equality?

I think getting some of these references weak within the coercion framework would be great. It should be a little more robust that a `_coerce_to` and `_coerce_from` solution (except for maps that internally end up keeping a strong reference to their domain; how do map compositions fare in this respect?).



---

archive/issue_comments_181450.json:
```json
{
    "body": "<a id='comment:42'></a>\nHi Nils,\n\nReplying to [nbruin](#comment%3A41):\n> Replying to [SimonKing](#comment%3A40):\n> > No idea what you are talking about here. \"Protocol\" in the sense of \"interface\"?\n\n> \n> Protocol as in \"how to use the interface properly\". In this case the protocol would include: keep strong references to domain and codomain for as long as you're keeping a reference to the the map.\n\nYou mean: Of the homset. If you create a map, then it's fine.\n\nAdmittedly, I am not totally happy with letting Hom be with weak references from the very beginning. What I could imagine, though: Let it be strong in the beginning; but change `Homset.__call__` so that it first replaces the strong by a weak reference *in the homset*. Namely, maps (i.e., the things returned by `__call__`!) will then have the burden to carry strong references to domain and codomain.\n\n> The problem is, homomorphisms constructed by the coercion framework might leak into user space:\n> \n> ```\n> sage: QQ.coerce_map_from(ZZ)\n> Natural morphism:\n>   From: Integer Ring\n>   To:   Rational Field\n> ```\n\nCorrect.\n\nWhat about renaming `coerce_map_from()` into `_cm_coerce_map_from()`? It would not be part of the official interface (since it is an underscore method) and hence is entitled to return something that only makes sense when used within the coercion model. We could then define\n\n```python\ndef coerce_map_from(self, P):\n    phi = self._cm_coerce_map_from(P)\n    if phi is None:\n        return\n    phi._make_strong_references()\n    return phi\n```\nreturning a map with strengthened references (note: I am not speaking about a copy). So, this would be the \"official\" way to get a \"safe\" map from an unsafe internally used coercion.\n\n> No, I said \"fully weak\", i.e., also with weak values. You already have one of those global associative caches in the `Homset` constructor.\n\nI see. Hmmm. There is one important difference to Homsets: If you only store weak references to the coerce maps, then what would prevent them from being immediately garbage collected? In the case of Homsets, it is the elements that prevents them from being garbage collected. Hence, having a fully weak cache does make sense.\n\n> Indeed, if you can make you idea work. But I think it needs some pretty invasive changes in how one can extract and use maps found by the coercion framework.\n\nI don't think so, if one separates the internally used methods from the interface.\n \n> Your idea would mean we'd have multiple versions of maps around, some with weak references (which shouldn't leave the coercion framework) and some with strong references. Which should be equal? which should be identical?\n\nAgain, I am not talking about \"returning copies\".",
    "created_at": "2013-09-30T19:08:53Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181450",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:42'></a>
Hi Nils,

Replying to [nbruin](#comment%3A41):
> Replying to [SimonKing](#comment%3A40):
> > No idea what you are talking about here. "Protocol" in the sense of "interface"?

> 
> Protocol as in "how to use the interface properly". In this case the protocol would include: keep strong references to domain and codomain for as long as you're keeping a reference to the the map.

You mean: Of the homset. If you create a map, then it's fine.

Admittedly, I am not totally happy with letting Hom be with weak references from the very beginning. What I could imagine, though: Let it be strong in the beginning; but change `Homset.__call__` so that it first replaces the strong by a weak reference *in the homset*. Namely, maps (i.e., the things returned by `__call__`!) will then have the burden to carry strong references to domain and codomain.

> The problem is, homomorphisms constructed by the coercion framework might leak into user space:
> 
> ```
> sage: QQ.coerce_map_from(ZZ)
> Natural morphism:
>   From: Integer Ring
>   To:   Rational Field
> ```

Correct.

What about renaming `coerce_map_from()` into `_cm_coerce_map_from()`? It would not be part of the official interface (since it is an underscore method) and hence is entitled to return something that only makes sense when used within the coercion model. We could then define

```python
def coerce_map_from(self, P):
    phi = self._cm_coerce_map_from(P)
    if phi is None:
        return
    phi._make_strong_references()
    return phi
```
returning a map with strengthened references (note: I am not speaking about a copy). So, this would be the "official" way to get a "safe" map from an unsafe internally used coercion.

> No, I said "fully weak", i.e., also with weak values. You already have one of those global associative caches in the `Homset` constructor.

I see. Hmmm. There is one important difference to Homsets: If you only store weak references to the coerce maps, then what would prevent them from being immediately garbage collected? In the case of Homsets, it is the elements that prevents them from being garbage collected. Hence, having a fully weak cache does make sense.

> Indeed, if you can make you idea work. But I think it needs some pretty invasive changes in how one can extract and use maps found by the coercion framework.

I don't think so, if one separates the internally used methods from the interface.
 
> Your idea would mean we'd have multiple versions of maps around, some with weak references (which shouldn't leave the coercion framework) and some with strong references. Which should be equal? which should be identical?

Again, I am not talking about "returning copies".



---

archive/issue_comments_181451.json:
```json
{
    "body": "<a id='comment:43'></a>\nReplying to [SimonKing](#comment%3A42):\n> Hi Nils,\n> \n> Replying to [nbruin](#comment%3A41):\n> > Replying to [SimonKing](#comment%3A40):\n> > > No idea what you are talking about here. \"Protocol\" in the sense of \"interface\"?\n\n> > \n> > Protocol as in \"how to use the interface properly\". In this case the protocol would include: keep strong references to domain and codomain for as long as you're keeping a reference to the the map.\n\n> \n> You mean: Of the homset. If you create a map, then it's fine.\n\nNo, also for the map, if I understand your proposal correctly. If I keep a reference to just a map, I'd expect it to keep the domain and codomain alive as well (i.e., the semantics of a map with `_make_strong_references`; the only type of map that should be allowed to escape into the wild).\n\n> Admittedly, I am not totally happy with letting Hom be with weak references from the very beginning. What I could imagine, though: Let it be strong in the beginning; but change `Homset.__call__` so that it first replaces the strong by a weak reference *in the homset*. Namely, maps (i.e., the things returned by `__call__`!) will then have the burden to carry strong references to domain and codomain.\n\nBut that responsibility would fall back onto the homset once the last reference to a map has been lost. You wouldn't know when that would happen. Do the maps in the coercion framework really need a Homset? Perhaps you can just leave that blank if you have `_use_weak_references`.\n\n> What about renaming `coerce_map_from()` into `_cm_coerce_map_from()`? It would not be part of the official interface (since it is an underscore method) and hence is entitled to return something that only makes sense when used within the coercion model. We could then define\n> \n> ```python\n> def coerce_map_from(self, P):\n>     phi = self._cm_coerce_map_from(P)\n>     if phi is None:\n>         return\n>     phi._make_strong_references()\n>     return phi\n> ```\n> returning a map with strengthened references (note: I am not speaking about a copy). So, this would be the \"official\" way to get a \"safe\" map from an unsafe internally used coercion.\n\nThat leaves you with a memory leak again: After asking for a `coerce_map`, the map stored in the coercion framework now has strong references again, even after I discard my requested `coerce_map`.\n\n> > No, I said \"fully weak\", i.e., also with weak values. You already have one of those global associative caches in the `Homset` constructor.\n\n> \n> I see. Hmmm. There is one important difference to Homsets: If you only store weak references to the coerce maps, then what would prevent them from being immediately garbage collected? In the case of Homsets, it is the elements that prevents them from being garbage collected. Hence, having a fully weak cache does make sense.\n\nYes, that's why one still needs the strong references in `_coerce_from` or `_coerce_to`. It just unlinks the responsibility of keeping the map alive from the ability to find it, given domain and codomain. If you can make your idea work, you won't need it. But I'll keep my sceptical position for now (either justified or for the sake of constructive argument, we'll see).\n\n> Again, I am not talking about \"returning copies\".\n\nAnd that's where you'll get big trouble from. If you're going to return strong versions of maps stored in the coercion system, you have to make those copies. Otherwise, there's nothing that tracks the lifetimes properly.",
    "created_at": "2013-09-30T19:49:00Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181451",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:43'></a>
Replying to [SimonKing](#comment%3A42):
> Hi Nils,
> 
> Replying to [nbruin](#comment%3A41):
> > Replying to [SimonKing](#comment%3A40):
> > > No idea what you are talking about here. "Protocol" in the sense of "interface"?

> > 
> > Protocol as in "how to use the interface properly". In this case the protocol would include: keep strong references to domain and codomain for as long as you're keeping a reference to the the map.

> 
> You mean: Of the homset. If you create a map, then it's fine.

No, also for the map, if I understand your proposal correctly. If I keep a reference to just a map, I'd expect it to keep the domain and codomain alive as well (i.e., the semantics of a map with `_make_strong_references`; the only type of map that should be allowed to escape into the wild).

> Admittedly, I am not totally happy with letting Hom be with weak references from the very beginning. What I could imagine, though: Let it be strong in the beginning; but change `Homset.__call__` so that it first replaces the strong by a weak reference *in the homset*. Namely, maps (i.e., the things returned by `__call__`!) will then have the burden to carry strong references to domain and codomain.

But that responsibility would fall back onto the homset once the last reference to a map has been lost. You wouldn't know when that would happen. Do the maps in the coercion framework really need a Homset? Perhaps you can just leave that blank if you have `_use_weak_references`.

> What about renaming `coerce_map_from()` into `_cm_coerce_map_from()`? It would not be part of the official interface (since it is an underscore method) and hence is entitled to return something that only makes sense when used within the coercion model. We could then define
> 
> ```python
> def coerce_map_from(self, P):
>     phi = self._cm_coerce_map_from(P)
>     if phi is None:
>         return
>     phi._make_strong_references()
>     return phi
> ```
> returning a map with strengthened references (note: I am not speaking about a copy). So, this would be the "official" way to get a "safe" map from an unsafe internally used coercion.

That leaves you with a memory leak again: After asking for a `coerce_map`, the map stored in the coercion framework now has strong references again, even after I discard my requested `coerce_map`.

> > No, I said "fully weak", i.e., also with weak values. You already have one of those global associative caches in the `Homset` constructor.

> 
> I see. Hmmm. There is one important difference to Homsets: If you only store weak references to the coerce maps, then what would prevent them from being immediately garbage collected? In the case of Homsets, it is the elements that prevents them from being garbage collected. Hence, having a fully weak cache does make sense.

Yes, that's why one still needs the strong references in `_coerce_from` or `_coerce_to`. It just unlinks the responsibility of keeping the map alive from the ability to find it, given domain and codomain. If you can make your idea work, you won't need it. But I'll keep my sceptical position for now (either justified or for the sake of constructive argument, we'll see).

> Again, I am not talking about "returning copies".

And that's where you'll get big trouble from. If you're going to return strong versions of maps stored in the coercion system, you have to make those copies. Otherwise, there's nothing that tracks the lifetimes properly.



---

archive/issue_comments_181452.json:
```json
{
    "body": "<a id='comment:44'></a>\nReplying to [nbruin](#comment%3A43):\n> But that responsibility would fall back onto the homset once the last reference to a map has been lost. You wouldn't know when that would happen. Do the maps in the coercion framework really need a Homset? Perhaps you can just leave that blank if you have `_use_weak_references`.\n\nThis could actually be a good idea that would allow to preserve the strong references of Homsets to domain and codomain. I originally hesitated to have `Map._parent=None` for maps that are in the coercion framework, because maps are elements and thus should have parents. But the parent could easily be reconstructed, provided that domain and codomain of the coerce map are still alive. And it *will* be alive if we access the map, because accessing it only works if we have the domain and codomain in our hands.",
    "created_at": "2013-09-30T21:02:03Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181452",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:44'></a>
Replying to [nbruin](#comment%3A43):
> But that responsibility would fall back onto the homset once the last reference to a map has been lost. You wouldn't know when that would happen. Do the maps in the coercion framework really need a Homset? Perhaps you can just leave that blank if you have `_use_weak_references`.

This could actually be a good idea that would allow to preserve the strong references of Homsets to domain and codomain. I originally hesitated to have `Map._parent=None` for maps that are in the coercion framework, because maps are elements and thus should have parents. But the parent could easily be reconstructed, provided that domain and codomain of the coerce map are still alive. And it *will* be alive if we access the map, because accessing it only works if we have the domain and codomain in our hands.



---

archive/issue_comments_181453.json:
```json
{
    "body": "<a id='comment:45'></a>\nWith the following done, Sage starts:\n- Having the usual strong references of homsets to domain and codomain.\n- Having maps by default as \"usual\" elements with strong references to domain and codomain.\n- `self._parent=None` for maps registered by the coercion model, overriding the `self.parent()` method by something that tries to reconstruct the parent from domain and codomain.\n\nMoreover, it fixes the memleak:\n\n```\nsage: Q = QuadraticField(-5)\nsage: C = Q.__class__.__base__\nsage: import gc\nsage: _ = gc.collect()\nsage: numberQuadFields = len([x for x in gc.get_objects() if isinstance(x, C)])\nsage: del Q\nsage: _ = gc.collect()\nsage: numberQuadFields == len([x for x in gc.get_objects() if isinstance(x, C)]) + 1\nTrue\n```\n\nGranted, it is possible to get a map in an invalid state (at least with the not-yet-posted version of my branch):\n\n```\nsage: Q = QuadraticField(-5)\nsage: phi = CDF.convert_map_from(Q)\nsage: del Q\nsage: _ = gc.collect()\nsage: phi.parent()\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n<ipython-input-14-5708ddd58791> in <module>()\n----> 1 phi.parent()\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/categories/map.so in sage.categories.map.Map.parent (sage/categories/map.c:3023)()\n\nValueError: This map is in an invalid state, domain or codomain have been garbage collected\n```\n\nBut the question is: Is there any way to make Q garbage collectable in the first example but not collectable in the second example?",
    "created_at": "2013-09-30T21:56:08Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181453",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:45'></a>
With the following done, Sage starts:
- Having the usual strong references of homsets to domain and codomain.
- Having maps by default as "usual" elements with strong references to domain and codomain.
- `self._parent=None` for maps registered by the coercion model, overriding the `self.parent()` method by something that tries to reconstruct the parent from domain and codomain.

Moreover, it fixes the memleak:

```
sage: Q = QuadraticField(-5)
sage: C = Q.__class__.__base__
sage: import gc
sage: _ = gc.collect()
sage: numberQuadFields = len([x for x in gc.get_objects() if isinstance(x, C)])
sage: del Q
sage: _ = gc.collect()
sage: numberQuadFields == len([x for x in gc.get_objects() if isinstance(x, C)]) + 1
True
```

Granted, it is possible to get a map in an invalid state (at least with the not-yet-posted version of my branch):

```
sage: Q = QuadraticField(-5)
sage: phi = CDF.convert_map_from(Q)
sage: del Q
sage: _ = gc.collect()
sage: phi.parent()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-14-5708ddd58791> in <module>()
----> 1 phi.parent()

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/categories/map.so in sage.categories.map.Map.parent (sage/categories/map.c:3023)()

ValueError: This map is in an invalid state, domain or codomain have been garbage collected
```

But the question is: Is there any way to make Q garbage collectable in the first example but not collectable in the second example?



---

archive/issue_comments_181454.json:
```json
{
    "body": "<a id='comment:46'></a>\nReplying to [SimonKing](#comment%3A45):\n\n> ```\n> sage: Q = QuadraticField(-5)\n> sage: phi = CDF.convert_map_from(Q)\n> sage: del Q\n> sage: _ = gc.collect()\n> sage: phi.parent()\n> ValueError: This map is in an invalid state, domain or codomain have been garbage collected\n> ```\n> \n> But the question is: Is there any way to make Q garbage collectable in the first example but not collectable in the second example?\n\nYes of course. `CDF.convert_map_from(Q)` should return a copy equivalent to `phi` with strong references to domain and codomain. If the original `phi` is a composition of \"weak\" (coercion generated) maps then all the components of the returned `phi` should also be strengthened copies.\n\nNote that the full story should be\n\n```\nsage: Q = QuadraticField(-5)\nsage: phi = CDF.convert_map_from(Q)\nsage: del Q\nsage: _ = gc.collect() #Q is kept alive due to phi\nsage: phi.parent() is not None\nTrue\nsage: del phi\nsage: _ = gc.collect() #now Q gets collected.\n```\n\nIt means that getting safe maps out of the coercion framework is relatively expensive business, and it means that maps dwelling there must have some concept of how to make a copy of themselves. It can be fairly high level: we just need a container that can have fresh `_domain,_codomain,_parent` slots to reference strongly what's only reffed weakly (or not at all) on the maps internal to coercion.\n\nI hope this can all happen without incurring too much performance loss: the weak reference checking and Homspace reconstruction could end up being slow(ish) in the coercion framework if those operations are done too often.",
    "created_at": "2013-09-30T23:05:09Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181454",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:46'></a>
Replying to [SimonKing](#comment%3A45):

> ```
> sage: Q = QuadraticField(-5)
> sage: phi = CDF.convert_map_from(Q)
> sage: del Q
> sage: _ = gc.collect()
> sage: phi.parent()
> ValueError: This map is in an invalid state, domain or codomain have been garbage collected
> ```
> 
> But the question is: Is there any way to make Q garbage collectable in the first example but not collectable in the second example?

Yes of course. `CDF.convert_map_from(Q)` should return a copy equivalent to `phi` with strong references to domain and codomain. If the original `phi` is a composition of "weak" (coercion generated) maps then all the components of the returned `phi` should also be strengthened copies.

Note that the full story should be

```
sage: Q = QuadraticField(-5)
sage: phi = CDF.convert_map_from(Q)
sage: del Q
sage: _ = gc.collect() #Q is kept alive due to phi
sage: phi.parent() is not None
True
sage: del phi
sage: _ = gc.collect() #now Q gets collected.
```

It means that getting safe maps out of the coercion framework is relatively expensive business, and it means that maps dwelling there must have some concept of how to make a copy of themselves. It can be fairly high level: we just need a container that can have fresh `_domain,_codomain,_parent` slots to reference strongly what's only reffed weakly (or not at all) on the maps internal to coercion.

I hope this can all happen without incurring too much performance loss: the weak reference checking and Homspace reconstruction could end up being slow(ish) in the coercion framework if those operations are done too often.



---

archive/issue_comments_181455.json:
```json
{
    "body": "<a id='comment:47'></a>\nJust a random thought about the coerce_to construction using strong references: we really have to make sure to pay attention to things like coercions from ZZ to GF(p) which could make finite fields live forever (once again).",
    "created_at": "2013-10-01T12:17:18Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181455",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:47'></a>
Just a random thought about the coerce_to construction using strong references: we really have to make sure to pay attention to things like coercions from ZZ to GF(p) which could make finite fields live forever (once again).



---

archive/issue_comments_181456.json:
```json
{
    "body": "<a id='comment:48'></a>\nConcerning a generic copy method for maps: It is of course possible to provide a generic method that takes care of all data in the `__dict__` and all slots common to maps (namels: those of Element plus domain and codomain). Everything else should be done in the subclasses.\n\nThe code I am experimenting with results in some crashes, I am afraid. Hopefully I will be able to fix this.",
    "created_at": "2013-10-01T13:43:04Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181456",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:48'></a>
Concerning a generic copy method for maps: It is of course possible to provide a generic method that takes care of all data in the `__dict__` and all slots common to maps (namels: those of Element plus domain and codomain). Everything else should be done in the subclasses.

The code I am experimenting with results in some crashes, I am afraid. Hopefully I will be able to fix this.



---

archive/issue_comments_181457.json:
```json
{
    "body": "<a id='comment:49'></a>\nExample of a crash:\n\n```\nsage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]; s                                        \n{-1/9, 0}\nsage: loads(dumps(s)) == s\nTrue\nsage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]\n<BOOOM>\n```",
    "created_at": "2013-10-01T13:46:01Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181457",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:49'></a>
Example of a crash:

```
sage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]; s                                        
{-1/9, 0}
sage: loads(dumps(s)) == s
True
sage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]
<BOOOM>
```



---

archive/issue_comments_181458.json:
```json
{
    "body": "<a id='comment:50'></a>\nOoops! That's odd:\n\n```\nsage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]\nsage: f, (a,b,c), D = s.__reduce__()\nsage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]\nsage: D['_ModularSymbol__space']\nManin Symbol List of weight 2 for Gamma0(11)\nsage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]\n<BOOOM>\n```\nSo, printing the \"Manin Symbol List\" is enough to trigger the crash. Very bad.",
    "created_at": "2013-10-01T14:08:37Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181458",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:50'></a>
Ooops! That's odd:

```
sage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]
sage: f, (a,b,c), D = s.__reduce__()
sage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]
sage: D['_ModularSymbol__space']
Manin Symbol List of weight 2 for Gamma0(11)
sage: s = ModularSymbols(11).2.modular_symbol_rep()[0][1]
<BOOOM>
```
So, printing the "Manin Symbol List" is enough to trigger the crash. Very bad.



---

archive/issue_comments_181459.json:
```json
{
    "body": "<a id='comment:51'></a>\nSorry, reduction is not to blame. Doing a garbage collection after the first line and then repeating the first line reproduces the crash. Hence, some parent is not correctly kept alive. Anyway, you can't see it, since I didn't post the code yet...",
    "created_at": "2013-10-01T14:13:56Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181459",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:51'></a>
Sorry, reduction is not to blame. Doing a garbage collection after the first line and then repeating the first line reproduces the crash. Hence, some parent is not correctly kept alive. Anyway, you can't see it, since I didn't post the code yet...



---

archive/issue_comments_181460.json:
```json
{
    "body": "<a id='comment:52'></a>\nReplying to [nbruin](#comment%3A46):\n> Yes of course. `CDF.convert_map_from(Q)` should return a copy equivalent to `phi` with strong references to domain and codomain. If the original `phi` is a composition of \"weak\" (coercion generated) maps then all the components of the returned `phi` should also be strengthened copies.\n\nIn other words, you do think that we should distinguish between underscore methods that are used internally in the coercion system and just return the maps, and an \"official\" interface that returns strong copies. Do I understand correctly?\n\nConcerning compositions, I agree that the parent in the middle should be kept alive by the composed map (even if this map is in the coercion system, hence, domain and codomain are only weakly referenced): If the composed map is kept in memory, then we need to be able to apply the composition, and hence the \"man in the middle\" needs to be available.",
    "created_at": "2013-10-01T15:03:58Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181460",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:52'></a>
Replying to [nbruin](#comment%3A46):
> Yes of course. `CDF.convert_map_from(Q)` should return a copy equivalent to `phi` with strong references to domain and codomain. If the original `phi` is a composition of "weak" (coercion generated) maps then all the components of the returned `phi` should also be strengthened copies.

In other words, you do think that we should distinguish between underscore methods that are used internally in the coercion system and just return the maps, and an "official" interface that returns strong copies. Do I understand correctly?

Concerning compositions, I agree that the parent in the middle should be kept alive by the composed map (even if this map is in the coercion system, hence, domain and codomain are only weakly referenced): If the composed map is kept in memory, then we need to be able to apply the composition, and hence the "man in the middle" needs to be available.



---

archive/issue_comments_181461.json:
```json
{
    "body": "<a id='comment:53'></a>\nReplying to [SimonKing](#comment%3A52):\n> In other words, you do think that we should distinguish between underscore methods that are used internally in the coercion system and just return the maps, and an \"official\" interface that returns strong copies. Do I understand correctly?\n\nYes, with your approach the maps stored and used in the internals of the coercion systems are not able to stay healthy on their own. They can only survive within a controlled environment. So you cannot let those maps escape into the wild (the royal society for prevention of cruelty to maps would probably have you arrested). I don't see another solution than making a version that is better prepared for the outside world.\n\n> Concerning compositions, I agree that the parent in the middle should be kept alive by the composed map (even if this map is in the coercion system, hence, domain and codomain are only weakly referenced): If the composed map is kept in memory, then we need to be able to apply the composition, and hence the \"man in the middle\" needs to be available.\n\nYes, you are correct. You might want to check if compositions do tend to occur in the coercion system. They would be quite painful to work with. The natural way of constructing them would be to have a containing map type with `_domain,_codomain,_parent` set appropriately, together with a sequence of maps. Those maps would normally be normal, healthy maps with their own strong references to their domains and codomains: a composition would hence carry internally a strong reference to both its domain and codomain (due to the first and last map in the sequence).\n\nThe generic way of making a \"weak\" version of a map would still lead to a map that (internally) keeps strong references to domain and codomain. You'd have to make a custom way of weakening this map. Would you weaken the first and last map in the sequence? Then for a composition of two maps, you'd have to separately keep a reference to the middle (co)domain. Or would you have half-weakened maps as well, that only have a weaked domain or codomain?\n\nThat makes me realize a further complication: the copying probably has to happen both ways. \nBefore you prepare a map to become part of the coercion system, you'd have to make sure that the map you're holding is not referenced by anyone outside. Thus, you'd have to make sure that either the origin of the map is guaranteed (it's not a map that is referenced elsewhere--I think this will be impossible to verify in practice, since users can register arbitrary maps as coercions) or you have to make a copy before weakening it (if weakening is an in-place operation, as you proposed above), further upping the cost of coercion discovery. Otherwise, registering a coercion might have the side-effect of weakening a map that someone else is holding already.\n\n(these are the kind of snowballing complications I was afraid of by making a separate type of map suitable for the coercion system)",
    "created_at": "2013-10-01T16:09:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181461",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:53'></a>
Replying to [SimonKing](#comment%3A52):
> In other words, you do think that we should distinguish between underscore methods that are used internally in the coercion system and just return the maps, and an "official" interface that returns strong copies. Do I understand correctly?

Yes, with your approach the maps stored and used in the internals of the coercion systems are not able to stay healthy on their own. They can only survive within a controlled environment. So you cannot let those maps escape into the wild (the royal society for prevention of cruelty to maps would probably have you arrested). I don't see another solution than making a version that is better prepared for the outside world.

> Concerning compositions, I agree that the parent in the middle should be kept alive by the composed map (even if this map is in the coercion system, hence, domain and codomain are only weakly referenced): If the composed map is kept in memory, then we need to be able to apply the composition, and hence the "man in the middle" needs to be available.

Yes, you are correct. You might want to check if compositions do tend to occur in the coercion system. They would be quite painful to work with. The natural way of constructing them would be to have a containing map type with `_domain,_codomain,_parent` set appropriately, together with a sequence of maps. Those maps would normally be normal, healthy maps with their own strong references to their domains and codomains: a composition would hence carry internally a strong reference to both its domain and codomain (due to the first and last map in the sequence).

The generic way of making a "weak" version of a map would still lead to a map that (internally) keeps strong references to domain and codomain. You'd have to make a custom way of weakening this map. Would you weaken the first and last map in the sequence? Then for a composition of two maps, you'd have to separately keep a reference to the middle (co)domain. Or would you have half-weakened maps as well, that only have a weaked domain or codomain?

That makes me realize a further complication: the copying probably has to happen both ways. 
Before you prepare a map to become part of the coercion system, you'd have to make sure that the map you're holding is not referenced by anyone outside. Thus, you'd have to make sure that either the origin of the map is guaranteed (it's not a map that is referenced elsewhere--I think this will be impossible to verify in practice, since users can register arbitrary maps as coercions) or you have to make a copy before weakening it (if weakening is an in-place operation, as you proposed above), further upping the cost of coercion discovery. Otherwise, registering a coercion might have the side-effect of weakening a map that someone else is holding already.

(these are the kind of snowballing complications I was afraid of by making a separate type of map suitable for the coercion system)



---

archive/issue_comments_181462.json:
```json
{
    "body": "<a id='comment:54'></a>\nReplying to [nbruin](#comment%3A53):\n> > Concerning compositions, I agree that the parent in the middle should be kept alive by the composed map (even if this map is in the coercion system, hence, domain and codomain are only weakly referenced): If the composed map is kept in memory, then we need to be able to apply the composition, and hence the \"man in the middle\" needs to be available.\n\n> \n> Yes, you are correct. You might want to check if compositions do tend to occur in the coercion system.\n\nThey do frequently occur, because coercions are found by some kind of backtracking algorithm. But, somehow surprisingly, I don't got the impression that the crashes I am observing come from this.\n\nAnyway, I agree that one should have a strong reference in the middle.\n\n> The generic way of making a \"weak\" version of a map would still lead to a map that (internally) keeps strong references to domain and codomain. \n\nNo. You would have weak reference to the domain and codomain, but a strong reference to the middle. A `FormalCompositeMap`, by the way, stores two maps `__first` and `__second`, and in my current experimental code I simply make `__first.codomain` a constant function (if it isn't already).\n\nIt *could* in principle mean that the composite map gets deallocated, while `__first` stays somewhere else in the coercion system, and now keeps a parent (namely the middle one) alive that may be collectable. I'll worry about it later...\n\n> That makes me realize a further complication: the copying probably has to happen both ways. \n> Before you prepare a map to become part of the coercion system, you'd have to make sure that the map you're holding is not referenced by anyone outside. Thus, you'd have to make sure that either the origin of the map is guaranteed (it's not a map that is referenced elsewhere--I think this will be impossible to verify in practice, since users can register arbitrary maps as coercions)\n\nI think the (unwritten, I am afraid) contract is that `register_coercion()` is only called in `__init__`. So, perhaps it should rather be `_register_coercion()`, to remove it from the user interface.",
    "created_at": "2013-10-01T16:22:17Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181462",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:54'></a>
Replying to [nbruin](#comment%3A53):
> > Concerning compositions, I agree that the parent in the middle should be kept alive by the composed map (even if this map is in the coercion system, hence, domain and codomain are only weakly referenced): If the composed map is kept in memory, then we need to be able to apply the composition, and hence the "man in the middle" needs to be available.

> 
> Yes, you are correct. You might want to check if compositions do tend to occur in the coercion system.

They do frequently occur, because coercions are found by some kind of backtracking algorithm. But, somehow surprisingly, I don't got the impression that the crashes I am observing come from this.

Anyway, I agree that one should have a strong reference in the middle.

> The generic way of making a "weak" version of a map would still lead to a map that (internally) keeps strong references to domain and codomain. 

No. You would have weak reference to the domain and codomain, but a strong reference to the middle. A `FormalCompositeMap`, by the way, stores two maps `__first` and `__second`, and in my current experimental code I simply make `__first.codomain` a constant function (if it isn't already).

It *could* in principle mean that the composite map gets deallocated, while `__first` stays somewhere else in the coercion system, and now keeps a parent (namely the middle one) alive that may be collectable. I'll worry about it later...

> That makes me realize a further complication: the copying probably has to happen both ways. 
> Before you prepare a map to become part of the coercion system, you'd have to make sure that the map you're holding is not referenced by anyone outside. Thus, you'd have to make sure that either the origin of the map is guaranteed (it's not a map that is referenced elsewhere--I think this will be impossible to verify in practice, since users can register arbitrary maps as coercions)

I think the (unwritten, I am afraid) contract is that `register_coercion()` is only called in `__init__`. So, perhaps it should rather be `_register_coercion()`, to remove it from the user interface.



---

archive/issue_comments_181463.json:
```json
{
    "body": "<a id='comment:55'></a>\nReplying to [SimonKing](#comment%3A54):\n\n> I think the (unwritten, I am afraid) contract is that `register_coercion()` is only called in `__init__`. So, perhaps it should rather be `_register_coercion()`, to remove it from the user interface.\n\nAbsolutely not! I think it's a very important feature that coercions can be discovered \"lazily\", i.e., be registered after the fact. It also means (but this is just a fact of life) that, while parents are supposed to be immutable, their relations in the (global state)! coercion graph can evolve over time.\nYou could of course have a `_register_coercion` for internal use that mandates being passed a map with the promise no-one else will keep a reference to that map, but I'm pretty sure we have to keep an advertised `register_coercion`. You could ask sage-devel, of course.\n\nAt some point there was even an idea to have a context manager to temporarily modify the coercion graph:\n\n```\nK=QuadraticField(3)\nwith coercion(K.real_embeddings()[0]):\n    print 1+K.0\n```\nleading to `-0.732050807568877` (assuming the first embedding is the negative one).\nFor basic computations these things are not so essential, but by the time you're a couple levels deep, e.g., you want to compute the archimedean period matrices of some abelian variety defined over a number field, letting the coercion framework to the required conversions might be the only quick way to actually get your data in the right ring. I think we don't want to take away that possibility.",
    "created_at": "2013-10-01T16:58:47Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181463",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:55'></a>
Replying to [SimonKing](#comment%3A54):

> I think the (unwritten, I am afraid) contract is that `register_coercion()` is only called in `__init__`. So, perhaps it should rather be `_register_coercion()`, to remove it from the user interface.

Absolutely not! I think it's a very important feature that coercions can be discovered "lazily", i.e., be registered after the fact. It also means (but this is just a fact of life) that, while parents are supposed to be immutable, their relations in the (global state)! coercion graph can evolve over time.
You could of course have a `_register_coercion` for internal use that mandates being passed a map with the promise no-one else will keep a reference to that map, but I'm pretty sure we have to keep an advertised `register_coercion`. You could ask sage-devel, of course.

At some point there was even an idea to have a context manager to temporarily modify the coercion graph:

```
K=QuadraticField(3)
with coercion(K.real_embeddings()[0]):
    print 1+K.0
```
leading to `-0.732050807568877` (assuming the first embedding is the negative one).
For basic computations these things are not so essential, but by the time you're a couple levels deep, e.g., you want to compute the archimedean period matrices of some abelian variety defined over a number field, letting the coercion framework to the required conversions might be the only quick way to actually get your data in the right ring. I think we don't want to take away that possibility.



---

archive/issue_comments_181464.json:
```json
{
    "body": "<a id='comment:56'></a>\nReplying to [SimonKing](#comment%3A54):\n\n> It *could* in principle mean that the composite map gets deallocated, while `__first` stays somewhere else in the coercion system, and now keeps a parent (namely the middle one) alive that may be collectable. I'll worry about it later...\n\nHm. Any time you have different versions of the same map that may diverge in the strength with which they refer to one of their domain, codomain, parent, etc., you'll need to make a copy to accommodate the divergence in strength. So it probably makes sense to only have two levels: either domain,codomain, and parent are referenced strongly or domain and codomain are referenced weakly (and probably there's no reference to parent at all).\n\nThat means that \"weak\" map compositions in the coercion system need to have a strong reference to the middle domain. That shouldn't be too bad.\n\nApart from possible efficiency problems, I think this idea can be made to work. The main programming penalty is the added burden on writing new map classes: maps must be able to generate a copy of themselves. You could make this optional: maps unable to copy themselves would be just stored as-is in the coercion framework, with all the memory leak consequences this has. If it's cheap to figure out if maps are weak and/or are capable of generating a weak/strong version of themselves, we could just accommodate both: If a \"weakened\" map arrives into the coercion framework it can just be used as-is. If a normal map arrives, we see if it can be weakened. If so, we make a weakened copy and store that. Otherwise the map is used as-is.\n\nIf a map is about to be passed out of the coercion framework, we check if it's weakened. If not, we can just give out the map itself. Otherwise, we make a strengthened copy and give that. If making a strengthened copy is not possible, we'd have to raise an error.\n\nOf course the main point whether this is acceptable is whether it can be done with little to no increase to overhead compared to now. Costs come at two points\n- map access: domain and codomain must always be accessed via the methods rather than the (lightning fast) cdeffed attributes _domain and _codomain, since they may be stored via weakref or not. Coercion lookup itself shouldn't really be affected, but coercion application might. If the parent of coercion maps is accessed in the process, we might see a slowdown due to that too.\n- coercion discovery and registration: This will likely involve copying maps now, so this might slow down considerably. This shouldn't really be an inner loop operation, but it may affect things: multimodular algorithms may create lots of, say, matrix rings over finite fields. The computation itself may be relatively cheap, so the construction of the parent and the registration of its coercions may be a significant part of the total cost.\n\nI guess the only way to see whether this is worth it is by trying. At least the semantics are clear. I find it a little scary to weigh down the entire interface for \"Maps\" but if we can make it opt-in it's perhaps not too much of a burden. (We could just gradually upgrade map classes to be \"weakenable\" as we find them to be responsible for memory leaks)",
    "created_at": "2013-10-01T18:32:59Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181464",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:56'></a>
Replying to [SimonKing](#comment%3A54):

> It *could* in principle mean that the composite map gets deallocated, while `__first` stays somewhere else in the coercion system, and now keeps a parent (namely the middle one) alive that may be collectable. I'll worry about it later...

Hm. Any time you have different versions of the same map that may diverge in the strength with which they refer to one of their domain, codomain, parent, etc., you'll need to make a copy to accommodate the divergence in strength. So it probably makes sense to only have two levels: either domain,codomain, and parent are referenced strongly or domain and codomain are referenced weakly (and probably there's no reference to parent at all).

That means that "weak" map compositions in the coercion system need to have a strong reference to the middle domain. That shouldn't be too bad.

Apart from possible efficiency problems, I think this idea can be made to work. The main programming penalty is the added burden on writing new map classes: maps must be able to generate a copy of themselves. You could make this optional: maps unable to copy themselves would be just stored as-is in the coercion framework, with all the memory leak consequences this has. If it's cheap to figure out if maps are weak and/or are capable of generating a weak/strong version of themselves, we could just accommodate both: If a "weakened" map arrives into the coercion framework it can just be used as-is. If a normal map arrives, we see if it can be weakened. If so, we make a weakened copy and store that. Otherwise the map is used as-is.

If a map is about to be passed out of the coercion framework, we check if it's weakened. If not, we can just give out the map itself. Otherwise, we make a strengthened copy and give that. If making a strengthened copy is not possible, we'd have to raise an error.

Of course the main point whether this is acceptable is whether it can be done with little to no increase to overhead compared to now. Costs come at two points
- map access: domain and codomain must always be accessed via the methods rather than the (lightning fast) cdeffed attributes _domain and _codomain, since they may be stored via weakref or not. Coercion lookup itself shouldn't really be affected, but coercion application might. If the parent of coercion maps is accessed in the process, we might see a slowdown due to that too.
- coercion discovery and registration: This will likely involve copying maps now, so this might slow down considerably. This shouldn't really be an inner loop operation, but it may affect things: multimodular algorithms may create lots of, say, matrix rings over finite fields. The computation itself may be relatively cheap, so the construction of the parent and the registration of its coercions may be a significant part of the total cost.

I guess the only way to see whether this is worth it is by trying. At least the semantics are clear. I find it a little scary to weigh down the entire interface for "Maps" but if we can make it opt-in it's perhaps not too much of a burden. (We could just gradually upgrade map classes to be "weakenable" as we find them to be responsible for memory leaks)



---

archive/issue_comments_181465.json:
```json
{
    "body": "<a id='comment:57'></a>\nI just found something crazy: Apparently the rational field got garbage collected in one of the crashing examples. Hard to believe. But it is in something using modular symbols, which is very old code, predating the unique parent paradigma. So, could be that it calls the constructor of the rational field, rather than a factory or whatever makes the rational field unique.",
    "created_at": "2013-10-01T20:58:29Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181465",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:57'></a>
I just found something crazy: Apparently the rational field got garbage collected in one of the crashing examples. Hard to believe. But it is in something using modular symbols, which is very old code, predating the unique parent paradigma. So, could be that it calls the constructor of the rational field, rather than a factory or whatever makes the rational field unique.



---

archive/issue_comments_181466.json:
```json
{
    "body": "<a id='comment:58'></a>\nReplying to [SimonKing](#comment%3A57):\n> I just found something crazy: Apparently the rational field got garbage collected in one of the crashing examples. Hard to believe.\n\nFortunately I was mistaken: It is only the case that the `__init__` method is called repeatedly on the same object `QQ` if you call `RationalField()` repeatedly. Namely, it is not using a classcall metaclass, but does the caching in `__new__`---but `__init__` is always called after `__new__`, whether it is cached or not. That's one of the reasons for introducing classcall metaclass.",
    "created_at": "2013-10-01T21:05:58Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181466",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:58'></a>
Replying to [SimonKing](#comment%3A57):
> I just found something crazy: Apparently the rational field got garbage collected in one of the crashing examples. Hard to believe.

Fortunately I was mistaken: It is only the case that the `__init__` method is called repeatedly on the same object `QQ` if you call `RationalField()` repeatedly. Namely, it is not using a classcall metaclass, but does the caching in `__new__`---but `__init__` is always called after `__new__`, whether it is cached or not. That's one of the reasons for introducing classcall metaclass.



---

archive/issue_comments_181467.json:
```json
{
    "body": "<a id='comment:59'></a>\nPerhaps it would be a good idea to change `RationalField` to use `ClasscallMetaclass`, but of course on a new ticket. Anyway, it is not related to the problem here.",
    "created_at": "2013-10-01T21:22:20Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181467",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:59'></a>
Perhaps it would be a good idea to change `RationalField` to use `ClasscallMetaclass`, but of course on a new ticket. Anyway, it is not related to the problem here.



---

archive/issue_comments_181468.json:
```json
{
    "body": "<a id='comment:60'></a>\nReplying to [SimonKing](#comment%3A59):\n> Perhaps it would be a good idea to change `RationalField` to use `ClasscallMetaclass`, but of course on a new ticket.\n\nI created #15247",
    "created_at": "2013-10-01T22:46:23Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181468",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:60'></a>
Replying to [SimonKing](#comment%3A59):
> Perhaps it would be a good idea to change `RationalField` to use `ClasscallMetaclass`, but of course on a new ticket.

I created #15247



---

archive/issue_comments_181469.json:
```json
{
    "body": "<a id='comment:61'></a>\nToo bad. The idea as suggested doesn't actually solve the memory leak; it just makes it less severe (by a constant factor). The problem is: The weakened maps don't prevent their domain from being GCed, but after than happens they linger (now defunct) in `_coerce_from`. You'll see that even with your patch in, the example in the ticket description will still eat memory--just a little less quickly. You'll find that `CDF._coerce_from_hash` will contain a LOT of entries.\n\nIf we were to use a mix of `_coerce_from` and `_coerce_to` (somehow choosing which one to use) you wouldn't see this problem.\n\nIf we really want/need to, we could probably salvage the \"weakened map\" solution:\n- we could install a callback on the weakrefs. Note that the callback would have to be delivered to the codomain, so we wouldn't really have \"weakened maps\" as objects on their own: the callback on the weakref would make them specific to the data structure in which they reside. There is also the usual problem that weakref callback if very critical and we'd have to be very careful what we do there.\n- defunct maps are easy to recognize: they have a dead weakref in their domain. We could just periodically scrub `_coerce_from` for defunct maps. One possible strategy would be to keep a \"reference size\" for `_coerce_from` and every time we add an entry we check if it is now double the reference size. If it is, we trigger gc, scrub, and reset the reference size. This would at least keep the list bounded in size and hopefully limit the number of expensive scrubs we have to do (treating the bounds exponentially should lead to small amortized costs)",
    "created_at": "2013-10-02T03:11:20Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181469",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:61'></a>
Too bad. The idea as suggested doesn't actually solve the memory leak; it just makes it less severe (by a constant factor). The problem is: The weakened maps don't prevent their domain from being GCed, but after than happens they linger (now defunct) in `_coerce_from`. You'll see that even with your patch in, the example in the ticket description will still eat memory--just a little less quickly. You'll find that `CDF._coerce_from_hash` will contain a LOT of entries.

If we were to use a mix of `_coerce_from` and `_coerce_to` (somehow choosing which one to use) you wouldn't see this problem.

If we really want/need to, we could probably salvage the "weakened map" solution:
- we could install a callback on the weakrefs. Note that the callback would have to be delivered to the codomain, so we wouldn't really have "weakened maps" as objects on their own: the callback on the weakref would make them specific to the data structure in which they reside. There is also the usual problem that weakref callback if very critical and we'd have to be very careful what we do there.
- defunct maps are easy to recognize: they have a dead weakref in their domain. We could just periodically scrub `_coerce_from` for defunct maps. One possible strategy would be to keep a "reference size" for `_coerce_from` and every time we add an entry we check if it is now double the reference size. If it is, we trigger gc, scrub, and reset the reference size. This would at least keep the list bounded in size and hopefully limit the number of expensive scrubs we have to do (treating the bounds exponentially should lead to small amortized costs)



---

archive/issue_comments_181470.json:
```json
{
    "body": "<a id='comment:62'></a>\nI have pushed my branch. I wonder why this did not show up as a post on trac. Anyway, I checked that when clicking on \"Commits\" then everything is there.\n\nI hesitated to push it before, because it is not ready for review. However, it would be better if we'd all agree what code we are talking about.\n\nReplying to [nbruin](#comment%3A61):\n> Too bad. The idea as suggested doesn't actually solve the memory leak; it just makes it less severe (by a constant factor).\n\nI think this is not the case with the branch that I have just uploaded. I did\n\n```\nsage: for D in xrange(2,2**30):\n....:    print get_memory_usage()\n....:    Q = QuadraticField(-D)\n```\nFirst, the memory\u00a0consumption very slowly raised from 213.60546875 to 214.10546875 and then remained steady for several minutes, until I interrupted. And I rather think that the increased consumption was just due to the increased size of D.\n\n> The problem is: The weakened maps don't prevent their domain from being GCed, but after than happens they linger (now defunct) in `_coerce_from`. You'll see that even with your patch in, the example in the ticket description will still eat memory--just a little less quickly. You'll find that `CDF._coerce_from_hash` will contain a LOT of entries.\n\nThis is clearly not the case with the current commit. After running thousands of cycles in the above \"for\" loop, I get\n\n```\nsage: CDF._introspect_coerce()\n{'_action_hash': <sage.structure.coerce_dict.TripleDict at 0xa26b25c>,\n '_action_list': [],\n '_coerce_from_hash': <sage.structure.coerce_dict.MonoDict at 0xa26b3e4>,\n '_coerce_from_list': [],\n '_convert_from_hash': <sage.structure.coerce_dict.MonoDict at 0xa26b41c>,\n '_convert_from_list': [],\n '_element_init_pass_parent': False,\n '_embedding': None,\n '_initial_action_list': [],\n '_initial_coerce_list': [],\n '_initial_convert_list': []}\nsage: gc.collect()\n2213\nsage: for k,v in CDF._introspect_coerce().iteritems():\n    if v:\n        print k, len(v)\n....:         \n_coerce_from_hash 4\n_convert_from_hash 3\n```\n\n> If we were to use a mix of `_coerce_from` and `_coerce_to` (somehow choosing which one to use) you wouldn't see this problem.\n\nI don't see this problem anyway.\n\n> If we really want/need to, we could probably salvage the \"weakened map\" solution:\n> - we could install a callback on the weakrefs.\n\nWhat weakrefs are you talking about? Those to domain and codomain?\n\nAnd what would the callback be supposed to do?\n\n> - defunct maps are easy to recognize: they have a dead weakref in their domain. We could just periodically scrub `_coerce_from` for defunct maps.\n\nWell, with the current commit, if a map becomes defunct by some garbage collection then it is removed from the `_coerce_from_hash` by *the same* garbage collection, hence, it will not linger around.\n\nA different story is `_coerce_from_list`, which is a list. Here, we might need to take care of defunct maps. Perhaps the maps there shouldn't be weakened in the first place (`_coerce_from_list` is filled by `register_coercion()`, and perhaps it would make sense to keep these maps strong), but I am not sure if this wouldn't re-introduce the `QuadraticField` leak I have just fixed.\n\n> One possible strategy would be to keep a \"reference size\" for `_coerce_from` and every time we add an entry we check if it is now double the reference size. If it is, we trigger gc, scrub, and reset the reference size.\n\nAs I have stated above, I don't think there is a problem with `_coerce_from_hash` accumulating garbage. But `_coerce_from_list` may contain garbage, of limited size, because it is only added to by explicit calls to `register_coercion()`.\n\nI think a better strategy would be to make `discover_coercion` check whether it meets a defunct map when it performs the backtrack algorithm.",
    "created_at": "2013-10-03T10:23:10Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181470",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:62'></a>
I have pushed my branch. I wonder why this did not show up as a post on trac. Anyway, I checked that when clicking on "Commits" then everything is there.

I hesitated to push it before, because it is not ready for review. However, it would be better if we'd all agree what code we are talking about.

Replying to [nbruin](#comment%3A61):
> Too bad. The idea as suggested doesn't actually solve the memory leak; it just makes it less severe (by a constant factor).

I think this is not the case with the branch that I have just uploaded. I did

```
sage: for D in xrange(2,2**30):
....:    print get_memory_usage()
....:    Q = QuadraticField(-D)
```
First, the memory consumption very slowly raised from 213.60546875 to 214.10546875 and then remained steady for several minutes, until I interrupted. And I rather think that the increased consumption was just due to the increased size of D.

> The problem is: The weakened maps don't prevent their domain from being GCed, but after than happens they linger (now defunct) in `_coerce_from`. You'll see that even with your patch in, the example in the ticket description will still eat memory--just a little less quickly. You'll find that `CDF._coerce_from_hash` will contain a LOT of entries.

This is clearly not the case with the current commit. After running thousands of cycles in the above "for" loop, I get

```
sage: CDF._introspect_coerce()
{'_action_hash': <sage.structure.coerce_dict.TripleDict at 0xa26b25c>,
 '_action_list': [],
 '_coerce_from_hash': <sage.structure.coerce_dict.MonoDict at 0xa26b3e4>,
 '_coerce_from_list': [],
 '_convert_from_hash': <sage.structure.coerce_dict.MonoDict at 0xa26b41c>,
 '_convert_from_list': [],
 '_element_init_pass_parent': False,
 '_embedding': None,
 '_initial_action_list': [],
 '_initial_coerce_list': [],
 '_initial_convert_list': []}
sage: gc.collect()
2213
sage: for k,v in CDF._introspect_coerce().iteritems():
    if v:
        print k, len(v)
....:         
_coerce_from_hash 4
_convert_from_hash 3
```

> If we were to use a mix of `_coerce_from` and `_coerce_to` (somehow choosing which one to use) you wouldn't see this problem.

I don't see this problem anyway.

> If we really want/need to, we could probably salvage the "weakened map" solution:
> - we could install a callback on the weakrefs.

What weakrefs are you talking about? Those to domain and codomain?

And what would the callback be supposed to do?

> - defunct maps are easy to recognize: they have a dead weakref in their domain. We could just periodically scrub `_coerce_from` for defunct maps.

Well, with the current commit, if a map becomes defunct by some garbage collection then it is removed from the `_coerce_from_hash` by *the same* garbage collection, hence, it will not linger around.

A different story is `_coerce_from_list`, which is a list. Here, we might need to take care of defunct maps. Perhaps the maps there shouldn't be weakened in the first place (`_coerce_from_list` is filled by `register_coercion()`, and perhaps it would make sense to keep these maps strong), but I am not sure if this wouldn't re-introduce the `QuadraticField` leak I have just fixed.

> One possible strategy would be to keep a "reference size" for `_coerce_from` and every time we add an entry we check if it is now double the reference size. If it is, we trigger gc, scrub, and reset the reference size.

As I have stated above, I don't think there is a problem with `_coerce_from_hash` accumulating garbage. But `_coerce_from_list` may contain garbage, of limited size, because it is only added to by explicit calls to `register_coercion()`.

I think a better strategy would be to make `discover_coercion` check whether it meets a defunct map when it performs the backtrack algorithm.



---

archive/issue_comments_181471.json:
```json
{
    "body": "<a id='comment:63'></a>\nAnyway, here is the problem I am currently having:\n\n```\nsage: E = ModularSymbols(11).2\nsage: s = E.modular_symbol_rep()\nsage: del E,s\nsage: import gc\nsage: gc.collect()\n1309\nsage: E = ModularSymbols(11).2\nsage: v = E.manin_symbol_rep()\nsage: c,x = v[0]\nsage: y = x.modular_symbol_rep()\nsage: y.parent()\nAbelian Group of all Formal Finite Sums over Integer Ring\nsage: A = y.parent().get_action(QQ, self_on_left=False, op=operator.mul)\nsage: A.right_domain()\nAbelian Group of all Formal Finite Sums over Integer Ring\nsage: A.left_domain()\nRational Field\nsage: A.codomain()\nTraceback (most recent call last):\n...\nRuntimeError: This action acted on a set that became garbage collected\n```\n\nHence, If I understand correctly, the \"Formal Finite Sums over Rational Field\" became garbage collected.\n\nAnd that's where action differ from maps:\n\n- In the case of coercion maps, we have domain and codomain, which together are used as weak cache keys for the map. Hence, if either domain or codomain become garbage, then the map becomes invalid but is immediately removed from the cache and will thus not hurt.\n\n- In the case of actions, we have left domain and right domain, which together are used as weak cache keys for the action. However, in addition to the two domains, an action has a codomain, which currently is weak referenced (this was in order to fix some memory leak). If the codomain is distinct from both left and right domain and if the codomain becomes garbage, then the action becomes invalid, but it would NOT be removed from the cache, as long as domain and codomain are no garbage.\n\nI am afraid that having a strong reference to the codomain of all actions will re-introduce a memory leak fixed elsewhere. But in the above analysis, you may notice that there only is a problem if the codomain is distinct from both left and right domain. Hence, we could be clever and have a strong reference to the codomain *only* in this case, and a weak reference otherwise.\n\nI will try this now...",
    "created_at": "2013-10-03T10:42:32Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181471",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:63'></a>
Anyway, here is the problem I am currently having:

```
sage: E = ModularSymbols(11).2
sage: s = E.modular_symbol_rep()
sage: del E,s
sage: import gc
sage: gc.collect()
1309
sage: E = ModularSymbols(11).2
sage: v = E.manin_symbol_rep()
sage: c,x = v[0]
sage: y = x.modular_symbol_rep()
sage: y.parent()
Abelian Group of all Formal Finite Sums over Integer Ring
sage: A = y.parent().get_action(QQ, self_on_left=False, op=operator.mul)
sage: A.right_domain()
Abelian Group of all Formal Finite Sums over Integer Ring
sage: A.left_domain()
Rational Field
sage: A.codomain()
Traceback (most recent call last):
...
RuntimeError: This action acted on a set that became garbage collected
```

Hence, If I understand correctly, the "Formal Finite Sums over Rational Field" became garbage collected.

And that's where action differ from maps:

- In the case of coercion maps, we have domain and codomain, which together are used as weak cache keys for the map. Hence, if either domain or codomain become garbage, then the map becomes invalid but is immediately removed from the cache and will thus not hurt.

- In the case of actions, we have left domain and right domain, which together are used as weak cache keys for the action. However, in addition to the two domains, an action has a codomain, which currently is weak referenced (this was in order to fix some memory leak). If the codomain is distinct from both left and right domain and if the codomain becomes garbage, then the action becomes invalid, but it would NOT be removed from the cache, as long as domain and codomain are no garbage.

I am afraid that having a strong reference to the codomain of all actions will re-introduce a memory leak fixed elsewhere. But in the above analysis, you may notice that there only is a problem if the codomain is distinct from both left and right domain. Hence, we could be clever and have a strong reference to the codomain *only* in this case, and a weak reference otherwise.

I will try this now...



---

archive/issue_comments_181472.json:
```json
{
    "body": "<a id='comment:64'></a>\nI just learnt that the codomain of an action coincides with the set that is acted upon. But here, we have a `sage.categories.action.PrecomposedAction`. So, it composes maps phi from left and psi from right domain with an action alpha that knows about the codomains of phi and psi only. And thus perhaps we have again the problem of keeping \"the middle parent\" alive.\n\nNamely, if the underlying set S of alpha is the codomain of psi, but psi is weak, then neither psi nor alpha will keep S alive. But S is sometimes not used as cache key for the precomposed action: Only the domains of psi and phi appear in the key. Hence, I think I just need to add a strong reference to the underlying set of alpha.",
    "created_at": "2013-10-03T11:02:39Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181472",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:64'></a>
I just learnt that the codomain of an action coincides with the set that is acted upon. But here, we have a `sage.categories.action.PrecomposedAction`. So, it composes maps phi from left and psi from right domain with an action alpha that knows about the codomains of phi and psi only. And thus perhaps we have again the problem of keeping "the middle parent" alive.

Namely, if the underlying set S of alpha is the codomain of psi, but psi is weak, then neither psi nor alpha will keep S alive. But S is sometimes not used as cache key for the precomposed action: Only the domains of psi and phi appear in the key. Hence, I think I just need to add a strong reference to the underlying set of alpha.



---

archive/issue_comments_181473.json:
```json
{
    "body": "<a id='comment:65'></a>\nThe proposed change does in fact fix the problem mentioned in [comment:63](#comment%3A63)",
    "created_at": "2013-10-03T11:23:47Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181473",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:65'></a>
The proposed change does in fact fix the problem mentioned in [comment:63](#comment%3A63)



---

archive/issue_comments_181474.json:
```json
{
    "body": "<a id='comment:66'></a>\nI have pushed the new commit. The example from [comment:63](#comment%3A63) became a doctest.\n\nI am now running make ptest. Let us see how many problems persist. Depending on the result, we may worry later whether or not we want to add a safe user interface to the coercion system.",
    "created_at": "2013-10-03T11:36:17Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181474",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:66'></a>
I have pushed the new commit. The example from [comment:63](#comment%3A63) became a doctest.

I am now running make ptest. Let us see how many problems persist. Depending on the result, we may worry later whether or not we want to add a safe user interface to the coercion system.



---

archive/issue_comments_181475.json:
```json
{
    "body": "<a id='comment:67'></a>\nNote that I have retested\n\n```\nsage: for D in xrange(2,2**30):\n....:    print get_memory_usage()\n....:    Q = QuadraticField(-D)\n```\nwith the current commit. The memory consumption stays level after a short while, and moreover the numbers returned by `get_memory_usage()` are now less than 190!",
    "created_at": "2013-10-03T11:45:29Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181475",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:67'></a>
Note that I have retested

```
sage: for D in xrange(2,2**30):
....:    print get_memory_usage()
....:    Q = QuadraticField(-D)
```
with the current commit. The memory consumption stays level after a short while, and moreover the numbers returned by `get_memory_usage()` are now less than 190!



---

archive/issue_comments_181476.json:
```json
{
    "body": "<a id='comment:68'></a>\nResult of `make ptest` with the current commit:\n\n```\nsage -t src/sage/interfaces/maxima_abstract.py  # 1 doctest failed\nsage -t src/sage/matrix/matrix2.pyx  # 1 doctest failed\nsage -t src/sage/categories/group_algebras.py  # Killed due to segmentation fault\nsage -t src/sage/combinat/symmetric_group_algebra.py  # Killed due to segmentation fault\nsage -t src/sage/combinat/ncsf_qsym/ncsf.py  # Killed due to segmentation fault\nsage -t src/sage/combinat/words/morphism.py  # 10 doctests failed\nsage -t src/sage/schemes/toric/morphism.py  # 4 doctests failed\nsage -t src/sage/matrix/matrix0.pyx  # 3 doctests failed\nsage -t src/sage/categories/pushout.py  # Killed due to segmentation fault\nsage -t src/sage/rings/polynomial/plural.pyx  # 11 doctests failed\nsage -t src/sage/libs/singular/function.pyx  # 2 doctests failed\nsage -t src/sage/structure/coerce.pyx  # 5 doctests failed\nsage -t src/sage/libs/singular/groebner_strategy.pyx  # 2 doctests failed\n```\nSo, there remains a lot of work to do.",
    "created_at": "2013-10-03T13:01:54Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181476",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:68'></a>
Result of `make ptest` with the current commit:

```
sage -t src/sage/interfaces/maxima_abstract.py  # 1 doctest failed
sage -t src/sage/matrix/matrix2.pyx  # 1 doctest failed
sage -t src/sage/categories/group_algebras.py  # Killed due to segmentation fault
sage -t src/sage/combinat/symmetric_group_algebra.py  # Killed due to segmentation fault
sage -t src/sage/combinat/ncsf_qsym/ncsf.py  # Killed due to segmentation fault
sage -t src/sage/combinat/words/morphism.py  # 10 doctests failed
sage -t src/sage/schemes/toric/morphism.py  # 4 doctests failed
sage -t src/sage/matrix/matrix0.pyx  # 3 doctests failed
sage -t src/sage/categories/pushout.py  # Killed due to segmentation fault
sage -t src/sage/rings/polynomial/plural.pyx  # 11 doctests failed
sage -t src/sage/libs/singular/function.pyx  # 2 doctests failed
sage -t src/sage/structure/coerce.pyx  # 5 doctests failed
sage -t src/sage/libs/singular/groebner_strategy.pyx  # 2 doctests failed
```
So, there remains a lot of work to do.



---

archive/issue_comments_181477.json:
```json
{
    "body": "<a id='comment:69'></a>\nReplying to [SimonKing](#comment%3A62):\n> I think this is not the case with the branch that I have just uploaded. I did\n\nGot it! Thanks. To have documented *why* we're OK here: `_coerce_from_hash` is a `MonoDict`, so it holds a *strong* reference to the map stored. This is what keeps the map alive. However, when the domain vanishes, then the `MonoDict` callback will remove the entry and hence the strong reference to the map. This makes it possible for the map to be GCed. So the required callback to clean up is already triggered via the key triple.\n\n> What weakrefs are you talking about? Those to domain and codomain? \n> And what would the callback be supposed to do?\n\nIndeed, domain and codomain. So those callbacks are already taken care of by `_coerce_from_hash` being a `MonoDict`. The codomain is actually not relevant for this (and would be strongly referenced by the map anyway -- perhaps \"weakened\" maps should only have their domain reference weakened and parent (reference to the homset) cleared? If we just always keep codomain strongly referenced compositions would naturally keep things alive guaranteed anyway. Virtually all maps have a strong ref to the codomain (via generator images) internally anyway, so putting it explicitly on the outside shouldn't hurt much.\n\n> A different story is `_coerce_from_list`, which is a list. Here, we might need to take care of defunct maps. Perhaps the maps there shouldn't be weakened in the first place (`_coerce_from_list` is filled by `register_coercion()`, and perhaps it would make sense to keep these maps strong), but I am not sure if this wouldn't re-introduce the `QuadraticField` leak I have just fixed.\n\nDo we really need `_coerce_from_list`? Have we identified what it does that cannot be accomplished with the data stored in `_coerce_from_hash`?\n\n> As I have stated above, I don't think there is a problem with `_coerce_from_hash` accumulating garbage. But `_coerce_from_list` may contain garbage, of limited size, because it is only added to by explicit calls to `register_coercion()`.\n> \n> I think a better strategy would be to make `discover_coercion` check whether it meets a defunct map when it performs the backtrack algorithm.\n\nI doubt you could prove about such an incidental \"bumping in\" strategy that the number of defunct maps is bounded linearly in the number of active stuff (perhaps measured by active entries in `_coerce_from`?). That means you wouldn't be able to prove that you don't have a memory leak, and I suspect that with a little study, one could concoct an example that exhibits the leak as well. If `discover_coercion` would regularly visit all entries in `_coerce_from_list` then the process would be way too slow.\n\nGiven how delicate this code is, please do put ample documentation about assumptions and strategies in the code. Otherwise, the next person to work on this code will likely screw things up. Hopefully it'll be cought by doctests, but we've seen that this could easily not happen.",
    "created_at": "2013-10-03T16:04:30Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181477",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:69'></a>
Replying to [SimonKing](#comment%3A62):
> I think this is not the case with the branch that I have just uploaded. I did

Got it! Thanks. To have documented *why* we're OK here: `_coerce_from_hash` is a `MonoDict`, so it holds a *strong* reference to the map stored. This is what keeps the map alive. However, when the domain vanishes, then the `MonoDict` callback will remove the entry and hence the strong reference to the map. This makes it possible for the map to be GCed. So the required callback to clean up is already triggered via the key triple.

> What weakrefs are you talking about? Those to domain and codomain? 
> And what would the callback be supposed to do?

Indeed, domain and codomain. So those callbacks are already taken care of by `_coerce_from_hash` being a `MonoDict`. The codomain is actually not relevant for this (and would be strongly referenced by the map anyway -- perhaps "weakened" maps should only have their domain reference weakened and parent (reference to the homset) cleared? If we just always keep codomain strongly referenced compositions would naturally keep things alive guaranteed anyway. Virtually all maps have a strong ref to the codomain (via generator images) internally anyway, so putting it explicitly on the outside shouldn't hurt much.

> A different story is `_coerce_from_list`, which is a list. Here, we might need to take care of defunct maps. Perhaps the maps there shouldn't be weakened in the first place (`_coerce_from_list` is filled by `register_coercion()`, and perhaps it would make sense to keep these maps strong), but I am not sure if this wouldn't re-introduce the `QuadraticField` leak I have just fixed.

Do we really need `_coerce_from_list`? Have we identified what it does that cannot be accomplished with the data stored in `_coerce_from_hash`?

> As I have stated above, I don't think there is a problem with `_coerce_from_hash` accumulating garbage. But `_coerce_from_list` may contain garbage, of limited size, because it is only added to by explicit calls to `register_coercion()`.
> 
> I think a better strategy would be to make `discover_coercion` check whether it meets a defunct map when it performs the backtrack algorithm.

I doubt you could prove about such an incidental "bumping in" strategy that the number of defunct maps is bounded linearly in the number of active stuff (perhaps measured by active entries in `_coerce_from`?). That means you wouldn't be able to prove that you don't have a memory leak, and I suspect that with a little study, one could concoct an example that exhibits the leak as well. If `discover_coercion` would regularly visit all entries in `_coerce_from_list` then the process would be way too slow.

Given how delicate this code is, please do put ample documentation about assumptions and strategies in the code. Otherwise, the next person to work on this code will likely screw things up. Hopefully it'll be cought by doctests, but we've seen that this could easily not happen.



---

archive/issue_comments_181478.json:
```json
{
    "body": "<a id='comment:70'></a>\nSo one action point: Have you considered just leaving the codomain strongly referenced? Apart from the fact that `_make_weak` and `_make_strong` on map compositions still needs to recurse into components, it should make compositions easier to work with, because the first map will keep the middle (co)domain alive, as desired.\n\nIt also means `_codomain` can remain a fast slot.\n\nI currently don't see a scenario where weakening the codomain reference buys us anything, especially because maps internally will usually reference the codomain.\n\nAnother action point: see if `_coerce_from_list` can simply be thrown away.",
    "created_at": "2013-10-03T18:22:54Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181478",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:70'></a>
So one action point: Have you considered just leaving the codomain strongly referenced? Apart from the fact that `_make_weak` and `_make_strong` on map compositions still needs to recurse into components, it should make compositions easier to work with, because the first map will keep the middle (co)domain alive, as desired.

It also means `_codomain` can remain a fast slot.

I currently don't see a scenario where weakening the codomain reference buys us anything, especially because maps internally will usually reference the codomain.

Another action point: see if `_coerce_from_list` can simply be thrown away.



---

archive/issue_comments_181479.json:
```json
{
    "body": "<a id='comment:71'></a>\nReplying to [nbruin](#comment%3A69):\n> \n> Indeed, domain and codomain. So those callbacks are already taken care of by `_coerce_from_hash` being a `MonoDict`. The codomain is actually not relevant for this (and would be strongly referenced by the map anyway -- perhaps \"weakened\" maps should only have their domain reference weakened and parent (reference to the homset) cleared? If we just always keep codomain strongly referenced compositions would naturally keep things alive guaranteed anyway. Virtually all maps have a strong ref to the codomain (via generator images) internally anyway, so putting it explicitly on the outside shouldn't hurt much.\n\nThis might actually be a good idea. Note that some wise person decided to store coerce maps on the codomain. Hence, having a strong reference from the map back to the codomain will not hurt at all, with the additional advantage you just mentioned. It would also fix the problem with composed maps *and* with `PrecomposedAction`!\n\n> Do we really need `_coerce_from_list`? Have we identified what it does that cannot be accomplished with the data stored in `_coerce_from_hash`?\n\nI don't know why it had originally been introduced. But when I added the weak versions of triple and mono dict, I actually thought of it as a way to make some coercions (namely those explicitly registered) permanent.\n\n> I doubt you could prove about such an incidental \"bumping in\" strategy that the number of defunct maps is bounded linearly in the number of active stuff (perhaps measured by active entries in `_coerce_from`?). That means you wouldn't be able to prove that you don't have a memory leak, and I suspect that with a little study, one could concoct an example that exhibits the leak as well.\n\nSure. But the more you have to struggle to construct a leak, the more happy I'll be... `:-P`\n\n> Given how delicate this code is, please do put ample documentation about assumptions and strategies in the code. Otherwise, the next person to work on this code will likely screw things up. Hopefully it'll be cought by doctests, but we've seen that this could easily not happen.\n\nOK, I'll try to be explicit in either the comments in the code, or in the docs.",
    "created_at": "2013-10-03T19:28:06Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181479",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:71'></a>
Replying to [nbruin](#comment%3A69):
> 
> Indeed, domain and codomain. So those callbacks are already taken care of by `_coerce_from_hash` being a `MonoDict`. The codomain is actually not relevant for this (and would be strongly referenced by the map anyway -- perhaps "weakened" maps should only have their domain reference weakened and parent (reference to the homset) cleared? If we just always keep codomain strongly referenced compositions would naturally keep things alive guaranteed anyway. Virtually all maps have a strong ref to the codomain (via generator images) internally anyway, so putting it explicitly on the outside shouldn't hurt much.

This might actually be a good idea. Note that some wise person decided to store coerce maps on the codomain. Hence, having a strong reference from the map back to the codomain will not hurt at all, with the additional advantage you just mentioned. It would also fix the problem with composed maps *and* with `PrecomposedAction`!

> Do we really need `_coerce_from_list`? Have we identified what it does that cannot be accomplished with the data stored in `_coerce_from_hash`?

I don't know why it had originally been introduced. But when I added the weak versions of triple and mono dict, I actually thought of it as a way to make some coercions (namely those explicitly registered) permanent.

> I doubt you could prove about such an incidental "bumping in" strategy that the number of defunct maps is bounded linearly in the number of active stuff (perhaps measured by active entries in `_coerce_from`?). That means you wouldn't be able to prove that you don't have a memory leak, and I suspect that with a little study, one could concoct an example that exhibits the leak as well.

Sure. But the more you have to struggle to construct a leak, the more happy I'll be... `:-P`

> Given how delicate this code is, please do put ample documentation about assumptions and strategies in the code. Otherwise, the next person to work on this code will likely screw things up. Hopefully it'll be cought by doctests, but we've seen that this could easily not happen.

OK, I'll try to be explicit in either the comments in the code, or in the docs.



---

archive/issue_comments_181480.json:
```json
{
    "body": "<a id='comment:72'></a>\nI can confirm that with a strong reference to the codomain, the leak is still fixed. Now trying to see if it also prevents some of the crashes I've seen in the tests!",
    "created_at": "2013-10-03T19:40:48Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181480",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:72'></a>
I can confirm that with a strong reference to the codomain, the leak is still fixed. Now trying to see if it also prevents some of the crashes I've seen in the tests!



---

archive/issue_comments_181481.json:
```json
{
    "body": "<a id='comment:73'></a>\nOutch. Sage started, but the first four tests I've run have segfaulted. Very bad. How can that be?",
    "created_at": "2013-10-03T19:44:31Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181481",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:73'></a>
Outch. Sage started, but the first four tests I've run have segfaulted. Very bad. How can that be?



---

archive/issue_comments_181482.json:
```json
{
    "body": "<a id='comment:74'></a>\nReplying to [SimonKing](#comment%3A73):\n> Outch. Sage started, but the first four tests I've run have segfaulted. Very bad. How can that be?\n\nThis is really getting scary. I see in an interactive session that the leak is fixed, but according to the corresponding doctest it isn't fixed.",
    "created_at": "2013-10-03T20:30:07Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181482",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:74'></a>
Replying to [SimonKing](#comment%3A73):
> Outch. Sage started, but the first four tests I've run have segfaulted. Very bad. How can that be?

This is really getting scary. I see in an interactive session that the leak is fixed, but according to the corresponding doctest it isn't fixed.



---

archive/issue_comments_181483.json:
```json
{
    "body": "<a id='comment:75'></a>\nReplying to [SimonKing](#comment%3A74):\n> This is really getting scary. I see in an interactive session that the leak is fixed, but according to the corresponding doctest it isn't fixed.\n\nWhat a fun...\n\nWhen counting the number of quadratic number fields tracked by gc, I did\n\n```\nnumberQuadFields = len([x for x in gc.get_objects() if isinstance(x, C)])\n```\nAnd apparently,just  by chance, x became a pointer to the number field that I wanted to delete. Hence, I had to add `del x` to make the tests pass.",
    "created_at": "2013-10-03T21:31:19Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181483",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:75'></a>
Replying to [SimonKing](#comment%3A74):
> This is really getting scary. I see in an interactive session that the leak is fixed, but according to the corresponding doctest it isn't fixed.

What a fun...

When counting the number of quadratic number fields tracked by gc, I did

```
numberQuadFields = len([x for x in gc.get_objects() if isinstance(x, C)])
```
And apparently,just  by chance, x became a pointer to the number field that I wanted to delete. Hence, I had to add `del x` to make the tests pass.



---

archive/issue_comments_181484.json:
```json
{
    "body": "<a id='comment:76'></a>\nI am now back at trying to trace down the errors mentioned in [comment:68](#comment%3A68). Frustratingly, with my current local branch (not yet posted), I can not reproduce all the errors, even though the code during [comment:68](#comment%3A68) looked nearly the same.",
    "created_at": "2013-10-03T21:46:40Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181484",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:76'></a>
I am now back at trying to trace down the errors mentioned in [comment:68](#comment%3A68). Frustratingly, with my current local branch (not yet posted), I can not reproduce all the errors, even though the code during [comment:68](#comment%3A68) looked nearly the same.



---

archive/issue_comments_181485.json:
```json
{
    "body": "<a id='comment:77'></a>\nOne rather puzzling error:\n\n```\nsage: import gc\nsage: SG4 = SymmetricGroupAlgebra(ZZ,4)\nsage: gc.collect()\n1051\nsage: SG4(1).is_central()\n------------------------------------------------------------------------\n./sage: Zeile 134: 14576 Speicherzugriffsfehler  \"$SAGE_ROOT/src/bin/sage\" \"$@\"\n```\n\nWhy is this puzzling? Well, it does not occur when I make both domain and codomain weak references, for coerce maps. But it *does* occur when I only make the domain a weak reference.\n\nSo, is it the case that \"the more weak references, the more crash safe\"??",
    "created_at": "2013-10-03T21:54:24Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181485",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:77'></a>
One rather puzzling error:

```
sage: import gc
sage: SG4 = SymmetricGroupAlgebra(ZZ,4)
sage: gc.collect()
1051
sage: SG4(1).is_central()
------------------------------------------------------------------------
./sage: Zeile 134: 14576 Speicherzugriffsfehler  "$SAGE_ROOT/src/bin/sage" "$@"
```

Why is this puzzling? Well, it does not occur when I make both domain and codomain weak references, for coerce maps. But it *does* occur when I only make the domain a weak reference.

So, is it the case that "the more weak references, the more crash safe"??



---

archive/issue_comments_181486.json:
```json
{
    "body": "<a id='comment:78'></a>\nReplying to [SimonKing](#comment%3A75):\n\n> ```\n> numberQuadFields = len([x for x in gc.get_objects() if isinstance(x, C)])\n> ```\n\nPerhaps use\n\n```\nnumberQuadFields = sum(1 for x in gc.get_objects() if isinstance(x, C))\n```\ninstead, to prevent leaking x?",
    "created_at": "2013-10-03T22:06:29Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181486",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:78'></a>
Replying to [SimonKing](#comment%3A75):

> ```
> numberQuadFields = len([x for x in gc.get_objects() if isinstance(x, C)])
> ```

Perhaps use

```
numberQuadFields = sum(1 for x in gc.get_objects() if isinstance(x, C))
```
instead, to prevent leaking x?



---

archive/issue_comments_181487.json:
```json
{
    "body": "<a id='comment:79'></a>\nIt reduces to\n\n```\nsage: SG4 = SymmetricGroupAlgebra(ZZ,4)\nsage: SG4._introspect_coerce()['_coerce_from_list']\n[Generic morphism:\n  From: Integer Ring\n  To:   Symmetric group algebra of order 4 over Integer Ring,\n Generic morphism:\n  From: Symmetric group algebra of order 3 over Integer Ring\n  To:   Symmetric group algebra of order 4 over Integer Ring]\nsage: phi, psi = _\nsage: import gc\nsage: gc.collect()\n1062\nsage: phi\nGeneric morphism:\n  From: Integer Ring\n  To:   Symmetric group algebra of order 4 over Integer Ring\nsage: psi\nTraceback (most recent call last):\n...\nValueError: This map is in an invalid state, domain or codomain have been garbage collected\n```\n\nSo, perhaps we need to keep stuff strong in the coerce_from_list after all.",
    "created_at": "2013-10-03T22:08:04Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181487",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:79'></a>
It reduces to

```
sage: SG4 = SymmetricGroupAlgebra(ZZ,4)
sage: SG4._introspect_coerce()['_coerce_from_list']
[Generic morphism:
  From: Integer Ring
  To:   Symmetric group algebra of order 4 over Integer Ring,
 Generic morphism:
  From: Symmetric group algebra of order 3 over Integer Ring
  To:   Symmetric group algebra of order 4 over Integer Ring]
sage: phi, psi = _
sage: import gc
sage: gc.collect()
1062
sage: phi
Generic morphism:
  From: Integer Ring
  To:   Symmetric group algebra of order 4 over Integer Ring
sage: psi
Traceback (most recent call last):
...
ValueError: This map is in an invalid state, domain or codomain have been garbage collected
```

So, perhaps we need to keep stuff strong in the coerce_from_list after all.



---

archive/issue_comments_181488.json:
```json
{
    "body": "<a id='comment:80'></a>\nPS: But why does it not crash if the coerce maps' codomains get weakref'd too?",
    "created_at": "2013-10-03T22:12:04Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181488",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:80'></a>
PS: But why does it not crash if the coerce maps' codomains get weakref'd too?



---

archive/issue_comments_181489.json:
```json
{
    "body": "<a id='comment:81'></a>\nFor the record: When I do not weaken the maps on `_coerce_from_list` or `_convert_from_list`, the crash vanishes, but the memory leak is still fixed.\n\nAlso in my unpublished branch: Skip invalid maps in discover coercion (in the backtracking algorithm). But this is just an additional safety. I think we want that explicitly registered maps (i.e., those which are the fundamental path ways in the backtracking algorithm) will stay alive. Hence, it might even be worth while to keep an explicit reference to the domain of the map, so that the map will remain valid even if something weakens it.\n\nI am now running tests again.",
    "created_at": "2013-10-03T22:26:00Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181489",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:81'></a>
For the record: When I do not weaken the maps on `_coerce_from_list` or `_convert_from_list`, the crash vanishes, but the memory leak is still fixed.

Also in my unpublished branch: Skip invalid maps in discover coercion (in the backtracking algorithm). But this is just an additional safety. I think we want that explicitly registered maps (i.e., those which are the fundamental path ways in the backtracking algorithm) will stay alive. Hence, it might even be worth while to keep an explicit reference to the domain of the map, so that the map will remain valid even if something weakens it.

I am now running tests again.



---

archive/issue_comments_181490.json:
```json
{
    "body": "<a id='comment:82'></a>\nTo summarise the requirements found in our discussion for a stable and memory\nfriendly coercion system:\n\n- Maps registered by `P.register_coercion(mor)` are the backbone of the discover_coercion algorithm. Hence, they need to be kept healthy as long as `P` lives.\n- If P has a coerce embedding then this embedding needs to be kept healthy as long as P lives.\n- If the coercion system finds a coercion from P to Q different from the two preceding cases (i.e., by transitive closure), then P must not prevent Q and the coercion map from garbage collection, and Q must not prevent P and the coercion map from garbage collection. But the coercion map needs to stay healthy as long as both P and Q are alive. In particular, take care of composed maps and actions.\n\nTo summarise how I think we can meet these requirements:\n\n- `P.register_coercion(mor)` keeps a strong reference to `mor.domain()` in a new attribute `P._registered_domains` (which is a list). All other maps in the coercion system will be weakened.\n- Homsets keep strong references to domain and codomain.\n- \"Weakening a map\" means to use a weak reference to the domain and a removed reference to the homset. But we will keep a strong reference to the codomain. Consequence: (1) In a composed map or action, the \"middle parents\" will always stay alive as long as the composed map lives. (2) Embeddings do what we required above: The embedding keeps the codomain alive.\n- We store the map phi found by `P.discover_coercion(Q)` in `P._coerce_from_hash`, which is a monodict. In particular, if Q will be garbage collected, then phi is immediately removed from the cache, and thus the strong reference of phi to the codomain P will not prevent P from garbage collection. And if P will be garbage collected, then the whole cache including phi is removed. However, if both P and Q live, then phi will stay in `P._coerce_from_hash[Q]`, and it will stay healthy, because its domain Q is still alive (and hence the weak reference is still ok).\n\nI think this model makes sense.\n\nAnd concerning a safe user interface: Perhaps we can do without. Namely, we could make it so that the string representation of a weakened map will consist of a warning, suggesting to use a copy. In this way, it would be sufficiently likely that the user wouldn't have too many bad surprises.",
    "created_at": "2013-10-03T23:37:51Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181490",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:82'></a>
To summarise the requirements found in our discussion for a stable and memory
friendly coercion system:

- Maps registered by `P.register_coercion(mor)` are the backbone of the discover_coercion algorithm. Hence, they need to be kept healthy as long as `P` lives.
- If P has a coerce embedding then this embedding needs to be kept healthy as long as P lives.
- If the coercion system finds a coercion from P to Q different from the two preceding cases (i.e., by transitive closure), then P must not prevent Q and the coercion map from garbage collection, and Q must not prevent P and the coercion map from garbage collection. But the coercion map needs to stay healthy as long as both P and Q are alive. In particular, take care of composed maps and actions.

To summarise how I think we can meet these requirements:

- `P.register_coercion(mor)` keeps a strong reference to `mor.domain()` in a new attribute `P._registered_domains` (which is a list). All other maps in the coercion system will be weakened.
- Homsets keep strong references to domain and codomain.
- "Weakening a map" means to use a weak reference to the domain and a removed reference to the homset. But we will keep a strong reference to the codomain. Consequence: (1) In a composed map or action, the "middle parents" will always stay alive as long as the composed map lives. (2) Embeddings do what we required above: The embedding keeps the codomain alive.
- We store the map phi found by `P.discover_coercion(Q)` in `P._coerce_from_hash`, which is a monodict. In particular, if Q will be garbage collected, then phi is immediately removed from the cache, and thus the strong reference of phi to the codomain P will not prevent P from garbage collection. And if P will be garbage collected, then the whole cache including phi is removed. However, if both P and Q live, then phi will stay in `P._coerce_from_hash[Q]`, and it will stay healthy, because its domain Q is still alive (and hence the weak reference is still ok).

I think this model makes sense.

And concerning a safe user interface: Perhaps we can do without. Namely, we could make it so that the string representation of a weakened map will consist of a warning, suggesting to use a copy. In this way, it would be sufficiently likely that the user wouldn't have too many bad surprises.



---

archive/issue_comments_181491.json:
```json
{
    "body": "<a id='comment:83'></a>\nReplying to [SimonKing](#comment%3A82):\n> - Maps registered by `P.register_coercion(mor)` are the backbone of the discover_coercion algorithm. Hence, they need to be kept healthy as long as `P` lives.\n\nIt's not clear to me this is the case. If `mor` is a map from S to P then `P.register_coercion(mor)` ensures the coercion system knows how to map an element from S into P. Why is it important to maintain this information for the lifetime of P? If S ceases to exist, then one would not need to map elements from S to P. Why do we need to ensure S keeps existing? Shouldn't P have a reference to S independent of the coercion system if P's health depends on the existence of S? I think the coercion system is there to keep track of relations between existing objects, not to keep objects in existence (although this might be a side-effect of keeping track of relations between other objects).\n\n> - If P has a coerce embedding then this embedding needs to be kept healthy as long as P lives.\n\nI presume this is the function of the `_embedding` coercion attribute? So it looks like we already have that. What if we want multiple embeddings?\n\n> - `P.register_coercion(mor)` keeps a strong reference to `mor.domain()` in a new attribute `P._registered_domains` (which is a list). All other maps in the coercion system will be weakened.\n\nSo what means are there available to add a coercion without tying the lifespan of one to the other? Shouldn't it be possible to specify such things too?\n\n> - We store the map phi found by `P.discover_coercion(Q)` in `P._coerce_from_hash`, which is a monodict. In particular, if Q will be garbage collected, then phi is immediately removed from the cache, and thus the strong reference of phi to the codomain P will not prevent P from garbage collection.\n\nIt never did prevent collection: The reference to phi is held by P, so the reference from phi to P would be recognized as a cycle, so the cyclic GC would find it (and parents usually are involved in cycles already, so cyclic GC is their only chance for being reclaimed anyway). Your statement is still true.\n\n> And concerning a safe user interface: Perhaps we can do without. Namely, we could make it so that the string representation of a weakened map will consist of a warning, suggesting to use a copy. In this way, it would be sufficiently likely that the user wouldn't have too many bad surprises.\n\nHm, we'll see.",
    "created_at": "2013-10-04T06:33:52Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181491",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:83'></a>
Replying to [SimonKing](#comment%3A82):
> - Maps registered by `P.register_coercion(mor)` are the backbone of the discover_coercion algorithm. Hence, they need to be kept healthy as long as `P` lives.

It's not clear to me this is the case. If `mor` is a map from S to P then `P.register_coercion(mor)` ensures the coercion system knows how to map an element from S into P. Why is it important to maintain this information for the lifetime of P? If S ceases to exist, then one would not need to map elements from S to P. Why do we need to ensure S keeps existing? Shouldn't P have a reference to S independent of the coercion system if P's health depends on the existence of S? I think the coercion system is there to keep track of relations between existing objects, not to keep objects in existence (although this might be a side-effect of keeping track of relations between other objects).

> - If P has a coerce embedding then this embedding needs to be kept healthy as long as P lives.

I presume this is the function of the `_embedding` coercion attribute? So it looks like we already have that. What if we want multiple embeddings?

> - `P.register_coercion(mor)` keeps a strong reference to `mor.domain()` in a new attribute `P._registered_domains` (which is a list). All other maps in the coercion system will be weakened.

So what means are there available to add a coercion without tying the lifespan of one to the other? Shouldn't it be possible to specify such things too?

> - We store the map phi found by `P.discover_coercion(Q)` in `P._coerce_from_hash`, which is a monodict. In particular, if Q will be garbage collected, then phi is immediately removed from the cache, and thus the strong reference of phi to the codomain P will not prevent P from garbage collection.

It never did prevent collection: The reference to phi is held by P, so the reference from phi to P would be recognized as a cycle, so the cyclic GC would find it (and parents usually are involved in cycles already, so cyclic GC is their only chance for being reclaimed anyway). Your statement is still true.

> And concerning a safe user interface: Perhaps we can do without. Namely, we could make it so that the string representation of a weakened map will consist of a warning, suggesting to use a copy. In this way, it would be sufficiently likely that the user wouldn't have too many bad surprises.

Hm, we'll see.



---

archive/issue_comments_181492.json:
```json
{
    "body": "<a id='comment:84'></a>\nWith my current not yet published code, I get errors only in one file, namely with scheme morphisms. And this actually isn't a surprise, since scheme morphisms almost completely ignore the existing methods they inherit from `sage.categories.map.Map`. They have a custom `__init__` doing more or less the same what the *old* version of `Map.__init__` used to do, and they even override `domain()` and `codomain()`.\n\nSo, this should be fixable, and I suppose I will be able to post a commit so that all tests pass, later today.\n\nReplying to [nbruin](#comment%3A83):\n> Replying to [SimonKing](#comment%3A82):\n> > - Maps registered by `P.register_coercion(mor)` are the backbone of the discover_coercion algorithm. Hence, they need to be kept healthy as long as `P` lives.\n\n> \n> It's not clear to me this is the case. If `mor` is a map from S to P then `P.register_coercion(mor)` ensures the coercion system knows how to map an element from S into P. Why is it important to maintain this information for the lifetime of P? If S ceases to exist, then one would not need to map elements from S to P.\n\nOne does! Namely, suppose that you first do `P.register_coercion(mor)`, then you allow `S` to become garbage collected, and then you create a new parent `Q` with an embedding into what looks like `S` (of course, it now is a replica of the original now garbage collected `S`).\n\nYou would want that `Q` coerces into `P` via `S`, by transitivity of coercions. But you collected `mor.domain()` and thus you will fail to find this coercion.\n\nAnother attempt to explain why I think the explicitly registered maps need to be kept:\n\nThink of the coercions as a digraph.\n- The vertices correspond to parents.\n- The arrows (oriented edges) of the digraph correspond to those maps that are declared as coercions by `.register_coercion(...)`.\n- In addition to the arrows created with `register_coercion`, the coercion system may find short-cuts by calling `._coerce_map_from_(...)`. For efficiency reasons, these short-cuts are stored in a cache.\n- The coercion system then tries to find directed paths between two given vertices, including short-cuts. For efficiency reasons, it stores the resulting composed maps in a cache.\n\nHow does the coercion system find \"directed paths with short-cuts\" from Q to P?\n- Of course, it would be impossible to just guess a parent S such that Q has a short-cut into S and S has a short-cut into P.\n- One could search through all paths alpha (paths without shortcuts, I mean) starting at Q and simultaneously through all paths beta ending at P, and then test whether there is a short-cut from the endpoint of alpha to the startpoint of beta. It would work, but I guess it would be very time consuming.\n- The current coercion system will therefore just search (by backtracking) through all shortcut-free paths beta ending at P, end then test whether there is a short-cut from Q to the startpoint of beta. In addition, the coerce embedding registered for Q will be considered in forward direction.\n\n__Remark__\n\nPerhaps in the long run, we could actually use a proper digraph (with a lightning fast backend) to keep track of coercions.\n\nNow for garbage collection:\n\n> Why do we need to ensure S keeps existing? Shouldn't P have a reference to S independent of the coercion system if P's health depends on the existence of S? I think the coercion system is there to keep track of relations between existing objects, not to keep objects in existence (although this might be a side-effect of keeping track of relations between other objects).\n\nI think that in many cases it would indeed be the case that P should reference S independent of coercions (say, if S is the base ring of P). However, it is conceivable (and I think I've met such cases in failing doctests) that P can remain perfectly healthy without S, but still we would like to find coercions from Q to P via S.\n\nSo, the coercion system will not care for the health of P, but it must care for the connectivity of the coercion graph. And in the current algorithm sketched above, it is of vital importance to keep arrows leading to P alive, since otherwise we have to live with shortcuts only.\n\n> > - If P has a coerce embedding then this embedding needs to be kept healthy as long as P lives.\n\n> \n> I presume this is the function of the `_embedding` coercion attribute? So it looks like we already have that. What if we want multiple embeddings?\n\nThen we look into the code and see that multiple embeddings are explicitly excluded. A parent has precisely one embedding that is taken into account by the coercion search *in forward direction*. You may of course register further embeddings as coercions, by `emb.codomain().register_coercion(emb)`, but they would only be used for search in backward direction.\n\n> > - `P.register_coercion(mor)` keeps a strong reference to `mor.domain()` in a new attribute `P._registered_domains` (which is a list). All other maps in the coercion system will be weakened.\n\n> \n> So what means are there available to add a coercion without tying the lifespan of one to the other?\n\nNote that after `P.register_coercion(mor)`, `mor.domain()` will live at least as long as P. But `mor.domain()` would not be enough to keep P alive.\n\nAnd there surely is a means available to add a coercion that doesn't tie the lifespan of two parents too closely: Implement `P._coerce_map_from_(Q)`, which can return a map or simply \"True\" (in the latter case, conversion is used to coerce Q into P). The result is cached in `P._coerce_from_hash`, but not in `P._coerce_from_list`.\n\n>  Shouldn't it be possible to specify such things too?\n\nPerhaps in the long run? I wouldn't like to do those things (such as: Rewrite the coercion system to use a proper digraph backend) here.",
    "created_at": "2013-10-04T08:21:03Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181492",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:84'></a>
With my current not yet published code, I get errors only in one file, namely with scheme morphisms. And this actually isn't a surprise, since scheme morphisms almost completely ignore the existing methods they inherit from `sage.categories.map.Map`. They have a custom `__init__` doing more or less the same what the *old* version of `Map.__init__` used to do, and they even override `domain()` and `codomain()`.

So, this should be fixable, and I suppose I will be able to post a commit so that all tests pass, later today.

Replying to [nbruin](#comment%3A83):
> Replying to [SimonKing](#comment%3A82):
> > - Maps registered by `P.register_coercion(mor)` are the backbone of the discover_coercion algorithm. Hence, they need to be kept healthy as long as `P` lives.

> 
> It's not clear to me this is the case. If `mor` is a map from S to P then `P.register_coercion(mor)` ensures the coercion system knows how to map an element from S into P. Why is it important to maintain this information for the lifetime of P? If S ceases to exist, then one would not need to map elements from S to P.

One does! Namely, suppose that you first do `P.register_coercion(mor)`, then you allow `S` to become garbage collected, and then you create a new parent `Q` with an embedding into what looks like `S` (of course, it now is a replica of the original now garbage collected `S`).

You would want that `Q` coerces into `P` via `S`, by transitivity of coercions. But you collected `mor.domain()` and thus you will fail to find this coercion.

Another attempt to explain why I think the explicitly registered maps need to be kept:

Think of the coercions as a digraph.
- The vertices correspond to parents.
- The arrows (oriented edges) of the digraph correspond to those maps that are declared as coercions by `.register_coercion(...)`.
- In addition to the arrows created with `register_coercion`, the coercion system may find short-cuts by calling `._coerce_map_from_(...)`. For efficiency reasons, these short-cuts are stored in a cache.
- The coercion system then tries to find directed paths between two given vertices, including short-cuts. For efficiency reasons, it stores the resulting composed maps in a cache.

How does the coercion system find "directed paths with short-cuts" from Q to P?
- Of course, it would be impossible to just guess a parent S such that Q has a short-cut into S and S has a short-cut into P.
- One could search through all paths alpha (paths without shortcuts, I mean) starting at Q and simultaneously through all paths beta ending at P, and then test whether there is a short-cut from the endpoint of alpha to the startpoint of beta. It would work, but I guess it would be very time consuming.
- The current coercion system will therefore just search (by backtracking) through all shortcut-free paths beta ending at P, end then test whether there is a short-cut from Q to the startpoint of beta. In addition, the coerce embedding registered for Q will be considered in forward direction.

__Remark__

Perhaps in the long run, we could actually use a proper digraph (with a lightning fast backend) to keep track of coercions.

Now for garbage collection:

> Why do we need to ensure S keeps existing? Shouldn't P have a reference to S independent of the coercion system if P's health depends on the existence of S? I think the coercion system is there to keep track of relations between existing objects, not to keep objects in existence (although this might be a side-effect of keeping track of relations between other objects).

I think that in many cases it would indeed be the case that P should reference S independent of coercions (say, if S is the base ring of P). However, it is conceivable (and I think I've met such cases in failing doctests) that P can remain perfectly healthy without S, but still we would like to find coercions from Q to P via S.

So, the coercion system will not care for the health of P, but it must care for the connectivity of the coercion graph. And in the current algorithm sketched above, it is of vital importance to keep arrows leading to P alive, since otherwise we have to live with shortcuts only.

> > - If P has a coerce embedding then this embedding needs to be kept healthy as long as P lives.

> 
> I presume this is the function of the `_embedding` coercion attribute? So it looks like we already have that. What if we want multiple embeddings?

Then we look into the code and see that multiple embeddings are explicitly excluded. A parent has precisely one embedding that is taken into account by the coercion search *in forward direction*. You may of course register further embeddings as coercions, by `emb.codomain().register_coercion(emb)`, but they would only be used for search in backward direction.

> > - `P.register_coercion(mor)` keeps a strong reference to `mor.domain()` in a new attribute `P._registered_domains` (which is a list). All other maps in the coercion system will be weakened.

> 
> So what means are there available to add a coercion without tying the lifespan of one to the other?

Note that after `P.register_coercion(mor)`, `mor.domain()` will live at least as long as P. But `mor.domain()` would not be enough to keep P alive.

And there surely is a means available to add a coercion that doesn't tie the lifespan of two parents too closely: Implement `P._coerce_map_from_(Q)`, which can return a map or simply "True" (in the latter case, conversion is used to coerce Q into P). The result is cached in `P._coerce_from_hash`, but not in `P._coerce_from_list`.

>  Shouldn't it be possible to specify such things too?

Perhaps in the long run? I wouldn't like to do those things (such as: Rewrite the coercion system to use a proper digraph backend) here.



---

archive/issue_comments_181493.json:
```json
{
    "body": "<a id='comment:85'></a>\nReplying to [SimonKing](#comment%3A84):\n> With my current not yet published code, I get errors only in one file, namely with scheme morphisms. And this actually isn't a surprise, since scheme morphisms almost completely ignore the existing methods they inherit from `sage.categories.map.Map`. They have a custom `__init__` doing more or less the same what the *old* version of `Map.__init__` used to do, and they even override `domain()` and `codomain()`.\n\nArrgh, it is even worse: `SchemeMorphism` just inherits from `Element`, not from `Map`! Unbelievable.",
    "created_at": "2013-10-04T08:52:34Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181493",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:85'></a>
Replying to [SimonKing](#comment%3A84):
> With my current not yet published code, I get errors only in one file, namely with scheme morphisms. And this actually isn't a surprise, since scheme morphisms almost completely ignore the existing methods they inherit from `sage.categories.map.Map`. They have a custom `__init__` doing more or less the same what the *old* version of `Map.__init__` used to do, and they even override `domain()` and `codomain()`.

Arrgh, it is even worse: `SchemeMorphism` just inherits from `Element`, not from `Map`! Unbelievable.



---

archive/issue_comments_181494.json:
```json
{
    "body": "**Author:** Simon King",
    "created_at": "2013-10-04T10:36:34Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181494",
    "user": "https://github.com/simon-king-jena"
}
```

**Author:** Simon King



---

archive/issue_comments_181495.json:
```json
{
    "body": "<a id='comment:86'></a>\nI have pushed two more commits, and now *all* doctests should pass (to be verified).\n\nI also think I have extensively explained the rationale behind the changes. Hence, I have already clicked \"Needs review\". But it was too soon (see below).\n\nA potential \"todo\": We might want that a weakened map returned by `P.coerce_map_from(Q)` will print as\n\n```\nsage: QQ['x'].coerce_map_from(QQ)\nThis is a map used by the coercion system.\nIf you want to use it outside of the coercion system,\nplease use a copy of the map\nsage: copy(_)\nPolynomial base injection morphism:\n  From: Rational Field\n  To:   Univariate Polynomial Ring in x over Rational Field\n```\n\nIn this case, we may want to have `__copy__` methods everywhere. Even though the current branch improves copying, I just obtained the following crash that I want to fix first:\n\n```\nsage: QQ['x'].coerce_map_from(ZZ)\nComposite map:\n  From: Integer Ring\n  To:   Univariate Polynomial Ring in x over Rational Field\n  Defn:   Natural morphism:\n          From: Integer Ring\n          To:   Rational Field\n        then\n          Polynomial base injection morphism:\n          From: Rational Field\n          To:   Univariate Polynomial Ring in x over Rational Field\nsage: phi = copy(_)\nsage: phi(2)\n<SEGFAULT>\n```",
    "created_at": "2013-10-04T10:36:34Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181495",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:86'></a>
I have pushed two more commits, and now *all* doctests should pass (to be verified).

I also think I have extensively explained the rationale behind the changes. Hence, I have already clicked "Needs review". But it was too soon (see below).

A potential "todo": We might want that a weakened map returned by `P.coerce_map_from(Q)` will print as

```
sage: QQ['x'].coerce_map_from(QQ)
This is a map used by the coercion system.
If you want to use it outside of the coercion system,
please use a copy of the map
sage: copy(_)
Polynomial base injection morphism:
  From: Rational Field
  To:   Univariate Polynomial Ring in x over Rational Field
```

In this case, we may want to have `__copy__` methods everywhere. Even though the current branch improves copying, I just obtained the following crash that I want to fix first:

```
sage: QQ['x'].coerce_map_from(ZZ)
Composite map:
  From: Integer Ring
  To:   Univariate Polynomial Ring in x over Rational Field
  Defn:   Natural morphism:
          From: Integer Ring
          To:   Rational Field
        then
          Polynomial base injection morphism:
          From: Rational Field
          To:   Univariate Polynomial Ring in x over Rational Field
sage: phi = copy(_)
sage: phi(2)
<SEGFAULT>
```



---

archive/issue_comments_181496.json:
```json
{
    "body": "**Work Issues:** Provide copy of composed maps",
    "created_at": "2013-10-04T10:36:34Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181496",
    "user": "https://github.com/simon-king-jena"
}
```

**Work Issues:** Provide copy of composed maps



---

archive/issue_comments_181497.json:
```json
{
    "body": "<a id='comment:87'></a>\nDone, and now I'd say it can be reviewed. With the latest commit, one can do\n\n```\nsage: phi = QQ['x'].coerce_map_from(ZZ)\nsage: phi.domain\n<weakref at 0xa225284; to 'sage.rings.integer_ring.IntegerRing_class' at 0x96ddd3c (EuclideanDomains.parent_class)>\nsage: type(phi)\n<type 'sage.categories.map.FormalCompositeMap'>\nsage: psi = copy(phi)\nsage: psi\nComposite map:\n  From: Integer Ring\n  To:   Univariate Polynomial Ring in x over Rational Field\n  Defn:   Natural morphism:\n          From: Integer Ring\n          To:   Rational Field\n        then\n          Polynomial base injection morphism:\n          From: Rational Field\n          To:   Univariate Polynomial Ring in x over Rational Field\nsage: psi(3)\n3\nsage: psi.domain\nThe constant function (...) -> Integer Ring\n```\nwhich required implementing `__copy__` for polynomial basering injections and formal composite maps.\n\nIf you want me to make weakened coercion maps print as a big warning, then I could of course do so, but will only do if you ask.",
    "created_at": "2013-10-04T10:52:15Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181497",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:87'></a>
Done, and now I'd say it can be reviewed. With the latest commit, one can do

```
sage: phi = QQ['x'].coerce_map_from(ZZ)
sage: phi.domain
<weakref at 0xa225284; to 'sage.rings.integer_ring.IntegerRing_class' at 0x96ddd3c (EuclideanDomains.parent_class)>
sage: type(phi)
<type 'sage.categories.map.FormalCompositeMap'>
sage: psi = copy(phi)
sage: psi
Composite map:
  From: Integer Ring
  To:   Univariate Polynomial Ring in x over Rational Field
  Defn:   Natural morphism:
          From: Integer Ring
          To:   Rational Field
        then
          Polynomial base injection morphism:
          From: Rational Field
          To:   Univariate Polynomial Ring in x over Rational Field
sage: psi(3)
3
sage: psi.domain
The constant function (...) -> Integer Ring
```
which required implementing `__copy__` for polynomial basering injections and formal composite maps.

If you want me to make weakened coercion maps print as a big warning, then I could of course do so, but will only do if you ask.



---

archive/issue_events_128585.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-04T10:52:15Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128585"
}
```



---

archive/issue_comments_181498.json:
```json
{
    "body": "<a id='comment:88'></a>\nToo bad. Apparently the elliptic curve code does not like `SchemeMorphism` to be a `Morphism`...",
    "created_at": "2013-10-04T11:03:08Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181498",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:88'></a>
Too bad. Apparently the elliptic curve code does not like `SchemeMorphism` to be a `Morphism`...



---

archive/issue_comments_181499.json:
```json
{
    "body": "**Changing work issues** from \"Provide copy of composed maps\" to \"Fix elliptic curves code\".",
    "created_at": "2013-10-04T11:03:08Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181499",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "Provide copy of composed maps" to "Fix elliptic curves code".



---

archive/issue_events_128586.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-04T11:03:08Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128586"
}
```



---

archive/issue_events_128587.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-04T11:03:08Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128587"
}
```



---

archive/issue_comments_181500.json:
```json
{
    "body": "<a id='comment:89'></a>\nNamely:\n\n```\nsage: E=EllipticCurve('37a1')\nsage: P=E(0,0)\nsage: Q=5*P\n<Booom>\n```\napparently while trying to create an action.",
    "created_at": "2013-10-04T11:07:37Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181500",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:89'></a>
Namely:

```
sage: E=EllipticCurve('37a1')
sage: P=E(0,0)
sage: Q=5*P
<Booom>
```
apparently while trying to create an action.



---

archive/issue_comments_181501.json:
```json
{
    "body": "<a id='comment:90'></a>\nAha.\n\n```\nsage: P.__class__.mro()\n[sage.schemes.elliptic_curves.ell_point.EllipticCurvePoint_number_field,\n sage.schemes.elliptic_curves.ell_point.EllipticCurvePoint_field,\n sage.schemes.projective.projective_point.SchemeMorphism_point_abelian_variety_field,\n sage.structure.element.AdditiveGroupElement,\n sage.structure.element.ModuleElement,\n sage.schemes.projective.projective_point.SchemeMorphism_point_projective_field,\n sage.schemes.projective.projective_point.SchemeMorphism_point_projective_ring,\n sage.schemes.generic.morphism.SchemeMorphism_point,\n sage.schemes.generic.morphism.SchemeMorphism,\n sage.categories.morphism.Morphism,\n sage.categories.map.Map,\n sage.structure.element.Element,\n sage.structure.sage_object.SageObject,\n object]\n```\nand\n\n```\nsage: P.domain\n<bound method EllipticCurvePoint_number_field.domain of (0 : 0 : 1)>\nsage: P.domain.__module__\n'sage.schemes.elliptic_curves.ell_point'\nsage: P.domain??\nType:       instancemethod\nString Form:<bound method EllipticCurvePoint_number_field.domain of (0 : 0 : 1)>\nFile:       /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/schemes/elliptic_curves/ell_point.py\nDefinition: P.domain(self)\nSource:\n    def domain(self):\n        \"\"\"\n        Return the domain of this point, which is `Spec(F)` where `F` is\n        the field of definition.\n\n        EXAMPLES::\n\n            sage: E=EllipticCurve(QQ,[1,1])\n            sage: P=E(0,1)\n            sage: P.domain()\n            Spectrum of Rational Field\n            sage: K.<a>=NumberField(x^2-3,'a')\n            sage: P=E.base_extend(K)(1,a)\n            sage: P.domain()\n            Spectrum of Number Field in a with defining polynomial x^2 - 3\n       \"\"\"\n        return self.parent().domain()\n```\n\nSo, not only was `SchemeMorphism` ignoring `Morphism`, but additionally its sub-class `EllipticCurvePoint_fieldEllipticCurvePoint_field` overrode what it inherited from `SchemeMorphism` by a *verbosely identical* copy.\n\nThe elliptic curve code is a mess.",
    "created_at": "2013-10-04T12:31:19Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181501",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:90'></a>
Aha.

```
sage: P.__class__.mro()
[sage.schemes.elliptic_curves.ell_point.EllipticCurvePoint_number_field,
 sage.schemes.elliptic_curves.ell_point.EllipticCurvePoint_field,
 sage.schemes.projective.projective_point.SchemeMorphism_point_abelian_variety_field,
 sage.structure.element.AdditiveGroupElement,
 sage.structure.element.ModuleElement,
 sage.schemes.projective.projective_point.SchemeMorphism_point_projective_field,
 sage.schemes.projective.projective_point.SchemeMorphism_point_projective_ring,
 sage.schemes.generic.morphism.SchemeMorphism_point,
 sage.schemes.generic.morphism.SchemeMorphism,
 sage.categories.morphism.Morphism,
 sage.categories.map.Map,
 sage.structure.element.Element,
 sage.structure.sage_object.SageObject,
 object]
```
and

```
sage: P.domain
<bound method EllipticCurvePoint_number_field.domain of (0 : 0 : 1)>
sage: P.domain.__module__
'sage.schemes.elliptic_curves.ell_point'
sage: P.domain??
Type:       instancemethod
String Form:<bound method EllipticCurvePoint_number_field.domain of (0 : 0 : 1)>
File:       /home/king/Sage/git/sage/local/lib/python2.7/site-packages/sage/schemes/elliptic_curves/ell_point.py
Definition: P.domain(self)
Source:
    def domain(self):
        """
        Return the domain of this point, which is `Spec(F)` where `F` is
        the field of definition.

        EXAMPLES::

            sage: E=EllipticCurve(QQ,[1,1])
            sage: P=E(0,1)
            sage: P.domain()
            Spectrum of Rational Field
            sage: K.<a>=NumberField(x^2-3,'a')
            sage: P=E.base_extend(K)(1,a)
            sage: P.domain()
            Spectrum of Number Field in a with defining polynomial x^2 - 3
       """
        return self.parent().domain()
```

So, not only was `SchemeMorphism` ignoring `Morphism`, but additionally its sub-class `EllipticCurvePoint_fieldEllipticCurvePoint_field` overrode what it inherited from `SchemeMorphism` by a *verbosely identical* copy.

The elliptic curve code is a mess.



---

archive/issue_comments_181502.json:
```json
{
    "body": "<a id='comment:91'></a>\nIn `sage.schemes.elliptic_curves.heegner`, it also seems to me that `GaloisAutomorphism` should use `Morphism`. I don't know if I will change it here.",
    "created_at": "2013-10-04T12:40:23Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181502",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:91'></a>
In `sage.schemes.elliptic_curves.heegner`, it also seems to me that `GaloisAutomorphism` should use `Morphism`. I don't know if I will change it here.



---

archive/issue_comments_181503.json:
```json
{
    "body": "<a id='comment:92'></a>\nHmm. If we are in very bad luck, then the current commit triggers a bug in Cython concerning confusion of different cpdef slots when one provides two different base classes (`ModuleElement` and `Morphism`). Namely, it pretty much seems that\n\n```\n   (<ModuleElement>left)._add_(<ModuleElement>right)\n```\ndoes not return\n\n```\n   left._add_(right)\n```",
    "created_at": "2013-10-04T12:59:41Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181503",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:92'></a>
Hmm. If we are in very bad luck, then the current commit triggers a bug in Cython concerning confusion of different cpdef slots when one provides two different base classes (`ModuleElement` and `Morphism`). Namely, it pretty much seems that

```
   (<ModuleElement>left)._add_(<ModuleElement>right)
```
does not return

```
   left._add_(right)
```



---

archive/issue_comments_181504.json:
```json
{
    "body": "<a id='comment:93'></a>\nHooray!\n\n```\n----------------------------------------------------------------------\nAll tests passed!\n----------------------------------------------------------------------\nTotal time for all tests: 3777.0 seconds\n    cpu time: 5867.6 seconds\n    cumulative wall time: 7256.6 seconds\n```\n\nI added a \"todo\" to the documentation of `sage.schemes.generic.morphism`, stating that `SchemeMorphism` should rather inherit from `Morphism`, but currently can not, because of a bug in Cython. I modified the code so that it now exactly imitates the new `Morphism` code. In this way, a future transition to a sub-class of `Morphism` should be easier.\n\nAnyway, since the tests pass, I'd say it is \"needs review\" for now.\n\nPlan: If you believe that the new approach makes sense, then I'll also add a longer section to the reference manual, explaining how the weakref business is supposed to work.",
    "created_at": "2013-10-04T18:54:24Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181504",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:93'></a>
Hooray!

```
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 3777.0 seconds
    cpu time: 5867.6 seconds
    cumulative wall time: 7256.6 seconds
```

I added a "todo" to the documentation of `sage.schemes.generic.morphism`, stating that `SchemeMorphism` should rather inherit from `Morphism`, but currently can not, because of a bug in Cython. I modified the code so that it now exactly imitates the new `Morphism` code. In this way, a future transition to a sub-class of `Morphism` should be easier.

Anyway, since the tests pass, I'd say it is "needs review" for now.

Plan: If you believe that the new approach makes sense, then I'll also add a longer section to the reference manual, explaining how the weakref business is supposed to work.



---

archive/issue_events_128588.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-04T18:54:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128588"
}
```



---

archive/issue_events_128589.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-04T18:54:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128589"
}
```



---

archive/issue_comments_181505.json:
```json
{
    "body": "<a id='comment:94'></a>\nBy the way, I was looking into my logs/ptest.log, and it seems that the total cpu time for the tests remained essentially the same. Hence, hopefully there is no bad slow-down. But we should probably take some old benchmarks used at, say, #11900, and see what my new commits do with them.",
    "created_at": "2013-10-04T19:32:01Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181505",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:94'></a>
By the way, I was looking into my logs/ptest.log, and it seems that the total cpu time for the tests remained essentially the same. Hence, hopefully there is no bad slow-down. But we should probably take some old benchmarks used at, say, #11900, and see what my new commits do with them.



---

archive/issue_comments_181506.json:
```json
{
    "body": "<a id='comment:95'></a>\nHere are the tests from #11900.\n\nIn Commit:05fb569, I get\n\n```\nsage: E = J0(46).endomorphism_ring()\nsage: %time g = E.gens()\nCPU times: user 10.76 s, sys: 0.18 s, total: 10.93 s\nWall time: 10.95 s\nsage: %time TestSuite(CrystalOfTableaux(['B',4],shape=[2,1,1,0])).run()\nCPU times: user 3.12 s, sys: 0.00 s, total: 3.12 s\nWall time: 3.13 s\nsage: W.<z> = CyclotomicField(13)\nsage: %time M = Matrix(W, 2, 3, [10^30*(1-z)^13, 1, 2, 3, 4, z]).echelon_form()\nCPU times: user 2.28 s, sys: 0.02 s, total: 2.29 s\nWall time: 2.30 s\nsage: %time L = EllipticCurve('960d1').prove_BSD()\nCPU times: user 4.80 s, sys: 0.04 s, total: 4.84 s\nWall time: 4.85 s\nsage: def test(E):\n....:     for p in prime_range(10000):\n....:         if p != 389:\n....:             G = E.change_ring(GF(p)).abelian_group()\n....:\nsage: E = EllipticCurve('389a')\nsage: %time test(E)\nCPU times: user 31.56 s, sys: 0.09 s, total: 31.65 s\nWall time: 31.70 s\nsage: %time for E in cremona_curves([11..100]): S = E.integral_points(both_signs=False)\nCPU times: user 21.96 s, sys: 0.06 s, total: 22.02 s\nWall time: 22.07 s\n```\n\nIn public/sage-git/master, I get\n\n```\nsage: E = J0(46).endomorphism_ring()\nsage: %time g = E.gens()\nCPU times: user 10.72 s, sys: 0.17 s, total: 10.90 s\nWall time: 10.91 s\nsage: %time TestSuite(CrystalOfTableaux(['B',4],shape=[2,1,1,0])).run()\nCPU times: user 3.23 s, sys: 0.00 s, total: 3.23 s\nWall time: 3.24 s\nsage: W.<z> = CyclotomicField(13)\nsage: %time M = Matrix(W, 2, 3, [10^30*(1-z)^13, 1, 2, 3, 4, z]).echelon_form()\nCPU times: user 2.21 s, sys: 0.02 s, total: 2.23 s\nWall time: 2.23 s\nsage: %time L = EllipticCurve('960d1').prove_BSD()\nCPU times: user 5.27 s, sys: 0.04 s, total: 5.32 s\nWall time: 5.32 s\nsage: def test(E):\n....:    for p in prime_range(10000):\n....:        if p != 389:\n....:            G = E.change_ring(GF(p)).abelian_group()\n....:\nsage: E = EllipticCurve('389a')\nsage: %time test(E)\nCPU times: user 32.06 s, sys: 0.11 s, total: 32.17 s\nWall time: 32.22 s\nsage: %time for E in cremona_curves([11..100]): S = E.integral_points(both_signs=False)\nCPU times: user 22.11 s, sys: 0.07 s, total: 22.17 s\n```\nThese tests have been found sensitive against slowness in category and coercion framework. So, the fact that there is not the faintest regression in these tests gives some confidence.",
    "created_at": "2013-10-04T20:16:29Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181506",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:95'></a>
Here are the tests from #11900.

In Commit:05fb569, I get

```
sage: E = J0(46).endomorphism_ring()
sage: %time g = E.gens()
CPU times: user 10.76 s, sys: 0.18 s, total: 10.93 s
Wall time: 10.95 s
sage: %time TestSuite(CrystalOfTableaux(['B',4],shape=[2,1,1,0])).run()
CPU times: user 3.12 s, sys: 0.00 s, total: 3.12 s
Wall time: 3.13 s
sage: W.<z> = CyclotomicField(13)
sage: %time M = Matrix(W, 2, 3, [10^30*(1-z)^13, 1, 2, 3, 4, z]).echelon_form()
CPU times: user 2.28 s, sys: 0.02 s, total: 2.29 s
Wall time: 2.30 s
sage: %time L = EllipticCurve('960d1').prove_BSD()
CPU times: user 4.80 s, sys: 0.04 s, total: 4.84 s
Wall time: 4.85 s
sage: def test(E):
....:     for p in prime_range(10000):
....:         if p != 389:
....:             G = E.change_ring(GF(p)).abelian_group()
....:
sage: E = EllipticCurve('389a')
sage: %time test(E)
CPU times: user 31.56 s, sys: 0.09 s, total: 31.65 s
Wall time: 31.70 s
sage: %time for E in cremona_curves([11..100]): S = E.integral_points(both_signs=False)
CPU times: user 21.96 s, sys: 0.06 s, total: 22.02 s
Wall time: 22.07 s
```

In public/sage-git/master, I get

```
sage: E = J0(46).endomorphism_ring()
sage: %time g = E.gens()
CPU times: user 10.72 s, sys: 0.17 s, total: 10.90 s
Wall time: 10.91 s
sage: %time TestSuite(CrystalOfTableaux(['B',4],shape=[2,1,1,0])).run()
CPU times: user 3.23 s, sys: 0.00 s, total: 3.23 s
Wall time: 3.24 s
sage: W.<z> = CyclotomicField(13)
sage: %time M = Matrix(W, 2, 3, [10^30*(1-z)^13, 1, 2, 3, 4, z]).echelon_form()
CPU times: user 2.21 s, sys: 0.02 s, total: 2.23 s
Wall time: 2.23 s
sage: %time L = EllipticCurve('960d1').prove_BSD()
CPU times: user 5.27 s, sys: 0.04 s, total: 5.32 s
Wall time: 5.32 s
sage: def test(E):
....:    for p in prime_range(10000):
....:        if p != 389:
....:            G = E.change_ring(GF(p)).abelian_group()
....:
sage: E = EllipticCurve('389a')
sage: %time test(E)
CPU times: user 32.06 s, sys: 0.11 s, total: 32.17 s
Wall time: 32.22 s
sage: %time for E in cremona_curves([11..100]): S = E.integral_points(both_signs=False)
CPU times: user 22.11 s, sys: 0.07 s, total: 22.17 s
```
These tests have been found sensitive against slowness in category and coercion framework. So, the fact that there is not the faintest regression in these tests gives some confidence.



---

archive/issue_comments_181507.json:
```json
{
    "body": "<a id='comment:96'></a>\nReplying to [SimonKing](#comment%3A84):\n\n> One does! Namely, suppose that you first do `P.register_coercion(mor)`, then you allow `S` to become garbage collected, and then you create a new parent `Q` with an\n\nembedding into what looks like `S` (of course, it now is a replica of the original now garbage collected `S`).\n> You would want that `Q` coerces into `P` via `S`, by transitivity of coercions. But you collected `mor.domain()` and thus you will fail to find this coercion.\n\nI agree that there is a place for such strong connections, but I have severe reservations about declaring it's the only way or even the default way to inform the system\nabout coercions. \n\nThe following would leak memory with the model you propose:\n\n```\nM1=ZZ^1\nM2=ZZ^2\nfor d in [2..100000]:\n    N=ZZ^d\n    m1=Hom(N,M1)([M.0 for i in range(d)])\n    m2=Hom(N,M2)([M.(i % 2) for i in range(d)])\n    M1.register_coercion(m1)\n    M2.register_coercion(m2)\n```\nI have severe reservations about declaring that this code \"will never be memory efficient\" in sage. One way out is to use the (for this purpose) extremely inappropriately named\n\n```\n    N.register_embedding(m1)\n```\ninstead, which in your model would mean M1 lives at least as long as N instead. In addition, we would not be able to do this for both `M1` and `M2`.\n\nI think there's room for a `register_embedding` with those semantics (although it should probably have a different name, because it doesn't have to be an embedding)\nas well as for `register_coercion_from_while_keeping_domain_alive` with a catchier name, but the life-enhancing side effects are fundamentally separate from the fact\nthat there's a coercion in the first place, and I think it should be possible to register a non-life-enhancing coercion as well (the main reason is that\nit's easily done and that I haven't seen a proof it's not necessary. We don't want to unnecessarily hamstring the system).\n\n**philosophical ramblings**\n\nThe following observations are the result of trying to come up with a conceptual ideal/model that we could use to argue what our coercion framework SHOULD do. Up to\nnow it seems to me people have mainly been making ad-hoc, gut feeling decisions about how to put together coercion. I haven't found a better solution here, but I\nthink there are some examples may illustrate we might just have to be pragmatic about this.\n\nYour suggestion makes sense if you want to model a \"permanent, unchanging universe\" in which all possible parents, with consistent coercions, already exist; we're\nsimply \"discovering\" this universe in a piecemeal fashion. It's a common model in modern algebra, but I think our computer algebra model is too far away from this\nideal to follow this model too far. Consider:\n\n```\nQx.<x>=QQ[]\nK.<a>=NumberField(x^4-2)\nL.<b>=NumberField(x^2-2,embedding=a^2)\n```\nThis fits perfectly in the \"unchanging universe\" model. Also note that the coercion system does not need to let L keep K alive, since the construction parameters,\nwhich get kept alive for the life of L by `CachedRepresentation` or something analogous, refer to K already.\n\nNow consider\n\n```\nM.<b>=NumberField(x^2-2)\n```\nIn the \"unchanging universe\" (and in sage as well) we have that M is distinct from L. However, I think it's unrealistic to expect that all \"embeddings\" etc. can be\nspecified at construction time. So I think, even though it's not possible currently in sage, that one should allow for\n\n```\nm1=Hom(M,K)([a^2])\nm2=Hom(M,K)([-a^2])\nM.register_embedding(m1)\n```\nNote that the choice of `m1` or `m2` here leads to different relations between `M` and `K` and hence different universes.\nIn other words, our concept of \"globally unique\" is not powerful enough to capture the\nfull identity of objects, which would include the coercion relations with objects that haven't been \"discovered\" yet. In practice, we can usually work around that by\nfor instance changing the names of generators and hence create artificially differently labelled objects but that's already not a possibility for creating\ndifferent copies of `ZZ^n`, since there are no generator names to choose there.\n\nI think one has to accept the reality here: what we have is a collection of objects whose relations do change in time.\n \n\n\n**Some particular responses** (most of them direct corollaries from what is observed above).\n \n> Another attempt to explain why I think the explicitly registered maps need to be kept:\n> \n> Think of the coercions as a digraph.\n> - The vertices correspond to parents.\n> - The arrows (oriented edges) of the digraph correspond to those maps that are declared as coercions by `.register_coercion(...)`.\n> - In addition to the arrows created with `register_coercion`, the coercion system may find short-cuts by calling `._coerce_map_from_(...)`. For efficiency reasons,\n> these short-cuts are stored in a cache.\n> - The coercion system then tries to find directed paths between two given vertices, including short-cuts. For efficiency reasons, it stores the resulting composed\n> maps in a cache.\n\nThat's not the only thing coercion does. It may also find \"common covering structures\", which may lead to construction of new parents. Those definitely don't deserve\nto get nailed into memory. Yet, the code that creates these parents will look (to the coercion system) as a \"user\", so it would be using these strong-referencing\ncoercion registration routines.\n\n> So, the coercion system will not care for the health of P, but it must care for the connectivity of the coercion graph. And in the current algorithm sketched above,\n> it is of vital importance to keep arrows leading to P alive, since otherwise we have to live with shortcuts only.\n\nI think it may well be a feature, not a bug, that one at some point can just be left with the shortcuts and that the intermediates have fallen out. The natural way of\nstaying close to \"discovering a permanent universe\" is by never throwing away anything that has been discovered, and I think we agree that's a \"memory leak\". So\nit's really a matter of only keeping things around that we still need. If we're too lax with considering what is \"needed\", we'll end up keeping too many things in\nmemory.\n\n> Then we look into the code and see that multiple embeddings are explicitly excluded. A parent has precisely one embedding that is taken into account by the coercion\n\nsearch *in forward direction*. You may of course register further embeddings as coercions, by `emb.codomain().register_coercion(emb)`, but they would only be used\nfor search in backward direction.\n\nNot only that: you'd be tying different lifetime implications to that construction too.\n\n> And there surely is a means available to add a coercion that doesn't tie the lifespan of two parents too closely: Implement `P._coerce_map_from_(Q)`, which can\n> return a map or simply \"True\" (in the latter case, conversion is used to coerce Q into P). The result is cached in `P._coerce_from_hash`, but not in\n> `P._coerce_from_list`.\n\nYou mean: implement `P._install_coerce_map_from_(m)`, which does: `_coerce_from_hash[Domain(m)]=m`. I think it is quite important to be able to manipulate the\ncoercion graph without having to modify library code.",
    "created_at": "2013-10-04T23:35:42Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181507",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:96'></a>
Replying to [SimonKing](#comment%3A84):

> One does! Namely, suppose that you first do `P.register_coercion(mor)`, then you allow `S` to become garbage collected, and then you create a new parent `Q` with an

embedding into what looks like `S` (of course, it now is a replica of the original now garbage collected `S`).
> You would want that `Q` coerces into `P` via `S`, by transitivity of coercions. But you collected `mor.domain()` and thus you will fail to find this coercion.

I agree that there is a place for such strong connections, but I have severe reservations about declaring it's the only way or even the default way to inform the system
about coercions. 

The following would leak memory with the model you propose:

```
M1=ZZ^1
M2=ZZ^2
for d in [2..100000]:
    N=ZZ^d
    m1=Hom(N,M1)([M.0 for i in range(d)])
    m2=Hom(N,M2)([M.(i % 2) for i in range(d)])
    M1.register_coercion(m1)
    M2.register_coercion(m2)
```
I have severe reservations about declaring that this code "will never be memory efficient" in sage. One way out is to use the (for this purpose) extremely inappropriately named

```
    N.register_embedding(m1)
```
instead, which in your model would mean M1 lives at least as long as N instead. In addition, we would not be able to do this for both `M1` and `M2`.

I think there's room for a `register_embedding` with those semantics (although it should probably have a different name, because it doesn't have to be an embedding)
as well as for `register_coercion_from_while_keeping_domain_alive` with a catchier name, but the life-enhancing side effects are fundamentally separate from the fact
that there's a coercion in the first place, and I think it should be possible to register a non-life-enhancing coercion as well (the main reason is that
it's easily done and that I haven't seen a proof it's not necessary. We don't want to unnecessarily hamstring the system).

**philosophical ramblings**

The following observations are the result of trying to come up with a conceptual ideal/model that we could use to argue what our coercion framework SHOULD do. Up to
now it seems to me people have mainly been making ad-hoc, gut feeling decisions about how to put together coercion. I haven't found a better solution here, but I
think there are some examples may illustrate we might just have to be pragmatic about this.

Your suggestion makes sense if you want to model a "permanent, unchanging universe" in which all possible parents, with consistent coercions, already exist; we're
simply "discovering" this universe in a piecemeal fashion. It's a common model in modern algebra, but I think our computer algebra model is too far away from this
ideal to follow this model too far. Consider:

```
Qx.<x>=QQ[]
K.<a>=NumberField(x^4-2)
L.<b>=NumberField(x^2-2,embedding=a^2)
```
This fits perfectly in the "unchanging universe" model. Also note that the coercion system does not need to let L keep K alive, since the construction parameters,
which get kept alive for the life of L by `CachedRepresentation` or something analogous, refer to K already.

Now consider

```
M.<b>=NumberField(x^2-2)
```
In the "unchanging universe" (and in sage as well) we have that M is distinct from L. However, I think it's unrealistic to expect that all "embeddings" etc. can be
specified at construction time. So I think, even though it's not possible currently in sage, that one should allow for

```
m1=Hom(M,K)([a^2])
m2=Hom(M,K)([-a^2])
M.register_embedding(m1)
```
Note that the choice of `m1` or `m2` here leads to different relations between `M` and `K` and hence different universes.
In other words, our concept of "globally unique" is not powerful enough to capture the
full identity of objects, which would include the coercion relations with objects that haven't been "discovered" yet. In practice, we can usually work around that by
for instance changing the names of generators and hence create artificially differently labelled objects but that's already not a possibility for creating
different copies of `ZZ^n`, since there are no generator names to choose there.

I think one has to accept the reality here: what we have is a collection of objects whose relations do change in time.
 


**Some particular responses** (most of them direct corollaries from what is observed above).
 
> Another attempt to explain why I think the explicitly registered maps need to be kept:
> 
> Think of the coercions as a digraph.
> - The vertices correspond to parents.
> - The arrows (oriented edges) of the digraph correspond to those maps that are declared as coercions by `.register_coercion(...)`.
> - In addition to the arrows created with `register_coercion`, the coercion system may find short-cuts by calling `._coerce_map_from_(...)`. For efficiency reasons,
> these short-cuts are stored in a cache.
> - The coercion system then tries to find directed paths between two given vertices, including short-cuts. For efficiency reasons, it stores the resulting composed
> maps in a cache.

That's not the only thing coercion does. It may also find "common covering structures", which may lead to construction of new parents. Those definitely don't deserve
to get nailed into memory. Yet, the code that creates these parents will look (to the coercion system) as a "user", so it would be using these strong-referencing
coercion registration routines.

> So, the coercion system will not care for the health of P, but it must care for the connectivity of the coercion graph. And in the current algorithm sketched above,
> it is of vital importance to keep arrows leading to P alive, since otherwise we have to live with shortcuts only.

I think it may well be a feature, not a bug, that one at some point can just be left with the shortcuts and that the intermediates have fallen out. The natural way of
staying close to "discovering a permanent universe" is by never throwing away anything that has been discovered, and I think we agree that's a "memory leak". So
it's really a matter of only keeping things around that we still need. If we're too lax with considering what is "needed", we'll end up keeping too many things in
memory.

> Then we look into the code and see that multiple embeddings are explicitly excluded. A parent has precisely one embedding that is taken into account by the coercion

search *in forward direction*. You may of course register further embeddings as coercions, by `emb.codomain().register_coercion(emb)`, but they would only be used
for search in backward direction.

Not only that: you'd be tying different lifetime implications to that construction too.

> And there surely is a means available to add a coercion that doesn't tie the lifespan of two parents too closely: Implement `P._coerce_map_from_(Q)`, which can
> return a map or simply "True" (in the latter case, conversion is used to coerce Q into P). The result is cached in `P._coerce_from_hash`, but not in
> `P._coerce_from_list`.

You mean: implement `P._install_coerce_map_from_(m)`, which does: `_coerce_from_hash[Domain(m)]=m`. I think it is quite important to be able to manipulate the
coercion graph without having to modify library code.



---

archive/issue_comments_181508.json:
```json
{
    "body": "<a id='comment:97'></a>\nCongratulations on making such good headway! The main thing left is to determine how weakly referenced the coercion framework needs to be.",
    "created_at": "2013-10-05T00:39:26Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181508",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:97'></a>
Congratulations on making such good headway! The main thing left is to determine how weakly referenced the coercion framework needs to be.



---

archive/issue_comments_181509.json:
```json
{
    "body": "**Commit:** [05fb569cb132a8c89713021f1f4b25cd2dd7cb1c](https://github.com/sagemath/sagetrac-mirror/commit/05fb569cb132a8c89713021f1f4b25cd2dd7cb1c)",
    "created_at": "2013-10-05T09:13:30Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181509",
    "user": "https://github.com/simon-king-jena"
}
```

**Commit:** [05fb569cb132a8c89713021f1f4b25cd2dd7cb1c](https://github.com/sagemath/sagetrac-mirror/commit/05fb569cb132a8c89713021f1f4b25cd2dd7cb1c)



---

archive/issue_comments_181510.json:
```json
{
    "body": "<a id='comment:98'></a>\n**New commits:**\n<table><tr><td>[changeset:05fb569]</td><td><code>Change SchemeMorphism back (to cope with a Cython bug), copying the new code from sage.categories.map.Map</code></td></tr><tr><td>[changeset:8fd09d5]</td><td><code>Copying of PolynomialBaseringInjection and FormalCompositeMap</code></td></tr><tr><td>[changeset:be37145]</td><td><code>Let SchemeMorphism inherit from Morphism, not from Element</code></td></tr><tr><td>[changeset:0f38a2c]</td><td><code>Keep strong reference to codomain of weakened coerce maps Keep strong reference to domains of *registered* coercions</code></td></tr><tr><td>[changeset:a53261d]</td><td><code>Keep a strong reference to the codomain of PrecomposedAction</code></td></tr><tr><td>[changeset:1ff6f3f]</td><td><code>Add generic copy of maps. Fix copy of elements. Replace _(co)domain everywhere</code></td></tr><tr><td>[changeset:61d818c]</td><td><code>Replace Map.(co)domain by constant functions, remove ._(co)domain</code></td></tr><tr><td>[changeset:ebe82df]</td><td><code>Use a proper WeakValueDictionary for number fields</code></td></tr><tr><td>[changeset:4685c73]</td><td><code>convert_map_from() should only store weak references Similar to coerce_map_from, the detected morphism should be stored only in a weak dictionary, not in a list.</code></td></tr></table>\n",
    "created_at": "2013-10-05T09:13:30Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181510",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:98'></a>
**New commits:**
<table><tr><td>[changeset:05fb569]</td><td><code>Change SchemeMorphism back (to cope with a Cython bug), copying the new code from sage.categories.map.Map</code></td></tr><tr><td>[changeset:8fd09d5]</td><td><code>Copying of PolynomialBaseringInjection and FormalCompositeMap</code></td></tr><tr><td>[changeset:be37145]</td><td><code>Let SchemeMorphism inherit from Morphism, not from Element</code></td></tr><tr><td>[changeset:0f38a2c]</td><td><code>Keep strong reference to codomain of weakened coerce maps Keep strong reference to domains of *registered* coercions</code></td></tr><tr><td>[changeset:a53261d]</td><td><code>Keep a strong reference to the codomain of PrecomposedAction</code></td></tr><tr><td>[changeset:1ff6f3f]</td><td><code>Add generic copy of maps. Fix copy of elements. Replace _(co)domain everywhere</code></td></tr><tr><td>[changeset:61d818c]</td><td><code>Replace Map.(co)domain by constant functions, remove ._(co)domain</code></td></tr><tr><td>[changeset:ebe82df]</td><td><code>Use a proper WeakValueDictionary for number fields</code></td></tr><tr><td>[changeset:4685c73]</td><td><code>convert_map_from() should only store weak references Similar to coerce_map_from, the detected morphism should be stored only in a weak dictionary, not in a list.</code></td></tr></table>




---

archive/issue_comments_181511.json:
```json
{
    "body": "<a id='comment:99'></a>\nReplying to [nbruin](#comment%3A96):\n> I agree that there is a place for such strong connections, but I have severe reservations about declaring it [`.register_coercion()`] is the only way or even the default way to inform the system\n> about coercions.\n\nWell, I have mentioned `._coerce_map_from_(...)` in several previous posts, and if you look at my thematic tutorial on categories and coercion, you'll find that I consider *this* the default. And it only yields *weak* caching.\n\n> I have severe reservations about declaring that this code \"will never be memory efficient\" in sage.\n\nI think that we want *some* particularly important coercions to be tied to the lifetime of the codomain, and thus we use `.register_coercion()`, and we want other coercions to be tied to the minimum of the lifetimes of domain and codomain, and thus we use `._coerce_map_from_()`. I don't think we have a problem here.\n\n> Consider:\n> \n> ```\n> Qx.<x>=QQ[]\n> K.<a>=NumberField(x^4-2)\n> L.<b>=NumberField(x^2-2,embedding=a^2)\n> ```\n> This fits perfectly in the \"unchanging universe\" model. Also note that the coercion system does not need to let L keep K alive, since the construction parameters,\n> which get kept alive for the life of L by `CachedRepresentation` or something analogous, refer to K already.\n\nIt isn't `CachedRepresentation`, but this doesn't matter.\n\n> Now consider\n> \n> ```\n> M.<b>=NumberField(x^2-2)\n> ```\n> In the \"unchanging universe\" (and in sage as well) we have that M is distinct from L. However, I think it's unrealistic to expect that all \"embeddings\" etc. can be\n> specified at construction time.\n\nAgain, nobody has claimed that everything needs to be declared at construction\ntime. There are some particularly important coercions registered at\nconstruction time, namely **the** coerce embedding (if it exists then it is\nunique) and those installed by `.register_coercion()`. Everything else is\ndynamical, based on `_coerce_map_from_()`.\n\nIn my description from [comment:84](#comment%3A84), note that the digraph is not totally\nstatic. It has static parts (corresponding to coerce embeddings and coercions\nfixed by `.register_coercion()`) and dynamic shortcuts (corresponding to `_coerce_map_from_`).\n\n\n> So I think, even though it's not possible currently in sage, that one should allow for\n> \n> ```\n> m1=Hom(M,K)([a^2])\n> m2=Hom(M,K)([-a^2])\n> M.register_embedding(m1)\n> ```\n\nI don't know if this is reasonable, but at least it is against what people\noriginally wanted with the coerce embedding. If you declare the coerce\nembedding phi from a number field `K` to, say, `CC`, then you consider `K` as a\nsubfield of `CC`. If you provide another number field `L`, which is isomorphic\nto `K`, with a different embedding psi into `CC`, then adding an element of\n`K` to an element of `L` is done by embedding both into `CC` and then adding\ncomplex numbers.\n\nSince we think of K and L as different subfields of `CC` and not as abstract\nfields, we *must* consider K and L as different objects, and so the different\nembedding must play a role in the cache key for K and L. This is why they have\nto be provided at construction time.\n\nIt would be a totally different way of thinking if you tried to do the same\nwith `CC.register_coercion(phi/psi)` or with\n`CC._coerce_map_from_(K/L)`. Namely, in both cases, you would not be able to\nadd elements of K and L, because neither K nor L would know about the\nembedding. And in fact you would consider K and L as abstract fields, and you\nwould in fact want `K is L` (at least if you fancy unique parents, which I\ndo...). And then the axioms for coercion would strike: There can be at most\none coercion from `K` (i.e., `L`) to `CC`. Hence, you could *not*\nsimultaneously declare different embeddings of `K` into `CC` as coercions.\n\nSince it pretty much seems to me that number theorists want to comfortable\ncompute with different isomorphic subfields of `CC`, it would thus simply not\nfeasible to restrict oneself to `.register_coercion` and `_coerce_map_from_`:\nOne *needs* coerce embeddings, and one *needs* that they are part of the\ndefining data of a number field.\n\n> Note that the choice of `m1` or `m2` here leads to different relations between `M` and `K` and hence different universes.\n> In other words, our concept of \"globally unique\" is not powerful enough to capture the\n> full identity of objects, which would include the coercion relations with\n> objects that haven't been \"discovered\" yet.\n\nI would state it differently. In order to define `K` (a subfield of CC), there\nis no way around providing the embedding during creation. \"Discovering\" a\ncoercion relation seems the wrong approach here.\n\nAnd speaking about memory: The embedding of K into CC is stored as an\nattribute of K, not of CC. Hence, K keeps CC alive, but CC does not prevent K\nfrom garbage collection. So, I really don't understand where you see a problem.\n\n> In practice, we can usually work around that by\n> for instance changing the names of generators and hence create artificially differently labelled objects but that's already not a possibility for creating\n> different copies of `ZZ^n`, since there are no generator names to choose there.\n\nWell, if one has obvious distinguishing data, such as an embedding, then there\nis nothing artificial when using them.\n\n> I think one has to accept the reality here: what we have is a collection of objects whose relations do change in time.\n\nNo. I don't see anything dynamic in your \"embedded numberfield\" examples. A\nsubfield is a subfield is a subfield.\n\n> That's not the only thing coercion does. It may also find \"common covering\n> structures\", which may lead to construction of new parents. Those definitely\n> don't deserve to get nailed into memory. Yet, the code that creates these\n> parents will look (to the coercion system) as a \"user\", so it would be using\n> these strong-referencing coercion registration routines.\n\nWhat you seem to mention here is the pushout construction. It mainly relies on\n\"construction functors\". I don't even know if it takes the coerce embeddings\ninto account at all.\n\nAnyway, the new parents created by pushouts indeed play the same role as parents\ncreated by the user. Let's try to be more concrete. Let P and Q be\nparents, you want to add an element p of P to an element q of Q, and the pushout\nconstruction finds a parent R such that both P and Q coerce into R, allowing\nto perform the addition in R, resulting in `r=R(p)+R(q)`.\n\nNow, it could be that `R.register_coercion(P)` and `R.register_coercion(Q)`\nare both executed in `R.__init__` (but see the remark below). In the current\ncode (also in my branch), this would imply a strong reference chain from R to\nboth P and Q. Hence, even if you did `del p,q,P,Q`, P and Q could not be\ngarbage collected.\n\nBut I don't think we should see this problematic, for several reasons:\n\n- Pushout constructions don't arise particularly often. Normally, either P\n  coerces into Q or Q coerces into P, or both embed into the same parent\n  anyway, and I have mentioned above: With a coerce embedding, the existance\n  of R would not prevent P and Q from garbage collection (plus, it has nothing\n  to do with pushout anyway...)\n\n- Is `register_coercion` really used so often? I think `_coerce_map_from_` is\n  more commonly used, and then the existence of R would *not* prevent P and\n  Q from garbage collection.\n\n> I think it may well be a feature, not a bug, that one at some point can just\n> be left with the shortcuts and that the intermediates have fallen out.\n\nHow would you guarantee that you kept in mind enough shortcuts to not change\nconnectivity by throwing away intermediates?\n\n> The\n> natural way of staying close to \"discovering a permanent universe\" is by\n> never throwing away anything that has been discovered, and I think we agree\n> that's a \"memory leak\".\n\nNo, we disagree.\n\nIt is a memory leak if a connected component (not taking into account\nshortcuts) of the coercion graph can not be garbage collected, even though\nthere is no external strong reference (which may be a coerce embedding) to any\nvertex of the connected component.\n\nNote that this was exactly the problem with the example from the ticket\ndescription! As I have pointed out in [comment:18](#comment%3A18), it was *not* the case that\nthe problem lay in `_coerce_from_list_`, because this was empty. In\nparticular, it was *not* the case that `.register_coercion()` was to\nblame.\n\nInstead, the memory leak came from short-cuts, i.e., from the stuff\nstored in `_coerce_from_hash`, which can also be seen in\n[attachment:chain.png](https://github.com/sagemath/sage/files/ticket14711/chain.png).\n\nHence, the quadratic field and CC did belong to different connected components\nof the coercion graph, but the shortcut kept Q alive.\n\n> > And there surely is a means available to add a coercion that doesn't tie the\n> > lifespan of two parents too closely: Implement `P._coerce_map_from_(Q)`,\n> > which can return a map or simply \"True\" (in the latter case, conversion is\n> > used to coerce Q into P). The result is cached in `P._coerce_from_hash`, but\n> > not in `P._coerce_from_list`.\n\n> You mean: implement\n> `P._install_coerce_map_from_(m)`, which does:\n> `_coerce_from_hash[Domain(m)]=m`. I think it is quite important to be able\n> to manipulate the coercion graph without having to modify library code.\n\nThis might be a good idea. So, we would have `.register_coercion()` for\npermanent pathways, and `_install_coerce_map_from()` (with a similar\nsemantics, i.e., you can either just provide the parent or a whole morphism)\nfor impermanent shortcuts.",
    "created_at": "2013-10-05T09:13:30Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181511",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:99'></a>
Replying to [nbruin](#comment%3A96):
> I agree that there is a place for such strong connections, but I have severe reservations about declaring it [`.register_coercion()`] is the only way or even the default way to inform the system
> about coercions.

Well, I have mentioned `._coerce_map_from_(...)` in several previous posts, and if you look at my thematic tutorial on categories and coercion, you'll find that I consider *this* the default. And it only yields *weak* caching.

> I have severe reservations about declaring that this code "will never be memory efficient" in sage.

I think that we want *some* particularly important coercions to be tied to the lifetime of the codomain, and thus we use `.register_coercion()`, and we want other coercions to be tied to the minimum of the lifetimes of domain and codomain, and thus we use `._coerce_map_from_()`. I don't think we have a problem here.

> Consider:
> 
> ```
> Qx.<x>=QQ[]
> K.<a>=NumberField(x^4-2)
> L.<b>=NumberField(x^2-2,embedding=a^2)
> ```
> This fits perfectly in the "unchanging universe" model. Also note that the coercion system does not need to let L keep K alive, since the construction parameters,
> which get kept alive for the life of L by `CachedRepresentation` or something analogous, refer to K already.

It isn't `CachedRepresentation`, but this doesn't matter.

> Now consider
> 
> ```
> M.<b>=NumberField(x^2-2)
> ```
> In the "unchanging universe" (and in sage as well) we have that M is distinct from L. However, I think it's unrealistic to expect that all "embeddings" etc. can be
> specified at construction time.

Again, nobody has claimed that everything needs to be declared at construction
time. There are some particularly important coercions registered at
construction time, namely **the** coerce embedding (if it exists then it is
unique) and those installed by `.register_coercion()`. Everything else is
dynamical, based on `_coerce_map_from_()`.

In my description from [comment:84](#comment%3A84), note that the digraph is not totally
static. It has static parts (corresponding to coerce embeddings and coercions
fixed by `.register_coercion()`) and dynamic shortcuts (corresponding to `_coerce_map_from_`).


> So I think, even though it's not possible currently in sage, that one should allow for
> 
> ```
> m1=Hom(M,K)([a^2])
> m2=Hom(M,K)([-a^2])
> M.register_embedding(m1)
> ```

I don't know if this is reasonable, but at least it is against what people
originally wanted with the coerce embedding. If you declare the coerce
embedding phi from a number field `K` to, say, `CC`, then you consider `K` as a
subfield of `CC`. If you provide another number field `L`, which is isomorphic
to `K`, with a different embedding psi into `CC`, then adding an element of
`K` to an element of `L` is done by embedding both into `CC` and then adding
complex numbers.

Since we think of K and L as different subfields of `CC` and not as abstract
fields, we *must* consider K and L as different objects, and so the different
embedding must play a role in the cache key for K and L. This is why they have
to be provided at construction time.

It would be a totally different way of thinking if you tried to do the same
with `CC.register_coercion(phi/psi)` or with
`CC._coerce_map_from_(K/L)`. Namely, in both cases, you would not be able to
add elements of K and L, because neither K nor L would know about the
embedding. And in fact you would consider K and L as abstract fields, and you
would in fact want `K is L` (at least if you fancy unique parents, which I
do...). And then the axioms for coercion would strike: There can be at most
one coercion from `K` (i.e., `L`) to `CC`. Hence, you could *not*
simultaneously declare different embeddings of `K` into `CC` as coercions.

Since it pretty much seems to me that number theorists want to comfortable
compute with different isomorphic subfields of `CC`, it would thus simply not
feasible to restrict oneself to `.register_coercion` and `_coerce_map_from_`:
One *needs* coerce embeddings, and one *needs* that they are part of the
defining data of a number field.

> Note that the choice of `m1` or `m2` here leads to different relations between `M` and `K` and hence different universes.
> In other words, our concept of "globally unique" is not powerful enough to capture the
> full identity of objects, which would include the coercion relations with
> objects that haven't been "discovered" yet.

I would state it differently. In order to define `K` (a subfield of CC), there
is no way around providing the embedding during creation. "Discovering" a
coercion relation seems the wrong approach here.

And speaking about memory: The embedding of K into CC is stored as an
attribute of K, not of CC. Hence, K keeps CC alive, but CC does not prevent K
from garbage collection. So, I really don't understand where you see a problem.

> In practice, we can usually work around that by
> for instance changing the names of generators and hence create artificially differently labelled objects but that's already not a possibility for creating
> different copies of `ZZ^n`, since there are no generator names to choose there.

Well, if one has obvious distinguishing data, such as an embedding, then there
is nothing artificial when using them.

> I think one has to accept the reality here: what we have is a collection of objects whose relations do change in time.

No. I don't see anything dynamic in your "embedded numberfield" examples. A
subfield is a subfield is a subfield.

> That's not the only thing coercion does. It may also find "common covering
> structures", which may lead to construction of new parents. Those definitely
> don't deserve to get nailed into memory. Yet, the code that creates these
> parents will look (to the coercion system) as a "user", so it would be using
> these strong-referencing coercion registration routines.

What you seem to mention here is the pushout construction. It mainly relies on
"construction functors". I don't even know if it takes the coerce embeddings
into account at all.

Anyway, the new parents created by pushouts indeed play the same role as parents
created by the user. Let's try to be more concrete. Let P and Q be
parents, you want to add an element p of P to an element q of Q, and the pushout
construction finds a parent R such that both P and Q coerce into R, allowing
to perform the addition in R, resulting in `r=R(p)+R(q)`.

Now, it could be that `R.register_coercion(P)` and `R.register_coercion(Q)`
are both executed in `R.__init__` (but see the remark below). In the current
code (also in my branch), this would imply a strong reference chain from R to
both P and Q. Hence, even if you did `del p,q,P,Q`, P and Q could not be
garbage collected.

But I don't think we should see this problematic, for several reasons:

- Pushout constructions don't arise particularly often. Normally, either P
  coerces into Q or Q coerces into P, or both embed into the same parent
  anyway, and I have mentioned above: With a coerce embedding, the existance
  of R would not prevent P and Q from garbage collection (plus, it has nothing
  to do with pushout anyway...)

- Is `register_coercion` really used so often? I think `_coerce_map_from_` is
  more commonly used, and then the existence of R would *not* prevent P and
  Q from garbage collection.

> I think it may well be a feature, not a bug, that one at some point can just
> be left with the shortcuts and that the intermediates have fallen out.

How would you guarantee that you kept in mind enough shortcuts to not change
connectivity by throwing away intermediates?

> The
> natural way of staying close to "discovering a permanent universe" is by
> never throwing away anything that has been discovered, and I think we agree
> that's a "memory leak".

No, we disagree.

It is a memory leak if a connected component (not taking into account
shortcuts) of the coercion graph can not be garbage collected, even though
there is no external strong reference (which may be a coerce embedding) to any
vertex of the connected component.

Note that this was exactly the problem with the example from the ticket
description! As I have pointed out in [comment:18](#comment%3A18), it was *not* the case that
the problem lay in `_coerce_from_list_`, because this was empty. In
particular, it was *not* the case that `.register_coercion()` was to
blame.

Instead, the memory leak came from short-cuts, i.e., from the stuff
stored in `_coerce_from_hash`, which can also be seen in
[attachment:chain.png](https://github.com/sagemath/sage/files/ticket14711/chain.png).

Hence, the quadratic field and CC did belong to different connected components
of the coercion graph, but the shortcut kept Q alive.

> > And there surely is a means available to add a coercion that doesn't tie the
> > lifespan of two parents too closely: Implement `P._coerce_map_from_(Q)`,
> > which can return a map or simply "True" (in the latter case, conversion is
> > used to coerce Q into P). The result is cached in `P._coerce_from_hash`, but
> > not in `P._coerce_from_list`.

> You mean: implement
> `P._install_coerce_map_from_(m)`, which does:
> `_coerce_from_hash[Domain(m)]=m`. I think it is quite important to be able
> to manipulate the coercion graph without having to modify library code.

This might be a good idea. So, we would have `.register_coercion()` for
permanent pathways, and `_install_coerce_map_from()` (with a similar
semantics, i.e., you can either just provide the parent or a whole morphism)
for impermanent shortcuts.



---

archive/issue_comments_181512.json:
```json
{
    "body": "<a id='comment:0'></a>\nLet me try to summarise what is (or may be) left to do:\n\n- Add a section explaining the current weak coercion model, to facilitate maintanance,\n- I think I forgot to add some doc strings when I changed `SchemeMorphism`,\n- Add `_install_coerce_map_from()`.\n- Perhaps: Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.\n- Perhaps: Re-introduce a `cdef public` attribute `_codomain`, since this would allow faster access than calling `.codomain()`, and since the codomain will be strongly referenced anyway.\n\nAnything I forgot?",
    "created_at": "2013-10-05T09:18:02Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181512",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
Let me try to summarise what is (or may be) left to do:

- Add a section explaining the current weak coercion model, to facilitate maintanance,
- I think I forgot to add some doc strings when I changed `SchemeMorphism`,
- Add `_install_coerce_map_from()`.
- Perhaps: Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.
- Perhaps: Re-introduce a `cdef public` attribute `_codomain`, since this would allow faster access than calling `.codomain()`, and since the codomain will be strongly referenced anyway.

Anything I forgot?



---

archive/issue_comments_181513.json:
```json
{
    "body": "**Changing work issues** from \"Fix elliptic curves code\" to \"\".",
    "created_at": "2013-10-05T12:28:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181513",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "Fix elliptic curves code" to "".



---

archive/issue_comments_181514.json:
```json
{
    "body": "<a id='comment:2'></a>\nAnd I think I should do a further test: I will modify `Parent.__init__` so that it prints the type of self to a log file, and so I'll see how many parents are created with and without the patch. If we see a sudden change in the statistics for some types, then it might point us to code that implicitly relies on a permanent cache.",
    "created_at": "2013-10-05T12:45:24Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181514",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
And I think I should do a further test: I will modify `Parent.__init__` so that it prints the type of self to a log file, and so I'll see how many parents are created with and without the patch. If we see a sudden change in the statistics for some types, then it might point us to code that implicitly relies on a permanent cache.



---

archive/issue_comments_181515.json:
```json
{
    "body": "<a id='comment:103'></a>\nReplying to [SimonKing](#comment%3A100):\n\nGood, I think we at least are in sufficient agreement for the practical implications of what we need.\n\n> Let me try to summarise what is (or may be) left to do:\n> \n> - Add a section explaining the current weak coercion model, to facilitate maintenance,\n> - Add `_install_coerce_map_from()`.\n\nTo clarify this point (and it might be helpful to put something along these lines in the documentation), it seems to me there would be 4 ways to put coercions in place:\n- A programmatic way, by supplying code in `_coerce_map_from_`. Since it's programmatic, it seems it can be rediscovered easily when parents get garbage collected and recreated, so it seems appropriate maps stemming from here do not lead to lifetime implications.\n- A way to put a coercion in that ensures that the codomain keeps the domain alive (`.register_coercion`)\n- A way to put a coercion in that ensures that the domain keeps the codomain alive (`register_embedding` does that, but only can only accommodate one per domain)\n- A way to put a coercion in that does not imply any life support between domain and codomain. Someone who starts out should probably not use this, because garbage collection can lead to surprising results. It may be required to avoid memory problems.\nI think the fourth point is desirable because the alternative, programmatic solutions via `_coerce_map_from_`, feel much more heavy-weight (subclassing a whole parent just to extend `_coerce_map_from_` may be appropriate for someone who is concerned with developing sage, but seems inappropriate to me for someone who is thinking about using sage to do a complicated computation.\n\n> - Perhaps: Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.\n\nI think yes: Due to cyclic references, parents will usually survive until the next GC, which may be quite a while after the last reference is lost. So place where the map becomes liable to turn defunct may be quite distant from the place where the map if found to be defunct. People deserve a reminder about that.",
    "created_at": "2013-10-05T18:07:27Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181515",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:103'></a>
Replying to [SimonKing](#comment%3A100):

Good, I think we at least are in sufficient agreement for the practical implications of what we need.

> Let me try to summarise what is (or may be) left to do:
> 
> - Add a section explaining the current weak coercion model, to facilitate maintenance,
> - Add `_install_coerce_map_from()`.

To clarify this point (and it might be helpful to put something along these lines in the documentation), it seems to me there would be 4 ways to put coercions in place:
- A programmatic way, by supplying code in `_coerce_map_from_`. Since it's programmatic, it seems it can be rediscovered easily when parents get garbage collected and recreated, so it seems appropriate maps stemming from here do not lead to lifetime implications.
- A way to put a coercion in that ensures that the codomain keeps the domain alive (`.register_coercion`)
- A way to put a coercion in that ensures that the domain keeps the codomain alive (`register_embedding` does that, but only can only accommodate one per domain)
- A way to put a coercion in that does not imply any life support between domain and codomain. Someone who starts out should probably not use this, because garbage collection can lead to surprising results. It may be required to avoid memory problems.
I think the fourth point is desirable because the alternative, programmatic solutions via `_coerce_map_from_`, feel much more heavy-weight (subclassing a whole parent just to extend `_coerce_map_from_` may be appropriate for someone who is concerned with developing sage, but seems inappropriate to me for someone who is thinking about using sage to do a complicated computation.

> - Perhaps: Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.

I think yes: Due to cyclic references, parents will usually survive until the next GC, which may be quite a while after the last reference is lost. So place where the map becomes liable to turn defunct may be quite distant from the place where the map if found to be defunct. People deserve a reminder about that.



---

archive/issue_comments_181516.json:
```json
{
    "body": "<a id='comment:104'></a>\nReplying to [nbruin](#comment%3A103):\n> Replying to [SimonKing](#comment%3A100):\n> > Let me try to summarise what is (or may be) left to do:\n> > \n> > - Add a section explaining the current weak coercion model, to facilitate maintenance,\n> > - Add `_install_coerce_map_from()`.\n\n> To clarify this point (and it might be helpful to put something along these lines in the documentation), ...\n\nBut where?\n\n> I think the fourth point is desirable because the alternative, programmatic solutions via `_coerce_map_from_`, feel much more heavy-weight (subclassing a whole parent just to extend `_coerce_map_from_` may be appropriate for someone who is concerned with developing sage, but seems inappropriate to me for someone who is thinking about using sage to do a complicated computation.\n\nOK. But then, this method should be visible, hence, not starting with an underscore.\n\n> > - Perhaps: Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.\n\n> I think yes: Due to cyclic references, parents will usually survive until the next GC, which may be quite a while after the last reference is lost. So place where the map becomes liable to turn defunct may be quite distant from the place where the map if found to be defunct. People deserve a reminder about that.\n\nOK. Perhaps: If the map is weak but the domain reference is still available, then show the map as \n\n```\n\"\"\"WARNING: This %s map from %s to %s\nmay become defunct after the next garbage collection.\nFor usage outside of the coercion system, try to create a copy,\nor apply the method `_make_strong_references()`\"\"\"%(self._repr_type(), self.domain(),self.codomain()\n```\nand if the domain is unavailable, then show the map as\n\n```\n\"Defunct %s map\"%self._repr_type()\"\n```",
    "created_at": "2013-10-05T18:41:12Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181516",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:104'></a>
Replying to [nbruin](#comment%3A103):
> Replying to [SimonKing](#comment%3A100):
> > Let me try to summarise what is (or may be) left to do:
> > 
> > - Add a section explaining the current weak coercion model, to facilitate maintenance,
> > - Add `_install_coerce_map_from()`.

> To clarify this point (and it might be helpful to put something along these lines in the documentation), ...

But where?

> I think the fourth point is desirable because the alternative, programmatic solutions via `_coerce_map_from_`, feel much more heavy-weight (subclassing a whole parent just to extend `_coerce_map_from_` may be appropriate for someone who is concerned with developing sage, but seems inappropriate to me for someone who is thinking about using sage to do a complicated computation.

OK. But then, this method should be visible, hence, not starting with an underscore.

> > - Perhaps: Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.

> I think yes: Due to cyclic references, parents will usually survive until the next GC, which may be quite a while after the last reference is lost. So place where the map becomes liable to turn defunct may be quite distant from the place where the map if found to be defunct. People deserve a reminder about that.

OK. Perhaps: If the map is weak but the domain reference is still available, then show the map as 

```
"""WARNING: This %s map from %s to %s
may become defunct after the next garbage collection.
For usage outside of the coercion system, try to create a copy,
or apply the method `_make_strong_references()`"""%(self._repr_type(), self.domain(),self.codomain()
```
and if the domain is unavailable, then show the map as

```
"Defunct %s map"%self._repr_type()"
```



---

archive/issue_comments_181517.json:
```json
{
    "body": "<a id='comment:105'></a>\nReplying to [SimonKing](#comment%3A104):\n> > To clarify this point (and it might be helpful to put something along these lines in the documentation), ...\n\n> \n> But where?\n\nThe thematic tutorial `coercion_and_categories` would be a natural place, but would it be enough? Granted, the doc of `register_embedding`, `register_coercion` and `install_coercion` should refer to each other and elaborate on the different use cases and should also mention `_coerce_map_from_`.",
    "created_at": "2013-10-05T18:50:24Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181517",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:105'></a>
Replying to [SimonKing](#comment%3A104):
> > To clarify this point (and it might be helpful to put something along these lines in the documentation), ...

> 
> But where?

The thematic tutorial `coercion_and_categories` would be a natural place, but would it be enough? Granted, the doc of `register_embedding`, `register_coercion` and `install_coercion` should refer to each other and elaborate on the different use cases and should also mention `_coerce_map_from_`.



---

archive/issue_comments_181518.json:
```json
{
    "body": "<a id='comment:6'></a>\nWith vanilla public/sage-git/master, I find that `sage -t --all` results in 1083022 calls to `Parent.__init__`, while with the branch from here it is called 1129534 times.\n\nHence, there *is* an increase in the number of parents being created. No surprise, since this ticket is about making parents garbage collectable in some situations.\n\nNevertheless, it might make sense to see whether some types of parents show a particularly strong increase, so that we can then decide whether we should have some stronger cache for these types.",
    "created_at": "2013-10-05T19:38:30Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181518",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
With vanilla public/sage-git/master, I find that `sage -t --all` results in 1083022 calls to `Parent.__init__`, while with the branch from here it is called 1129534 times.

Hence, there *is* an increase in the number of parents being created. No surprise, since this ticket is about making parents garbage collectable in some situations.

Nevertheless, it might make sense to see whether some types of parents show a particularly strong increase, so that we can then decide whether we should have some stronger cache for these types.



---

archive/issue_comments_181519.json:
```json
{
    "body": "<a id='comment:7'></a>\nI studied the differences in parent creation during `sage -t --all` in more detail.\n\n__Absolute differences__\n\nHere are the 10 classes that have the most additional creations in the ticket branch compared with the public/sage-git/master branch (the list shows the absolute number of additional creations and the name of the class):\n\n```\n(19873, 'sage.rings.homset.RingHomset_generic')\n(16597, 'sage.categories.homset.Homset')\n(2839, 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic')\n(2270, 'sage.rings.homset.RingHomset_quo_ring')\n(2137, 'sage.rings.finite_rings.homset.FiniteFieldHomset')\n(1960, 'sage.rings.number_field.morphism.NumberFieldHomset')\n(1279, 'sage.sets.positive_integers.PositiveIntegers')\n(851, 'sage.combinat.tableau.Tableaux_all')\n(831, 'sage.modules.free_module_homspace.FreeModuleHomspace')\n(481, 'sage.rings.polynomial.polynomial_ring.PolynomialRing_dense_mod_p')\n```\nHere are the \"bottom 10\" classes. As you can see, there are parents for which we have considerably *less* creations with the ticket than without, which comes as a surprise to me:\n\n```\n(-57, 'sage.sets.family.LazyFamily')\n(-134, 'sage.combinat.words.words.Words_all')\n(-134, 'sage.combinat.permutation.StandardPermutations_all')\n(-136, 'sage.combinat.permutation.Permutations_set')\n(-142, 'sage.combinat.subset.Subsets_sk')\n(-158, 'sage.sets.non_negative_integers.NonNegativeIntegers')\n(-166, 'sage.combinat.cartesian_product.CartesianProduct_iters')\n(-170, 'sage.combinat.integer_list.IntegerListsLex')\n(-253, 'sage.combinat.skew_partition.SkewPartitions_rowlengths')\n(-3838, 'sage.sets.set.Set_object_enumerated')\n```\n\n__Relative differences__\n\nHere are the 10 classes that have the biggest relative increase in number of creations (ticket compared with master):\n\n```\n+14.67% sage.combinat.tableau.Tableaux_all\n+3.79% sage.combinat.skew_tableau.SemistandardSkewTableaux_all\n+1.00% sage.combinat.skew_tableau.SkewTableaux\n+1.00% sage.combinat.partition_tuple.PartitionTuples_all\n+0.91% sage.rings.homset.RingHomset_quo_ring\n+0.75% sage.categories.examples.sets_cat.PrimeNumbers_Facade\n+0.67% sage.combinat.crystals.affine.AffineCrystalFromClassicalAndPromotion\n+0.66% sage.groups.matrix_gps.homset.MatrixGroupHomset\n+0.64% sage.combinat.partition_tuple.PartitionTuples_level\n+0.60% sage.structure.list_clone_demo.IncreasingIntArrays\n```\nHere are the 10 classes with the biggest relative decrease in the number of creations:\n\n```\n-0.25% sage.combinat.crystals.kirillov_reshetikhin.KR_type_A2_with_category\n-0.25% sage.combinat.crystals.kirillov_reshetikhin.KR_type_A2\n-0.25% sage.categories.examples.finite_monoids.IntegerModMonoid\n-0.33% sage.sets.integer_range.IntegerRangeEmpty\n-0.33% sage.combinat.affine_permutation.AffinePermutationGroupTypeG\n-0.33% sage.combinat.affine_permutation.AffinePermutationGroupTypeC\n-0.38% sage.combinat.crystals.infinity_crystals.InfinityCrystalOfTableauxTypeD\n-0.39% sage.combinat.permutation.CyclicPermutations\n-0.40% sage.combinat.vector_partition.VectorPartitions\n-0.54% sage.combinat.composition_tableau.CompositionTableaux_all\n```\n\n__Conclusion__\n\nEven though the absolute differences in the creation of various kinds of homsets seem to be dramatic, the relative differences suggest that there is no serious problem here. There are only four classes that show an increase of at least 1%. Three of them are related with tableaux, that's why I add Nicolas to the ticket: Perhaps we want to change the cache for tableaux?",
    "created_at": "2013-10-05T20:34:22Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181519",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
I studied the differences in parent creation during `sage -t --all` in more detail.

__Absolute differences__

Here are the 10 classes that have the most additional creations in the ticket branch compared with the public/sage-git/master branch (the list shows the absolute number of additional creations and the name of the class):

```
(19873, 'sage.rings.homset.RingHomset_generic')
(16597, 'sage.categories.homset.Homset')
(2839, 'sage.rings.finite_rings.integer_mod_ring.IntegerModRing_generic')
(2270, 'sage.rings.homset.RingHomset_quo_ring')
(2137, 'sage.rings.finite_rings.homset.FiniteFieldHomset')
(1960, 'sage.rings.number_field.morphism.NumberFieldHomset')
(1279, 'sage.sets.positive_integers.PositiveIntegers')
(851, 'sage.combinat.tableau.Tableaux_all')
(831, 'sage.modules.free_module_homspace.FreeModuleHomspace')
(481, 'sage.rings.polynomial.polynomial_ring.PolynomialRing_dense_mod_p')
```
Here are the "bottom 10" classes. As you can see, there are parents for which we have considerably *less* creations with the ticket than without, which comes as a surprise to me:

```
(-57, 'sage.sets.family.LazyFamily')
(-134, 'sage.combinat.words.words.Words_all')
(-134, 'sage.combinat.permutation.StandardPermutations_all')
(-136, 'sage.combinat.permutation.Permutations_set')
(-142, 'sage.combinat.subset.Subsets_sk')
(-158, 'sage.sets.non_negative_integers.NonNegativeIntegers')
(-166, 'sage.combinat.cartesian_product.CartesianProduct_iters')
(-170, 'sage.combinat.integer_list.IntegerListsLex')
(-253, 'sage.combinat.skew_partition.SkewPartitions_rowlengths')
(-3838, 'sage.sets.set.Set_object_enumerated')
```

__Relative differences__

Here are the 10 classes that have the biggest relative increase in number of creations (ticket compared with master):

```
+14.67% sage.combinat.tableau.Tableaux_all
+3.79% sage.combinat.skew_tableau.SemistandardSkewTableaux_all
+1.00% sage.combinat.skew_tableau.SkewTableaux
+1.00% sage.combinat.partition_tuple.PartitionTuples_all
+0.91% sage.rings.homset.RingHomset_quo_ring
+0.75% sage.categories.examples.sets_cat.PrimeNumbers_Facade
+0.67% sage.combinat.crystals.affine.AffineCrystalFromClassicalAndPromotion
+0.66% sage.groups.matrix_gps.homset.MatrixGroupHomset
+0.64% sage.combinat.partition_tuple.PartitionTuples_level
+0.60% sage.structure.list_clone_demo.IncreasingIntArrays
```
Here are the 10 classes with the biggest relative decrease in the number of creations:

```
-0.25% sage.combinat.crystals.kirillov_reshetikhin.KR_type_A2_with_category
-0.25% sage.combinat.crystals.kirillov_reshetikhin.KR_type_A2
-0.25% sage.categories.examples.finite_monoids.IntegerModMonoid
-0.33% sage.sets.integer_range.IntegerRangeEmpty
-0.33% sage.combinat.affine_permutation.AffinePermutationGroupTypeG
-0.33% sage.combinat.affine_permutation.AffinePermutationGroupTypeC
-0.38% sage.combinat.crystals.infinity_crystals.InfinityCrystalOfTableauxTypeD
-0.39% sage.combinat.permutation.CyclicPermutations
-0.40% sage.combinat.vector_partition.VectorPartitions
-0.54% sage.combinat.composition_tableau.CompositionTableaux_all
```

__Conclusion__

Even though the absolute differences in the creation of various kinds of homsets seem to be dramatic, the relative differences suggest that there is no serious problem here. There are only four classes that show an increase of at least 1%. Three of them are related with tableaux, that's why I add Nicolas to the ticket: Perhaps we want to change the cache for tableaux?



---

archive/issue_comments_181520.json:
```json
{
    "body": "<a id='comment:8'></a>\nConcerning a new method `install_coercion`: Wouldn't it be easier to provide `register_coercion` with an optional argument `permanent=True`, so that using the method with `permanent=False` would do what you suggested for `install_coercion`? I guess having two methods `install_coercion` and `register_coercion` could confuse the user.",
    "created_at": "2013-10-05T20:45:49Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181520",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
Concerning a new method `install_coercion`: Wouldn't it be easier to provide `register_coercion` with an optional argument `permanent=True`, so that using the method with `permanent=False` would do what you suggested for `install_coercion`? I guess having two methods `install_coercion` and `register_coercion` could confuse the user.



---

archive/issue_comments_181521.json:
```json
{
    "body": "<a id='comment:9'></a>\nConcerning documentation: I just found that the underscore methods of `sage.structure.parent.Parent` are documented in the reference manual. Hence it should be no problem to add documentation of `_coerce_map_from_` directly in-place.",
    "created_at": "2013-10-06T15:08:32Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181521",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Concerning documentation: I just found that the underscore methods of `sage.structure.parent.Parent` are documented in the reference manual. Hence it should be no problem to add documentation of `_coerce_map_from_` directly in-place.



---

archive/issue_comments_181522.json:
```json
{
    "body": "<a id='comment:0'></a>\nAnd I just notice that the documentation of the module `sage.structure.parent` starts with a \"simple example of registering coercions\", which I find rather obscure and which does things in a way that we would do differently today. E.g., it does not initialise the category, but overrides the method `category()`. And it calls `self._populate_coercion_lists_()`, which I have never seen in code created in the past few years.\n\nHence, I'll update this example.",
    "created_at": "2013-10-06T15:17:54Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181522",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
And I just notice that the documentation of the module `sage.structure.parent` starts with a "simple example of registering coercions", which I find rather obscure and which does things in a way that we would do differently today. E.g., it does not initialise the category, but overrides the method `category()`. And it calls `self._populate_coercion_lists_()`, which I have never seen in code created in the past few years.

Hence, I'll update this example.



---

archive/issue_comments_181523.json:
```json
{
    "body": "<a id='comment:111'></a>\nReplying to [SimonKing](#comment%3A110):\n> And I just notice that the documentation of the module `sage.structure.parent` starts with a \"simple example of registering coercions\", which I find rather obscure and which does things in a way that we would do differently today. E.g., it does not initialise the category, but overrides the method `category()`. And it calls `self._populate_coercion_lists_()`, which I have never seen in code created in the past few years.\n> \n> Hence, I'll update this example.\n\nHm. I am undecided.\n\nPerhaps it would be better to focus here on fixing the memory leak (which, I think succeeded), only documenting with examples that it has worked.\n\nHence, on *this* ticket, I would just\n- provide missing docs for `SchemeMorphism`\n- Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.\n- Perhaps: Re-introduce a cdef public attribute _codomain, since this would allow faster access than calling .codomain(), and since the codomain will be strongly referenced anyway. \n\nEverything else should perhaps better be done on a follow-up ticket:\n- Add documentation explaining the current weak coercion model, to facilitate maintanance,\n- Add `permanent=True` option to `register_coercion()`.\n\nWhat do you think?",
    "created_at": "2013-10-06T15:31:16Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181523",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:111'></a>
Replying to [SimonKing](#comment%3A110):
> And I just notice that the documentation of the module `sage.structure.parent` starts with a "simple example of registering coercions", which I find rather obscure and which does things in a way that we would do differently today. E.g., it does not initialise the category, but overrides the method `category()`. And it calls `self._populate_coercion_lists_()`, which I have never seen in code created in the past few years.
> 
> Hence, I'll update this example.

Hm. I am undecided.

Perhaps it would be better to focus here on fixing the memory leak (which, I think succeeded), only documenting with examples that it has worked.

Hence, on *this* ticket, I would just
- provide missing docs for `SchemeMorphism`
- Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.
- Perhaps: Re-introduce a cdef public attribute _codomain, since this would allow faster access than calling .codomain(), and since the codomain will be strongly referenced anyway. 

Everything else should perhaps better be done on a follow-up ticket:
- Add documentation explaining the current weak coercion model, to facilitate maintanance,
- Add `permanent=True` option to `register_coercion()`.

What do you think?



---

archive/issue_comments_181524.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[changeset:452d216]</td><td><code>Add docs to SchemeMorphism</code></td></tr></table>\n",
    "created_at": "2013-10-06T16:29:24Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181524",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[changeset:452d216]</td><td><code>Add docs to SchemeMorphism</code></td></tr></table>




---

archive/issue_comments_181525.json:
```json
{
    "body": "**Changing commit** from \"[05fb569cb132a8c89713021f1f4b25cd2dd7cb1c](https://github.com/sagemath/sagetrac-mirror/commit/05fb569cb132a8c89713021f1f4b25cd2dd7cb1c)\" to \"[452d21629d4531d8e117e869b65bac0ab350c1ee](https://github.com/sagemath/sagetrac-mirror/commit/452d21629d4531d8e117e869b65bac0ab350c1ee)\".",
    "created_at": "2013-10-06T16:29:24Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181525",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[05fb569cb132a8c89713021f1f4b25cd2dd7cb1c](https://github.com/sagemath/sagetrac-mirror/commit/05fb569cb132a8c89713021f1f4b25cd2dd7cb1c)" to "[452d21629d4531d8e117e869b65bac0ab350c1ee](https://github.com/sagemath/sagetrac-mirror/commit/452d21629d4531d8e117e869b65bac0ab350c1ee)".



---

archive/issue_comments_181526.json:
```json
{
    "body": "<a id='comment:3'></a>\nI think there is a further technical thing I could do in the next commit: I have implemented `__copy__` for some types of morphisms. But there already exist methods called `_extra_slots()` and `_update_slots()`, and I think in order to implement copying one should update these. This might (on a different ticket) also help to provide a default pickling for maps.",
    "created_at": "2013-10-06T17:10:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181526",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
I think there is a further technical thing I could do in the next commit: I have implemented `__copy__` for some types of morphisms. But there already exist methods called `_extra_slots()` and `_update_slots()`, and I think in order to implement copying one should update these. This might (on a different ticket) also help to provide a default pickling for maps.



---

archive/issue_comments_181527.json:
```json
{
    "body": "**Changing commit** from \"[452d21629d4531d8e117e869b65bac0ab350c1ee](https://github.com/sagemath/sagetrac-mirror/commit/452d21629d4531d8e117e869b65bac0ab350c1ee)\" to \"[5168cfd15d4cdbaa3ffdbd4be0f7d783f77257c7](https://github.com/sagemath/sagetrac-mirror/commit/5168cfd15d4cdbaa3ffdbd4be0f7d783f77257c7)\".",
    "created_at": "2013-10-06T18:17:10Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181527",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[452d21629d4531d8e117e869b65bac0ab350c1ee](https://github.com/sagemath/sagetrac-mirror/commit/452d21629d4531d8e117e869b65bac0ab350c1ee)" to "[5168cfd15d4cdbaa3ffdbd4be0f7d783f77257c7](https://github.com/sagemath/sagetrac-mirror/commit/5168cfd15d4cdbaa3ffdbd4be0f7d783f77257c7)".



---

archive/issue_comments_181528.json:
```json
{
    "body": "<a id='comment:4'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[changeset:5168cfd]</td><td><code>Generic copy method for maps, using _update_slots Use a cdef _codomain, since the codomain is strongly refed anyway Add doctests</code></td></tr></table>\n",
    "created_at": "2013-10-06T18:17:10Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181528",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:4'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[changeset:5168cfd]</td><td><code>Generic copy method for maps, using _update_slots Use a cdef _codomain, since the codomain is strongly refed anyway Add doctests</code></td></tr></table>




---

archive/issue_comments_181529.json:
```json
{
    "body": "<a id='comment:115'></a>\nReplying to [SimonKing](#comment%3A111):\n> Perhaps it would be better to focus here on fixing the memory leak (which, I think succeeded), only documenting with examples that it has worked.\n> \n> Hence, on *this* ticket, I would just\n> - provide missing docs for `SchemeMorphism`\n\nDone in the current commit.\n\n> - Perhaps: Re-introduce a cdef public attribute _codomain, since this would allow faster access than calling .codomain(), and since the codomain will be strongly referenced anyway. \n\nDone in the current commit.\n\nIn addition, I changed the new generic `__copy__` method of maps so that it uses `_update_slots` and `_extra_slots`. This complies with how currently pickling is implemented by default. For several types of maps, I implemented copying accordingly.\n\n> - Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.\n\nStill todo.\n\n> Everything else should perhaps better be done on a follow-up ticket:\n> - Add documentation explaining the current weak coercion model, to facilitate maintanance,\n> - Add `permanent=True` option to `register_coercion()`.\n\nDo you agree that this shall be on a different ticket?",
    "created_at": "2013-10-06T18:22:15Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181529",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:115'></a>
Replying to [SimonKing](#comment%3A111):
> Perhaps it would be better to focus here on fixing the memory leak (which, I think succeeded), only documenting with examples that it has worked.
> 
> Hence, on *this* ticket, I would just
> - provide missing docs for `SchemeMorphism`

Done in the current commit.

> - Perhaps: Re-introduce a cdef public attribute _codomain, since this would allow faster access than calling .codomain(), and since the codomain will be strongly referenced anyway. 

Done in the current commit.

In addition, I changed the new generic `__copy__` method of maps so that it uses `_update_slots` and `_extra_slots`. This complies with how currently pickling is implemented by default. For several types of maps, I implemented copying accordingly.

> - Let the string representation of a weakened map consist of a warning to not use this map outside of the coercion framework.

Still todo.

> Everything else should perhaps better be done on a follow-up ticket:
> - Add documentation explaining the current weak coercion model, to facilitate maintanance,
> - Add `permanent=True` option to `register_coercion()`.

Do you agree that this shall be on a different ticket?



---

archive/issue_comments_181530.json:
```json
{
    "body": "<a id='comment:116'></a>\nReplying to [SimonKing](#comment%3A107):\n> Even though the absolute differences in the creation of various kinds of homsets seem to be dramatic, the relative differences suggest that there is no serious problem here. There are only four classes that show an increase of at least 1%. Three of them are related with tableaux, that's why I add Nicolas to the ticket: Perhaps we want to change the cache for tableaux?\n\nCould you post a quick summary (say in the ticket description/title)\nof what the current patch does?\n\nThanks!",
    "created_at": "2013-10-06T20:17:31Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181530",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:116'></a>
Replying to [SimonKing](#comment%3A107):
> Even though the absolute differences in the creation of various kinds of homsets seem to be dramatic, the relative differences suggest that there is no serious problem here. There are only four classes that show an increase of at least 1%. Three of them are related with tableaux, that's why I add Nicolas to the ticket: Perhaps we want to change the cache for tableaux?

Could you post a quick summary (say in the ticket description/title)
of what the current patch does?

Thanks!



---

archive/issue_comments_181531.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -6,3 +6,105 @@\n ....:\n ```\n (This is with 5.10.rc0)\n+\n+__Problem analysis__\n+\n+The quadratic field is created with a coerce embedding into `CLF`. At the same\n+time, this coerce embedding is stored in `CLF._coerce_from_hash`:\n+\n+```\n+sage: phi = CLF.coerce_map_from(Q)\n+sage: phi is Q.coerce_embedding()\n+True\n+sage: Q in CLF._introspect_coerce()['_coerce_from_hash']\n+True\n+```\n+The \"coerce_from_hash\" is a `MonoDict`, hence, has only a weak reference to the key\n+(Q, in this case). However, there still is a *strong* reference from\n+CLF to the coerce map phi. And phi has a strong reference to its\n+domain, thus, to Q. Hence, the existence of CLF prevents garbage collection of\n+Q.\n+\n+And there is a second chain of strong references from CLF to Q: From CLF to\n+phi to the parent of phi (i.e., a homset) to the domain Q of this homset.\n+\n+__Suggested solution__\n+\n+We can not turn the reference from CLF to phi into a weak reference, because\n+then even a strong reference to Q would not prevent phi from garbage\n+collection. Hence, we need to break the above mentioned reference chains in\n+two points. In the attached branch, maps generally keep a strong reference to\n+the codomain (this is important in composite maps and actions), but those used\n+*in the coercion system* (and *only* there!!) will only have a weak\n+reference to the domain, and they set the cdef `._parent` attribute to `None`\n+(hence, we also override `.parent()`, so that it reconstructs the homset if\n+the weak reference to the domain is still valid).\n+\n+To preserve the `domain()/codomain()` interface, I have removed the method\n+`domain()` and have replaced it by a cdef public attribute that will either\n+hold a weak reference (which returns the domain when called, hence, the\n+interface does not change) or a `ConstantFunction` (which should actually be\n+faster to call than a method). Since accessing a cdef attribute is still\n+faster, the cdef attribute `_codomain` is kept (since this will always be a\n+strong reference), but `_domain` has been removed.\n+\n+This \"weakening of references\" is done for the coercions found by\n+`discover_coerce_map_from()` stored into `_coerce_from_hash`. So, this mainly\n+happens for things done with `_coerce_map_from_()` and with composite\n+maps. Similarly for `_convert_from_hash`.\n+\n+Weakening is *not* used on the maps that are explicitly registered by\n+`.register_embedding()` and `.register_coercion()`. This is in order to\n+preserve the connectivity of the coercion graph. The `register_*` methods\n+are only used on selected maps, that are of particular importance for the\n+backtrack search in `discover_coerce_map_from()`. These *strong*\n+registrations do not propagate: Compositions of strongly registered\n+coercions found by `discover_coerce_map_from()` will be weakened.\n+\n+Since weakened maps should not be used outside of the coercion system, its\n+string representation shows a warning to replace them by a copy. The attached\n+branch implements copying of maps in some additional cases.\n+\n+`SchemeMorphism` can not inherit from `Morphism`, because of a bug with\n+multiple inheritance of a Python class from Cython extension classes. But once\n+this bug is fixed, we surely want to make `SchemeMorphism` inherit from\n+`Morphism`. This transition is prepared here.\n+\n+In any case, the commit messages should give a concise description of what has\n+been done.\n+\n+**__Still TODO__**\n+\n+Let the string representation of weakened maps point the user to the need of\n+creating a copy.\n+\n+**__TODO in future tickets__**\n+\n+- Provide a documentation of the use of weak references in coercion, and of\n+  different ways of registering coercions, with their different impacts on\n+  garbage collecion.\n+- Provide a version of `.register_coercion()` that weakens the coercion\n+  map. It would hence have the same effect as returning a map by\n+  `._coerce_map_from_()`, but of course `._coerce_map_from()` could not easily\n+  be changed in an interactive session.\n+- provide copying for *all* kinds of maps.\n+\n+**__Effects on the overall functioning of Sage__**\n+\n+It is conceivable that some parts of Sage still suppose implicitly that stuff\n+cached with `UniqueRepresentation` is *permanently* cached, even though the\n+seemingly permanent cache was not more than a consequence of a memory leak in\n+the coercion system. With the attached branch, garbage collection of parent\n+structures will much more often become possible. Hence, code that relied on a\n+fake-permanent cache would now need to create the same parent repeatedly.\n+\n+I (Simon) have tested how many additional parent creations occur with the\n+attached branch when running `sage -t --all`. The findings are summarised in\n+comment:107: The number of additional parent creations increased by not more\n+than 1% for all but two parent classes (both related with tableaux). I also\n+found that the time to run the tests did not significantly increase.\n+\n+Jean-Pierre has occasionally stated that some of his computations have been\n+infeasible with the memory leak in the above example. I hope that his\n+computations will now succeed.\n+\n``````\n",
    "created_at": "2013-10-06T21:30:55Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181531",
    "user": "https://github.com/simon-king-jena"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -6,3 +6,105 @@
 ....:
 ```
 (This is with 5.10.rc0)
+
+__Problem analysis__
+
+The quadratic field is created with a coerce embedding into `CLF`. At the same
+time, this coerce embedding is stored in `CLF._coerce_from_hash`:
+
+```
+sage: phi = CLF.coerce_map_from(Q)
+sage: phi is Q.coerce_embedding()
+True
+sage: Q in CLF._introspect_coerce()['_coerce_from_hash']
+True
+```
+The "coerce_from_hash" is a `MonoDict`, hence, has only a weak reference to the key
+(Q, in this case). However, there still is a *strong* reference from
+CLF to the coerce map phi. And phi has a strong reference to its
+domain, thus, to Q. Hence, the existence of CLF prevents garbage collection of
+Q.
+
+And there is a second chain of strong references from CLF to Q: From CLF to
+phi to the parent of phi (i.e., a homset) to the domain Q of this homset.
+
+__Suggested solution__
+
+We can not turn the reference from CLF to phi into a weak reference, because
+then even a strong reference to Q would not prevent phi from garbage
+collection. Hence, we need to break the above mentioned reference chains in
+two points. In the attached branch, maps generally keep a strong reference to
+the codomain (this is important in composite maps and actions), but those used
+*in the coercion system* (and *only* there!!) will only have a weak
+reference to the domain, and they set the cdef `._parent` attribute to `None`
+(hence, we also override `.parent()`, so that it reconstructs the homset if
+the weak reference to the domain is still valid).
+
+To preserve the `domain()/codomain()` interface, I have removed the method
+`domain()` and have replaced it by a cdef public attribute that will either
+hold a weak reference (which returns the domain when called, hence, the
+interface does not change) or a `ConstantFunction` (which should actually be
+faster to call than a method). Since accessing a cdef attribute is still
+faster, the cdef attribute `_codomain` is kept (since this will always be a
+strong reference), but `_domain` has been removed.
+
+This "weakening of references" is done for the coercions found by
+`discover_coerce_map_from()` stored into `_coerce_from_hash`. So, this mainly
+happens for things done with `_coerce_map_from_()` and with composite
+maps. Similarly for `_convert_from_hash`.
+
+Weakening is *not* used on the maps that are explicitly registered by
+`.register_embedding()` and `.register_coercion()`. This is in order to
+preserve the connectivity of the coercion graph. The `register_*` methods
+are only used on selected maps, that are of particular importance for the
+backtrack search in `discover_coerce_map_from()`. These *strong*
+registrations do not propagate: Compositions of strongly registered
+coercions found by `discover_coerce_map_from()` will be weakened.
+
+Since weakened maps should not be used outside of the coercion system, its
+string representation shows a warning to replace them by a copy. The attached
+branch implements copying of maps in some additional cases.
+
+`SchemeMorphism` can not inherit from `Morphism`, because of a bug with
+multiple inheritance of a Python class from Cython extension classes. But once
+this bug is fixed, we surely want to make `SchemeMorphism` inherit from
+`Morphism`. This transition is prepared here.
+
+In any case, the commit messages should give a concise description of what has
+been done.
+
+**__Still TODO__**
+
+Let the string representation of weakened maps point the user to the need of
+creating a copy.
+
+**__TODO in future tickets__**
+
+- Provide a documentation of the use of weak references in coercion, and of
+  different ways of registering coercions, with their different impacts on
+  garbage collecion.
+- Provide a version of `.register_coercion()` that weakens the coercion
+  map. It would hence have the same effect as returning a map by
+  `._coerce_map_from_()`, but of course `._coerce_map_from()` could not easily
+  be changed in an interactive session.
+- provide copying for *all* kinds of maps.
+
+**__Effects on the overall functioning of Sage__**
+
+It is conceivable that some parts of Sage still suppose implicitly that stuff
+cached with `UniqueRepresentation` is *permanently* cached, even though the
+seemingly permanent cache was not more than a consequence of a memory leak in
+the coercion system. With the attached branch, garbage collection of parent
+structures will much more often become possible. Hence, code that relied on a
+fake-permanent cache would now need to create the same parent repeatedly.
+
+I (Simon) have tested how many additional parent creations occur with the
+attached branch when running `sage -t --all`. The findings are summarised in
+comment:107: The number of additional parent creations increased by not more
+than 1% for all but two parent classes (both related with tableaux). I also
+found that the time to run the tests did not significantly increase.
+
+Jean-Pierre has occasionally stated that some of his computations have been
+infeasible with the memory leak in the above example. I hope that his
+computations will now succeed.
+
``````




---

archive/issue_events_128590.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-06T21:30:55Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "rename": {
        "from": "Memleak when creating QuadraticField",
        "to": "Weak references in the coercion graph"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128590"
}
```



---

archive/issue_comments_181532.json:
```json
{
    "body": "<a id='comment:117'></a>\nReplying to [nthiery](#comment%3A116):\n> Could you post a quick summary (say in the ticket description/title)\n> of what the current patch does?\n\nDone. OK, the summary is actually not quick. Sorry.",
    "created_at": "2013-10-06T21:30:55Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181532",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:117'></a>
Replying to [nthiery](#comment%3A116):
> Could you post a quick summary (say in the ticket description/title)
> of what the current patch does?

Done. OK, the summary is actually not quick. Sorry.



---

archive/issue_comments_181533.json:
```json
{
    "body": "**Work Issues:** String repr. of weakened maps; copying/pickling of maps",
    "created_at": "2013-10-07T11:25:40Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181533",
    "user": "https://github.com/simon-king-jena"
}
```

**Work Issues:** String repr. of weakened maps; copying/pickling of maps



---

archive/issue_comments_181534.json:
```json
{
    "body": "<a id='comment:8'></a>\nI think changing the string representation of weakened maps should be done here. And then, in a couple of tests, one needs to copy the map in order to get the test pass.\n\nTherefore, I suggest to implement copying for all maps *here* as well, not on a different ticket. After all, it is not difficult: One just looks at the list of cdef attributes, and implements `_extra_slots` and `_update_slots` taking exactly these attributes into account. The only difficulty is to really catch *all* kinds of maps.\n\nNote that in most cases `phi == loads(dumps(phi))` would return False, but this is since comparison of maps is often not implemented---and this is what I will certainly *not* attempt to implement here.",
    "created_at": "2013-10-07T11:25:40Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181534",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
I think changing the string representation of weakened maps should be done here. And then, in a couple of tests, one needs to copy the map in order to get the test pass.

Therefore, I suggest to implement copying for all maps *here* as well, not on a different ticket. After all, it is not difficult: One just looks at the list of cdef attributes, and implements `_extra_slots` and `_update_slots` taking exactly these attributes into account. The only difficulty is to really catch *all* kinds of maps.

Note that in most cases `phi == loads(dumps(phi))` would return False, but this is since comparison of maps is often not implemented---and this is what I will certainly *not* attempt to implement here.



---

archive/issue_comments_181535.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -75,8 +75,9 @@\n \n **__Still TODO__**\n \n-Let the string representation of weakened maps point the user to the need of\n+- Let the string representation of weakened maps point the user to the need of\n creating a copy.\n+- Provide copying for *all* kinds of maps.\n \n **__TODO in future tickets__**\n \n@@ -87,7 +88,6 @@\n   map. It would hence have the same effect as returning a map by\n   `._coerce_map_from_()`, but of course `._coerce_map_from()` could not easily\n   be changed in an interactive session.\n-- provide copying for *all* kinds of maps.\n \n **__Effects on the overall functioning of Sage__**\n \n``````\n",
    "created_at": "2013-10-07T11:25:40Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181535",
    "user": "https://github.com/simon-king-jena"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -75,8 +75,9 @@
 
 **__Still TODO__**
 
-Let the string representation of weakened maps point the user to the need of
+- Let the string representation of weakened maps point the user to the need of
 creating a copy.
+- Provide copying for *all* kinds of maps.
 
 **__TODO in future tickets__**
 
@@ -87,7 +88,6 @@
   map. It would hence have the same effect as returning a map by
   `._coerce_map_from_()`, but of course `._coerce_map_from()` could not easily
   be changed in an interactive session.
-- provide copying for *all* kinds of maps.
 
 **__Effects on the overall functioning of Sage__**
 
``````




---

archive/issue_events_128591.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-07T11:25:40Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128591"
}
```



---

archive/issue_events_128592.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-07T11:25:40Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128592"
}
```



---

archive/issue_comments_181536.json:
```json
{
    "body": "<a id='comment:9'></a>\nI wonder: Would it make sense to implement a generic comparison for maps, based on the dictionary returned by `self._extra_slots({})`? Namely, these data are used for pickling and copying of maps, and thus it seems reasonable to me that two maps are equal if and only if the pickling data coincide.\n\nWhat do you think? Worth trying? Better be done on a different ticket?",
    "created_at": "2013-10-07T15:26:57Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181536",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
I wonder: Would it make sense to implement a generic comparison for maps, based on the dictionary returned by `self._extra_slots({})`? Namely, these data are used for pickling and copying of maps, and thus it seems reasonable to me that two maps are equal if and only if the pickling data coincide.

What do you think? Worth trying? Better be done on a different ticket?



---

archive/issue_comments_181537.json:
```json
{
    "body": "<a id='comment:120'></a>\nReplying to [SimonKing](#comment%3A119):\n> I wonder: Would it make sense to implement a generic comparison for maps, based on the dictionary returned by `self._extra_slots({})`? Namely, these data are used for pickling and copying of maps, and thus it seems reasonable to me that two maps are equal if and only if the pickling data coincide.\n\nAnd the \"weakened\" copies of maps (with in the near future an easily distinguished string rep) would be *equal* to their counter parts? That may well be a desirable choice, but by no means uncontroversial. I don't think in coercion we ever depend on equality testing on maps do we? I think it's better done on a separate ticket.\n\nAnother suggestion about how to get the the strong references in for register_coercion. If the maps put in by register_coercion are used afterwards many times to derive other cached coercion maps from, it would perhaps be preferable to have them in a form that is readily usable for that, i.e., as \"weakened\" maps (it means the map can go straight into map compositions etc.). Otherwise we may well end up making copies repeatedly in the coercion framework.\n\nWe could get the strong connections in by, for instance, referencing the domains explicitly, say on an attribute `_domains_with_registered_coercions_to_here`. The coercion map itself could simply live in the normal cache, as a weakened map.\n\nThe same applies to `_register_embedding`, although perhaps the coercion discovery treats the store differently, and storing a strong reference to even a weakened map implies a strong reference to the codomain.\n\nOther question, does `_parent=None` imply a weakened map? (I guess isinstance(_domain,weakref.ref) definintely does) or are there other reasons for the parent to be unset?",
    "created_at": "2013-10-07T15:57:08Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181537",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:120'></a>
Replying to [SimonKing](#comment%3A119):
> I wonder: Would it make sense to implement a generic comparison for maps, based on the dictionary returned by `self._extra_slots({})`? Namely, these data are used for pickling and copying of maps, and thus it seems reasonable to me that two maps are equal if and only if the pickling data coincide.

And the "weakened" copies of maps (with in the near future an easily distinguished string rep) would be *equal* to their counter parts? That may well be a desirable choice, but by no means uncontroversial. I don't think in coercion we ever depend on equality testing on maps do we? I think it's better done on a separate ticket.

Another suggestion about how to get the the strong references in for register_coercion. If the maps put in by register_coercion are used afterwards many times to derive other cached coercion maps from, it would perhaps be preferable to have them in a form that is readily usable for that, i.e., as "weakened" maps (it means the map can go straight into map compositions etc.). Otherwise we may well end up making copies repeatedly in the coercion framework.

We could get the strong connections in by, for instance, referencing the domains explicitly, say on an attribute `_domains_with_registered_coercions_to_here`. The coercion map itself could simply live in the normal cache, as a weakened map.

The same applies to `_register_embedding`, although perhaps the coercion discovery treats the store differently, and storing a strong reference to even a weakened map implies a strong reference to the codomain.

Other question, does `_parent=None` imply a weakened map? (I guess isinstance(_domain,weakref.ref) definintely does) or are there other reasons for the parent to be unset?



---

archive/issue_comments_181538.json:
```json
{
    "body": "<a id='comment:121'></a>\nReplying to [nbruin](#comment%3A120):\n> And the \"weakened\" copies of maps (with in the near future an easily distinguished string rep) would be *equal* to their counter parts?\n\nOf course. Equality does (and should) not depend on weak references, I think\n\n> I don't think in coercion we ever depend on equality testing on maps do we?\n\nWe don't. Otherwise, people would have had comparison implemented already.\n\n> I think it's better done on a separate ticket.\n\nAgreed.\n\nConcerning \"near future\": I am already testing a new commit that provides\n- special string representation for weakened maps\n- copying for *all* maps and morphisms (at least those that I was able to find in the sources). It was very dull work: Look up the cdef slots, implement `_extra_slots` and `_update_slots`, add a test...\n- Use the copy functionality on most tests that expose coerce maps. Hence, I replace\n\n  ```\n  sage: R.coerce_map_from(P)\n  ...\n  ```\n  by\n\n  ```\n  sage: copy(R.coerce_map_from(P))\n  ```\n  and also add a link to this ticket. Not everywhere, but in most places.\n\n> Another suggestion about how to get the the strong references in for register_coercion. If the maps put in by register_coercion are used afterwards many times to derive other cached coercion maps from, it would perhaps be preferable to have them in a form that is readily usable for that, i.e., as \"weakened\" maps (it means the map can go straight into map compositions etc.). Otherwise we may well end up making copies repeatedly in the coercion framework.\n\nWhy do you think they would/should be copied *inside* of the coercion model? I thought we already had agreed that copying is needed when exposing a coerce map to the user (this is why I suggested that the string repr contains a warning!). But certainly not internally. This would be by far too slow.\n\nSuppose you have two non-weakened maps phi and psi, and then do `chi = phi*psi` (a composite map). When you then weaken `chi`, neither `phi` nor `psi` would be changed. So, why copying?\n\n> We could get the strong connections in by, for instance, referencing the domains explicitly, say on an attribute `_domains_with_registered_coercions_to_here`.\n\nThis is already done in my current branch, and it is called `_registered_domains` (simply a list).\n\n> The coercion map itself could simply live in the normal cache, as a weakened map.\n\nNo, because we need some container that *only* stores those maps that are considered in the backtracking algorithm. So, the current separate list `_coerce_from_list` must be preserved.\n\n> The same applies to `_register_embedding`, although perhaps the coercion discovery treats the store differently, and storing a strong reference to even a weakened map implies a strong reference to the codomain.\n\nAll weakened maps still have a *strong* reference to the codomain. Only the reference to the domain will be weak. And `register_embedding` is still simply assigning the embedding to an attribute `_embedding` of the domain.\n\n> Other question, does `_parent=None` imply a weakened map? (I guess isinstance(_domain,weakref.ref) definintely does) or are there other reasons for the parent to be unset?\n\nI guess one could test `self._parent is None`, rather than typetest stuff. This should actually be faster.\n\nConcerning \"reasons\": The parent is unset, because otherwise we have a chain of references from the map to the domain, namely via the parent (i.e., the homset). Hence, having a weak reference from the map to the domain would be futile if there is a reference from the map to its parent. Note that alternatively one could have a weak reference from the *homset* to the domain. But I think we have agreed above that we don't want this as a default.",
    "created_at": "2013-10-07T16:50:31Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181538",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:121'></a>
Replying to [nbruin](#comment%3A120):
> And the "weakened" copies of maps (with in the near future an easily distinguished string rep) would be *equal* to their counter parts?

Of course. Equality does (and should) not depend on weak references, I think

> I don't think in coercion we ever depend on equality testing on maps do we?

We don't. Otherwise, people would have had comparison implemented already.

> I think it's better done on a separate ticket.

Agreed.

Concerning "near future": I am already testing a new commit that provides
- special string representation for weakened maps
- copying for *all* maps and morphisms (at least those that I was able to find in the sources). It was very dull work: Look up the cdef slots, implement `_extra_slots` and `_update_slots`, add a test...
- Use the copy functionality on most tests that expose coerce maps. Hence, I replace

  ```
  sage: R.coerce_map_from(P)
  ...
  ```
  by

  ```
  sage: copy(R.coerce_map_from(P))
  ```
  and also add a link to this ticket. Not everywhere, but in most places.

> Another suggestion about how to get the the strong references in for register_coercion. If the maps put in by register_coercion are used afterwards many times to derive other cached coercion maps from, it would perhaps be preferable to have them in a form that is readily usable for that, i.e., as "weakened" maps (it means the map can go straight into map compositions etc.). Otherwise we may well end up making copies repeatedly in the coercion framework.

Why do you think they would/should be copied *inside* of the coercion model? I thought we already had agreed that copying is needed when exposing a coerce map to the user (this is why I suggested that the string repr contains a warning!). But certainly not internally. This would be by far too slow.

Suppose you have two non-weakened maps phi and psi, and then do `chi = phi*psi` (a composite map). When you then weaken `chi`, neither `phi` nor `psi` would be changed. So, why copying?

> We could get the strong connections in by, for instance, referencing the domains explicitly, say on an attribute `_domains_with_registered_coercions_to_here`.

This is already done in my current branch, and it is called `_registered_domains` (simply a list).

> The coercion map itself could simply live in the normal cache, as a weakened map.

No, because we need some container that *only* stores those maps that are considered in the backtracking algorithm. So, the current separate list `_coerce_from_list` must be preserved.

> The same applies to `_register_embedding`, although perhaps the coercion discovery treats the store differently, and storing a strong reference to even a weakened map implies a strong reference to the codomain.

All weakened maps still have a *strong* reference to the codomain. Only the reference to the domain will be weak. And `register_embedding` is still simply assigning the embedding to an attribute `_embedding` of the domain.

> Other question, does `_parent=None` imply a weakened map? (I guess isinstance(_domain,weakref.ref) definintely does) or are there other reasons for the parent to be unset?

I guess one could test `self._parent is None`, rather than typetest stuff. This should actually be faster.

Concerning "reasons": The parent is unset, because otherwise we have a chain of references from the map to the domain, namely via the parent (i.e., the homset). Hence, having a weak reference from the map to the domain would be futile if there is a reference from the map to its parent. Note that alternatively one could have a weak reference from the *homset* to the domain. But I think we have agreed above that we don't want this as a default.



---

archive/issue_comments_181539.json:
```json
{
    "body": "<a id='comment:122'></a>\nReplying to [SimonKing](#comment%3A121):\n> Suppose you have two non-weakened maps phi and psi, and then do chi = phi*psi (a composite map). When you then weaken chi, neither phi nor psi would be changed. So, why copying? \n\nWell, if you'd do that then `chi` wouldn't really be a weakened map. Assuming maps act on the left, i.e. `chi.domain()=psi.domain()`, the resulting structure would have a strong reference to its domain, via psi.domain().\n\nThe converse, making a strong composite out of weakened maps, shouldn't be a problem at all (except that if people start looking at the components, they'd be able to get their hands on weakened maps).\n\nI think the coercion system makes a lot of map compositions, and they usually would have to be weakened. That's why it might be worth ensuring that the maps stored internally are already weakened. \n\n> This is already done in my current branch, and it is called `_registered_domains` (simply a list).\n\nAnd the maps inserted into `_coerce_from_hash` are weakened or not? Conceptually it would be a little easier if all of them are. Perhaps enforcing such a rule (or at least change most code to comply) is too costly, though.\n\n> No, because we need some container that *only* stores those maps that are considered in the backtracking algorithm. So, the current separate list `_coerce_from_list` must be preserved.\n\nAh. I didn't realize that. You say that `_coerce_from_hash` is not considered by backtracking. Indeed, that changes things. In that case, `_coerce_from_list` could be a \"weak set\" (e.g., a `WeakValueDictionary` with trivial keys), since the maps are kept alive by their entries in `_coerce_from_hash`, where the key is kept alive by the `_registered_domains`. This would get rid of the garbage collection problem, if we ever want to have maps that help coercion discovery but don't have lifetime implications.\n\n(this should go on a different ticket)",
    "created_at": "2013-10-07T17:37:51Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181539",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:122'></a>
Replying to [SimonKing](#comment%3A121):
> Suppose you have two non-weakened maps phi and psi, and then do chi = phi*psi (a composite map). When you then weaken chi, neither phi nor psi would be changed. So, why copying? 

Well, if you'd do that then `chi` wouldn't really be a weakened map. Assuming maps act on the left, i.e. `chi.domain()=psi.domain()`, the resulting structure would have a strong reference to its domain, via psi.domain().

The converse, making a strong composite out of weakened maps, shouldn't be a problem at all (except that if people start looking at the components, they'd be able to get their hands on weakened maps).

I think the coercion system makes a lot of map compositions, and they usually would have to be weakened. That's why it might be worth ensuring that the maps stored internally are already weakened. 

> This is already done in my current branch, and it is called `_registered_domains` (simply a list).

And the maps inserted into `_coerce_from_hash` are weakened or not? Conceptually it would be a little easier if all of them are. Perhaps enforcing such a rule (or at least change most code to comply) is too costly, though.

> No, because we need some container that *only* stores those maps that are considered in the backtracking algorithm. So, the current separate list `_coerce_from_list` must be preserved.

Ah. I didn't realize that. You say that `_coerce_from_hash` is not considered by backtracking. Indeed, that changes things. In that case, `_coerce_from_list` could be a "weak set" (e.g., a `WeakValueDictionary` with trivial keys), since the maps are kept alive by their entries in `_coerce_from_hash`, where the key is kept alive by the `_registered_domains`. This would get rid of the garbage collection problem, if we ever want to have maps that help coercion discovery but don't have lifetime implications.

(this should go on a different ticket)



---

archive/issue_comments_181540.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[changeset:364b985]</td><td><code>Add warning to string repr of weakened maps. Implement copying for *all* kinds of maps.</code></td></tr></table>\n",
    "created_at": "2013-10-07T20:47:12Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181540",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[changeset:364b985]</td><td><code>Add warning to string repr of weakened maps. Implement copying for *all* kinds of maps.</code></td></tr></table>




---

archive/issue_comments_181541.json:
```json
{
    "body": "**Changing commit** from \"[5168cfd15d4cdbaa3ffdbd4be0f7d783f77257c7](https://github.com/sagemath/sagetrac-mirror/commit/5168cfd15d4cdbaa3ffdbd4be0f7d783f77257c7)\" to \"[364b9856b28d7060e3ea9825144de66c8f11ca2a](https://github.com/sagemath/sagetrac-mirror/commit/364b9856b28d7060e3ea9825144de66c8f11ca2a)\".",
    "created_at": "2013-10-07T20:47:12Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181541",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[5168cfd15d4cdbaa3ffdbd4be0f7d783f77257c7](https://github.com/sagemath/sagetrac-mirror/commit/5168cfd15d4cdbaa3ffdbd4be0f7d783f77257c7)" to "[364b9856b28d7060e3ea9825144de66c8f11ca2a](https://github.com/sagemath/sagetrac-mirror/commit/364b9856b28d7060e3ea9825144de66c8f11ca2a)".



---

archive/issue_comments_181542.json:
```json
{
    "body": "<a id='comment:124'></a>\nReplying to [nbruin](#comment%3A122):\n> Replying to [SimonKing](#comment%3A121):\n> > Suppose you have two non-weakened maps phi and psi, and then do chi = phi*psi (a composite map). When you then weaken chi, neither phi nor psi would be changed. So, why copying? \n\n> \n> Well, if you'd do that then `chi` wouldn't really be a weakened map. Assuming maps act on the left, i.e. `chi.domain()=psi.domain()`, the resulting structure would have a strong reference to its domain, via psi.domain().\n\nCorrect. Would this be a problem? Let's see:\n\nLet `psi: A -> B` and `phi: B -> C` be coerce maps, hence, `chi=phi*psi: A -> C` is a coerce map as well. Assume that we have done `B.register_coercion(psi)`, so that B prevents A from garbage collection. Assume that `phi` is only stored in `C._coerce_from_hash`, i.e., C would not prevent B from garbage collection. In other words, we assume that phi is weakened but psi isn't.\n\nLet us assume first that we did not discover `chi` as a coercion yet. If we have a strong reference to C but no external reference to B, then B and A could of course be garbage collected.\n\nNow, let us assume that we *did* discover that `chi` is a coercion and put it into `C._coerce_from_hash`, in the attempt of weakening it. C would have a strong reference to `chi`, which has a strong reference to its first map, `psi`, which has a strong reference to both its domain A and codomain B. Hence, C would prevent both A and B from garbage collection.\n\nI think this indeed qualifies as a memory leak, according to the definition I gave in some post above.\n\nDifficult. Can this be solved, even *with* copying? I have to think about it.\n\n> > This is already done in my current branch, and it is called `_registered_domains` (simply a list).\n\n> \n> And the maps inserted into `_coerce_from_hash` are weakened or not?\n\nIn my current branch, it is not weakened. Perhaps it should be. It would indeed be conceptually easier if a map is in the coercion system if and only if it is weakened. One *could* do it, since `_registered_domains` would keep the domain alive, Note, however, that this would not suffice for fixing the memory leak described above. We would still have that `chi` refers to `psi`, which strongly refers to its *codomain* B (the codomain is always strong), and then `B._registered_domains` strongly refers to `A`.\n\nIn this situation,\n- we want to have a strong reference from B to A, since we used `B.register_coercion(mor)`.\n- we must not have a strong reference from C to A, since `chi` was discovered but not registered.\n- we must not have a strong reference from C to B, since `phi` was not registered.\n- we could live with a strong reference from A to B, I guess.\n\nIf C is alive, then we want that it does not prevent A or B from garbage collection. But if both A and C are alive, then `chi` must remain a valid map, hence, B must be prevented from garbage collection. It follows that if C is alive then either A and B get collected *together*, or they both stay alive.\n\nI should catch some sleep now, perhaps I'll find a solution to the puzzle tomorrow.",
    "created_at": "2013-10-07T21:39:25Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181542",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:124'></a>
Replying to [nbruin](#comment%3A122):
> Replying to [SimonKing](#comment%3A121):
> > Suppose you have two non-weakened maps phi and psi, and then do chi = phi*psi (a composite map). When you then weaken chi, neither phi nor psi would be changed. So, why copying? 

> 
> Well, if you'd do that then `chi` wouldn't really be a weakened map. Assuming maps act on the left, i.e. `chi.domain()=psi.domain()`, the resulting structure would have a strong reference to its domain, via psi.domain().

Correct. Would this be a problem? Let's see:

Let `psi: A -> B` and `phi: B -> C` be coerce maps, hence, `chi=phi*psi: A -> C` is a coerce map as well. Assume that we have done `B.register_coercion(psi)`, so that B prevents A from garbage collection. Assume that `phi` is only stored in `C._coerce_from_hash`, i.e., C would not prevent B from garbage collection. In other words, we assume that phi is weakened but psi isn't.

Let us assume first that we did not discover `chi` as a coercion yet. If we have a strong reference to C but no external reference to B, then B and A could of course be garbage collected.

Now, let us assume that we *did* discover that `chi` is a coercion and put it into `C._coerce_from_hash`, in the attempt of weakening it. C would have a strong reference to `chi`, which has a strong reference to its first map, `psi`, which has a strong reference to both its domain A and codomain B. Hence, C would prevent both A and B from garbage collection.

I think this indeed qualifies as a memory leak, according to the definition I gave in some post above.

Difficult. Can this be solved, even *with* copying? I have to think about it.

> > This is already done in my current branch, and it is called `_registered_domains` (simply a list).

> 
> And the maps inserted into `_coerce_from_hash` are weakened or not?

In my current branch, it is not weakened. Perhaps it should be. It would indeed be conceptually easier if a map is in the coercion system if and only if it is weakened. One *could* do it, since `_registered_domains` would keep the domain alive, Note, however, that this would not suffice for fixing the memory leak described above. We would still have that `chi` refers to `psi`, which strongly refers to its *codomain* B (the codomain is always strong), and then `B._registered_domains` strongly refers to `A`.

In this situation,
- we want to have a strong reference from B to A, since we used `B.register_coercion(mor)`.
- we must not have a strong reference from C to A, since `chi` was discovered but not registered.
- we must not have a strong reference from C to B, since `phi` was not registered.
- we could live with a strong reference from A to B, I guess.

If C is alive, then we want that it does not prevent A or B from garbage collection. But if both A and C are alive, then `chi` must remain a valid map, hence, B must be prevented from garbage collection. It follows that if C is alive then either A and B get collected *together*, or they both stay alive.

I should catch some sleep now, perhaps I'll find a solution to the puzzle tomorrow.



---

archive/issue_comments_181543.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -70,14 +70,12 @@\n this bug is fixed, we surely want to make `SchemeMorphism` inherit from\n `Morphism`. This transition is prepared here.\n \n+Weakened maps should only be used in the coercion system: A weakened map can become invalid by garbage collection, and the coercion system has the job to remove a map from the coercion cache as soon as it becomes invalid.\n+\n+Maps outside of the coercion system should be safe against invalidation. Hence, when we take a coerce map, then we should better create a non-weakened copy. The branch also provides copying (and pickling) for *all* kinds of maps and morphisms (hopefully no map/morphism class went unnoticed).\n+\n In any case, the commit messages should give a concise description of what has\n been done.\n-\n-**__Still TODO__**\n-\n-- Let the string representation of weakened maps point the user to the need of\n-creating a copy.\n-- Provide copying for *all* kinds of maps.\n \n **__TODO in future tickets__**\n \n``````\n",
    "created_at": "2013-10-07T21:54:19Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181543",
    "user": "https://github.com/simon-king-jena"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -70,14 +70,12 @@
 this bug is fixed, we surely want to make `SchemeMorphism` inherit from
 `Morphism`. This transition is prepared here.
 
+Weakened maps should only be used in the coercion system: A weakened map can become invalid by garbage collection, and the coercion system has the job to remove a map from the coercion cache as soon as it becomes invalid.
+
+Maps outside of the coercion system should be safe against invalidation. Hence, when we take a coerce map, then we should better create a non-weakened copy. The branch also provides copying (and pickling) for *all* kinds of maps and morphisms (hopefully no map/morphism class went unnoticed).
+
 In any case, the commit messages should give a concise description of what has
 been done.
-
-**__Still TODO__**
-
-- Let the string representation of weakened maps point the user to the need of
-creating a copy.
-- Provide copying for *all* kinds of maps.
 
 **__TODO in future tickets__**
 
``````




---

archive/issue_comments_181544.json:
```json
{
    "body": "**Changing work issues** from \"String repr. of weakened maps; copying/pickling of maps\" to \"\".",
    "created_at": "2013-10-07T21:54:19Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181544",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "String repr. of weakened maps; copying/pickling of maps" to "".



---

archive/issue_comments_181545.json:
```json
{
    "body": "<a id='comment:5'></a>\nWith the new commit I have pushed today, all doctest should pass.",
    "created_at": "2013-10-07T21:54:19Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181545",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
With the new commit I have pushed today, all doctest should pass.



---

archive/issue_events_128593.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-07T21:54:19Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128593"
}
```



---

archive/issue_events_128594.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-10-07T21:54:19Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128594"
}
```



---

archive/issue_comments_181546.json:
```json
{
    "body": "<a id='comment:6'></a>\nLet me elaborate a bit more on the memory leak from [comment:124](#comment%3A124).\n\nFirst of all, this leak is not introduced by my branch. Hence, it would probably be better to attempt a fix on a different ticket, as the changes introduced in my branch already are big enough.\n\nNow for a deeper analysis of what happens. I want to argue that '''there is\nonly one scenario in which this leak occurs. This scenario rarely occurs\nand can easily be avoided.'''\n\nLet `phi: A -> B` and `psi: B -> C` be maps (sorry for changing the names\ncompared with [comment:124](#comment%3A124)...), and define `chi = psi*phi: A -> C`. We assume that `phi` and `psi` are coerce maps, and thus `chi` is a coerce\nmap as well, but initially Sage is not aware of `chi`.\n\n`chi` could be registered (i.e., `C.register_coercion(chi)`), it could be that\n`C._coerce_map_from_(A)` provides a shortcut, or it could be that `chi` is\ndiscovered by the backtracking algorithm of the coercion system.\n\n**Registering `chi`**\n\nOf course, if `chi` is explicitly registered as a coercion, then C will (with\nthe current code!!) keep A alive, and in order to not invalidate `chi`, B will\nbe kept alive as well. I don't consider this a memory leak, since it is an\nexplicit registration.\n\n**`_coerce_map_from_`**\n\nTypically, `C._coerce_map_from_(A)` just returns True, None or False, and not\na map. If it returns true, then a *direct* conversion `chi'` from A to C is\nstored as coercion. Note that `chi'` is not a composite map. So, we would be\nin a totally different situation. Since `chi'` has no reference to B, to `phi`\nor to `psi`, there is no leak in this case.\n\nTheoretically, `C._coerce_map_from_(A)` could return the composite map\n`chi`. This would be possible, and it would create a memory leak. Hence, we\nlearn that `_coerce_map_from_` should better not return a composite map. I\ndon't think we can automatically avoid a leak in this case.\n\n**Discovering `chi` by backtracking**\n\nWe need to distinguish cases, since there are different ways of how the\ncoercion system became aware of `phi` and `psi`.\n\nThe punchline is: '''If `chi` is discovered by backtracking then `psi` is\nstored in `C._coerce_from_list`.''' Without `psi` being on this list,\nbacktracking won't find `chi`.\n\nHence, there has `C.register_coercion(psi)` been done. With the current code, it\nmeans that C will keep B alive.\n\nThere remain only three cases:\n\n1. Assume that `phi` is a registered coercion. Hence, with the current code, B\n   keeps A alive, and still C will keep B alive. Hence, C also keeps A\n   alive. Adding `chi` to `C._coerce_from_hash[A]` won't change these lifetime\n   dependencies. *No leak.*\n\n2. Assume that `phi` is a coerce embedding. Hence, A will keep B alive, and\n   still C will keep B alive, but neither C nor B keep A alive. In particular, `phi` is weakened,\n   so that there is no strong reference from `phi` to A. Adding `chi` to\n   `C._coerce_from_hash[A]` will not change these lifetime dependencies, since\n   the key A is only weakly referenced. *No leak.*\n\n3. Assume that `phi` has been discovered by backtracking or has been provided by \n   `B._coerce_map_from_(A)` as a short-cut. In particular, it is weak and only has a weak\n   reference to A. Then, still C keeps B alive, but B does not keep A alive, nor does A keep B\n   alive, and C will also not keep A alive. If we put\n   `C._coerce_from_hash[A]=chi`, then again C will not prevent A from garbage\n   collection, since A is only weakly referenced in the `MonoDict`, and if\n   there is no external reference to C, then a strong reference to A will not\n   be enough to keep B alive. *No leak.*\n\n**__Conclusion__**\n\nA composite map can only arise in the coercion system, (1) if it is explicitly\nregistered, or (2) if the second map of the composition is explicitly\nregistered, or (3) if the composite map is returned by `_coerce_map_from_`.\n\nI think case (1) does not constitute a leak. I have shown that there is no\nmemory leak in case (2). Case (3) is a leak, but this case can easily be\navoided by returning a \"simple\" map that is mathematically equivalent to the\ncomposite map.",
    "created_at": "2013-10-08T14:26:22Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181546",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
Let me elaborate a bit more on the memory leak from [comment:124](#comment%3A124).

First of all, this leak is not introduced by my branch. Hence, it would probably be better to attempt a fix on a different ticket, as the changes introduced in my branch already are big enough.

Now for a deeper analysis of what happens. I want to argue that '''there is
only one scenario in which this leak occurs. This scenario rarely occurs
and can easily be avoided.'''

Let `phi: A -> B` and `psi: B -> C` be maps (sorry for changing the names
compared with [comment:124](#comment%3A124)...), and define `chi = psi*phi: A -> C`. We assume that `phi` and `psi` are coerce maps, and thus `chi` is a coerce
map as well, but initially Sage is not aware of `chi`.

`chi` could be registered (i.e., `C.register_coercion(chi)`), it could be that
`C._coerce_map_from_(A)` provides a shortcut, or it could be that `chi` is
discovered by the backtracking algorithm of the coercion system.

**Registering `chi`**

Of course, if `chi` is explicitly registered as a coercion, then C will (with
the current code!!) keep A alive, and in order to not invalidate `chi`, B will
be kept alive as well. I don't consider this a memory leak, since it is an
explicit registration.

**`_coerce_map_from_`**

Typically, `C._coerce_map_from_(A)` just returns True, None or False, and not
a map. If it returns true, then a *direct* conversion `chi'` from A to C is
stored as coercion. Note that `chi'` is not a composite map. So, we would be
in a totally different situation. Since `chi'` has no reference to B, to `phi`
or to `psi`, there is no leak in this case.

Theoretically, `C._coerce_map_from_(A)` could return the composite map
`chi`. This would be possible, and it would create a memory leak. Hence, we
learn that `_coerce_map_from_` should better not return a composite map. I
don't think we can automatically avoid a leak in this case.

**Discovering `chi` by backtracking**

We need to distinguish cases, since there are different ways of how the
coercion system became aware of `phi` and `psi`.

The punchline is: '''If `chi` is discovered by backtracking then `psi` is
stored in `C._coerce_from_list`.''' Without `psi` being on this list,
backtracking won't find `chi`.

Hence, there has `C.register_coercion(psi)` been done. With the current code, it
means that C will keep B alive.

There remain only three cases:

1. Assume that `phi` is a registered coercion. Hence, with the current code, B
   keeps A alive, and still C will keep B alive. Hence, C also keeps A
   alive. Adding `chi` to `C._coerce_from_hash[A]` won't change these lifetime
   dependencies. *No leak.*

2. Assume that `phi` is a coerce embedding. Hence, A will keep B alive, and
   still C will keep B alive, but neither C nor B keep A alive. In particular, `phi` is weakened,
   so that there is no strong reference from `phi` to A. Adding `chi` to
   `C._coerce_from_hash[A]` will not change these lifetime dependencies, since
   the key A is only weakly referenced. *No leak.*

3. Assume that `phi` has been discovered by backtracking or has been provided by 
   `B._coerce_map_from_(A)` as a short-cut. In particular, it is weak and only has a weak
   reference to A. Then, still C keeps B alive, but B does not keep A alive, nor does A keep B
   alive, and C will also not keep A alive. If we put
   `C._coerce_from_hash[A]=chi`, then again C will not prevent A from garbage
   collection, since A is only weakly referenced in the `MonoDict`, and if
   there is no external reference to C, then a strong reference to A will not
   be enough to keep B alive. *No leak.*

**__Conclusion__**

A composite map can only arise in the coercion system, (1) if it is explicitly
registered, or (2) if the second map of the composition is explicitly
registered, or (3) if the composite map is returned by `_coerce_map_from_`.

I think case (1) does not constitute a leak. I have shown that there is no
memory leak in case (2). Case (3) is a leak, but this case can easily be
avoided by returning a "simple" map that is mathematically equivalent to the
composite map.



---

archive/issue_comments_181547.json:
```json
{
    "body": "<a id='comment:7'></a>\nPS: Since teaching will start next week for me, I will probably not be able to fix the leak from [comment:124](#comment%3A124), even if you succeed to convince me that it *really* is a leak. So, I guess it is safe to start reviewing the attached branch, I think it will not change in the next few days...",
    "created_at": "2013-10-08T14:28:03Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181547",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
PS: Since teaching will start next week for me, I will probably not be able to fix the leak from [comment:124](#comment%3A124), even if you succeed to convince me that it *really* is a leak. So, I guess it is safe to start reviewing the attached branch, I think it will not change in the next few days...



---

archive/issue_comments_181548.json:
```json
{
    "body": "<a id='comment:8'></a>\nPPS: I just found that Sage's coercion system is clever enough to find a composite map if `phi` is registered as coerce embedding and `psi` is a short-cut:\n\n```\nsage: A = Aclass()\nsage: B = Bclass()\nsage: C = Cclass()\nsage: phi = sage.categories.map.Map(A,B)\nsage: A.register_embedding(phi)\nsage: psi = C.coerce_map_from(B)\nsage: print psi\nGeneric map:\n  From: <class '__main__.Bclass'>\n  To:   <class '__main__.Cclass'>\n\n        WARNING: This map has apparently been used internally\n        in the coercion system. It may become defunct in the next\n        garbage collection. Please use a copy.\nsage: print phi\nGeneric map:\n  From: <class '__main__.Aclass'>\n  To:   <class '__main__.Bclass'>\n\n        WARNING: This map has apparently been used internally\n        in the coercion system. It may become defunct in the next\n        garbage collection. Please use a copy.\nsage: C.coerce_map_from(A)\nComposite map:\n  From: <class '__main__.Aclass'>\n  To:   <class '__main__.Cclass'>\n\n        WARNING: This map has apparently been used internally\n        in the coercion system. It may become defunct in the next\n        garbage collection. Please use a copy.\n```\nHere, before discovering and caching the composite map, A keeps B alive because of the embedding, and C neither keeps A nor B alive. After caching the composite map, A still keeps B alive, and C still does not keep A alive, because it only occurs as weak key in a `MonoDict`.\n\nBut we have\n\n```\nsage: del psi, B, A\nsage: import gc\nsage: _ = gc.collect()\nsage: len([x for x in gc.get_objects() if isinstance(x,Aclass)])\n0\nsage: len([x for x in gc.get_objects() if isinstance(x,Bclass)])\n1\n```\nSo, why is B not garbage collected? To be investigated, I need to hurry now.",
    "created_at": "2013-10-08T15:32:15Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181548",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
PPS: I just found that Sage's coercion system is clever enough to find a composite map if `phi` is registered as coerce embedding and `psi` is a short-cut:

```
sage: A = Aclass()
sage: B = Bclass()
sage: C = Cclass()
sage: phi = sage.categories.map.Map(A,B)
sage: A.register_embedding(phi)
sage: psi = C.coerce_map_from(B)
sage: print psi
Generic map:
  From: <class '__main__.Bclass'>
  To:   <class '__main__.Cclass'>

        WARNING: This map has apparently been used internally
        in the coercion system. It may become defunct in the next
        garbage collection. Please use a copy.
sage: print phi
Generic map:
  From: <class '__main__.Aclass'>
  To:   <class '__main__.Bclass'>

        WARNING: This map has apparently been used internally
        in the coercion system. It may become defunct in the next
        garbage collection. Please use a copy.
sage: C.coerce_map_from(A)
Composite map:
  From: <class '__main__.Aclass'>
  To:   <class '__main__.Cclass'>

        WARNING: This map has apparently been used internally
        in the coercion system. It may become defunct in the next
        garbage collection. Please use a copy.
```
Here, before discovering and caching the composite map, A keeps B alive because of the embedding, and C neither keeps A nor B alive. After caching the composite map, A still keeps B alive, and C still does not keep A alive, because it only occurs as weak key in a `MonoDict`.

But we have

```
sage: del psi, B, A
sage: import gc
sage: _ = gc.collect()
sage: len([x for x in gc.get_objects() if isinstance(x,Aclass)])
0
sage: len([x for x in gc.get_objects() if isinstance(x,Bclass)])
1
```
So, why is B not garbage collected? To be investigated, I need to hurry now.



---

archive/issue_comments_181549.json:
```json
{
    "body": "<a id='comment:129'></a>\nReplying to [SimonKing](#comment%3A128):\n> \n> ```\n> sage: del psi, B, A\n> sage: import gc\n> sage: _ = gc.collect()\n> sage: len([x for x in gc.get_objects() if isinstance(x,Aclass)])\n> 0\n> sage: len([x for x in gc.get_objects() if isinstance(x,Bclass)])\n> 1\n> ```\n> So, why is B not garbage collected? To be investigated, I need to hurry now.\n\nArgh. Because simply I forgot to delete phi...\n\nLet's try again, this time without leaving a reference to the maps.\n\n```\nsage: import gc\nsage: class Aclass(Parent): pass                  \nsage: class Bclass(Parent): pass                  \nsage: class Cclass(Parent):                       \n....:    def _coerce_map_from_(self, P):\n....:        if isinstance(P, Bclass):\n....:            return sage.categories.map.Map(P,self)\n....:         \nsage: A = Aclass()\nsage: B = Bclass()\nsage: C = Cclass()\nsage: A.register_embedding(sage.categories.map.Map(A,B))\nsage: C.has_coerce_map_from(A)\nTrue\nsage: del A,B\nsage: gc.collect()\n862\nsage: len([x for x in gc.get_objects() if isinstance(x,Aclass)])\n0\nsage: len([x for x in gc.get_objects() if isinstance(x,Bclass)])\n0\n```\nSo, no leak.\n\nI think my analysis is now complete: A memory leak caused by composite coerce maps will only arise if `C._coerce_map_from_(A)` returns the composite map. I have also shown that there is no need to let `C._coerce_map_from_(A)` return a composite map.\n\nHence, I would argue that `C._coerce_map_from_(A)` returning a composite map is a misuse. Granted, it is far from obvious that it is a misuse. I feel tempted to investigate how often composite maps are actually returned by `_coerce_map_from_`.",
    "created_at": "2013-10-08T17:38:44Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181549",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:129'></a>
Replying to [SimonKing](#comment%3A128):
> 
> ```
> sage: del psi, B, A
> sage: import gc
> sage: _ = gc.collect()
> sage: len([x for x in gc.get_objects() if isinstance(x,Aclass)])
> 0
> sage: len([x for x in gc.get_objects() if isinstance(x,Bclass)])
> 1
> ```
> So, why is B not garbage collected? To be investigated, I need to hurry now.

Argh. Because simply I forgot to delete phi...

Let's try again, this time without leaving a reference to the maps.

```
sage: import gc
sage: class Aclass(Parent): pass                  
sage: class Bclass(Parent): pass                  
sage: class Cclass(Parent):                       
....:    def _coerce_map_from_(self, P):
....:        if isinstance(P, Bclass):
....:            return sage.categories.map.Map(P,self)
....:         
sage: A = Aclass()
sage: B = Bclass()
sage: C = Cclass()
sage: A.register_embedding(sage.categories.map.Map(A,B))
sage: C.has_coerce_map_from(A)
True
sage: del A,B
sage: gc.collect()
862
sage: len([x for x in gc.get_objects() if isinstance(x,Aclass)])
0
sage: len([x for x in gc.get_objects() if isinstance(x,Bclass)])
0
```
So, no leak.

I think my analysis is now complete: A memory leak caused by composite coerce maps will only arise if `C._coerce_map_from_(A)` returns the composite map. I have also shown that there is no need to let `C._coerce_map_from_(A)` return a composite map.

Hence, I would argue that `C._coerce_map_from_(A)` returning a composite map is a misuse. Granted, it is far from obvious that it is a misuse. I feel tempted to investigate how often composite maps are actually returned by `_coerce_map_from_`.



---

archive/issue_comments_181550.json:
```json
{
    "body": "<a id='comment:130'></a>\nReplying to [SimonKing](#comment%3A129):\n> Hence, I would argue that `C._coerce_map_from_(A)` returning a composite map is a misuse. Granted, it is far from obvious that it is a misuse. I feel tempted to investigate how often composite maps are actually returned by `_coerce_map_from_`.\n\nFor example, I found that during startup of Sage composite maps are returned by `Q._coerce_map_from_(P)` for the following values of P, Q:\n\n```\nCoercion Rational Field to Complex Field with 2 bits of precision\nCoercion Rational Field to Complex Field with 53 bits of precision\nCoercion <type 'int'> to Univariate Polynomial Ring in x over Integer Ring\nCoercion Integer Ring to Complex Field with 2 bits of precision\nCoercion <type 'int'> to Complex Field with 53 bits of precision\nCoercion <type 'int'> to Real Interval Field with 53 bits of precision\nCoercion <type 'int'> to Univariate Polynomial Ring in x over Rational Field\nCoercion <type 'int'> to Real Interval Field with 64 bits of precision\nCoercion Complex Lazy Field to Complex Double Field\nCoercion <type 'int'> to Univariate Polynomial Ring in x over Algebraic Real Field\n```\nI guess in all of these cases the domain and the \"middle parent\" will be immortal anyway.",
    "created_at": "2013-10-08T18:00:50Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181550",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:130'></a>
Replying to [SimonKing](#comment%3A129):
> Hence, I would argue that `C._coerce_map_from_(A)` returning a composite map is a misuse. Granted, it is far from obvious that it is a misuse. I feel tempted to investigate how often composite maps are actually returned by `_coerce_map_from_`.

For example, I found that during startup of Sage composite maps are returned by `Q._coerce_map_from_(P)` for the following values of P, Q:

```
Coercion Rational Field to Complex Field with 2 bits of precision
Coercion Rational Field to Complex Field with 53 bits of precision
Coercion <type 'int'> to Univariate Polynomial Ring in x over Integer Ring
Coercion Integer Ring to Complex Field with 2 bits of precision
Coercion <type 'int'> to Complex Field with 53 bits of precision
Coercion <type 'int'> to Real Interval Field with 53 bits of precision
Coercion <type 'int'> to Univariate Polynomial Ring in x over Rational Field
Coercion <type 'int'> to Real Interval Field with 64 bits of precision
Coercion Complex Lazy Field to Complex Double Field
Coercion <type 'int'> to Univariate Polynomial Ring in x over Algebraic Real Field
```
I guess in all of these cases the domain and the "middle parent" will be immortal anyway.



---

archive/issue_comments_181551.json:
```json
{
    "body": "<a id='comment:131'></a>\nReplying to [SimonKing](#comment%3A126):\n> First of all, this leak is not introduced by my branch. Hence, it would probably be better to attempt a fix on a different ticket, as the changes introduced in my branch already are big enough.\n\nAgreed.\n\n> Typically, `C._coerce_map_from_(A)` just returns True, None or False, and not\n> a map. If it returns true, then a *direct* conversion `chi'` from A to C is\n> stored as coercion.\n\nHm, I agree that the references are in that case out of reach of what we're considering here, but all this is saying is \"it is okay to use conversion as a coercion from A to C\". This conversion still has to be programmed/stored/discovered somewhere, so I'd expect that some conversion cache might be liable to hold a strong reference.\n\n> The punchline is: '''If `chi` is discovered by backtracking then `psi` is\n> stored in `C._coerce_from_list`.''' Without `psi` being on this list,\n> backtracking won't find `chi`.\n> \n> Hence, there has `C.register_coercion(psi)` been done. With the current code, it\n> means that C will keep B alive.\n\nRight, I was already expecting something along these lines when you explained the function of `coerce_from_list`: The backbone of the coercion framework presently requires lifetime specifications to be explicit and it seems this is not just a by-product of the implementation, it seems to be part of the spec. That's fine by itself. Whether having such implications is sufficient for sage in the future remains to be seen, but changing that is a redesign problem that would need to be carefully considered (just as it might be desirable to allow multiple embeddings to be registered)\n\nAs a consequence, in the present model, `register_coercion(...,strong=false)` would *not* be advisable.\n\n> Case (3) is a leak, but this case can easily be\n> avoided by returning a \"simple\" map that is mathematically equivalent to the\n> composite map.\n\nThis would be a necessary step to avoid the leak, and all the coercion system can do, but if programmed in a generic way, the references causing the leak would likely still be present internally.",
    "created_at": "2013-10-08T18:47:37Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181551",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:131'></a>
Replying to [SimonKing](#comment%3A126):
> First of all, this leak is not introduced by my branch. Hence, it would probably be better to attempt a fix on a different ticket, as the changes introduced in my branch already are big enough.

Agreed.

> Typically, `C._coerce_map_from_(A)` just returns True, None or False, and not
> a map. If it returns true, then a *direct* conversion `chi'` from A to C is
> stored as coercion.

Hm, I agree that the references are in that case out of reach of what we're considering here, but all this is saying is "it is okay to use conversion as a coercion from A to C". This conversion still has to be programmed/stored/discovered somewhere, so I'd expect that some conversion cache might be liable to hold a strong reference.

> The punchline is: '''If `chi` is discovered by backtracking then `psi` is
> stored in `C._coerce_from_list`.''' Without `psi` being on this list,
> backtracking won't find `chi`.
> 
> Hence, there has `C.register_coercion(psi)` been done. With the current code, it
> means that C will keep B alive.

Right, I was already expecting something along these lines when you explained the function of `coerce_from_list`: The backbone of the coercion framework presently requires lifetime specifications to be explicit and it seems this is not just a by-product of the implementation, it seems to be part of the spec. That's fine by itself. Whether having such implications is sufficient for sage in the future remains to be seen, but changing that is a redesign problem that would need to be carefully considered (just as it might be desirable to allow multiple embeddings to be registered)

As a consequence, in the present model, `register_coercion(...,strong=false)` would *not* be advisable.

> Case (3) is a leak, but this case can easily be
> avoided by returning a "simple" map that is mathematically equivalent to the
> composite map.

This would be a necessary step to avoid the leak, and all the coercion system can do, but if programmed in a generic way, the references causing the leak would likely still be present internally.



---

archive/issue_comments_181552.json:
```json
{
    "body": "<a id='comment:132'></a>\nReplying to [nbruin](#comment%3A131):\n> > The punchline is: '''If `chi` is discovered by backtracking then `psi` is\n> > stored in `C._coerce_from_list`.''' Without `psi` being on this list,\n> > backtracking won't find `chi`.\n\nModulo the oversight I have corrected in my previous posts:\n\nIf a composed map `chi` is discovered by backtracking, then either the second map is registered as a coercion (hence, C keeps B alive) or the first map is the coerce embedding of A (hence, A keeps B alive). But, as I have shown, storing the composed map as coercion from A to C (in `C._coerce_from_hash[A]`) does not cause a leak, at least not with the attached branch.\n \n> Right, I was already expecting something along these lines when you explained the function of `coerce_from_list`: The backbone of the coercion framework presently requires lifetime specifications to be explicit and it seems this is not just a by-product of the implementation, it seems to be part of the spec. That's fine by itself. Whether having such implications is sufficient for sage in the future remains to be seen, but changing that is a redesign problem that would need to be carefully considered\n\nAgreed. Currently, the coercion system operates on a virtual digraph, and I could actually imagine that this digraph could become an actual object with a fast graph backend. This might give more flexibility for our coercion system. But this would require a major rewrite.\n\n> (just as it might be desirable to allow multiple embeddings to be registered)\n\nWhy? What should be done with these embeddings?",
    "created_at": "2013-10-08T19:18:15Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181552",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:132'></a>
Replying to [nbruin](#comment%3A131):
> > The punchline is: '''If `chi` is discovered by backtracking then `psi` is
> > stored in `C._coerce_from_list`.''' Without `psi` being on this list,
> > backtracking won't find `chi`.

Modulo the oversight I have corrected in my previous posts:

If a composed map `chi` is discovered by backtracking, then either the second map is registered as a coercion (hence, C keeps B alive) or the first map is the coerce embedding of A (hence, A keeps B alive). But, as I have shown, storing the composed map as coercion from A to C (in `C._coerce_from_hash[A]`) does not cause a leak, at least not with the attached branch.
 
> Right, I was already expecting something along these lines when you explained the function of `coerce_from_list`: The backbone of the coercion framework presently requires lifetime specifications to be explicit and it seems this is not just a by-product of the implementation, it seems to be part of the spec. That's fine by itself. Whether having such implications is sufficient for sage in the future remains to be seen, but changing that is a redesign problem that would need to be carefully considered

Agreed. Currently, the coercion system operates on a virtual digraph, and I could actually imagine that this digraph could become an actual object with a fast graph backend. This might give more flexibility for our coercion system. But this would require a major rewrite.

> (just as it might be desirable to allow multiple embeddings to be registered)

Why? What should be done with these embeddings?



---

archive/issue_comments_181553.json:
```json
{
    "body": "<a id='comment:133'></a>\nReplying to [SimonKing](#comment%3A132):\n\n> Why? What should be done with these embeddings?\n\nI don't have a direct application in mind (hence the *might*), but just for symmetry it seems appropriate.\n\nOne possible example would be someone working on some weak approximation problem, having a whole bunch of number fields K with specified embeddings in CC as well as Qp (for some p). In this application, Qp may well be just as immortal as CC is, so using register_coercion would not express the right life time implications: The K should get deleted while Qp remains, just as CC remains.\n\nThis would be accomplished by letting  K have embeddings in both CC and Qp. I'm not claiming at this point that using coercion is the most appropriate tool to express the relations in this scenario.\n\nThere is one benefit one gets from having maps recognized as coercions: A lot of derived structures can now be automatically get built with the appropriate maps between them via pushout constructions. If you just have some maps lying around, constructing the corresponding derived maps will be a lot of work.\n\nThat's my reason to really care about an expressive coercion system. My experience with magma, which tends to have a much more restricted notion of coercion, has taught me that building these maps can be a *lot* of silly work. It would be great if one could \"borrow\" the coercion system for that every now and again (this is one of the reasons why I think some context manager that can put in \"temporary\" coercions would be great: inside the context manager one would request the derived map, store it, and then return the coercion system to its original state)",
    "created_at": "2013-10-09T17:26:24Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181553",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:133'></a>
Replying to [SimonKing](#comment%3A132):

> Why? What should be done with these embeddings?

I don't have a direct application in mind (hence the *might*), but just for symmetry it seems appropriate.

One possible example would be someone working on some weak approximation problem, having a whole bunch of number fields K with specified embeddings in CC as well as Qp (for some p). In this application, Qp may well be just as immortal as CC is, so using register_coercion would not express the right life time implications: The K should get deleted while Qp remains, just as CC remains.

This would be accomplished by letting  K have embeddings in both CC and Qp. I'm not claiming at this point that using coercion is the most appropriate tool to express the relations in this scenario.

There is one benefit one gets from having maps recognized as coercions: A lot of derived structures can now be automatically get built with the appropriate maps between them via pushout constructions. If you just have some maps lying around, constructing the corresponding derived maps will be a lot of work.

That's my reason to really care about an expressive coercion system. My experience with magma, which tends to have a much more restricted notion of coercion, has taught me that building these maps can be a *lot* of silly work. It would be great if one could "borrow" the coercion system for that every now and again (this is one of the reasons why I think some context manager that can put in "temporary" coercions would be great: inside the context manager one would request the derived map, store it, and then return the coercion system to its original state)



---

archive/issue_comments_181554.json:
```json
{
    "body": "<a id='comment:4'></a>\nI'm not so sure that the coercion system was designed with embeddings as an *alternative* to registered coercions: If you register a map only as an embedding (and not also as a coercion on the codomain) you can end up with the coercion system yielding non-transitive results:\n\n```\nclass pA(Parent): pass\nclass pB(Parent): pass\nclass pC(Parent): pass\n\nA=pA()\nB=pB()\nC=pC()\n\nBtoA=Hom(B,A)(lambda x: A(x))\nAtoC=Hom(A,C)(lambda x: C(x))\nA.register_coercion(BtoA)\nA.register_embedding(AtoC)\n\nC.coerce_map_from(A) #finds the right map\nA.coerce_map_from(B) #finds the right map\nC.coerce_map_from(B) #returns none!\n```\n(other combinations of using `register_coercion` and `register_embedding` do lead to the appropriate discovery)\n\nso, if we want to view the coercion framework as a digraph and valid coercions as paths in this digraph, then an arbitrary combination of `register_embedding` and `register_coercion` may lead to invalid manipulations of the graph (i.e., leading to a state where the system fails to provide consistent (transitive) results).\n\nThis wasn't such a problem before, but since we are now tying lifetime implications to how a coercion is registered, I think it now becomes apparent.",
    "created_at": "2013-10-10T18:39:14Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181554",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:4'></a>
I'm not so sure that the coercion system was designed with embeddings as an *alternative* to registered coercions: If you register a map only as an embedding (and not also as a coercion on the codomain) you can end up with the coercion system yielding non-transitive results:

```
class pA(Parent): pass
class pB(Parent): pass
class pC(Parent): pass

A=pA()
B=pB()
C=pC()

BtoA=Hom(B,A)(lambda x: A(x))
AtoC=Hom(A,C)(lambda x: C(x))
A.register_coercion(BtoA)
A.register_embedding(AtoC)

C.coerce_map_from(A) #finds the right map
A.coerce_map_from(B) #finds the right map
C.coerce_map_from(B) #returns none!
```
(other combinations of using `register_coercion` and `register_embedding` do lead to the appropriate discovery)

so, if we want to view the coercion framework as a digraph and valid coercions as paths in this digraph, then an arbitrary combination of `register_embedding` and `register_coercion` may lead to invalid manipulations of the graph (i.e., leading to a state where the system fails to provide consistent (transitive) results).

This wasn't such a problem before, but since we are now tying lifetime implications to how a coercion is registered, I think it now becomes apparent.



---

archive/issue_comments_181555.json:
```json
{
    "body": "<a id='comment:135'></a>\nReplying to [nbruin](#comment%3A134):\n> \n> ```\n> {{{\n> A.register_coercion(BtoA)\n> A.register_embedding(AtoC)\n> \n> C.coerce_map_from(A) #finds the right map\n> A.coerce_map_from(B) #finds the right map\n> C.coerce_map_from(B) #returns none!\n> }}}\n> ```\n\n*IF* this is a bug then it should be dealt with on a new ticket. Note, however, that `C` can not know about the embedding of `A` into `C`, and not even about the mere existence of `A`. So, how could it possibly be aware of a coercion from `B` to `C` via `A`? Hence, I am not sure if this qualifies as a bug or as a misuse.\n\n> This wasn't such a problem before, but since we are now tying lifetime implications to how a coercion is registered, I think it now becomes apparent.\n\nI don't quite follow this argument. Anyway, I should now do some more project related work, namely #12630,",
    "created_at": "2013-10-14T11:22:10Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181555",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:135'></a>
Replying to [nbruin](#comment%3A134):
> 
> ```
> {{{
> A.register_coercion(BtoA)
> A.register_embedding(AtoC)
> 
> C.coerce_map_from(A) #finds the right map
> A.coerce_map_from(B) #finds the right map
> C.coerce_map_from(B) #returns none!
> }}}
> ```

*IF* this is a bug then it should be dealt with on a new ticket. Note, however, that `C` can not know about the embedding of `A` into `C`, and not even about the mere existence of `A`. So, how could it possibly be aware of a coercion from `B` to `C` via `A`? Hence, I am not sure if this qualifies as a bug or as a misuse.

> This wasn't such a problem before, but since we are now tying lifetime implications to how a coercion is registered, I think it now becomes apparent.

I don't quite follow this argument. Anyway, I should now do some more project related work, namely #12630,



---

archive/issue_comments_181556.json:
```json
{
    "body": "<a id='comment:136'></a>\nReplying to [SimonKing](#comment%3A135):\n> *IF* this is a bug then it should be dealt with on a new ticket.\n\nAgreed.\n\n> Note, however, that `C` can not know about the embedding of `A` into `C`, and not even about the mere existence of `A`.\n\nAre you suggesting that `C.coerce_map_from(A)` already fails? If we follow the\ndigraph model for coercion, then whether there's a path from A to C is a\nproperty of the graph, not something the vertices \"know\" about. Perhaps the\nfollowing more symmetrically formulated code (which does the same thing anyway)\nis more convincing:\n\n```\nsage: G=get_coercion_model()\nsage: G.discover_coercion(A,C)\n(Generic morphism ..., None)\nsage: G.discover_coercion(B,A) #currently unweakened with your patch!\n(Generic morphism ..., None)\nsage: sage: G.discover_coercion(B,C)\nNone\n```\n\n> So, how could it possibly be aware of a coercion from `B` to `C` via `A`?\n> Hence, I am not sure if this qualifies as a bug or as a misuse.\n\nAre you claiming that `register_embedding` is not supposed to add edges to the\nsame graph as `register_coercion` does? I don't see how that would lead to a\nuseful model.\n\n> > This wasn't such a problem before, but since we are now tying lifetime\n> > implications to how a coercion is registered, I think it now becomes apparent.\n\n> I don't quite follow this argument.\n\nAs the documentation of `register_embedding` shows, it was originally considered\nto be a rather non-essential component; just some coercion map that gets\n\"blessed\" as a particularly canonical one, but doesn't actually has a\nvery different effect (in fact, as we see, really a more limited effect), so\npeople would just have used `register_coercion` or (even more flexible)\n`_coerce_map_from_`.\n\nWith less strong references, there is more reason to use `register_embedding`:\nit expresses that the domain should keep the codomain alive rather than the\nother way around; the kind of thing that wouldn't be expressed usefully before\nanyway.",
    "created_at": "2013-10-14T16:35:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181556",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:136'></a>
Replying to [SimonKing](#comment%3A135):
> *IF* this is a bug then it should be dealt with on a new ticket.

Agreed.

> Note, however, that `C` can not know about the embedding of `A` into `C`, and not even about the mere existence of `A`.

Are you suggesting that `C.coerce_map_from(A)` already fails? If we follow the
digraph model for coercion, then whether there's a path from A to C is a
property of the graph, not something the vertices "know" about. Perhaps the
following more symmetrically formulated code (which does the same thing anyway)
is more convincing:

```
sage: G=get_coercion_model()
sage: G.discover_coercion(A,C)
(Generic morphism ..., None)
sage: G.discover_coercion(B,A) #currently unweakened with your patch!
(Generic morphism ..., None)
sage: sage: G.discover_coercion(B,C)
None
```

> So, how could it possibly be aware of a coercion from `B` to `C` via `A`?
> Hence, I am not sure if this qualifies as a bug or as a misuse.

Are you claiming that `register_embedding` is not supposed to add edges to the
same graph as `register_coercion` does? I don't see how that would lead to a
useful model.

> > This wasn't such a problem before, but since we are now tying lifetime
> > implications to how a coercion is registered, I think it now becomes apparent.

> I don't quite follow this argument.

As the documentation of `register_embedding` shows, it was originally considered
to be a rather non-essential component; just some coercion map that gets
"blessed" as a particularly canonical one, but doesn't actually has a
very different effect (in fact, as we see, really a more limited effect), so
people would just have used `register_coercion` or (even more flexible)
`_coerce_map_from_`.

With less strong references, there is more reason to use `register_embedding`:
it expresses that the domain should keep the codomain alive rather than the
other way around; the kind of thing that wouldn't be expressed usefully before
anyway.



---

archive/issue_comments_181557.json:
```json
{
    "body": "<a id='comment:137'></a>\nReplying to [SimonKing](#comment%3A135):\n> Replying to [nbruin](#comment%3A134):\n> > \n> > ```\n> > A.register_coercion(BtoA)\n> > A.register_embedding(AtoC)\n> > \n> > C.coerce_map_from(A) #finds the right map\n> > A.coerce_map_from(B) #finds the right map\n> > C.coerce_map_from(B) #returns none!\n> > ```\n\n> \n> *IF* this is a bug then it should be dealt with on a new ticket.\n\nThis is now #15303.",
    "created_at": "2013-10-17T22:08:11Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181557",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:137'></a>
Replying to [SimonKing](#comment%3A135):
> Replying to [nbruin](#comment%3A134):
> > 
> > ```
> > A.register_coercion(BtoA)
> > A.register_embedding(AtoC)
> > 
> > C.coerce_map_from(A) #finds the right map
> > A.coerce_map_from(B) #finds the right map
> > C.coerce_map_from(B) #returns none!
> > ```

> 
> *IF* this is a bug then it should be dealt with on a new ticket.

This is now #15303.



---

archive/issue_comments_181558.json:
```json
{
    "body": "<a id='comment:8'></a>\nAny info what exactly slowed down the tableaux classes?",
    "created_at": "2013-11-15T03:27:45Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181558",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:8'></a>
Any info what exactly slowed down the tableaux classes?



---

archive/issue_comments_181559.json:
```json
{
    "body": "**Changing commit** from \"[364b9856b28d7060e3ea9825144de66c8f11ca2a](https://github.com/sagemath/sagetrac-mirror/commit/364b9856b28d7060e3ea9825144de66c8f11ca2a)\" to \"[23f18f23c38b104364ba499b4d4db8683480b895](https://github.com/sagemath/sagetrac-mirror/commit/23f18f23c38b104364ba499b4d4db8683480b895)\".",
    "created_at": "2013-11-16T16:37:25Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181559",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[364b9856b28d7060e3ea9825144de66c8f11ca2a](https://github.com/sagemath/sagetrac-mirror/commit/364b9856b28d7060e3ea9825144de66c8f11ca2a)" to "[23f18f23c38b104364ba499b4d4db8683480b895](https://github.com/sagemath/sagetrac-mirror/commit/23f18f23c38b104364ba499b4d4db8683480b895)".



---

archive/issue_comments_181560.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[23f18f2](https://github.com/sagemath/sagetrac-mirror/commit/23f18f2)</td><td><code>Merge branch 'master' into ticket/14711</code></td></tr></table>\n",
    "created_at": "2013-11-16T16:37:25Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181560",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[23f18f2](https://github.com/sagemath/sagetrac-mirror/commit/23f18f2)</td><td><code>Merge branch 'master' into ticket/14711</code></td></tr></table>




---

archive/issue_comments_181561.json:
```json
{
    "body": "<a id='comment:140'></a>\nFWIW, I have merged the current master branch into the branch from here. I had to resolve some merge conflicts. So, I hope I did right.\n\nReplying to [darij](#comment%3A138):\n> Any info what exactly slowed down the tableaux classes?\n\nI did not state (in [comment:107](#comment%3A107)) that tableaux classes became slower. All what I stated was: If you run the complete doc tests of Sage, then you will find that more parent creations occur with the branch than with vanilla Sage---and the tableaux classes show the largest relative increase.\n\nI don't even state that this is bad. Apparently there are doctests that would in vanilla Sage re-use tableaux that have been created in other doctests. This branch fixes a leak. Hence, some tableaux are garbage collected between doctests.\n\n**IF** the tableaux developers believe that tablaux should be more strongly cached, then they should properly implement a stronger cache, rather than relying on the memory leak that is fixed in this ticket.",
    "created_at": "2013-11-16T16:52:18Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181561",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:140'></a>
FWIW, I have merged the current master branch into the branch from here. I had to resolve some merge conflicts. So, I hope I did right.

Replying to [darij](#comment%3A138):
> Any info what exactly slowed down the tableaux classes?

I did not state (in [comment:107](#comment%3A107)) that tableaux classes became slower. All what I stated was: If you run the complete doc tests of Sage, then you will find that more parent creations occur with the branch than with vanilla Sage---and the tableaux classes show the largest relative increase.

I don't even state that this is bad. Apparently there are doctests that would in vanilla Sage re-use tableaux that have been created in other doctests. This branch fixes a leak. Hence, some tableaux are garbage collected between doctests.

**IF** the tableaux developers believe that tablaux should be more strongly cached, then they should properly implement a stronger cache, rather than relying on the memory leak that is fixed in this ticket.



---

archive/issue_comments_181562.json:
```json
{
    "body": "<a id='comment:1'></a>\nI'm not blaming your branch for slowing down tableaux! Actually, tableaux are probably doing a good job at slowing down themselves, and there's been a plan for quite a while now to rewrite their class hierarchy from scratch. But I want to know what exactly it is that causes these slowdowns in tableaux but nowhere else (kind of); that would probably an antipattern we should try to avoid.\n\nAre there good ways of finding out\n\n1) what causes the slowdown, and\n\n2) how the branches compare on more realistic measurements rather than doctests (say, by dropping the cache between every doctest and the next one?)?",
    "created_at": "2013-11-17T00:21:08Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181562",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:1'></a>
I'm not blaming your branch for slowing down tableaux! Actually, tableaux are probably doing a good job at slowing down themselves, and there's been a plan for quite a while now to rewrite their class hierarchy from scratch. But I want to know what exactly it is that causes these slowdowns in tableaux but nowhere else (kind of); that would probably an antipattern we should try to avoid.

Are there good ways of finding out

1) what causes the slowdown, and

2) how the branches compare on more realistic measurements rather than doctests (say, by dropping the cache between every doctest and the next one?)?



---

archive/issue_events_128595.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-26T10:52:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "milestone": "sage-5.13",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128595"
}
```



---

archive/issue_events_128596.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-11-26T10:52:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "milestone": "sage-6.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128596"
}
```



---

archive/issue_comments_181563.json:
```json
{
    "body": "<a id='comment:3'></a>\nCan't get this thing to compile:\n\n```\ndarij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ make build\ncd build && \\\n\t\"../build/pipestatus\" \\\n\t\t\"env SAGE_PARALLEL_SPKG_BUILD='' ./install all 2>&1\" \\\n\t\t\"tee -a ../logs/install.log\"\n```\nIt seems to hang at this place...",
    "created_at": "2013-11-30T06:39:33Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181563",
    "user": "https://github.com/darijgr"
}
```

<a id='comment:3'></a>
Can't get this thing to compile:

```
darij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ make build
cd build && \
	"../build/pipestatus" \
		"env SAGE_PARALLEL_SPKG_BUILD='' ./install all 2>&1" \
		"tee -a ../logs/install.log"
```
It seems to hang at this place...



---

archive/issue_comments_181564.json:
```json
{
    "body": "<a id='comment:144'></a>\nReplying to [darij](#comment%3A143):\n> Can't get this thing to compile:\n> \n> ```\n> darij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ make build\n> cd build && \\\n> \t\"../build/pipestatus\" \\\n> \t\t\"env SAGE_PARALLEL_SPKG_BUILD='' ./install all 2>&1\" \\\n> \t\t\"tee -a ../logs/install.log\"\n> ```\n> It seems to hang at this place...\n\nI have seen this a couple of times---not only here. Sometimes it even occurs when returning to vanilla sage. So, I believe it is not a problem of this branch, but a general problem. Of git? Of Sage's build system? No idea.\n\nI had the impression that doing \"pkill python\" helps. Not sure though.",
    "created_at": "2013-11-30T09:26:06Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181564",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:144'></a>
Replying to [darij](#comment%3A143):
> Can't get this thing to compile:
> 
> ```
> darij@travis-virtualbox:~/gitsage/sage-5.13.beta1$ make build
> cd build && \
> 	"../build/pipestatus" \
> 		"env SAGE_PARALLEL_SPKG_BUILD='' ./install all 2>&1" \
> 		"tee -a ../logs/install.log"
> ```
> It seems to hang at this place...

I have seen this a couple of times---not only here. Sometimes it even occurs when returning to vanilla sage. So, I believe it is not a problem of this branch, but a general problem. Of git? Of Sage's build system? No idea.

I had the impression that doing "pkill python" helps. Not sure though.



---

archive/issue_comments_181565.json:
```json
{
    "body": "**Work Issues:** Fix doctests errors after merging master",
    "created_at": "2013-11-30T19:58:44Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181565",
    "user": "https://github.com/simon-king-jena"
}
```

**Work Issues:** Fix doctests errors after merging master



---

archive/issue_comments_181566.json:
```json
{
    "body": "<a id='comment:5'></a>\nSome errors have emerged, at qsym.py, for example.",
    "created_at": "2013-11-30T19:58:44Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181566",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
Some errors have emerged, at qsym.py, for example.



---

archive/issue_comments_181567.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[d68c5df](https://github.com/sagemath/sagetrac-mirror/commit/d68c5df)</td><td><code>Minor fixes, that became needed since #14711 was not merged quickly enough</code></td></tr><tr><td>[c42b539](https://github.com/sagemath/sagetrac-mirror/commit/c42b539)</td><td><code>Merge branch 'master' into ticket/14711</code></td></tr></table>\n",
    "created_at": "2013-11-30T20:10:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181567",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[d68c5df](https://github.com/sagemath/sagetrac-mirror/commit/d68c5df)</td><td><code>Minor fixes, that became needed since #14711 was not merged quickly enough</code></td></tr><tr><td>[c42b539](https://github.com/sagemath/sagetrac-mirror/commit/c42b539)</td><td><code>Merge branch 'master' into ticket/14711</code></td></tr></table>




---

archive/issue_comments_181568.json:
```json
{
    "body": "**Changing commit** from \"[23f18f23c38b104364ba499b4d4db8683480b895](https://github.com/sagemath/sagetrac-mirror/commit/23f18f23c38b104364ba499b4d4db8683480b895)\" to \"[d68c5df4618cc4fcf8ef215ee6b2f475be028209](https://github.com/sagemath/sagetrac-mirror/commit/d68c5df4618cc4fcf8ef215ee6b2f475be028209)\".",
    "created_at": "2013-11-30T20:10:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181568",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[23f18f23c38b104364ba499b4d4db8683480b895](https://github.com/sagemath/sagetrac-mirror/commit/23f18f23c38b104364ba499b4d4db8683480b895)" to "[d68c5df4618cc4fcf8ef215ee6b2f475be028209](https://github.com/sagemath/sagetrac-mirror/commit/d68c5df4618cc4fcf8ef215ee6b2f475be028209)".



---

archive/issue_comments_181569.json:
```json
{
    "body": "<a id='comment:7'></a>\nThe new commit fixes some trivial errors (some people were still using `._domain` and were still not copying coerce maps when exposing them to the outside world).\n\nHowever, this will be a tough one:\n\n```\nsage -t src/sage/schemes/projective/projective_morphism.py\n**********************************************************************\nFile \"src/sage/schemes/projective/projective_morphism.py\", line 1326, in sage.schemes.projective.projective_morphism.SchemeMorphism_polynomial_projective_space.canonical_height\nFailed example:\n    f.canonical_height(Q,badprimes=[2])\nExpected:\n    0.0013538030870311431824555314882\nGot:\n    verbose 0 (3533: multi_polynomial_ideal.py, groebner_basis) Warning: falling back to very slow toy implementation.\n    verbose 0 (3533: multi_polynomial_ideal.py, groebner_basis) Warning: falling back to very slow toy implementation.\n    0.0013538030870311431824555314882\n**********************************************************************\n1 item had failures:\n   1 of  16 in sage.schemes.projective.projective_morphism.SchemeMorphism_polynomial_projective_space.canonical_height\n    [481 tests, 1 failure, 8.63 s]\n----------------------------------------------------------------------\nsage -t src/sage/schemes/projective/projective_morphism.py  # 1 doctest failed\n----------------------------------------------------------------------\nTotal time for all tests: 8.9 seconds\n    cpu time: 7.7 seconds\n    cumulative wall time: 8.6 seconds\n```\nSomehow, the use of a weakened coerce map makes the Gr\u00f6bner machinery use a slow toy implementation `:-/`",
    "created_at": "2013-11-30T20:14:17Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181569",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
The new commit fixes some trivial errors (some people were still using `._domain` and were still not copying coerce maps when exposing them to the outside world).

However, this will be a tough one:

```
sage -t src/sage/schemes/projective/projective_morphism.py
**********************************************************************
File "src/sage/schemes/projective/projective_morphism.py", line 1326, in sage.schemes.projective.projective_morphism.SchemeMorphism_polynomial_projective_space.canonical_height
Failed example:
    f.canonical_height(Q,badprimes=[2])
Expected:
    0.0013538030870311431824555314882
Got:
    verbose 0 (3533: multi_polynomial_ideal.py, groebner_basis) Warning: falling back to very slow toy implementation.
    verbose 0 (3533: multi_polynomial_ideal.py, groebner_basis) Warning: falling back to very slow toy implementation.
    0.0013538030870311431824555314882
**********************************************************************
1 item had failures:
   1 of  16 in sage.schemes.projective.projective_morphism.SchemeMorphism_polynomial_projective_space.canonical_height
    [481 tests, 1 failure, 8.63 s]
----------------------------------------------------------------------
sage -t src/sage/schemes/projective/projective_morphism.py  # 1 doctest failed
----------------------------------------------------------------------
Total time for all tests: 8.9 seconds
    cpu time: 7.7 seconds
    cumulative wall time: 8.6 seconds
```
Somehow, the use of a weakened coerce map makes the Gröbner machinery use a slow toy implementation `:-/`



---

archive/issue_events_128597.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-30T20:14:17Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128597"
}
```



---

archive/issue_events_128598.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-11-30T20:14:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128598"
}
```



---

archive/issue_comments_181570.json:
```json
{
    "body": "<a id='comment:8'></a>\nI found how Gr\u00f6bner basis computation comes into play: When calling a scheme morphism, a scheme is called, which involves for some map `S` to test `S.codomain() == self`. This comparison involves comparing ideals, and this means one needs to compute a Gr\u00f6bner basis.\n\nI only wonder why this comparison does not happen with strong maps. Also I need to study why the comparison is not by identity.",
    "created_at": "2013-12-01T13:08:26Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181570",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
I found how Gröbner basis computation comes into play: When calling a scheme morphism, a scheme is called, which involves for some map `S` to test `S.codomain() == self`. This comparison involves comparing ideals, and this means one needs to compute a Gröbner basis.

I only wonder why this comparison does not happen with strong maps. Also I need to study why the comparison is not by identity.



---

archive/issue_comments_181571.json:
```json
{
    "body": "<a id='comment:9'></a>\nAha! It does not come from the weak maps, but it comes from the fact that my branch also changes the `__call__` method of scheme morphisms (namely copying what happens in sage.categories.map`). So, this could be the problem.",
    "created_at": "2013-12-01T13:12:43Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181571",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Aha! It does not come from the weak maps, but it comes from the fact that my branch also changes the `__call__` method of scheme morphisms (namely copying what happens in sage.categories.map`). So, this could be the problem.



---

archive/issue_comments_181572.json:
```json
{
    "body": "<a id='comment:0'></a>\nI will fix it, but this also means that conversion between different schemes will be more permissive. But I think this is consistent with the rest of Sage: Conversions are just supposed to somehow make sense of the input, whereas only coercions have to satisfy certain axioms.",
    "created_at": "2013-12-01T15:37:56Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181572",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
I will fix it, but this also means that conversion between different schemes will be more permissive. But I think this is consistent with the rest of Sage: Conversions are just supposed to somehow make sense of the input, whereas only coercions have to satisfy certain axioms.



---

archive/issue_comments_181573.json:
```json
{
    "body": "<a id='comment:1'></a>\nToo bad. We *have* to have `check=True` by default (that's convention in Sage). And since schemes are no unique parents, comparison of schemes will generally involve Gr\u00f6bner basis computations.\n\nI only hope that in this particular application we *know* that we are dealing with good input and thus can set `check=False`.",
    "created_at": "2013-12-01T18:11:52Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181573",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
Too bad. We *have* to have `check=True` by default (that's convention in Sage). And since schemes are no unique parents, comparison of schemes will generally involve Gröbner basis computations.

I only hope that in this particular application we *know* that we are dealing with good input and thus can set `check=False`.



---

archive/issue_comments_181574.json:
```json
{
    "body": "**Changing commit** from \"[d68c5df4618cc4fcf8ef215ee6b2f475be028209](https://github.com/sagemath/sagetrac-mirror/commit/d68c5df4618cc4fcf8ef215ee6b2f475be028209)\" to \"[ee30c20b0adc9878a13c8286c96ee5e972e2b002](https://github.com/sagemath/sagetrac-mirror/commit/ee30c20b0adc9878a13c8286c96ee5e972e2b002)\".",
    "created_at": "2013-12-01T18:37:47Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181574",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[d68c5df4618cc4fcf8ef215ee6b2f475be028209](https://github.com/sagemath/sagetrac-mirror/commit/d68c5df4618cc4fcf8ef215ee6b2f475be028209)" to "[ee30c20b0adc9878a13c8286c96ee5e972e2b002](https://github.com/sagemath/sagetrac-mirror/commit/ee30c20b0adc9878a13c8286c96ee5e972e2b002)".



---

archive/issue_comments_181575.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td>[ee30c20](https://github.com/sagemath/sagetrac-mirror/commit/ee30c20)</td><td><code>Address the \"check\" keyword of scheme morphisms by name, not position</code></td></tr></table>\n",
    "created_at": "2013-12-01T18:37:47Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181575",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td>[ee30c20](https://github.com/sagemath/sagetrac-mirror/commit/ee30c20)</td><td><code>Address the "check" keyword of scheme morphisms by name, not position</code></td></tr></table>




---

archive/issue_comments_181576.json:
```json
{
    "body": "<a id='comment:3'></a>\nWith the new commit, all tests in sage.schemes pass. I guess this means \"needs review\" again!",
    "created_at": "2013-12-01T18:48:37Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181576",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
With the new commit, all tests in sage.schemes pass. I guess this means "needs review" again!



---

archive/issue_events_128599.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-12-01T18:48:37Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128599"
}
```



---

archive/issue_events_128600.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2013-12-01T18:48:37Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128600"
}
```



---

archive/issue_comments_181577.json:
```json
{
    "body": "**Changing work issues** from \"Fix doctests errors after merging master\" to \"\".",
    "created_at": "2013-12-01T18:48:37Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181577",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work issues** from "Fix doctests errors after merging master" to "".



---

archive/issue_comments_181578.json:
```json
{
    "body": "<a id='comment:4'></a>\nFor (sub)scheme equality testing, should there be a fast path returning true for identical schemes? That would be a rather common case in the coercion system. There are of course other fast \"true\" cases: When ideals have the same generators then equality can be determined pretty quickly too. (it wouldn't surprise me if singular already had that optimization)",
    "created_at": "2013-12-01T19:29:53Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181578",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:4'></a>
For (sub)scheme equality testing, should there be a fast path returning true for identical schemes? That would be a rather common case in the coercion system. There are of course other fast "true" cases: When ideals have the same generators then equality can be determined pretty quickly too. (it wouldn't surprise me if singular already had that optimization)



---

archive/issue_comments_181579.json:
```json
{
    "body": "<a id='comment:155'></a>\nReplying to [nbruin](#comment%3A154):\n> For (sub)scheme equality testing, should there be a fast path returning true for identical schemes? \n\nIsn't this what happens when doing `==` in python?\n\n> There are of course other fast \"true\" cases: When ideals have the same generators then equality can be determined pretty quickly too. (it wouldn't surprise me if singular already had that optimization)\n\nIndeed. But I think we already have a ticket for comparison of ideals---with the additional complication that the hash of ideals must involve a Gr\u00f6bner basis computation as well.",
    "created_at": "2013-12-01T19:44:02Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181579",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:155'></a>
Replying to [nbruin](#comment%3A154):
> For (sub)scheme equality testing, should there be a fast path returning true for identical schemes? 

Isn't this what happens when doing `==` in python?

> There are of course other fast "true" cases: When ideals have the same generators then equality can be determined pretty quickly too. (it wouldn't surprise me if singular already had that optimization)

Indeed. But I think we already have a ticket for comparison of ideals---with the additional complication that the hash of ideals must involve a Gröbner basis computation as well.



---

archive/issue_comments_181580.json:
```json
{
    "body": "<a id='comment:156'></a>\nReplying to [SimonKing](#comment%3A155):\n> Isn't this what happens when doing `==` in python?\n\nNo it doesn't:\n\n```\nsage: class T(object):\n....:     def __eq__(self,other):\n....:         return False\n....:     \nsage: a=T()\nsage: a == a\nFalse\n```\nand in fact, there is a famous object in standard Python with this property:\n\n```\nsage: float(NaN)\nnan\nsage: nan=float(NaN)\nsage: nan == nan\nFalse\n```\nThere is a documented optimization in dictionaries: Upon key lookup, identity is tested before equality is tried. This has odd consequences when `NaN` is used as a key in a dict: If you use the identical `NaN`, lookup will succeed, but not with any other `NaN`.\n\n> Indeed. But I think we already have a ticket for comparison of ideals---with the additional complication that the hash of ideals must involve a Gr\u00f6bner basis computation as well.\n\nHm, that's not clear to me. In order to have a GOOD hash it seems something like a groebner basis needs to be involved. but for some applications using the same hash as the ring would also be a great hash. Of course, in many cases a groebner basis is going to be required anyway (are ideals with different monomial orders automatically non-equal?), so perhaps basing the hash on it isn't such a big deal.\n\nIt is an indication that ideals shouldn't be used as keys in dictionaries, where their hash would be required. In particular, it means schemes shouldn't be produced from an ideal (literally) but from a list of generators. Otherwise we're going to be in trouble if schemes ever were to become UniqueRepresentation.",
    "created_at": "2013-12-01T20:23:22Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181580",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:156'></a>
Replying to [SimonKing](#comment%3A155):
> Isn't this what happens when doing `==` in python?

No it doesn't:

```
sage: class T(object):
....:     def __eq__(self,other):
....:         return False
....:     
sage: a=T()
sage: a == a
False
```
and in fact, there is a famous object in standard Python with this property:

```
sage: float(NaN)
nan
sage: nan=float(NaN)
sage: nan == nan
False
```
There is a documented optimization in dictionaries: Upon key lookup, identity is tested before equality is tried. This has odd consequences when `NaN` is used as a key in a dict: If you use the identical `NaN`, lookup will succeed, but not with any other `NaN`.

> Indeed. But I think we already have a ticket for comparison of ideals---with the additional complication that the hash of ideals must involve a Gröbner basis computation as well.

Hm, that's not clear to me. In order to have a GOOD hash it seems something like a groebner basis needs to be involved. but for some applications using the same hash as the ring would also be a great hash. Of course, in many cases a groebner basis is going to be required anyway (are ideals with different monomial orders automatically non-equal?), so perhaps basing the hash on it isn't such a big deal.

It is an indication that ideals shouldn't be used as keys in dictionaries, where their hash would be required. In particular, it means schemes shouldn't be produced from an ideal (literally) but from a list of generators. Otherwise we're going to be in trouble if schemes ever were to become UniqueRepresentation.



---

archive/issue_events_128601.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2013-12-17T18:39:51Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "milestone": "sage-6.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128601"
}
```



---

archive/issue_events_128602.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2013-12-17T18:39:51Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "milestone": "sage-6.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128602"
}
```



---

archive/issue_comments_181581.json:
```json
{
    "body": "<a id='comment:8'></a>\nHello everyone,\n\nIt looks like there has already been plenty of discussion about this branch, and stupid merge conflicts with `develop` accumulate while it is waiting for review. Could someone please clarify which parts of the changes still need review?\n\n(Btw I just pushed `u/mmezzarobba/ticket/14711` to resolve a trivial conflicts with the current `develop` branch. But it may be a better idea to wait until this branch is really ready to be merged and do a single merge.)",
    "created_at": "2013-12-20T08:29:49Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181581",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:8'></a>
Hello everyone,

It looks like there has already been plenty of discussion about this branch, and stupid merge conflicts with `develop` accumulate while it is waiting for review. Could someone please clarify which parts of the changes still need review?

(Btw I just pushed `u/mmezzarobba/ticket/14711` to resolve a trivial conflicts with the current `develop` branch. But it may be a better idea to wait until this branch is really ready to be merged and do a single merge.)



---

archive/issue_comments_181582.json:
```json
{
    "body": "<a id='comment:9'></a>\nThe current `master` seems to merge cleanly (I didn't test `develop`, though). What is the policy (Volker?): Is it enough to review a ticket after merging with the current master branch? Or has the reviewer to take into account the develop branch, too?",
    "created_at": "2013-12-21T13:21:39Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181582",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
The current `master` seems to merge cleanly (I didn't test `develop`, though). What is the policy (Volker?): Is it enough to review a ticket after merging with the current master branch? Or has the reviewer to take into account the develop branch, too?



---

archive/issue_comments_181583.json:
```json
{
    "body": "<a id='comment:0'></a>\nAll tests pass after merging master. But there is a conflict with #12217 (in the develop branch). I am now testing the merge I just did, and will push the resulting branch in case of success.",
    "created_at": "2013-12-21T15:11:55Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181583",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:0'></a>
All tests pass after merging master. But there is a conflict with #12217 (in the develop branch). I am now testing the merge I just did, and will push the resulting branch in case of success.



---

archive/issue_comments_181584.json:
```json
{
    "body": "<a id='comment:161'></a>\nReplying to [SimonKing](#comment%3A160):\n> All tests pass after merging master. But there is a conflict with #12217 (in the develop branch). I am now testing the merge I just did, and will push the resulting branch in case of success.\n\nIs your merge different from mine? No need to run the tests if it is identical, I already did.",
    "created_at": "2013-12-21T16:08:43Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181584",
    "user": "https://github.com/mezzarobba"
}
```

<a id='comment:161'></a>
Replying to [SimonKing](#comment%3A160):
> All tests pass after merging master. But there is a conflict with #12217 (in the develop branch). I am now testing the merge I just did, and will push the resulting branch in case of success.

Is your merge different from mine? No need to run the tests if it is identical, I already did.



---

archive/issue_comments_181585.json:
```json
{
    "body": "**Changing commit** from \"[ee30c20b0adc9878a13c8286c96ee5e972e2b002](https://github.com/sagemath/sagetrac-mirror/commit/ee30c20b0adc9878a13c8286c96ee5e972e2b002)\" to \"[37bf59eac24eda1ece89aff7dde4a1db5d0cbb5c](https://github.com/sagemath/sagetrac-mirror/commit/37bf59eac24eda1ece89aff7dde4a1db5d0cbb5c)\".",
    "created_at": "2013-12-21T16:30:43Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181585",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ee30c20b0adc9878a13c8286c96ee5e972e2b002](https://github.com/sagemath/sagetrac-mirror/commit/ee30c20b0adc9878a13c8286c96ee5e972e2b002)" to "[37bf59eac24eda1ece89aff7dde4a1db5d0cbb5c](https://github.com/sagemath/sagetrac-mirror/commit/37bf59eac24eda1ece89aff7dde4a1db5d0cbb5c)".



---

archive/issue_comments_181586.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/37bf59e\">37bf59e</a></td><td><code>Merge branch 'develop' into ticket/14711, resolving conflicts with Trac 12217</code></td></tr></table>\n",
    "created_at": "2013-12-21T16:30:43Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181586",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/37bf59e">37bf59e</a></td><td><code>Merge branch 'develop' into ticket/14711, resolving conflicts with Trac 12217</code></td></tr></table>




---

archive/issue_comments_181587.json:
```json
{
    "body": "<a id='comment:163'></a>\nReplying to [mmezzarobba](#comment%3A161):\n> Replying to [SimonKing](#comment%3A160):\n> > All tests pass after merging master. But there is a conflict with #12217 (in the develop branch). I am now testing the merge I just did, and will push the resulting branch in case of success.\n\n> \n> Is your merge different from mine? No need to run the tests if it is identical, I already did.\n\nNo idea if they are identical, and no idea how one could even test whether they *are* identical.\n\nAnyway, I pushed my version of the merge, since all tests in `src/sage/rings/` passed and since the examples from the ticket description of #12217 and the description of this ticket are fixed.",
    "created_at": "2013-12-21T16:43:51Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181587",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:163'></a>
Replying to [mmezzarobba](#comment%3A161):
> Replying to [SimonKing](#comment%3A160):
> > All tests pass after merging master. But there is a conflict with #12217 (in the develop branch). I am now testing the merge I just did, and will push the resulting branch in case of success.

> 
> Is your merge different from mine? No need to run the tests if it is identical, I already did.

No idea if they are identical, and no idea how one could even test whether they *are* identical.

Anyway, I pushed my version of the merge, since all tests in `src/sage/rings/` passed and since the examples from the ticket description of #12217 and the description of this ticket are fixed.



---

archive/issue_comments_181588.json:
```json
{
    "body": "<a id='comment:164'></a>\nReplying to [mmezzarobba](#comment%3A158):\n> It looks like there has already been plenty of discussion about this branch, and stupid merge conflicts with `develop` accumulate while it is waiting for review. Could someone please clarify which parts of the changes still need review?\n\nActually I don't know. Nils?",
    "created_at": "2013-12-28T09:19:23Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181588",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:164'></a>
Replying to [mmezzarobba](#comment%3A158):
> It looks like there has already been plenty of discussion about this branch, and stupid merge conflicts with `develop` accumulate while it is waiting for review. Could someone please clarify which parts of the changes still need review?

Actually I don't know. Nils?



---

archive/issue_comments_181589.json:
```json
{
    "body": "<a id='comment:165'></a>\nReplying to [SimonKing](#comment%3A164):\n> Replying to [mmezzarobba](#comment%3A158):\n> > It looks like there has already been plenty of discussion about this branch, and stupid merge conflicts with `develop` accumulate while it is waiting for review. Could someone please clarify which parts of the changes still need review?\n\n> \n> Actually I don't know. Nils?\n\nI didn't look at code with the purpose of review, but to figure out if our solution was conceptually the right one.\n\nIn the current coercion framework, something along the lines of this patch is necessary to avoid lifetime problems as mentioned in the ticket, so I guess someone can just go ahead and carefully read if the code does what it supposed to do and doesn't add to the confusion the coercion framework is prone to. Ideally, the patch might fix some of the horrible name choices in the coercion framework.\n\nThe end result of our investigations was: The coercion framework is purposely messy. It wasn't clear at the time what model would work well, so the ball was kicked further down the road: The main tool is `_coerce_map_from_` (note the underscores!) which is to be implemented by the author of a parent class and programmatically generates coercion maps. It is responsible for ensuring generating results that are consistent with the fact that path-connectedness is closed under composition.\n\nIn the light of that: The coercion system is not particularly designed to have any lifetime implications. Structures should keep related other structures alive by themselves (base rings etc.). So weakening lifetime implications as happens here should be OK.",
    "created_at": "2013-12-28T20:39:25Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181589",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:165'></a>
Replying to [SimonKing](#comment%3A164):
> Replying to [mmezzarobba](#comment%3A158):
> > It looks like there has already been plenty of discussion about this branch, and stupid merge conflicts with `develop` accumulate while it is waiting for review. Could someone please clarify which parts of the changes still need review?

> 
> Actually I don't know. Nils?

I didn't look at code with the purpose of review, but to figure out if our solution was conceptually the right one.

In the current coercion framework, something along the lines of this patch is necessary to avoid lifetime problems as mentioned in the ticket, so I guess someone can just go ahead and carefully read if the code does what it supposed to do and doesn't add to the confusion the coercion framework is prone to. Ideally, the patch might fix some of the horrible name choices in the coercion framework.

The end result of our investigations was: The coercion framework is purposely messy. It wasn't clear at the time what model would work well, so the ball was kicked further down the road: The main tool is `_coerce_map_from_` (note the underscores!) which is to be implemented by the author of a parent class and programmatically generates coercion maps. It is responsible for ensuring generating results that are consistent with the fact that path-connectedness is closed under composition.

In the light of that: The coercion system is not particularly designed to have any lifetime implications. Structures should keep related other structures alive by themselves (base rings etc.). So weakening lifetime implications as happens here should be OK.



---

archive/issue_comments_181590.json:
```json
{
    "body": "<a id='comment:166'></a>\nReplying to [nbruin](#comment%3A165):\n> In the current coercion framework, something along the lines of this patch is necessary to avoid lifetime problems as mentioned in the ticket, so I guess someone can just go ahead and carefully read if the code does what it supposed to do and doesn't add to the confusion the coercion framework is prone to.\n\nWell, the history of this ticket certainly is confusing, as there has been some back and forth, and a mercurial patch would be a lot nicer.\n\nAnyway, I guess in the end the patch can be summarised as follows:\n\nThe partially conflicting properties of Sage's coercion model are:\n- The coercion model uses a backtracking algorithm, relying on some maps that are explicitly provided during initialisation of the codomain, and it is also possible to provide a (single) embedding during initialisation of the domain. To keep the backtracking algorithm functional, it should not be allowed to garbage-collect these maps, as long as the codomain (resp. the domain of the embedding) is alive.\n- In addition to pure backtracking, the coercion model asks the codomain (via `_coerce_map_from_`) whether it knows a custom shortcut for coercion of the domain into the codomain.\n- For efficiency, the maps discovered by the \"backtracking with shortcuts\" model are cached. However, coerce maps cached in *this* way should not prevent any parent from garbage collection. \n\nThat's to say (@Nils): A coercion model (partially) relying on backtracking *MUST* have lifetime implications for the parents involved, simply to keep the backtracking algorithm functional. But ideally, all caching-for-efficiency and short-cutting done on top of backtracking algorithm should have no *additional* lifetime implications.\n\nCurrently, there are additional lifetime implications, and this ticket aims to remove some of them.\n\nThe approach is to \"weaken\" morphisms that are used in the coercion model.\n- Coerce maps discovered by backtracking-with-shortcuts are stored in a weak key dictionary that is an attribute of the codomain, keyed by the domain. Hence, if there is no chain of strong references to the domain, then the map can be collected. And also, if there is no chain of strong references to the codomain, then the codomain together with the weak key dictionary containing the maps can be collected.\n- The problem is that there could be two chains of strong references to the domain *via* the coerce map: One since the map has a strong reference to the domain, a second since the map has a strong reference to the homset it belongs to, which has a strong reference to the domain. So, the coerce map prevents itself from being collected in two ways.\n- But if the coerce map has only a weak reference to the domain and the homset, then this chains of strong references break, and hence nothing prevents the map from garbage collection, except of course there is a different chain of strong references to the domain.\n\nSo, this ticket introduces a method of maps for \"weakening\" the map: This\nmethod is used when a map is put into the coerce cache, and it replaces the\nstrong reference to domain and homset by weak maps. A strong reference to the\ncodomain is kept, since (1) the map is stored in the codomain, so, a strong\nreference from map to codomain is not more than a cyclic reference, and (2) it\nis a way to keep composite maps alive (composite maps need to keep the \"parent\nin the middle\" alive).\n\nOf course, when a map only has a weak map to the domain, then it is possible\nthat the map becomes defunct: This is when you keep the map, then its domain\nbecomes collected, and afterwards you want to do something with the map. This\npotential problem is addressed as follows:\n\n- If a weakened map stays inside of the coercion model, then it will always be\n  collected, as soon as either domain or codomain are collected: If the domain\n  is collected, then the corresponding item of the weak key dictionary is\n  removed, and if the codomain is collected then the whole dictionary is removed.\n- Hence, we only have a problem if we take a map created by the coercion model\n  and try to use it *outside* of the coercion model. With this ticket, this\n  usage is declared to be a *misuse*. To make the user aware, a weakened map\n  prints a big fat warning.\n- If one wants to use a map outside of the coercion model, one is supposed to\n  use a *copy* of this map.\n\nThe last point is another benefit of this ticket: It is supposed to implement\ncopying (and thus, pickling!!) of all maps in Sage!\n\n> Ideally, the patch might fix some of the horrible name choices in the coercion framework.\n\nThat's not the purpose of this ticket.\n\n\n> The end result of our investigations was: The coercion framework is\n> purposely messy. It wasn't clear at the time what model would work well, so\n> the ball was kicked further down the road: The main tool is\n> `_coerce_map_from_` (note the underscores!) which is to be implemented by the\n> author of a parent class and programmatically generates coercion maps.\n\nThat is only *one* tool. And if I am not mistaken about Sage's history,\n`_coerce_map_from_` was predated by a pure backtracking approach, that has\nturned out to be not flexible enough.\n\n> It is responsible for ensuring generating results that are consistent with the fact that path-connectedness is closed under composition.\n\n... which is dealt with on a *different* ticket. Please don't prevent this\nticket from review just because it only addresses *one* flaw of the current\ncoercion model.\n \n> In the light of that: The coercion system is not particularly designed to\n> have any lifetime implications.\n\nI disagree. If you want something like backtracking (i.e., if you do not want\nthat `_coerce_map_from_` is the only way to implement a coercion), then a\ncoercion model *must* have lifetime implications. But again, this ticket is\nabout removing some lifetime implication that is *not* a consequence of\nbacktracking, and I assume we both *do* agree that this implication should be avoided. Hence, the disagreement on a point that is not in the scope of this ticket should not prevent a review of this ticket.",
    "created_at": "2013-12-29T09:22:33Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181590",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:166'></a>
Replying to [nbruin](#comment%3A165):
> In the current coercion framework, something along the lines of this patch is necessary to avoid lifetime problems as mentioned in the ticket, so I guess someone can just go ahead and carefully read if the code does what it supposed to do and doesn't add to the confusion the coercion framework is prone to.

Well, the history of this ticket certainly is confusing, as there has been some back and forth, and a mercurial patch would be a lot nicer.

Anyway, I guess in the end the patch can be summarised as follows:

The partially conflicting properties of Sage's coercion model are:
- The coercion model uses a backtracking algorithm, relying on some maps that are explicitly provided during initialisation of the codomain, and it is also possible to provide a (single) embedding during initialisation of the domain. To keep the backtracking algorithm functional, it should not be allowed to garbage-collect these maps, as long as the codomain (resp. the domain of the embedding) is alive.
- In addition to pure backtracking, the coercion model asks the codomain (via `_coerce_map_from_`) whether it knows a custom shortcut for coercion of the domain into the codomain.
- For efficiency, the maps discovered by the "backtracking with shortcuts" model are cached. However, coerce maps cached in *this* way should not prevent any parent from garbage collection. 

That's to say (@Nils): A coercion model (partially) relying on backtracking *MUST* have lifetime implications for the parents involved, simply to keep the backtracking algorithm functional. But ideally, all caching-for-efficiency and short-cutting done on top of backtracking algorithm should have no *additional* lifetime implications.

Currently, there are additional lifetime implications, and this ticket aims to remove some of them.

The approach is to "weaken" morphisms that are used in the coercion model.
- Coerce maps discovered by backtracking-with-shortcuts are stored in a weak key dictionary that is an attribute of the codomain, keyed by the domain. Hence, if there is no chain of strong references to the domain, then the map can be collected. And also, if there is no chain of strong references to the codomain, then the codomain together with the weak key dictionary containing the maps can be collected.
- The problem is that there could be two chains of strong references to the domain *via* the coerce map: One since the map has a strong reference to the domain, a second since the map has a strong reference to the homset it belongs to, which has a strong reference to the domain. So, the coerce map prevents itself from being collected in two ways.
- But if the coerce map has only a weak reference to the domain and the homset, then this chains of strong references break, and hence nothing prevents the map from garbage collection, except of course there is a different chain of strong references to the domain.

So, this ticket introduces a method of maps for "weakening" the map: This
method is used when a map is put into the coerce cache, and it replaces the
strong reference to domain and homset by weak maps. A strong reference to the
codomain is kept, since (1) the map is stored in the codomain, so, a strong
reference from map to codomain is not more than a cyclic reference, and (2) it
is a way to keep composite maps alive (composite maps need to keep the "parent
in the middle" alive).

Of course, when a map only has a weak map to the domain, then it is possible
that the map becomes defunct: This is when you keep the map, then its domain
becomes collected, and afterwards you want to do something with the map. This
potential problem is addressed as follows:

- If a weakened map stays inside of the coercion model, then it will always be
  collected, as soon as either domain or codomain are collected: If the domain
  is collected, then the corresponding item of the weak key dictionary is
  removed, and if the codomain is collected then the whole dictionary is removed.
- Hence, we only have a problem if we take a map created by the coercion model
  and try to use it *outside* of the coercion model. With this ticket, this
  usage is declared to be a *misuse*. To make the user aware, a weakened map
  prints a big fat warning.
- If one wants to use a map outside of the coercion model, one is supposed to
  use a *copy* of this map.

The last point is another benefit of this ticket: It is supposed to implement
copying (and thus, pickling!!) of all maps in Sage!

> Ideally, the patch might fix some of the horrible name choices in the coercion framework.

That's not the purpose of this ticket.


> The end result of our investigations was: The coercion framework is
> purposely messy. It wasn't clear at the time what model would work well, so
> the ball was kicked further down the road: The main tool is
> `_coerce_map_from_` (note the underscores!) which is to be implemented by the
> author of a parent class and programmatically generates coercion maps.

That is only *one* tool. And if I am not mistaken about Sage's history,
`_coerce_map_from_` was predated by a pure backtracking approach, that has
turned out to be not flexible enough.

> It is responsible for ensuring generating results that are consistent with the fact that path-connectedness is closed under composition.

... which is dealt with on a *different* ticket. Please don't prevent this
ticket from review just because it only addresses *one* flaw of the current
coercion model.
 
> In the light of that: The coercion system is not particularly designed to
> have any lifetime implications.

I disagree. If you want something like backtracking (i.e., if you do not want
that `_coerce_map_from_` is the only way to implement a coercion), then a
coercion model *must* have lifetime implications. But again, this ticket is
about removing some lifetime implication that is *not* a consequence of
backtracking, and I assume we both *do* agree that this implication should be avoided. Hence, the disagreement on a point that is not in the scope of this ticket should not prevent a review of this ticket.



---

archive/issue_comments_181591.json:
```json
{
    "body": "<a id='comment:167'></a>\nReplying to [SimonKing](#comment%3A166):\n\nFirst of all, indeed someone SHOULD go ahead and review the ticket. I'm just not\ncomfortable with the sage coercion system (even after spending some time trying\nto become familiar with it), so it's not me.\n\n> That's to say (@Nils): A coercion model (partially) relying on backtracking *MUST* have lifetime implications for the parents involved, simply to keep the backtracking algorithm functional. But ideally, all caching-for-efficiency and short-cutting done on top of backtracking algorithm should have no *additional* lifetime implications.\n\nApart from intermediate parents involved in composed maps: I don't think so. If\nyou're working with finitely generated structures then any homomorphism can be\ngiven by images of generators, which in the end could be encoded as lists of\n(lists of) integers. So the defining information of a homomorphism doesn't have\nto hold explicit references to the (co)domain, and furthermore a composition of\nhomomorphisms doesn't have to refer to the homomorphisms it is composed of: one\njust needs to store the images in the final codomain of the generators of the\ninitial domain. The homomorphism can then just store weak references to domain\nand codomain to check that when it's used, the domain and codomain are still\navailable.\n\n> The last point is another benefit of this ticket: It is supposed to implement\n> copying (and thus, pickling!!) of all maps in Sage!\n\nThat's great.\n\n> > Ideally, the patch might fix some of the horrible name choices in the coercion framework.\n\n> That's not the purpose of this ticket.\n\nOK, I thought we had some steps in that direction somewhere; just not here then I guess.\n\n> [`_coerce_map_from_`] is only *one* tool. And if I am not mistaken about Sage's history,\n> `_coerce_map_from_` was predated by a pure backtracking approach, that has\n> turned out to be not flexible enough.\n\nPredated by a model that I think basically needed to be ripped out. If I'm not mistaken about a\nconversation in 2007 with Robert, when he was working on the framework we have now, the idea was that\nMOST parents would solve their coercions via this programmatic tool, because they would probably know\nbest to do it. The lists of maps used for automatic backtracking were supposed to be relatively short.\n\n> > It is responsible for ensuring generating results that are consistent with the fact that path-connectedness is closed under composition.\n\n> \n> ... which is dealt with on a *different* ticket. Please don't prevent this\n> ticket from review just because it only addresses *one* flaw of the current\n> coercion model.\n\n\"It\" being the parent that implements `_coerce_map_from_`, not this ticket. This remark was not meant to\nstate anything about the reviewability of this ticket.",
    "created_at": "2013-12-29T18:13:52Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181591",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:167'></a>
Replying to [SimonKing](#comment%3A166):

First of all, indeed someone SHOULD go ahead and review the ticket. I'm just not
comfortable with the sage coercion system (even after spending some time trying
to become familiar with it), so it's not me.

> That's to say (@Nils): A coercion model (partially) relying on backtracking *MUST* have lifetime implications for the parents involved, simply to keep the backtracking algorithm functional. But ideally, all caching-for-efficiency and short-cutting done on top of backtracking algorithm should have no *additional* lifetime implications.

Apart from intermediate parents involved in composed maps: I don't think so. If
you're working with finitely generated structures then any homomorphism can be
given by images of generators, which in the end could be encoded as lists of
(lists of) integers. So the defining information of a homomorphism doesn't have
to hold explicit references to the (co)domain, and furthermore a composition of
homomorphisms doesn't have to refer to the homomorphisms it is composed of: one
just needs to store the images in the final codomain of the generators of the
initial domain. The homomorphism can then just store weak references to domain
and codomain to check that when it's used, the domain and codomain are still
available.

> The last point is another benefit of this ticket: It is supposed to implement
> copying (and thus, pickling!!) of all maps in Sage!

That's great.

> > Ideally, the patch might fix some of the horrible name choices in the coercion framework.

> That's not the purpose of this ticket.

OK, I thought we had some steps in that direction somewhere; just not here then I guess.

> [`_coerce_map_from_`] is only *one* tool. And if I am not mistaken about Sage's history,
> `_coerce_map_from_` was predated by a pure backtracking approach, that has
> turned out to be not flexible enough.

Predated by a model that I think basically needed to be ripped out. If I'm not mistaken about a
conversation in 2007 with Robert, when he was working on the framework we have now, the idea was that
MOST parents would solve their coercions via this programmatic tool, because they would probably know
best to do it. The lists of maps used for automatic backtracking were supposed to be relatively short.

> > It is responsible for ensuring generating results that are consistent with the fact that path-connectedness is closed under composition.

> 
> ... which is dealt with on a *different* ticket. Please don't prevent this
> ticket from review just because it only addresses *one* flaw of the current
> coercion model.

"It" being the parent that implements `_coerce_map_from_`, not this ticket. This remark was not meant to
state anything about the reviewability of this ticket.



---

archive/issue_comments_181592.json:
```json
{
    "body": "<a id='comment:8'></a>\nI've had a look at the discussion here and the actual changes and am quite happy with them, at least with my current knowledge of the coercion framework.\nI'll push in a few minutes some reviewer changes mostly for formatting issues, a dirty utf8 \u00f6 character and a failing doctest.\nApart from this, there is one piece of code I'm not completely sure to get:\n\n```\n             mor = self.discover_convert_map_from(S)\n-            self._convert_from_list.append(mor)\n+            # Before trac #14711, the morphism has been \n+            # put both into _convert_from_list and into\n+            # _convert_from_hash. But there is no reason\n+            # to have a double book-keeping, specifically\n+            # if one of them is by strong references!\n             self._convert_from_hash.set(S, mor)\n+            # Moreover, again by #14711, the morphism should\n+            # only keep weak references to domain and codomain,\n+            # to allow them being garbage collected.\n+            if mor is not None:\n+                mor._make_weak_references()\n             return mor\n```\n\nFirst, I feel the inlined comments may deserve to be moved into the docstring.\n\nSecond, is the weakening necessary? Isn't the map already \"weak\"? And if not, why weaken it after storing it in the MonoDict? If I get that correctly, in the end, what is stored is weakened anyway as mor is just a pointer to some python object, it is just that doing it after storing a pointer to the object elsewhere feels akward to me.\n(The same thing is done at some other places in the same file.)",
    "created_at": "2013-12-30T13:58:51Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181592",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:8'></a>
I've had a look at the discussion here and the actual changes and am quite happy with them, at least with my current knowledge of the coercion framework.
I'll push in a few minutes some reviewer changes mostly for formatting issues, a dirty utf8 ö character and a failing doctest.
Apart from this, there is one piece of code I'm not completely sure to get:

```
             mor = self.discover_convert_map_from(S)
-            self._convert_from_list.append(mor)
+            # Before trac #14711, the morphism has been 
+            # put both into _convert_from_list and into
+            # _convert_from_hash. But there is no reason
+            # to have a double book-keeping, specifically
+            # if one of them is by strong references!
             self._convert_from_hash.set(S, mor)
+            # Moreover, again by #14711, the morphism should
+            # only keep weak references to domain and codomain,
+            # to allow them being garbage collected.
+            if mor is not None:
+                mor._make_weak_references()
             return mor
```

First, I feel the inlined comments may deserve to be moved into the docstring.

Second, is the weakening necessary? Isn't the map already "weak"? And if not, why weaken it after storing it in the MonoDict? If I get that correctly, in the end, what is stored is weakened anyway as mor is just a pointer to some python object, it is just that doing it after storing a pointer to the object elsewhere feels akward to me.
(The same thing is done at some other places in the same file.)



---

archive/issue_comments_181593.json:
```json
{
    "body": "<a id='comment:9'></a>\nA few other remarks:\n* has the Cython bug been reported upstream?\n* I think the first todo -- add a lot of doc -- is really critical :)\n* to correct the warning in combinat/ncsym/dual.py I filtered the warning stemming from the use of a weakened map with \"...\", as is done in combinat/sf/new_kschur.py (see commit 364b9856b) as from what I understood the combinat code tries to send something from one basis to another and to do so relies on the coercion framework so end up with a weakened map. Note that I don't feel it's really a satisfying long term solution; the combinat people surely won't like the output being polluted with warnings (which are not that helpful in these cases). But I don't want to dive into the combinat code to make a copy of the needed map at the right place now.\n \n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0af59ea\">0af59ea</a></td><td><code>Reviewer changes. Mostly formatting.</code></td></tr></table>\n",
    "created_at": "2013-12-30T15:03:06Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181593",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:9'></a>
A few other remarks:
* has the Cython bug been reported upstream?
* I think the first todo -- add a lot of doc -- is really critical :)
* to correct the warning in combinat/ncsym/dual.py I filtered the warning stemming from the use of a weakened map with "...", as is done in combinat/sf/new_kschur.py (see commit 364b9856b) as from what I understood the combinat code tries to send something from one basis to another and to do so relies on the coercion framework so end up with a weakened map. Note that I don't feel it's really a satisfying long term solution; the combinat people surely won't like the output being polluted with warnings (which are not that helpful in these cases). But I don't want to dive into the combinat code to make a copy of the needed map at the right place now.
 
---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0af59ea">0af59ea</a></td><td><code>Reviewer changes. Mostly formatting.</code></td></tr></table>




---

archive/issue_comments_181594.json:
```json
{
    "body": "**Reviewer:** Jean-Pierre Flori",
    "created_at": "2013-12-30T15:03:06Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181594",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

**Reviewer:** Jean-Pierre Flori



---

archive/issue_comments_181595.json:
```json
{
    "body": "**Changing branch** from \"[u/SimonKing/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/14711)\" to \"[u/jpflori/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/u/jpflori/ticket/14711)\".",
    "created_at": "2013-12-30T15:03:06Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181595",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

**Changing branch** from "[u/SimonKing/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/ticket/14711)" to "[u/jpflori/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/u/jpflori/ticket/14711)".



---

archive/issue_comments_181596.json:
```json
{
    "body": "**Changing commit** from \"[37bf59eac24eda1ece89aff7dde4a1db5d0cbb5c](https://github.com/sagemath/sagetrac-mirror/commit/37bf59eac24eda1ece89aff7dde4a1db5d0cbb5c)\" to \"[0af59ea93689cb6abb9d3fae0f1cf11f2aee5cca](https://github.com/sagemath/sagetrac-mirror/commit/0af59ea93689cb6abb9d3fae0f1cf11f2aee5cca)\".",
    "created_at": "2013-12-30T15:03:06Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181596",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

**Changing commit** from "[37bf59eac24eda1ece89aff7dde4a1db5d0cbb5c](https://github.com/sagemath/sagetrac-mirror/commit/37bf59eac24eda1ece89aff7dde4a1db5d0cbb5c)" to "[0af59ea93689cb6abb9d3fae0f1cf11f2aee5cca](https://github.com/sagemath/sagetrac-mirror/commit/0af59ea93689cb6abb9d3fae0f1cf11f2aee5cca)".



---

archive/issue_comments_181597.json:
```json
{
    "body": "<a id='comment:0'></a>\nFYI, this passes all tests when merged against 6.1.beta2.",
    "created_at": "2013-12-30T15:45:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181597",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:0'></a>
FYI, this passes all tests when merged against 6.1.beta2.



---

archive/issue_comments_181598.json:
```json
{
    "body": "<a id='comment:1'></a>\nMy 2 cents. I don't think that `coerce_map_from()` should return the map which is used in the coercion system, but a copy of it. I believe this would be a better system since it's easily accessible to a user, so the user could mess with the map and the coercion system, and the result is used in error messages where the \"copy\" warning message has no purpose (for example the doctest in `ncsym/dual.py`). Subsequently I believe we should have a hidden function which returns the actual map, for those cases when one needs it.\n\nAlso couldn't we use (some form of) #8878 get around some of the backtracking issues?",
    "created_at": "2013-12-30T17:06:21Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181598",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:1'></a>
My 2 cents. I don't think that `coerce_map_from()` should return the map which is used in the coercion system, but a copy of it. I believe this would be a better system since it's easily accessible to a user, so the user could mess with the map and the coercion system, and the result is used in error messages where the "copy" warning message has no purpose (for example the doctest in `ncsym/dual.py`). Subsequently I believe we should have a hidden function which returns the actual map, for those cases when one needs it.

Also couldn't we use (some form of) #8878 get around some of the backtracking issues?



---

archive/issue_comments_181599.json:
```json
{
    "body": "<a id='comment:172'></a>\nReplying to [tscrim](#comment%3A171):\n> My 2 cents. I don't think that `coerce_map_from()` should return the map which is used in the coercion system, but a copy of it.\n\nPresently, that routine gets used internally as well. The internal routine should of course NOT copy the map, so changing that would imply renaming the present routine to an underscore method and writing a new wrapper that does the copying ... and changing the internal code to use the new underscore method.\n\n> Also couldn't we use (some form of) #8878 get around some of the backtracking issues?\n\nThis is outside the scope of this ticket. We would need to seriously recalibrate the \"coercion costs\" to ensure that the \"shortest path\" would indeed be a reasonable thing. Furthermore, a large part of the graph is encoded programmatically, so not fully accessible for a backtracking search. We could of course just trust the programmatic bits to yield \"shortest\" paths, but those routines tend to do depth-first searches themselves",
    "created_at": "2013-12-30T22:14:15Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181599",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:172'></a>
Replying to [tscrim](#comment%3A171):
> My 2 cents. I don't think that `coerce_map_from()` should return the map which is used in the coercion system, but a copy of it.

Presently, that routine gets used internally as well. The internal routine should of course NOT copy the map, so changing that would imply renaming the present routine to an underscore method and writing a new wrapper that does the copying ... and changing the internal code to use the new underscore method.

> Also couldn't we use (some form of) #8878 get around some of the backtracking issues?

This is outside the scope of this ticket. We would need to seriously recalibrate the "coercion costs" to ensure that the "shortest path" would indeed be a reasonable thing. Furthermore, a large part of the graph is encoded programmatically, so not fully accessible for a backtracking search. We could of course just trust the programmatic bits to yield "shortest" paths, but those routines tend to do depth-first searches themselves



---

archive/issue_comments_181600.json:
```json
{
    "body": "<a id='comment:173'></a>\nReplying to [jpflori](#comment%3A169):\n> A few other remarks:\n> * has the Cython bug been reported upstream?\n\nYes, but I don't have a reference. Anyway, it was reported to cython-users mailing list, and some time ago on sage-devel Robert Bradshaw did recall that I had reported it.\n\n> * I think the first todo -- add a lot of doc -- is really critical :)\n\nWhat todo list are you referring to?",
    "created_at": "2013-12-30T22:57:34Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181600",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:173'></a>
Replying to [jpflori](#comment%3A169):
> A few other remarks:
> * has the Cython bug been reported upstream?

Yes, but I don't have a reference. Anyway, it was reported to cython-users mailing list, and some time ago on sage-devel Robert Bradshaw did recall that I had reported it.

> * I think the first todo -- add a lot of doc -- is really critical :)

What todo list are you referring to?



---

archive/issue_comments_181601.json:
```json
{
    "body": "<a id='comment:174'></a>\nReplying to [nbruin](#comment%3A172):\n> Replying to [tscrim](#comment%3A171):\n> > My 2 cents. I don't think that `coerce_map_from()` should return the map which is used in the coercion system, but a copy of it.\n\nI somehow agree, but:\n\n> Presently, that routine gets used internally as well. The internal routine should of course NOT copy the map, so changing that would imply renaming the present routine to an underscore method and writing a new wrapper that does the copying ... and changing the internal code to use the new underscore method.\n\nWould this really be so difficult?\n\n> > Also couldn't we use (some form of) #8878 get around some of the backtracking issues?\n\n> \n> This is outside the scope of this ticket.\n\nYes, but it is an interesting idea. Given the difficulties in #15303, it would actually be worth while to go beyond and create an actual digraph for dealing both with the search for coerce maps (and given an actual graph, it might be easier to instrument graph algorithms) and strong/weak references, caching of maps and so on.",
    "created_at": "2013-12-30T23:23:59Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181601",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:174'></a>
Replying to [nbruin](#comment%3A172):
> Replying to [tscrim](#comment%3A171):
> > My 2 cents. I don't think that `coerce_map_from()` should return the map which is used in the coercion system, but a copy of it.

I somehow agree, but:

> Presently, that routine gets used internally as well. The internal routine should of course NOT copy the map, so changing that would imply renaming the present routine to an underscore method and writing a new wrapper that does the copying ... and changing the internal code to use the new underscore method.

Would this really be so difficult?

> > Also couldn't we use (some form of) #8878 get around some of the backtracking issues?

> 
> This is outside the scope of this ticket.

Yes, but it is an interesting idea. Given the difficulties in #15303, it would actually be worth while to go beyond and create an actual digraph for dealing both with the search for coerce maps (and given an actual graph, it might be easier to instrument graph algorithms) and strong/weak references, caching of maps and so on.



---

archive/issue_comments_181602.json:
```json
{
    "body": "<a id='comment:5'></a>\nPS: The review commit looks ok to me. I only wonder: Should a doc string ending with a test also end with a blank line? I thought that the usual thing to do in Sage (but not official standard) is this\n\n```python\ndef f1(...):\n    \"\"\"\n    This is some doc\n\n    EXAMPLES::\n\n        sage: ...\n        ...\n\n    The doc ends with normal text and hence without blank line\n    \"\"\"\n    return None\n```\nbut\n\n```python\ndef f2(...):\n    \"\"\"\n    Some doc\n\n    EXAMPLES::\n\n        sage: ...\n\n    There is a concluding example, and after the example is\n    a blank line::\n\n        sage: ...\n        ,,,\n\n    \"\"\"\n    return None\n```\nSo, I wonder if it is needed that the review commit removes trailing blank lines. On the other hand, I don't mind if they'll be removed.",
    "created_at": "2013-12-30T23:32:40Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181602",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
PS: The review commit looks ok to me. I only wonder: Should a doc string ending with a test also end with a blank line? I thought that the usual thing to do in Sage (but not official standard) is this

```python
def f1(...):
    """
    This is some doc

    EXAMPLES::

        sage: ...
        ...

    The doc ends with normal text and hence without blank line
    """
    return None
```
but

```python
def f2(...):
    """
    Some doc

    EXAMPLES::

        sage: ...

    There is a concluding example, and after the example is
    a blank line::

        sage: ...
        ,,,

    """
    return None
```
So, I wonder if it is needed that the review commit removes trailing blank lines. On the other hand, I don't mind if they'll be removed.



---

archive/issue_comments_181603.json:
```json
{
    "body": "<a id='comment:6'></a>\nSorry about the blank lines, I think I've been overzealous and played too much with vim.\nI personally prefer not leaving superfluous blank lines and didn't get the impression it was an informal convention but I don't really care what ends up in the final branch.\n\nI was thinking about the todo in the ticket description:\n- Provide a documentation of the use of weak references in coercion, and of\n  different ways of registering coercions, with their different impacts on\n  garbage collecion.\n\nAt the moment, I feel like the ticket could be merged.\nThere's Travis issue with perfectly make sense, but how harmful would it be to leave that for another ticket?\nWould it really involve more work and rebasing than doing it here?\n\nNils idea would do the trick and doesn't look that hard at first but I feel it won't be that easy to ensure that each current incarnations of coerce_map_from have been correctly left as is when outside of the coercion framework but had an underscore added within the coercion framework (or we'll jsut end up with random memleaks again :().",
    "created_at": "2013-12-31T09:38:51Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181603",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:6'></a>
Sorry about the blank lines, I think I've been overzealous and played too much with vim.
I personally prefer not leaving superfluous blank lines and didn't get the impression it was an informal convention but I don't really care what ends up in the final branch.

I was thinking about the todo in the ticket description:
- Provide a documentation of the use of weak references in coercion, and of
  different ways of registering coercions, with their different impacts on
  garbage collecion.

At the moment, I feel like the ticket could be merged.
There's Travis issue with perfectly make sense, but how harmful would it be to leave that for another ticket?
Would it really involve more work and rebasing than doing it here?

Nils idea would do the trick and doesn't look that hard at first but I feel it won't be that easy to ensure that each current incarnations of coerce_map_from have been correctly left as is when outside of the coercion framework but had an underscore added within the coercion framework (or we'll jsut end up with random memleaks again :().



---

archive/issue_comments_181604.json:
```json
{
    "body": "<a id='comment:177'></a>\nReplying to [SimonKing](#comment%3A174):\n> Replying to [nbruin](#comment%3A172):\n> > Presently, that routine gets used internally as well. The internal routine should of course NOT copy the map, so changing that would imply renaming the present routine to an underscore method and writing a new wrapper that does the copying ... and changing the internal code to use the new underscore method.\n\n> \n> Would this really be so difficult?\n\nIsn't all of the coercion model consolidated in `coerce.pyx` and `parent.pyx`? I can make a more detailed look and work on this tomorrow.\n\n> > > Also couldn't we use (some form of) #8878 get around some of the backtracking issues?\n\n> > \n> > This is outside the scope of this ticket.\n\n> \n> Yes, but it is an interesting idea. Given the difficulties in #15303, it would actually be worth while to go beyond and create an actual digraph for dealing both with the search for coerce maps (and given an actual graph, it might be easier to instrument graph algorithms) and strong/weak references, caching of maps and so on.\n\nI was thinking it was outside of the scope of this ticket, but wasn't sure from the discussion if something like that was needed as a dependency. Although that's basically what we have currently (if I'm reading the code right). To do more of the graph algorithms, it might be worthwhile to also store the data in other formats (ex. a map of parents to an array of their \"neighbors\") depending on what is useful.",
    "created_at": "2013-12-31T16:43:17Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181604",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:177'></a>
Replying to [SimonKing](#comment%3A174):
> Replying to [nbruin](#comment%3A172):
> > Presently, that routine gets used internally as well. The internal routine should of course NOT copy the map, so changing that would imply renaming the present routine to an underscore method and writing a new wrapper that does the copying ... and changing the internal code to use the new underscore method.

> 
> Would this really be so difficult?

Isn't all of the coercion model consolidated in `coerce.pyx` and `parent.pyx`? I can make a more detailed look and work on this tomorrow.

> > > Also couldn't we use (some form of) #8878 get around some of the backtracking issues?

> > 
> > This is outside the scope of this ticket.

> 
> Yes, but it is an interesting idea. Given the difficulties in #15303, it would actually be worth while to go beyond and create an actual digraph for dealing both with the search for coerce maps (and given an actual graph, it might be easier to instrument graph algorithms) and strong/weak references, caching of maps and so on.

I was thinking it was outside of the scope of this ticket, but wasn't sure from the discussion if something like that was needed as a dependency. Although that's basically what we have currently (if I'm reading the code right). To do more of the graph algorithms, it might be worthwhile to also store the data in other formats (ex. a map of parents to an array of their "neighbors") depending on what is useful.



---

archive/issue_comments_181605.json:
```json
{
    "body": "<a id='comment:178'></a>\nReplying to [tscrim](#comment%3A177):\n> > Would this really be so difficult?\n\nI don't think it would be particularly difficult\n\n> I was thinking it was outside of the scope of this ticket, but wasn't sure from the discussion if something like that was needed as a dependency. Although that's basically what we have currently (if I'm reading the code right). To do more of the graph algorithms, it might be worthwhile to also store the data in other formats (ex. a map of parents to an array of their \"neighbors\") depending on what is useful.\n\nSimon's tutorial example for how to write parents is a very good illustration of the problem: Localizations of Z at a finite set of primes S. A parent may have so many coercions into it that it's inefficient, impractical, or impossible to list them all (the localization at any subset T would coerce naturally). The one (almost superfluous) thing his example is forgetting is to test if the asked ring coerces into ZZ and via that into the localization (i.e. the depth-first search). This example convinced me that the hybrid we have now, ugly, confusing and complicated as it may be, might actually be the best we can do. With things like Qbar, SR, ComplexField etc., I don't think it's possible to separate the programmatic and the recursible parts.",
    "created_at": "2013-12-31T17:55:36Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181605",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:178'></a>
Replying to [tscrim](#comment%3A177):
> > Would this really be so difficult?

I don't think it would be particularly difficult

> I was thinking it was outside of the scope of this ticket, but wasn't sure from the discussion if something like that was needed as a dependency. Although that's basically what we have currently (if I'm reading the code right). To do more of the graph algorithms, it might be worthwhile to also store the data in other formats (ex. a map of parents to an array of their "neighbors") depending on what is useful.

Simon's tutorial example for how to write parents is a very good illustration of the problem: Localizations of Z at a finite set of primes S. A parent may have so many coercions into it that it's inefficient, impractical, or impossible to list them all (the localization at any subset T would coerce naturally). The one (almost superfluous) thing his example is forgetting is to test if the asked ring coerces into ZZ and via that into the localization (i.e. the depth-first search). This example convinced me that the hybrid we have now, ugly, confusing and complicated as it may be, might actually be the best we can do. With things like Qbar, SR, ComplexField etc., I don't think it's possible to separate the programmatic and the recursible parts.



---

archive/issue_comments_181606.json:
```json
{
    "body": "<a id='comment:179'></a>\nReplying to [tscrim](#comment%3A177):\n> > Yes, but it is an interesting idea. Given the difficulties in #15303, it would actually be worth while to go beyond and create an actual digraph for dealing both with the search for coerce maps (and given an actual graph, it might be easier to instrument graph algorithms) and strong/weak references, caching of maps and so on.\n\n> \n> I was thinking it was outside of the scope of this ticket, but wasn't sure from the discussion if something like that was needed as a dependency.\n\nNo, it is more the other way around: Here, we lay the ground for building a coercion framework without undue lifetime implications. At least this is my viewpoint on this ticket.",
    "created_at": "2013-12-31T19:17:32Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181606",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:179'></a>
Replying to [tscrim](#comment%3A177):
> > Yes, but it is an interesting idea. Given the difficulties in #15303, it would actually be worth while to go beyond and create an actual digraph for dealing both with the search for coerce maps (and given an actual graph, it might be easier to instrument graph algorithms) and strong/weak references, caching of maps and so on.

> 
> I was thinking it was outside of the scope of this ticket, but wasn't sure from the discussion if something like that was needed as a dependency.

No, it is more the other way around: Here, we lay the ground for building a coercion framework without undue lifetime implications. At least this is my viewpoint on this ticket.



---

archive/issue_comments_181607.json:
```json
{
    "body": "<a id='comment:0'></a>\nOkay, I've done the initial stuff and called the new method `_internal_coerce_map_from()`. I've pushed it into the branch\n\n```\npublic/ticket/14711-internal_test\n```\nHowever I get the following doctest failing in `parent.pyx`:\n\n```\nThe following was fixed in :trac:`4740`::\n\n    sage: F = GF(13)\n    sage: F.coerce_map_from(F) is F.coerce_map_from(F)\n    True\n```\nIt's returning `False` which I think is okay, but I'd need someone more experienced in the finite fields code to verify that it's okay...well it might just need to be changed to the new internal method (see below).\n\nI'm also getting a strange `<BLANKLINE>` in a doctest in `coerce.pyx`, which is causing a doctest failure. My guess is it's somehow coming from the warning message... Anyways, I'm running all doctests now.\n\nNow here's the list of files in the new branch which use `coerce_map_from`:\n\n```\ncategories/pushout.py\ncombinat/sf/new_kschur.py\ncombinat/root_system/weight_lattice_realizations.py\ngeometry/polyhedron/parent.py\nrings/real_mpfr.pyx\nrings/real_double.pyx\nrings/finite_rings/finite_field_base.pyx\nrings/finite_rings/integer_mod_ring.py\nrings/finite_rings/finite_field_prime_modn.py\nrings/number_field/number_field.py\nrings/number_field/number_field_rel.py\nrings/polynomial/polynomial_modn_dense_ntl.pyx\nrings/polynomial/polynomial_ring.py\nrings/polynomial/laurent_polynomial_ring.py\nrings/complex_field.py\nrings/complex_double.pyx\nrings/rational_field.py\nrings/residue_field.pyx\n```\nI've also started doing some of the swaps to the internal maps in:\n\n```\nsrc/sage/categories/homset.py\nsrc/sage/categories/map.pyx\nsrc/sage/combinat/free_module.py\nsrc/sage/structure/parent_old.pyx\nschemes/projective/projective_point.py\nschemes/projective/projective_morphism.py\nschemes/generic/morphism.py\nstructure/formal_sum.py\n```\nI'd like to know if we're okay just swapping the old `coerce_map_from()` to the `_internal_coerce_map_from()`? I think we'd want to do this anytime the user will not have access to the maps, and I think they are safe to do so, but could someone else double-check this for me? Thanks.",
    "created_at": "2014-01-02T05:28:23Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181607",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:0'></a>
Okay, I've done the initial stuff and called the new method `_internal_coerce_map_from()`. I've pushed it into the branch

```
public/ticket/14711-internal_test
```
However I get the following doctest failing in `parent.pyx`:

```
The following was fixed in :trac:`4740`::

    sage: F = GF(13)
    sage: F.coerce_map_from(F) is F.coerce_map_from(F)
    True
```
It's returning `False` which I think is okay, but I'd need someone more experienced in the finite fields code to verify that it's okay...well it might just need to be changed to the new internal method (see below).

I'm also getting a strange `<BLANKLINE>` in a doctest in `coerce.pyx`, which is causing a doctest failure. My guess is it's somehow coming from the warning message... Anyways, I'm running all doctests now.

Now here's the list of files in the new branch which use `coerce_map_from`:

```
categories/pushout.py
combinat/sf/new_kschur.py
combinat/root_system/weight_lattice_realizations.py
geometry/polyhedron/parent.py
rings/real_mpfr.pyx
rings/real_double.pyx
rings/finite_rings/finite_field_base.pyx
rings/finite_rings/integer_mod_ring.py
rings/finite_rings/finite_field_prime_modn.py
rings/number_field/number_field.py
rings/number_field/number_field_rel.py
rings/polynomial/polynomial_modn_dense_ntl.pyx
rings/polynomial/polynomial_ring.py
rings/polynomial/laurent_polynomial_ring.py
rings/complex_field.py
rings/complex_double.pyx
rings/rational_field.py
rings/residue_field.pyx
```
I've also started doing some of the swaps to the internal maps in:

```
src/sage/categories/homset.py
src/sage/categories/map.pyx
src/sage/combinat/free_module.py
src/sage/structure/parent_old.pyx
schemes/projective/projective_point.py
schemes/projective/projective_morphism.py
schemes/generic/morphism.py
structure/formal_sum.py
```
I'd like to know if we're okay just swapping the old `coerce_map_from()` to the `_internal_coerce_map_from()`? I think we'd want to do this anytime the user will not have access to the maps, and I think they are safe to do so, but could someone else double-check this for me? Thanks.



---

archive/issue_comments_181608.json:
```json
{
    "body": "<a id='comment:181'></a>\nReplying to [tscrim](#comment%3A180):\n> However I get the following doctest failing in `parent.pyx`:\n> \n> ```\n> The following was fixed in :trac:`4740`::\n> \n>     sage: F = GF(13)\n>     sage: F.coerce_map_from(F) is F.coerce_map_from(F)\n>     True\n> ```\n> It's returning `False` which I think is okay, but I'd need someone more experienced in the finite fields code to verify that it's okay...\n\nI suppose what we want to test here is in fact that *internally* coerce maps are cached, and thus identical objects are used when one *internally* asks for the coerce maps.\n\nHence, I think one should test `F._internal_coerce_map_from(F) is F._internal_coerce_map_from(F)`, adding a comment that this is just a test and `_internal_coerce_map_from()` is, well, internal.\n\n> I'm also getting a strange `<BLANKLINE>` in a doctest in `coerce.pyx`, which is causing a doctest failure. My guess is it's somehow coming from the warning message...\n\nHmmm. This needs to be fixed.\n\n> I'd like to know if we're okay just swapping the old `coerce_map_from()` to the \n> `_internal_coerce_map_from()`? I think we'd want to do this anytime the user will not have access \n> to the maps, and I think they are safe to do so, but could someone else double-check this for me? \n\nI think it is almost exactly what we want.\n\nPerhaps with a little refinement:\n- In doctests, we should use `coerce_map_from()`, since we want to see proper maps there, except for educational purposes such as the test mentioned above.\n- In code, we will mostly want `_internal_coerce_map_from()`.\n- Exception: If we have a \"public\" (non-underscore) method that returns a coerce map, then it should internally either explicitly create a copy or use `coerce_map_from()`. We may think of turning some of these methods into cached methods: If they are frequently called, copying the map each time is bad.",
    "created_at": "2014-01-02T10:08:11Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181608",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:181'></a>
Replying to [tscrim](#comment%3A180):
> However I get the following doctest failing in `parent.pyx`:
> 
> ```
> The following was fixed in :trac:`4740`::
> 
>     sage: F = GF(13)
>     sage: F.coerce_map_from(F) is F.coerce_map_from(F)
>     True
> ```
> It's returning `False` which I think is okay, but I'd need someone more experienced in the finite fields code to verify that it's okay...

I suppose what we want to test here is in fact that *internally* coerce maps are cached, and thus identical objects are used when one *internally* asks for the coerce maps.

Hence, I think one should test `F._internal_coerce_map_from(F) is F._internal_coerce_map_from(F)`, adding a comment that this is just a test and `_internal_coerce_map_from()` is, well, internal.

> I'm also getting a strange `<BLANKLINE>` in a doctest in `coerce.pyx`, which is causing a doctest failure. My guess is it's somehow coming from the warning message...

Hmmm. This needs to be fixed.

> I'd like to know if we're okay just swapping the old `coerce_map_from()` to the 
> `_internal_coerce_map_from()`? I think we'd want to do this anytime the user will not have access 
> to the maps, and I think they are safe to do so, but could someone else double-check this for me? 

I think it is almost exactly what we want.

Perhaps with a little refinement:
- In doctests, we should use `coerce_map_from()`, since we want to see proper maps there, except for educational purposes such as the test mentioned above.
- In code, we will mostly want `_internal_coerce_map_from()`.
- Exception: If we have a "public" (non-underscore) method that returns a coerce map, then it should internally either explicitly create a copy or use `coerce_map_from()`. We may think of turning some of these methods into cached methods: If they are frequently called, copying the map each time is bad.



---

archive/issue_comments_181609.json:
```json
{
    "body": "<a id='comment:182'></a>\nReplying to [SimonKing](#comment%3A181):\n> I suppose what we want to test here is in fact that *internally* coerce maps are cached, and thus identical objects are used when one *internally* asks for the coerce maps.\n> \n> Hence, I think one should test `F._internal_coerce_map_from(F) is F._internal_coerce_map_from(F)`, adding a comment that this is just a test and `_internal_coerce_map_from()` is, well, internal.\n\nChanged.\n\n> > I'm also getting a strange `<BLANKLINE>` in a doctest in `coerce.pyx`, which is causing a doctest failure. My guess is it's somehow coming from the warning message...\n\n> \n> Hmmm. This needs to be fixed.\n\nI still don't know where this is coming from.\n\n> I think it is almost exactly what we want.\n> \n> Perhaps with a little refinement:\n> ...\n\nThat was exactly what I was thinking. Done and I've pushed the changes to the branch `public/ticket/14711-internal_test`.\n\nHowever I am getting segfaults in running the tests in `complex_number.pyx`, `number_field.py`, and others, and I don't know what's causing it. (I've also merged in `develop`.)\n\nI also don't quite understand why we need to copy the maps given in `geometry/polyhedron/parent.py` since it is being used in an internal `_get_action_()`?",
    "created_at": "2014-01-02T21:15:01Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181609",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:182'></a>
Replying to [SimonKing](#comment%3A181):
> I suppose what we want to test here is in fact that *internally* coerce maps are cached, and thus identical objects are used when one *internally* asks for the coerce maps.
> 
> Hence, I think one should test `F._internal_coerce_map_from(F) is F._internal_coerce_map_from(F)`, adding a comment that this is just a test and `_internal_coerce_map_from()` is, well, internal.

Changed.

> > I'm also getting a strange `<BLANKLINE>` in a doctest in `coerce.pyx`, which is causing a doctest failure. My guess is it's somehow coming from the warning message...

> 
> Hmmm. This needs to be fixed.

I still don't know where this is coming from.

> I think it is almost exactly what we want.
> 
> Perhaps with a little refinement:
> ...

That was exactly what I was thinking. Done and I've pushed the changes to the branch `public/ticket/14711-internal_test`.

However I am getting segfaults in running the tests in `complex_number.pyx`, `number_field.py`, and others, and I don't know what's causing it. (I've also merged in `develop`.)

I also don't quite understand why we need to copy the maps given in `geometry/polyhedron/parent.py` since it is being used in an internal `_get_action_()`?



---

archive/issue_comments_181610.json:
```json
{
    "body": "<a id='comment:3'></a>\nPlease also remove the \"...\" which were added previously to filter the warnings.\nI think of at least two of them in the combinat dir, maybe Simon remember more of them.",
    "created_at": "2014-01-02T21:28:33Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181610",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:3'></a>
Please also remove the "..." which were added previously to filter the warnings.
I think of at least two of them in the combinat dir, maybe Simon remember more of them.



---

archive/issue_comments_181611.json:
```json
{
    "body": "<a id='comment:184'></a>\nReplying to [jpflori](#comment%3A183):\n> Please also remove the \"...\" which were added previously to filter the warnings.\n> I think of at least two of them in the combinat dir, maybe Simon remember more of them.\n\nI got the ones in combinat, and I didn't come across any others (but I may have looked poorly).\n\nAlso, I hope I wasn't overzealous in removing some of the `copy()`'s and changing to the internal coerce map. We might also need to do something for the conversion maps as well... But first, I will need some help in figuring out the segfaults I'm getting.",
    "created_at": "2014-01-03T01:10:55Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181611",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:184'></a>
Replying to [jpflori](#comment%3A183):
> Please also remove the "..." which were added previously to filter the warnings.
> I think of at least two of them in the combinat dir, maybe Simon remember more of them.

I got the ones in combinat, and I didn't come across any others (but I may have looked poorly).

Also, I hope I wasn't overzealous in removing some of the `copy()`'s and changing to the internal coerce map. We might also need to do something for the conversion maps as well... But first, I will need some help in figuring out the segfaults I'm getting.



---

archive/issue_comments_181612.json:
```json
{
    "body": "<a id='comment:185'></a>\nReplying to [SimonKing](#comment%3A181):\n> We may think of turning some of these methods into cached methods: If they are frequently called, copying the map each time is bad.\n\nNO!! That very cache will then reintroduce the strong references we're trying to weaken!",
    "created_at": "2014-01-03T04:18:19Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181612",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:185'></a>
Replying to [SimonKing](#comment%3A181):
> We may think of turning some of these methods into cached methods: If they are frequently called, copying the map each time is bad.

NO!! That very cache will then reintroduce the strong references we're trying to weaken!



---

archive/issue_events_128603.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "milestone": "sage-6.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128603"
}
```



---

archive/issue_events_128604.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128604"
}
```



---

archive/issue_comments_181613.json:
```json
{
    "body": "**Changing commit** from \"[0af59ea93689cb6abb9d3fae0f1cf11f2aee5cca](https://github.com/sagemath/sagetrac-mirror/commit/0af59ea93689cb6abb9d3fae0f1cf11f2aee5cca)\" to \"[6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2](https://github.com/sagemath/sagetrac-mirror/commit/6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2)\".",
    "created_at": "2014-02-25T09:21:00Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181613",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[0af59ea93689cb6abb9d3fae0f1cf11f2aee5cca](https://github.com/sagemath/sagetrac-mirror/commit/0af59ea93689cb6abb9d3fae0f1cf11f2aee5cca)" to "[6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2](https://github.com/sagemath/sagetrac-mirror/commit/6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2)".



---

archive/issue_comments_181614.json:
```json
{
    "body": "<a id='comment:7'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6110bb984403114b2ddb8410868472d1cfdc64df\">6110bb9</a></td><td><code>Now using _internal_coerce_map_from.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6f22299a9a9353e445a67e6493b8686257880701\">6f22299</a></td><td><code>Initial attempt at _internal_coerce_map_from_() method.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/3b6ac3098a96579ebb12b9dd4403d335d57a6924\">3b6ac30</a></td><td><code>Started transition.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/147b4f56b1e92df1c3b62068e80ca9698bd80186\">147b4f5</a></td><td><code>Removed unneeded copying of maps.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8c1ef83b2680ac5cc1606ba9548fdc3a4c24042d\">8c1ef83</a></td><td><code>Merge branch 'develop' into public/ticket/14711</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/21aa9bc76e18893e5c26c633e0e17e44a5656402\">21aa9bc</a></td><td><code>Removed some more copy and some other formatting changes.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2\">6b233b5</a></td><td><code>Merge remote-tracking branch 'trac/develop' into ticket/14711</code></td></tr></table>\n",
    "created_at": "2014-02-25T09:21:00Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181614",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:7'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6110bb984403114b2ddb8410868472d1cfdc64df">6110bb9</a></td><td><code>Now using _internal_coerce_map_from.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6f22299a9a9353e445a67e6493b8686257880701">6f22299</a></td><td><code>Initial attempt at _internal_coerce_map_from_() method.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/3b6ac3098a96579ebb12b9dd4403d335d57a6924">3b6ac30</a></td><td><code>Started transition.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/147b4f56b1e92df1c3b62068e80ca9698bd80186">147b4f5</a></td><td><code>Removed unneeded copying of maps.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8c1ef83b2680ac5cc1606ba9548fdc3a4c24042d">8c1ef83</a></td><td><code>Merge branch 'develop' into public/ticket/14711</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/21aa9bc76e18893e5c26c633e0e17e44a5656402">21aa9bc</a></td><td><code>Removed some more copy and some other formatting changes.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2">6b233b5</a></td><td><code>Merge remote-tracking branch 'trac/develop' into ticket/14711</code></td></tr></table>




---

archive/issue_comments_181615.json:
```json
{
    "body": "<a id='comment:8'></a>\nFirst step toward rebasing.\nLots of work still needed, especially for p-adic stuff (at the very least).",
    "created_at": "2014-02-25T09:21:51Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181615",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:8'></a>
First step toward rebasing.
Lots of work still needed, especially for p-adic stuff (at the very least).



---

archive/issue_comments_181616.json:
```json
{
    "body": "**Changing commit** from \"[6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2](https://github.com/sagemath/sagetrac-mirror/commit/6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2)\" to \"[7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3](https://github.com/sagemath/sagetrac-mirror/commit/7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3)\".",
    "created_at": "2014-02-25T11:07:45Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181616",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2](https://github.com/sagemath/sagetrac-mirror/commit/6b233b52b8932cbe3a3f6ff9dabb0e5b5615b7e2)" to "[7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3](https://github.com/sagemath/sagetrac-mirror/commit/7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3)".



---

archive/issue_comments_181617.json:
```json
{
    "body": "<a id='comment:9'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3\">7d7f7ae</a></td><td><code>Fixes for p-adic coercions.</code></td></tr></table>\n",
    "created_at": "2014-02-25T11:07:45Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181617",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3">7d7f7ae</a></td><td><code>Fixes for p-adic coercions.</code></td></tr></table>




---

archive/issue_comments_181618.json:
```json
{
    "body": "<a id='comment:0'></a>\nSome maps created for p-adics seem to get automatically gc'ed and make some doctests fail.",
    "created_at": "2014-02-25T11:10:00Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181618",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:0'></a>
Some maps created for p-adics seem to get automatically gc'ed and make some doctests fail.



---

archive/issue_comments_181619.json:
```json
{
    "body": "<a id='comment:1'></a>\nThere are still a huge of number of failures, a lot of them in the number field stuff.\nI've double checked and these are not present in the old `u/SimonKing/ticket/14711` branch.\nSo it must be that something about number field or coercion has changed in other tickets since the original development of this ticket.\n\nThe current trac/master seems (mostly) fine.\nSo it's between trac/master (6.1.1) and trac/develop (6.2.beta2).\nOr not, as I've just tested every tag up to 6.2.beta2 on top of `u/SimonKing/ticket/14711` without problems.\nI've resolved conflicts in a slightly different way so it might be the reason behind the different behaviors.",
    "created_at": "2014-02-25T16:36:47Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181619",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:1'></a>
There are still a huge of number of failures, a lot of them in the number field stuff.
I've double checked and these are not present in the old `u/SimonKing/ticket/14711` branch.
So it must be that something about number field or coercion has changed in other tickets since the original development of this ticket.

The current trac/master seems (mostly) fine.
So it's between trac/master (6.1.1) and trac/develop (6.2.beta2).
Or not, as I've just tested every tag up to 6.2.beta2 on top of `u/SimonKing/ticket/14711` without problems.
I've resolved conflicts in a slightly different way so it might be the reason behind the different behaviors.



---

archive/issue_comments_181620.json:
```json
{
    "body": "<a id='comment:2'></a>\nIs your branch based off the one I was working on?",
    "created_at": "2014-02-25T16:42:36Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181620",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>
Is your branch based off the one I was working on?



---

archive/issue_comments_181621.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d0c26b94039540688eb35e985ebd7b558cec62b1\">d0c26b9</a></td><td><code>Fix wrong conflict resolution in number_field.py.</code></td></tr></table>\n",
    "created_at": "2014-02-25T16:50:11Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181621",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d0c26b94039540688eb35e985ebd7b558cec62b1">d0c26b9</a></td><td><code>Fix wrong conflict resolution in number_field.py.</code></td></tr></table>




---

archive/issue_comments_181622.json:
```json
{
    "body": "**Changing commit** from \"[7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3](https://github.com/sagemath/sagetrac-mirror/commit/7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3)\" to \"[d0c26b94039540688eb35e985ebd7b558cec62b1](https://github.com/sagemath/sagetrac-mirror/commit/d0c26b94039540688eb35e985ebd7b558cec62b1)\".",
    "created_at": "2014-02-25T16:50:11Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181622",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3](https://github.com/sagemath/sagetrac-mirror/commit/7d7f7ae03d3fd16e630c69fa863f9ce8e1ac01e3)" to "[d0c26b94039540688eb35e985ebd7b558cec62b1](https://github.com/sagemath/sagetrac-mirror/commit/d0c26b94039540688eb35e985ebd7b558cec62b1)".



---

archive/issue_comments_181623.json:
```json
{
    "body": "<a id='comment:4'></a>\nOk, my bad, I wrongly resolved a commit in number_field.py the first time.",
    "created_at": "2014-02-25T17:06:23Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181623",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:4'></a>
Ok, my bad, I wrongly resolved a commit in number_field.py the first time.



---

archive/issue_comments_181624.json:
```json
{
    "body": "<a id='comment:195'></a>\nReplying to [tscrim](#comment%3A192):\n> Is your branch based off the one I was working on?\n\nYes it is.",
    "created_at": "2014-02-25T17:06:40Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181624",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:195'></a>
Replying to [tscrim](#comment%3A192):
> Is your branch based off the one I was working on?

Yes it is.



---

archive/issue_comments_181625.json:
```json
{
    "body": "<a id='comment:6'></a>\nIt seems plausible that a bunch of errors and segaults are caused by the fact that some calls to `copy` were discarded in the construction of \"conversion maps\" or something in that spirit.\n\nFor sure something similar to what was done whit `_internal_coerce...` should be done for `convert_map...`.",
    "created_at": "2014-02-25T17:21:37Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181625",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:6'></a>
It seems plausible that a bunch of errors and segaults are caused by the fact that some calls to `copy` were discarded in the construction of "conversion maps" or something in that spirit.

For sure something similar to what was done whit `_internal_coerce...` should be done for `convert_map...`.



---

archive/issue_comments_181626.json:
```json
{
    "body": "<a id='comment:7'></a>\nDisregard my last comment, it seems I've forgotten to rebuild some files while switching between different branches...",
    "created_at": "2014-02-26T10:24:18Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181626",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:7'></a>
Disregard my last comment, it seems I've forgotten to rebuild some files while switching between different branches...



---

archive/issue_comments_181627.json:
```json
{
    "body": "<a id='comment:8'></a>\nOne of the \"new\" problems when testing number_field.py seems to be that\n\n```\ndef _lift_cyclotomic_element(self, new_parent, bint check=True, int rel=0)\n```\nis called with rel of non-int type.\nThe call stems from number_field_morphism.py:\n\n```\nx._lift_cyclotomic_element(self.codomain(), False, self.ratio)\n```",
    "created_at": "2014-02-26T10:44:29Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181627",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:8'></a>
One of the "new" problems when testing number_field.py seems to be that

```
def _lift_cyclotomic_element(self, new_parent, bint check=True, int rel=0)
```
is called with rel of non-int type.
The call stems from number_field_morphism.py:

```
x._lift_cyclotomic_element(self.codomain(), False, self.ratio)
```



---

archive/issue_comments_181628.json:
```json
{
    "body": "<a id='comment:9'></a>\nMinimal example:\n\n```\nsage: cf6 = CyclotomicField( 6 )\nsage: cf12 = CyclotomicField( 12 )\nsage: z6 = cf6.0\nsage: g = cf12.coerce_map_from(cf6)\nsage: g(z6)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-6-cc0ddcad408e> in <module>()\n----> 1 g(z6)\n\n/home/jpflori/sage.git/local/lib/python2.7/site-packages/sage/categories/map.so in sage.categories.map.Map.__call__ (sage/categories/map.c:4982)()\n\n/home/jpflori/sage.git/local/lib/python2.7/site-packages/sage/rings/number_field/number_field_morphisms.so in sage.rings.number_field.number_field_morphisms.CyclotomicFieldEmbedding._call_ (sage/rings/number_field/number_field_morphisms.c:6049)()\n\n/home/jpflori/sage.git/local/lib/python2.7/site-packages/sage/rings/number_field/number_field_element_quadratic.so in sage.rings.number_field.number_field_element_quadratic.NumberFieldElement_quadratic._lift_cyclotomic_element (sage/rings/number_field/number_field_element_quadratic.cpp:5613)()\n\nTypeError: an integer is required\n```",
    "created_at": "2014-02-26T11:01:15Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181628",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:9'></a>
Minimal example:

```
sage: cf6 = CyclotomicField( 6 )
sage: cf12 = CyclotomicField( 12 )
sage: z6 = cf6.0
sage: g = cf12.coerce_map_from(cf6)
sage: g(z6)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-6-cc0ddcad408e> in <module>()
----> 1 g(z6)

/home/jpflori/sage.git/local/lib/python2.7/site-packages/sage/categories/map.so in sage.categories.map.Map.__call__ (sage/categories/map.c:4982)()

/home/jpflori/sage.git/local/lib/python2.7/site-packages/sage/rings/number_field/number_field_morphisms.so in sage.rings.number_field.number_field_morphisms.CyclotomicFieldEmbedding._call_ (sage/rings/number_field/number_field_morphisms.c:6049)()

/home/jpflori/sage.git/local/lib/python2.7/site-packages/sage/rings/number_field/number_field_element_quadratic.so in sage.rings.number_field.number_field_element_quadratic.NumberFieldElement_quadratic._lift_cyclotomic_element (sage/rings/number_field/number_field_element_quadratic.cpp:5613)()

TypeError: an integer is required
```



---

archive/issue_comments_181629.json:
```json
{
    "body": "<a id='comment:0'></a>\nOk, it seems ratio is `None`.",
    "created_at": "2014-02-26T11:02:24Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181629",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:0'></a>
Ok, it seems ratio is `None`.



---

archive/issue_comments_181630.json:
```json
{
    "body": "<a id='comment:1'></a>\nI guess some update_slots magic has to be used to copy ratio for cyclotomic field morphims.",
    "created_at": "2014-02-26T11:09:19Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181630",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:1'></a>
I guess some update_slots magic has to be used to copy ratio for cyclotomic field morphims.



---

archive/issue_comments_181631.json:
```json
{
    "body": "<a id='comment:2'></a>\nIt might also be worth checking why this used to work and where these new (defunct) copies occur.",
    "created_at": "2014-02-26T12:20:40Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181631",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:2'></a>
It might also be worth checking why this used to work and where these new (defunct) copies occur.



---

archive/issue_comments_181632.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b21179f6631af835d01ed1f7f250bb2ac4c12f2b\">b21179f</a></td><td><code>Fix copying of some morphims.</code></td></tr></table>\n",
    "created_at": "2014-02-26T12:22:53Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181632",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b21179f6631af835d01ed1f7f250bb2ac4c12f2b">b21179f</a></td><td><code>Fix copying of some morphims.</code></td></tr></table>




---

archive/issue_comments_181633.json:
```json
{
    "body": "**Changing commit** from \"[d0c26b94039540688eb35e985ebd7b558cec62b1](https://github.com/sagemath/sagetrac-mirror/commit/d0c26b94039540688eb35e985ebd7b558cec62b1)\" to \"[b21179f6631af835d01ed1f7f250bb2ac4c12f2b](https://github.com/sagemath/sagetrac-mirror/commit/b21179f6631af835d01ed1f7f250bb2ac4c12f2b)\".",
    "created_at": "2014-02-26T12:22:53Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181633",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[d0c26b94039540688eb35e985ebd7b558cec62b1](https://github.com/sagemath/sagetrac-mirror/commit/d0c26b94039540688eb35e985ebd7b558cec62b1)" to "[b21179f6631af835d01ed1f7f250bb2ac4c12f2b](https://github.com/sagemath/sagetrac-mirror/commit/b21179f6631af835d01ed1f7f250bb2ac4c12f2b)".



---

archive/issue_comments_181634.json:
```json
{
    "body": "<a id='comment:204'></a>\nReplying to [jpflori](#comment%3A196):\n> For sure something similar to what was done whit `_internal_coerce...` should be done for `convert_map...`.\n> \n\nThis should still be done. See for example `src/sage/rings/polynomial/polynomial_element.pyx`.",
    "created_at": "2014-02-26T12:34:04Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181634",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:204'></a>
Replying to [jpflori](#comment%3A196):
> For sure something similar to what was done whit `_internal_coerce...` should be done for `convert_map...`.
> 

This should still be done. See for example `src/sage/rings/polynomial/polynomial_element.pyx`.



---

archive/issue_comments_181635.json:
```json
{
    "body": "**Changing commit** from \"[b21179f6631af835d01ed1f7f250bb2ac4c12f2b](https://github.com/sagemath/sagetrac-mirror/commit/b21179f6631af835d01ed1f7f250bb2ac4c12f2b)\" to \"[6b2b2e51ea475059605450d14fb657496e7f7c78](https://github.com/sagemath/sagetrac-mirror/commit/6b2b2e51ea475059605450d14fb657496e7f7c78)\".",
    "created_at": "2014-02-26T12:54:21Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181635",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[b21179f6631af835d01ed1f7f250bb2ac4c12f2b](https://github.com/sagemath/sagetrac-mirror/commit/b21179f6631af835d01ed1f7f250bb2ac4c12f2b)" to "[6b2b2e51ea475059605450d14fb657496e7f7c78](https://github.com/sagemath/sagetrac-mirror/commit/6b2b2e51ea475059605450d14fb657496e7f7c78)".



---

archive/issue_comments_181636.json:
```json
{
    "body": "<a id='comment:5'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6b2b2e51ea475059605450d14fb657496e7f7c78\">6b2b2e5</a></td><td><code>Fix test for weakened morphisms.</code></td></tr></table>\n",
    "created_at": "2014-02-26T12:54:21Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181636",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:5'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6b2b2e51ea475059605450d14fb657496e7f7c78">6b2b2e5</a></td><td><code>Fix test for weakened morphisms.</code></td></tr></table>




---

archive/issue_comments_181637.json:
```json
{
    "body": "**Changing commit** from \"[6b2b2e51ea475059605450d14fb657496e7f7c78](https://github.com/sagemath/sagetrac-mirror/commit/6b2b2e51ea475059605450d14fb657496e7f7c78)\" to \"[1cf51a4ce58fcc8620ac4158361567e73e7df9c5](https://github.com/sagemath/sagetrac-mirror/commit/1cf51a4ce58fcc8620ac4158361567e73e7df9c5)\".",
    "created_at": "2014-02-26T15:44:32Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181637",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[6b2b2e51ea475059605450d14fb657496e7f7c78](https://github.com/sagemath/sagetrac-mirror/commit/6b2b2e51ea475059605450d14fb657496e7f7c78)" to "[1cf51a4ce58fcc8620ac4158361567e73e7df9c5](https://github.com/sagemath/sagetrac-mirror/commit/1cf51a4ce58fcc8620ac4158361567e73e7df9c5)".



---

archive/issue_comments_181638.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1cf51a4ce58fcc8620ac4158361567e73e7df9c5\">1cf51a4</a></td><td><code>Introduce _internal_convert_map_from, use it and fix doctests.</code></td></tr></table>\n",
    "created_at": "2014-02-26T15:44:32Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181638",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:6'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1cf51a4ce58fcc8620ac4158361567e73e7df9c5">1cf51a4</a></td><td><code>Introduce _internal_convert_map_from, use it and fix doctests.</code></td></tr></table>




---

archive/issue_comments_181639.json:
```json
{
    "body": "<a id='comment:7'></a>\nThe remaining issues are:\n* some maps seem to get collected in padics/CR_template.pxi\n* <BLANKLINE> issue when the WARNING stuff is fed into an Exception/Error text (it seems to be duplicated: once before the Traceback and once in the error string, maybe a doctesting framework limitation?)",
    "created_at": "2014-02-26T15:59:38Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181639",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:7'></a>
The remaining issues are:
* some maps seem to get collected in padics/CR_template.pxi
* <BLANKLINE> issue when the WARNING stuff is fed into an Exception/Error text (it seems to be duplicated: once before the Traceback and once in the error string, maybe a doctesting framework limitation?)



---

archive/issue_comments_181640.json:
```json
{
    "body": "**Changing author** from \"Simon King\" to \"Simon King, Travis Scrimshaw, Jean-Pierre Flori\".",
    "created_at": "2014-02-26T15:59:38Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181640",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

**Changing author** from "Simon King" to "Simon King, Travis Scrimshaw, Jean-Pierre Flori".



---

archive/issue_comments_181641.json:
```json
{
    "body": "**Work Issues:** blankline, gc",
    "created_at": "2014-02-26T15:59:38Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181641",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

**Work Issues:** blankline, gc



---

archive/issue_comments_181642.json:
```json
{
    "body": "**Changing reviewer** from \"Jean-Pierre Flori\" to \"Nils Bruin, Jean-Pierre Flori\".",
    "created_at": "2014-02-26T15:59:38Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181642",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

**Changing reviewer** from "Jean-Pierre Flori" to "Nils Bruin, Jean-Pierre Flori".



---

archive/issue_events_128605.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/jpflori",
    "created_at": "2014-02-26T15:59:38Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128605"
}
```



---

archive/issue_events_128606.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/jpflori",
    "created_at": "2014-02-26T15:59:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128606"
}
```



---

archive/issue_comments_181643.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f5827666b700d3b8d245b20d2346c7110bd0c21d\">f582766</a></td><td><code>Fix doctests for copy of conversion from QQ to Zp.</code></td></tr></table>\n",
    "created_at": "2014-02-26T16:07:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181643",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f5827666b700d3b8d245b20d2346c7110bd0c21d">f582766</a></td><td><code>Fix doctests for copy of conversion from QQ to Zp.</code></td></tr></table>




---

archive/issue_comments_181644.json:
```json
{
    "body": "**Changing commit** from \"[1cf51a4ce58fcc8620ac4158361567e73e7df9c5](https://github.com/sagemath/sagetrac-mirror/commit/1cf51a4ce58fcc8620ac4158361567e73e7df9c5)\" to \"[f5827666b700d3b8d245b20d2346c7110bd0c21d](https://github.com/sagemath/sagetrac-mirror/commit/f5827666b700d3b8d245b20d2346c7110bd0c21d)\".",
    "created_at": "2014-02-26T16:07:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181644",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1cf51a4ce58fcc8620ac4158361567e73e7df9c5](https://github.com/sagemath/sagetrac-mirror/commit/1cf51a4ce58fcc8620ac4158361567e73e7df9c5)" to "[f5827666b700d3b8d245b20d2346c7110bd0c21d](https://github.com/sagemath/sagetrac-mirror/commit/f5827666b700d3b8d245b20d2346c7110bd0c21d)".



---

archive/issue_comments_181645.json:
```json
{
    "body": "**Changing work issues** from \"blankline, gc\" to \"blankline\".",
    "created_at": "2014-02-26T16:08:29Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181645",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

**Changing work issues** from "blankline, gc" to "blankline".



---

archive/issue_comments_181646.json:
```json
{
    "body": "<a id='comment:9'></a>\nThe padic issue was caused by a wrong doctest.\nFixed now.",
    "created_at": "2014-02-26T16:08:29Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181646",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:9'></a>
The padic issue was caused by a wrong doctest.
Fixed now.



---

archive/issue_comments_181647.json:
```json
{
    "body": "**Changing commit** from \"[f5827666b700d3b8d245b20d2346c7110bd0c21d](https://github.com/sagemath/sagetrac-mirror/commit/f5827666b700d3b8d245b20d2346c7110bd0c21d)\" to \"[c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8](https://github.com/sagemath/sagetrac-mirror/commit/c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8)\".",
    "created_at": "2014-02-26T16:41:06Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181647",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f5827666b700d3b8d245b20d2346c7110bd0c21d](https://github.com/sagemath/sagetrac-mirror/commit/f5827666b700d3b8d245b20d2346c7110bd0c21d)" to "[c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8](https://github.com/sagemath/sagetrac-mirror/commit/c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8)".



---

archive/issue_comments_181648.json:
```json
{
    "body": "<a id='comment:0'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8\">c9cd7a4</a></td><td><code>Fix doctests in combinat using coercion stuff.</code></td></tr></table>\n",
    "created_at": "2014-02-26T16:41:06Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181648",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:0'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8">c9cd7a4</a></td><td><code>Fix doctests in combinat using coercion stuff.</code></td></tr></table>




---

archive/issue_comments_181649.json:
```json
{
    "body": "<a id='comment:1'></a>\nI've set back the WARNING stuff in the combinat doctests which were failing.\nI'm not really acuqinted to this code, so Travis could you confirm that the fact that internal coercion stuff is used is expected?\n(I see you changed stuff from coerce_map_from to the internal version in sf/new_kschur and it seems the error is triggered when composing stuff internally, that is not when dealing with user visible stuff, so it seems ok)\n\nThere is still the strange blankline mentioned by Travis in structure/coerce.pyx.",
    "created_at": "2014-02-26T16:43:32Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181649",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:1'></a>
I've set back the WARNING stuff in the combinat doctests which were failing.
I'm not really acuqinted to this code, so Travis could you confirm that the fact that internal coercion stuff is used is expected?
(I see you changed stuff from coerce_map_from to the internal version in sf/new_kschur and it seems the error is triggered when composing stuff internally, that is not when dealing with user visible stuff, so it seems ok)

There is still the strange blankline mentioned by Travis in structure/coerce.pyx.



---

archive/issue_comments_181650.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4e4bdbb4abe71fd77529bfef5dadb12c473453af\">4e4bdbb</a></td><td><code>Fix for failing doctest in coerce.pyx.</code></td></tr></table>\n",
    "created_at": "2014-02-26T16:47:16Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181650",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4e4bdbb4abe71fd77529bfef5dadb12c473453af">4e4bdbb</a></td><td><code>Fix for failing doctest in coerce.pyx.</code></td></tr></table>




---

archive/issue_comments_181651.json:
```json
{
    "body": "**Changing commit** from \"[c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8](https://github.com/sagemath/sagetrac-mirror/commit/c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8)\" to \"[4e4bdbb4abe71fd77529bfef5dadb12c473453af](https://github.com/sagemath/sagetrac-mirror/commit/4e4bdbb4abe71fd77529bfef5dadb12c473453af)\".",
    "created_at": "2014-02-26T16:47:16Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181651",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8](https://github.com/sagemath/sagetrac-mirror/commit/c9cd7a46c1338b7e452ea8f4e5e26d189f43ddb8)" to "[4e4bdbb4abe71fd77529bfef5dadb12c473453af](https://github.com/sagemath/sagetrac-mirror/commit/4e4bdbb4abe71fd77529bfef5dadb12c473453af)".



---

archive/issue_comments_181652.json:
```json
{
    "body": "<a id='comment:3'></a>\nOk, this was some strange output from the doctesting framework not liking the new lines and `...` in the expected output.\n\nI guess we could set this to positive review if Travis or Simon is ok with my latest changes (_internal_convert_map_from and the combinat doctests) and avoid further painful rebasing.",
    "created_at": "2014-02-26T16:48:57Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181652",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:3'></a>
Ok, this was some strange output from the doctesting framework not liking the new lines and `...` in the expected output.

I guess we could set this to positive review if Travis or Simon is ok with my latest changes (_internal_convert_map_from and the combinat doctests) and avoid further painful rebasing.



---

archive/issue_comments_181653.json:
```json
{
    "body": "**Changing work issues** from \"blankline\" to \"\".",
    "created_at": "2014-02-26T16:48:57Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181653",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

**Changing work issues** from "blankline" to "".



---

archive/issue_events_128607.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/jpflori",
    "created_at": "2014-02-26T16:48:57Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128607"
}
```



---

archive/issue_events_128608.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/jpflori",
    "created_at": "2014-02-26T16:48:57Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128608"
}
```



---

archive/issue_comments_181654.json:
```json
{
    "body": "<a id='comment:4'></a>\nI'll try to take a look at it tonight, otherwise I will do so tomorrow unless Simon beats me too it.",
    "created_at": "2014-02-27T00:46:40Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181654",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:4'></a>
I'll try to take a look at it tonight, otherwise I will do so tomorrow unless Simon beats me too it.



---

archive/issue_comments_181655.json:
```json
{
    "body": "<a id='comment:5'></a>\nI've actually changed `TriangularModuleMorphism` to print out a copy of itself when raising an error because I didn't like the WARNING message being displayed. (FTR, they were being used as expected since they are suppose to be internal coercions.) And while that strange blankline is weird, it doesn't seem to be harmful, so I'm up for setting this to positive review. Simon, Nils, any objections?\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf\">ea58b22</a></td><td><code>Made triangular module morphism return a copy of self in error messages.</code></td></tr></table>\n",
    "created_at": "2014-02-27T18:22:25Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181655",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:5'></a>
I've actually changed `TriangularModuleMorphism` to print out a copy of itself when raising an error because I didn't like the WARNING message being displayed. (FTR, they were being used as expected since they are suppose to be internal coercions.) And while that strange blankline is weird, it doesn't seem to be harmful, so I'm up for setting this to positive review. Simon, Nils, any objections?

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf">ea58b22</a></td><td><code>Made triangular module morphism return a copy of self in error messages.</code></td></tr></table>




---

archive/issue_comments_181656.json:
```json
{
    "body": "**Changing branch** from \"[u/jpflori/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/u/jpflori/ticket/14711)\" to \"[public/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/14711)\".",
    "created_at": "2014-02-27T18:22:25Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181656",
    "user": "https://github.com/tscrim"
}
```

**Changing branch** from "[u/jpflori/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/u/jpflori/ticket/14711)" to "[public/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/14711)".



---

archive/issue_comments_181657.json:
```json
{
    "body": "**Changing commit** from \"[4e4bdbb4abe71fd77529bfef5dadb12c473453af](https://github.com/sagemath/sagetrac-mirror/commit/4e4bdbb4abe71fd77529bfef5dadb12c473453af)\" to \"[ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf](https://github.com/sagemath/sagetrac-mirror/commit/ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf)\".",
    "created_at": "2014-02-27T18:22:25Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181657",
    "user": "https://github.com/tscrim"
}
```

**Changing commit** from "[4e4bdbb4abe71fd77529bfef5dadb12c473453af](https://github.com/sagemath/sagetrac-mirror/commit/4e4bdbb4abe71fd77529bfef5dadb12c473453af)" to "[ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf](https://github.com/sagemath/sagetrac-mirror/commit/ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf)".



---

archive/issue_comments_181658.json:
```json
{
    "body": "<a id='comment:6'></a>\nIs it normally the case that the error being raised by `TriangularModuleMorphism` will not be caught? Otherwise, copying the morphism just for getting its print representation would be a waste of time.\n\nCurrently I do not have the capacity to check details, and for about one week I won't be able to review the recent changes.",
    "created_at": "2014-02-27T21:21:03Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181658",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
Is it normally the case that the error being raised by `TriangularModuleMorphism` will not be caught? Otherwise, copying the morphism just for getting its print representation would be a waste of time.

Currently I do not have the capacity to check details, and for about one week I won't be able to review the recent changes.



---

archive/issue_comments_181659.json:
```json
{
    "body": "<a id='comment:7'></a>\nI don't think so. It's for when trying to incorrectly use the (natural) inverse map, and as such, it shouldn't be caught much (if at all). At least I can't think of a case where it is...",
    "created_at": "2014-02-27T22:52:20Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181659",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:7'></a>
I don't think so. It's for when trying to incorrectly use the (natural) inverse map, and as such, it shouldn't be caught much (if at all). At least I can't think of a case where it is...



---

archive/issue_comments_181660.json:
```json
{
    "body": "<a id='comment:8'></a>\nHow about we add an optional argument `suppress_warning` to the `_repr_` for times like this but when the error is expected to be caught?",
    "created_at": "2014-03-01T15:35:19Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181660",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>
How about we add an optional argument `suppress_warning` to the `_repr_` for times like this but when the error is expected to be caught?



---

archive/issue_comments_181661.json:
```json
{
    "body": "<a id='comment:219'></a>\nHi!\n\nReplying to [tscrim](#comment%3A215):\n> I've actually changed `TriangularModuleMorphism` to print out a copy of itself when raising an error because I didn't like the WARNING message being displayed. (FTR, they were being used as expected since they are suppose to be internal coercions.)\n\nSorry, I haven't been following the details.  Having to change the\ncode of existing morphisms when the usage is as expected feels like a\nsmell (one more thing to think about when using/implementing\nmorphisms). If I understand properly, in certain circumstances, one\nhas to make copies of morphisms. Is it described somewhere in the documentation what those\ncircumstances are exactly? It would be best if the warning would point\nto this documentation, as I would not guess, at first sight, why I'd\nneed to make a copy of an immutable object.\n\nCheers,\n                             Nicolas",
    "created_at": "2014-03-03T10:48:53Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181661",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:219'></a>
Hi!

Replying to [tscrim](#comment%3A215):
> I've actually changed `TriangularModuleMorphism` to print out a copy of itself when raising an error because I didn't like the WARNING message being displayed. (FTR, they were being used as expected since they are suppose to be internal coercions.)

Sorry, I haven't been following the details.  Having to change the
code of existing morphisms when the usage is as expected feels like a
smell (one more thing to think about when using/implementing
morphisms). If I understand properly, in certain circumstances, one
has to make copies of morphisms. Is it described somewhere in the documentation what those
circumstances are exactly? It would be best if the warning would point
to this documentation, as I would not guess, at first sight, why I'd
need to make a copy of an immutable object.

Cheers,
                             Nicolas



---

archive/issue_comments_181662.json:
```json
{
    "body": "<a id='comment:220'></a>\nReplying to [nthiery](#comment%3A219):\n>     Hi!\n> \n> Replying to [tscrim](#comment%3A215):\n> > I've actually changed `TriangularModuleMorphism` to print out a copy of itself when raising an error because I didn't like the WARNING message being displayed. (FTR, they were being used as expected since they are suppose to be internal coercions.)\n\n> \n> Sorry, I haven't been following the details.  Having to change the\n> code of existing morphisms when the usage is as expected feels like a\n> smell (one more thing to think about when using/implementing\n> morphisms). If I understand properly, in certain circumstances, one\n> has to make copies of morphisms. Is it described somewhere in the documentation what those\n\nNot with Travis last changes.\nNow the `coerce/convert_map_from` methods return \"safe\" objects for which the copying was automatically done.\nIt's only the `_internal_` prefixed methods which return weakened objects but might be faster as no copies are involved.",
    "created_at": "2014-03-03T10:52:24Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181662",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:220'></a>
Replying to [nthiery](#comment%3A219):
>     Hi!
> 
> Replying to [tscrim](#comment%3A215):
> > I've actually changed `TriangularModuleMorphism` to print out a copy of itself when raising an error because I didn't like the WARNING message being displayed. (FTR, they were being used as expected since they are suppose to be internal coercions.)

> 
> Sorry, I haven't been following the details.  Having to change the
> code of existing morphisms when the usage is as expected feels like a
> smell (one more thing to think about when using/implementing
> morphisms). If I understand properly, in certain circumstances, one
> has to make copies of morphisms. Is it described somewhere in the documentation what those

Not with Travis last changes.
Now the `coerce/convert_map_from` methods return "safe" objects for which the copying was automatically done.
It's only the `_internal_` prefixed methods which return weakened objects but might be faster as no copies are involved.



---

archive/issue_comments_181663.json:
```json
{
    "body": "<a id='comment:221'></a>\nReplying to [jpflori](#comment%3A220):\n> Replying to [nthiery](#comment%3A219):\n> > Replying to [tscrim](#comment%3A215):\n> > > I've actually changed `TriangularModuleMorphism` to print out a copy of itself when raising an error because I didn't like the WARNING message being displayed. (FTR, they were being used as expected since they are suppose to be internal coercions.)\n\n> > \n> > Sorry, I haven't been following the details.  Having to change the\n> > code of existing morphisms when the usage is as expected feels like a\n> > smell (one more thing to think about when using/implementing\n> > morphisms). If I understand properly, in certain circumstances, one\n> > has to make copies of morphisms. Is it described somewhere in the documentation what those\n\n> Not with Travis last changes.\n> Now the `coerce/convert_map_from` methods return \"safe\" objects for which the copying was automatically done.\n> It's only the `_internal_` prefixed methods which return weakened objects but might be faster as no copies are involved.\n\nYou mean that the change to `TriangularModuleMorphism` is not needed any more?",
    "created_at": "2014-03-03T11:26:38Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181663",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:221'></a>
Replying to [jpflori](#comment%3A220):
> Replying to [nthiery](#comment%3A219):
> > Replying to [tscrim](#comment%3A215):
> > > I've actually changed `TriangularModuleMorphism` to print out a copy of itself when raising an error because I didn't like the WARNING message being displayed. (FTR, they were being used as expected since they are suppose to be internal coercions.)

> > 
> > Sorry, I haven't been following the details.  Having to change the
> > code of existing morphisms when the usage is as expected feels like a
> > smell (one more thing to think about when using/implementing
> > morphisms). If I understand properly, in certain circumstances, one
> > has to make copies of morphisms. Is it described somewhere in the documentation what those

> Not with Travis last changes.
> Now the `coerce/convert_map_from` methods return "safe" objects for which the copying was automatically done.
> It's only the `_internal_` prefixed methods which return weakened objects but might be faster as no copies are involved.

You mean that the change to `TriangularModuleMorphism` is not needed any more?



---

archive/issue_comments_181664.json:
```json
{
    "body": "<a id='comment:2'></a>\nI'd say the change is needed.\nBut that's because the code there uses an internal method to go faster rather than the publicized safe and slower method.\n\nNormally one would use the public and slower method and won't have such problems.\nIf one wants to use internal stuff, then it does not sound so unnatural that one has to be careful.",
    "created_at": "2014-03-03T12:24:51Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181664",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:2'></a>
I'd say the change is needed.
But that's because the code there uses an internal method to go faster rather than the publicized safe and slower method.

Normally one would use the public and slower method and won't have such problems.
If one wants to use internal stuff, then it does not sound so unnatural that one has to be careful.



---

archive/issue_comments_181665.json:
```json
{
    "body": "<a id='comment:223'></a>\nReplying to [jpflori](#comment%3A222):\n> I'd say the change is needed.\n> But that's because the code there uses an internal method to go faster rather than the publicized safe and slower method.\n\nSorry, I am confused; which internal method?",
    "created_at": "2014-03-03T14:07:42Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181665",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:223'></a>
Replying to [jpflori](#comment%3A222):
> I'd say the change is needed.
> But that's because the code there uses an internal method to go faster rather than the publicized safe and slower method.

Sorry, I am confused; which internal method?



---

archive/issue_comments_181666.json:
```json
{
    "body": "<a id='comment:4'></a>\nIn fact, the code in `Triangular...` does not use the new `_internal_coerce_map_from`, but the code here:\nhttps://github.com/sagemath/sagetrac-mirror/blob/6110bb984403114b2ddb8410868472d1cfdc64df/src/sage/combinat/sf/new_kschur.py",
    "created_at": "2014-03-03T14:13:32Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181666",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:4'></a>
In fact, the code in `Triangular...` does not use the new `_internal_coerce_map_from`, but the code here:
https://github.com/sagemath/sagetrac-mirror/blob/6110bb984403114b2ddb8410868472d1cfdc64df/src/sage/combinat/sf/new_kschur.py



---

archive/issue_comments_181667.json:
```json
{
    "body": "<a id='comment:5'></a>\nIMO the `TriangularModuleMorphism` should be an internal coercion map in these cases, and so the issue is the error messages includes the map. Hence there is a big, scary, but completely unrelated warning printed with the error message. So to suppress the warning, either we copy `self` or do (something like) [comment:218](#comment%3A218).",
    "created_at": "2014-03-03T15:14:22Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181667",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:5'></a>
IMO the `TriangularModuleMorphism` should be an internal coercion map in these cases, and so the issue is the error messages includes the map. Hence there is a big, scary, but completely unrelated warning printed with the error message. So to suppress the warning, either we copy `self` or do (something like) [comment:218](#comment%3A218).



---

archive/issue_comments_181668.json:
```json
{
    "body": "<a id='comment:6'></a>\nOk, thanks for the explanations!\n\nHmm, this is not super convincing since this adds some complexity: when should one use _internal_coercion_map_from or coerce_map_from? when should one do a copy? I guess that will do for now, but if we end up having to worry about those every so often, we should find some better approach.\n\nAs for the current workaround, I prefer using `copy` to introducing another protocol as in [comment:218](#comment%3A218).\n\nCheers,\n                                       Nicolas",
    "created_at": "2014-03-03T17:23:59Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181668",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>
Ok, thanks for the explanations!

Hmm, this is not super convincing since this adds some complexity: when should one use _internal_coercion_map_from or coerce_map_from? when should one do a copy? I guess that will do for now, but if we end up having to worry about those every so often, we should find some better approach.

As for the current workaround, I prefer using `copy` to introducing another protocol as in [comment:218](#comment%3A218).

Cheers,
                                       Nicolas



---

archive/issue_comments_181669.json:
```json
{
    "body": "<a id='comment:227'></a>\nReplying to [nthiery](#comment%3A226):\n> Hmm, this is not super convincing since this adds some complexity: when should one use _internal_coercion_map_from or coerce_map_from? when should one do a copy?\n\nIf you can be sure that domain and codomain will remain strongly referenced, then you should be safe with _internal_coercion_map_from---but since the `_repr_` method can not know whether a strong reference will remain, it will print the warning.\n\nIf it could be that the map itself is the only object holding references to domain and codomain, then you must copy it (or use coerce_map_from).\n\n> As for the current workaround, I prefer using `copy` to introducing another protocol as in [comment:218](#comment%3A218).\n\nI don't think the suggestion from [comment:218](#comment%3A218) has a chance to work. Can `_repr_` take an optional argument?",
    "created_at": "2014-03-03T17:29:28Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181669",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:227'></a>
Replying to [nthiery](#comment%3A226):
> Hmm, this is not super convincing since this adds some complexity: when should one use _internal_coercion_map_from or coerce_map_from? when should one do a copy?

If you can be sure that domain and codomain will remain strongly referenced, then you should be safe with _internal_coercion_map_from---but since the `_repr_` method can not know whether a strong reference will remain, it will print the warning.

If it could be that the map itself is the only object holding references to domain and codomain, then you must copy it (or use coerce_map_from).

> As for the current workaround, I prefer using `copy` to introducing another protocol as in [comment:218](#comment%3A218).

I don't think the suggestion from [comment:218](#comment%3A218) has a chance to work. Can `_repr_` take an optional argument?



---

archive/issue_comments_181670.json:
```json
{
    "body": "<a id='comment:8'></a>\nPS: Why not use some kind of lazy string, that will copy the map only if the string representation is actually printed? Hence, if the error is caught somewhere, then the error message will not be expanded. But if the error appears on screen, then the lazy string will copy the map before printing it.",
    "created_at": "2014-03-03T17:31:11Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181670",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
PS: Why not use some kind of lazy string, that will copy the map only if the string representation is actually printed? Hence, if the error is caught somewhere, then the error message will not be expanded. But if the error appears on screen, then the lazy string will copy the map before printing it.



---

archive/issue_comments_181671.json:
```json
{
    "body": "<a id='comment:229'></a>\nReplying to [nthiery](#comment%3A226):\n> Ok, thanks for the explanations!\n> \n> Hmm, this is not super convincing since this adds some complexity: \n\nSure but it's hard fixing bugs without modifying code :)\n>when should one use _internal_coercion_map_from or coerce_map_from? when should one do a copy? I guess that will do for now, but if we end up having to worry about those every so often, we should find some better approach.\n\nI'd say the answer is simple: just use the non-internal method by default.\n\nOf course this is \"unless you know what you're doing\"...",
    "created_at": "2014-03-03T17:32:35Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181671",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:229'></a>
Replying to [nthiery](#comment%3A226):
> Ok, thanks for the explanations!
> 
> Hmm, this is not super convincing since this adds some complexity: 

Sure but it's hard fixing bugs without modifying code :)
>when should one use _internal_coercion_map_from or coerce_map_from? when should one do a copy? I guess that will do for now, but if we end up having to worry about those every so often, we should find some better approach.

I'd say the answer is simple: just use the non-internal method by default.

Of course this is "unless you know what you're doing"...



---

archive/issue_comments_181672.json:
```json
{
    "body": "<a id='comment:230'></a>\nReplying to [SimonKing](#comment%3A227):\n> I don't think the suggestion from [comment:218](#comment%3A218) has a chance to work. Can `_repr_` take an optional argument?\n\nYes it can, as long as it has a default value. The plus-minus diagrams in `combinat/crystals/kirillov_reshetikhin.py` do it, and I think a few other places as well.",
    "created_at": "2014-03-05T23:25:46Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181672",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:230'></a>
Replying to [SimonKing](#comment%3A227):
> I don't think the suggestion from [comment:218](#comment%3A218) has a chance to work. Can `_repr_` take an optional argument?

Yes it can, as long as it has a default value. The plus-minus diagrams in `combinat/crystals/kirillov_reshetikhin.py` do it, and I think a few other places as well.



---

archive/issue_comments_181673.json:
```json
{
    "body": "<a id='comment:231'></a>\nIs the suggestion to do something like this:\n\n```\n    raise TypeError(\"%s is totally doomed.\"%m)\n```\n(which is when an optional parameter to `_repr_` can not make sense) or like this:\n\n```\n    raise TypeError(\"%s is totally doomed.\"%m._repr_(suppress_warning=False))\n```\n(which works but is is clumsy)?",
    "created_at": "2014-03-05T23:33:42Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181673",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:231'></a>
Is the suggestion to do something like this:

```
    raise TypeError("%s is totally doomed."%m)
```
(which is when an optional parameter to `_repr_` can not make sense) or like this:

```
    raise TypeError("%s is totally doomed."%m._repr_(suppress_warning=False))
```
(which works but is is clumsy)?



---

archive/issue_comments_181674.json:
```json
{
    "body": "<a id='comment:232'></a>\nReplying to [SimonKing](#comment%3A231):\n> Is the suggestion to do something like this:\n> \n> ```\n>     raise TypeError(\"%s is totally doomed.\"%m)\n> ```\n> (which is when an optional parameter to `_repr_` can not make sense) or like this:\n> \n> ```\n>     raise TypeError(\"%s is totally doomed.\"%m._repr_(suppress_warning=False))\n> ```\n> (which works but is is clumsy)?\n\nThe latter one (so we don't have to do the copy unnecessarily).",
    "created_at": "2014-03-05T23:41:49Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181674",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:232'></a>
Replying to [SimonKing](#comment%3A231):
> Is the suggestion to do something like this:
> 
> ```
>     raise TypeError("%s is totally doomed."%m)
> ```
> (which is when an optional parameter to `_repr_` can not make sense) or like this:
> 
> ```
>     raise TypeError("%s is totally doomed."%m._repr_(suppress_warning=False))
> ```
> (which works but is is clumsy)?

The latter one (so we don't have to do the copy unnecessarily).



---

archive/issue_comments_181675.json:
```json
{
    "body": "<a id='comment:3'></a>\nDo you mean one would have to always pass the suppress_warning thing?",
    "created_at": "2014-03-18T14:04:05Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181675",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:3'></a>
Do you mean one would have to always pass the suppress_warning thing?



---

archive/issue_comments_181676.json:
```json
{
    "body": "<a id='comment:234'></a>\nReplying to [jpflori](#comment%3A233):\n> Do you mean one would have to always pass the suppress_warning thing?\n\nI'm not completely sure what you mean. I'm going to take a shot and say only if one wants to suppress the warning, not if they didn't care if it has a warning or not. For example,\n\n```\nsage: domain._get_coerce_map_internal(codomain)\n```\nwill work because of the default value of `True` (and display the warning message as well).\n\n`@`Simon, I don't think that will work because python should run the copy before passing to the lazy string, since I think the string's formatting is the only thing being lazily done.",
    "created_at": "2014-03-18T15:28:09Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181676",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:234'></a>
Replying to [jpflori](#comment%3A233):
> Do you mean one would have to always pass the suppress_warning thing?

I'm not completely sure what you mean. I'm going to take a shot and say only if one wants to suppress the warning, not if they didn't care if it has a warning or not. For example,

```
sage: domain._get_coerce_map_internal(codomain)
```
will work because of the default value of `True` (and display the warning message as well).

`@`Simon, I don't think that will work because python should run the copy before passing to the lazy string, since I think the string's formatting is the only thing being lazily done.



---

archive/issue_comments_181677.json:
```json
{
    "body": "<a id='comment:235'></a>\nReplying to [tscrim](#comment%3A234):\n>> `@`Simon, I don't think that will work because python should run the copy before passing to the lazy string, since I think the string's formatting is the only thing being lazily done.\n\nThat's why I said \"Why not use *some kind of* lazy string\" in [comment:228](#comment%3A228). It would of course be a new class, along the lines of\n\n```python\nclass CopyOnPrint:\n    def __init__(self, x):\n        self.x = x\n    def __repr__(self):\n        return repr(self.x.__copy__())\n```",
    "created_at": "2014-03-18T15:58:49Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181677",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:235'></a>
Replying to [tscrim](#comment%3A234):
>> `@`Simon, I don't think that will work because python should run the copy before passing to the lazy string, since I think the string's formatting is the only thing being lazily done.

That's why I said "Why not use *some kind of* lazy string" in [comment:228](#comment%3A228). It would of course be a new class, along the lines of

```python
class CopyOnPrint:
    def __init__(self, x):
        self.x = x
    def __repr__(self):
        return repr(self.x.__copy__())
```



---

archive/issue_comments_181678.json:
```json
{
    "body": "<a id='comment:6'></a>\nI'm also lost now.\n\nMy problem is I don't feel we need to copy that map just to print it.\nAnd I don't get the meaning of Simon point in [comment:231](#comment%3A231).\n\nWhat I understood is that Travis suggested to add an optional `suppress_warning` option to the `_repr_` method of `Morphism` set to `False` by default.\nIn the piece of code currently printing the boring warning, one would use `%m._repr_(suppress_warning)` as we don't really care to print that the map was using weak references.\n`@`Simon is it this construction that you find clumsy?",
    "created_at": "2014-03-18T16:08:34Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181678",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:6'></a>
I'm also lost now.

My problem is I don't feel we need to copy that map just to print it.
And I don't get the meaning of Simon point in [comment:231](#comment%3A231).

What I understood is that Travis suggested to add an optional `suppress_warning` option to the `_repr_` method of `Morphism` set to `False` by default.
In the piece of code currently printing the boring warning, one would use `%m._repr_(suppress_warning)` as we don't really care to print that the map was using weak references.
`@`Simon is it this construction that you find clumsy?



---

archive/issue_comments_181679.json:
```json
{
    "body": "<a id='comment:7'></a>\nPS: This \"`CopyOnPrint`\" would only provide the string representation of the map. The whole error message would then be a lazy format string, such that the copy would really *only* happen when printing the error message.\n\nProof of concept:\n\n```\nsage: class CopyOnPrint:\n....:     def __init__(self, x):\n....:         self.x = x\n....:     def __repr__(self):\n....:         print \"Now a copy is taken\"\n....:         return repr(x.__copy__())\n....:     \nsage: O = CopyOnPrint(x)\nsage: O\nNow a copy is taken\nx\nsage: msg = \"The map %s is doomed\"%O\nNow a copy is taken\n```\nThe last line shows that the copy happens even though the message is not printed. However, when combined with a lazy format string, the behaviour is as intended:\n\n```\nsage: from sage.misc.lazy_format import LazyFormat\nsage: lazy_msg = LazyFormat(\"The map %s is doomed\")%O\n```\nSo, the message is created without copying, but copying happens when printing the message:\n\n```\nsage: lazy_msg\nNow a copy is taken\nThe map x is doomed\n```",
    "created_at": "2014-03-18T16:08:58Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181679",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
PS: This "`CopyOnPrint`" would only provide the string representation of the map. The whole error message would then be a lazy format string, such that the copy would really *only* happen when printing the error message.

Proof of concept:

```
sage: class CopyOnPrint:
....:     def __init__(self, x):
....:         self.x = x
....:     def __repr__(self):
....:         print "Now a copy is taken"
....:         return repr(x.__copy__())
....:     
sage: O = CopyOnPrint(x)
sage: O
Now a copy is taken
x
sage: msg = "The map %s is doomed"%O
Now a copy is taken
```
The last line shows that the copy happens even though the message is not printed. However, when combined with a lazy format string, the behaviour is as intended:

```
sage: from sage.misc.lazy_format import LazyFormat
sage: lazy_msg = LazyFormat("The map %s is doomed")%O
```
So, the message is created without copying, but copying happens when printing the message:

```
sage: lazy_msg
Now a copy is taken
The map x is doomed
```



---

archive/issue_comments_181680.json:
```json
{
    "body": "<a id='comment:8'></a>\nAh, sorry about that Simon. However do you think we find this useful enough to not do the evils of copying or adding an optional arg to `_repr_`? Because having the lazy format and copy string seems to specific to our case.\n\nActually...what it we have a lazy string that takes an arbitrary function and prints the result? This might be useful for errors which want to do some (non-trivial) transformation to an object before adding it to the error.",
    "created_at": "2014-03-18T16:13:50Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181680",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>
Ah, sorry about that Simon. However do you think we find this useful enough to not do the evils of copying or adding an optional arg to `_repr_`? Because having the lazy format and copy string seems to specific to our case.

Actually...what it we have a lazy string that takes an arbitrary function and prints the result? This might be useful for errors which want to do some (non-trivial) transformation to an object before adding it to the error.



---

archive/issue_comments_181681.json:
```json
{
    "body": "<a id='comment:239'></a>\nReplying to [jpflori](#comment%3A236):\n> My problem is I don't feel we need to copy that map just to print it.\n\nI understand that we want all our weakened maps to print a big fat warning, since they are only safe to use when a reference to domain and codomain is being kept. This should be guaranteed as long as the weakened maps live in the safe environment of the coercion framework, but can not be guaranteed if the user pulls them out of their natural environment.\n\nNormally, the coercion framework will not print maps, hence, one will see the big fat warning *only* if one deals with a weakened map that lives outside of the coercion framework.\n\nNow, back to your question: If we accept that a weakened map must provide a big fat warning then we have to do something special when we want that a weakened map prints as a normal map.\n\nOptions:\n- Make it strong in-place. That's bad, because it may create a memory leak on the fly.\n- Use a copy. That's what the big fat warning currently suggests.\n- Find a way to tell `_repr_` whether the warning shall be given or not. I.e.: Introduce an optional parameter to `_repr_` \n\n> And I don't get the meaning of Simon point in [comment:231](#comment%3A231).\n\nAll I wanted to say is: the optional argument to `_repr_` will not save us any effort.\n\n> What I understood is that Travis suggested to add an optional `suppress_warning` option to the `_repr_` method of `Morphism` set to `False` by default.\n\nWhich I find odd.\n\n> In the piece of code currently printing the boring warning, one would use `%m._repr_(suppress_warning)` as we don't really care to print that the map was using weak references.\n> `@`Simon is it this construction that you find clumsy?\n\nYes.",
    "created_at": "2014-03-18T16:17:48Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181681",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:239'></a>
Replying to [jpflori](#comment%3A236):
> My problem is I don't feel we need to copy that map just to print it.

I understand that we want all our weakened maps to print a big fat warning, since they are only safe to use when a reference to domain and codomain is being kept. This should be guaranteed as long as the weakened maps live in the safe environment of the coercion framework, but can not be guaranteed if the user pulls them out of their natural environment.

Normally, the coercion framework will not print maps, hence, one will see the big fat warning *only* if one deals with a weakened map that lives outside of the coercion framework.

Now, back to your question: If we accept that a weakened map must provide a big fat warning then we have to do something special when we want that a weakened map prints as a normal map.

Options:
- Make it strong in-place. That's bad, because it may create a memory leak on the fly.
- Use a copy. That's what the big fat warning currently suggests.
- Find a way to tell `_repr_` whether the warning shall be given or not. I.e.: Introduce an optional parameter to `_repr_` 

> And I don't get the meaning of Simon point in [comment:231](#comment%3A231).

All I wanted to say is: the optional argument to `_repr_` will not save us any effort.

> What I understood is that Travis suggested to add an optional `suppress_warning` option to the `_repr_` method of `Morphism` set to `False` by default.

Which I find odd.

> In the piece of code currently printing the boring warning, one would use `%m._repr_(suppress_warning)` as we don't really care to print that the map was using weak references.
> `@`Simon is it this construction that you find clumsy?

Yes.



---

archive/issue_comments_181682.json:
```json
{
    "body": "<a id='comment:240'></a>\nReplying to [tscrim](#comment%3A238):\n> Actually...what it we have a lazy string that takes an arbitrary function and prints the result? \n\nThat's `lazy_string`, which is different from `LazyFormat`.",
    "created_at": "2014-03-18T16:19:07Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181682",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:240'></a>
Replying to [tscrim](#comment%3A238):
> Actually...what it we have a lazy string that takes an arbitrary function and prints the result? 

That's `lazy_string`, which is different from `LazyFormat`.



---

archive/issue_comments_181683.json:
```json
{
    "body": "<a id='comment:241'></a>\nReplying to [SimonKing](#comment%3A240):\n> Replying to [tscrim](#comment%3A238):\n> > Actually...what it we have a lazy string that takes an arbitrary function and prints the result? \n\n> \n> That's `lazy_string`, which is different from `LazyFormat`.\n\nWhy can't we just use that with `copy` as the function? Something like:\n\n```\nsage: from sage.misc.lazy_string import lazy_string\nsage: LazyFormat('%s')%lazy_string(copy, 5)\n5\n```",
    "created_at": "2014-03-18T16:31:08Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181683",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:241'></a>
Replying to [SimonKing](#comment%3A240):
> Replying to [tscrim](#comment%3A238):
> > Actually...what it we have a lazy string that takes an arbitrary function and prints the result? 

> 
> That's `lazy_string`, which is different from `LazyFormat`.

Why can't we just use that with `copy` as the function? Something like:

```
sage: from sage.misc.lazy_string import lazy_string
sage: LazyFormat('%s')%lazy_string(copy, 5)
5
```



---

archive/issue_comments_181684.json:
```json
{
    "body": "<a id='comment:242'></a>\nReplying to [tscrim](#comment%3A241):\n> Why can't we just use that with `copy` as the function? Something like:\n> \n> ```\n> sage: from sage.misc.lazy_string import lazy_string\n> sage: LazyFormat('%s')%lazy_string(copy, 5)\n> 5\n> ```\n\nMakes sense to me.",
    "created_at": "2014-03-18T17:00:57Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181684",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:242'></a>
Replying to [tscrim](#comment%3A241):
> Why can't we just use that with `copy` as the function? Something like:
> 
> ```
> sage: from sage.misc.lazy_string import lazy_string
> sage: LazyFormat('%s')%lazy_string(copy, 5)
> 5
> ```

Makes sense to me.



---

archive/issue_comments_181685.json:
```json
{
    "body": "<a id='comment:243'></a>\nReplying to [SimonKing](#comment%3A242):\n> Replying to [tscrim](#comment%3A241):\n> > Why can't we just use that with `copy` as the function? Something like:\n> > \n> > ```\n> > sage: from sage.misc.lazy_string import lazy_string\n> > sage: LazyFormat('%s')%lazy_string(copy, 5)\n> > 5\n> > ```\n\n> \n> Makes sense to me.\n\nThis may mean that by the time the string gets expanded, the domain of the weak map has already been garbage collected and that the copy may fail; now leading to a failure in error message production (which is even worse than an awkward error message). Can't we just live with a slightly more awkward error message; possibly combined with a slightly less awkward warning?",
    "created_at": "2014-03-18T18:08:06Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181685",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:243'></a>
Replying to [SimonKing](#comment%3A242):
> Replying to [tscrim](#comment%3A241):
> > Why can't we just use that with `copy` as the function? Something like:
> > 
> > ```
> > sage: from sage.misc.lazy_string import lazy_string
> > sage: LazyFormat('%s')%lazy_string(copy, 5)
> > 5
> > ```

> 
> Makes sense to me.

This may mean that by the time the string gets expanded, the domain of the weak map has already been garbage collected and that the copy may fail; now leading to a failure in error message production (which is even worse than an awkward error message). Can't we just live with a slightly more awkward error message; possibly combined with a slightly less awkward warning?



---

archive/issue_comments_181686.json:
```json
{
    "body": "<a id='comment:244'></a>\nReplying to [nbruin](#comment%3A243):\n> This may mean that by the time the string gets expanded, the domain of the weak map has already been garbage collected and that the copy may fail; now leading to a failure in error message production (which is even worse than an awkward error message). Can't we just live with a slightly more awkward error message; possibly combined with a slightly less awkward warning?\n\nEeek, you're right. However I believe we should not print the warning message when we're not exposing an object to the public.\n\nAnother option would be to print the warning message via `_repr_help` that Volker proposed in #15036 comment 20 for the internal maps. How do you feel about this?",
    "created_at": "2014-03-18T19:34:07Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181686",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:244'></a>
Replying to [nbruin](#comment%3A243):
> This may mean that by the time the string gets expanded, the domain of the weak map has already been garbage collected and that the copy may fail; now leading to a failure in error message production (which is even worse than an awkward error message). Can't we just live with a slightly more awkward error message; possibly combined with a slightly less awkward warning?

Eeek, you're right. However I believe we should not print the warning message when we're not exposing an object to the public.

Another option would be to print the warning message via `_repr_help` that Volker proposed in #15036 comment 20 for the internal maps. How do you feel about this?



---

archive/issue_comments_181687.json:
```json
{
    "body": "<a id='comment:245'></a>\nReplying to [tscrim](#comment%3A244):\n> Eeek, you're right. However I believe we should not print the warning message when we're not exposing an object to the public.\n\nThen you should probably just chop off the warning from the string, since that seems by far the cheapest option (other than coming up with an entirely new protocol):\n\n```\nsage: def fn(S):\n    i=S.find('\\n\\n        WARNING')\n    return S[:i] if i >=0 else S\nsage: phi=QQ._internal_coerce_map_from(ZZ)\nsage: timeit(\"str(phi)\")\n625 loops, best of 3: 15.7 \u00b5s per loop\nsage: timeit('str(phi).split(\"\\\\n\\\\n        WARNING\")[0]')\n625 loops, best of 3: 16 \u00b5s per loop\nsage: timeit(\"fn(str(phi))\")\n625 loops, best of 3: 16.9 \u00b5s per loop\nsage: timeit(\"str(copy(phi))\")\n625 loops, best of 3: 23.6 \u00b5s per loop\n```\nAnd to check the penalty on a normal, strong, map:\n\n```\nsage: psi=copy(phi)\nsage: timeit(\"str(psi)\")\n625 loops, best of 3: 9.97 \u00b5s per loop\nsage: timeit(\"fn(str(psi))\")\n625 loops, best of 3: 11.4 \u00b5s per loop\nsage: timeit('str(psi).split(\"\\\\n\\\\n        WARNING\")[0]')\n625 loops, best of 3: 11.1 \u00b5s per loop\n```\n\nWhether you do it lazily or upon creation of the error message is another matter, but I think this example shows that just stripping the \"WARNING\" from the string when that is absolutely required is cheap enough compared to producing the string in the first place. I do think it will be a source for confusion if we start printing objects in error messages differently from how they are normally represented.\n\nWould the following string rep perhaps be more acceptable?\n\n```\nsage: phi\n(internal coercion system map--copy before use) Natural morphism:\n  From: Integer Ring\n  To:   Rational Field\n```\n\n> Another option would be to print the warning message via `_repr_help` that Volker proposed in #15036 comment 20 for the internal maps. How do you feel about this?\n\nI think that's bad, because Volker's proposal serves a completely different purpose. This has nothing to do with something being printed at top-level or not, but with the context in which it is printed.",
    "created_at": "2014-03-18T21:33:15Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181687",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:245'></a>
Replying to [tscrim](#comment%3A244):
> Eeek, you're right. However I believe we should not print the warning message when we're not exposing an object to the public.

Then you should probably just chop off the warning from the string, since that seems by far the cheapest option (other than coming up with an entirely new protocol):

```
sage: def fn(S):
    i=S.find('\n\n        WARNING')
    return S[:i] if i >=0 else S
sage: phi=QQ._internal_coerce_map_from(ZZ)
sage: timeit("str(phi)")
625 loops, best of 3: 15.7 µs per loop
sage: timeit('str(phi).split("\\n\\n        WARNING")[0]')
625 loops, best of 3: 16 µs per loop
sage: timeit("fn(str(phi))")
625 loops, best of 3: 16.9 µs per loop
sage: timeit("str(copy(phi))")
625 loops, best of 3: 23.6 µs per loop
```
And to check the penalty on a normal, strong, map:

```
sage: psi=copy(phi)
sage: timeit("str(psi)")
625 loops, best of 3: 9.97 µs per loop
sage: timeit("fn(str(psi))")
625 loops, best of 3: 11.4 µs per loop
sage: timeit('str(psi).split("\\n\\n        WARNING")[0]')
625 loops, best of 3: 11.1 µs per loop
```

Whether you do it lazily or upon creation of the error message is another matter, but I think this example shows that just stripping the "WARNING" from the string when that is absolutely required is cheap enough compared to producing the string in the first place. I do think it will be a source for confusion if we start printing objects in error messages differently from how they are normally represented.

Would the following string rep perhaps be more acceptable?

```
sage: phi
(internal coercion system map--copy before use) Natural morphism:
  From: Integer Ring
  To:   Rational Field
```

> Another option would be to print the warning message via `_repr_help` that Volker proposed in #15036 comment 20 for the internal maps. How do you feel about this?

I think that's bad, because Volker's proposal serves a completely different purpose. This has nothing to do with something being printed at top-level or not, but with the context in which it is printed.



---

archive/issue_comments_181688.json:
```json
{
    "body": "<a id='comment:246'></a>\nReplying to [nbruin](#comment%3A245):\n> Then you should probably just chop off the warning from the string, since that seems by far the cheapest option (other than coming up with an entirely new protocol):\n\nI'm happy with doing it this way. Simon, Nicolas, Jean-Pierre, any objections?",
    "created_at": "2014-03-18T22:48:02Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181688",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:246'></a>
Replying to [nbruin](#comment%3A245):
> Then you should probably just chop off the warning from the string, since that seems by far the cheapest option (other than coming up with an entirely new protocol):

I'm happy with doing it this way. Simon, Nicolas, Jean-Pierre, any objections?



---

archive/issue_comments_181689.json:
```json
{
    "body": "<a id='comment:247'></a>\nReplying to [nbruin](#comment%3A245):\n> I do think it will be a source for confusion if we start printing objects in error messages differently from how they are normally represented.\n> \n> Would the following string rep perhaps be more acceptable?\n> \n> ```\n> sage: phi\n> (internal coercion system map--copy before use) Natural morphism:\n>   From: Integer Ring\n>   To:   Rational Field\n> ```\n\nI think it is better than my \"big fat warning\", and I prefer this solution over \"chopping off the warning\".",
    "created_at": "2014-03-19T06:23:20Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181689",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:247'></a>
Replying to [nbruin](#comment%3A245):
> I do think it will be a source for confusion if we start printing objects in error messages differently from how they are normally represented.
> 
> Would the following string rep perhaps be more acceptable?
> 
> ```
> sage: phi
> (internal coercion system map--copy before use) Natural morphism:
>   From: Integer Ring
>   To:   Rational Field
> ```

I think it is better than my "big fat warning", and I prefer this solution over "chopping off the warning".



---

archive/issue_comments_181690.json:
```json
{
    "body": "**Changing commit** from \"[ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf](https://github.com/sagemath/sagetrac-mirror/commit/ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf)\" to \"[f68550d17989e50adecc9c1d6634109095174003](https://github.com/sagemath/sagetrac-mirror/commit/f68550d17989e50adecc9c1d6634109095174003)\".",
    "created_at": "2014-03-24T17:07:49Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181690",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf](https://github.com/sagemath/sagetrac-mirror/commit/ea58b22f0bf2652e7d04b3d55e6217dcb8732cdf)" to "[f68550d17989e50adecc9c1d6634109095174003](https://github.com/sagemath/sagetrac-mirror/commit/f68550d17989e50adecc9c1d6634109095174003)".



---

archive/issue_comments_181691.json:
```json
{
    "body": "<a id='comment:8'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c7d070f7622de8f907d54ed567600c24e46a4963\">c7d070f</a></td><td><code>Merge branch 'public/ticket/14711' of trac.sagemath.org:sage into public/ticket/14711</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f68550d17989e50adecc9c1d6634109095174003\">f68550d</a></td><td><code>Fixed bad doctests from merge.</code></td></tr></table>\n",
    "created_at": "2014-03-24T17:07:49Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181691",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:8'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c7d070f7622de8f907d54ed567600c24e46a4963">c7d070f</a></td><td><code>Merge branch 'public/ticket/14711' of trac.sagemath.org:sage into public/ticket/14711</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f68550d17989e50adecc9c1d6634109095174003">f68550d</a></td><td><code>Fixed bad doctests from merge.</code></td></tr></table>




---

archive/issue_comments_181692.json:
```json
{
    "body": "<a id='comment:9'></a>\nRebased on 6.2.beta5.\n\nI'm not in favor of having any warning message displayed as part of an error message. Here's another option then (a variant on the optional arg):\n\nDefine `_repr_no_warning()` which does the main bulk of the string construction and then `_repr_` just adds the warning. Then for things which want to include the a possible internal map, they just call `_repr_no_warning()`.\n\nVariant on the above: instead of `_repr_no_warning()`, we override `__str__()` and have `TriangularModuleMorphism` call `str(self)`.\n\nOne more option: we change the warning message in `TriangularModuleMorphism` to not call `repr(self)` and instead spell some things out.\n\n---\n\nAt some point we will have to do something (one of us) considers evil. If people en masse think leaving an error message in there is the best course of action, I'll accept it.\n\nThoughts?",
    "created_at": "2014-03-24T17:26:18Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181692",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:9'></a>
Rebased on 6.2.beta5.

I'm not in favor of having any warning message displayed as part of an error message. Here's another option then (a variant on the optional arg):

Define `_repr_no_warning()` which does the main bulk of the string construction and then `_repr_` just adds the warning. Then for things which want to include the a possible internal map, they just call `_repr_no_warning()`.

Variant on the above: instead of `_repr_no_warning()`, we override `__str__()` and have `TriangularModuleMorphism` call `str(self)`.

One more option: we change the warning message in `TriangularModuleMorphism` to not call `repr(self)` and instead spell some things out.

---

At some point we will have to do something (one of us) considers evil. If people en masse think leaving an error message in there is the best course of action, I'll accept it.

Thoughts?



---

archive/issue_comments_181693.json:
```json
{
    "body": "<a id='comment:250'></a>\nReplying to [tscrim](#comment%3A249):\n> Define `_repr_no_warning()` which does the main bulk of the string construction and then `_repr_` just adds the warning. Then for things which want to include the a possible internal map, they just call `_repr_no_warning()`.\n\nI would be ok with that one.\n\nAnd we should definitely merge this ticket, so some compromise has to be reached.",
    "created_at": "2014-03-31T13:04:00Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181693",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:250'></a>
Replying to [tscrim](#comment%3A249):
> Define `_repr_no_warning()` which does the main bulk of the string construction and then `_repr_` just adds the warning. Then for things which want to include the a possible internal map, they just call `_repr_no_warning()`.

I would be ok with that one.

And we should definitely merge this ticket, so some compromise has to be reached.



---

archive/issue_comments_181694.json:
```json
{
    "body": "<a id='comment:1'></a>\nMy $0.02:\n- Don't overengineer this special case (i.e., don't add new API)\n- my preference would be to change the error messages to not include the maps. Those errors look ugly even without the warning in there and maps tend to print in a rather uninformative way anyway.\n- toning down the warning to just an informative prefix `(map internal to coercion system--copy before use)` would be fine with me\n- string chopping seems a reasonable alternative\n- it doesn't look like `TriangleModuleMorphism` is very time critical anyway, so a copy of the map would be OK too. If it becomes a bottleneck, it can be revisited.",
    "created_at": "2014-04-01T01:59:54Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181694",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:1'></a>
My $0.02:
- Don't overengineer this special case (i.e., don't add new API)
- my preference would be to change the error messages to not include the maps. Those errors look ugly even without the warning in there and maps tend to print in a rather uninformative way anyway.
- toning down the warning to just an informative prefix `(map internal to coercion system--copy before use)` would be fine with me
- string chopping seems a reasonable alternative
- it doesn't look like `TriangleModuleMorphism` is very time critical anyway, so a copy of the map would be OK too. If it becomes a bottleneck, it can be revisited.



---

archive/issue_comments_181695.json:
```json
{
    "body": "<a id='comment:2'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d91bfabb6d89333fb0237d1c97fbf830c3a7e2be\">d91bfab</a></td><td><code>Merge branch 'develop' into public/ticket/14711</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8e5fe42b226442ef1dc181de0838803f00b29638\">8e5fe42</a></td><td><code>Changed warning message to leaner version.</code></td></tr></table>\n",
    "created_at": "2014-04-02T07:01:37Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181695",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:2'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d91bfabb6d89333fb0237d1c97fbf830c3a7e2be">d91bfab</a></td><td><code>Merge branch 'develop' into public/ticket/14711</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8e5fe42b226442ef1dc181de0838803f00b29638">8e5fe42</a></td><td><code>Changed warning message to leaner version.</code></td></tr></table>




---

archive/issue_comments_181696.json:
```json
{
    "body": "**Changing commit** from \"[f68550d17989e50adecc9c1d6634109095174003](https://github.com/sagemath/sagetrac-mirror/commit/f68550d17989e50adecc9c1d6634109095174003)\" to \"[8e5fe42b226442ef1dc181de0838803f00b29638](https://github.com/sagemath/sagetrac-mirror/commit/8e5fe42b226442ef1dc181de0838803f00b29638)\".",
    "created_at": "2014-04-02T07:01:37Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181696",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f68550d17989e50adecc9c1d6634109095174003](https://github.com/sagemath/sagetrac-mirror/commit/f68550d17989e50adecc9c1d6634109095174003)" to "[8e5fe42b226442ef1dc181de0838803f00b29638](https://github.com/sagemath/sagetrac-mirror/commit/8e5fe42b226442ef1dc181de0838803f00b29638)".



---

archive/issue_comments_181697.json:
```json
{
    "body": "<a id='comment:3'></a>\nOkay, I've cut down the size of the warning and removed the printing of the map from the error message for `TriangularModuleMorphism` (which is more inline with python's error messages).",
    "created_at": "2014-04-02T07:04:48Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181697",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:3'></a>
Okay, I've cut down the size of the warning and removed the printing of the map from the error message for `TriangularModuleMorphism` (which is more inline with python's error messages).



---

archive/issue_comments_181698.json:
```json
{
    "body": "<a id='comment:4'></a>\nThese changes look good to me.",
    "created_at": "2014-04-02T07:13:32Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181698",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
These changes look good to me.



---

archive/issue_comments_181699.json:
```json
{
    "body": "<a id='comment:5'></a>\nJean-Pierre, any objections? Because I believe if you don't have any, we can set this to positive review and get this merged in.",
    "created_at": "2014-04-02T14:37:01Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181699",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:5'></a>
Jean-Pierre, any objections? Because I believe if you don't have any, we can set this to positive review and get this merged in.



---

archive/issue_comments_181700.json:
```json
{
    "body": "<a id='comment:6'></a>\nNot any objection, I want this merged asap.",
    "created_at": "2014-04-02T16:04:12Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181700",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```

<a id='comment:6'></a>
Not any objection, I want this merged asap.



---

archive/issue_events_128609.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/jpflori",
    "created_at": "2014-04-02T16:04:12Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128609"
}
```



---

archive/issue_events_128610.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/jpflori",
    "created_at": "2014-04-02T16:04:12Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128610"
}
```



---

archive/issue_events_128611.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-04-04T13:27:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128611"
}
```



---

archive/issue_events_128612.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-04-04T13:27:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128612"
}
```



---

archive/issue_comments_181701.json:
```json
{
    "body": "<a id='comment:7'></a>\n\n```\nsage -t --long src/sage/structure/coerce.pyx\n**********************************************************************\nFile \"src/sage/structure/coerce.pyx\", line 1180, in sage.structure.coerce.CoercionModel_cache_maps.discover_coercion\nFailed example:\n    cm.discover_coercion(RR, QQ)\nExpected:\n    (None,\n     Generic map:\n      From: Rational Field\n      To:   Real Field with 53 bits of precision...)\nGot:\n    (None, (map internal to coercion system -- copy before use)\n    Generic map:\n      From: Rational Field\n      To:   Real Field with 53 bits of precision)\n**********************************************************************\n```",
    "created_at": "2014-04-04T13:27:49Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181701",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:7'></a>

```
sage -t --long src/sage/structure/coerce.pyx
**********************************************************************
File "src/sage/structure/coerce.pyx", line 1180, in sage.structure.coerce.CoercionModel_cache_maps.discover_coercion
Failed example:
    cm.discover_coercion(RR, QQ)
Expected:
    (None,
     Generic map:
      From: Rational Field
      To:   Real Field with 53 bits of precision...)
Got:
    (None, (map internal to coercion system -- copy before use)
    Generic map:
      From: Rational Field
      To:   Real Field with 53 bits of precision)
**********************************************************************
```



---

archive/issue_comments_181702.json:
```json
{
    "body": "<a id='comment:8'></a>\nAlso:\n\n```\nsage -t --long src/sage/tests/book_schilling_zabrocki_kschur_primer.py\n**********************************************************************\nFile \"src/sage/tests/book_schilling_zabrocki_kschur_primer.py\", line 619, in sage.tests.book_schilling_zabrocki_kschur_primer\nFailed example:\n    ks3([3,2]).omega()\nExpected:\n    Traceback (most recent call last):\n    ...\n    ValueError: t^2*s[1, 1, 1, 1, 1] + t*s[2, 1, 1, 1] + s[2, 2, 1] is not\n    in the image of Generic morphism:\n    From: 3-bounded Symmetric Functions over Fraction Field of Univariate\n    Polynomial Ring in t over Rational Field in the 3-Schur basis\n    To:   Symmetric Functions over Fraction Field of Univariate Polynomial Ring\n    in t over Rational Field in the Schur basis\nGot:\n    <BLANKLINE>\n    Traceback (most recent call last):\n      File \"/home/release/Sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 480, in _run\n        self.execute(example, compiled, test.globs)\n      File \"/home/release/Sage/local/lib/python2.7/site-packages/sage/doctest/forker.py\", line 839, in execute\n        exec compiled in globs\n      File \"<doctest sage.tests.book_schilling_zabrocki_kschur_primer[214]>\", line 1, in <module>\n        ks3([Integer(3),Integer(2)]).omega()\n      File \"/home/release/Sage/local/lib/python2.7/site-packages/sage/combinat/sf/new_kschur.py\", line 715, in omega\n        return self.parent()(self.lift().omega())\n      File \"parent.pyx\", line 1070, in sage.structure.parent.Parent.__call__ (sage/structure/parent.c:8858)\n      File \"morphism.pyx\", line 431, in sage.categories.morphism.SetMorphism._call_ (sage/categories/morphism.c:6519)\n      File \"/home/release/Sage/local/lib/python2.7/site-packages/sage/categories/modules_with_basis.py\", line 1830, in preimage\n        raise ValueError(\"{} is not in the image\".format(f))\n    ValueError: t^2*s[1, 1, 1, 1, 1] + t*s[2, 1, 1, 1] + s[2, 2, 1] is not in the image\n**********************************************************************\n```",
    "created_at": "2014-04-04T13:30:08Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181702",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:8'></a>
Also:

```
sage -t --long src/sage/tests/book_schilling_zabrocki_kschur_primer.py
**********************************************************************
File "src/sage/tests/book_schilling_zabrocki_kschur_primer.py", line 619, in sage.tests.book_schilling_zabrocki_kschur_primer
Failed example:
    ks3([3,2]).omega()
Expected:
    Traceback (most recent call last):
    ...
    ValueError: t^2*s[1, 1, 1, 1, 1] + t*s[2, 1, 1, 1] + s[2, 2, 1] is not
    in the image of Generic morphism:
    From: 3-bounded Symmetric Functions over Fraction Field of Univariate
    Polynomial Ring in t over Rational Field in the 3-Schur basis
    To:   Symmetric Functions over Fraction Field of Univariate Polynomial Ring
    in t over Rational Field in the Schur basis
Got:
    <BLANKLINE>
    Traceback (most recent call last):
      File "/home/release/Sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 480, in _run
        self.execute(example, compiled, test.globs)
      File "/home/release/Sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 839, in execute
        exec compiled in globs
      File "<doctest sage.tests.book_schilling_zabrocki_kschur_primer[214]>", line 1, in <module>
        ks3([Integer(3),Integer(2)]).omega()
      File "/home/release/Sage/local/lib/python2.7/site-packages/sage/combinat/sf/new_kschur.py", line 715, in omega
        return self.parent()(self.lift().omega())
      File "parent.pyx", line 1070, in sage.structure.parent.Parent.__call__ (sage/structure/parent.c:8858)
      File "morphism.pyx", line 431, in sage.categories.morphism.SetMorphism._call_ (sage/categories/morphism.c:6519)
      File "/home/release/Sage/local/lib/python2.7/site-packages/sage/categories/modules_with_basis.py", line 1830, in preimage
        raise ValueError("{} is not in the image".format(f))
    ValueError: t^2*s[1, 1, 1, 1, 1] + t*s[2, 1, 1, 1] + s[2, 2, 1] is not in the image
**********************************************************************
```



---

archive/issue_comments_181703.json:
```json
{
    "body": "<a id='comment:9'></a>\n??? I tested `coerce.pyx` so many times I lost track. Anyways, I've fixed the doctests, but waiting on my sage to recompile to do a final check.",
    "created_at": "2014-04-04T14:50:41Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181703",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:9'></a>
??? I tested `coerce.pyx` so many times I lost track. Anyways, I've fixed the doctests, but waiting on my sage to recompile to do a final check.



---

archive/issue_comments_181704.json:
```json
{
    "body": "<a id='comment:0'></a>\nAnne, Mike - More changes to the k-schur book...",
    "created_at": "2014-04-04T14:52:02Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181704",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:0'></a>
Anne, Mike - More changes to the k-schur book...



---

archive/issue_comments_181705.json:
```json
{
    "body": "<a id='comment:261'></a>\nReplying to [tscrim](#comment%3A259):\n> ??? I tested `coerce.pyx` so many times I lost track. I've fixed the doctests, but waiting on my sage to recompile to do a final check.\n\nKeep cool, these failures look totally trivial. While we are at it: Thank you very much for finishing these patches. I could currently not work on it myself.",
    "created_at": "2014-04-04T14:52:51Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181705",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:261'></a>
Replying to [tscrim](#comment%3A259):
> ??? I tested `coerce.pyx` so many times I lost track. I've fixed the doctests, but waiting on my sage to recompile to do a final check.

Keep cool, these failures look totally trivial. While we are at it: Thank you very much for finishing these patches. I could currently not work on it myself.



---

archive/issue_comments_181706.json:
```json
{
    "body": "<a id='comment:2'></a>\nI really need to figure out how to get `ccache` to work, so as to avoid those long recompiles (I think I'm about 50/238 files in :/).",
    "created_at": "2014-04-04T15:08:44Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181706",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:2'></a>
I really need to figure out how to get `ccache` to work, so as to avoid those long recompiles (I think I'm about 50/238 files in :/).



---

archive/issue_comments_181707.json:
```json
{
    "body": "<a id='comment:3'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7\">00b3e2f</a></td><td><code>Fixed doctests.</code></td></tr></table>\n",
    "created_at": "2014-04-04T15:41:36Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181707",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:3'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7">00b3e2f</a></td><td><code>Fixed doctests.</code></td></tr></table>




---

archive/issue_comments_181708.json:
```json
{
    "body": "**Changing commit** from \"[8e5fe42b226442ef1dc181de0838803f00b29638](https://github.com/sagemath/sagetrac-mirror/commit/8e5fe42b226442ef1dc181de0838803f00b29638)\" to \"[00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7](https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7)\".",
    "created_at": "2014-04-04T15:41:36Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181708",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[8e5fe42b226442ef1dc181de0838803f00b29638](https://github.com/sagemath/sagetrac-mirror/commit/8e5fe42b226442ef1dc181de0838803f00b29638)" to "[00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7](https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7)".



---

archive/issue_comments_181709.json:
```json
{
    "body": "<a id='comment:4'></a>\nFixed. Took 51 minutes for my Sage to recompile itself. Now to have it recompile again!",
    "created_at": "2014-04-04T15:42:42Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181709",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:4'></a>
Fixed. Took 51 minutes for my Sage to recompile itself. Now to have it recompile again!



---

archive/issue_events_128613.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2014-04-04T15:42:42Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128613"
}
```



---

archive/issue_events_128614.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2014-04-04T15:42:42Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128614"
}
```



---

archive/issue_comments_181710.json:
```json
{
    "body": "<a id='comment:265'></a>\nReplying to [tscrim](#comment%3A262):\n> I really need to figure out how to get `ccache` to work\n\n`sage -i ccache` doesn't work for you?",
    "created_at": "2014-04-04T16:44:17Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181710",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:265'></a>
Replying to [tscrim](#comment%3A262):
> I really need to figure out how to get `ccache` to work

`sage -i ccache` doesn't work for you?



---

archive/issue_comments_181711.json:
```json
{
    "body": "<a id='comment:266'></a>\nReplying to [tscrim](#comment%3A260):\n> Anne, Mike - More changes to the k-schur book...\n\nDo you really think that it is a good idea to remove valuable information? Now\n\n```\n    sage: Sym = SymmetricFunctions(FractionField(QQ[\"t\"]))\n    sage: ks3 = Sym.kschur(3)\n    sage: ks3([3,2]).omega()\n    Traceback (most recent call last):\n    ...\n    ValueError: t^2*s[1, 1, 1, 1, 1] + t*s[2, 1, 1, 1] + s[2, 2, 1] is not \n    in the image\n```\nBefore\n\n```\n    sage: Sym = SymmetricFunctions(FractionField(QQ[\"t\"]))\n    sage: ks3 = Sym.kschur(3)\n    sage: ks3([3,2]).omega()\n    Traceback (most recent call last):\n    ...\n    ValueError: t^2*s[1, 1, 1, 1, 1] + t*s[2, 1, 1, 1] + s[2, 2, 1] is not \n    in the image of Generic morphism\"\n    From: 3-bounded Symmetric Functions over Fraction Field of Univariate \n    Polynomial Ring in t over Rational Field in the 3-Schur basis\n    To:   Symmetric Functions over Fraction Field of Univariate Polynomial Ring\n    in t over Rational Field in the Schur basis\n```",
    "created_at": "2014-04-04T19:39:36Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181711",
    "user": "https://github.com/anneschilling"
}
```

<a id='comment:266'></a>
Replying to [tscrim](#comment%3A260):
> Anne, Mike - More changes to the k-schur book...

Do you really think that it is a good idea to remove valuable information? Now

```
    sage: Sym = SymmetricFunctions(FractionField(QQ["t"]))
    sage: ks3 = Sym.kschur(3)
    sage: ks3([3,2]).omega()
    Traceback (most recent call last):
    ...
    ValueError: t^2*s[1, 1, 1, 1, 1] + t*s[2, 1, 1, 1] + s[2, 2, 1] is not 
    in the image
```
Before

```
    sage: Sym = SymmetricFunctions(FractionField(QQ["t"]))
    sage: ks3 = Sym.kschur(3)
    sage: ks3([3,2]).omega()
    Traceback (most recent call last):
    ...
    ValueError: t^2*s[1, 1, 1, 1, 1] + t*s[2, 1, 1, 1] + s[2, 2, 1] is not 
    in the image of Generic morphism"
    From: 3-bounded Symmetric Functions over Fraction Field of Univariate 
    Polynomial Ring in t over Rational Field in the 3-Schur basis
    To:   Symmetric Functions over Fraction Field of Univariate Polynomial Ring
    in t over Rational Field in the Schur basis
```



---

archive/issue_comments_181712.json:
```json
{
    "body": "<a id='comment:7'></a>\nI don't think the information about a generic statement of a map is useful. I think if you come across this error message you either:\n- know the morphism you're trying explicitly (such as the coercion in the example) and are feeding it bad data, or\n- it's buried deep or implicitly in your code and you have a bug somewhere (to which you can use some print statements or pdb to figure out what map it is).\n\nIMO, it really is the error message (and the traceback) that carries the pertinent information, not saying what domain <-> codomain is actually raising the error message.",
    "created_at": "2014-04-04T22:19:32Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181712",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:7'></a>
I don't think the information about a generic statement of a map is useful. I think if you come across this error message you either:
- know the morphism you're trying explicitly (such as the coercion in the example) and are feeding it bad data, or
- it's buried deep or implicitly in your code and you have a bug somewhere (to which you can use some print statements or pdb to figure out what map it is).

IMO, it really is the error message (and the traceback) that carries the pertinent information, not saying what domain <-> codomain is actually raising the error message.



---

archive/issue_events_128615.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-04-05T10:43:50Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128615"
}
```



---

archive/issue_events_128616.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "5aa9842f06b0fbc8b9412e972b7df849b1fce937",
    "created_at": "2014-04-05T10:43:50Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/14711#event-128616"
}
```



---

archive/issue_comments_181713.json:
```json
{
    "body": "**Changing branch** from \"[public/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/14711)\" to \"[00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7](https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7)\".",
    "created_at": "2014-04-05T10:43:50Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181713",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[public/ticket/14711](https://github.com/sagemath/sagetrac-mirror/tree/public/ticket/14711)" to "[00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7](https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7)".



---

archive/issue_comments_181714.json:
```json
{
    "body": "**Changing commit** from \"[00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7](https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7)\" to \"\".",
    "created_at": "2018-02-14T08:35:03Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181714",
    "user": "https://github.com/jdemeyer"
}
```

**Changing commit** from "[00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7](https://github.com/sagemath/sagetrac-mirror/commit/00b3e2f3cf90b5e7a339367f8ad4e08e1f0fb3d7)" to "".



---

archive/issue_comments_181715.json:
```json
{
    "body": "Replying to [ticket:14711 jpflori]:\n> `SchemeMorphism` can not inherit from `Morphism`, because of a bug with\n> multiple inheritance of a Python class from Cython extension classes.\n\nDoes anybody have a reference to this bug? I see only comments about \"a bug in Cython\" without any specifics.",
    "created_at": "2018-02-14T08:35:03Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181715",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [ticket:14711 jpflori]:
> `SchemeMorphism` can not inherit from `Morphism`, because of a bug with
> multiple inheritance of a Python class from Cython extension classes.

Does anybody have a reference to this bug? I see only comments about "a bug in Cython" without any specifics.



---

archive/issue_comments_181716.json:
```json
{
    "body": "<a id='comment:0'></a>\nThere is [comment:92](#comment%3A92) for a bit more specifics. It might also be some shadow of https://github.com/cython/cython/issues/1732 or have worked itself out in Cython upgrades. IDK, I could not explicitly reproduce any failures. (Although this was done before I was looking at this ticket.)",
    "created_at": "2018-02-14T12:17:57Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181716",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:0'></a>
There is [comment:92](#comment%3A92) for a bit more specifics. It might also be some shadow of https://github.com/cython/cython/issues/1732 or have worked itself out in Cython upgrades. IDK, I could not explicitly reproduce any failures. (Although this was done before I was looking at this ticket.)



---

archive/issue_comments_181717.json:
```json
{
    "body": "<a id='comment:271'></a>\nReplying to [tscrim](#comment%3A270):\n> It might also be some shadow of https://github.com/cython/cython/issues/1732\n\nI doubt it because that is specifically about overriding `cdef` methods with `cpdef` methods. I don't think that Sage did that before my relatively recent changes to the coercion model.",
    "created_at": "2018-02-14T12:41:57Z",
    "issue": "https://github.com/sagemath/sage/issues/14711",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/14711#issuecomment-181717",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:271'></a>
Replying to [tscrim](#comment%3A270):
> It might also be some shadow of https://github.com/cython/cython/issues/1732

I doubt it because that is specifically about overriding `cdef` methods with `cpdef` methods. I don't think that Sage did that before my relatively recent changes to the coercion model.
