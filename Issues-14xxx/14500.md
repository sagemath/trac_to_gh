# Issue 14500: Use GMP's mpz_t for bitsets

archive/issues_014500.json:
```json
{
    "body": "Assignee: @jasongrout\n\nCC:  @jasongrout @dcoudert @nathanncohen @robertwb\n\nIt was suggested on #14668 that GMP has a type mpz_t that is very much like Sage's bitset_t.\n\nThe goal of this ticket: attempt to use mpz_t as base data structure for bitsets and see if it results in a speedup.\n\nIssue created by migration from https://trac.sagemath.org/ticket/14704\n\n",
    "closed_at": "2014-01-09T06:44:27Z",
    "created_at": "2013-06-08T14:08:47Z",
    "labels": [
        "component: misc",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "Use GMP's mpz_t for bitsets",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14500",
    "user": "https://trac.sagemath.org/admin/accounts/users/Stefan"
}
```
Assignee: @jasongrout

CC:  @jasongrout @dcoudert @nathanncohen @robertwb

It was suggested on #14668 that GMP has a type mpz_t that is very much like Sage's bitset_t.

The goal of this ticket: attempt to use mpz_t as base data structure for bitsets and see if it results in a speedup.

Issue created by migration from https://trac.sagemath.org/ticket/14704





---

archive/issue_comments_183345.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2013-06-08T14:09:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183345",
    "user": "https://trac.sagemath.org/admin/accounts/users/Stefan"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_183346.json:
```json
{
    "body": "Note that (AFAIK, haven't looked at it recently) the implementation of the usual operations is pretty dumb (i.e., generic and not using any machine-specific features), so you may get even worse performance (compared to \"direct\" implementations in C, say).",
    "created_at": "2013-06-08T15:01:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183346",
    "user": "https://github.com/nexttime"
}
```

Note that (AFAIK, haven't looked at it recently) the implementation of the usual operations is pretty dumb (i.e., generic and not using any machine-specific features), so you may get even worse performance (compared to "direct" implementations in C, say).



---

archive/issue_comments_183347.json:
```json
{
    "body": "Yes, I was afraid of that; that's why I think we should definitely test it before committing to it.",
    "created_at": "2013-06-08T15:12:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183347",
    "user": "https://github.com/jasongrout"
}
```

Yes, I was afraid of that; that's why I think we should definitely test it before committing to it.



---

archive/issue_comments_183348.json:
```json
{
    "body": "Replying to [comment:3 jason]:\n> Yes, I was afraid of that; that's why I think we should definitely test it before committing to it.\n\n\nMaybe I missed something w.r.t. GMP, but MPIR appears to have asm implementations for a couple of operations.",
    "created_at": "2013-06-08T15:14:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183348",
    "user": "https://github.com/nexttime"
}
```

Replying to [comment:3 jason]:
> Yes, I was afraid of that; that's why I think we should definitely test it before committing to it.


Maybe I missed something w.r.t. GMP, but MPIR appears to have asm implementations for a couple of operations.



---

archive/issue_comments_183349.json:
```json
{
    "body": "Replying to [comment:4 leif]:\n> Replying to [comment:3 jason]:\n> > Yes, I was afraid of that; that's why I think we should definitely test it before committing to it.\n\n> \n> Maybe I missed something w.r.t. GMP, but MPIR appears to have asm implementations for a couple of operations.\n\n\nP.S.:\n\n(GMP does also have at least some.)\n\nWhich doesn't mean that using them is guaranteed to be faster in all cases; there still remains some overhead and a level of indirection.\n\nFor small or fixed-size bitsets for example, using a custom C implementation (with macros or inline functions) can still be faster.  (And it could further be sped up by using inline assembly or compiler built-ins.)",
    "created_at": "2013-06-08T16:39:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183349",
    "user": "https://github.com/nexttime"
}
```

Replying to [comment:4 leif]:
> Replying to [comment:3 jason]:
> > Yes, I was afraid of that; that's why I think we should definitely test it before committing to it.

> 
> Maybe I missed something w.r.t. GMP, but MPIR appears to have asm implementations for a couple of operations.


P.S.:

(GMP does also have at least some.)

Which doesn't mean that using them is guaranteed to be faster in all cases; there still remains some overhead and a level of indirection.

For small or fixed-size bitsets for example, using a custom C implementation (with macros or inline functions) can still be faster.  (And it could further be sped up by using inline assembly or compiler built-ins.)



---

archive/issue_comments_183350.json:
```json
{
    "body": "I agree that for small bitsets, one can possibly produce a very fast implementation in C. But then you should implement a \"small-size-bitset\" type with all dedicated and optimized methods. I'm not sure it is worth the effort.\n\nSince GMP / MPIR (I don't know which one is the best) are already used by sage and are reasonably fast, It is interesting to use them for bitsets or at least to try. I assume they use calls to low level / build in methods.",
    "created_at": "2013-06-08T17:21:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183350",
    "user": "https://github.com/dcoudert"
}
```

I agree that for small bitsets, one can possibly produce a very fast implementation in C. But then you should implement a "small-size-bitset" type with all dedicated and optimized methods. I'm not sure it is worth the effort.

Since GMP / MPIR (I don't know which one is the best) are already used by sage and are reasonably fast, It is interesting to use them for bitsets or at least to try. I assume they use calls to low level / build in methods.



---

archive/issue_comments_183351.json:
```json
{
    "body": "CCing Robert Bradshaw, since he's an expert in such things.",
    "created_at": "2013-06-08T17:26:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183351",
    "user": "https://github.com/jasongrout"
}
```

CCing Robert Bradshaw, since he's an expert in such things.



---

archive/issue_comments_183352.json:
```json
{
    "body": "Well, the main disadvantage of using GMP's / MPIR's functions is that the compiler has no chance to inline them / do further optimizations depending on the context, and that you get another level of boxing (`mpz_t` points to a structure containing a pointer to the actual data / the limbs).\n\nSo whether it's worth heavily depends on the application / use case.\n\nBut we could of course (probably dynamically) use different implementations, whichever fits best in the specific case.",
    "created_at": "2013-06-08T17:49:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183352",
    "user": "https://github.com/nexttime"
}
```

Well, the main disadvantage of using GMP's / MPIR's functions is that the compiler has no chance to inline them / do further optimizations depending on the context, and that you get another level of boxing (`mpz_t` points to a structure containing a pointer to the actual data / the limbs).

So whether it's worth heavily depends on the application / use case.

But we could of course (probably dynamically) use different implementations, whichever fits best in the specific case.



---

archive/issue_comments_183353.json:
```json
{
    "body": "The only way to know for sure is to code something up and compare performance, until then all discussion is rather hypothetical (and I could see things going both ways, but probably would place my bet on mpz_t.)\n\nNote that mpz_t could be a member of the bitset struct (if indeed another struct is needed) which would avoid one level of indirection. It may be worth looking at using the mpn structures directly for this low-level behavior as well.",
    "created_at": "2013-06-10T16:03:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183353",
    "user": "https://github.com/robertwb"
}
```

The only way to know for sure is to code something up and compare performance, until then all discussion is rather hypothetical (and I could see things going both ways, but probably would place my bet on mpz_t.)

Note that mpz_t could be a member of the bitset struct (if indeed another struct is needed) which would avoid one level of indirection. It may be worth looking at using the mpn structures directly for this low-level behavior as well.



---

archive/issue_comments_183354.json:
```json
{
    "body": "Replying to [comment:9 robertwb]:\n> The only way to know for sure is to code something up and compare performance, until then all discussion is rather hypothetical (and I could see things going both ways, but probably would place my bet on mpz_t.)\n\n\nWell, you do not only need different implementations, but also typical use cases to make comparisons meaningful.\n\n\n\n\n> Note that mpz_t could be a member of the bitset struct (if indeed another struct is needed) which would avoid one level of indirection. It may be worth looking at using the mpn structures directly for this low-level behavior as well. \n\n\nI actually did not think of not making it part of some bitset structure.  (But the pointer to the limbs remains.)\n\nNote that GMP operates on limbs, so the (logical) \"size\" of a plain `mpz_t` bitset would always be a multiple of `BITS_PER_LIMB`.  (And we certainly don't need the \"sign\" of a bitset; GMP's treatment may even disturb.)\n\nIt would probably make sense to (optionally) keep track of the least and largest element contained in a set, and perhaps its cardinality as well, depending on the application.",
    "created_at": "2013-06-10T16:56:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183354",
    "user": "https://github.com/nexttime"
}
```

Replying to [comment:9 robertwb]:
> The only way to know for sure is to code something up and compare performance, until then all discussion is rather hypothetical (and I could see things going both ways, but probably would place my bet on mpz_t.)


Well, you do not only need different implementations, but also typical use cases to make comparisons meaningful.




> Note that mpz_t could be a member of the bitset struct (if indeed another struct is needed) which would avoid one level of indirection. It may be worth looking at using the mpn structures directly for this low-level behavior as well. 


I actually did not think of not making it part of some bitset structure.  (But the pointer to the limbs remains.)

Note that GMP operates on limbs, so the (logical) "size" of a plain `mpz_t` bitset would always be a multiple of `BITS_PER_LIMB`.  (And we certainly don't need the "sign" of a bitset; GMP's treatment may even disturb.)

It would probably make sense to (optionally) keep track of the least and largest element contained in a set, and perhaps its cardinality as well, depending on the application.



---

archive/issue_comments_183355.json:
```json
{
    "body": "Replying to [comment:10 leif]:\n> Note that GMP operates on limbs, so the (logical) \"size\" of a plain `mpz_t` bitset would always be a multiple of `BITS_PER_LIMB`.  (And we certainly don't need the \"sign\" of a bitset; GMP's treatment may even disturb.)\n\n\nJust to elaborate a bit the subtle issues one has to take care of:\n\n```c\n#include <gmp.h>\n\nint main(void)\n{\n  mpz_t bs;\n  int i;\n\n  mpz_init2(bs,(mp_bitcnt_t)(1UL<<16)); // 2^16 *bits*\n  gmp_printf(\"empty bitset:\\n\"\n   \"  size=%d alloc=%d value=%Zd popcnt=%lu\\n\",\n    bs[0]._mp_size,\n    bs[0]._mp_alloc,\n    bs,\n    (unsigned long)mpz_popcount(bs));\n    \n  mpz_com(bs,bs); // complement\n  gmp_printf(\"empty bitset complemented:\\n\"\n     \"  size=%d alloc=%d value=... popcnt=%lu\\n\",\n      bs[0]._mp_size,\n      bs[0]._mp_alloc,\n      /* bs, */\n      (unsigned long)mpz_popcount(bs));\n\n  // restore logical size:\n  bs[0]._mp_size=1024; // 64-bit *limbs*; 2^16=64*1024\n  gmp_printf(\"with (logical) size \\\"restored\\\":\\n\"\n    \"  size=%d alloc=%d value=... popcnt=%lu\\n\",\n    bs[0]._mp_size,\n    bs[0]._mp_alloc,\n    /* bs, */\n    (unsigned long)mpz_popcount(bs));\n\n  // (construct) complement (of empty bitset) \"manually\":\n  for(i=0;i<1024;i++)\n    bs[0]._mp_d[i]=~0UL;\n  gmp_printf(\"empty bitset manually complemented:\\n\"\n    \"  size=%d alloc=%d value=... popcnt=%lu\\n\",\n    bs[0]._mp_size,\n    bs[0]._mp_alloc,\n    /* bs, */\n    (unsigned long)mpz_popcount(bs));\n\n  mpz_clear(bs);\n  return 0;\n}\n```\ngives\n\n```\nempty bitset:\n  size=0 alloc=1024 value=0 popcnt=0\nempty bitset complemented:\n  size=-1 alloc=1024 value=... popcnt=18446744073709551615\nwith (logical) size \"restored\":\n  size=1024 alloc=1024 value=... popcnt=1\nempty bitset manually complemented:\n  size=1024 alloc=1024 value=... popcnt=65536\n```\n\n(Note that I've \"hardcoded\" 64-bit limbs / assumption is that `sizeof(long)==8`.)",
    "created_at": "2013-06-10T17:41:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183355",
    "user": "https://github.com/nexttime"
}
```

Replying to [comment:10 leif]:
> Note that GMP operates on limbs, so the (logical) "size" of a plain `mpz_t` bitset would always be a multiple of `BITS_PER_LIMB`.  (And we certainly don't need the "sign" of a bitset; GMP's treatment may even disturb.)


Just to elaborate a bit the subtle issues one has to take care of:

```c
#include <gmp.h>

int main(void)
{
  mpz_t bs;
  int i;

  mpz_init2(bs,(mp_bitcnt_t)(1UL<<16)); // 2^16 *bits*
  gmp_printf("empty bitset:\n"
   "  size=%d alloc=%d value=%Zd popcnt=%lu\n",
    bs[0]._mp_size,
    bs[0]._mp_alloc,
    bs,
    (unsigned long)mpz_popcount(bs));
    
  mpz_com(bs,bs); // complement
  gmp_printf("empty bitset complemented:\n"
     "  size=%d alloc=%d value=... popcnt=%lu\n",
      bs[0]._mp_size,
      bs[0]._mp_alloc,
      /* bs, */
      (unsigned long)mpz_popcount(bs));

  // restore logical size:
  bs[0]._mp_size=1024; // 64-bit *limbs*; 2^16=64*1024
  gmp_printf("with (logical) size \"restored\":\n"
    "  size=%d alloc=%d value=... popcnt=%lu\n",
    bs[0]._mp_size,
    bs[0]._mp_alloc,
    /* bs, */
    (unsigned long)mpz_popcount(bs));

  // (construct) complement (of empty bitset) "manually":
  for(i=0;i<1024;i++)
    bs[0]._mp_d[i]=~0UL;
  gmp_printf("empty bitset manually complemented:\n"
    "  size=%d alloc=%d value=... popcnt=%lu\n",
    bs[0]._mp_size,
    bs[0]._mp_alloc,
    /* bs, */
    (unsigned long)mpz_popcount(bs));

  mpz_clear(bs);
  return 0;
}
```
gives

```
empty bitset:
  size=0 alloc=1024 value=0 popcnt=0
empty bitset complemented:
  size=-1 alloc=1024 value=... popcnt=18446744073709551615
with (logical) size "restored":
  size=1024 alloc=1024 value=... popcnt=1
empty bitset manually complemented:
  size=1024 alloc=1024 value=... popcnt=65536
```

(Note that I've "hardcoded" 64-bit limbs / assumption is that `sizeof(long)==8`.)



---

archive/issue_comments_183356.json:
```json
{
    "body": "Note that the current bitset code also deals with limbs...",
    "created_at": "2013-06-11T05:50:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183356",
    "user": "https://github.com/jasongrout"
}
```

Note that the current bitset code also deals with limbs...



---

archive/issue_comments_183357.json:
```json
{
    "body": "Alternatively: keep the `bitset_t` type but use some `mpn` functions in the implementation, see #13352 for a proof-of-concept with the `mpn_popcount()` function. I think that's a much better alternative than `mpz_t` because\n1. `mpz_t` has a sign which we don't need.\n2. `mpz_t` does not have a \"size\" (number of bits) which we do need.\n3. `mpz_t` is used to represent numbers which have the most significant bit set to 1. It cannot really deal with a long bitstring consisting of only zeros for example.\n\nProposal: close this ticket as \"wontfix\".",
    "created_at": "2013-12-10T13:05:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183357",
    "user": "https://github.com/jdemeyer"
}
```

Alternatively: keep the `bitset_t` type but use some `mpn` functions in the implementation, see #13352 for a proof-of-concept with the `mpn_popcount()` function. I think that's a much better alternative than `mpz_t` because
1. `mpz_t` has a sign which we don't need.
2. `mpz_t` does not have a "size" (number of bits) which we do need.
3. `mpz_t` is used to represent numbers which have the most significant bit set to 1. It cannot really deal with a long bitstring consisting of only zeros for example.

Proposal: close this ticket as "wontfix".



---

archive/issue_comments_183358.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-01-07T15:49:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183358",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_events_042111.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2014-01-07T15:49:59Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14500#event-42111"
}
```



---

archive/issue_comments_183359.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-01-07T15:50:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183359",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_042112.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-01-09T06:44:27Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/14500#event-42112"
}
```



---

archive/issue_comments_183360.json:
```json
{
    "body": "Resolution: wontfix",
    "created_at": "2014-01-09T06:44:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14500",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14500#issuecomment-183360",
    "user": "https://github.com/vbraun"
}
```

Resolution: wontfix
