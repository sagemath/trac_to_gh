# Issue 10476: dimension() and is_smooth() for algebraic subschemes of toric varieties

Issue created by migration from https://trac.sagemath.org/ticket/10529

Original creator: vbraun

Original creation time: 2010-12-27 22:45:13

Assignee: AlexGhitza

CC:  novoselt

The purpose of this ticket is to implement `dimension()` and a `is_smooth()` method for algebraic subschemes of toric varieties, that is, not necessarily complete intersection subschemes.

This patch does not yet deal properly with singular ambient toric varieties. This will be implemented in a different ticket since this part has further dependencies.


---

Comment by vbraun created at 2010-12-28 00:12:04

Changing status from new to needs_review.


---

Comment by vbraun created at 2010-12-28 17:13:49

For the trac bot:

Depends on #10525

Apply trac_10529_toric_variety_library_names.patch, trac_10529_MPolynomialIdeal_subs.patch, trac_10529_QuotientRingElement_call.patch, trac_10529_SubschemeMorphisms_without_QuotientRing.patch, trac_10529_smoothness_of_algebraic_subschemes.patch


---

Comment by vbraun created at 2011-01-19 03:58:08

Updated patch for sage-4.6.2.alpha0


---

Attachment

For the patch bot: 
Depends on #9055, #10525


---

Comment by novoselt created at 2011-02-23 03:47:39

Hi Volker, I guess I better start reviewing this ticket. Little picks at the first patch (trac_10529_toric_variety_library_names.patch).

 1. It seems that instead of
 {{{
    - ``names`` -- an alias of ``coordinate_names`` for internal
      use. Takes precedence if set.
}}}
 you mean to say
 {{{
    - ``names`` -- an alias of ``coordinate_names`` for internal
      use, cannot be specified together with ``coordinate_names``;
}}}
 and I think that instead of 
 {{{
    if not names is None:
        assert coordinate_names is None, \
            'You must not specify both coordinate_names and names!'
        coordinate_names = names
}}}
 it would be better to have
 {{{
    if names is not None:
        if coordinate_names is not None:
            raise ValueError('You must not specify both coordinate_names and names!')
        coordinate_names = names
}}}

 2. When you write
 {{{
dict_key = '_ '+name+' '+'_'.join(coordinate_names) 
}}}
 is it intentional that there is a space after the first underscore? Also, did you mean to join coordinate names with underscores? Look at this:
 {{{
sage: toric_varieties.__dict__
{}
sage: toric_varieties.P2()    
2-d CPR-Fano toric variety covered by 3 affine patches
sage: toric_varieties.__dict__
{'_ P2 x_ _y_ _z': 2-d CPR-Fano toric variety covered by 3 affine patches}
}}}
 If you meant to create a key `_P2_x_y_z`, I suggest using `normalize_names` from `toric_variety` on coordinate names before joining them and, of course, removing the space. Since you directly work with `__dict__` it is fine even with spaces, but you cannot call this name as an attribute (which can be sometimes convenient for debugging). It still shows in TAB completion, however!

 3. Wouldn't it be better to write
 {{{
def dP6(self, names='x u y v z w'): 
   ...
}}}
 instead of 
 {{{
def dP6(self, names=None):
    if names is None:
        names = 'x u y v z w'
    ...
}}}

 4. This new argument `names` must be documented in `dP6` etc.


---

Comment by novoselt created at 2011-02-23 03:47:39

Changing status from needs_review to needs_work.


---

Comment by novoselt created at 2011-02-23 03:52:05

P.S. If you agree with all these suggestions, I'd be happy to implement them since it is mostly copy-pasting and you have a bunch of other tickets to worry about ;-)


---

Comment by novoselt created at 2011-02-23 04:22:53

Comments on the second patch (trac_10529_MPolynomialIdeal_subs.patch)

 1. The "two-line description" is a little hard to understand, I would remove "while not touching other variables" part and instead demonstrate it on examples. (But I don't insist on this point.)

 2. The second example in the doctest works with a polynomial, not an ideal, so it should be fixed.

 3. The following fails for no reason:
 {{{
sage: R.<a,b> = PolynomialRing(QQ,2)
sage: S = PolynomialRing(QQ,"x")
sage: S.inject_variables()
Defining x
sage: p = a<sup>2+b</sup>2+a-b+2
sage: p.subs(a=x, b=x)
2*x^2 + 2
sage: _.parent()
Univariate Polynomial Ring in x over Rational Field
sage: I = R.ideal(p)
sage: I
Ideal (a^2 + b^2 + a - b + 2) of Multivariate Polynomial Ring in a, b over Rational Field
sage: I.subs(a=x, b=x)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: Could not find a common ring for the substituted generators.
}}}
 One solution is to add a check for univariate polynomial rings, but what about fraction fields and symbolic rings
 {{{
sage: var("x")    
x
sage: x.parent()
Symbolic Ring
sage: I.subs(a=x, b=x)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: Could not find a common ring for the substituted generators.
}}}
 Maybe it is OK to try to construct an ideal using the sequence universe if it has ideal method? So that the code looks like
 {{{
ring = self.ring() 
generators = [f.subs(in_dict, **kwds) for f in self.gens()] 
if not all(gen in ring for gen in generators): 
    ring = Sequence(generators).universe()
try:
    return ring.ideal(generators)
except AttributeError:
    raise TypeError("cannot form an ideal from the substituted generators!")
}}}


---

Comment by novoselt created at 2011-02-23 05:15:22

The third patch (trac_10529_QuotientRingElement_call.patch) looks fine except for a little typo: "Additionally, if quotient ring generators can be used as keywords." should be without "if".


---

Comment by vbraun created at 2011-02-23 16:37:28

Changing status from needs_work to needs_review.


---

Comment by vbraun created at 2011-02-23 16:37:28

About `trac_10529_toric_variety_library_names.patch`:

I changed the `dict_key` to remove spaces and start with
`_cached_`... to avoid any collisions.

I implemented the other changes.


---

Comment by vbraun created at 2011-02-23 16:38:04

Updated patch


---

Attachment

Updated patch


---

Attachment


---

Comment by novoselt created at 2011-02-23 16:52:42

OK, I am fine with the forth patch (trac_10529_SubschemeMorphisms_without_QuotientRing.patch).

I think it is very bad that the class description states

```
    A morphism of schemes determined by rational functions that define
    what the morphism does on points in the ambient space.
```

and yet the previous version was expecting (with `check=False`) polynomials in the quotient ring and the new one - in the original polynomial ring. It is also bad that a generic class does something special for projective targets. But fixing all this is beyond the scope of the ticket and I think that this patch is an improvement to the current situation.


---

Comment by novoselt created at 2011-02-23 16:53:25

I meant the fourth...


---

Comment by novoselt created at 2011-02-23 16:56:18

The first comment in http://trac.sagemath.org/sage_trac/ticket/10529#comment:5 applies to two cases in `toric_variety` and `fano_toric_variety` ;-)


---

Attachment

Now also fixed in fano_toric_varieties.py


---

Comment by novoselt created at 2011-02-23 17:17:43

I am having second thoughts about calling elements of quotient rings. It seems dangerous to evaluate the lift without checking that the input is acceptable. Given your code for ideal subs, it seems very easy to check that the ideal vanishes on the input, although it will potentially add a big overhead. How about doing it and providing an option `check=False` for turning it off in internal algorithms where the input is already known to be valid? (And if lifts have `check` option already, it should be passed to them as well.)


---

Comment by novoselt created at 2011-02-23 18:25:03

Glanced through the main patch. What is "the best affine patch" and why?

Regarding checking global smoothness in affine varieties, I got very annoyed by "speed" of affine patches recently and the following dramatically works:

```
diff -r b749e0edc82b sage/schemes/generic/algebraic_scheme.py
--- a/sage/schemes/generic/algebraic_scheme.py	Mon Feb 21 09:35:33 2011 -0700
+++ b/sage/schemes/generic/algebraic_scheme.py	Tue Feb 22 19:47:20 2011 -0700
@@ -1498,7 +1498,7 @@
         phi_p = ambient_patch.embedding_morphism().defining_polynomials()
         patch = ambient_patch.subscheme(
                             [p(phi_p) for p in self.defining_polynomials()])
-        patch._embedding_morphism = patch.hom(phi_p, self)
+        patch._embedding_morphism = patch.hom(phi_p, self, check=False)
         self._affine_patches[i] = patch
         return patch

diff -r b749e0edc82b sage/schemes/generic/scheme.py
--- a/sage/schemes/generic/scheme.py	Mon Feb 21 09:35:33 2011 -0700
+++ b/sage/schemes/generic/scheme.py	Tue Feb 22 19:47:20 2011 -0700
@@ -459,7 +459,7 @@
         """
         return morphism.SchemeMorphism_id(self)
 
-    def hom(self, x, Y=None):
+    def hom(self, x, Y=None, check=True):
         """
         Return the scheme morphism from self to Y defined by x. If x is a
         scheme, try to determine a natural map to x.
@@ -480,7 +480,7 @@
                 return self.Hom(x).natural_map()
             else:
                 raise TypeError, "unable to determine codomain"
-        return self.Hom(Y)(x)
+        return self.Hom(Y)(x, check)
 
     def _Hom_(self, Y, category=None, check=True):
         """
```

Feel free to add it to your patch (with documentation and examples ;-)), but I have not spend much time thinking about implications and what can go wrong with such changes. I think I had at least one doctest failure, but for now I am using it anyway since it works fine for toric varieties and makes a difference between interactive work and coffee breaks.


---

Comment by vbraun created at 2011-02-23 18:37:39

The "best" affine patch is where you have to divide by the largest number to dehomogenize; Division by small numbers is numerically unstable.


---

Attachment

Updated patch


---

Comment by vbraun created at 2011-02-24 10:42:27

I added your optional `check=<boolean>` argument. The one ensuing doctest failure is caused by a different presentation of the embedding morphism (modulo the ideal of the domain variety), so either answer is mathematically correct.


---

Comment by novoselt created at 2011-04-08 17:12:07

Replying to [comment:14 novoselt]:
> I am having second thoughts about calling elements of quotient rings. It seems dangerous to evaluate the lift without checking that the input is acceptable. Given your code for ideal subs, it seems very easy to check that the ideal vanishes on the input, although it will potentially add a big overhead. How about doing it and providing an option `check=False` for turning it off in internal algorithms where the input is already known to be valid? (And if lifts have `check` option already, it should be passed to them as well.)

Hi Volker, any thoughts/objections on this one? (I am going to finally read the last patch today or this weekend.)


---

Comment by vbraun created at 2011-04-09 05:29:25

I think the calling quotient rings stuff is actually not used because I later switched the maps between affine algebraic schemes to be defined by actual polynomials instead of quotient rings.


---

Comment by novoselt created at 2011-04-09 20:57:49

Replying to [comment:20 vbraun]:
> I think the calling quotient rings stuff is actually not used because I later switched the maps between affine algebraic schemes to be defined by actual polynomials instead of quotient rings. 

So you want to just drop this patch? I think that the functionality you have added is neat and useful even without relation to this ticket, just don't want it to be dangerous ;-)

Comments on the last patch:

 1. How about renaming `Jacobian` to `Jacobian_ideal`? I associate `Jacobian` with a single determinant of a square matrix...
 1. It seems to me also that it should NOT include the original polynomials. I am having difficulties with finding a definition of the Jacobian ideal, but at least in the case of one polynomial Singular does not add it in this function http://www.singular.uni-kl.de/Manual/3-0-4/sing_986.htm and its Milnor number routine takes into account all critical points of a function and not just critical points in the zero set http://www.singular.uni-kl.de/Manual/latest/sing_718.htm#SEC770. Another argument against mixing in the defining ideal is that it is easier to combine ideals than to split one apart. So I propose to have `Jacobian_ideal` for the ideal generated by partial derivatives or their minors and some other function or an optional parameter for combining it with the defining ideal.
 1. Wouldn't it be faster to check the rank of the Jacobian matrix rather than to compute all maximal minors?
 1. If there are obstructions to it, probably the Jacobian ideal should be cached.
 1. Can the documentation of `_best_affine_patch` be extended a little with the explanation you gave earlier?
 1. I have a number of issues with `affine_neighbourhood`
  1. Its purpose is not quite clear from the name: since projective spaces and toric varieties have "natural" affine covers, I would expect to get one of the standard patches as an affine neighbourhood. How about changing it to `centered_neigbourhood`?
  1. I think it actually can be nice to get one of those standard ones as well. How about `affine_neigbourhood(point)` returning a patch which contains `point`?
  1. This is, of course, close to what `_best_affine_patch` does. I think it would be nice to expose its functionality to the user, but make it a bit more clear that it returns a number. So I guess I propose three functions:
   * `containing_patch_index(point)` - does what is now done by `_best_affine_patch(point)` (I think that access to the index can be convenient e.g. if a user wants to consider the same points on several subschemes.);
   * `affine_neighbourhood(point)` - a shortcut for `X.affine_patch(X.containing_patch_index(point))`;
   * `centered_neigbourhood(point)` - does what is now done by `affine_neigbourhood`.
  1. I think that returned neighbourhoods should be affine schemes with a determined embedding, not just the embedding morphism (I know that it is possible to get domain/codomain from a morphism, but I think that most people think of neighbourhoods as open subsets, plus it is more consistent with the current `affine_patch`.)
  1. I don't see any point storing `point_preimage` since it is the origin. Plus having plain public attributes is not in the style of Sage.
  1. Why do you say that it returns a local isomorphism? A neighbourhood should be isomorphic to its image under the inclusion morphism, and I don't think that it needs any clarification. A local isomorphism, on the other hand, means to me that every point in the domain has a neighbourhood which is isomorphic to its image. That is clearly a weaker statement in general, so it seems confusing to me here.
 1. For toric varieties `_best_affine_patch` can be written a bit more efficiently (for fans with many rays it may give a considerable speed-up):
 {{{
point = list(point) 
zeros = set(i for i, coord in enumerate(point) if coord == 0)   
for cone_idx, cone in enumerate(self.ambient_space().fan().generating_cones()): 
    if zeros.issubset(cone.ambient_ray_indices()): 
        return cone_idx 
assert False, 'The point must not have been a point of the toric variety.' 
}}}
 Here we work sets of zeros in the point and indices of the cone rather than their completements, which can be much bigger. Also this isn't "the best" patch, it is "just a patch" so I think that `containing_patch_index` is a better name and when possible it can try to return the best option.
 1. Now I see that for toric varieties `affine_neighbourhood` is not centered. Then I think that for sure the method of projective varieties should be renamed to `centered_neighbourhood`. Other comments still apply. And I still don't like `point_preimage` even though now it is non-trivial. I think that if it is exposed to users it should be a function with documentation and have a bit more meaningful name. (`center_preimage` comes to mind, although I am not sure if that's clear/standard.) Or, perhaps, we still can return an honest centered neighbourhood realized as a plain affine scheme (with an appropriate embedding map)? That actually would be very handy, as so far I was doing such shifts manually whenever I had to put my special points to the origin.
 1. Would be nice to add a message to `NoteImplementedError` in `is_smooth` of affine toric subschemes.


---

Comment by novoselt created at 2011-04-09 20:57:49

Changing status from needs_review to needs_work.


---

Comment by vbraun created at 2011-04-14 15:44:37

Changing status from needs_work to needs_review.


---

Comment by vbraun created at 2011-04-14 15:44:37

1. Thats just the 0-dimensional case. I don't care about `Jacobian` vs. `Jacobian_ideal`, but since you thought of the right thing I would prefer to keep the shorter name.

2. In projective coordinates the CI equations are implied by the minors of the partial derivatives, which is part of why it is usually not spelled out. For speed, it is important to add the equations so that the minors (which often have high degree) can be reduced quickly. Also, in the context of subschemes it is dangerous to not add the equations; For example if you compute the Milnor number you really do only want the critical points on the subvariety. So I very much prefer it the way it is.

3. If you have a faster algorithm then you should be writing a paper on it. But note that you need the rank *everywhere* on the subvariety :-)

4. Computing the Jacobian ideal is fast. Eventually you'll have to compute Groebner basis, this is the slow and memory intensive part. But we can't cache all of these with whatever term ordering the user is going to use. I think its better to cache the final result (whether the variety is smooth) instead of the Jacobian ideal.

5. OK

6. in #10540, the `affine_neighbourhood` method is removed. There are two different methods `affine_patch(int)` and `neighbourhood(point)`. The neighborhood may or may not be centered.

7. Eventually the `_best_affine_patch` should be the "best" patch in the same sense as for projective varieties. But we first need some way to easily access the homogeneous rescalings. So I'll leave this as a TODO.

8. In #10540, this is refactored into `subscheme.embedding_morphism()` and `subscheme.embedding_origin` methods. No more public attributes. I think it is better to have un-shifted affine patches for toric varieties as it makes the embedding map easier. But it would be nice to have a `shift()` method, feel free to write a patch on top of #10540 :-)

9. Implemented in #10540


---

Comment by vbraun created at 2011-04-14 16:03:15

I've moved the `trac_10529_QuotientRingElement_call.patch` to #11199.


---

Attachment

Documentation added to _best_affine_patch


---

Comment by novoselt created at 2011-04-17 02:07:07

1. If you don't really care, I'd go with `Jacobian_ideal` since it is more clear.

2. But in the affine case the defining equations are not implied and I gave examples where they are not included. I agree with your points about adding them. In fact, I was very confused and frustrated when I was computing Milnor numbers for a certain example and results didn't match with expectations precisely because of "extra critical points". However, I don't want to go against usual definitions and conventions. Could you please give a reference to the definition of a Jacobian ideal in the sense that you have implemented?

3-4. I was thinking about a particular point, not testing smoothness of the whole scheme ;-) I am OK to leave it for the future.

6-9. If these issues are addressed in #10540, I propose either moving the main patch of this ticket to #10540 or putting it in front of #10540 in the queue and making sure that they are merged together. The second option probably makes more sense, but it will add 2 more tickets as prerequisites for this one.

7. The suggested optimization will work for any definition of "best", it is just a more efficient way of determining whether a certain patch is acceptable at all or not.


---

Comment by vbraun created at 2011-04-17 16:13:57

1. But the general usage in Sage is to prefer shorter names. For example `I.is_prime` instead of `I.is_prime_ideal` or `I.quotient` instead of `I.quotient_ring`.

2. Lazarsfeld: Positivity in algebraic geometry: II, p.181

6-9: The tracker bug clearly states that #10540 depends on this ticket. I find that the methods introduced in this ticket are an improvement, even if they get superseded in #10540 by even better ones. How about you review #10540 and this ticket, then they'll automatically end up in the same Sage release.


---

Comment by vbraun created at 2011-04-17 16:33:11

Added Lazarsfeld reference and code cleanup to _best_affine_patch


---

Attachment


---

Comment by novoselt created at 2011-04-17 17:34:55

1. `is*` methods always return True/False, so there is no need to clarify the output. `I.quotient` actually returns an ideal, not ring, but that's also quite unambiguous. On the other hand, you can associate several "Jacobian things" to a scheme - you have already implemented matrix and ideal and one can also add  the determinant when it makes sense. Note that it still will be different from the ideal, since this determinant will be its generator. So I still think that `Jacobian_ideal` is better, but I will not insist anymore.

2. Thank you! As I said, I think that this definition is more convenient, but I didn't want to go against standard conventions (and I don't really know what they are in this case).

6-9. Absolutely, I hope to review all current tickets on #9604 for 4.7.1.


---

Comment by vbraun created at 2011-04-17 17:42:28

I meant to refer to `ring.quotient(ideal)`, not `ideal.quotient(ideal)`.  I guess that illustrates the fact that Sage tends to shorten the method names :-)


---

Comment by novoselt created at 2011-04-17 20:24:44

Since you wrote `I.is_prime` and `I.quotient`, I concluded that `I` is some ideal. Both in cases of ideal and the ring the output is of the type of initial object. The point of OOP is that you don't have to explain "what is the first input" for methods of the class. In the case of `Jacobian_ideal`, on the other hand, the clarification would refer to the output, which is ambiguous...


---

Attachment

For my record: everything is addressed in the current patches except for 6,8,9 which should be taken care off in #10540.

There was also the second instance of a little adjustment missed in the beginning, I have attached a patch fixing it.

Once we are done with #10540, I will switch this one to positive review.


---

Comment by novoselt created at 2011-06-15 20:34:07

Changing status from needs_review to positive_review.


---

Comment by novoselt created at 2011-06-15 20:34:50

Changing keywords from "" to "sd31".


---

Comment by jdemeyer created at 2011-06-24 09:20:15

Resolution: fixed
