# Issue 28256: add .is_self_dual method for polytopes

archive/issues_028019.json:
```json
{
    "body": "CC:  @jplab @kliem\n\nKeywords: self-dual, polytope, dual, days100\n\nA polytope is self-dual if its face lattice is isomorphic to the face lattice of its dual polytope.\n\nIn this tickets I will add `is_self_dual` method to the `Polyhedron` class to check (combinatorially) if a polytope is self-dual.\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/28256\n\n",
    "closed_at": "2019-07-29T21:54:35Z",
    "created_at": "2019-07-24T20:01:46Z",
    "labels": [
        "component: geometry"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.9",
    "title": "add .is_self_dual method for polytopes",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/28256",
    "user": "https://github.com/LaisRast"
}
```
CC:  @jplab @kliem

Keywords: self-dual, polytope, dual, days100

A polytope is self-dual if its face lattice is isomorphic to the face lattice of its dual polytope.

In this tickets I will add `is_self_dual` method to the `Polyhedron` class to check (combinatorially) if a polytope is self-dual.


Issue created by migration from https://trac.sagemath.org/ticket/28256





---

archive/issue_comments_395621.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-07-24T20:03:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395621",
    "user": "https://github.com/LaisRast"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_395622.json:
```json
{
    "body": "New commits:",
    "created_at": "2019-07-24T20:03:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395622",
    "user": "https://github.com/LaisRast"
}
```

New commits:



---

archive/issue_comments_395623.json:
```json
{
    "body": "Please have in mind that the check should also work for non-fulldimensional polyhedra (e.g. Simplex).\n\nUnfortunately, git.sagemath is down at the moment, so I don't see your code.",
    "created_at": "2019-07-24T20:47:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395623",
    "user": "https://github.com/kliem"
}
```

Please have in mind that the check should also work for non-fulldimensional polyhedra (e.g. Simplex).

Unfortunately, git.sagemath is down at the moment, so I don't see your code.



---

archive/issue_comments_395624.json:
```json
{
    "body": "Never mind.",
    "created_at": "2019-07-24T20:48:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395624",
    "user": "https://github.com/kliem"
}
```

Never mind.



---

archive/issue_comments_395625.json:
```json
{
    "body": "Replying to [comment:2 gh-kliem]:\n> Please have in mind that the check should also work for non-fulldimensional polyhedra (e.g. Simplex).\n> \n> Unfortunately, git.sagemath is down at the moment, so I don't see your code.\n\n\nIt does work for non-full dimensional polytopes. The 3-simplex (a positive example) and the 2nd 4-hypersimplex (a negative example) are already in the doctest.",
    "created_at": "2019-07-24T20:51:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395625",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:2 gh-kliem]:
> Please have in mind that the check should also work for non-fulldimensional polyhedra (e.g. Simplex).
> 
> Unfortunately, git.sagemath is down at the moment, so I don't see your code.


It does work for non-full dimensional polytopes. The 3-simplex (a positive example) and the 2nd 4-hypersimplex (a negative example) are already in the doctest.



---

archive/issue_comments_395626.json:
```json
{
    "body": "Instead of testing whether the matrix is square, I would check first thing that `n_facets` equals `n_vertices` (incidence matrix does take some time).\n\nThe approach seems somewhat hacky. How about taking the `vertex_facet_graph` and checking that it is isomorphic to its reverse (I assume that isomorphism does distinct directions, didn't ckeck).",
    "created_at": "2019-07-24T22:03:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395626",
    "user": "https://github.com/kliem"
}
```

Instead of testing whether the matrix is square, I would check first thing that `n_facets` equals `n_vertices` (incidence matrix does take some time).

The approach seems somewhat hacky. How about taking the `vertex_facet_graph` and checking that it is isomorphic to its reverse (I assume that isomorphism does distinct directions, didn't ckeck).



---

archive/issue_comments_395627.json:
```json
{
    "body": "> The approach seems somewhat hacky. How about taking the `vertex_facet_graph` and checking that it is isomorphic to its reverse (I assume that isomorphism does distinct directions, didn't ckeck).\n\n\nI'd rather qualify this as a clever algorithm. This gets rid of automorphisms of the polytope directly while you will have to deal with them in the oriented graphs. The complexity should be exactly the same and most likely equivalent, because adding the special vertex is equivalent to specify the orientation.\n\nNow, I do not know how isomorphism of graphs is preparsing things, but most likely there is something dealing with bipartite graphs.",
    "created_at": "2019-07-25T07:39:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395627",
    "user": "https://github.com/jplab"
}
```

> The approach seems somewhat hacky. How about taking the `vertex_facet_graph` and checking that it is isomorphic to its reverse (I assume that isomorphism does distinct directions, didn't ckeck).


I'd rather qualify this as a clever algorithm. This gets rid of automorphisms of the polytope directly while you will have to deal with them in the oriented graphs. The complexity should be exactly the same and most likely equivalent, because adding the special vertex is equivalent to specify the orientation.

Now, I do not know how isomorphism of graphs is preparsing things, but most likely there is something dealing with bipartite graphs.



---

archive/issue_comments_395628.json:
```json
{
    "body": "Replying to [comment:6 jipilab]:\n> > The approach seems somewhat hacky. How about taking the `vertex_facet_graph` and checking that it is isomorphic to its reverse (I assume that isomorphism does distinct directions, didn't ckeck).\n\n> \n> I'd rather qualify this as a clever algorithm. This gets rid of automorphisms of the polytope directly while you will have to deal with them in the oriented graphs. The complexity should be exactly the same and most likely equivalent, because adding the special vertex is equivalent to specify the orientation.\n\n\nYes, most likely both approaches take almost the same time.\nI just figured, it's a lot of lines to create a graph that is basically the `vertex_facet_graph`.\n\nInstead of the current approach, I find some prechecking and\n\n```\nG1 = self.vertex_facet_graph()\nG2 = G1.reverse()\nreturn G1.is_isomorphic(G2)\n```\nto be more transparent.\n> \n> Now, I do not know how isomorphism of graphs is preparsing things, but most likely there is something dealing with bipartite graphs.",
    "created_at": "2019-07-25T09:05:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395628",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:6 jipilab]:
> > The approach seems somewhat hacky. How about taking the `vertex_facet_graph` and checking that it is isomorphic to its reverse (I assume that isomorphism does distinct directions, didn't ckeck).

> 
> I'd rather qualify this as a clever algorithm. This gets rid of automorphisms of the polytope directly while you will have to deal with them in the oriented graphs. The complexity should be exactly the same and most likely equivalent, because adding the special vertex is equivalent to specify the orientation.


Yes, most likely both approaches take almost the same time.
I just figured, it's a lot of lines to create a graph that is basically the `vertex_facet_graph`.

Instead of the current approach, I find some prechecking and

```
G1 = self.vertex_facet_graph()
G2 = G1.reverse()
return G1.is_isomorphic(G2)
```
to be more transparent.
> 
> Now, I do not know how isomorphism of graphs is preparsing things, but most likely there is something dealing with bipartite graphs.



---

archive/issue_comments_395629.json:
```json
{
    "body": "Replying to [comment:5 gh-kliem]:\n> Instead of testing whether the matrix is square, I would check first thing that `n_facets` equals `n_vertices` (incidence matrix does take some time).\n\nAgree\n\n> The approach seems somewhat hacky. How about taking the `vertex_facet_graph` and checking that it is isomorphic to its reverse (I assume that isomorphism does distinct directions, didn't ckeck).\n\nIt turns out that 'is_isomorphic' does see the directions. So less lines and more readable code.",
    "created_at": "2019-07-25T09:42:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395629",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:5 gh-kliem]:
> Instead of testing whether the matrix is square, I would check first thing that `n_facets` equals `n_vertices` (incidence matrix does take some time).

Agree

> The approach seems somewhat hacky. How about taking the `vertex_facet_graph` and checking that it is isomorphic to its reverse (I assume that isomorphism does distinct directions, didn't ckeck).

It turns out that 'is_isomorphic' does see the directions. So less lines and more readable code.



---

archive/issue_comments_395630.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-25T09:44:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395630",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_395631.json:
```json
{
    "body": "This looks good to me now (remember that I haven't tested this on a computer).",
    "created_at": "2019-07-25T11:35:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395631",
    "user": "https://github.com/kliem"
}
```

This looks good to me now (remember that I haven't tested this on a computer).



---

archive/issue_comments_395632.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-07-25T16:38:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395632",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_395633.json:
```json
{
    "body": "The pyflakes plugin complains. But apparently it only complains about lines that aren't touched by the patch and thus shouldn't be a problem for this ticket.\n\nTests on a patchbot pass. And the code and docs look good to me. I believe this can constitute a positive review.",
    "created_at": "2019-07-25T16:38:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395633",
    "user": "https://github.com/simon-king-jena"
}
```

The pyflakes plugin complains. But apparently it only complains about lines that aren't touched by the patch and thus shouldn't be a problem for this ticket.

Tests on a patchbot pass. And the code and docs look good to me. I believe this can constitute a positive review.



---

archive/issue_comments_395634.json:
```json
{
    "body": "Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self polarity)?",
    "created_at": "2019-07-26T16:13:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395634",
    "user": "https://github.com/mkoeppe"
}
```

Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self polarity)?



---

archive/issue_comments_395635.json:
```json
{
    "body": "Replying to [comment:12 mkoeppe]:\n> Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self \n\n\nWhat do you mean by geometric self duality?\n\nFrom many ways one could distinguish polyhedra Sage only knows identical and combinatorially equivalent, doesn't it (affinely equivalent and projectively would make sense as well, but I couldn't find this anywhere).\n\nFor self duality being exactly self dual doesn't make any sense (once we are at least 2 dimensional). So I would figure the question is a combinatorial one.\n\nIn #27689, on the other hand we check of a polyhedron is a prism etc. Here it makes sense to ask for exactly and up to combinatorially equivalence. Maybe one could provide a keyword for cases, where the question has multiple meanings.",
    "created_at": "2019-07-26T19:15:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395635",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:12 mkoeppe]:
> Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self 


What do you mean by geometric self duality?

From many ways one could distinguish polyhedra Sage only knows identical and combinatorially equivalent, doesn't it (affinely equivalent and projectively would make sense as well, but I couldn't find this anywhere).

For self duality being exactly self dual doesn't make any sense (once we are at least 2 dimensional). So I would figure the question is a combinatorial one.

In #27689, on the other hand we check of a polyhedron is a prism etc. Here it makes sense to ask for exactly and up to combinatorially equivalence. Maybe one could provide a keyword for cases, where the question has multiple meanings.



---

archive/issue_comments_395636.json:
```json
{
    "body": "Replying to [comment:12 mkoeppe]:\n> Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self polarity)?\n\n+1\n\nI would vote to simply rename the function to that. It is a combinatorial self duality and should not be confused with the eventual property that `self.polar() == self`.",
    "created_at": "2019-07-28T11:35:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395636",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:12 mkoeppe]:
> Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self polarity)?

+1

I would vote to simply rename the function to that. It is a combinatorial self duality and should not be confused with the eventual property that `self.polar() == self`.



---

archive/issue_comments_395637.json:
```json
{
    "body": "Replying to [comment:12 mkoeppe]:\n> Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self polarity)?\n\n\n+1\n\nConvinced.\n\nBtw, potentially there is also the method `is_combinatorially_dual(self, other)`. Here, specifying 'combinatorially' is even more important. One should name this ticket's method consistently. (Even though checking for self polarity is probably not worth a method.)",
    "created_at": "2019-07-28T13:20:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395637",
    "user": "https://github.com/kliem"
}
```

Replying to [comment:12 mkoeppe]:
> Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self polarity)?


+1

Convinced.

Btw, potentially there is also the method `is_combinatorially_dual(self, other)`. Here, specifying 'combinatorially' is even more important. One should name this ticket's method consistently. (Even though checking for self polarity is probably not worth a method.)



---

archive/issue_comments_395638.json:
```json
{
    "body": "> Btw, potentially there is also the method `is_combinatorially_dual(self, other)`. Here, specifying 'combinatorially' is even more important. One should name this ticket's method consistently. (Even though checking for self polarity is probably not worth a method.)\n\n\nA compact polyhedron is always dual to another one using polarity. So this name is incomplete, the self is important there.",
    "created_at": "2019-07-28T13:55:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395638",
    "user": "https://github.com/jplab"
}
```

> Btw, potentially there is also the method `is_combinatorially_dual(self, other)`. Here, specifying 'combinatorially' is even more important. One should name this ticket's method consistently. (Even though checking for self polarity is probably not worth a method.)


A compact polyhedron is always dual to another one using polarity. So this name is incomplete, the self is important there.



---

archive/issue_comments_395639.json:
```json
{
    "body": "Replying to [comment:16 jipilab]:\n> > Btw, potentially there is also the method `is_combinatorially_dual(self, other)`. Here, specifying 'combinatorially' is even more important. One should name this ticket's method consistently. (Even though checking for self polarity is probably not worth a method.)\n\n> \n> A compact polyhedron is always dual to another one using polarity. So this name is incomplete, the self is important there.\n\n\nOops, my bad. Didn't see the `other`.\n\nI would say that this could be done in a different ticket, if someone expresses the need.",
    "created_at": "2019-07-28T14:07:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395639",
    "user": "https://github.com/jplab"
}
```

Replying to [comment:16 jipilab]:
> > Btw, potentially there is also the method `is_combinatorially_dual(self, other)`. Here, specifying 'combinatorially' is even more important. One should name this ticket's method consistently. (Even though checking for self polarity is probably not worth a method.)

> 
> A compact polyhedron is always dual to another one using polarity. So this name is incomplete, the self is important there.


Oops, my bad. Didn't see the `other`.

I would say that this could be done in a different ticket, if someone expresses the need.



---

archive/issue_comments_395640.json:
```json
{
    "body": "Replying to [comment:12 mkoeppe]:\n> Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self polarity)?\n\n\nI would still vote for leaving it as `is_self_dual` instead of `is_combinatorially_self_dual`.\nI am following the convention that duality is defined for abstract polytopes (face lattices), while polarity is defined for geometric realizations of polytopes (and more generally any subset of an Euclidean space).\n\nFor that you can refer to \u200eGr\u00fcnbaum's book (Convex Ptolytopes). In section 3.4, he defined two (geometric realizations of two) polytopes to be *dual* to each other if there is an inclusion-reversing bijection between their face lattices. And later, in the same section, he defined polarity for geometric polytopes by the well know definition.\n\nOn the other hand, for `is_self_polar`, since The only set `A` for which `A == A.polar()` is the unit ball (Theorem 3.1 of [1]), the definition should be more loosely than what is suggested. In [1], this is the definition of self-polarity:\nA subset `A` of `R^d` is *self-polar* provided there exists some orthogonal transformation `U` of `R^d` such that `A = U*A.polar()`.\nThis is of course can be done in a different ticket.\n\n[1]: Alathea Jensen, Self-polar polytopes https://arxiv.org/pdf/1902.00784.pdf",
    "created_at": "2019-07-28T20:15:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395640",
    "user": "https://github.com/LaisRast"
}
```

Replying to [comment:12 mkoeppe]:
> Shouldn't this method be called `is_combinatorially_self_dual` to distinguish the tested property from geometric self duality (self polarity)?


I would still vote for leaving it as `is_self_dual` instead of `is_combinatorially_self_dual`.
I am following the convention that duality is defined for abstract polytopes (face lattices), while polarity is defined for geometric realizations of polytopes (and more generally any subset of an Euclidean space).

For that you can refer to ‎Grünbaum's book (Convex Ptolytopes). In section 3.4, he defined two (geometric realizations of two) polytopes to be *dual* to each other if there is an inclusion-reversing bijection between their face lattices. And later, in the same section, he defined polarity for geometric polytopes by the well know definition.

On the other hand, for `is_self_polar`, since The only set `A` for which `A == A.polar()` is the unit ball (Theorem 3.1 of [1]), the definition should be more loosely than what is suggested. In [1], this is the definition of self-polarity:
A subset `A` of `R^d` is *self-polar* provided there exists some orthogonal transformation `U` of `R^d` such that `A = U*A.polar()`.
This is of course can be done in a different ticket.

[1]: Alathea Jensen, Self-polar polytopes https://arxiv.org/pdf/1902.00784.pdf



---

archive/issue_comments_395641.json:
```json
{
    "body": "I'm totally confused by now and don't know what to think.\n\nI figured we name everything that can be confused with the `combinatorially` prefix.\nNow in #27689, JP voted against that.\nIf find the property self-dual far less ambiguous as being a prism.\nThe name `is_combinatorially_self_dual` is also hard to find via tab completion.\n\nOverall, I think people with stronger opinions on names than me should decide.",
    "created_at": "2019-07-28T20:27:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395641",
    "user": "https://github.com/kliem"
}
```

I'm totally confused by now and don't know what to think.

I figured we name everything that can be confused with the `combinatorially` prefix.
Now in #27689, JP voted against that.
If find the property self-dual far less ambiguous as being a prism.
The name `is_combinatorially_self_dual` is also hard to find via tab completion.

Overall, I think people with stronger opinions on names than me should decide.



---

archive/issue_comments_395642.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-07-29T21:54:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28256#issuecomment-395642",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_070361.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2019-07-29T21:54:35Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/28256",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28256#event-70361"
}
```
