# Issue 28922: Function fields: updates to series expansion code

archive/issues_028685.json:
```json
{
    "assignees": [],
    "body": "<div id=\"comment:0\"></div>\n\nThis patch changes four things concerning series expansions in the function field code:\n\n1. The uniformizing variable can be specified\n\n   This patch adds an optional `local_uniformizer` argument to `FunctionField`'s `completion()` method.  ~~It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.~~\n\n   If the specified element is not a uniformizing variable at the given place, an exception is raised.\n\n2. ~~If a series expansion is exact, the `O(s^n)` is dropped.  So, for example, the following test case:~~\n\n```\nK.<x> = FunctionField(QQbar); _.<Y> = K[]\nL.<y> = K.extension(Y^2 + Y + x + 1/x)\nO = L.maximal_order()\nI = O.ideal(y)\npl = I.divisor().support()[0]\nm = L.completion(pl, prec=5)\nm(x)\n```\n   ~~now returns `I + s` instead of `I + s + O(s^5)`.~~\n\n3. ~~The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test:~~\n\n```\nsage: K.<x> = FunctionField(GF(2)); _.<Y> = K[]\nsage: L.<y> = K.extension(Y^2 + Y + x + 1/x)\nsage: p = L.places_finite()[0]\nsage: m = L.completion(p)\nsage: m(x+y, 5)\n```\n\n   ~~returns `s^-1 + 1 + s^2 + s^4 + O(s^5)` instead of `s^-1 + 1 + s^2 + O(s^4)`~~\n\n4. Function field elements can now be raised to fractional powers.  ~~If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.~~  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.\n\nComponent: **algebraic geometry**\n\nKeywords: **function field**\n\nAuthor: **Brent Baccala**\n\nBranch/Commit: **[public/28922](https://github.com/sagemath/sagetrac-mirror/tree/public/28922) @ [`4189256`](https://github.com/sagemath/sagetrac-mirror/commit/4189256a741231c4f6cd1305c548fcc05d9fff41)**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/28922_\n\n",
    "created_at": "2019-12-29T01:29:15Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20algebraic%20geometry",
        "https://github.com/sagemath/sage/labels/p%3A%20minor%20/%204",
        "https://github.com/sagemath/sage/labels/enhancement",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.8",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Function fields: updates to series expansion code",
    "type": "issue",
    "updated_at": "2022-09-19T18:58:47Z",
    "url": "https://github.com/sagemath/sage/issues/28922",
    "user": "https://github.com/BrentBaccala"
}
```
<div id="comment:0"></div>

This patch changes four things concerning series expansions in the function field code:

1. The uniformizing variable can be specified

   This patch adds an optional `local_uniformizer` argument to `FunctionField`'s `completion()` method.  ~~It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.~~

   If the specified element is not a uniformizing variable at the given place, an exception is raised.

2. ~~If a series expansion is exact, the `O(s^n)` is dropped.  So, for example, the following test case:~~

```
K.<x> = FunctionField(QQbar); _.<Y> = K[]
L.<y> = K.extension(Y^2 + Y + x + 1/x)
O = L.maximal_order()
I = O.ideal(y)
pl = I.divisor().support()[0]
m = L.completion(pl, prec=5)
m(x)
```
   ~~now returns `I + s` instead of `I + s + O(s^5)`.~~

3. ~~The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test:~~

```
sage: K.<x> = FunctionField(GF(2)); _.<Y> = K[]
sage: L.<y> = K.extension(Y^2 + Y + x + 1/x)
sage: p = L.places_finite()[0]
sage: m = L.completion(p)
sage: m(x+y, 5)
```

   ~~returns `s^-1 + 1 + s^2 + s^4 + O(s^5)` instead of `s^-1 + 1 + s^2 + O(s^4)`~~

4. Function field elements can now be raised to fractional powers.  ~~If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.~~  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.

Component: **algebraic geometry**

Keywords: **function field**

Author: **Brent Baccala**

Branch/Commit: **[public/28922](https://github.com/sagemath/sagetrac-mirror/tree/public/28922) @ [`4189256`](https://github.com/sagemath/sagetrac-mirror/commit/4189256a741231c4f6cd1305c548fcc05d9fff41)**

_Issue created by migration from https://trac.sagemath.org/ticket/28922_





---

archive/issue_events_394378.json:
```json
{
    "actor": "https://github.com/BrentBaccala",
    "created_at": "2019-12-29T01:29:15Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394378"
}
```



---

archive/issue_events_394379.json:
```json
{
    "actor": "https://github.com/BrentBaccala",
    "created_at": "2019-12-29T01:29:15Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20algebraic%20geometry",
    "label_color": "0000ff",
    "label_name": "c: algebraic geometry",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394379"
}
```



---

archive/issue_events_394380.json:
```json
{
    "actor": "https://github.com/BrentBaccala",
    "created_at": "2019-12-29T01:29:15Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20minor%20/%204",
    "label_color": "ffe799",
    "label_name": "p: minor / 4",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394380"
}
```



---

archive/issue_events_394381.json:
```json
{
    "actor": "https://github.com/BrentBaccala",
    "created_at": "2019-12-29T01:29:15Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394381"
}
```



---

archive/issue_comments_451484.json:
```json
{
    "body": "Commit: **[`aa9230c`](https://github.com/sagemath/sagetrac-mirror/commit/aa9230c41b708e7ec3df98eafa06ac148597a4c0)**",
    "created_at": "2020-01-03T21:46:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451484",
    "user": "https://github.com/BrentBaccala"
}
```

Commit: **[`aa9230c`](https://github.com/sagemath/sagetrac-mirror/commit/aa9230c41b708e7ec3df98eafa06ac148597a4c0)**



---

archive/issue_events_394382.json:
```json
{
    "actor": "https://github.com/BrentBaccala",
    "created_at": "2020-01-03T21:46:10Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "title_is": "Function fields: updates to series expansion code",
    "title_was": "Function fields: allow uniformizing variable to be specified in a completion",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394382"
}
```



---

archive/issue_comments_451485.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,32 @@\n-This patch adds an optional `uvar` argument to `FunctionField`'s `completion()` method.  It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.\n+This patch changes three things concerning series expansions in the function field code:\n \n-If the specified element is not a uniformizing variable at the given place, an exception is raised.\n+1. The uniformizing variable can be specified\n \n+   This patch adds an optional `uvar` argument to `FunctionField`'s `completion()` method.  It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.\n+\n+   If the specified element is not a uniformizing variable at the given place, an exception is raised.\n+\n+2. If a series expansion is exact, the `O(s^n)` is dropped.  So, for example, the following test case:\n+\n+```\n+K.<x> = FunctionField(QQbar); _.<Y> = K[]\n+L.<y> = K.extension(Y^2 + Y + x + 1/x)\n+O = L.maximal_order()\n+I = O.ideal(y)\n+pl = I.divisor().support()[0]\n+m = L.completion(pl, prec=5)\n+m(x)\n+```\n+   now returns `I + s` instead of `I + s + O(s^5)`.\n+\n+3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test case:\n+\n+```\n+sage: K.<x> = FunctionField(GF(2)); _.<Y> = K[]\n+sage: L.<y> = K.extension(Y^2 + Y + x + 1/x)\n+sage: p = L.places_finite()[0]\n+sage: m = L.completion(p)\n+sage: m(x+y, 10)\n+```\n+\n+   returns `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^10)` instead of `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^9)`\n``````\n",
    "created_at": "2020-01-03T21:46:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451485",
    "user": "https://github.com/BrentBaccala"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,32 @@
-This patch adds an optional `uvar` argument to `FunctionField`'s `completion()` method.  It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.
+This patch changes three things concerning series expansions in the function field code:
 
-If the specified element is not a uniformizing variable at the given place, an exception is raised.
+1. The uniformizing variable can be specified
 
+   This patch adds an optional `uvar` argument to `FunctionField`'s `completion()` method.  It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.
+
+   If the specified element is not a uniformizing variable at the given place, an exception is raised.
+
+2. If a series expansion is exact, the `O(s^n)` is dropped.  So, for example, the following test case:
+
+```
+K.<x> = FunctionField(QQbar); _.<Y> = K[]
+L.<y> = K.extension(Y^2 + Y + x + 1/x)
+O = L.maximal_order()
+I = O.ideal(y)
+pl = I.divisor().support()[0]
+m = L.completion(pl, prec=5)
+m(x)
+```
+   now returns `I + s` instead of `I + s + O(s^5)`.
+
+3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test case:
+
+```
+sage: K.<x> = FunctionField(GF(2)); _.<Y> = K[]
+sage: L.<y> = K.extension(Y^2 + Y + x + 1/x)
+sage: p = L.places_finite()[0]
+sage: m = L.completion(p)
+sage: m(x+y, 10)
+```
+
+   returns `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^10)` instead of `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^9)`
``````




---

archive/issue_comments_451486.json:
```json
{
    "body": "<div id=\"comment:1\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fca168df7480ee68f3d62918869fd01410562546\"><code>fca168d</code></a></td><td><code>Trac #28922: allow series completion's uniformizing variable to be specified</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2dba0136622dc8c806461d66f9f15da1d7cb6600\"><code>2dba013</code></a></td><td><code>Trac #28922: return exact results for series expansions that are exact</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f27c629f295b6a9362ad1c30f4c8c7b7a5253a9a\"><code>f27c629</code></a></td><td><code>Trac #28922: modified test cases that now return exact results</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/dc2b7a7e9c3c618b993996ff398385747dcea94b\"><code>dc2b7a7</code></a></td><td><code>Trac #28922: function field series expansion now uses absolute precision,</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/aa9230c41b708e7ec3df98eafa06ac148597a4c0\"><code>aa9230c</code></a></td><td><code>Trac #28922: simplify a doctest</code></td></tr></table>\n",
    "created_at": "2020-01-03T21:46:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451486",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:1"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fca168df7480ee68f3d62918869fd01410562546"><code>fca168d</code></a></td><td><code>Trac #28922: allow series completion's uniformizing variable to be specified</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2dba0136622dc8c806461d66f9f15da1d7cb6600"><code>2dba013</code></a></td><td><code>Trac #28922: return exact results for series expansions that are exact</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f27c629f295b6a9362ad1c30f4c8c7b7a5253a9a"><code>f27c629</code></a></td><td><code>Trac #28922: modified test cases that now return exact results</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/dc2b7a7e9c3c618b993996ff398385747dcea94b"><code>dc2b7a7</code></a></td><td><code>Trac #28922: function field series expansion now uses absolute precision,</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/aa9230c41b708e7ec3df98eafa06ac148597a4c0"><code>aa9230c</code></a></td><td><code>Trac #28922: simplify a doctest</code></td></tr></table>




---

archive/issue_comments_451487.json:
```json
{
    "body": "Branch: **[public/28922](https://github.com/sagemath/sagetrac-mirror/tree/public/28922)**",
    "created_at": "2020-01-03T21:46:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451487",
    "user": "https://github.com/BrentBaccala"
}
```

Branch: **[public/28922](https://github.com/sagemath/sagetrac-mirror/tree/public/28922)**



---

archive/issue_comments_451488.json:
```json
{
    "body": "Author: **Brent Baccala**",
    "created_at": "2020-01-03T21:46:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451488",
    "user": "https://github.com/BrentBaccala"
}
```

Author: **Brent Baccala**



---

archive/issue_comments_451489.json:
```json
{
    "body": "<div id=\"comment:2\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/012365f9814246858c38d2e0f43bf4b4552646d1\"><code>012365f</code></a></td><td><code>Trac #28922: compute fractional powers of function field elements</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/734c9b2f542b00f605c152da3edd81cf134ed30c\"><code>734c9b2</code></a></td><td><code>Trac #28922: no longer need to cast into SR to take roots of fraction field elements</code></td></tr></table>\n",
    "created_at": "2020-01-06T01:39:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451489",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:2"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/012365f9814246858c38d2e0f43bf4b4552646d1"><code>012365f</code></a></td><td><code>Trac #28922: compute fractional powers of function field elements</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/734c9b2f542b00f605c152da3edd81cf134ed30c"><code>734c9b2</code></a></td><td><code>Trac #28922: no longer need to cast into SR to take roots of fraction field elements</code></td></tr></table>




---

archive/issue_comments_451490.json:
```json
{
    "body": "Changed commit from **[`aa9230c`](https://github.com/sagemath/sagetrac-mirror/commit/aa9230c41b708e7ec3df98eafa06ac148597a4c0)** to **[`734c9b2`](https://github.com/sagemath/sagetrac-mirror/commit/734c9b2f542b00f605c152da3edd81cf134ed30c)**",
    "created_at": "2020-01-06T01:39:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451490",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`aa9230c`](https://github.com/sagemath/sagetrac-mirror/commit/aa9230c41b708e7ec3df98eafa06ac148597a4c0)** to **[`734c9b2`](https://github.com/sagemath/sagetrac-mirror/commit/734c9b2f542b00f605c152da3edd81cf134ed30c)**



---

archive/issue_comments_451491.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n-This patch changes three things concerning series expansions in the function field code:\n+This patch changes four things concerning series expansions in the function field code:\n \n 1. The uniformizing variable can be specified\n \n@@ -30,3 +30,5 @@\n ```\n \n    returns `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^10)` instead of `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^9)`\n+\n+4. Function field elements can now be raised to fractional powers.  If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.\n``````\n",
    "created_at": "2020-01-06T01:43:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451491",
    "user": "https://github.com/BrentBaccala"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
-This patch changes three things concerning series expansions in the function field code:
+This patch changes four things concerning series expansions in the function field code:
 
 1. The uniformizing variable can be specified
 
@@ -30,3 +30,5 @@
 ```
 
    returns `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^10)` instead of `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^9)`
+
+4. Function field elements can now be raised to fractional powers.  If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.
``````




---

archive/issue_comments_451492.json:
```json
{
    "body": "<div id=\"comment:4\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/59081b1fdfb562fa3dc34766b90a6f83207a9531\"><code>59081b1</code></a></td><td><code>Merge tag '9.0' into public/28922</code></td></tr></table>\n",
    "created_at": "2020-01-06T01:46:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451492",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:4"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/59081b1fdfb562fa3dc34766b90a6f83207a9531"><code>59081b1</code></a></td><td><code>Merge tag '9.0' into public/28922</code></td></tr></table>




---

archive/issue_comments_451493.json:
```json
{
    "body": "Changed commit from **[`734c9b2`](https://github.com/sagemath/sagetrac-mirror/commit/734c9b2f542b00f605c152da3edd81cf134ed30c)** to **[`59081b1`](https://github.com/sagemath/sagetrac-mirror/commit/59081b1fdfb562fa3dc34766b90a6f83207a9531)**",
    "created_at": "2020-01-06T01:46:20Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451493",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`734c9b2`](https://github.com/sagemath/sagetrac-mirror/commit/734c9b2f542b00f605c152da3edd81cf134ed30c)** to **[`59081b1`](https://github.com/sagemath/sagetrac-mirror/commit/59081b1fdfb562fa3dc34766b90a6f83207a9531)**



---

archive/issue_comments_451494.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -19,16 +19,16 @@\n ```\n    now returns `I + s` instead of `I + s + O(s^5)`.\n \n-3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test case:\n+3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test:\n \n ```\n sage: K.<x> = FunctionField(GF(2)); _.<Y> = K[]\n sage: L.<y> = K.extension(Y^2 + Y + x + 1/x)\n sage: p = L.places_finite()[0]\n sage: m = L.completion(p)\n-sage: m(x+y, 10)\n+sage: m(x+y, 5)\n ```\n \n-   returns `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^10)` instead of `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^9)`\n+   returns `s^-1 + 1 + s^2 + s^4 + O(s^5)` instead of `s^-1 + 1 + s^2 + O(s^4)`\n \n 4. Function field elements can now be raised to fractional powers.  If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.\n``````\n",
    "created_at": "2020-01-06T01:47:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451494",
    "user": "https://github.com/BrentBaccala"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -19,16 +19,16 @@
 ```
    now returns `I + s` instead of `I + s + O(s^5)`.
 
-3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test case:
+3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test:
 
 ```
 sage: K.<x> = FunctionField(GF(2)); _.<Y> = K[]
 sage: L.<y> = K.extension(Y^2 + Y + x + 1/x)
 sage: p = L.places_finite()[0]
 sage: m = L.completion(p)
-sage: m(x+y, 10)
+sage: m(x+y, 5)
 ```
 
-   returns `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^10)` instead of `s^-1 + 1 + s^2 + s^4 + s^8 + O(s^9)`
+   returns `s^-1 + 1 + s^2 + s^4 + O(s^5)` instead of `s^-1 + 1 + s^2 + O(s^4)`
 
 4. Function field elements can now be raised to fractional powers.  If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.
``````




---

archive/issue_events_394383.json:
```json
{
    "actor": "https://github.com/BrentBaccala",
    "created_at": "2020-01-06T01:47:45Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394383"
}
```



---

archive/issue_comments_451495.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\n> 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n\nWhy is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?",
    "created_at": "2020-01-06T07:12:26Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451495",
    "user": "https://github.com/kwankyu"
}
```

<div id="comment:6" align="right">comment:6</div>

> 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 

Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?



---

archive/issue_comments_451496.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nReplying to [@kwankyu](#comment%3A6):\n> > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n> \n> \n> Why is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?  \n\nTaylor and Laurent series expansions in the Symbolic Ring are specified using absolute precision.\n\n```\nsage: var('x')\nx\n\nsage: sin(x).series(x,4)\n1*x + (-1/6)*x^3 + Order(x^4)\n\nsage: (1/(x^2+x)).series(x,4)\n1*x^(-1) + (-1) + 1*x + (-1)*x^2 + 1*x^3 + Order(x^4)\n\n```\n\nI am not aware of any other examples.",
    "created_at": "2020-01-06T15:54:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451496",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:7" align="right">comment:7</div>

Replying to [@kwankyu](#comment%3A6):
> > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 
> 
> 
> Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?  

Taylor and Laurent series expansions in the Symbolic Ring are specified using absolute precision.

```
sage: var('x')
x

sage: sin(x).series(x,4)
1*x + (-1/6)*x^3 + Order(x^4)

sage: (1/(x^2+x)).series(x,4)
1*x^(-1) + (-1) + 1*x + (-1)*x^2 + 1*x^3 + Order(x^4)

```

I am not aware of any other examples.



---

archive/issue_comments_451497.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nReplying to [@kwankyu](#comment%3A6):\n> > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n> \n> \n> Why is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?  \n\nHave you already written a lot of code that uses relative precision?",
    "created_at": "2020-01-06T17:06:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451497",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:8" align="right">comment:8</div>

Replying to [@kwankyu](#comment%3A6):
> > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 
> 
> 
> Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?  

Have you already written a lot of code that uses relative precision?



---

archive/issue_comments_451498.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nReplying to [@BrentBaccala](#comment%3A8):\n> Replying to [@kwankyu](#comment%3A6):\n> > > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n> > \n> > \n> > Why is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?  \n> \n> \n> Have you already written a lot of code that uses relative precision?\n\nNo. But no change to an existing interface should be made without a compelling reason.",
    "created_at": "2020-01-08T02:39:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451498",
    "user": "https://github.com/kwankyu"
}
```

<div id="comment:9" align="right">comment:9</div>

Replying to [@BrentBaccala](#comment%3A8):
> Replying to [@kwankyu](#comment%3A6):
> > > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 
> > 
> > 
> > Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?  
> 
> 
> Have you already written a lot of code that uses relative precision?

No. But no change to an existing interface should be made without a compelling reason.



---

archive/issue_comments_451499.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nReplying to [@kwankyu](#comment%3A9):\n> Replying to [@BrentBaccala](#comment%3A8):\n> > Replying to [@kwankyu](#comment%3A6):\n> > > > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n> > > \n> > > \n> > > Why is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?  \n> > \n> > \n> > Have you already written a lot of code that uses relative precision?\n> \n> \n> No. But no change to an existing interface should be made without a compelling reason.\n\nI agree.  I suggest making this change now, since I believe that a uniform interface is a compelling reason.",
    "created_at": "2020-01-08T04:06:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451499",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:10" align="right">comment:10</div>

Replying to [@kwankyu](#comment%3A9):
> Replying to [@BrentBaccala](#comment%3A8):
> > Replying to [@kwankyu](#comment%3A6):
> > > > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 
> > > 
> > > 
> > > Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?  
> > 
> > 
> > Have you already written a lot of code that uses relative precision?
> 
> 
> No. But no change to an existing interface should be made without a compelling reason.

I agree.  I suggest making this change now, since I believe that a uniform interface is a compelling reason.



---

archive/issue_comments_451500.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nAnother reason to use absolute precision is that a common construction is to calculate the principal part of the series expansion (i.e, the negative powers).  With absolute precision, it's easier to specify: `prec=0` instead of `prec=-A.valuation(pl)(f)`.",
    "created_at": "2020-01-12T18:56:06Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451500",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:11" align="right">comment:11</div>

Another reason to use absolute precision is that a common construction is to calculate the principal part of the series expansion (i.e, the negative powers).  With absolute precision, it's easier to specify: `prec=0` instead of `prec=-A.valuation(pl)(f)`.



---

archive/issue_comments_451501.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nMy comments:\n\n4. Function field elements can now be raised to fractional powers. \n\nAs far as I understand, fractional power, as an operation, is not well defined for elements of an algebraic function field. It may not even exist, and then you return a symbolic ring element. I don't get this. In general, I object to the idea of injecting symbolic ring stuff into exact function field computation.\n\n2. If a series expansion is exact, the `O(s^n)` is dropped. \n\nWhy slow down series expansion computation to check if it is exact? If you want an exact result for your computation, you can check it and get it. This does not make sense to me.\n\n1. The uniformizing variable can be specified\n\nOk. But please use the name `local_uniformizer`or shortly `uniformizer` for consistency. This is only acceptable if you do not clutter the series expansion code with the fractional power stuff.\n\n3. The precision is now specified as absolute precision, instead of relative. \n\nOk. But this need a deprecation warning as it is an user interface change.",
    "created_at": "2020-01-13T07:35:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451501",
    "user": "https://github.com/kwankyu"
}
```

<div id="comment:12" align="right">comment:12</div>

My comments:

4. Function field elements can now be raised to fractional powers. 

As far as I understand, fractional power, as an operation, is not well defined for elements of an algebraic function field. It may not even exist, and then you return a symbolic ring element. I don't get this. In general, I object to the idea of injecting symbolic ring stuff into exact function field computation.

2. If a series expansion is exact, the `O(s^n)` is dropped. 

Why slow down series expansion computation to check if it is exact? If you want an exact result for your computation, you can check it and get it. This does not make sense to me.

1. The uniformizing variable can be specified

Ok. But please use the name `local_uniformizer`or shortly `uniformizer` for consistency. This is only acceptable if you do not clutter the series expansion code with the fractional power stuff.

3. The precision is now specified as absolute precision, instead of relative. 

Ok. But this need a deprecation warning as it is an user interface change.



---

archive/issue_comments_451502.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nReplying to [@kwankyu](#comment%3A12):\n> My comments:\n> \n> 4. Function field elements can now be raised to fractional powers. \n> \n> As far as I understand, fractional power, as an operation, is not well defined for elements of an algebraic function field. It may not even exist, and then you return a symbolic ring element. I don't get this. In general, I object to the idea of injecting symbolic ring stuff into exact function field computation.\n\n\n\nOK, I'll drop the symbolic ring stuff, and only return fractional powers if they actually exist, otherwise raise an exception.\n\nI did the symbolic ring stuff so that a uniformizing variable could be specified as something like `sqrt(x)` even if such an element didn't actually exist.\n\n\n\n> 2. If a series expansion is exact, the `O(s^n)` is dropped. \n> \n> Why slow down series expansion computation to check if it is exact? If you want an exact result for your computation, you can check it and get it. This does not make sense to me.\n\n```\nsage: var('x')\nx\nsage: x.series(x)\n1*x + Order(x^20)\n```\n\n\nOK, not what I expected, but it's consistent with what you propose.\n\n\n\n> 1. The uniformizing variable can be specified\n> \n> Ok. But please use the name `local_uniformizer`or shortly `uniformizer` for consistency. This is only acceptable if you do not clutter the series expansion code with the fractional power stuff.\n\n\n\nOK, I'll go with `local_uniformizer`.  I'll rip the fractional power stuff out of the series expansion code and require an actual function field element to be specified as the `local_uniformizer`.\n\n\n\n> 3. The precision is now specified as absolute precision, instead of relative. \n> \n> Ok. But this need a deprecation warning as it is an user interface change.\n\n\n\nI'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.",
    "created_at": "2020-01-14T03:27:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451502",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:13" align="right">comment:13</div>

Replying to [@kwankyu](#comment%3A12):
> My comments:
> 
> 4. Function field elements can now be raised to fractional powers. 
> 
> As far as I understand, fractional power, as an operation, is not well defined for elements of an algebraic function field. It may not even exist, and then you return a symbolic ring element. I don't get this. In general, I object to the idea of injecting symbolic ring stuff into exact function field computation.



OK, I'll drop the symbolic ring stuff, and only return fractional powers if they actually exist, otherwise raise an exception.

I did the symbolic ring stuff so that a uniformizing variable could be specified as something like `sqrt(x)` even if such an element didn't actually exist.



> 2. If a series expansion is exact, the `O(s^n)` is dropped. 
> 
> Why slow down series expansion computation to check if it is exact? If you want an exact result for your computation, you can check it and get it. This does not make sense to me.

```
sage: var('x')
x
sage: x.series(x)
1*x + Order(x^20)
```


OK, not what I expected, but it's consistent with what you propose.



> 1. The uniformizing variable can be specified
> 
> Ok. But please use the name `local_uniformizer`or shortly `uniformizer` for consistency. This is only acceptable if you do not clutter the series expansion code with the fractional power stuff.



OK, I'll go with `local_uniformizer`.  I'll rip the fractional power stuff out of the series expansion code and require an actual function field element to be specified as the `local_uniformizer`.



> 3. The precision is now specified as absolute precision, instead of relative. 
> 
> Ok. But this need a deprecation warning as it is an user interface change.



I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.



---

archive/issue_comments_451503.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\n> > Ok. But this need a deprecation warning as it is an user interface change.\n> \n> \n> \n> \n> I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.\n> \n\nIt would suffice to warn the user:\n\n```\nsage.misc.superseded.warning(28922, \"Mind that prec now means absolute precision.\")\n```",
    "created_at": "2020-01-14T05:35:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451503",
    "user": "https://github.com/kwankyu"
}
```

<div id="comment:14" align="right">comment:14</div>

> > Ok. But this need a deprecation warning as it is an user interface change.
> 
> 
> 
> 
> I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.
> 

It would suffice to warn the user:

```
sage.misc.superseded.warning(28922, "Mind that prec now means absolute precision.")
```



---

archive/issue_comments_451504.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nReplying to [@kwankyu](#comment%3A14):\n> > > Ok. But this need a deprecation warning as it is an user interface change.\n> > \n> > \n> > \n> > \n> > I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.\n> > \n> \n> \n> It would suffice to warn the user:\n> \n> ```\n> sage.misc.superseded.warning(28922, \"Mind that prec now means absolute precision.\")\n> ```\n\nI don't like that user interface.  It seems like the only way to disable the warning is to disable all warnings.  Since the Trac number is included in the message, it would be nice to have a feature where warnings associated with given tickets are silenced, but that's another feature entirely.\n\nI'll just drop this change.",
    "created_at": "2020-01-14T20:59:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451504",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:15" align="right">comment:15</div>

Replying to [@kwankyu](#comment%3A14):
> > > Ok. But this need a deprecation warning as it is an user interface change.
> > 
> > 
> > 
> > 
> > I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.
> > 
> 
> 
> It would suffice to warn the user:
> 
> ```
> sage.misc.superseded.warning(28922, "Mind that prec now means absolute precision.")
> ```

I don't like that user interface.  It seems like the only way to disable the warning is to disable all warnings.  Since the Trac number is included in the message, it would be nice to have a feature where warnings associated with given tickets are silenced, but that's another feature entirely.

I'll just drop this change.



---

archive/issue_comments_451505.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -2,11 +2,11 @@\n \n 1. The uniformizing variable can be specified\n \n-   This patch adds an optional `uvar` argument to `FunctionField`'s `completion()` method.  It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.\n+   This patch adds an optional `local_uniformizer` argument to `FunctionField`'s `completion()` method.  ~~It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.~~\n \n    If the specified element is not a uniformizing variable at the given place, an exception is raised.\n \n-2. If a series expansion is exact, the `O(s^n)` is dropped.  So, for example, the following test case:\n+2. ~~If a series expansion is exact, the `O(s^n)` is dropped.  So, for example, the following test case:~~\n \n ```\n K.<x> = FunctionField(QQbar); _.<Y> = K[]\n@@ -17,9 +17,9 @@\n m = L.completion(pl, prec=5)\n m(x)\n ```\n-   now returns `I + s` instead of `I + s + O(s^5)`.\n+   ~~now returns `I + s` instead of `I + s + O(s^5)`.~~\n \n-3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test:\n+3. ~~The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test:~~\n \n ```\n sage: K.<x> = FunctionField(GF(2)); _.<Y> = K[]\n@@ -29,6 +29,6 @@\n sage: m(x+y, 5)\n ```\n \n-   returns `s^-1 + 1 + s^2 + s^4 + O(s^5)` instead of `s^-1 + 1 + s^2 + O(s^4)`\n+   ~~returns `s^-1 + 1 + s^2 + s^4 + O(s^5)` instead of `s^-1 + 1 + s^2 + O(s^4)`~~\n \n-4. Function field elements can now be raised to fractional powers.  If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.\n+4. Function field elements can now be raised to fractional powers.  ~~If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.~~  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.\n``````\n",
    "created_at": "2020-01-14T20:59:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451505",
    "user": "https://github.com/BrentBaccala"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -2,11 +2,11 @@
 
 1. The uniformizing variable can be specified
 
-   This patch adds an optional `uvar` argument to `FunctionField`'s `completion()` method.  It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.
+   This patch adds an optional `local_uniformizer` argument to `FunctionField`'s `completion()` method.  ~~It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.~~
 
    If the specified element is not a uniformizing variable at the given place, an exception is raised.
 
-2. If a series expansion is exact, the `O(s^n)` is dropped.  So, for example, the following test case:
+2. ~~If a series expansion is exact, the `O(s^n)` is dropped.  So, for example, the following test case:~~
 
 ```
 K.<x> = FunctionField(QQbar); _.<Y> = K[]
@@ -17,9 +17,9 @@
 m = L.completion(pl, prec=5)
 m(x)
 ```
-   now returns `I + s` instead of `I + s + O(s^5)`.
+   ~~now returns `I + s` instead of `I + s + O(s^5)`.~~
 
-3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test:
+3. ~~The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage.  So, now, this test:~~
 
 ```
 sage: K.<x> = FunctionField(GF(2)); _.<Y> = K[]
@@ -29,6 +29,6 @@
 sage: m(x+y, 5)
 ```
 
-   returns `s^-1 + 1 + s^2 + s^4 + O(s^5)` instead of `s^-1 + 1 + s^2 + O(s^4)`
+   ~~returns `s^-1 + 1 + s^2 + s^4 + O(s^5)` instead of `s^-1 + 1 + s^2 + O(s^4)`~~
 
-4. Function field elements can now be raised to fractional powers.  If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.
+4. Function field elements can now be raised to fractional powers.  ~~If the fractional power does not exist in the function field, a result in the Symbolic Ring is returned.~~  While not, strictly speaking, a change to the series expansion code, this change allows fractional powers like `x^(1/3)` to be specified as uniformizing variables.
``````




---

archive/issue_comments_451506.json:
```json
{
    "body": "<div id=\"comment:16\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7c9d2611933d265a5bc9feed88da50bfa1517143\"><code>7c9d261</code></a></td><td><code>Trac #28922: don't check for exact result in series expansion</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6df8f55d926348fc906ef30446a3aaf72a4fc6ca\"><code>6df8f55</code></a></td><td><code>Trac #28922: if a fractional power can't be taken, raise an exception</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/faeb46d16e7c65305257847f5d6018c6a7a40ef7\"><code>faeb46d</code></a></td><td><code>Trac #28922: use 'local_uniformizer' instead of 'uvar' and require</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c258884d00a0e696e4f080a4564c49f1ecb55e6e\"><code>c258884</code></a></td><td><code>Revert \"Trac #28922: function field series expansion now uses absolute precision,\"</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0ab8240ca35d7d87544d99dd5be0cb9bacc3f5aa\"><code>0ab8240</code></a></td><td><code>Merge tag '9.1.beta0' into public/28922</code></td></tr></table>\n",
    "created_at": "2020-01-15T01:40:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451506",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:16"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7c9d2611933d265a5bc9feed88da50bfa1517143"><code>7c9d261</code></a></td><td><code>Trac #28922: don't check for exact result in series expansion</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6df8f55d926348fc906ef30446a3aaf72a4fc6ca"><code>6df8f55</code></a></td><td><code>Trac #28922: if a fractional power can't be taken, raise an exception</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/faeb46d16e7c65305257847f5d6018c6a7a40ef7"><code>faeb46d</code></a></td><td><code>Trac #28922: use 'local_uniformizer' instead of 'uvar' and require</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c258884d00a0e696e4f080a4564c49f1ecb55e6e"><code>c258884</code></a></td><td><code>Revert "Trac #28922: function field series expansion now uses absolute precision,"</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0ab8240ca35d7d87544d99dd5be0cb9bacc3f5aa"><code>0ab8240</code></a></td><td><code>Merge tag '9.1.beta0' into public/28922</code></td></tr></table>




---

archive/issue_comments_451507.json:
```json
{
    "body": "Changed commit from **[`59081b1`](https://github.com/sagemath/sagetrac-mirror/commit/59081b1fdfb562fa3dc34766b90a6f83207a9531)** to **[`0ab8240`](https://github.com/sagemath/sagetrac-mirror/commit/0ab8240ca35d7d87544d99dd5be0cb9bacc3f5aa)**",
    "created_at": "2020-01-15T01:40:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451507",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`59081b1`](https://github.com/sagemath/sagetrac-mirror/commit/59081b1fdfb562fa3dc34766b90a6f83207a9531)** to **[`0ab8240`](https://github.com/sagemath/sagetrac-mirror/commit/0ab8240ca35d7d87544d99dd5be0cb9bacc3f5aa)**



---

archive/issue_comments_451508.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nIs the algorithm for computing the fractional power correct? I don't see how `root` has the divisor you want.",
    "created_at": "2020-01-15T08:35:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451508",
    "user": "https://github.com/kwankyu"
}
```

<div id="comment:17" align="right">comment:17</div>

Is the algorithm for computing the fractional power correct? I don't see how `root` has the divisor you want.



---

archive/issue_comments_451509.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nReplying to [@kwankyu](#comment%3A17):\n> Is the algorithm for computing the fractional power correct? I don't see how `root` has the divisor you want.\n\n```\n191         numer = right.numerator()\n192         denom = right.denominator()\n193 \n194         if denom == 1:\n195             return self._pow_int(right)\n196         else:\n197             try:\n198                 D = self.divisor()\n199                 Droot = sum([Integer(m*right)*pl for pl,m in D.dict().items()])\n200                 basis = (-Droot).basis_function_space()\n201                 root = basis[0]\n202                 coeff = self.parent().constant_base_field()(self**numer)/(root**denom))**(1/denom)\n203                 return coeff*root\n204             except (TypeError, IndexError):\n205                 pass\n206             raise ValueError(\"not a %s power\"%Integer(denom).ordinal_str())\n```\n\nThe algorithm's logic runs like this:\n\n1. Valuations are multiplicative homomorphisms, i.e, \u03bc(fg) = \u03bc(f) + \u03bc(g)\n2. This implies \u03bc(f<sup>n</sup>) = n\u03bc(f)\n3. So if the divisor of f is \u2211mP, the divisor of f<sup>n</sup> is \u2211nmP\n4. All of the nm products have to be integers for this to be a well-formed divisor\n5. This yields line 199, with `TypeError` raised if any of nm's aren't integers\n6. `Droot` has total degree zero, so `basis` will have either zero or one elements\n7. If it has zero elements, line 201 will raise `IndexError`\n8. If we make it to line 202, we've found an element with the correct divisor\n\nIs there a flaw in any of this?",
    "created_at": "2020-01-15T20:43:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451509",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:18" align="right">comment:18</div>

Replying to [@kwankyu](#comment%3A17):
> Is the algorithm for computing the fractional power correct? I don't see how `root` has the divisor you want.

```
191         numer = right.numerator()
192         denom = right.denominator()
193 
194         if denom == 1:
195             return self._pow_int(right)
196         else:
197             try:
198                 D = self.divisor()
199                 Droot = sum([Integer(m*right)*pl for pl,m in D.dict().items()])
200                 basis = (-Droot).basis_function_space()
201                 root = basis[0]
202                 coeff = self.parent().constant_base_field()(self**numer)/(root**denom))**(1/denom)
203                 return coeff*root
204             except (TypeError, IndexError):
205                 pass
206             raise ValueError("not a %s power"%Integer(denom).ordinal_str())
```

The algorithm's logic runs like this:

1. Valuations are multiplicative homomorphisms, i.e, μ(fg) = μ(f) + μ(g)
2. This implies μ(f<sup>n</sup>) = nμ(f)
3. So if the divisor of f is ∑mP, the divisor of f<sup>n</sup> is ∑nmP
4. All of the nm products have to be integers for this to be a well-formed divisor
5. This yields line 199, with `TypeError` raised if any of nm's aren't integers
6. `Droot` has total degree zero, so `basis` will have either zero or one elements
7. If it has zero elements, line 201 will raise `IndexError`
8. If we make it to line 202, we've found an element with the correct divisor

Is there a flaw in any of this?



---

archive/issue_comments_451510.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nReplying to [@BrentBaccala](#comment%3A18):\n\n> The algorithm's logic runs like this:\n> \n> 1. Valuations are multiplicative homomorphisms, i.e, \u03bc(fg) = \u03bc(f) + \u03bc(g)\n> 2. This implies \u03bc(f<sup>n</sup>) = n\u03bc(f)\n> 3. So if the divisor of f is \u2211mP, the divisor of f<sup>n</sup> is \u2211nmP\n> 4. All of the nm products have to be integers for this to be a well-formed divisor\n> 5. This yields line 199, with `TypeError` raised if any of nm's aren't integers\n> 6. `Droot` has total degree zero, so `basis` will have either zero or one elements\n> 7. If it has zero elements, line 201 will raise `IndexError`\n> 8. If we make it to line 202, we've found an element with the correct divisor\n\nI see. Thanks. \n\nIt seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.",
    "created_at": "2020-01-16T04:47:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451510",
    "user": "https://github.com/kwankyu"
}
```

<div id="comment:19" align="right">comment:19</div>

Replying to [@BrentBaccala](#comment%3A18):

> The algorithm's logic runs like this:
> 
> 1. Valuations are multiplicative homomorphisms, i.e, μ(fg) = μ(f) + μ(g)
> 2. This implies μ(f<sup>n</sup>) = nμ(f)
> 3. So if the divisor of f is ∑mP, the divisor of f<sup>n</sup> is ∑nmP
> 4. All of the nm products have to be integers for this to be a well-formed divisor
> 5. This yields line 199, with `TypeError` raised if any of nm's aren't integers
> 6. `Droot` has total degree zero, so `basis` will have either zero or one elements
> 7. If it has zero elements, line 201 will raise `IndexError`
> 8. If we make it to line 202, we've found an element with the correct divisor

I see. Thanks. 

It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.



---

archive/issue_comments_451511.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nReplying to [@kwankyu](#comment%3A19):\n\n> I see. Thanks. \n> \n> It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.\n\nThat's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?",
    "created_at": "2020-01-16T04:53:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451511",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:20" align="right">comment:20</div>

Replying to [@kwankyu](#comment%3A19):

> I see. Thanks. 
> 
> It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.

That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?



---

archive/issue_comments_451512.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nReplying to [@BrentBaccala](#comment%3A20):\n> Replying to [@kwankyu](#comment%3A19):\n> \n> > I see. Thanks. \n> > \n> > It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.\n> \n> \n> That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?\n> \n\n`self`/`root^n` is in the full constant field, which is the Riemann-Roch space of zero divisor.",
    "created_at": "2020-01-16T05:09:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451512",
    "user": "https://github.com/kwankyu"
}
```

<div id="comment:21" align="right">comment:21</div>

Replying to [@BrentBaccala](#comment%3A20):
> Replying to [@kwankyu](#comment%3A19):
> 
> > I see. Thanks. 
> > 
> > It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.
> 
> 
> That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?
> 

`self`/`root^n` is in the full constant field, which is the Riemann-Roch space of zero divisor.



---

archive/issue_events_394384.json:
```json
{
    "actor": "https://github.com/BrentBaccala",
    "created_at": "2020-01-16T20:06:41Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394384"
}
```



---

archive/issue_events_394385.json:
```json
{
    "actor": "https://github.com/BrentBaccala",
    "created_at": "2020-01-16T20:06:41Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394385"
}
```



---

archive/issue_comments_451513.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nReplying to [@kwankyu](#comment%3A21):\n> Replying to [@BrentBaccala](#comment%3A20):\n> > Replying to [@kwankyu](#comment%3A19):\n> > \n> > > I see. Thanks. \n> > > \n> > > It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.\n> > \n> > \n> > That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?\n> > \n> \n> \n> `self`/`root^n` is in the full constant field, which is the Riemann-Roch space of zero divisor.\n\nOK, I see.\n\nThank you.\n\nI spent quite a while convincing myself that the homomorphism logic in steps 1-5 was correct, but I never considered for a minute that the zero divisor might have dimension greater than one.",
    "created_at": "2020-01-16T20:06:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451513",
    "user": "https://github.com/BrentBaccala"
}
```

<div id="comment:22" align="right">comment:22</div>

Replying to [@kwankyu](#comment%3A21):
> Replying to [@BrentBaccala](#comment%3A20):
> > Replying to [@kwankyu](#comment%3A19):
> > 
> > > I see. Thanks. 
> > > 
> > > It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.
> > 
> > 
> > That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?
> > 
> 
> 
> `self`/`root^n` is in the full constant field, which is the Riemann-Roch space of zero divisor.

OK, I see.

Thank you.

I spent quite a while convincing myself that the homomorphism logic in steps 1-5 was correct, but I never considered for a minute that the zero divisor might have dimension greater than one.



---

archive/issue_events_394386.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-04-14T19:41:51Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394386"
}
```



---

archive/issue_events_394387.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-04-14T19:41:51Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394387"
}
```



---

archive/issue_comments_451514.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nBatch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451514",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:23" align="right">comment:23</div>

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_comments_451515.json:
```json
{
    "body": "Changed commit from **[`0ab8240`](https://github.com/sagemath/sagetrac-mirror/commit/0ab8240ca35d7d87544d99dd5be0cb9bacc3f5aa)** to **[`4189256`](https://github.com/sagemath/sagetrac-mirror/commit/4189256a741231c4f6cd1305c548fcc05d9fff41)**",
    "created_at": "2020-08-03T02:42:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451515",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`0ab8240`](https://github.com/sagemath/sagetrac-mirror/commit/0ab8240ca35d7d87544d99dd5be0cb9bacc3f5aa)** to **[`4189256`](https://github.com/sagemath/sagetrac-mirror/commit/4189256a741231c4f6cd1305c548fcc05d9fff41)**



---

archive/issue_comments_451516.json:
```json
{
    "body": "<div id=\"comment:24\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/82405520fcbae67fb67b658928ea0dc78b3350b0\"><code>8240552</code></a></td><td><code>Merge tag '9.2.beta0' into public/28922</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6fd8451ac5cd87ea64940b696c156db437721a28\"><code>6fd8451</code></a></td><td><code>Trac #28922: silence pyflakes warnings</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4189256a741231c4f6cd1305c548fcc05d9fff41\"><code>4189256</code></a></td><td><code>an attempt to implement `__pow__` for function field elements... but</code></td></tr></table>\n",
    "created_at": "2020-08-03T02:42:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451516",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:24"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/82405520fcbae67fb67b658928ea0dc78b3350b0"><code>8240552</code></a></td><td><code>Merge tag '9.2.beta0' into public/28922</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6fd8451ac5cd87ea64940b696c156db437721a28"><code>6fd8451</code></a></td><td><code>Trac #28922: silence pyflakes warnings</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4189256a741231c4f6cd1305c548fcc05d9fff41"><code>4189256</code></a></td><td><code>an attempt to implement `__pow__` for function field elements... but</code></td></tr></table>




---

archive/issue_events_394388.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-09-05T19:21:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394388"
}
```



---

archive/issue_events_394389.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-09-05T19:21:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394389"
}
```



---

archive/issue_comments_451517.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nSetting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451517",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:26" align="right">comment:26</div>

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_394390.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394390"
}
```



---

archive/issue_events_394391.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394391"
}
```



---

archive/issue_events_394392.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T00:44:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394392"
}
```



---

archive/issue_events_394393.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T00:44:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394393"
}
```



---

archive/issue_comments_451518.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nSetting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/28922#issuecomment-451518",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:27" align="right">comment:27</div>

Setting a new milestone for this ticket based on a cursory review.



---

archive/issue_events_394394.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394394"
}
```



---

archive/issue_events_394395.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394395"
}
```



---

archive/issue_events_394396.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-02T20:27:49Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394396"
}
```



---

archive/issue_events_394397.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-02T20:27:49Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394397"
}
```



---

archive/issue_events_394398.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394398"
}
```



---

archive/issue_events_394399.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/28922",
    "milestone_number": null,
    "milestone_title": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/28922#event-394399"
}
```
