# Issue 28974: F-strings (PEP 498) are not correctly handled by Sage's preparser

archive/issues_028737.json:
```json
{
    "body": "F-strings are defined by PEP 498 ([https://www.python.org/dev/peps/pep-0498/](https://www.python.org/dev/peps/pep-0498/))\n\nCurrently, in sage, they are not touched by the preparser which can cause incoherences.\n\nFor example, the following code\n\n```\nprint (f'{1/3}')\nprint (1/3)\na = 1\nprint (f'{a/3}')\nprint (a/3)\n```\n\noutputs\n\n```\n0.3333333333333333\n1/3\n1/3\n1/3\n```\n\nThe difference between the first and second print statement is due to the facts that:\n- in the second print statement, the preparser replace 1/3 by Integer(1)/Integer(3) which is a Rational\n- in the first print, the preparser does not touch the content of the string between the brackets\n\nOther incoherences can be found with power:\n\n```\nprint (f'{2^3}')\nprint (2^3)\n```\n\noutputs\n\n```\n1\n8\n```\n\n\nCC:  @jcamp0x2a @kliem @slel @embray\n\nKeywords: f-string, preparse, preparser\n\nBranch/Commit: 3eedd36e37a5b1d1d966c078c2f02a05e5253060\n\nReviewer: Markus Wageringel\n\nAuthor: Joshua Campbell\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/28974\n\n",
    "closed_at": "2020-10-31T18:08:12Z",
    "created_at": "2020-01-09T16:32:53Z",
    "labels": [
        "component: user interface",
        "critical",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.3",
    "title": "F-strings (PEP 498) are not correctly handled by Sage's preparser",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/28974",
    "user": "https://trac.sagemath.org/admin/accounts/users/bouvier"
}
```
F-strings are defined by PEP 498 ([https://www.python.org/dev/peps/pep-0498/](https://www.python.org/dev/peps/pep-0498/))

Currently, in sage, they are not touched by the preparser which can cause incoherences.

For example, the following code

```
print (f'{1/3}')
print (1/3)
a = 1
print (f'{a/3}')
print (a/3)
```

outputs

```
0.3333333333333333
1/3
1/3
1/3
```

The difference between the first and second print statement is due to the facts that:
- in the second print statement, the preparser replace 1/3 by Integer(1)/Integer(3) which is a Rational
- in the first print, the preparser does not touch the content of the string between the brackets

Other incoherences can be found with power:

```
print (f'{2^3}')
print (2^3)
```

outputs

```
1
8
```


CC:  @jcamp0x2a @kliem @slel @embray

Keywords: f-string, preparse, preparser

Branch/Commit: 3eedd36e37a5b1d1d966c078c2f02a05e5253060

Reviewer: Markus Wageringel

Author: Joshua Campbell

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/28974





---

archive/issue_comments_432063.json:
```json
{
    "body": "<a id='comment:1'></a>Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432063",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:1'></a>Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_events_073353.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-04-14T19:41:51Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28974#event-73353"
}
```



---

archive/issue_comments_432064.json:
```json
{
    "body": "Changing priority from major to critical.",
    "created_at": "2020-08-29T20:58:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432064",
    "user": "https://github.com/mkoeppe"
}
```

Changing priority from major to critical.



---

archive/issue_comments_432065.json:
```json
{
    "body": "<a id='comment:4'></a>Hmm, seems tricky due to the possibility of nesting strings -- including other f-strings -- inside their replacement sections, like in the following:\n\n```python\n>>> f\"{ 'abc-1-2'.upper() }\" # Don't want 'ABC-Integer(1)-Integer(2)'\n'ABC-1-2'\n>>> f\"\"\"1 { f'''2 { f\"4 { f'8 { 2**4 } 8' } 4\" } 2''' } 1\"\"\" # Ideally 2^4\n'1 2 4 8 16 8 4 2 1'\n```\n\nI can take a stab at implementing this since the preparser code is somewhat fresh in my mind from troubleshooting #30417.",
    "created_at": "2020-08-30T04:54:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432065",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:4'></a>Hmm, seems tricky due to the possibility of nesting strings -- including other f-strings -- inside their replacement sections, like in the following:

```python
>>> f"{ 'abc-1-2'.upper() }" # Don't want 'ABC-Integer(1)-Integer(2)'
'ABC-1-2'
>>> f"""1 { f'''2 { f"4 { f'8 { 2**4 } 8' } 4" } 2''' } 1""" # Ideally 2^4
'1 2 4 8 16 8 4 2 1'
```

I can take a stab at implementing this since the preparser code is somewhat fresh in my mind from troubleshooting #30417.



---

archive/issue_comments_432066.json:
```json
{
    "body": "<a id='comment:5'></a>I think it will be a great improvement already if it can handle simple cases; I would not worry about nested f-strings too much.",
    "created_at": "2020-08-30T18:12:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432066",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:5'></a>I think it will be a great improvement already if it can handle simple cases; I would not worry about nested f-strings too much.



---

archive/issue_comments_432067.json:
```json
{
    "body": "<a id='comment:6'></a>The nested case turned out to be fairly straight-forward to implement after all. Have pushed a rough draft. It handles, among other things, the two examples I posted before.\n\nStill need to:\n- deal with `{{` and `}}` escape sequences in literal portion of F-string.\n- treat format specifier as literal except for portions surrounded by braces in order to avoid an error b/c of something like `f'{x:5}'` transforming into `f'{x:Integer(5)}'`, which is invalid. `f'{x:{5}}'` is a workaround, though.\n- add lots of new doctests to deal with all these fun corner cases.",
    "created_at": "2020-08-31T00:33:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432067",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:6'></a>The nested case turned out to be fairly straight-forward to implement after all. Have pushed a rough draft. It handles, among other things, the two examples I posted before.

Still need to:
- deal with `{{` and `}}` escape sequences in literal portion of F-string.
- treat format specifier as literal except for portions surrounded by braces in order to avoid an error b/c of something like `f'{x:5}'` transforming into `f'{x:Integer(5)}'`, which is invalid. `f'{x:{5}}'` is a workaround, though.
- add lots of new doctests to deal with all these fun corner cases.



---

archive/issue_comments_432068.json:
```json
{
    "body": "<a id='comment:7'></a>Thanks for your work on the preparser. I have not looked at your code in detail yet, but I think the function `containing_block` might be useful for the nested cases. It could be used to extract a substring that is preparsed individually. For example:\n\n```\nsage: s = \"\"\"1 { f'''2 { f\"4 { f'8 { 2**4 } 8' } 4\" } 2''' } 1\"\"\"\nsage: sage.repl.preparse.containing_block(s, 2, delimiters=['{}'])\n(2, 47)\nsage: print(s[slice(*_)])\n{ f'''2 { f\"4 { f'8 { 2**4 } 8' } 4\" } 2''' }\nsage: for idx in [2, 10, 16, 22]: print(s[slice(*sage.repl.preparse.containing_block(s, idx, delimiters=['{}']))])\n{ f'''2 { f\"4 { f'8 { 2**4 } 8' } 4\" } 2''' }\n{ f\"4 { f'8 { 2**4 } 8' } 4\" }\n{ f'8 { 2**4 } 8' }\n{ 2**4 }\n```",
    "created_at": "2020-08-31T06:38:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432068",
    "user": "https://github.com/mwageringel"
}
```

<a id='comment:7'></a>Thanks for your work on the preparser. I have not looked at your code in detail yet, but I think the function `containing_block` might be useful for the nested cases. It could be used to extract a substring that is preparsed individually. For example:

```
sage: s = """1 { f'''2 { f"4 { f'8 { 2**4 } 8' } 4" } 2''' } 1"""
sage: sage.repl.preparse.containing_block(s, 2, delimiters=['{}'])
(2, 47)
sage: print(s[slice(*_)])
{ f'''2 { f"4 { f'8 { 2**4 } 8' } 4" } 2''' }
sage: for idx in [2, 10, 16, 22]: print(s[slice(*sage.repl.preparse.containing_block(s, idx, delimiters=['{}']))])
{ f'''2 { f"4 { f'8 { 2**4 } 8' } 4" } 2''' }
{ f"4 { f'8 { 2**4 } 8' } 4" }
{ f'8 { 2**4 } 8' }
{ 2**4 }
```



---

archive/issue_comments_432069.json:
```json
{
    "body": "<a id='comment:8'></a>Replying to [comment:7 gh-mwageringel]:\n> Thanks for your work on the preparser. I have not looked at your code in detail yet, but I think the function `containing_block` might be useful for the nested cases. It could be used to extract a substring that is preparsed individually.\n\n\nThank you. I will take a look at `containing_block` and see if I can use it to simplify things. I'm concerned that it might not work for multi-line F-strings, though, since each line is preparsed separately, and so the braces on any one line may be unbalanced.",
    "created_at": "2020-08-31T16:21:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432069",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:8'></a>Replying to [comment:7 gh-mwageringel]:
> Thanks for your work on the preparser. I have not looked at your code in detail yet, but I think the function `containing_block` might be useful for the nested cases. It could be used to extract a substring that is preparsed individually.


Thank you. I will take a look at `containing_block` and see if I can use it to simplify things. I'm concerned that it might not work for multi-line F-strings, though, since each line is preparsed separately, and so the braces on any one line may be unbalanced.



---

archive/issue_comments_432070.json:
```json
{
    "body": "<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-31T22:16:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432070",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:10'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_432071.json:
```json
{
    "body": "<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-01T02:28:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432071",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_432072.json:
```json
{
    "body": "<a id='comment:12'></a>I ran into a snag with another, later stage of the preparser, `preparse_numeric_literals`, and would like feedback on how to proceed.\n\nExpressions like `3.14` and `5j` get turned into `RealNumber('3.14')` and `ComplexNumber(0, '5')`. That's fine when using a double-quoted F-string, but it of course fails when surrounded by single-quotes in an F-string:\n\n```python\nsage: f\"{3.14}\"\n'3.14000000000000'\nsage: f\"{5j}\"\n'5.00000000000000*I'\nsage: f'{3.14}'\n  File \"<ipython-input-11-8042a075c204>\", line 1\n    f'{RealNumber('3.14')}'\n                      ^\nSyntaxError: invalid syntax\n\nsage: f'{5j}'\n  File \"<ipython-input-12-a4948e5b5673>\", line 1\n    f'{ComplexNumber(0, '5')}'\n                         ^\nSyntaxError: invalid syntax\n\nsage: f'{3.14r}'\n'3.14'\nsage: f'{5jr}'\n'5j'\n```\n\nI've \"solved\" this by keeping track of which quotation marks (`', \", ''', \"\"\"`) have been used by F-strings and telling `preparse_numeric_literals` to use one of the unused ones instead, if any. In the -- perhaps rare -- case of all of them being used up, numeric wrapping will not occur. For example:\n\n```python\nsage: f'{3.14}' + f\"{3.14}\" + f'''{3.14}'''  # \"\"\" is available to use\n'3.140000000000003.140000000000003.14000000000000'\nsage: f'{3.14}' + f\"{3.14}\" + f'''{3.14}''' + f\"\"\"{3.14}\"\"\"  # no longer\n'3.143.143.143.14'\nsage: f\"\"\"{f'''{f\"{3.14}\"}'''}\"\"\"  # ' is available to use\n'3.14000000000000'\nsage: f\"\"\"{f'''{f\"{f'{3.14}'}\"}'''}\"\"\"  # no longer\n'3.14'\n```\n\nIs this acceptable? The only other way forward I see at the moment would be to modify Sage's RealNumber and ComplexNumber to accept something like a (digits, exponent) tuple like `([3, 1, 4], 1)` in place of the string '3.14'. Then have `preparse_numeric_literals` use those to avoid adding any of its own quotation marks whatsoever. I'm not familiar with the sage.rings code nor do I have much experience with Cython, and there's lots of Cython in there, so I could do some damage mucking around :)\n\nOn a brighter note, I figured out how to handle the `{{` and `}}` escape sequences. I also found Python's own set of [test cases for F-strings](https://github.com/python/cpython/blob/3.6/Lib/test/test_fstring.py) so that should be a good source of inspiration for doctests. I turned that file into a .sage so the preparser could have a go at it, and the only failures at this point seem to be related to the format specifier problem I already noted in a previous comment.",
    "created_at": "2020-09-01T02:55:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432072",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:12'></a>I ran into a snag with another, later stage of the preparser, `preparse_numeric_literals`, and would like feedback on how to proceed.

Expressions like `3.14` and `5j` get turned into `RealNumber('3.14')` and `ComplexNumber(0, '5')`. That's fine when using a double-quoted F-string, but it of course fails when surrounded by single-quotes in an F-string:

```python
sage: f"{3.14}"
'3.14000000000000'
sage: f"{5j}"
'5.00000000000000*I'
sage: f'{3.14}'
  File "<ipython-input-11-8042a075c204>", line 1
    f'{RealNumber('3.14')}'
                      ^
SyntaxError: invalid syntax

sage: f'{5j}'
  File "<ipython-input-12-a4948e5b5673>", line 1
    f'{ComplexNumber(0, '5')}'
                         ^
SyntaxError: invalid syntax

sage: f'{3.14r}'
'3.14'
sage: f'{5jr}'
'5j'
```

I've "solved" this by keeping track of which quotation marks (`', ", ''', """`) have been used by F-strings and telling `preparse_numeric_literals` to use one of the unused ones instead, if any. In the -- perhaps rare -- case of all of them being used up, numeric wrapping will not occur. For example:

```python
sage: f'{3.14}' + f"{3.14}" + f'''{3.14}'''  # """ is available to use
'3.140000000000003.140000000000003.14000000000000'
sage: f'{3.14}' + f"{3.14}" + f'''{3.14}''' + f"""{3.14}"""  # no longer
'3.143.143.143.14'
sage: f"""{f'''{f"{3.14}"}'''}"""  # ' is available to use
'3.14000000000000'
sage: f"""{f'''{f"{f'{3.14}'}"}'''}"""  # no longer
'3.14'
```

Is this acceptable? The only other way forward I see at the moment would be to modify Sage's RealNumber and ComplexNumber to accept something like a (digits, exponent) tuple like `([3, 1, 4], 1)` in place of the string '3.14'. Then have `preparse_numeric_literals` use those to avoid adding any of its own quotation marks whatsoever. I'm not familiar with the sage.rings code nor do I have much experience with Cython, and there's lots of Cython in there, so I could do some damage mucking around :)

On a brighter note, I figured out how to handle the `{{` and `}}` escape sequences. I also found Python's own set of [test cases for F-strings](https://github.com/python/cpython/blob/3.6/Lib/test/test_fstring.py) so that should be a good source of inspiration for doctests. I turned that file into a .sage so the preparser could have a go at it, and the only failures at this point seem to be related to the format specifier problem I already noted in a previous comment.



---

archive/issue_comments_432073.json:
```json
{
    "body": "<a id='comment:13'></a>This might be ugly, but would be more reliable and less messy than dealing with nesting of quotation marks.  I don't know if it would be easy though.  What if the preparser replaced all numerical literals in the format string (of any sort that are already handled by the preparser) with variables?  Something like:\n\n```\nf'{3.14} {5j}' ->\n__sage_tmp_literals = [RealNumber('3.14'), ComplexNumber(0, '5')]; f'{__sage_tmp_literals[0]} {__sage_tmp_literals[1]}'; del __sage_tmp_literals\n```",
    "created_at": "2020-09-01T13:26:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432073",
    "user": "https://github.com/embray"
}
```

<a id='comment:13'></a>This might be ugly, but would be more reliable and less messy than dealing with nesting of quotation marks.  I don't know if it would be easy though.  What if the preparser replaced all numerical literals in the format string (of any sort that are already handled by the preparser) with variables?  Something like:

```
f'{3.14} {5j}' ->
__sage_tmp_literals = [RealNumber('3.14'), ComplexNumber(0, '5')]; f'{__sage_tmp_literals[0]} {__sage_tmp_literals[1]}'; del __sage_tmp_literals
```



---

archive/issue_comments_432074.json:
```json
{
    "body": "<a id='comment:14'></a>Replying to [comment:13 embray]:\n> This might be ugly, but would be more reliable and less messy than dealing with nesting of quotation marks.  I don't know if it would be easy though.  What if the preparser replaced all numerical literals in the format string (of any sort that are already handled by the preparser) with variables?  Something like:\n> \n> \n> ```\n> f'{3.14} {5j}' ->\n> __sage_tmp_literals = [RealNumber('3.14'), ComplexNumber(0, '5')]; f'{__sage_tmp_literals[0]} {__sage_tmp_literals[1]}'; del __sage_tmp_literals\n> ```\n\n\nI really like the idea, and I believe something similar is already occurring when preparsing an entire file (such as when running a .sage script). For example, one of the test case failures I mentioned looks like:\n\n```python\n# in test_fstring.sage:\nself.assertEqual(f'{3.14:10.10}', '      3.14')\n# when running with ./sage test_fstring.sage:\n======================================================================\nERROR: test_conversions (__main__.TestCase)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"test_fstring.sage.py\", line 866, in test_conversions\n    self.assertEqual(f'{_sage_const_3p14 :_sage_const_10p10 }', '      3.14')\nTypeError: unsupported format string passed to sage.rings.real_mpfr.RealLiteral.__format__\n```\n\nThose constants are seen at the top of the preparsed file, test_fstring.sage.py:\n\n```python\n_sage_const_3p14 = RealNumber('3.14'); _sage_const_10p10 = RealNumber('10.10');\n```\n\nMy concern is that `preparse` is invoked on individual lines by the interpreter and even on individual expressions elsewhere in Sage (ex: `sage_eval` and the `sage(...)` construct you can use from gap/maxima/singular). I wouldn't want to prepend an assignment in the middle of a multi-line statement or an arbitrary expression. Might be able to fix it on a case-by-case basis everywhere `preparse` is called, but I'd like a more self-contained solution.\n\nI'm going to try that (sign, digits, exponent) idea and see how it works out. If it gets too messy, I'll come back to this idea instead.",
    "created_at": "2020-09-01T17:43:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432074",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:14'></a>Replying to [comment:13 embray]:
> This might be ugly, but would be more reliable and less messy than dealing with nesting of quotation marks.  I don't know if it would be easy though.  What if the preparser replaced all numerical literals in the format string (of any sort that are already handled by the preparser) with variables?  Something like:
> 
> 
> ```
> f'{3.14} {5j}' ->
> __sage_tmp_literals = [RealNumber('3.14'), ComplexNumber(0, '5')]; f'{__sage_tmp_literals[0]} {__sage_tmp_literals[1]}'; del __sage_tmp_literals
> ```


I really like the idea, and I believe something similar is already occurring when preparsing an entire file (such as when running a .sage script). For example, one of the test case failures I mentioned looks like:

```python
# in test_fstring.sage:
self.assertEqual(f'{3.14:10.10}', '      3.14')
# when running with ./sage test_fstring.sage:
======================================================================
ERROR: test_conversions (__main__.TestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "test_fstring.sage.py", line 866, in test_conversions
    self.assertEqual(f'{_sage_const_3p14 :_sage_const_10p10 }', '      3.14')
TypeError: unsupported format string passed to sage.rings.real_mpfr.RealLiteral.__format__
```

Those constants are seen at the top of the preparsed file, test_fstring.sage.py:

```python
_sage_const_3p14 = RealNumber('3.14'); _sage_const_10p10 = RealNumber('10.10');
```

My concern is that `preparse` is invoked on individual lines by the interpreter and even on individual expressions elsewhere in Sage (ex: `sage_eval` and the `sage(...)` construct you can use from gap/maxima/singular). I wouldn't want to prepend an assignment in the middle of a multi-line statement or an arbitrary expression. Might be able to fix it on a case-by-case basis everywhere `preparse` is called, but I'd like a more self-contained solution.

I'm going to try that (sign, digits, exponent) idea and see how it works out. If it gets too messy, I'll come back to this idea instead.



---

archive/issue_comments_432075.json:
```json
{
    "body": "<a id='comment:15'></a>Replying to [comment:14 gh-jcamp0x2a]:\n\n> My concern is that `preparse` is invoked on individual lines by the interpreter and even on individual expressions elsewhere in Sage (ex: `sage_eval` and the `sage(...)` construct you can use from gap/maxima/singular). I wouldn't want to prepend an assignment in the middle of a multi-line statement or an arbitrary expression. Might be able to fix it on a case-by-case basis everywhere `preparse` is called, but I'd like a more self-contained solution.\n\n\nThese are different modes. `preparse_file` indeed factors out numerical constants and assigns them to variables, to avoid the repeated recreation of them in loops. However, `preparse` normally doesn't do that, and cannot do that for f-string components either.",
    "created_at": "2020-09-01T19:01:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432075",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:15'></a>Replying to [comment:14 gh-jcamp0x2a]:

> My concern is that `preparse` is invoked on individual lines by the interpreter and even on individual expressions elsewhere in Sage (ex: `sage_eval` and the `sage(...)` construct you can use from gap/maxima/singular). I wouldn't want to prepend an assignment in the middle of a multi-line statement or an arbitrary expression. Might be able to fix it on a case-by-case basis everywhere `preparse` is called, but I'd like a more self-contained solution.


These are different modes. `preparse_file` indeed factors out numerical constants and assigns them to variables, to avoid the repeated recreation of them in loops. However, `preparse` normally doesn't do that, and cannot do that for f-string components either.



---

archive/issue_comments_432076.json:
```json
{
    "body": "<a id='comment:16'></a>Inside expressions, one could use anonymous lambdas in order to avoid assignments, like this:\n\n```\nsage: f'\u03c0 \u2248 {(lambda __sage_tmp: f\"{__sage_tmp}\")(RealNumber(\"3.14\"))}'\n'\u03c0 \u2248 3.14000000000000'\n```\nThis would still be difficult in case of multiline strings \u2013 though, I am not really sure why the preparser needs to run line by line.\n\nIn reality though I think that nested f-strings are quite rare, so just raising a `SyntaxError` with a helpful message when all possible quotes have been used should be fine. This can already happen in the first nested level as in\n\n```\nf\"{f'{3.14}'}\"\n```\nbut the example from comment:12 can be rewritten without conflicting quotes:\n\n```\nsage: f'{3.14}' + f\"{3.14}\" + f'''{3.14}''' + f\"\"\"{3.14}\"\"\"  # no longer\n```",
    "created_at": "2020-09-01T19:20:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432076",
    "user": "https://github.com/mwageringel"
}
```

<a id='comment:16'></a>Inside expressions, one could use anonymous lambdas in order to avoid assignments, like this:

```
sage: f'π ≈ {(lambda __sage_tmp: f"{__sage_tmp}")(RealNumber("3.14"))}'
'π ≈ 3.14000000000000'
```
This would still be difficult in case of multiline strings – though, I am not really sure why the preparser needs to run line by line.

In reality though I think that nested f-strings are quite rare, so just raising a `SyntaxError` with a helpful message when all possible quotes have been used should be fine. This can already happen in the first nested level as in

```
f"{f'{3.14}'}"
```
but the example from comment:12 can be rewritten without conflicting quotes:

```
sage: f'{3.14}' + f"{3.14}" + f'''{3.14}''' + f"""{3.14}"""  # no longer
```



---

archive/issue_comments_432077.json:
```json
{
    "body": "<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-01T23:13:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432077",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_432078.json:
```json
{
    "body": "<a id='comment:18'></a>After thinking it over, I realized I was over-thinking it :)\n\nI was able to fix it by just converting to/from a list of Unicode code-points when out of quote delimiters to use. The preparsed code doesn't look pretty, but it only happens in one of those rare cases mentioned. Ugly yet functional over pretty yet broken.\n\n```python\nsage: preparse('f\"\"\"{f\\'\\'\\'{f\"{f\\'{3.14}\\'}\"}\\'\\'\\'\"\"\"')\n'f\"\"\"{f\\'\\'\\'{f\"{f\\'{RealNumber(str().join(map(chr, [51, 46, 49, 52])))}\\'}\"}\\'\\'\\'\"\"\"'\n```\n\nI apologize for the churn. I expect to get that format specifier problem ironed out and doctests ready for review within a day or so.",
    "created_at": "2020-09-01T23:27:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432078",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:18'></a>After thinking it over, I realized I was over-thinking it :)

I was able to fix it by just converting to/from a list of Unicode code-points when out of quote delimiters to use. The preparsed code doesn't look pretty, but it only happens in one of those rare cases mentioned. Ugly yet functional over pretty yet broken.

```python
sage: preparse('f"""{f\'\'\'{f"{f\'{3.14}\'}"}\'\'\'"""')
'f"""{f\'\'\'{f"{f\'{RealNumber(str().join(map(chr, [51, 46, 49, 52])))}\'}"}\'\'\'"""'
```

I apologize for the churn. I expect to get that format specifier problem ironed out and doctests ready for review within a day or so.



---

archive/issue_comments_432079.json:
```json
{
    "body": "<a id='comment:19'></a>Replying to [comment:16 gh-mwageringel]:\n> This would still be difficult in case of multiline strings \u2013 though, I am not really sure why the preparser needs to run line by line.\n\n\nIt's definitely a mess.  No one has taken the time to sit down and write a proper grammar for Sage and a real parser.",
    "created_at": "2020-09-02T09:21:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432079",
    "user": "https://github.com/embray"
}
```

<a id='comment:19'></a>Replying to [comment:16 gh-mwageringel]:
> This would still be difficult in case of multiline strings – though, I am not really sure why the preparser needs to run line by line.


It's definitely a mess.  No one has taken the time to sit down and write a proper grammar for Sage and a real parser.



---

archive/issue_comments_432080.json:
```json
{
    "body": "<a id='comment:20'></a>Replying to [comment:18 gh-jcamp0x2a]:\n> After thinking it over, I realized I was over-thinking it :)\n> \n> I was able to fix it by just converting to/from a list of Unicode code-points when out of quote delimiters to use. The preparsed code doesn't look pretty, but it only happens in one of those rare cases mentioned. Ugly yet functional over pretty yet broken.\n> \n> \n> ```\n> #!python\n> sage: preparse('f\"\"\"{f\\'\\'\\'{f\"{f\\'{3.14}\\'}\"}\\'\\'\\'\"\"\"')\n> 'f\"\"\"{f\\'\\'\\'{f\"{f\\'{RealNumber(str().join(map(chr, [51, 46, 49, 52])))}\\'}\"}\\'\\'\\'\"\"\"'\n> ```\n> \n> I apologize for the churn. I expect to get that format specifier problem ironed out and doctests ready for review within a day or so.\n\n\nThat's still pretty hideous (which I don't mean as a dig at you; it's a clever solution).  But if it works for now I say go with it.  The only \"good\" solution I think is to completely rewrite the parser from bottom up but that's a bigger project.",
    "created_at": "2020-09-02T09:23:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432080",
    "user": "https://github.com/embray"
}
```

<a id='comment:20'></a>Replying to [comment:18 gh-jcamp0x2a]:
> After thinking it over, I realized I was over-thinking it :)
> 
> I was able to fix it by just converting to/from a list of Unicode code-points when out of quote delimiters to use. The preparsed code doesn't look pretty, but it only happens in one of those rare cases mentioned. Ugly yet functional over pretty yet broken.
> 
> 
> ```
> #!python
> sage: preparse('f"""{f\'\'\'{f"{f\'{3.14}\'}"}\'\'\'"""')
> 'f"""{f\'\'\'{f"{f\'{RealNumber(str().join(map(chr, [51, 46, 49, 52])))}\'}"}\'\'\'"""'
> ```
> 
> I apologize for the churn. I expect to get that format specifier problem ironed out and doctests ready for review within a day or so.


That's still pretty hideous (which I don't mean as a dig at you; it's a clever solution).  But if it works for now I say go with it.  The only "good" solution I think is to completely rewrite the parser from bottom up but that's a bigger project.



---

archive/issue_comments_432081.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-03T06:22:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432081",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_432082.json:
```json
{
    "body": "<a id='comment:22'></a>I was able to resolve the issue with format specifiers and added some documentation and doctests to make it ready for review.\n\nI cleaned up a bunch in `sage.repl.preparse.strip_string_literals` where most of my changes were focused. It's harder to understand now (due to the necessary added complexity of F-strings), but hopefully easier to understand than it otherwise would've been.",
    "created_at": "2020-09-03T06:31:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432082",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:22'></a>I was able to resolve the issue with format specifiers and added some documentation and doctests to make it ready for review.

I cleaned up a bunch in `sage.repl.preparse.strip_string_literals` where most of my changes were focused. It's harder to understand now (due to the necessary added complexity of F-strings), but hopefully easier to understand than it otherwise would've been.



---

archive/issue_comments_432083.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-09-03T06:31:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432083",
    "user": "https://github.com/jcamp0x2a"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_432084.json:
```json
{
    "body": "<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-03T15:41:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432084",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_432085.json:
```json
{
    "body": "<a id='comment:24'></a>\n```\nsage -t --long --random-seed=0 src/sage/doctest/sources.py\n**********************************************************************\nFile \"src/sage/doctest/sources.py\", line 765, in sage.doctest.sources.FileDocTestSource._test_enough_doctests\nFailed example:\n    for path, dirs, files in itertools.chain(os.walk('sage'), os.walk('doc')): # long time\n        path = os.path.relpath(path)\n        dirs.sort(); files.sort()\n        for F in files:\n            _, ext = os.path.splitext(F)\n            if ext in ('.py', '.pyx', '.pxd', '.pxi', '.sage', '.spyx', '.rst'):\n                filename = os.path.join(path, F)\n                FDS = FileDocTestSource(filename, DocTestDefaults(long=True, optional=True, force_lib=True))\n                FDS._test_enough_doctests(verbose=False)\nExpected:\n    There are 3 unexpected tests being run in sage/doctest/parsing.py\n    There are 1 unexpected tests being run in sage/doctest/reporting.py\nGot:\n    There are 3 unexpected tests being run in sage/doctest/parsing.py\n    There are 1 unexpected tests being run in sage/doctest/reporting.py\n    There are 5 tests in sage/repl/preparse.py that are not being run\n```\n\nAlso there are several methods that need coverage.",
    "created_at": "2020-09-04T12:51:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432085",
    "user": "https://github.com/kliem"
}
```

<a id='comment:24'></a>
```
sage -t --long --random-seed=0 src/sage/doctest/sources.py
**********************************************************************
File "src/sage/doctest/sources.py", line 765, in sage.doctest.sources.FileDocTestSource._test_enough_doctests
Failed example:
    for path, dirs, files in itertools.chain(os.walk('sage'), os.walk('doc')): # long time
        path = os.path.relpath(path)
        dirs.sort(); files.sort()
        for F in files:
            _, ext = os.path.splitext(F)
            if ext in ('.py', '.pyx', '.pxd', '.pxi', '.sage', '.spyx', '.rst'):
                filename = os.path.join(path, F)
                FDS = FileDocTestSource(filename, DocTestDefaults(long=True, optional=True, force_lib=True))
                FDS._test_enough_doctests(verbose=False)
Expected:
    There are 3 unexpected tests being run in sage/doctest/parsing.py
    There are 1 unexpected tests being run in sage/doctest/reporting.py
Got:
    There are 3 unexpected tests being run in sage/doctest/parsing.py
    There are 1 unexpected tests being run in sage/doctest/reporting.py
    There are 5 tests in sage/repl/preparse.py that are not being run
```

Also there are several methods that need coverage.



---

archive/issue_comments_432086.json:
```json
{
    "body": "<a id='comment:25'></a>Replying to [comment:24 gh-kliem]:\n> {{{\n> sage -t --long --random-seed=0 src/sage/doctest/sources.py\n> **********************************************************************\n> File \"src/sage/doctest/sources.py\", line 765, in sage.doctest.sources.FileDocTestSource._test_enough_doctests\n> Failed example:\n>     for path, dirs, files in itertools.chain(os.walk('sage'), os.walk('doc')): # long time\n>         path = os.path.relpath(path)\n>         dirs.sort(); files.sort()\n>         for F in files:\n>             _, ext = os.path.splitext(F)\n>             if ext in ('.py', '.pyx', '.pxd', '.pxi', '.sage', '.spyx', '.rst'):\n>                 filename = os.path.join(path, F)\n>                 FDS = FileDocTestSource(filename, DocTestDefaults(long=True, optional=True, force_lib=True))\n>                 FDS._test_enough_doctests(verbose=False)\n> Expected:\n>     There are 3 unexpected tests being run in sage/doctest/parsing.py\n>     There are 1 unexpected tests being run in sage/doctest/reporting.py\n> Got:\n>     There are 3 unexpected tests being run in sage/doctest/parsing.py\n>     There are 1 unexpected tests being run in sage/doctest/reporting.py\n>     There are 5 tests in sage/repl/preparse.py that are not being run\n> }}}\n\n\nI think the latest commit, [1d6b9d6](https://git.sagemath.org/sage.git/commit/?id=1d6b9d6dd9e8f25f9d7e7c4b342da6f4fbf8b4d0), should resolve this.\n\n> Also there are several methods that need coverage.\n\n\nI will push a commit to add doctests to these methods shortly.\n\n---\n\nPerhaps related, perhaps not: I noticed a segfault in the patchbot results when it was testing `src/sage/interfaces/singular.py`, and I was able to reproduce it locally. Interestingly, I still see it happening intermittently on develop, and I also see it in the patchbot results for other tickets like #9407 and #29541.",
    "created_at": "2020-09-04T17:11:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432086",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:25'></a>Replying to [comment:24 gh-kliem]:
> {{{
> sage -t --long --random-seed=0 src/sage/doctest/sources.py
> **********************************************************************
> File "src/sage/doctest/sources.py", line 765, in sage.doctest.sources.FileDocTestSource._test_enough_doctests
> Failed example:
>     for path, dirs, files in itertools.chain(os.walk('sage'), os.walk('doc')): # long time
>         path = os.path.relpath(path)
>         dirs.sort(); files.sort()
>         for F in files:
>             _, ext = os.path.splitext(F)
>             if ext in ('.py', '.pyx', '.pxd', '.pxi', '.sage', '.spyx', '.rst'):
>                 filename = os.path.join(path, F)
>                 FDS = FileDocTestSource(filename, DocTestDefaults(long=True, optional=True, force_lib=True))
>                 FDS._test_enough_doctests(verbose=False)
> Expected:
>     There are 3 unexpected tests being run in sage/doctest/parsing.py
>     There are 1 unexpected tests being run in sage/doctest/reporting.py
> Got:
>     There are 3 unexpected tests being run in sage/doctest/parsing.py
>     There are 1 unexpected tests being run in sage/doctest/reporting.py
>     There are 5 tests in sage/repl/preparse.py that are not being run
> }}}


I think the latest commit, [1d6b9d6](https://git.sagemath.org/sage.git/commit/?id=1d6b9d6dd9e8f25f9d7e7c4b342da6f4fbf8b4d0), should resolve this.

> Also there are several methods that need coverage.


I will push a commit to add doctests to these methods shortly.

---

Perhaps related, perhaps not: I noticed a segfault in the patchbot results when it was testing `src/sage/interfaces/singular.py`, and I was able to reproduce it locally. Interestingly, I still see it happening intermittently on develop, and I also see it in the patchbot results for other tickets like #9407 and #29541.



---

archive/issue_comments_432087.json:
```json
{
    "body": "<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-04T17:53:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432087",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:26'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_432088.json:
```json
{
    "body": "<a id='comment:27'></a>Replying to [comment:25 gh-jcamp0x2a]:\n> Replying to [comment:24 gh-kliem]:\n> > Also there are several methods that need coverage.\n\n> \n> I will push a commit to add doctests to these methods shortly.\n\n\nThank you for mentioning the need for these doctests. In the course of adding them, I found a bug in `QuoteStack.safe_delimiter`. Was popping an element from the set when I should've just been peeking at the first one.",
    "created_at": "2020-09-04T17:57:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432088",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:27'></a>Replying to [comment:25 gh-jcamp0x2a]:
> Replying to [comment:24 gh-kliem]:
> > Also there are several methods that need coverage.

> 
> I will push a commit to add doctests to these methods shortly.


Thank you for mentioning the need for these doctests. In the course of adding them, I found a bug in `QuoteStack.safe_delimiter`. Was popping an element from the set when I should've just been peeking at the first one.



---

archive/issue_comments_432089.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-09-08T20:13:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432089",
    "user": "https://github.com/mwageringel"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_432090.json:
```json
{
    "body": "<a id='comment:28'></a>Nice. Overall the implementation looks ok to me. Here are a couple of remarks.\n\nTriple quotes cannot be used inside single or double quotes:\n\n```\nsage: f'{ f\"{ 3.14 }\" }'\n  File \"<ipython-input-9-f05825bdea91>\", line 1\n    f'{ f\"{ RealNumber('''3.14''') }\" }'\n                          ^\nSyntaxError: invalid syntax\n```\nAlso, could this\n\n```\nsage: preparse(\"\"\" f'{ 3.14 }' + f\"{ 3.14 }\"  \"\"\")\n f'{ RealNumber('''3.14''') }' + f\"{ RealNumber('''3.14''') }\"\n```\nreturn the following instead?\n\n```\n f'{ RealNumber(\"3.14\") }' + f\"{ RealNumber('3.14') }\"\n```\n\nChange: they're -> they are\n\nPlease avoid assigning to the `_` identifier. I have used this pattern before myself, but in Python, this assigns a value to the variable named `_` which is not a descriptive name. It does not avoid warnings that an assigned variable is not used. Since IPython 6, this also conflicts with the IPython convention that `_` denotes the result of the last computation. If you want to avoid assigning a tuple component to a name, you could use slices. For example:\n\n```diff\n-        sage: s, literals, _ = strip_string_literals(''' f'{ {\"x\":1, \"y\":2} }' '''); s\n-        ' f%(L1)s{ {%(L2)s:1, %(L3)s:2} }%(L4)s '\n-        sage: literals\n-        {'L1': \"'\", 'L2': '\"x\"', 'L3': '\"y\"', 'L4': \"'\"}\n+        sage: strip_string_literals(''' f'{ {\"x\":1, \"y\":2} }' ''')[:2]\n+        (' f%(L1)s{ {%(L2)s:1, %(L3)s:2} }%(L4)s ',\n+         {'L1': \"'\", 'L2': '\"x\"', 'L3': '\"y\"', 'L4': \"'\"})\n```\n\nUse quotes in docstrings in cases like these: `(default: False)` -> `(default: ``False``)`\n\nWhen specifying the type in docstrings, simply use \"boolean\"/\"string\" instead of \"a boolean\"/\"a string\".\n\nTypo(?):\n\n```diff\n-    '{{' and '}}' only escape sequences work in the literal portion of an F-string::\n+    '{{' and '}}' escape sequences only work in the literal portion of an F-string::\n```\n\nTypo: specier -> specifier\n\nPreferably add a space after commas, e.g.:\n\n```diff\n-            new_code.append(code[start:q].replace('%','%%'))\n+            new_code.append(code[start:q].replace('%', '%%'))\n```\n\n\nDid you think of colons in slices here?\n\n```\n        elif ch == ':' and quote and not quote.parens and (quote.braces == 1 or quote.fmt_spec):\n            if quote.braces == 1:\n                # In a replacement section but outside of any nested braces or\n                # parentheses, the colon signals the beginning of the format specifier.\n```\nFor example:\n\n```\nsage: strip_string_literals(\"f'{ [1,2,3][:1]  } '\")\n('f%(L1)s{ [1,2,3][:%(L2)s}%(L3)s', {'L1': \"'\", 'L2': '1]  ', 'L3': \" '\"}, [])\n```\nBesides lambdas, dictionaries and slices, are there other possible uses of colons?\n\n\nCheck that the indices are \u2265 0:\n\n```\n                if code[q-1] == '\\\\':\n                    k = 2\n                    while code[q-k] == '\\\\':\n```\n\nPlease change the comment to an explanation about why this is done \u2013 something along the lines that Python 3 does not accept leading 0s, but Sage does and interprets them as decimal.\n\n```\n                num = re.sub(r'^0+', '', num) # Strip leading zeroes.\n```",
    "created_at": "2020-09-08T20:13:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432090",
    "user": "https://github.com/mwageringel"
}
```

<a id='comment:28'></a>Nice. Overall the implementation looks ok to me. Here are a couple of remarks.

Triple quotes cannot be used inside single or double quotes:

```
sage: f'{ f"{ 3.14 }" }'
  File "<ipython-input-9-f05825bdea91>", line 1
    f'{ f"{ RealNumber('''3.14''') }" }'
                          ^
SyntaxError: invalid syntax
```
Also, could this

```
sage: preparse(""" f'{ 3.14 }' + f"{ 3.14 }"  """)
 f'{ RealNumber('''3.14''') }' + f"{ RealNumber('''3.14''') }"
```
return the following instead?

```
 f'{ RealNumber("3.14") }' + f"{ RealNumber('3.14') }"
```

Change: they're -> they are

Please avoid assigning to the `_` identifier. I have used this pattern before myself, but in Python, this assigns a value to the variable named `_` which is not a descriptive name. It does not avoid warnings that an assigned variable is not used. Since IPython 6, this also conflicts with the IPython convention that `_` denotes the result of the last computation. If you want to avoid assigning a tuple component to a name, you could use slices. For example:

```diff
-        sage: s, literals, _ = strip_string_literals(''' f'{ {"x":1, "y":2} }' '''); s
-        ' f%(L1)s{ {%(L2)s:1, %(L3)s:2} }%(L4)s '
-        sage: literals
-        {'L1': "'", 'L2': '"x"', 'L3': '"y"', 'L4': "'"}
+        sage: strip_string_literals(''' f'{ {"x":1, "y":2} }' ''')[:2]
+        (' f%(L1)s{ {%(L2)s:1, %(L3)s:2} }%(L4)s ',
+         {'L1': "'", 'L2': '"x"', 'L3': '"y"', 'L4': "'"})
```

Use quotes in docstrings in cases like these: `(default: False)` -> `(default: ``False``)`

When specifying the type in docstrings, simply use "boolean"/"string" instead of "a boolean"/"a string".

Typo(?):

```diff
-    '{{' and '}}' only escape sequences work in the literal portion of an F-string::
+    '{{' and '}}' escape sequences only work in the literal portion of an F-string::
```

Typo: specier -> specifier

Preferably add a space after commas, e.g.:

```diff
-            new_code.append(code[start:q].replace('%','%%'))
+            new_code.append(code[start:q].replace('%', '%%'))
```


Did you think of colons in slices here?

```
        elif ch == ':' and quote and not quote.parens and (quote.braces == 1 or quote.fmt_spec):
            if quote.braces == 1:
                # In a replacement section but outside of any nested braces or
                # parentheses, the colon signals the beginning of the format specifier.
```
For example:

```
sage: strip_string_literals("f'{ [1,2,3][:1]  } '")
('f%(L1)s{ [1,2,3][:%(L2)s}%(L3)s', {'L1': "'", 'L2': '1]  ', 'L3': " '"}, [])
```
Besides lambdas, dictionaries and slices, are there other possible uses of colons?


Check that the indices are ≥ 0:

```
                if code[q-1] == '\\':
                    k = 2
                    while code[q-k] == '\\':
```

Please change the comment to an explanation about why this is done – something along the lines that Python 3 does not accept leading 0s, but Sage does and interprets them as decimal.

```
                num = re.sub(r'^0+', '', num) # Strip leading zeroes.
```



---

archive/issue_comments_432091.json:
```json
{
    "body": "<a id='comment:29'></a>Replying to [comment:19 embray]:\n> Replying to [comment:16 gh-mwageringel]:\n> > This would still be difficult in case of multiline strings \u2013 though, I am not really sure why the preparser needs to run line by line.\n\n> \n> It's definitely a mess.  No one has taken the time to sit down and write a proper grammar for Sage and a real parser.\n\n\nDo I understand correctly that such a change would replace the preparser by a lexer and a parser in order to convert Sage code directly to an AST that can be compiled to byte code? Is this a long-term goal?",
    "created_at": "2020-09-08T20:17:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432091",
    "user": "https://github.com/mwageringel"
}
```

<a id='comment:29'></a>Replying to [comment:19 embray]:
> Replying to [comment:16 gh-mwageringel]:
> > This would still be difficult in case of multiline strings – though, I am not really sure why the preparser needs to run line by line.

> 
> It's definitely a mess.  No one has taken the time to sit down and write a proper grammar for Sage and a real parser.


Do I understand correctly that such a change would replace the preparser by a lexer and a parser in order to convert Sage code directly to an AST that can be compiled to byte code? Is this a long-term goal?



---

archive/issue_comments_432092.json:
```json
{
    "body": "<a id='comment:30'></a>Replying to [comment:28 gh-mwageringel]:\n> Nice. Overall the implementation looks ok to me. Here are a couple of remarks.\n> \n> Triple quotes cannot be used inside single or double quotes:\n> [...]\n\n\nMy relative inexperience with Python is showing. A case of the blind \"leading\" the seeing :) I don't think this will be difficult to remedy; just popping `'''` and `\"\"\"` out of the set of safe delimiters whenever a `'` or `\"` is used.\n\n> Also, could this\n> \n> ```\n> sage: preparse(\"\"\" f'{ 3.14 }' + f\"{ 3.14 }\"  \"\"\")\n>  f'{ RealNumber('''3.14''') }' + f\"{ RealNumber('''3.14''') }\"\n> ```\n> return the following instead?\n> \n> ```\n>  f'{ RealNumber(\"3.14\") }' + f\"{ RealNumber('3.14') }\"\n> ```\n\n\nNot with the current approach. Both the `'` and `\"` would be used up, and since triple quotes would be invalid, it'd have to fallback to the list of ordinals. Could try to maintain a mapping between ranges in the processed code and sets of valid delimiters within instead of the single set of delimiters that applies to the whole thing. I'm not sure if the effort or cycles would be worth it, though. Is there a need for the preparsed code to be particularly human-readable? Perhaps to make error messages occuring within it more readable?\n\n> Did you think of colons in slices here?\n\n\nI did not, and that's a very good catch. I think keeping track of unmatched square brackets as I do braces and parentheses will solve the slice problem.\n\n> Besides lambdas, dictionaries and slices, are there other possible uses of colons?\n\n\nI will look into this further and check the Python grammar. I know trying to define a function or start an if/while/try block inside an F-string will raise a SyntaxError.\n\n---\n\nI agree 100% with your other points and will work on remedying them. It seems like the 9.2.beta builds are wrapping up, and I don't think I'll be able to get this ready in time for the last one, so I'm going to go ahead and change the milestone to 9.3.\n\nThank you for your time reviewing this ticket; it is most appreciated!",
    "created_at": "2020-09-08T21:58:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432092",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:30'></a>Replying to [comment:28 gh-mwageringel]:
> Nice. Overall the implementation looks ok to me. Here are a couple of remarks.
> 
> Triple quotes cannot be used inside single or double quotes:
> [...]


My relative inexperience with Python is showing. A case of the blind "leading" the seeing :) I don't think this will be difficult to remedy; just popping `'''` and `"""` out of the set of safe delimiters whenever a `'` or `"` is used.

> Also, could this
> 
> ```
> sage: preparse(""" f'{ 3.14 }' + f"{ 3.14 }"  """)
>  f'{ RealNumber('''3.14''') }' + f"{ RealNumber('''3.14''') }"
> ```
> return the following instead?
> 
> ```
>  f'{ RealNumber("3.14") }' + f"{ RealNumber('3.14') }"
> ```


Not with the current approach. Both the `'` and `"` would be used up, and since triple quotes would be invalid, it'd have to fallback to the list of ordinals. Could try to maintain a mapping between ranges in the processed code and sets of valid delimiters within instead of the single set of delimiters that applies to the whole thing. I'm not sure if the effort or cycles would be worth it, though. Is there a need for the preparsed code to be particularly human-readable? Perhaps to make error messages occuring within it more readable?

> Did you think of colons in slices here?


I did not, and that's a very good catch. I think keeping track of unmatched square brackets as I do braces and parentheses will solve the slice problem.

> Besides lambdas, dictionaries and slices, are there other possible uses of colons?


I will look into this further and check the Python grammar. I know trying to define a function or start an if/while/try block inside an F-string will raise a SyntaxError.

---

I agree 100% with your other points and will work on remedying them. It seems like the 9.2.beta builds are wrapping up, and I don't think I'll be able to get this ready in time for the last one, so I'm going to go ahead and change the milestone to 9.3.

Thank you for your time reviewing this ticket; it is most appreciated!



---

archive/issue_events_073354.json:
```json
{
    "actor": "https://github.com/jcamp0x2a",
    "created_at": "2020-09-08T21:58:28Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28974#event-73354"
}
```



---

archive/issue_events_073355.json:
```json
{
    "actor": "https://github.com/jcamp0x2a",
    "created_at": "2020-09-08T21:58:28Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28974#event-73355"
}
```



---

archive/issue_comments_432093.json:
```json
{
    "body": "<a id='comment:32'></a>Replying to [comment:30 gh-jcamp0x2a]:\n> Not with the current approach. Both the `'` and `\"` would be used up, and since triple quotes would be invalid, it'd have to fallback to the list of ordinals.\n\n\nOk, let us keep it like this then to avoid unnecessary complication. This only happens in the rare case of nested f-strings anyway. Personally, I have never inspected the transpiled code, so I agree there is no need to make it particularly pretty.\n\nReplying to [comment:25 gh-jcamp0x2a]:\n> Perhaps related, perhaps not: I noticed a segfault in the patchbot results when it was testing `src/sage/interfaces/singular.py`, and I was able to reproduce it locally. \n\n\nThis is not related. I was able to reproduce it with 9.2.beta11 and it is most likely related to the Pexpect upgrade in that beta. With 9.2.beta12 after the upgrade to Python 3.8, I am unable to reproduce it anymore, so the problem seems to have solved itself.",
    "created_at": "2020-09-09T17:27:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432093",
    "user": "https://github.com/mwageringel"
}
```

<a id='comment:32'></a>Replying to [comment:30 gh-jcamp0x2a]:
> Not with the current approach. Both the `'` and `"` would be used up, and since triple quotes would be invalid, it'd have to fallback to the list of ordinals.


Ok, let us keep it like this then to avoid unnecessary complication. This only happens in the rare case of nested f-strings anyway. Personally, I have never inspected the transpiled code, so I agree there is no need to make it particularly pretty.

Replying to [comment:25 gh-jcamp0x2a]:
> Perhaps related, perhaps not: I noticed a segfault in the patchbot results when it was testing `src/sage/interfaces/singular.py`, and I was able to reproduce it locally. 


This is not related. I was able to reproduce it with 9.2.beta11 and it is most likely related to the Pexpect upgrade in that beta. With 9.2.beta12 after the upgrade to Python 3.8, I am unable to reproduce it anymore, so the problem seems to have solved itself.



---

archive/issue_comments_432094.json:
```json
{
    "body": "<a id='comment:33'></a>Replying to [comment:32 gh-mwageringel]:\n> Replying to [comment:25 gh-jcamp0x2a]:\n> > Perhaps related, perhaps not: I noticed a segfault in the patchbot results when it was testing `src/sage/interfaces/singular.py`, and I was able to reproduce it locally. \n\n> \n> This is not related. I was able to reproduce it with 9.2.beta11 and it is most likely related to the Pexpect upgrade in that beta. With 9.2.beta12 after the upgrade to Python 3.8, I am unable to reproduce it anymore, so the problem seems to have solved itself.\n\n\nThat's a relief. Didn't look forward to trying to troubleshoot that! :)",
    "created_at": "2020-09-10T19:37:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432094",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:33'></a>Replying to [comment:32 gh-mwageringel]:
> Replying to [comment:25 gh-jcamp0x2a]:
> > Perhaps related, perhaps not: I noticed a segfault in the patchbot results when it was testing `src/sage/interfaces/singular.py`, and I was able to reproduce it locally. 

> 
> This is not related. I was able to reproduce it with 9.2.beta11 and it is most likely related to the Pexpect upgrade in that beta. With 9.2.beta12 after the upgrade to Python 3.8, I am unable to reproduce it anymore, so the problem seems to have solved itself.


That's a relief. Didn't look forward to trying to troubleshoot that! :)



---

archive/issue_comments_432095.json:
```json
{
    "body": "<a id='comment:34'></a>Markus, I shall be pushing an updated branch shortly that seeks to address the issues you raised in your review.\n\nAlso, as to...\n\nReplying to [comment:30 gh-jcamp0x2a]:\n> Replying to [comment:28 gh-mwageringel]:\n> > Besides lambdas, dictionaries and slices, are there other possible uses of colons?\n\n> \n> I will look into this further and check the Python grammar. I know trying to define a function or start an if/while/try block inside an F-string will raise a SyntaxError.\n\n\n...I believe I've identified all of the uses of the colon in [Python's grammar](https://docs.python.org/3/reference/grammar.html). My findings:\n\n Function and class definitions: `def foo():`, `class Foo:`::\n    not allowed inside F-strings\n\n Control flow statements: `if x:`, `elif x:`, `else:`, `while x:`, `for x in y:`, `try:`, `except:`, `finally:`, `with x as y:`::\n    not allowed inside F-strings\n\n Dictionary literals: `{\"x\": 5}`:: \n    enclosed in braces, and the brace count is already checked before handling the colon\n\n Lambda expressions: `lambda x: expr`::\n    \"Because lambdas use the ':' character, they cannot appear outside of parentheses in an expression.\" [PEP 498 \"Lambdas inside expressions\"](https://www.python.org/dev/peps/pep-0498/#lambdas-inside-expressions). The parenthesis count is already checked before handling the colon. \n\n Slice notation: `x[start:stop:step]`::\n    enclosed in square brackets, and my latest push adds a square bracket check before handling the colon\n\n Assignment expressions: `x := y`)::\n    \"Assignment expressions inside of f-strings require parentheses.\"[PEP 572 \"Exceptional cases\", last bullet point](https://www.python.org/dev/peps/pep-0572/#exceptional-cases). The parenthesis count is already checked before handling the colon.\n\n Parameter annotations: `def foo(x: int, y: float):`::\n    Function definitions aren't allowed inside F-strings. \"lambda's syntax does not support annotations.\" [PEP 3107, \"Lambda\"](https://www.python.org/dev/peps/pep-3107/#lambda). Even if they did, the entire lambda expression would still require parentheses around it.\n\n Variable annotations / annotated assignment: `x: int`, `x: int = 5`::\n    I'm least sure about this one, and I've been unable to find any solid documentation relating it with F-strings. My reading of the grammar suggests it's not allowed, and sure enough Python seems to reject any attempts to use such an annotation in an F-String. For example: `f'{x: int}'` and `f'{x: int = 5}'` seem to treat `int` and `int = 5` as format specifiers and end up raising an error to that effect.",
    "created_at": "2020-09-12T22:57:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432095",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:34'></a>Markus, I shall be pushing an updated branch shortly that seeks to address the issues you raised in your review.

Also, as to...

Replying to [comment:30 gh-jcamp0x2a]:
> Replying to [comment:28 gh-mwageringel]:
> > Besides lambdas, dictionaries and slices, are there other possible uses of colons?

> 
> I will look into this further and check the Python grammar. I know trying to define a function or start an if/while/try block inside an F-string will raise a SyntaxError.


...I believe I've identified all of the uses of the colon in [Python's grammar](https://docs.python.org/3/reference/grammar.html). My findings:

 Function and class definitions: `def foo():`, `class Foo:`::
    not allowed inside F-strings

 Control flow statements: `if x:`, `elif x:`, `else:`, `while x:`, `for x in y:`, `try:`, `except:`, `finally:`, `with x as y:`::
    not allowed inside F-strings

 Dictionary literals: `{"x": 5}`:: 
    enclosed in braces, and the brace count is already checked before handling the colon

 Lambda expressions: `lambda x: expr`::
    "Because lambdas use the ':' character, they cannot appear outside of parentheses in an expression." [PEP 498 "Lambdas inside expressions"](https://www.python.org/dev/peps/pep-0498/#lambdas-inside-expressions). The parenthesis count is already checked before handling the colon. 

 Slice notation: `x[start:stop:step]`::
    enclosed in square brackets, and my latest push adds a square bracket check before handling the colon

 Assignment expressions: `x := y`)::
    "Assignment expressions inside of f-strings require parentheses."[PEP 572 "Exceptional cases", last bullet point](https://www.python.org/dev/peps/pep-0572/#exceptional-cases). The parenthesis count is already checked before handling the colon.

 Parameter annotations: `def foo(x: int, y: float):`::
    Function definitions aren't allowed inside F-strings. "lambda's syntax does not support annotations." [PEP 3107, "Lambda"](https://www.python.org/dev/peps/pep-3107/#lambda). Even if they did, the entire lambda expression would still require parentheses around it.

 Variable annotations / annotated assignment: `x: int`, `x: int = 5`::
    I'm least sure about this one, and I've been unable to find any solid documentation relating it with F-strings. My reading of the grammar suggests it's not allowed, and sure enough Python seems to reject any attempts to use such an annotation in an F-String. For example: `f'{x: int}'` and `f'{x: int = 5}'` seem to treat `int` and `int = 5` as format specifiers and end up raising an error to that effect.



---

archive/issue_comments_432096.json:
```json
{
    "body": "<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-12T22:58:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432096",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_432097.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-09-12T23:00:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432097",
    "user": "https://github.com/jcamp0x2a"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_432098.json:
```json
{
    "body": "<a id='comment:37'></a>Thanks for the detailed analysis.\n\nReplying to [comment:34 gh-jcamp0x2a]:\n>  Assignment expressions: `x := y`)::\n>     \"Assignment expressions inside of f-strings require parentheses.\"[PEP 572 \"Exceptional cases\", last bullet point](https://www.python.org/dev/peps/pep-0572/#exceptional-cases). The parenthesis count is already checked before handling the colon.\n\n\nI did not know about this syntax yet, but indeed there seems to be no problem.\n\n>  Variable annotations / annotated assignment: `x: int`, `x: int = 5`::\n>     I'm least sure about this one, and I've been unable to find any solid documentation relating it with F-strings. My reading of the grammar suggests it's not allowed, and sure enough Python seems to reject any attempts to use such an annotation in an F-String. For example: `f'{x: int}'` and `f'{x: int = 5}'` seem to treat `int` and `int = 5` as format specifiers and end up raising an error to that effect.\n\n\nAs far as I understand, these are statements, not expressions, and therefore cannot occur in f-strings.\n\n\nHere are a few more small comments about the code:\n\nThe method `safe_delimiters` does not seem to be used anywhere. I think it would be fine to remove it \u2013 the purpose of the class is only for internal use in Sage anyway. The tests in its docstring seem to be mainly replicating the tests of `push`, so are not really needed either.\n\nSince Python 3.6, dictionaries are order-preserving, so you could replace the uses of `OrderedDict` by `dict`.\n\nThis could be shortened:\n\n```diff\n-        return next(iter(self._safe_delims)) if self._safe_delims else None\n+        return next(iter(self._safe_delims), None)\n```\n\n\n```\n    Similarly, a colon inside brackets doesn't start the format specifier in order\n    to allow slices.::\n```\nThe `.::` is not optimal here. Either remove the dot or add a space. This is how Sphinx interprets this:\n\n```\nslices.::    \u21d2   slices.:\nslices::     \u21d2   slices:\nslices. ::   \u21d2   slices.\n```\n\nFurther, the first paragraph of docstrings should not be more than one sentence. If you have more than one sentence, start a new paragraph. Also, the first sentence should use the imperative form. For example:\n\n```diff\n-        Adds a frame to the stack.\n+        Add a frame to the stack.\n```\n\nFinally, I would like to mention that, with this branch, preparsing files is about 60% slower than before. That is quite a big difference, but it is still quite fast, so it seems to me this is ok. If it turns out this is a problem, we can look into improving the performance later on.",
    "created_at": "2020-09-13T16:16:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432098",
    "user": "https://github.com/mwageringel"
}
```

<a id='comment:37'></a>Thanks for the detailed analysis.

Replying to [comment:34 gh-jcamp0x2a]:
>  Assignment expressions: `x := y`)::
>     "Assignment expressions inside of f-strings require parentheses."[PEP 572 "Exceptional cases", last bullet point](https://www.python.org/dev/peps/pep-0572/#exceptional-cases). The parenthesis count is already checked before handling the colon.


I did not know about this syntax yet, but indeed there seems to be no problem.

>  Variable annotations / annotated assignment: `x: int`, `x: int = 5`::
>     I'm least sure about this one, and I've been unable to find any solid documentation relating it with F-strings. My reading of the grammar suggests it's not allowed, and sure enough Python seems to reject any attempts to use such an annotation in an F-String. For example: `f'{x: int}'` and `f'{x: int = 5}'` seem to treat `int` and `int = 5` as format specifiers and end up raising an error to that effect.


As far as I understand, these are statements, not expressions, and therefore cannot occur in f-strings.


Here are a few more small comments about the code:

The method `safe_delimiters` does not seem to be used anywhere. I think it would be fine to remove it – the purpose of the class is only for internal use in Sage anyway. The tests in its docstring seem to be mainly replicating the tests of `push`, so are not really needed either.

Since Python 3.6, dictionaries are order-preserving, so you could replace the uses of `OrderedDict` by `dict`.

This could be shortened:

```diff
-        return next(iter(self._safe_delims)) if self._safe_delims else None
+        return next(iter(self._safe_delims), None)
```


```
    Similarly, a colon inside brackets doesn't start the format specifier in order
    to allow slices.::
```
The `.::` is not optimal here. Either remove the dot or add a space. This is how Sphinx interprets this:

```
slices.::    ⇒   slices.:
slices::     ⇒   slices:
slices. ::   ⇒   slices.
```

Further, the first paragraph of docstrings should not be more than one sentence. If you have more than one sentence, start a new paragraph. Also, the first sentence should use the imperative form. For example:

```diff
-        Adds a frame to the stack.
+        Add a frame to the stack.
```

Finally, I would like to mention that, with this branch, preparsing files is about 60% slower than before. That is quite a big difference, but it is still quite fast, so it seems to me this is ok. If it turns out this is a problem, we can look into improving the performance later on.



---

archive/issue_comments_432099.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-09-13T16:16:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432099",
    "user": "https://github.com/mwageringel"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_432100.json:
```json
{
    "body": "<a id='comment:38'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-13T18:17:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432100",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:38'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_432101.json:
```json
{
    "body": "<a id='comment:39'></a>Thanks Markus. I believe I have addressed most of your feedback in my latest push.\n\nReplying to [comment:37 gh-mwageringel]:\n> The method `safe_delimiters` does not seem to be used anywhere. I think it would be fine to remove it \u2013 the purpose of the class is only for internal use in Sage anyway. The tests in its docstring seem to be mainly replicating the tests of `push`, so are not really needed either.\n\n>\n> Since Python 3.6, dictionaries are order-preserving, so you could replace the uses of `OrderedDict` by `dict`. \n\n\nI have removed the `_safe_delims` dict entirely in favor of a couple booleans to keep track of `'` and `\"`. The triple-quoted versions would never be chosen anyway, since by the time they would (`'` and `\"` used up), they'd also be invalid (since `'''` can't appear within an F-string delimited by `'` for example). All the doctests related to safe delimiters are moved to the `safe_delimiter` method itself.\n\n> Finally, I would like to mention that, with this branch, preparsing files is about 60% slower than before. That is quite a big difference, but it is still quite fast, so it seems to me this is ok. If it turns out this is a problem, we can look into improving the performance later on.\n\n\nThat is a problem. A small overall drop in performance would be ok, I think, as would a bigger drop when dealing with code that uses F-strings extensively. That big of a drop for preparsing files in general seems unacceptable, though. \n\nLooks like I've got some more testing and tweaking to do. I'll leave the ticket as //needs_work//.",
    "created_at": "2020-09-13T18:41:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432101",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:39'></a>Thanks Markus. I believe I have addressed most of your feedback in my latest push.

Replying to [comment:37 gh-mwageringel]:
> The method `safe_delimiters` does not seem to be used anywhere. I think it would be fine to remove it – the purpose of the class is only for internal use in Sage anyway. The tests in its docstring seem to be mainly replicating the tests of `push`, so are not really needed either.

>
> Since Python 3.6, dictionaries are order-preserving, so you could replace the uses of `OrderedDict` by `dict`. 


I have removed the `_safe_delims` dict entirely in favor of a couple booleans to keep track of `'` and `"`. The triple-quoted versions would never be chosen anyway, since by the time they would (`'` and `"` used up), they'd also be invalid (since `'''` can't appear within an F-string delimited by `'` for example). All the doctests related to safe delimiters are moved to the `safe_delimiter` method itself.

> Finally, I would like to mention that, with this branch, preparsing files is about 60% slower than before. That is quite a big difference, but it is still quite fast, so it seems to me this is ok. If it turns out this is a problem, we can look into improving the performance later on.


That is a problem. A small overall drop in performance would be ok, I think, as would a bigger drop when dealing with code that uses F-strings extensively. That big of a drop for preparsing files in general seems unacceptable, though. 

Looks like I've got some more testing and tweaking to do. I'll leave the ticket as //needs_work//.



---

archive/issue_comments_432102.json:
```json
{
    "body": "<a id='comment:40'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-22T04:05:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432102",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:40'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_432103.json:
```json
{
    "body": "<a id='comment:41'></a>I've pushed a commit that attempts to improve the performance by:\n\n- Jumping between special chars (parentheses, quotes, etc.) using re.search similar to what the original algorithm was doing with str.find instead of handling every character ourselves.\n- Avoiding peeking at the top of the stack every special char, maintaining a local copy of the frame at the top.\n- Re-organizing the control flow to bail out as soon as possible including performing the checks for each special char in order of frequency found in the examples in src/doc and src/sage.\n\nAs my test case, I concatenated all of the code examples in src/doc and src/sage into a single file of about 400,000 lines. There is a single line that needs to be removed due to it using a variable name with special meaning to preparse_file.\n\n```sh\n$ grep -Phro \"(?<=(sage|\\.\\.\\.\\.): ).+$\" src/doc src/sage | grep -v \"f(_sage_const_)\" > preparser_test_input\n```\n\nI used this file to also determine the frequency of special chars in the Sage examples and thus inform the order in which to place their conditions.\n\n```sh\n$ fgrep -o \"(\" preparser_test_input  | wc -l\n508806\n```\n\nI then ran the following in Sage to time how long it took to preparse the large test file:\n\n```python\nwith open('preparser_test_input', 'r') as f:\n    contents = f.read()\nprint(timeit('sage.repl.preparse.preparse_file(contents)'))\n```\n\nMy results the first time were as follows:\n\n|         |                                     |\n|---------|-------------------------------------|\n| develop | 5 loops, best of 3: 16.1 s per loop |\n| prev commit | 5 loops, best of 3: 23.5 s per loop |\n| new commit | 5 loops, best of 3: 17.9 s per loop |\n...and a second time, mostly the same:\n\n|         |                                     |\n|---------|-------------------------------------|\n| develop | 5 loops, best of 3: 16.1 s per loop |\n| prev commit | 5 loops, best of 3: 23.5 s per loop |\n| new commit | 5 loops, best of 3: 18 s per loop |\nSo from a ~45% increase to ~10%, which I'm personally OK with now. I'm curious if others will get the same results.",
    "created_at": "2020-09-22T04:08:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432103",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:41'></a>I've pushed a commit that attempts to improve the performance by:

- Jumping between special chars (parentheses, quotes, etc.) using re.search similar to what the original algorithm was doing with str.find instead of handling every character ourselves.
- Avoiding peeking at the top of the stack every special char, maintaining a local copy of the frame at the top.
- Re-organizing the control flow to bail out as soon as possible including performing the checks for each special char in order of frequency found in the examples in src/doc and src/sage.

As my test case, I concatenated all of the code examples in src/doc and src/sage into a single file of about 400,000 lines. There is a single line that needs to be removed due to it using a variable name with special meaning to preparse_file.

```sh
$ grep -Phro "(?<=(sage|\.\.\.\.): ).+$" src/doc src/sage | grep -v "f(_sage_const_)" > preparser_test_input
```

I used this file to also determine the frequency of special chars in the Sage examples and thus inform the order in which to place their conditions.

```sh
$ fgrep -o "(" preparser_test_input  | wc -l
508806
```

I then ran the following in Sage to time how long it took to preparse the large test file:

```python
with open('preparser_test_input', 'r') as f:
    contents = f.read()
print(timeit('sage.repl.preparse.preparse_file(contents)'))
```

My results the first time were as follows:

|         |                                     |
|---------|-------------------------------------|
| develop | 5 loops, best of 3: 16.1 s per loop |
| prev commit | 5 loops, best of 3: 23.5 s per loop |
| new commit | 5 loops, best of 3: 17.9 s per loop |
...and a second time, mostly the same:

|         |                                     |
|---------|-------------------------------------|
| develop | 5 loops, best of 3: 16.1 s per loop |
| prev commit | 5 loops, best of 3: 23.5 s per loop |
| new commit | 5 loops, best of 3: 18 s per loop |
So from a ~45% increase to ~10%, which I'm personally OK with now. I'm curious if others will get the same results.



---

archive/issue_comments_432104.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-09-22T04:08:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432104",
    "user": "https://github.com/jcamp0x2a"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_432105.json:
```json
{
    "body": "<a id='comment:42'></a>Thank you for the analysis. The changes look good to me. Now, I also see a slowdown of only about 10%, which seems fine.\n\nI have just one more question regarding this comment:\n\n```\n# Deal with escaped quotes (odd number of backslashes preceding).\n```\nCould it be a problem here if we are inside a raw string? In this case an odd number of backslashes might not indicate an escaped quote. I could not find any example where this is a problem, so maybe there is no problem. Could you confirm this?",
    "created_at": "2020-10-03T22:05:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432105",
    "user": "https://github.com/mwageringel"
}
```

<a id='comment:42'></a>Thank you for the analysis. The changes look good to me. Now, I also see a slowdown of only about 10%, which seems fine.

I have just one more question regarding this comment:

```
# Deal with escaped quotes (odd number of backslashes preceding).
```
Could it be a problem here if we are inside a raw string? In this case an odd number of backslashes might not indicate an escaped quote. I could not find any example where this is a problem, so maybe there is no problem. Could you confirm this?



---

archive/issue_comments_432106.json:
```json
{
    "body": "<a id='comment:43'></a>Thank you for your time looking through the code again; I know there's been quite a bit of churn.\n\nReplying to [comment:42 gh-mwageringel]:\n> I have just one more question regarding this comment:\n> \n> ```\n> # Deal with escaped quotes (odd number of backslashes preceding).\n> ```\n> Could it be a problem here if we are inside a raw string? In this case an odd number of backslashes might not indicate an escaped quote. I could not find any example where this is a problem, so maybe there is no problem. Could you confirm this?\n\n\nThis threw me for a loop when I first encountered it, too. I had thought that backslashes had no meaning in a raw string whatsoever, but apparently they can still be used to escape a quote character, although the backslash still appears in the output. For example:\n\n```python\n>>> r'\\'\n  File \"<stdin>\", line 1\n    r'\\'\n       ^\nSyntaxError: EOL while scanning string literal\n>>>\n>>> r'\\''\n\"\\\\'\"\n```\n\n...and `strip_string_literals` has the following test:\n\n```\nTESTS:\n\n    Even for raw strings, a backslash can escape a following quote::\n\n        sage: s, literals, state = strip_string_literals(r\"r'somethin\\' funny'\"); s\n        'r%(L1)s'\n        sage: dep_regex = r'^ *(?:(?:cimport +([\\w\\. ,]+))|(?:from +(\\w+) +cimport)|(?:include *[\\'\"]([^\\'\"]+)[\\'\"])|(?:cdef *extern *from *[\\'\"]([^\\'\"]+)[\\'\"]))' # Ticket 5821\n```\n\nThe ticket mentioned is #5821. It looks like prior to that ticket, raw-strings were excluded from the check for escaped quotes, resulting in a bug.",
    "created_at": "2020-10-04T00:49:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432106",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:43'></a>Thank you for your time looking through the code again; I know there's been quite a bit of churn.

Replying to [comment:42 gh-mwageringel]:
> I have just one more question regarding this comment:
> 
> ```
> # Deal with escaped quotes (odd number of backslashes preceding).
> ```
> Could it be a problem here if we are inside a raw string? In this case an odd number of backslashes might not indicate an escaped quote. I could not find any example where this is a problem, so maybe there is no problem. Could you confirm this?


This threw me for a loop when I first encountered it, too. I had thought that backslashes had no meaning in a raw string whatsoever, but apparently they can still be used to escape a quote character, although the backslash still appears in the output. For example:

```python
>>> r'\'
  File "<stdin>", line 1
    r'\'
       ^
SyntaxError: EOL while scanning string literal
>>>
>>> r'\''
"\\'"
```

...and `strip_string_literals` has the following test:

```
TESTS:

    Even for raw strings, a backslash can escape a following quote::

        sage: s, literals, state = strip_string_literals(r"r'somethin\' funny'"); s
        'r%(L1)s'
        sage: dep_regex = r'^ *(?:(?:cimport +([\w\. ,]+))|(?:from +(\w+) +cimport)|(?:include *[\'"]([^\'"]+)[\'"])|(?:cdef *extern *from *[\'"]([^\'"]+)[\'"]))' # Ticket 5821
```

The ticket mentioned is #5821. It looks like prior to that ticket, raw-strings were excluded from the check for escaped quotes, resulting in a bug.



---

archive/issue_comments_432107.json:
```json
{
    "body": "<a id='comment:44'></a>Oh, just to add to the example to show how python treats raw-strings with multiple backslashes:\n\n```python\n>>> r'\\\\'\n'\\\\\\\\'\n>>> r'\\\\\\'\n  File \"<stdin>\", line 1\n    r'\\\\\\'\n         ^\nSyntaxError: EOL while scanning string literal\n>>> r'\\\\\\\\'\n'\\\\\\\\\\\\\\\\'\n>>> r'\\\\\\\\\\'\n  File \"<stdin>\", line 1\n    r'\\\\\\\\\\'\n           ^\nSyntaxError: EOL while scanning string literal\n```\n\nSo the difference between even/odd numbers of backslashes seems to carry over into raw-strings as well.",
    "created_at": "2020-10-04T00:58:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432107",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:44'></a>Oh, just to add to the example to show how python treats raw-strings with multiple backslashes:

```python
>>> r'\\'
'\\\\'
>>> r'\\\'
  File "<stdin>", line 1
    r'\\\'
         ^
SyntaxError: EOL while scanning string literal
>>> r'\\\\'
'\\\\\\\\'
>>> r'\\\\\'
  File "<stdin>", line 1
    r'\\\\\'
           ^
SyntaxError: EOL while scanning string literal
```

So the difference between even/odd numbers of backslashes seems to carry over into raw-strings as well.



---

archive/issue_comments_432108.json:
```json
{
    "body": "<a id='comment:45'></a>Replying to [comment:44 gh-jcamp0x2a]:\n> So the difference between even/odd numbers of backslashes seems to carry over into raw-strings as well.\n\n\nOk, I see. I was not aware of that.\n\nLet us move forward with this ticket then. Thanks again for all the effort that went into this.",
    "created_at": "2020-10-04T08:37:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432108",
    "user": "https://github.com/mwageringel"
}
```

<a id='comment:45'></a>Replying to [comment:44 gh-jcamp0x2a]:
> So the difference between even/odd numbers of backslashes seems to carry over into raw-strings as well.


Ok, I see. I was not aware of that.

Let us move forward with this ticket then. Thanks again for all the effort that went into this.



---

archive/issue_comments_432109.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-10-04T08:37:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432109",
    "user": "https://github.com/mwageringel"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_432110.json:
```json
{
    "body": "<a id='comment:46'></a>Changing the milestone just in case it is still possible to get the code into 9.2 since I haven't seen a release candidate build for 9.2 yet.",
    "created_at": "2020-10-04T15:41:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432110",
    "user": "https://github.com/jcamp0x2a"
}
```

<a id='comment:46'></a>Changing the milestone just in case it is still possible to get the code into 9.2 since I haven't seen a release candidate build for 9.2 yet.



---

archive/issue_events_073356.json:
```json
{
    "actor": "https://github.com/jcamp0x2a",
    "created_at": "2020-10-04T15:41:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28974#event-73356"
}
```



---

archive/issue_events_073357.json:
```json
{
    "actor": "https://github.com/jcamp0x2a",
    "created_at": "2020-10-04T15:41:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28974#event-73357"
}
```



---

archive/issue_comments_432111.json:
```json
{
    "body": "<a id='comment:47'></a>Since this is a pretty large change, I think it is better to merge it at the beginning of the 9.3 series.",
    "created_at": "2020-10-11T01:46:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432111",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:47'></a>Since this is a pretty large change, I think it is better to merge it at the beginning of the 9.3 series.



---

archive/issue_events_073358.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-10-11T01:46:10Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28974#event-73358"
}
```



---

archive/issue_events_073359.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-10-11T01:46:10Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28974#event-73359"
}
```



---

archive/issue_comments_432112.json:
```json
{
    "body": "<a id='comment:48'></a>Replying to [comment:29 gh-mwageringel]:\n> Replying to [comment:19 embray]:\n> > Replying to [comment:16 gh-mwageringel]:\n> > > This would still be difficult in case of multiline strings \u2013 though, I am not really sure why the preparser needs to run line by line.\n\n> > \n> > It's definitely a mess.  No one has taken the time to sit down and write a proper grammar for Sage and a real parser.\n\n> \n> Do I understand correctly that such a change would replace the preparser by a lexer and a parser in order to convert Sage code directly to an AST that can be compiled to byte code? Is this a long-term goal?\n\n\nYes, exactly.  The Sage interpreter should have its own parser based on extending the exiting Python grammar where necessary, plus a node transformer that transforms the AST into one that implements other preparser transformations, such as converting int literals to sage Integers.\n\nI don't think it's formally a \"long-term goal\" of anyone, but it really should be.  It's just a big task that no one's been motivated to take on.  But it would make issues like this one, and any other extensions we might want to add to the Sage language, much more feasible.  Python 3.8's new PEG parser (which we don't necessarily need to depend on Python 3.8 to use for Sage) might help make this easier: https://www.python.org/dev/peps/pep-0617/",
    "created_at": "2020-10-13T13:44:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432112",
    "user": "https://github.com/embray"
}
```

<a id='comment:48'></a>Replying to [comment:29 gh-mwageringel]:
> Replying to [comment:19 embray]:
> > Replying to [comment:16 gh-mwageringel]:
> > > This would still be difficult in case of multiline strings – though, I am not really sure why the preparser needs to run line by line.

> > 
> > It's definitely a mess.  No one has taken the time to sit down and write a proper grammar for Sage and a real parser.

> 
> Do I understand correctly that such a change would replace the preparser by a lexer and a parser in order to convert Sage code directly to an AST that can be compiled to byte code? Is this a long-term goal?


Yes, exactly.  The Sage interpreter should have its own parser based on extending the exiting Python grammar where necessary, plus a node transformer that transforms the AST into one that implements other preparser transformations, such as converting int literals to sage Integers.

I don't think it's formally a "long-term goal" of anyone, but it really should be.  It's just a big task that no one's been motivated to take on.  But it would make issues like this one, and any other extensions we might want to add to the Sage language, much more feasible.  Python 3.8's new PEG parser (which we don't necessarily need to depend on Python 3.8 to use for Sage) might help make this easier: https://www.python.org/dev/peps/pep-0617/



---

archive/issue_comments_432113.json:
```json
{
    "body": "<a id='comment:49'></a>I opened #30760 to provide some description to this task and put it out there for anyone who wants to tackle it.  I would work on it myself if I had the time...",
    "created_at": "2020-10-13T14:13:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432113",
    "user": "https://github.com/embray"
}
```

<a id='comment:49'></a>I opened #30760 to provide some description to this task and put it out there for anyone who wants to tackle it.  I would work on it myself if I had the time...



---

archive/issue_events_073360.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2020-10-31T18:08:12Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28974#event-73360"
}
```



---

archive/issue_comments_432114.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2020-10-31T18:08:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28974",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28974#issuecomment-432114",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
