# Issue 28444: Fix backwards incompatibility of unpickling in Python 3

archive/issues_028207.json:
```json
{
    "body": "EDIT: In the original ticket description, I stated: \"I believe that a backwards incompatible change of pickling is a blocker for Python-3 support.\" In that (and ONLY in that) sense I believe this ticket is a blocker. I replaced the original ticket description by something that I wrote in a comment, because now I have a much smaller example, and moreover pickles of the same object created with Python-3 and with Python-2, so that one can compare.\n\n\nThe following examples require the optional meataxe package, but I am not sure yet if meataxe is to blame or Python-3 (I hope it is the former, because I guess it would be more easy to fix).\n\nattachment:Py2.sobj\u200b and attachment:Py3.sobj\u200b result in the following behaviour in Python-3\n\n```\nsage: load('/home/king/Projekte/coho/tests/Py2.sobj')\n---------------------------------------------------------------------------\nUnicodeDecodeError                        Traceback (most recent call last)\n<ipython-input-3-5705b555470a> in <module>()\n----> 1 load('/home/king/Projekte/coho/tests/Py2.sobj')\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2824)()\n    149 \n    150     ## Load file by absolute filename\n--> 151     with open(filename, 'rb') as fobj:\n    152         X = loads(fobj.read(), compress=compress)\n    153     try:\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2774)()\n    150     ## Load file by absolute filename\n    151     with open(filename, 'rb') as fobj:\n--> 152         X = loads(fobj.read(), compress=compress)\n    153     try:\n    154         X._default_filename = os.path.abspath(filename)\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7270)()\n    967 \n    968     unpickler = SageUnpickler(io.BytesIO(s))\n--> 969     return unpickler.load()\n    970 \n    971 \n\nUnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)\nsage: load('/home/king/Projekte/coho/tests/Py3.sobj')\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\n```\nand in Python-2\n\n```\nsage: load('/home/king/Projekte/coho/tests/Py2.sobj')\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\nsage: load('/home/king/Projekte/coho/tests/Py3.sobj')\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\nsage: __ == _\nTrue\n```\nSo, the Python-3 pickle can be unpickled in Python-2, but not the other way around. What is the problem?\n\n**Keywords:** unpickling UnicodeError backwards compatibility\n\n**Branch:** [d7f170f2a2b8371da13d5577770b80868b21a726](https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726)\n\n**Reviewer:** Nils Bruin\n\n**Author:** Simon King\n\n**Resolution:** fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/28444\n\n",
    "closed_at": "2019-09-19T22:35:55Z",
    "created_at": "2019-09-02T15:50:02Z",
    "labels": [
        "component: python3",
        "blocker",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.9",
    "title": "Fix backwards incompatibility of unpickling in Python 3",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/28444",
    "user": "https://github.com/simon-king-jena"
}
```
EDIT: In the original ticket description, I stated: "I believe that a backwards incompatible change of pickling is a blocker for Python-3 support." In that (and ONLY in that) sense I believe this ticket is a blocker. I replaced the original ticket description by something that I wrote in a comment, because now I have a much smaller example, and moreover pickles of the same object created with Python-3 and with Python-2, so that one can compare.


The following examples require the optional meataxe package, but I am not sure yet if meataxe is to blame or Python-3 (I hope it is the former, because I guess it would be more easy to fix).

attachment:Py2.sobj​ and attachment:Py3.sobj​ result in the following behaviour in Python-3

```
sage: load('/home/king/Projekte/coho/tests/Py2.sobj')
---------------------------------------------------------------------------
UnicodeDecodeError                        Traceback (most recent call last)
<ipython-input-3-5705b555470a> in <module>()
----> 1 load('/home/king/Projekte/coho/tests/Py2.sobj')

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2824)()
    149 
    150     ## Load file by absolute filename
--> 151     with open(filename, 'rb') as fobj:
    152         X = loads(fobj.read(), compress=compress)
    153     try:

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2774)()
    150     ## Load file by absolute filename
    151     with open(filename, 'rb') as fobj:
--> 152         X = loads(fobj.read(), compress=compress)
    153     try:
    154         X._default_filename = os.path.abspath(filename)

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7270)()
    967 
    968     unpickler = SageUnpickler(io.BytesIO(s))
--> 969     return unpickler.load()
    970 
    971 

UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)
sage: load('/home/king/Projekte/coho/tests/Py3.sobj')
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
```
and in Python-2

```
sage: load('/home/king/Projekte/coho/tests/Py2.sobj')
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
sage: load('/home/king/Projekte/coho/tests/Py3.sobj')
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
sage: __ == _
True
```
So, the Python-3 pickle can be unpickled in Python-2, but not the other way around. What is the problem?

**Keywords:** unpickling UnicodeError backwards compatibility

**Branch:** [d7f170f2a2b8371da13d5577770b80868b21a726](https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726)

**Reviewer:** Nils Bruin

**Author:** Simon King

**Resolution:** fixed

Issue created by migration from https://trac.sagemath.org/ticket/28444





---

archive/issue_comments_552798.json:
```json
{
    "body": "File that cannot be unpickled in Python-3",
    "created_at": "2019-09-02T15:50:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552798",
    "user": "https://github.com/simon-king-jena"
}
```

File that cannot be unpickled in Python-3



---

archive/issue_comments_552799.json:
```json
{
    "body": "<a id='comment:1'></a>\nAttachment [State.sobj](tarball://root/attachments/some-uuid/ticket28444/State.sobj) by @nbruin created at 2019-09-02 16:20:11\n\nCan Sage/Py3 produce the pickle? In that case, you could compare the produced pickles to see how far apart they are. Of course, if an ASCII decoder encounters 0x80 it's justified to not decode it, so it might be interesting to see what py3 makes from it itself. My guess would be that the bytestring should NOT be decoded by ascii, but something else. Perhaps unpickle can be configured to use a different decoder. But it would be good to see what generates the non-ascii symbol and what its meaning is.",
    "created_at": "2019-09-02T16:20:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552799",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:1'></a>
Attachment [State.sobj](tarball://root/attachments/some-uuid/ticket28444/State.sobj) by @nbruin created at 2019-09-02 16:20:11

Can Sage/Py3 produce the pickle? In that case, you could compare the produced pickles to see how far apart they are. Of course, if an ASCII decoder encounters 0x80 it's justified to not decode it, so it might be interesting to see what py3 makes from it itself. My guess would be that the bytestring should NOT be decoded by ascii, but something else. Perhaps unpickle can be configured to use a different decoder. But it would be good to see what generates the non-ascii symbol and what its meaning is.



---

archive/issue_comments_552800.json:
```json
{
    "body": "<a id='comment:2'></a>\nReplying to [nbruin](#comment%3A1):\n> Of course, if an ASCII decoder encounters 0x80 it's justified to not decode it\n\n\nThen the same should hold for Python-2. It doesn't. Hence, it shouldn't hold for Python-3 either.",
    "created_at": "2019-09-02T16:24:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552800",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>
Replying to [nbruin](#comment%3A1):
> Of course, if an ASCII decoder encounters 0x80 it's justified to not decode it


Then the same should hold for Python-2. It doesn't. Hence, it shouldn't hold for Python-3 either.



---

archive/issue_comments_552801.json:
```json
{
    "body": "<a id='comment:3'></a>\nReplying to [nbruin](#comment%3A1):\n> Can Sage/Py3 produce the pickle?\n\n\nThe problem is that the pickle comes from an old version of an optional Sage package. That's why I use the \"unpickle override\". But I'll see what I can do.",
    "created_at": "2019-09-02T16:41:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552801",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:3'></a>
Replying to [nbruin](#comment%3A1):
> Can Sage/Py3 produce the pickle?


The problem is that the pickle comes from an old version of an optional Sage package. That's why I use the "unpickle override". But I'll see what I can do.



---

archive/issue_comments_552802.json:
```json
{
    "body": "<a id='comment:4'></a>\nThe new attachment was created with Python-2 and can be used without \"unpickle override\", but it requires the optional meataxe spkg.",
    "created_at": "2019-09-02T17:47:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552802",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
The new attachment was created with Python-2 and can be used without "unpickle override", but it requires the optional meataxe spkg.



---

archive/issue_comments_552803.json:
```json
{
    "body": "Pickle of MeatAxe in Python-2",
    "created_at": "2019-09-02T18:06:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552803",
    "user": "https://github.com/simon-king-jena"
}
```

Pickle of MeatAxe in Python-2



---

archive/issue_comments_552804.json:
```json
{
    "body": "Attachment [Py3.sobj](tarball://root/attachments/some-uuid/ticket28444/Py3.sobj) by @simon-king-jena created at 2019-09-02 18:09:13\n\nPickle of MeaAxe matrix created with Python-3",
    "created_at": "2019-09-02T18:09:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552804",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [Py3.sobj](tarball://root/attachments/some-uuid/ticket28444/Py3.sobj) by @simon-king-jena created at 2019-09-02 18:09:13

Pickle of MeaAxe matrix created with Python-3



---

archive/issue_comments_552805.json:
```json
{
    "body": "<a id='comment:5'></a>\nI think now I have a very small example. It uses the optional meataxe package. It would be a good news if actually the meataxe wrapper was to blame for the unpickling problem --- but I am not expert enough to tell whether (1) it is the case and (2) how it could be fixed (if it was the case).\n\nAnyway. I have a new version of attachment:Py2.sobj, and a new attachment:Py3.sobj.\nIt results in the following behaviour in Python-3\n\n```\nsage: load('/home/king/Projekte/coho/tests/Py2.sobj')\n---------------------------------------------------------------------------\nUnicodeDecodeError                        Traceback (most recent call last)\n<ipython-input-3-5705b555470a> in <module>()\n----> 1 load('/home/king/Projekte/coho/tests/Py2.sobj')\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2824)()\n    149 \n    150     ## Load file by absolute filename\n--> 151     with open(filename, 'rb') as fobj:\n    152         X = loads(fobj.read(), compress=compress)\n    153     try:\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2774)()\n    150     ## Load file by absolute filename\n    151     with open(filename, 'rb') as fobj:\n--> 152         X = loads(fobj.read(), compress=compress)\n    153     try:\n    154         X._default_filename = os.path.abspath(filename)\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7270)()\n    967 \n    968     unpickler = SageUnpickler(io.BytesIO(s))\n--> 969     return unpickler.load()\n    970 \n    971 \n\nUnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)\nsage: load('/home/king/Projekte/coho/tests/Py3.sobj')\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\n```\nand in Python-2\n\n```\nsage: load('/home/king/Projekte/coho/tests/Py2.sobj')\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\nsage: load('/home/king/Projekte/coho/tests/Py3.sobj')\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\nsage: __ == _\nTrue\n```\nSo, the Python-3 pickle can be unpickled in Python-2, but not the other way around. What is the problem?",
    "created_at": "2019-09-02T18:15:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552805",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
I think now I have a very small example. It uses the optional meataxe package. It would be a good news if actually the meataxe wrapper was to blame for the unpickling problem --- but I am not expert enough to tell whether (1) it is the case and (2) how it could be fixed (if it was the case).

Anyway. I have a new version of attachment:Py2.sobj, and a new attachment:Py3.sobj.
It results in the following behaviour in Python-3

```
sage: load('/home/king/Projekte/coho/tests/Py2.sobj')
---------------------------------------------------------------------------
UnicodeDecodeError                        Traceback (most recent call last)
<ipython-input-3-5705b555470a> in <module>()
----> 1 load('/home/king/Projekte/coho/tests/Py2.sobj')

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2824)()
    149 
    150     ## Load file by absolute filename
--> 151     with open(filename, 'rb') as fobj:
    152         X = loads(fobj.read(), compress=compress)
    153     try:

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2774)()
    150     ## Load file by absolute filename
    151     with open(filename, 'rb') as fobj:
--> 152         X = loads(fobj.read(), compress=compress)
    153     try:
    154         X._default_filename = os.path.abspath(filename)

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7270)()
    967 
    968     unpickler = SageUnpickler(io.BytesIO(s))
--> 969     return unpickler.load()
    970 
    971 

UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)
sage: load('/home/king/Projekte/coho/tests/Py3.sobj')
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
```
and in Python-2

```
sage: load('/home/king/Projekte/coho/tests/Py2.sobj')
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
sage: load('/home/king/Projekte/coho/tests/Py3.sobj')
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
sage: __ == _
True
```
So, the Python-3 pickle can be unpickled in Python-2, but not the other way around. What is the problem?



---

archive/issue_comments_552806.json:
```json
{
    "body": "<a id='comment:6'></a>\nNote that the Python-3 pickle is as much as 25% larger than the Python-2 pickle. Is that regression typical?",
    "created_at": "2019-09-02T18:17:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552806",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>
Note that the Python-3 pickle is as much as 25% larger than the Python-2 pickle. Is that regression typical?



---

archive/issue_comments_552807.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,16 +1,16 @@\n-The following happens in Sage with Python-3, when trying to unpickle the attached file `State.sobj`:\n+EDIT: I replaced the original ticket description by something that I wrote in a comment, because now I have a much smaller example, and moreover pickles of the same object created with Python-3 and with Python-2, so that one can compare.\n+\n+\n+The following examples require the optional meataxe package, but I am not sure yet if meataxe is to blame or Python-3 (I hope it is the former, because I guess it would be more easy to fix).\n+\n+attachment:Py2.sobj\u200b and attachment:Py3.sobj\u200b result in the following behaviour in Python-3\n \n ```\n-sage: class unpickle_old_mtx:\n-....:     def __call__(self, *args, **kwds):\n-....:         return None\n-....:     \n-sage: register_unpickle_override('pGroupCohomology.mtx', 'MTX_unpickle_class', unpickle_old_mtx)\n-sage: X = load('/home/king/Projekte/coho/tests/State.sobj')\n+sage: load('/home/king/Projekte/coho/tests/Py2.sobj')\n ---------------------------------------------------------------------------\n UnicodeDecodeError                        Traceback (most recent call last)\n-<ipython-input-3-74e7e91f9969> in <module>()\n-----> 1 X = load('/home/king/Projekte/coho/tests/State.sobj')\n+<ipython-input-3-5705b555470a> in <module>()\n+----> 1 load('/home/king/Projekte/coho/tests/Py2.sobj')\n \n /home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2824)()\n     149 \n@@ -34,95 +34,20 @@\n     971 \n \n UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)\n+sage: load('/home/king/Projekte/coho/tests/Py3.sobj')\n+[1 0 0 0 0 0 0 0]\n+[0 0 0 1 1 1 1 1]\n ```\n-\n-Doing the same in Sage-with-Python-2, one gets\n+and in Python-2\n \n ```\n-sage: class unpickle_old_mtx:\n-....:     def __call__(self, *args, **kwds):\n-....:         return None\n-....:     \n-sage: register_unpickle_override('pGroupCohomology.mtx', 'MTX_unpickle_class', unpickle_old_mtx)\n-sage: X = load('/home/king/Projekte/coho/tests/State.sobj')\n-sage: X\n-([[1,\n-   [(2, 1),\n-    [None,\n-     [None,\n-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg1_1',\n-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg1_2']]]],\n-  [2,\n-   [(4, 2),\n-    [None,\n-     [None,\n-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg2_1',\n-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg2_2']]]],\n-  [3,\n-   [(4, 2),\n-    [None,\n-     [None,\n-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg3_1',\n-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg3_2']]]]],\n- [2, 1, 1],\n- 1,\n- 1,\n- '8gp3/',\n- ['b_1_0*b_1_1'],\n- '8gp3/dat/',\n- [((4, 2), '/home/king/.sage/pGroupCohomology/db/4gp2/H4gp2'),\n-  ((2, 1), '/home/king/.sage/pGroupCohomology/db/2gp1/H2gp1')],\n- '8gp3/dat/',\n- [],\n- '8gp3/sgp/',\n- 2,\n- [2, 3],\n- [2, 2],\n- 2,\n- 2,\n- ['b_1_0*b_1_1'],\n- [[2, 'c_2_2', None, 1, 0],\n-  [1, 'b_1_0', None, 0, 0],\n-  [1, 'b_1_1', None, 0, 0]],\n- [[0, [['1', ['1']]]],\n-  [1, [['b_1_0', ['b_1_0']], ['b_1_1', ['b_1_1']]]],\n-  [2,\n-   [['c_2_2', ['c_2_2']],\n-    ['b_1_0', ['b_1_0^2']],\n-    ['b_1_1', ['b_1_0*b_1_1', 'b_1_1^2']]]]],\n- {},\n- 0.24,\n- True,\n- 'Monomials',\n- 2,\n- None,\n- '',\n- 0,\n- '8gp3',\n- '8gp3/dat/R8gp3.sobj',\n- 1,\n- ['0'],\n- ['b_1_0 + b_1_1'],\n- None,\n- [('_max_module_deg', 0),\n-  ('sgpDickson', [((4, 2), [[1, 'c_1_1', None]])]),\n-  ('useFactorization', True),\n-  ('useElimination', False),\n-  ('GroupDescr', 'Dihedral group of order 8'),\n-  ('_key', ((8, 3), '/home/king/SPKG/database/8gp3/dat/State')),\n-  ('auto', 4),\n-  ('Restriction_2', ['c_1_0*c_1_1+c_1_0^2', 'c_1_1', '0']),\n-  ('GroupName', 'D8'),\n-  ('DicksonExp', 3),\n-  ('_parameters_do_exist', True),\n-  ('KeepBases', None),\n-  ('completeGroebner', True),\n-  ('_SymondsTestdata', ['c_2_2', 'b_1_1', 'b_1_0']),\n-  ('_parameters_for_criterion', ['c_2_2', 'b_1_1', 'b_1_0']),\n-  ('root', '/home/king/SPKG/database/'),\n-  ('Restriction_3', ['c_1_0*c_1_1+c_1_0^2', '0', 'c_1_1']),\n-  ('_method', 'Symonds')],\n- [(('dependent_parameters',), [['c_2_2', 'b_1_1', 'b_1_0'], 2])])\n+sage: load('/home/king/Projekte/coho/tests/Py2.sobj')\n+[1 0 0 0 0 0 0 0]\n+[0 0 0 1 1 1 1 1]\n+sage: load('/home/king/Projekte/coho/tests/Py3.sobj')\n+[1 0 0 0 0 0 0 0]\n+[0 0 0 1 1 1 1 1]\n+sage: __ == _\n+True\n ```\n-\n-I believe that a backwards incompatible change of pickling is a blocker for Python-3 support.\n+So, the Python-3 pickle can be unpickled in Python-2, but not the other way around. What is the problem?\n``````\n",
    "created_at": "2019-09-02T18:28:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552807",
    "user": "https://github.com/simon-king-jena"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,16 +1,16 @@
-The following happens in Sage with Python-3, when trying to unpickle the attached file `State.sobj`:
+EDIT: I replaced the original ticket description by something that I wrote in a comment, because now I have a much smaller example, and moreover pickles of the same object created with Python-3 and with Python-2, so that one can compare.
+
+
+The following examples require the optional meataxe package, but I am not sure yet if meataxe is to blame or Python-3 (I hope it is the former, because I guess it would be more easy to fix).
+
+attachment:Py2.sobj​ and attachment:Py3.sobj​ result in the following behaviour in Python-3
 
 ```
-sage: class unpickle_old_mtx:
-....:     def __call__(self, *args, **kwds):
-....:         return None
-....:     
-sage: register_unpickle_override('pGroupCohomology.mtx', 'MTX_unpickle_class', unpickle_old_mtx)
-sage: X = load('/home/king/Projekte/coho/tests/State.sobj')
+sage: load('/home/king/Projekte/coho/tests/Py2.sobj')
 ---------------------------------------------------------------------------
 UnicodeDecodeError                        Traceback (most recent call last)
-<ipython-input-3-74e7e91f9969> in <module>()
-----> 1 X = load('/home/king/Projekte/coho/tests/State.sobj')
+<ipython-input-3-5705b555470a> in <module>()
+----> 1 load('/home/king/Projekte/coho/tests/Py2.sobj')
 
 /home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2824)()
     149 
@@ -34,95 +34,20 @@
     971 
 
 UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)
+sage: load('/home/king/Projekte/coho/tests/Py3.sobj')
+[1 0 0 0 0 0 0 0]
+[0 0 0 1 1 1 1 1]
 ```
-
-Doing the same in Sage-with-Python-2, one gets
+and in Python-2
 
 ```
-sage: class unpickle_old_mtx:
-....:     def __call__(self, *args, **kwds):
-....:         return None
-....:     
-sage: register_unpickle_override('pGroupCohomology.mtx', 'MTX_unpickle_class', unpickle_old_mtx)
-sage: X = load('/home/king/Projekte/coho/tests/State.sobj')
-sage: X
-([[1,
-   [(2, 1),
-    [None,
-     [None,
-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg1_1',
-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg1_2']]]],
-  [2,
-   [(4, 2),
-    [None,
-     [None,
-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg2_1',
-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg2_2']]]],
-  [3,
-   [(4, 2),
-    [None,
-     [None,
-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg3_1',
-      '/home/king/SPKG/database/8gp3/sgp/8gp3sg3_2']]]]],
- [2, 1, 1],
- 1,
- 1,
- '8gp3/',
- ['b_1_0*b_1_1'],
- '8gp3/dat/',
- [((4, 2), '/home/king/.sage/pGroupCohomology/db/4gp2/H4gp2'),
-  ((2, 1), '/home/king/.sage/pGroupCohomology/db/2gp1/H2gp1')],
- '8gp3/dat/',
- [],
- '8gp3/sgp/',
- 2,
- [2, 3],
- [2, 2],
- 2,
- 2,
- ['b_1_0*b_1_1'],
- [[2, 'c_2_2', None, 1, 0],
-  [1, 'b_1_0', None, 0, 0],
-  [1, 'b_1_1', None, 0, 0]],
- [[0, [['1', ['1']]]],
-  [1, [['b_1_0', ['b_1_0']], ['b_1_1', ['b_1_1']]]],
-  [2,
-   [['c_2_2', ['c_2_2']],
-    ['b_1_0', ['b_1_0^2']],
-    ['b_1_1', ['b_1_0*b_1_1', 'b_1_1^2']]]]],
- {},
- 0.24,
- True,
- 'Monomials',
- 2,
- None,
- '',
- 0,
- '8gp3',
- '8gp3/dat/R8gp3.sobj',
- 1,
- ['0'],
- ['b_1_0 + b_1_1'],
- None,
- [('_max_module_deg', 0),
-  ('sgpDickson', [((4, 2), [[1, 'c_1_1', None]])]),
-  ('useFactorization', True),
-  ('useElimination', False),
-  ('GroupDescr', 'Dihedral group of order 8'),
-  ('_key', ((8, 3), '/home/king/SPKG/database/8gp3/dat/State')),
-  ('auto', 4),
-  ('Restriction_2', ['c_1_0*c_1_1+c_1_0^2', 'c_1_1', '0']),
-  ('GroupName', 'D8'),
-  ('DicksonExp', 3),
-  ('_parameters_do_exist', True),
-  ('KeepBases', None),
-  ('completeGroebner', True),
-  ('_SymondsTestdata', ['c_2_2', 'b_1_1', 'b_1_0']),
-  ('_parameters_for_criterion', ['c_2_2', 'b_1_1', 'b_1_0']),
-  ('root', '/home/king/SPKG/database/'),
-  ('Restriction_3', ['c_1_0*c_1_1+c_1_0^2', '0', 'c_1_1']),
-  ('_method', 'Symonds')],
- [(('dependent_parameters',), [['c_2_2', 'b_1_1', 'b_1_0'], 2])])
+sage: load('/home/king/Projekte/coho/tests/Py2.sobj')
+[1 0 0 0 0 0 0 0]
+[0 0 0 1 1 1 1 1]
+sage: load('/home/king/Projekte/coho/tests/Py3.sobj')
+[1 0 0 0 0 0 0 0]
+[0 0 0 1 1 1 1 1]
+sage: __ == _
+True
 ```
-
-I believe that a backwards incompatible change of pickling is a blocker for Python-3 support.
+So, the Python-3 pickle can be unpickled in Python-2, but not the other way around. What is the problem?
``````




---

archive/issue_comments_552808.json:
```json
{
    "body": "**Changing keywords** from \"unpickling UnicodeError\" to \"unpickling UnicodeError meataxe\".",
    "created_at": "2019-09-02T18:28:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552808",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing keywords** from "unpickling UnicodeError" to "unpickling UnicodeError meataxe".



---

archive/issue_comments_552809.json:
```json
{
    "body": "<a id='comment:8'></a>\nThis is in no way a blocker, IMHO.",
    "created_at": "2019-09-02T19:07:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552809",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:8'></a>
This is in no way a blocker, IMHO.



---

archive/issue_comments_552810.json:
```json
{
    "body": "<a id='comment:9'></a>\nReplying to [chapoton](#comment%3A8):\n> This is in no way a blocker, IMHO.\n\n\nIf it is due to meataxe (an optional package), then it is not a blocker. If it is due to the upcoming switch to Python-3, then IMHO it is a blocker to that switch (not to a Python-2 version of Sage, though). Since currently it isn't clear if the example reveals a problem in Python-3 or not, I'd say better safe than sorry.",
    "created_at": "2019-09-02T19:10:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552810",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Replying to [chapoton](#comment%3A8):
> This is in no way a blocker, IMHO.


If it is due to meataxe (an optional package), then it is not a blocker. If it is due to the upcoming switch to Python-3, then IMHO it is a blocker to that switch (not to a Python-2 version of Sage, though). Since currently it isn't clear if the example reveals a problem in Python-3 or not, I'd say better safe than sorry.



---

archive/issue_comments_552811.json:
```json
{
    "body": "<a id='comment:10'></a>\nSo we agree that this is not a blocker for the upcoming 8.9 release, still py2. This is the usual meaning of blocker. But in this time of transition, we must be clearer about what blocker means.",
    "created_at": "2019-09-02T19:17:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552811",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:10'></a>
So we agree that this is not a blocker for the upcoming 8.9 release, still py2. This is the usual meaning of blocker. But in this time of transition, we must be clearer about what blocker means.



---

archive/issue_comments_552812.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n-EDIT: I replaced the original ticket description by something that I wrote in a comment, because now I have a much smaller example, and moreover pickles of the same object created with Python-3 and with Python-2, so that one can compare.\n+EDIT: In the original ticket description, I stated: \"I believe that a backwards incompatible change of pickling is a blocker for Python-3 support.\" In that (and ONLY in that) sense I believe this ticket is a blocker. I replaced the original ticket description by something that I wrote in a comment, because now I have a much smaller example, and moreover pickles of the same object created with Python-3 and with Python-2, so that one can compare.\n \n \n The following examples require the optional meataxe package, but I am not sure yet if meataxe is to blame or Python-3 (I hope it is the former, because I guess it would be more easy to fix).\n``````\n",
    "created_at": "2019-09-02T19:20:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552812",
    "user": "https://github.com/simon-king-jena"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
-EDIT: I replaced the original ticket description by something that I wrote in a comment, because now I have a much smaller example, and moreover pickles of the same object created with Python-3 and with Python-2, so that one can compare.
+EDIT: In the original ticket description, I stated: "I believe that a backwards incompatible change of pickling is a blocker for Python-3 support." In that (and ONLY in that) sense I believe this ticket is a blocker. I replaced the original ticket description by something that I wrote in a comment, because now I have a much smaller example, and moreover pickles of the same object created with Python-3 and with Python-2, so that one can compare.
 
 
 The following examples require the optional meataxe package, but I am not sure yet if meataxe is to blame or Python-3 (I hope it is the former, because I guess it would be more easy to fix).
``````




---

archive/issue_comments_552813.json:
```json
{
    "body": "<a id='comment:11'></a>\nReplying to [chapoton](#comment%3A10):\n> So we agree that this is not a blocker for the upcoming 8.9 release, still py2. This is the usual meaning of blocker. But in this time of transition, we must be clearer about what blocker means.\n\n\nIn the original ticket description, I told in what sense I believe it was a blocker, but I somehow deleted that clarification when I changed the ticket description. Now, the statement is back, at the top of the ticket description.",
    "created_at": "2019-09-02T19:20:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552813",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'></a>
Replying to [chapoton](#comment%3A10):
> So we agree that this is not a blocker for the upcoming 8.9 release, still py2. This is the usual meaning of blocker. But in this time of transition, we must be clearer about what blocker means.


In the original ticket description, I told in what sense I believe it was a blocker, but I somehow deleted that clarification when I changed the ticket description. Now, the statement is back, at the top of the ticket description.



---

archive/issue_comments_552814.json:
```json
{
    "body": "<a id='comment:12'></a>\ncould you provide the needed register unpickle override ?\n\nTrying to load with py3, I stumble on\n\n```\nModuleNotFoundError: No module named 'sage.matrix.matrix_gfpn_dense'\n```",
    "created_at": "2019-09-02T19:25:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552814",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:12'></a>
could you provide the needed register unpickle override ?

Trying to load with py3, I stumble on

```
ModuleNotFoundError: No module named 'sage.matrix.matrix_gfpn_dense'
```



---

archive/issue_comments_552815.json:
```json
{
    "body": "<a id='comment:13'></a>\nReplying to [chapoton](#comment%3A12):\n> could you provide the needed register unpickle override ?\n> \n> Trying to load with py3, I stumble on\n> \n> ```\n> ModuleNotFoundError: No module named 'sage.matrix.matrix_gfpn_dense'\n> ```\n\n\nAs stated in the ticket description, the pickle is supposed to be loadable with the optional meataxe package (followed by `sage -b`) installed. However, I believe (but cannot test it, as I do not have Sage without meataxe) that the following register unpickle override would work:\n\n```\nsage: def unpickler(*args, **kwds):\n....:     return None\n....: \nsage: register_unpickle_override('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle', unpickler)\nsage: load('/home/king/Projekte/coho/tests/Py2.sobj')\n```\nI suppose the \"load()\" command will return None in Python-2 but result in an error with Python-3 (even without meataxe installed).",
    "created_at": "2019-09-02T19:33:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552815",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:13'></a>
Replying to [chapoton](#comment%3A12):
> could you provide the needed register unpickle override ?
> 
> Trying to load with py3, I stumble on
> 
> ```
> ModuleNotFoundError: No module named 'sage.matrix.matrix_gfpn_dense'
> ```


As stated in the ticket description, the pickle is supposed to be loadable with the optional meataxe package (followed by `sage -b`) installed. However, I believe (but cannot test it, as I do not have Sage without meataxe) that the following register unpickle override would work:

```
sage: def unpickler(*args, **kwds):
....:     return None
....: 
sage: register_unpickle_override('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle', unpickler)
sage: load('/home/king/Projekte/coho/tests/Py2.sobj')
```
I suppose the "load()" command will return None in Python-2 but result in an error with Python-3 (even without meataxe installed).



---

archive/issue_comments_552816.json:
```json
{
    "body": "<a id='comment:14'></a>\nusing your empty unpickler, I still get the same `ModuleNotFoundError`",
    "created_at": "2019-09-02T19:36:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552816",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:14'></a>
using your empty unpickler, I still get the same `ModuleNotFoundError`



---

archive/issue_comments_552817.json:
```json
{
    "body": "<a id='comment:15'></a>\nReplying to [chapoton](#comment%3A14):\n> using you empty unpickler, I still get the same `ModuleNotFoundError`\n\n\nI guess the matrix space is a matrix space with `implementation=meataxe`, and the parent of a matrix is also part of the pickle.\n\nSo, we'll override unpickling the matrix space as well:\n\n```\nsage: def MS_unpickler(*args, **kwds):\n....:     return MatrixSpace(*(args[:4]),**kwds)\n....: \nsage: def mtx_unpickler(*args, **kwds):\n....:     return None\n....: \nsage: register_unpickle_override('sage.matrix.matrix_space', 'MatrixSpace', MS_unpickler)\nsage: register_unpickle_override('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle', mtx_unpickler)\nsage: load('/home/king/Projekte/coho/tests/Py2.sobj')\n```",
    "created_at": "2019-09-02T19:44:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552817",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:15'></a>
Replying to [chapoton](#comment%3A14):
> using you empty unpickler, I still get the same `ModuleNotFoundError`


I guess the matrix space is a matrix space with `implementation=meataxe`, and the parent of a matrix is also part of the pickle.

So, we'll override unpickling the matrix space as well:

```
sage: def MS_unpickler(*args, **kwds):
....:     return MatrixSpace(*(args[:4]),**kwds)
....: 
sage: def mtx_unpickler(*args, **kwds):
....:     return None
....: 
sage: register_unpickle_override('sage.matrix.matrix_space', 'MatrixSpace', MS_unpickler)
sage: register_unpickle_override('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle', mtx_unpickler)
sage: load('/home/king/Projekte/coho/tests/Py2.sobj')
```



---

archive/issue_comments_552818.json:
```json
{
    "body": "<a id='comment:16'></a>\nSame thing with the new unpicklers proposal. I tried something else:\n\n```\nsage: explain_pickle(open('Py2.sobj', 'rb').read())\npg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')\npg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')\npg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')\npg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')\npg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')\npg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')\nsi = pg_make_integer('2')\npg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')\npg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, '\\x80\\x1f', True)\n\nsage: explain_pickle(open('Py3.sobj', 'rb').read())\npg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')\npg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')\npg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')\npg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')\npg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')\npg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')\nsi = pg_make_integer('2')\npg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')\npg_encode = unpickle_global('_codecs', 'encode')\npg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, pg_encode('\\x80\\x1f', 'latin1'), True)\n```",
    "created_at": "2019-09-02T19:48:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552818",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:16'></a>
Same thing with the new unpicklers proposal. I tried something else:

```
sage: explain_pickle(open('Py2.sobj', 'rb').read())
pg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')
pg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')
pg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')
pg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')
pg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')
pg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')
si = pg_make_integer('2')
pg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')
pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, '\x80\x1f', True)

sage: explain_pickle(open('Py3.sobj', 'rb').read())
pg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')
pg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')
pg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')
pg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')
pg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')
pg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')
si = pg_make_integer('2')
pg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')
pg_encode = unpickle_global('_codecs', 'encode')
pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, pg_encode('\x80\x1f', 'latin1'), True)
```



---

archive/issue_comments_552819.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [chapoton](#comment%3A16):\n> Same thing with the new unpicklers proposal.\n\n\nCan you try to add another line:\n\n```\nsage: register_unpickle_override('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense', type)\n```",
    "created_at": "2019-09-02T19:56:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552819",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:17'></a>
Replying to [chapoton](#comment%3A16):
> Same thing with the new unpicklers proposal.


Can you try to add another line:

```
sage: register_unpickle_override('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense', type)
```



---

archive/issue_comments_552820.json:
```json
{
    "body": "<a id='comment:18'></a>\nReplying to [chapoton](#comment%3A16):\n> I tried something else:\n> \n> ```\n> sage: explain_pickle(open('Py2.sobj', 'rb').read())\n> pg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')\n> pg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')\n> pg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')\n> pg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')\n> pg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')\n> pg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')\n> si = pg_make_integer('2')\n> pg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')\n> pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, '\\x80\\x1f', True)\n> \n> sage: explain_pickle(open('Py3.sobj', 'rb').read())\n> pg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')\n> pg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')\n> pg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')\n> pg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')\n> pg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')\n> pg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')\n> si = pg_make_integer('2')\n> pg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')\n> pg_encode = unpickle_global('_codecs', 'encode')\n> pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, pg_encode('\\x80\\x1f', 'latin1'), True)\n> ```\n\n\nDo I see correctly that the only difference is the line\n\n```\npg_encode = unpickle_global('_codecs', 'encode')\n```\nthat is in Python-3 but not in Python-2? What are the implications?",
    "created_at": "2019-09-02T19:59:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552820",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'></a>
Replying to [chapoton](#comment%3A16):
> I tried something else:
> 
> ```
> sage: explain_pickle(open('Py2.sobj', 'rb').read())
> pg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')
> pg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')
> pg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')
> pg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')
> pg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')
> pg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')
> si = pg_make_integer('2')
> pg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')
> pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, '\x80\x1f', True)
> 
> sage: explain_pickle(open('Py3.sobj', 'rb').read())
> pg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')
> pg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')
> pg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')
> pg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')
> pg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')
> pg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')
> si = pg_make_integer('2')
> pg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')
> pg_encode = unpickle_global('_codecs', 'encode')
> pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, pg_encode('\x80\x1f', 'latin1'), True)
> ```


Do I see correctly that the only difference is the line

```
pg_encode = unpickle_global('_codecs', 'encode')
```
that is in Python-3 but not in Python-2? What are the implications?



---

archive/issue_comments_552821.json:
```json
{
    "body": "<a id='comment:19'></a>\nThere is another difference at the end of the last line of the explain pickles, that contains 0x80..\n\nWith the third \"register_unpickle, I now get\n\n```\nsage: load('Py3.sobj')\n```\nworks ie returns None. And\n\n```\nsage: load('Py2.sobj')\n---------------------------------------------------------------------------\nUnicodeDecodeError                        Traceback (most recent call last)\n<ipython-input-38-45fcfa858fc2> in <module>()\n----> 1 load('Py2.sobj')\n\n/home/chapoton/sage3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2824)()\n    149 \n    150     ## Load file by absolute filename\n--> 151     with open(filename, 'rb') as fobj:\n    152         X = loads(fobj.read(), compress=compress)\n    153     try:\n\n/home/chapoton/sage3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2774)()\n    150     ## Load file by absolute filename\n    151     with open(filename, 'rb') as fobj:\n--> 152         X = loads(fobj.read(), compress=compress)\n    153     try:\n    154         X._default_filename = os.path.abspath(filename)\n\n/home/chapoton/sage3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7270)()\n    967 \n    968     unpickler = SageUnpickler(io.BytesIO(s))\n--> 969     return unpickler.load()\n    970 \n    971 \n\nUnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)\n```",
    "created_at": "2019-09-02T20:02:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552821",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:19'></a>
There is another difference at the end of the last line of the explain pickles, that contains 0x80..

With the third "register_unpickle, I now get

```
sage: load('Py3.sobj')
```
works ie returns None. And

```
sage: load('Py2.sobj')
---------------------------------------------------------------------------
UnicodeDecodeError                        Traceback (most recent call last)
<ipython-input-38-45fcfa858fc2> in <module>()
----> 1 load('Py2.sobj')

/home/chapoton/sage3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2824)()
    149 
    150     ## Load file by absolute filename
--> 151     with open(filename, 'rb') as fobj:
    152         X = loads(fobj.read(), compress=compress)
    153     try:

/home/chapoton/sage3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2774)()
    150     ## Load file by absolute filename
    151     with open(filename, 'rb') as fobj:
--> 152         X = loads(fobj.read(), compress=compress)
    153     try:
    154         X._default_filename = os.path.abspath(filename)

/home/chapoton/sage3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7270)()
    967 
    968     unpickler = SageUnpickler(io.BytesIO(s))
--> 969     return unpickler.load()
    970 
    971 

UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)
```



---

archive/issue_comments_552822.json:
```json
{
    "body": "<a id='comment:20'></a>\nReplying to [chapoton](#comment%3A19):\n> There is another difference at the end of the last line of the explain pickles, that contains 0x80..\n\n\nRight.\n\nDo I understand correctly, that the string with 0x80 is swallowed without problem by Python-2, both with and without explicit encoding, while Python-3 will swallow it ONLY with an explicit encoding?\n\nThen: How to make it so that temporarily the unpickler assumes a default encoding?\n\n\n> With the third \"register_unpickle, I now get ...\n\n\nHooray! So, it is now possible to investigate the core problem.",
    "created_at": "2019-09-02T20:08:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552822",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:20'></a>
Replying to [chapoton](#comment%3A19):
> There is another difference at the end of the last line of the explain pickles, that contains 0x80..


Right.

Do I understand correctly, that the string with 0x80 is swallowed without problem by Python-2, both with and without explicit encoding, while Python-3 will swallow it ONLY with an explicit encoding?

Then: How to make it so that temporarily the unpickler assumes a default encoding?


> With the third "register_unpickle, I now get ...


Hooray! So, it is now possible to investigate the core problem.



---

archive/issue_comments_552823.json:
```json
{
    "body": "<a id='comment:21'></a>\nAha! I guess the problem is indeed that the string passed to the matrix constructor is supposed to be interpreted as bytes. Namely:\n\n```\nsage: pg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')\n....: pg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')\n....: pg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')\n....: pg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')\n....: pg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')\n....: pg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')\n....: si = pg_make_integer('2')\n....: pg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')\nsage: pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField\n....: '), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {\n....: }), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, '\\x80\\x1f', True)\n....: \n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-12-5506f597954b> in <module>()\n----> 1 pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8, 9, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2, 8, False, pg_Matrix_gfpn_dense), {}), 2, 8, '\\x80\\x1f', True)\n\nTypeError: Argument 'Data' has incorrect type (expected bytes, got str)\nsage: pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField\n....: '), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {\n....: }), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, b'\\x80\\x1f', True)\n....: \n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\n```\n(of course, this is with meataxe installed).\n\nSo, is it possible to automatically load a Python-2 string as a Python-3 bytes, as if one simply puts a `b` in front of the string (that's what I did in the last line of the above example)?",
    "created_at": "2019-09-02T20:14:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552823",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:21'></a>
Aha! I guess the problem is indeed that the string passed to the matrix constructor is supposed to be interpreted as bytes. Namely:

```
sage: pg_mtx_unpickle = unpickle_global('sage.matrix.matrix_gfpn_dense', 'mtx_unpickle')
....: pg_unreduce = unpickle_global('sage.structure.unique_representation', 'unreduce')
....: pg_MatrixSpace = unpickle_global('sage.matrix.matrix_space', 'MatrixSpace')
....: pg_generic_factory_unpickle = unpickle_global('sage.structure.factory', 'generic_factory_unpickle')
....: pg_lookup_global = unpickle_global('sage.structure.factory', 'lookup_global')
....: pg_make_integer = unpickle_global('sage.rings.integer', 'make_integer')
....: si = pg_make_integer('2')
....: pg_Matrix_gfpn_dense = unpickle_global('sage.matrix.matrix_gfpn_dense', 'Matrix_gfpn_dense')
sage: pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField
....: '), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {
....: }), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, '\x80\x1f', True)
....: 
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-12-5506f597954b> in <module>()
----> 1 pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField'), (8, 9, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {}), 2, 8, False, pg_Matrix_gfpn_dense), {}), 2, 8, '\x80\x1f', True)

TypeError: Argument 'Data' has incorrect type (expected bytes, got str)
sage: pg_mtx_unpickle(pg_unreduce(pg_MatrixSpace, (pg_generic_factory_unpickle(pg_lookup_global('FiniteField
....: '), (8r, 9r, 'beta8'), (si, ('x',), None, 'modn', si, pg_make_integer('1'), True, None, None, None), {
....: }), 2r, 8r, False, pg_Matrix_gfpn_dense), {}), 2r, 8r, b'\x80\x1f', True)
....: 
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
```
(of course, this is with meataxe installed).

So, is it possible to automatically load a Python-2 string as a Python-3 bytes, as if one simply puts a `b` in front of the string (that's what I did in the last line of the above example)?



---

archive/issue_comments_552824.json:
```json
{
    "body": "<a id='comment:22'></a>\nHappy to see progress. But sorry, I will now turn offline..",
    "created_at": "2019-09-02T20:17:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552824",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:22'></a>
Happy to see progress. But sorry, I will now turn offline..



---

archive/issue_comments_552825.json:
```json
{
    "body": "<a id='comment:23'></a>\nEverything boils down to the following:\n\n- In Python-2, do\n\n  ```\nsage: X = '\\x80\\x1f'\nsage: save(X, 'Py2_string.sobj')\n  ```\n- In Python-3, you'll get\n\n  ```\nsage: load('/home/king/Projekte/coho/tests/Py2_string.sobj')\nTraceback (most recent call last):\n...\nUnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)\n  ```\n\nSo, it is really the question: How can I (temporarily) force Python-3 to interpret a pickled string as bytes?",
    "created_at": "2019-09-02T20:34:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552825",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:23'></a>
Everything boils down to the following:

- In Python-2, do

  ```
sage: X = '\x80\x1f'
sage: save(X, 'Py2_string.sobj')
  ```
- In Python-3, you'll get

  ```
sage: load('/home/king/Projekte/coho/tests/Py2_string.sobj')
Traceback (most recent call last):
...
UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)
  ```

So, it is really the question: How can I (temporarily) force Python-3 to interpret a pickled string as bytes?



---

archive/issue_comments_552826.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [SimonKing](#comment%3A23):\n> So, it is really the question: How can I (temporarily) force Python-3 to interpret a pickled string as bytes?\n\n\nIt looks like other people have run into this problem:\n\nhttps://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3",
    "created_at": "2019-09-02T22:53:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552826",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:24'></a>
Replying to [SimonKing](#comment%3A23):
> So, it is really the question: How can I (temporarily) force Python-3 to interpret a pickled string as bytes?


It looks like other people have run into this problem:

https://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3



---

archive/issue_comments_552827.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [nbruin](#comment%3A24):\n> Replying to [SimonKing](#comment%3A23):\n> > So, it is really the question: How can I (temporarily) force Python-3 to interpret a pickled string as bytes?\n\n> \n> It looks like other people have run into this problem:\n> \n> https://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3\n\n\nI was wondering about one of the approaches mentioned there: within Python 2, unpickle the data, then save it in a format which can be read by Python 3, or ideally, read by both Python 2 and 3.",
    "created_at": "2019-09-02T22:57:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552827",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:25'></a>
Replying to [nbruin](#comment%3A24):
> Replying to [SimonKing](#comment%3A23):
> > So, it is really the question: How can I (temporarily) force Python-3 to interpret a pickled string as bytes?

> 
> It looks like other people have run into this problem:
> 
> https://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3


I was wondering about one of the approaches mentioned there: within Python 2, unpickle the data, then save it in a format which can be read by Python 3, or ideally, read by both Python 2 and 3.



---

archive/issue_comments_552828.json:
```json
{
    "body": "<a id='comment:26'></a>\nReplying to [jhpalmieri](#comment%3A25):\n> I was wondering about one of the approaches mentioned there: within Python 2, unpickle the data, then save it in a format which can be read by Python 3, or ideally, read by both Python 2 and 3.\n\n\nI think the main point here is to be able to solve it on the Py3 side: have a *BACKWARD* compatible solution. If we can work on both sides, there are plenty of work-arounds, for instance, write the data as JSON and parse that on the other side.\n\nThat said, I think this is another example that shows that we should be serious about keeping VMs of a reasonable spread of sage versions -- people might end up needing them for data archaeology.\n(do we do this already? I know VMs get produced for a lot of releases; archiving them would just be a matter of resources.",
    "created_at": "2019-09-03T03:57:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552828",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:26'></a>
Replying to [jhpalmieri](#comment%3A25):
> I was wondering about one of the approaches mentioned there: within Python 2, unpickle the data, then save it in a format which can be read by Python 3, or ideally, read by both Python 2 and 3.


I think the main point here is to be able to solve it on the Py3 side: have a *BACKWARD* compatible solution. If we can work on both sides, there are plenty of work-arounds, for instance, write the data as JSON and parse that on the other side.

That said, I think this is another example that shows that we should be serious about keeping VMs of a reasonable spread of sage versions -- people might end up needing them for data archaeology.
(do we do this already? I know VMs get produced for a lot of releases; archiving them would just be a matter of resources.



---

archive/issue_comments_552829.json:
```json
{
    "body": "<a id='comment:27'></a>\nReplying to [nbruin](#comment%3A26):\n> Replying to [jhpalmieri](#comment%3A25):\n> > I was wondering about one of the approaches mentioned there: within Python 2, unpickle the data, then save it in a format which can be read by Python 3, or ideally, read by both Python 2 and 3.\n\n> \n> I think the main point here is to be able to solve it on the Py3 side: have a *BACKWARD* compatible solution.\n\n\nRight, sorry, I was thinking about the immediate problem of the data in the p-group cohomology package. Simon, maybe it's the right time to change the format of the saved data?",
    "created_at": "2019-09-03T05:09:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552829",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:27'></a>
Replying to [nbruin](#comment%3A26):
> Replying to [jhpalmieri](#comment%3A25):
> > I was wondering about one of the approaches mentioned there: within Python 2, unpickle the data, then save it in a format which can be read by Python 3, or ideally, read by both Python 2 and 3.

> 
> I think the main point here is to be able to solve it on the Py3 side: have a *BACKWARD* compatible solution.


Right, sorry, I was thinking about the immediate problem of the data in the p-group cohomology package. Simon, maybe it's the right time to change the format of the saved data?



---

archive/issue_comments_552830.json:
```json
{
    "body": "<a id='comment:28'></a>\nReplying to [jhpalmieri](#comment%3A27):\n> Replying to [nbruin](#comment%3A26):\n> > I think the main point here is to be able to solve it on the Py3 side: have a *BACKWARD* compatible solution.\n\n\nIndeed, that's what I want to achieve here.\n \n> Right, sorry, I was thinking about the immediate problem of the data in the p-group cohomology package. Simon, maybe it's the right time to change the format of the saved data?\n\n\nAs I have demonstrated above, a pickle created with Python-3 can be read both with Python-2 and Python-3. So, that side of the problem isn't really urgent for the p_group_cohomology package, I think. \n\nHowever, I'd like to understand\n- why the Python-3 pickle is 25% larger than the Python-2 pickle, and\n- why pickling bytes in Python-3 is apparently more involved than pickling a string, even though to my understanding a string is something more complicated, as it needs to be interpreted by some encoding. That's to say: Why is `b'\\x80\\x1f'` not pickled as `b'\\x80\\x1f'` but as\n\n  ```\npg_encode = unpickle_global('_codecs', 'encode')\npg_encode('\\x80\\x1f', 'latin1')\n  ```\n  My expectation actually was that `bytes` is a more basic data type than `str`, as the latter needs to know how it is interpreted (utf-8? isolatin-1? etc.)",
    "created_at": "2019-09-03T05:56:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552830",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:28'></a>
Replying to [jhpalmieri](#comment%3A27):
> Replying to [nbruin](#comment%3A26):
> > I think the main point here is to be able to solve it on the Py3 side: have a *BACKWARD* compatible solution.


Indeed, that's what I want to achieve here.
 
> Right, sorry, I was thinking about the immediate problem of the data in the p-group cohomology package. Simon, maybe it's the right time to change the format of the saved data?


As I have demonstrated above, a pickle created with Python-3 can be read both with Python-2 and Python-3. So, that side of the problem isn't really urgent for the p_group_cohomology package, I think. 

However, I'd like to understand
- why the Python-3 pickle is 25% larger than the Python-2 pickle, and
- why pickling bytes in Python-3 is apparently more involved than pickling a string, even though to my understanding a string is something more complicated, as it needs to be interpreted by some encoding. That's to say: Why is `b'\x80\x1f'` not pickled as `b'\x80\x1f'` but as

  ```
pg_encode = unpickle_global('_codecs', 'encode')
pg_encode('\x80\x1f', 'latin1')
  ```
  My expectation actually was that `bytes` is a more basic data type than `str`, as the latter needs to know how it is interpreted (utf-8? isolatin-1? etc.)



---

archive/issue_comments_552831.json:
```json
{
    "body": "<a id='comment:29'></a>\nReplying to [nbruin](#comment%3A24):\n> It looks like other people have run into this problem:\n> \n> https://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3\n\n\nThank you! The recommended solution is\n\n```python\nwith open(mshelffile, 'rb') as f:\n    d = pickle.load(f, encoding='bytes')\n```\nHowever, Sage's `load` apparently doesn't know about the encoding keyword. So, I suggest the solution to add an `encoding` keyword to appropriate places in `sage.misc.persist`; that keyword should just be ignored in Python-2 (as apparently Python-2 doesn't support it) and passed to the `pickle` module in Python-3.\n\nIf you agree that the approach makes sense, I'll change the ticket description accordingly.",
    "created_at": "2019-09-03T06:05:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552831",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:29'></a>
Replying to [nbruin](#comment%3A24):
> It looks like other people have run into this problem:
> 
> https://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3


Thank you! The recommended solution is

```python
with open(mshelffile, 'rb') as f:
    d = pickle.load(f, encoding='bytes')
```
However, Sage's `load` apparently doesn't know about the encoding keyword. So, I suggest the solution to add an `encoding` keyword to appropriate places in `sage.misc.persist`; that keyword should just be ignored in Python-2 (as apparently Python-2 doesn't support it) and passed to the `pickle` module in Python-3.

If you agree that the approach makes sense, I'll change the ticket description accordingly.



---

archive/issue_comments_552832.json:
```json
{
    "body": "**Changing keywords** from \"unpickling UnicodeError meataxe\" to \"unpickling UnicodeError backwards compatibility\".",
    "created_at": "2019-09-03T06:15:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552832",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing keywords** from "unpickling UnicodeError meataxe" to "unpickling UnicodeError backwards compatibility".



---

archive/issue_comments_552833.json:
```json
{
    "body": "<a id='comment:30'></a>\nI just checked: When I `pickle.dump('\\x80\\x1f', <file>)` with either Python-2 or Python-3, then I can `pickle.load(<file>, encoding=bytes)` in Python-3 and can `pickle.load(<file>)` in Python-2. So, that looks like backwards and forwards compatibility to me.\n\nAlso we see in the stackoverflow thread that the problem really isn't related with our optional meataxe or p_groupcohomology modules. Therefore I remove the keyword from the ticket description.",
    "created_at": "2019-09-03T06:15:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552833",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:30'></a>
I just checked: When I `pickle.dump('\x80\x1f', <file>)` with either Python-2 or Python-3, then I can `pickle.load(<file>, encoding=bytes)` in Python-3 and can `pickle.load(<file>)` in Python-2. So, that looks like backwards and forwards compatibility to me.

Also we see in the stackoverflow thread that the problem really isn't related with our optional meataxe or p_groupcohomology modules. Therefore I remove the keyword from the ticket description.



---

archive/issue_comments_552834.json:
```json
{
    "body": "<a id='comment:31'></a>\nI would also suggest to understand where this non-ascii string comes from in your example pickles, and fix the responsible of that to use instead unicode strings. This '\\x80\\x1f' may be related to the empty-set symbol, but I am not sure.",
    "created_at": "2019-09-03T06:31:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552834",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:31'></a>
I would also suggest to understand where this non-ascii string comes from in your example pickles, and fix the responsible of that to use instead unicode strings. This '\x80\x1f' may be related to the empty-set symbol, but I am not sure.



---

archive/issue_comments_552835.json:
```json
{
    "body": "<a id='comment:32'></a>\nReplying to [chapoton](#comment%3A31):\n> I would also suggest to understand where this non-ascii string comes from in your example pickles, and fix the responsible of that to use instead unicode strings.\n\n\nThis already is understood. '\\x80\\x1f' is `bytes` corresponding to the data of some meataxe matrix. It really *is* a bytes (see line 528 in src/sage/matrix/matrix_gfpn_dense.pyx! It SHOULDN'T be a unicode string. And the problem is that Python-3 tries to erroneously read it as unicode string, when it encounters it in a Python-2 pickle.\n\nOstensibly, it is the case that Python-2 str corresponds to Python-3 bytes, and Python-2 unicode corresponds to Python-3 str. But apparently Python-3 tries to unpickle a Python-2 str as unicode, and that's a bug (in Python, not in Sage), IMHO. Example:\n\n```python\nking@klap:~$ ~/Sage/git/sage/sage -python\nPython 2.7.15 (default, Jul 26 2019, 11:49:43) \n[GCC 5.4.0 20160609] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import pickle\n>>> with open('bla', 'wb') as f:\n...     pickle.dump(('\\x80\\x1f', u'\\x80\\x1f'), f)\n... \n>>> \nking@klap:~$ ~/Sage/git/py3/sage -python\nPython 3.7.3 (default, Aug 27 2019, 23:22:23) \n[GCC 5.4.0 20160609] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import pickle\n>>> with open('bla', 'rb') as f:\n...     pickle.load(f)\n... \nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nUnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)\n>>> with open('bla', 'rb') as f:\n...     X = pickle.load(f, encoding='bytes')\n... \n>>> X\n(b'\\x80\\x1f', '\\x80\\x1f')\n```\nNote that according to the stackoverflow thread, the same problem would also arise when you pickle a Python-2 dictionary whose keys are Python-2 strings, and then unpickle in Python-3. It isn't an exotic problem that is in any way caused by a Sage (optional) package.",
    "created_at": "2019-09-03T06:46:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552835",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:32'></a>
Replying to [chapoton](#comment%3A31):
> I would also suggest to understand where this non-ascii string comes from in your example pickles, and fix the responsible of that to use instead unicode strings.


This already is understood. '\x80\x1f' is `bytes` corresponding to the data of some meataxe matrix. It really *is* a bytes (see line 528 in src/sage/matrix/matrix_gfpn_dense.pyx! It SHOULDN'T be a unicode string. And the problem is that Python-3 tries to erroneously read it as unicode string, when it encounters it in a Python-2 pickle.

Ostensibly, it is the case that Python-2 str corresponds to Python-3 bytes, and Python-2 unicode corresponds to Python-3 str. But apparently Python-3 tries to unpickle a Python-2 str as unicode, and that's a bug (in Python, not in Sage), IMHO. Example:

```python
king@klap:~$ ~/Sage/git/sage/sage -python
Python 2.7.15 (default, Jul 26 2019, 11:49:43) 
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import pickle
>>> with open('bla', 'wb') as f:
...     pickle.dump(('\x80\x1f', u'\x80\x1f'), f)
... 
>>> 
king@klap:~$ ~/Sage/git/py3/sage -python
Python 3.7.3 (default, Aug 27 2019, 23:22:23) 
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import pickle
>>> with open('bla', 'rb') as f:
...     pickle.load(f)
... 
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0: ordinal not in range(128)
>>> with open('bla', 'rb') as f:
...     X = pickle.load(f, encoding='bytes')
... 
>>> X
(b'\x80\x1f', '\x80\x1f')
```
Note that according to the stackoverflow thread, the same problem would also arise when you pickle a Python-2 dictionary whose keys are Python-2 strings, and then unpickle in Python-3. It isn't an exotic problem that is in any way caused by a Sage (optional) package.



---

archive/issue_comments_552836.json:
```json
{
    "body": "<a id='comment:33'></a>\nPS:\n\n```python\nking@klap:~$ ~/Sage/git/py3/sage -python\nPython 3.7.3 (default, Aug 27 2019, 23:22:23) \n[GCC 5.4.0 20160609] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import pickle\n>>> with open('bla', 'wb') as f:\n...     pickle.dump(('\\x80\\x1f', b'\\x80\\x1f'), f)\n... \n>>> \nking@klap:~$ ~/Sage/git/py3/sage -python\nPython 3.7.3 (default, Aug 27 2019, 23:22:23) \n[GCC 5.4.0 20160609] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import pickle\n>>> with open('bla', 'rb') as f:\n...     X = pickle.load(f)\n... \n>>> X\n('\\x80\\x1f', b'\\x80\\x1f')\n>>> with open('bla', 'rb') as f:\n...     X = pickle.load(f, encoding='bytes')\n... \n>>> X\n('\\x80\\x1f', b'\\x80\\x1f')\n```\nSo, the types of a Python-3 pickle are still correct when unpickling them with the `encode='bytes'` keyword.",
    "created_at": "2019-09-03T06:54:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552836",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:33'></a>
PS:

```python
king@klap:~$ ~/Sage/git/py3/sage -python
Python 3.7.3 (default, Aug 27 2019, 23:22:23) 
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import pickle
>>> with open('bla', 'wb') as f:
...     pickle.dump(('\x80\x1f', b'\x80\x1f'), f)
... 
>>> 
king@klap:~$ ~/Sage/git/py3/sage -python
Python 3.7.3 (default, Aug 27 2019, 23:22:23) 
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import pickle
>>> with open('bla', 'rb') as f:
...     X = pickle.load(f)
... 
>>> X
('\x80\x1f', b'\x80\x1f')
>>> with open('bla', 'rb') as f:
...     X = pickle.load(f, encoding='bytes')
... 
>>> X
('\x80\x1f', b'\x80\x1f')
```
So, the types of a Python-3 pickle are still correct when unpickling them with the `encode='bytes'` keyword.



---

archive/issue_comments_552837.json:
```json
{
    "body": "<a id='comment:34'></a>\nArgh. It is of course possible to pass the `encoding` keyword to the pickle module. But then, things fail because of things like\n\n```python\n    if '.' in name:\n        module, name = name.rsplit('.', 1)\n        all = __import__(module, fromlist=[name])\n```\nin `sage.structure.factory.unpickle_global`: `name` should be a string, but is bytes when using `encoding='bytes'` (whereas '.' still is a string).",
    "created_at": "2019-09-03T18:31:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552837",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:34'></a>
Argh. It is of course possible to pass the `encoding` keyword to the pickle module. But then, things fail because of things like

```python
    if '.' in name:
        module, name = name.rsplit('.', 1)
        all = __import__(module, fromlist=[name])
```
in `sage.structure.factory.unpickle_global`: `name` should be a string, but is bytes when using `encoding='bytes'` (whereas '.' still is a string).



---

archive/issue_comments_552838.json:
```json
{
    "body": "<a id='comment:35'></a>\nDoes the function `bytes_to_str` (from `sage.cpython.string`) help? The docstring:\n\n```\n    Convert ``bytes`` to ``str``.\n\n    On Python 2 this is a no-op since ``bytes is str``.  On Python 3\n    this decodes the given ``bytes`` to a Python 3 unicode ``str`` using\n    the specified encoding.\n```\nYou could apply that to `name`.",
    "created_at": "2019-09-03T18:36:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552838",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:35'></a>
Does the function `bytes_to_str` (from `sage.cpython.string`) help? The docstring:

```
    Convert ``bytes`` to ``str``.

    On Python 2 this is a no-op since ``bytes is str``.  On Python 3
    this decodes the given ``bytes`` to a Python 3 unicode ``str`` using
    the specified encoding.
```
You could apply that to `name`.



---

archive/issue_comments_552839.json:
```json
{
    "body": "<a id='comment:36'></a>\nReplying to [jhpalmieri](#comment%3A35):\n> Does the function `bytes_to_str` (from `sage.cpython.string`) help?\n\n\nYes, but currently it seems that I am just opening a can of worms. The error that I'm getting next:\n\n```\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/rings/integer.pyx in sage.rings.integer.make_integer (build/cythonized/sage/rings/integer.c:43277)()\n   7220     \"\"\"\n   7221     cdef Integer r = PY_NEW(Integer)\n-> 7222     mpz_set_str(r.value, str_to_bytes(s), 32)\n   7223     return r\n   7224 \n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/cpython/string.pxd in sage.cpython.string.str_to_bytes (build/cythonized/sage/rings/integer.c:47648)()\n     90     # compile-time variable. We keep the Cython wrapper to deal with\n     91     # the default arguments.\n---> 92     return _str_to_bytes(s, encoding, errors)\n\nTypeError: expected str, bytes found\n```\n\nSo, summary: In many places, python-3 really uses str in the same way as python-2 was using str. Hence, it *does* make sense to unpickle a python-2 str as a python-3 string. However, in other situations, we really want and need that a python-2 str unpickles as a python-3 bytes, because in python-2 `str is bytes`.\n\nAnd that really makes everything complicated.",
    "created_at": "2019-09-03T19:25:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552839",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:36'></a>
Replying to [jhpalmieri](#comment%3A35):
> Does the function `bytes_to_str` (from `sage.cpython.string`) help?


Yes, but currently it seems that I am just opening a can of worms. The error that I'm getting next:

```
/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/rings/integer.pyx in sage.rings.integer.make_integer (build/cythonized/sage/rings/integer.c:43277)()
   7220     """
   7221     cdef Integer r = PY_NEW(Integer)
-> 7222     mpz_set_str(r.value, str_to_bytes(s), 32)
   7223     return r
   7224 

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/cpython/string.pxd in sage.cpython.string.str_to_bytes (build/cythonized/sage/rings/integer.c:47648)()
     90     # compile-time variable. We keep the Cython wrapper to deal with
     91     # the default arguments.
---> 92     return _str_to_bytes(s, encoding, errors)

TypeError: expected str, bytes found
```

So, summary: In many places, python-3 really uses str in the same way as python-2 was using str. Hence, it *does* make sense to unpickle a python-2 str as a python-3 string. However, in other situations, we really want and need that a python-2 str unpickles as a python-3 bytes, because in python-2 `str is bytes`.

And that really makes everything complicated.



---

archive/issue_comments_552840.json:
```json
{
    "body": "<a id='comment:37'></a>\nReplying to [SimonKing](#comment%3A36):\n> So, summary: In many places, python-3 really uses str in the same way as python-2 was using str. Hence, it *does* make sense to unpickle a python-2 str as a python-3 string. However, in other situations, we really want and need that a python-2 str unpickles as a python-3 bytes, because in python-2 `str is bytes`.\n\n\nThat would indicate we need a heuristic. We might have to patch [pickle._decode_string](https://github.com/python/cpython/blob/ea21389dda401457198fb214aa2c981a45ed9528/Lib/pickle.py#L1197): perhaps have another pseudo-encoding \"ascii_or_bytes\" which decodes via ascii to a unicode string if possible and otherwise returns a bytes object.\n\nAnother option is to decode with 'latin-1' to always get a unicode string, but it's already documented that that breaks stuff as well. So it seems we would need to try and break things in as few cases as possible ...",
    "created_at": "2019-09-03T21:14:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552840",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:37'></a>
Replying to [SimonKing](#comment%3A36):
> So, summary: In many places, python-3 really uses str in the same way as python-2 was using str. Hence, it *does* make sense to unpickle a python-2 str as a python-3 string. However, in other situations, we really want and need that a python-2 str unpickles as a python-3 bytes, because in python-2 `str is bytes`.


That would indicate we need a heuristic. We might have to patch [pickle._decode_string](https://github.com/python/cpython/blob/ea21389dda401457198fb214aa2c981a45ed9528/Lib/pickle.py#L1197): perhaps have another pseudo-encoding "ascii_or_bytes" which decodes via ascii to a unicode string if possible and otherwise returns a bytes object.

Another option is to decode with 'latin-1' to always get a unicode string, but it's already documented that that breaks stuff as well. So it seems we would need to try and break things in as few cases as possible ...



---

archive/issue_comments_552841.json:
```json
{
    "body": "<a id='comment:38'></a>\nReplying to [nbruin](#comment%3A37):\n> That would indicate we need a heuristic. We might have to patch [pickle._decode_string](https://github.com/python/cpython/blob/ea21389dda401457198fb214aa2c981a45ed9528/Lib/pickle.py#L1197): perhaps have another pseudo-encoding \"ascii_or_bytes\" which decodes via ascii to a unicode string if possible and otherwise returns a bytes object.\n> \n> Another option is to decode with 'latin-1' to always get a unicode string, but it's already documented that that breaks stuff as well. \n\n\n\"Break\" in what sense?\n\nThere are two types of problems we encounter when pickling:\n1. Unpickling of objects of basic python types results in an error, thus, unpickling aborts before a call to code from the Sage library is involved.\n2. Unpickling of objects of basic python types is faulty but without raising an error, thus, code from the Sage library is called with incorrect input.\n\nProblems of type 1. are very bad, because unpickling fails before our Sage library code even has a chance to get things right. Therefore we should try to make it so that problems of type 1. are strictly avoided.\n\nProblems of type 2. can at least in principal be fixed by changes to the Sage library. So, they are less critical. Let us focus on the bytes versus str problem.\n\nIf we use `encoding='bytes'`, then all python-2 str are unpickled as bytes. And that breaks *lots and lots* of things, such as looking up functions in the global namespace by their function name (function names must be str, not bytes). So, I believe this is no option.\n\nWhat if we use `encoding='latin1'`? Is it guaranteed that if `b` is a bytes then `b.decode('latin1')` yields a str (without raising an error) and that `b.decode('latin1').encode('latin1') == b`? I tested that it is the case at least in some example, in which other encodings fail:\n\n```\nsage: b = b'\\x80\\x1f'\nsage: b.decode('utf-16').encode('utf-16') == b\nFalse\nsage: b.decode('utf-8').encode('utf-8') == b\n---------------------------------------------------------------------------\nUnicodeDecodeError                        Traceback (most recent call last)\n<ipython-input-130-7e0e96195e1e> in <module>()\n----> 1 b.decode('utf-8').encode('utf-8') == b\n\nUnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0: invalid start byte\nsage: b.decode('latin1').encode('latin1') == b\nTrue\n```\nIf the answer to the question generally is \"yes, it is guaranteed\", then the natural approach would be: Whenever a Sage function or method expects an input of type bytes but encounters str, then the str should be encoded to a bytes with encoding 'latin1'.\n\nThe price to pay: The automatic conversion may be fine during unpickling, but may be unwanted in all other situations.\n\nI wonder how feasible this would be.",
    "created_at": "2019-09-03T22:35:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552841",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:38'></a>
Replying to [nbruin](#comment%3A37):
> That would indicate we need a heuristic. We might have to patch [pickle._decode_string](https://github.com/python/cpython/blob/ea21389dda401457198fb214aa2c981a45ed9528/Lib/pickle.py#L1197): perhaps have another pseudo-encoding "ascii_or_bytes" which decodes via ascii to a unicode string if possible and otherwise returns a bytes object.
> 
> Another option is to decode with 'latin-1' to always get a unicode string, but it's already documented that that breaks stuff as well. 


"Break" in what sense?

There are two types of problems we encounter when pickling:
1. Unpickling of objects of basic python types results in an error, thus, unpickling aborts before a call to code from the Sage library is involved.
2. Unpickling of objects of basic python types is faulty but without raising an error, thus, code from the Sage library is called with incorrect input.

Problems of type 1. are very bad, because unpickling fails before our Sage library code even has a chance to get things right. Therefore we should try to make it so that problems of type 1. are strictly avoided.

Problems of type 2. can at least in principal be fixed by changes to the Sage library. So, they are less critical. Let us focus on the bytes versus str problem.

If we use `encoding='bytes'`, then all python-2 str are unpickled as bytes. And that breaks *lots and lots* of things, such as looking up functions in the global namespace by their function name (function names must be str, not bytes). So, I believe this is no option.

What if we use `encoding='latin1'`? Is it guaranteed that if `b` is a bytes then `b.decode('latin1')` yields a str (without raising an error) and that `b.decode('latin1').encode('latin1') == b`? I tested that it is the case at least in some example, in which other encodings fail:

```
sage: b = b'\x80\x1f'
sage: b.decode('utf-16').encode('utf-16') == b
False
sage: b.decode('utf-8').encode('utf-8') == b
---------------------------------------------------------------------------
UnicodeDecodeError                        Traceback (most recent call last)
<ipython-input-130-7e0e96195e1e> in <module>()
----> 1 b.decode('utf-8').encode('utf-8') == b

UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0: invalid start byte
sage: b.decode('latin1').encode('latin1') == b
True
```
If the answer to the question generally is "yes, it is guaranteed", then the natural approach would be: Whenever a Sage function or method expects an input of type bytes but encounters str, then the str should be encoded to a bytes with encoding 'latin1'.

The price to pay: The automatic conversion may be fine during unpickling, but may be unwanted in all other situations.

I wonder how feasible this would be.



---

archive/issue_comments_552842.json:
```json
{
    "body": "<a id='comment:39'></a>\nReplying to [SimonKing](#comment%3A38):\n> What if we use `encoding='latin1'`? Is it guaranteed that if `b` is a bytes then `b.decode('latin1')` yields a str (without raising an error) and that `b.decode('latin1').encode('latin1') == b`?\n\n\nYes!!\n\n```\nsage: all_bytes = bytearray(range(0x100)); all_bytes.decode('latin1').encode('latin1') == all_bytes\nTrue\n```\nGood news.\n\nIs there a way to temporarily (i.e., during unpickling) set the default encoding to `latin1`, so that `cdef bytes x = s` where `s` is a string will automatically use latin1-encoding? This may already fix some cases.",
    "created_at": "2019-09-03T22:47:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552842",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:39'></a>
Replying to [SimonKing](#comment%3A38):
> What if we use `encoding='latin1'`? Is it guaranteed that if `b` is a bytes then `b.decode('latin1')` yields a str (without raising an error) and that `b.decode('latin1').encode('latin1') == b`?


Yes!!

```
sage: all_bytes = bytearray(range(0x100)); all_bytes.decode('latin1').encode('latin1') == all_bytes
True
```
Good news.

Is there a way to temporarily (i.e., during unpickling) set the default encoding to `latin1`, so that `cdef bytes x = s` where `s` is a string will automatically use latin1-encoding? This may already fix some cases.



---

archive/issue_comments_552843.json:
```json
{
    "body": "<a id='comment:40'></a>\nReplying to [SimonKing](#comment%3A38):\n> > Another option is to decode with 'latin-1' to always get a unicode string, but it's already documented that that breaks stuff as well. \n\n> \n> \"Break\" in what sense?\n\n\nat the [stackoverflow mentioned before](https://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3) it's mentioned that `encoding='latin1'` breaks unpickling of numpy arrays, which is used as motivation that `encoding='bytes'` would be better. That's obviously not uniformly the case, as you're encountering.\n\nRoundtrip invariance is definitely guaranteed by latin1: it's just a 1-1 mapping between byte values and characters (in fact, the first 256 unicode code-points. If 0 can count as a code point).\n\nBad news: the [cython documentation](https://cython.readthedocs.io/en/latest/src/tutorial/strings.html) suggests that cython's string conversion encodings are determined (from cython 0.19) by compile-time directives.",
    "created_at": "2019-09-04T00:24:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552843",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:40'></a>
Replying to [SimonKing](#comment%3A38):
> > Another option is to decode with 'latin-1' to always get a unicode string, but it's already documented that that breaks stuff as well. 

> 
> "Break" in what sense?


at the [stackoverflow mentioned before](https://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3) it's mentioned that `encoding='latin1'` breaks unpickling of numpy arrays, which is used as motivation that `encoding='bytes'` would be better. That's obviously not uniformly the case, as you're encountering.

Roundtrip invariance is definitely guaranteed by latin1: it's just a 1-1 mapping between byte values and characters (in fact, the first 256 unicode code-points. If 0 can count as a code point).

Bad news: the [cython documentation](https://cython.readthedocs.io/en/latest/src/tutorial/strings.html) suggests that cython's string conversion encodings are determined (from cython 0.19) by compile-time directives.



---

archive/issue_comments_552844.json:
```json
{
    "body": "<a id='comment:41'></a>\nReplying to [nbruin](#comment%3A40):\n> at the [stackoverflow mentioned before](https://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3) it's mentioned that `encoding='latin1'` breaks unpickling of numpy arrays, which is used as motivation that `encoding='bytes'` would be better. That's obviously not uniformly the case, as you're encountering.\n\n\nIn the thread, I see mentioned that \"Using encoding = 'latin1' causes some issues when your object contains numpy arrays in it.\" However, I don't see an explicit example or an explanation what these issues are.",
    "created_at": "2019-09-04T01:06:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552844",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:41'></a>
Replying to [nbruin](#comment%3A40):
> at the [stackoverflow mentioned before](https://stackoverflow.com/questions/28218466/unpickling-a-python-2-object-with-python-3) it's mentioned that `encoding='latin1'` breaks unpickling of numpy arrays, which is used as motivation that `encoding='bytes'` would be better. That's obviously not uniformly the case, as you're encountering.


In the thread, I see mentioned that "Using encoding = 'latin1' causes some issues when your object contains numpy arrays in it." However, I don't see an explicit example or an explanation what these issues are.



---

archive/issue_comments_552845.json:
```json
{
    "body": "<a id='comment:42'></a>\nReplying to [SimonKing](#comment%3A41):\n> In the thread, I see mentioned that \"Using encoding = 'latin1' causes some issues when your object contains numpy arrays in it.\" However, I don't see an explicit example or an explanation what these issues are.\n\n\nOne quote:\n\nNote that up to Python versions before 3.6.8, 3.7.2 and 3.8.0, unpickling of Python 2 datetime object data is broken unless you use encoding='bytes'.\n\n(linking to [Python issue 22005](https://bugs.python.org/issue22005). The issue is an interesting read, displaying a similar spread of attitudes among core Python developers as we have seen on sage-devel. In the end a fix was accepted in Python, so some willingness to consider compatibility for pickles between python versions (especially 2/3) does exist.)\n\nThis could be what the advice was about (since numpy arrays in pandas applications are quite prone to containing datetimes)\n\nThe [numpy.load](https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.load.html) command accepts an encoding (for passing to pickle) and enforces it to be `ascii`, `latin1`, or `bytes` to avoid corrupting numerical data.\n\nThere is a [numpy issue](https://github.com/numpy/numpy/issues/4879) about this as well, which seems to be resolved.\n\nThe main thing I seem to find here: `datetime` had a problem with pickle `encoding=latin1` prior to 3.9. Otherwise, `bytes` seems to cause various problems. So from this search it seems to me going with `latin1` might indeed be the better default.",
    "created_at": "2019-09-04T03:53:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552845",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:42'></a>
Replying to [SimonKing](#comment%3A41):
> In the thread, I see mentioned that "Using encoding = 'latin1' causes some issues when your object contains numpy arrays in it." However, I don't see an explicit example or an explanation what these issues are.


One quote:

Note that up to Python versions before 3.6.8, 3.7.2 and 3.8.0, unpickling of Python 2 datetime object data is broken unless you use encoding='bytes'.

(linking to [Python issue 22005](https://bugs.python.org/issue22005). The issue is an interesting read, displaying a similar spread of attitudes among core Python developers as we have seen on sage-devel. In the end a fix was accepted in Python, so some willingness to consider compatibility for pickles between python versions (especially 2/3) does exist.)

This could be what the advice was about (since numpy arrays in pandas applications are quite prone to containing datetimes)

The [numpy.load](https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.load.html) command accepts an encoding (for passing to pickle) and enforces it to be `ascii`, `latin1`, or `bytes` to avoid corrupting numerical data.

There is a [numpy issue](https://github.com/numpy/numpy/issues/4879) about this as well, which seems to be resolved.

The main thing I seem to find here: `datetime` had a problem with pickle `encoding=latin1` prior to 3.9. Otherwise, `bytes` seems to cause various problems. So from this search it seems to me going with `latin1` might indeed be the better default.



---

archive/issue_comments_552846.json:
```json
{
    "body": "<a id='comment:43'></a>\nReplying to [nbruin](#comment%3A42):\n> One quote:\n> \n> Note that up to Python versions before 3.6.8, 3.7.2 and 3.8.0, unpickling of Python 2 datetime object data is broken unless you use encoding='bytes'.\n> ...\n> This could be what the advice was about (since numpy arrays in pandas applications are quite prone to containing datetimes)\n> \n> The [numpy.load](https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.load.html) command accepts an encoding (for passing to pickle) and enforces it to be `ascii`, `latin1`, or `bytes` to avoid corrupting numerical data.\n\n>\n> There is a [numpy issue](https://github.com/numpy/numpy/issues/4879) about this as well, which seems to be resolved.\n\n\nIn a version that is in Sage?\n \n> The main thing I seem to find here: `datetime` had a problem with pickle `encoding=latin1` prior to 3.9.\n\n\nWe *are* prior to 3.9 (the current Py-3 version is 3.8 in Sage).\n\n> Otherwise, `bytes` seems to cause various problems. So from this search it seems to me going with `latin1` might indeed be the better default.\n\n\nOf course we should have a default, but most importantly is that we allow the user to specify all optional arguments to `load/dump` that are accepted by `pickle.load/pickle.dump`. Namely, in Python-2:\n\n```python\nPython 2.7.15 (default, Jul 26 2019, 11:49:43) \n[GCC 5.4.0 20160609] on linux2\n>>> import pickle, inspect\n>>> inspect.getargspec(pickle.load)\nArgSpec(args=['file'], varargs=None, keywords=None, defaults=None)\n>>> inspect.getargspec(pickle.dump)\nArgSpec(args=['obj', 'file', 'protocol'], varargs=None, keywords=None, defaults=(None,))\n```\nand in Python-3:\n\n```\nPython 3.7.3 (default, Aug 27 2019, 23:22:23) \n[GCC 5.4.0 20160609] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import pickle, inspect\n>>> inspect.getfullargspec(pickle.load)\nFullArgSpec(args=['file'], varargs=None, varkw=None, defaults=None, kwonlyargs=['fix_imports', 'encoding', 'errors'], kwonlydefaults={'fix_imports': True, 'encoding': 'ASCII', 'errors': 'strict'}, annotations={})\n>>> inspect.getfullargspec(pickle.dump)\nFullArgSpec(args=['obj', 'file', 'protocol'], varargs=None, varkw=None, defaults=(None,), kwonlyargs=['fix_imports'], kwonlydefaults={'fix_imports': True}, annotations={})\n```\nI wonder if we should be explicit (i.e., `def load(file, fix_imports=True, encoding='ASCII', errors='strict')`), which means that the code would depend on the Python language level, or implicit (i.e., `def load(file, **kwargs)`)?",
    "created_at": "2019-09-04T11:41:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552846",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:43'></a>
Replying to [nbruin](#comment%3A42):
> One quote:
> 
> Note that up to Python versions before 3.6.8, 3.7.2 and 3.8.0, unpickling of Python 2 datetime object data is broken unless you use encoding='bytes'.
> ...
> This could be what the advice was about (since numpy arrays in pandas applications are quite prone to containing datetimes)
> 
> The [numpy.load](https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.load.html) command accepts an encoding (for passing to pickle) and enforces it to be `ascii`, `latin1`, or `bytes` to avoid corrupting numerical data.

>
> There is a [numpy issue](https://github.com/numpy/numpy/issues/4879) about this as well, which seems to be resolved.


In a version that is in Sage?
 
> The main thing I seem to find here: `datetime` had a problem with pickle `encoding=latin1` prior to 3.9.


We *are* prior to 3.9 (the current Py-3 version is 3.8 in Sage).

> Otherwise, `bytes` seems to cause various problems. So from this search it seems to me going with `latin1` might indeed be the better default.


Of course we should have a default, but most importantly is that we allow the user to specify all optional arguments to `load/dump` that are accepted by `pickle.load/pickle.dump`. Namely, in Python-2:

```python
Python 2.7.15 (default, Jul 26 2019, 11:49:43) 
[GCC 5.4.0 20160609] on linux2
>>> import pickle, inspect
>>> inspect.getargspec(pickle.load)
ArgSpec(args=['file'], varargs=None, keywords=None, defaults=None)
>>> inspect.getargspec(pickle.dump)
ArgSpec(args=['obj', 'file', 'protocol'], varargs=None, keywords=None, defaults=(None,))
```
and in Python-3:

```
Python 3.7.3 (default, Aug 27 2019, 23:22:23) 
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import pickle, inspect
>>> inspect.getfullargspec(pickle.load)
FullArgSpec(args=['file'], varargs=None, varkw=None, defaults=None, kwonlyargs=['fix_imports', 'encoding', 'errors'], kwonlydefaults={'fix_imports': True, 'encoding': 'ASCII', 'errors': 'strict'}, annotations={})
>>> inspect.getfullargspec(pickle.dump)
FullArgSpec(args=['obj', 'file', 'protocol'], varargs=None, varkw=None, defaults=(None,), kwonlyargs=['fix_imports'], kwonlydefaults={'fix_imports': True}, annotations={})
```
I wonder if we should be explicit (i.e., `def load(file, fix_imports=True, encoding='ASCII', errors='strict')`), which means that the code would depend on the Python language level, or implicit (i.e., `def load(file, **kwargs)`)?



---

archive/issue_comments_552847.json:
```json
{
    "body": "<a id='comment:44'></a>\nIn this comment, I'm trying to summarise the different approaches. Please add if I omit or misrepresent something.\n\n- Sage's pickling and unpickling functions (save, load, dumps, loads) should accept optional arguments. These should be passed to `SageUnpickler.__init__` and `SagePickler.__init__`; I think this is uncontroversial. Only question: explicit or implicit, as asked in[comment:43](#comment%3A43).\n\n- Should the `encoding` keyword get a default in Sage? Actually I am not sure if it should! But probably it should, and we should consider it a bug if a Sage object pickled with Python-2 cannot be unpickled with Python-3.\n\nIf we decide to have `encoding` with a default:\n- `encoding='bytes'` means that unpickling will fail as soon as a function is looked up in some module, because the look-up is by function name, and the name is a `str`, not `bytes`. So, `bytes` is a very bad default, unless we modify `sage.structure.factory.lookup_global` so that it also accepts `bytes` in lieu of `str`. When this is fixed, each Sage function expecting a `str` needs to be changed so that it also accepts `bytes` and transforms it to `str` with encoding \"latin1\" (?), case-by-case.\n- `encoding='latin1'` will make it so that always the unpickler will be in a position to look up globals. However, each Sage function expecting a `bytes` needs to be changed so that it also accepts `str` and transforms it to `bytes` with encoding \"latin1\".\n\nWhich scenario would be the worse can of worms?I guess using strings to pickle objects is more common than using bytes (`sage.matrix.matrix_gfpn_dense` use bytes, but what else?). So, it seems the approach to use `latin1` will be easier *in the Sage library*.\n\nHowever, we also need to worry about non-Sage library objects that might occur as attributes of Sage library objects. Such as numpy arrays/datetime. Is there a hack to make unpickling of numpy arrays work even when latin1 is used? Or is bytes the only way out for them?",
    "created_at": "2019-09-04T12:39:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552847",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:44'></a>
In this comment, I'm trying to summarise the different approaches. Please add if I omit or misrepresent something.

- Sage's pickling and unpickling functions (save, load, dumps, loads) should accept optional arguments. These should be passed to `SageUnpickler.__init__` and `SagePickler.__init__`; I think this is uncontroversial. Only question: explicit or implicit, as asked in[comment:43](#comment%3A43).

- Should the `encoding` keyword get a default in Sage? Actually I am not sure if it should! But probably it should, and we should consider it a bug if a Sage object pickled with Python-2 cannot be unpickled with Python-3.

If we decide to have `encoding` with a default:
- `encoding='bytes'` means that unpickling will fail as soon as a function is looked up in some module, because the look-up is by function name, and the name is a `str`, not `bytes`. So, `bytes` is a very bad default, unless we modify `sage.structure.factory.lookup_global` so that it also accepts `bytes` in lieu of `str`. When this is fixed, each Sage function expecting a `str` needs to be changed so that it also accepts `bytes` and transforms it to `str` with encoding "latin1" (?), case-by-case.
- `encoding='latin1'` will make it so that always the unpickler will be in a position to look up globals. However, each Sage function expecting a `bytes` needs to be changed so that it also accepts `str` and transforms it to `bytes` with encoding "latin1".

Which scenario would be the worse can of worms?I guess using strings to pickle objects is more common than using bytes (`sage.matrix.matrix_gfpn_dense` use bytes, but what else?). So, it seems the approach to use `latin1` will be easier *in the Sage library*.

However, we also need to worry about non-Sage library objects that might occur as attributes of Sage library objects. Such as numpy arrays/datetime. Is there a hack to make unpickling of numpy arrays work even when latin1 is used? Or is bytes the only way out for them?



---

archive/issue_comments_552848.json:
```json
{
    "body": "<a id='comment:45'></a>\nPS: Another approach was mentioned, namely to patch the `pickle` module, so that it is guessed whether a pickled Py-2 str is unpickled as Py-3 str or bytes. But each heuristics to do so can fail on specific data, and in such cases we would still need to add appropriate conversion from str to bytes and from bytes to str to Sage library functions, to catch the cases in which the heuristics fails.",
    "created_at": "2019-09-04T12:42:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552848",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:45'></a>
PS: Another approach was mentioned, namely to patch the `pickle` module, so that it is guessed whether a pickled Py-2 str is unpickled as Py-3 str or bytes. But each heuristics to do so can fail on specific data, and in such cases we would still need to add appropriate conversion from str to bytes and from bytes to str to Sage library functions, to catch the cases in which the heuristics fails.



---

archive/issue_comments_552849.json:
```json
{
    "body": "<a id='comment:46'></a>\nHere is another aspect that we could consider:\n\n```\nsage: all_bytes = bytes(range(0x100))\nsage: len(dumps(all_bytes))\n410\nsage: len(dumps(all_bytes.decode(encoding='latin')))\n361\n```\nSo, it might actually be a good idea to NOT use bytes for pickles, but use str instead, when Python 3 is involved (I am slightly surprised, because I thought bytes objects are simpler than str objects and thus their pickle should be smaller, not larger).\n\nWhen we change pickle functions to switch from using bytes to using str, it would be the *corresponding* unpickling functions that should be changed to accept str instead of bytes to make Py-2 pickles useable in Py-3 with `encoding='latin1'`. That's another reason to choose the default `encoding='latin1'`.",
    "created_at": "2019-09-04T13:00:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552849",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:46'></a>
Here is another aspect that we could consider:

```
sage: all_bytes = bytes(range(0x100))
sage: len(dumps(all_bytes))
410
sage: len(dumps(all_bytes.decode(encoding='latin')))
361
```
So, it might actually be a good idea to NOT use bytes for pickles, but use str instead, when Python 3 is involved (I am slightly surprised, because I thought bytes objects are simpler than str objects and thus their pickle should be smaller, not larger).

When we change pickle functions to switch from using bytes to using str, it would be the *corresponding* unpickling functions that should be changed to accept str instead of bytes to make Py-2 pickles useable in Py-3 with `encoding='latin1'`. That's another reason to choose the default `encoding='latin1'`.



---

archive/issue_comments_552850.json:
```json
{
    "body": "<a id='comment:47'></a>\nReplying to [SimonKing](#comment%3A44):\n\n> - `encoding='latin1'` will make it so that always the unpickler will be in a position to look up globals. However, each Sage function expecting a `bytes` needs to be changed so that it also accepts `str` and transforms it to `bytes` with encoding \"latin1\".\n\n\nWe only need to do so at the time of unpickling, for backwards compatibility reasons (i.e., if we move to a python-3 only protocol in the future, the workaround can be turned off when unpickling at that protocol level). So instead of actually changing the (hopefully few) objects that have a \"bytes\" object in them to accept strings and interpret them with latin1 encoding, can we just register little wrappers in \"copyreg\" to do that decoding for us?\n\n> However, we also need to worry about non-Sage library objects that might occur as attributes of Sage library objects. Such as numpy arrays/datetime. Is there a hack to make unpickling of numpy arrays work even when latin1 is used? Or is bytes the only way out for them?\n\n\nBackport [Issue 22005](https://bugs.python.org/issue22005) from Python 3.9?\n\nIf the copyreg option is available, perhaps the following would be a workable, extendable solutions:\n- make sure `encoding` is available for sage's unpickler access\n- aim for \"latin1\" being the default, but let 'bytes' be an option for the (rare?) pickles that need it\n- solve a few cases needing 'bytes', using copyreg registered constructors, so that they also work with 'latin1'\n- document the process of writing these copyreg constructors so that it's relatively straightforward to do it when we discover other data types that need it.\n\nI think that gets us at least to a state where the \"blocker\" status of this ticket can be lifted, because there's a clear path to resolving this pickle incompatibility.\n\nTruth is: any data type that is not in a pickle jar that gets tested regularly will almost certainly not be supported for unpickling in the future. Backwards compatibility of pickle requires real and constant work as sage develops. Major overhauls particularly will be a huge problem, and in some cases (if we don't have a version attribute) there might already be pickles that are genuinely ambiguous in how they should be unpickled.",
    "created_at": "2019-09-04T15:56:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552850",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:47'></a>
Replying to [SimonKing](#comment%3A44):

> - `encoding='latin1'` will make it so that always the unpickler will be in a position to look up globals. However, each Sage function expecting a `bytes` needs to be changed so that it also accepts `str` and transforms it to `bytes` with encoding "latin1".


We only need to do so at the time of unpickling, for backwards compatibility reasons (i.e., if we move to a python-3 only protocol in the future, the workaround can be turned off when unpickling at that protocol level). So instead of actually changing the (hopefully few) objects that have a "bytes" object in them to accept strings and interpret them with latin1 encoding, can we just register little wrappers in "copyreg" to do that decoding for us?

> However, we also need to worry about non-Sage library objects that might occur as attributes of Sage library objects. Such as numpy arrays/datetime. Is there a hack to make unpickling of numpy arrays work even when latin1 is used? Or is bytes the only way out for them?


Backport [Issue 22005](https://bugs.python.org/issue22005) from Python 3.9?

If the copyreg option is available, perhaps the following would be a workable, extendable solutions:
- make sure `encoding` is available for sage's unpickler access
- aim for "latin1" being the default, but let 'bytes' be an option for the (rare?) pickles that need it
- solve a few cases needing 'bytes', using copyreg registered constructors, so that they also work with 'latin1'
- document the process of writing these copyreg constructors so that it's relatively straightforward to do it when we discover other data types that need it.

I think that gets us at least to a state where the "blocker" status of this ticket can be lifted, because there's a clear path to resolving this pickle incompatibility.

Truth is: any data type that is not in a pickle jar that gets tested regularly will almost certainly not be supported for unpickling in the future. Backwards compatibility of pickle requires real and constant work as sage develops. Major overhauls particularly will be a huge problem, and in some cases (if we don't have a version attribute) there might already be pickles that are genuinely ambiguous in how they should be unpickled.



---

archive/issue_comments_552851.json:
```json
{
    "body": "<a id='comment:48'></a>\nCan we do something like the following? Suppose we have an object as below. It's written without particular considerations for pickling and it uses both bytes and str, so on the Py3 side, we're hooped:\n\n```\nclass MixedObject(object):\n    def __init__(self,B,S):\n        if not(isinstance(B,bytes)):\n            raise TypeError(\"Parameter B must be of type bytes\")\n        if not(isinstance(S,str)):\n            raise TypeError(\"Parameter S must be ot type str\")\n        self.B=B\n        self.S=S\n    def validate(self):\n        if not(isinstance(self.B,bytes)):\n            raise TypeError(\"Parameter B must be of type bytes\")\n        if not(isinstance(self.S,str)):\n            raise TypeError(\"Parameter S must be ot type str\")\n        return True\n\nX=MixedObject(b\"hi\",\"there\")\n```\nThe pickle we get with `pickle.dumps(X)` from Py2 unpacks into Py3 into an object that doesn't validate. If we use `pickle.loads(X,encoding=\"bytes\")` we end up with an object that doesn't even have the required attributes (because the dictionary gets reconstructed with `bytes` keys).\n\nHowever, if we equip the object on the Py3 side with a `__setstate__`:\n\n```\n    def __setstate__(self,D):\n        if isinstance(D['B'],str):\n            self.B=D['B'].encode('latin1')\n        else:\n            self.B=D['B']\n        self.S=D['S']\n```\nwe can use `loads(...,encoding=\"latin1\")` and get an object that validates. So with a bit of luck, I think we can deal with most cases where we do need a `bytes` attribute with either use `copyreg` to register a custom reconstructor (when an object uses a `__reduce__`) that can preprocess construction parameters that are to be turned into `bytes` or by amending/adding `__setstate__` to use `encode('latin1')` on values that are supposed to be `bytes`.\n\nIt's a fairly painful process, but it should be doable entirely on the py3 side.",
    "created_at": "2019-09-04T21:06:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552851",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:48'></a>
Can we do something like the following? Suppose we have an object as below. It's written without particular considerations for pickling and it uses both bytes and str, so on the Py3 side, we're hooped:

```
class MixedObject(object):
    def __init__(self,B,S):
        if not(isinstance(B,bytes)):
            raise TypeError("Parameter B must be of type bytes")
        if not(isinstance(S,str)):
            raise TypeError("Parameter S must be ot type str")
        self.B=B
        self.S=S
    def validate(self):
        if not(isinstance(self.B,bytes)):
            raise TypeError("Parameter B must be of type bytes")
        if not(isinstance(self.S,str)):
            raise TypeError("Parameter S must be ot type str")
        return True

X=MixedObject(b"hi","there")
```
The pickle we get with `pickle.dumps(X)` from Py2 unpacks into Py3 into an object that doesn't validate. If we use `pickle.loads(X,encoding="bytes")` we end up with an object that doesn't even have the required attributes (because the dictionary gets reconstructed with `bytes` keys).

However, if we equip the object on the Py3 side with a `__setstate__`:

```
    def __setstate__(self,D):
        if isinstance(D['B'],str):
            self.B=D['B'].encode('latin1')
        else:
            self.B=D['B']
        self.S=D['S']
```
we can use `loads(...,encoding="latin1")` and get an object that validates. So with a bit of luck, I think we can deal with most cases where we do need a `bytes` attribute with either use `copyreg` to register a custom reconstructor (when an object uses a `__reduce__`) that can preprocess construction parameters that are to be turned into `bytes` or by amending/adding `__setstate__` to use `encode('latin1')` on values that are supposed to be `bytes`.

It's a fairly painful process, but it should be doable entirely on the py3 side.



---

archive/issue_comments_552852.json:
```json
{
    "body": "<a id='comment:49'></a>\nReplying to [nbruin](#comment%3A47):\n> Replying to [SimonKing](#comment%3A44):\n> \n> > - `encoding='latin1'` will make it so that always the unpickler will be in a position to look up globals. However, each Sage function expecting a `bytes` needs to be changed so that it also accepts `str` and transforms it to `bytes` with encoding \"latin1\".\n \n> \n> We only need to do so at the time of unpickling, for backwards compatibility reasons (i.e., if we move to a python-3 only protocol in the future, the workaround can be turned off when unpickling at that protocol level). So instead of actually changing the (hopefully few) objects that have a \"bytes\" object in them to accept strings and interpret them with latin1 encoding, can we just register little wrappers in \"copyreg\" to do that decoding for us?\n\n\nI don't know about copyreg. What and how can it do?\n\nThat said: We currently know only one type (namely `Matrix_gfpn_dense`) in the Sage library whose unpickling would fail if stored Python-2 str are interpreted as Python-3 str. And since a pickle with bytes is *larger* than a pickle with str, I'm inclined to change the pickling of `Matrix_gfpn_dense` anyway.\n\nSuggestion: In a *new* ticket that will be a dependency for here, I'll change `Matrix_gfpn_dense` so that it will in future use str for pickling and will be able to use both bytes and str for unpickling- Does that make sense to you?\n\nAfterwards, we can focus here on encoding defaults, copyreg...\n\n> Backport [Issue 22005](https://bugs.python.org/issue22005) from Python 3.9?\n\n\n... and the backport.\n\nSorry, I just notice that my above suggestions largely coincide with your suggestion in the rest of your post. So:\n\n> If the copyreg option is available, perhaps the following would be a workable, extendable solutions:\n> - make sure `encoding` is available for sage's unpickler access\n\n\nThat's for the ticket here, and easy.\n\n>  - aim for \"latin1\" being the default, but let 'bytes' be an option for the (rare?) pickles that need it\n\n\nWe should give the user the option to use options, regardless whether such options are needed for pickles of Sage library objects or not. That's easy to do.\n\n>  - solve a few cases needing 'bytes', using copyreg registered constructors, so that they also work with 'latin1'\n\n\nI would like to solve one case in a new ticket (namely `Matrix_gfpn_dense`) without copyreg. If further cases pop up (perhaps in the pickle jar?), we may tackle them here with copyreg. I don't know how difficult it is.\n\n>  - document the process of writing these copyreg constructors so that it's relatively straightforward to do it when we discover other data types that need it.\n\n\nGood idea.\n\n> I think that gets us at least to a state where the \"blocker\" status of this ticket can be lifted, because there's a clear path to resolving this pickle incompatibility.\n\n\nI think the example from the ticket description could be easily fixed.\n\n> Truth is: any data type that is not in a pickle jar that gets tested regularly will almost certainly not be supported for unpickling in the future.\n\n\nIf meataxe was a standard package (there are reasons to make it standard, btw.), `Matrix_gfpn_dense` should certainly become part of the pickle jar.",
    "created_at": "2019-09-04T21:54:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552852",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:49'></a>
Replying to [nbruin](#comment%3A47):
> Replying to [SimonKing](#comment%3A44):
> 
> > - `encoding='latin1'` will make it so that always the unpickler will be in a position to look up globals. However, each Sage function expecting a `bytes` needs to be changed so that it also accepts `str` and transforms it to `bytes` with encoding "latin1".
 
> 
> We only need to do so at the time of unpickling, for backwards compatibility reasons (i.e., if we move to a python-3 only protocol in the future, the workaround can be turned off when unpickling at that protocol level). So instead of actually changing the (hopefully few) objects that have a "bytes" object in them to accept strings and interpret them with latin1 encoding, can we just register little wrappers in "copyreg" to do that decoding for us?


I don't know about copyreg. What and how can it do?

That said: We currently know only one type (namely `Matrix_gfpn_dense`) in the Sage library whose unpickling would fail if stored Python-2 str are interpreted as Python-3 str. And since a pickle with bytes is *larger* than a pickle with str, I'm inclined to change the pickling of `Matrix_gfpn_dense` anyway.

Suggestion: In a *new* ticket that will be a dependency for here, I'll change `Matrix_gfpn_dense` so that it will in future use str for pickling and will be able to use both bytes and str for unpickling- Does that make sense to you?

Afterwards, we can focus here on encoding defaults, copyreg...

> Backport [Issue 22005](https://bugs.python.org/issue22005) from Python 3.9?


... and the backport.

Sorry, I just notice that my above suggestions largely coincide with your suggestion in the rest of your post. So:

> If the copyreg option is available, perhaps the following would be a workable, extendable solutions:
> - make sure `encoding` is available for sage's unpickler access


That's for the ticket here, and easy.

>  - aim for "latin1" being the default, but let 'bytes' be an option for the (rare?) pickles that need it


We should give the user the option to use options, regardless whether such options are needed for pickles of Sage library objects or not. That's easy to do.

>  - solve a few cases needing 'bytes', using copyreg registered constructors, so that they also work with 'latin1'


I would like to solve one case in a new ticket (namely `Matrix_gfpn_dense`) without copyreg. If further cases pop up (perhaps in the pickle jar?), we may tackle them here with copyreg. I don't know how difficult it is.

>  - document the process of writing these copyreg constructors so that it's relatively straightforward to do it when we discover other data types that need it.


Good idea.

> I think that gets us at least to a state where the "blocker" status of this ticket can be lifted, because there's a clear path to resolving this pickle incompatibility.


I think the example from the ticket description could be easily fixed.

> Truth is: any data type that is not in a pickle jar that gets tested regularly will almost certainly not be supported for unpickling in the future.


If meataxe was a standard package (there are reasons to make it standard, btw.), `Matrix_gfpn_dense` should certainly become part of the pickle jar.



---

archive/issue_comments_552853.json:
```json
{
    "body": "<a id='comment:50'></a>\nReplying to [SimonKing](#comment%3A49):\n\n> I don't know about copyreg. What and how can it do?\n\n\nFrom what I understand, it manages the dictionary in which \"constructors\" are looked up. A pickle of an object with a `__reduce__` would usually amount to instructions to call a certain named constructor with arguments (encoded in the pickle as well). The name of that constructor needs to be looked up somewhere. If I'm not mistaken, `copyreg` manages the dictionary for that. One can also instantiate `Unpickler` objects (or subclass them) to customize the constructor lookup. In cases where the arguments as pickled would need preprocessing before calling the normal constructor (just class names are generally used as constructors), then it makes sense to register a factory function in place of that class name to do the preprocessing (and then call the relevant class).\n\n**EDIT**: I see now that `register_unpickle_override` seems to hook into the same place where `copyreg` for the normal python unpickler goes (sage subclasses the normal unpickler and exposes that via load and loads)\n\n> Suggestion: In a *new* ticket that will be a dependency for here, I'll change `Matrix_gfpn_dense` so that it will in future use str for pickling and will be able to use both bytes and str for unpickling- Does that make sense to you?\n\n\nI'm rather strongly against misusing `str` for binary data. That's not what it's for! And what you can see in this ticket already, is that signalling intent properly in pickle files is of utmost importance for forward/backward compatibility option. The observation that it ends up shorter as a `str` could be something stupid as the sequence having a UTF-8 representation that happens to be surprisingly short. If you think the pickle format for binary can be improved, then patch pickle. I think `Matrix_gfpn_dense` should just have the interface that makes most sense for it. It can also have a custom `__reduce__` that encodes its defining data in a sensible way (it probably already has); possible zipping or otherwise compressing the data if that is appropriate (I don't think it is -- compression can always be done in a separate round)\n\n`Matrix_gfpn_dense` is very easy to fix: they are ALREADY unpickled using a helper function `mtx_unpickle`. If that would accept as Data both `bytes` and `str` (which it can then transform in `bytes` using the `latin1` encoder), you'd be done. That doesn't affect the normal API of the class at all.\n\n> If meataxe was a standard package (there are reasons to make it standard, btw.), `Matrix_gfpn_dense` should certainly become part of the pickle jar.\n\n\nIsn't the problem that the pickle jar isn't really maintained/tested anymore? With the corollary that pickling in sage is doomed to suffer from compatibility problems.",
    "created_at": "2019-09-04T22:18:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552853",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:50'></a>
Replying to [SimonKing](#comment%3A49):

> I don't know about copyreg. What and how can it do?


From what I understand, it manages the dictionary in which "constructors" are looked up. A pickle of an object with a `__reduce__` would usually amount to instructions to call a certain named constructor with arguments (encoded in the pickle as well). The name of that constructor needs to be looked up somewhere. If I'm not mistaken, `copyreg` manages the dictionary for that. One can also instantiate `Unpickler` objects (or subclass them) to customize the constructor lookup. In cases where the arguments as pickled would need preprocessing before calling the normal constructor (just class names are generally used as constructors), then it makes sense to register a factory function in place of that class name to do the preprocessing (and then call the relevant class).

**EDIT**: I see now that `register_unpickle_override` seems to hook into the same place where `copyreg` for the normal python unpickler goes (sage subclasses the normal unpickler and exposes that via load and loads)

> Suggestion: In a *new* ticket that will be a dependency for here, I'll change `Matrix_gfpn_dense` so that it will in future use str for pickling and will be able to use both bytes and str for unpickling- Does that make sense to you?


I'm rather strongly against misusing `str` for binary data. That's not what it's for! And what you can see in this ticket already, is that signalling intent properly in pickle files is of utmost importance for forward/backward compatibility option. The observation that it ends up shorter as a `str` could be something stupid as the sequence having a UTF-8 representation that happens to be surprisingly short. If you think the pickle format for binary can be improved, then patch pickle. I think `Matrix_gfpn_dense` should just have the interface that makes most sense for it. It can also have a custom `__reduce__` that encodes its defining data in a sensible way (it probably already has); possible zipping or otherwise compressing the data if that is appropriate (I don't think it is -- compression can always be done in a separate round)

`Matrix_gfpn_dense` is very easy to fix: they are ALREADY unpickled using a helper function `mtx_unpickle`. If that would accept as Data both `bytes` and `str` (which it can then transform in `bytes` using the `latin1` encoder), you'd be done. That doesn't affect the normal API of the class at all.

> If meataxe was a standard package (there are reasons to make it standard, btw.), `Matrix_gfpn_dense` should certainly become part of the pickle jar.


Isn't the problem that the pickle jar isn't really maintained/tested anymore? With the corollary that pickling in sage is doomed to suffer from compatibility problems.



---

archive/issue_comments_552854.json:
```json
{
    "body": "**Branch:** [u/SimonKing/fix_backwards_incompatibility_of_unpickling_in_python_3](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/fix_backwards_incompatibility_of_unpickling_in_python_3)",
    "created_at": "2019-09-05T22:50:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552854",
    "user": "https://github.com/simon-king-jena"
}
```

**Branch:** [u/SimonKing/fix_backwards_incompatibility_of_unpickling_in_python_3](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/fix_backwards_incompatibility_of_unpickling_in_python_3)



---

archive/issue_comments_552855.json:
```json
{
    "body": "<a id='comment:52'></a>\nWith the new commit, one can unpickle a previously un-unpicklable meataxe matrix:\n\n```\nsage: X = load('/home/king/Projekte/coho/tests/Py2.sobj')\nsage: X\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\n```\nHowever, we need doctests to demonstrate that this ticket fixes what it was supposed to fix.\n\nAlso, I wonder if we should strive to make it not only \"legal\" to use `encoding='bytes'` but to actually make it possible: Currently, one gets\n\n```\nsage: X = load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-1-1bf7b48d4b86> in <module>()\n----> 1 X = load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2863)()\n    154 \n    155     ## Load file by absolute filename\n--> 156     with open(filename, 'rb') as fobj:\n    157         X = loads(fobj.read(), compress=compress, **kwargs)\n    158     try:\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2813)()\n    155     ## Load file by absolute filename\n    156     with open(filename, 'rb') as fobj:\n--> 157         X = loads(fobj.read(), compress=compress, **kwargs)\n    158     try:\n    159         X._default_filename = os.path.abspath(filename)\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7318)()\n    974 \n    975     unpickler = SageUnpickler(io.BytesIO(s), **kwargs)\n--> 976     return unpickler.load()\n    977 \n    978 \n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/structure/factory.pyx in sage.structure.factory.lookup_global (build/cythonized/sage/structure/factory.c:4602)()\n    752         pass\n    753 \n--> 754     if '.' in name:\n    755         module, name = name.rsplit('.', 1)\n    756         all = __import__(module, fromlist=[name])\n\nTypeError: a bytes-like object is required, not 'str'\n```\nWe could of course make `lookup_global` to accept bytes (with encoding ascii, I guess) to look up functions given by names. It will, however, be very likely that that will not be the only change needed to make `encoding='bytes'` work.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d\">2e0d11e</a></td><td><code>Pass unpickling options to pickle.load, default encoding 'latin1'. Accept both str and bytes in mtx_unpickle</code></td></tr></table>\n",
    "created_at": "2019-09-05T22:54:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552855",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:52'></a>
With the new commit, one can unpickle a previously un-unpicklable meataxe matrix:

```
sage: X = load('/home/king/Projekte/coho/tests/Py2.sobj')
sage: X
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
```
However, we need doctests to demonstrate that this ticket fixes what it was supposed to fix.

Also, I wonder if we should strive to make it not only "legal" to use `encoding='bytes'` but to actually make it possible: Currently, one gets

```
sage: X = load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-1-1bf7b48d4b86> in <module>()
----> 1 X = load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2863)()
    154 
    155     ## Load file by absolute filename
--> 156     with open(filename, 'rb') as fobj:
    157         X = loads(fobj.read(), compress=compress, **kwargs)
    158     try:

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2813)()
    155     ## Load file by absolute filename
    156     with open(filename, 'rb') as fobj:
--> 157         X = loads(fobj.read(), compress=compress, **kwargs)
    158     try:
    159         X._default_filename = os.path.abspath(filename)

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7318)()
    974 
    975     unpickler = SageUnpickler(io.BytesIO(s), **kwargs)
--> 976     return unpickler.load()
    977 
    978 

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/structure/factory.pyx in sage.structure.factory.lookup_global (build/cythonized/sage/structure/factory.c:4602)()
    752         pass
    753 
--> 754     if '.' in name:
    755         module, name = name.rsplit('.', 1)
    756         all = __import__(module, fromlist=[name])

TypeError: a bytes-like object is required, not 'str'
```
We could of course make `lookup_global` to accept bytes (with encoding ascii, I guess) to look up functions given by names. It will, however, be very likely that that will not be the only change needed to make `encoding='bytes'` work.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d">2e0d11e</a></td><td><code>Pass unpickling options to pickle.load, default encoding 'latin1'. Accept both str and bytes in mtx_unpickle</code></td></tr></table>




---

archive/issue_comments_552856.json:
```json
{
    "body": "**Commit:** [2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d](https://github.com/sagemath/sagetrac-mirror/commit/2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d)",
    "created_at": "2019-09-05T22:54:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552856",
    "user": "https://github.com/simon-king-jena"
}
```

**Commit:** [2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d](https://github.com/sagemath/sagetrac-mirror/commit/2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d)



---

archive/issue_comments_552857.json:
```json
{
    "body": "<a id='comment:53'></a>\nWarning: Trying to make bytes encoding work is likely to open a can of worms. Such as:\n\n```\nsage: X = load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n<ipython-input-1-1bf7b48d4b86> in <module>()\n----> 1 X = load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2863)()\n    157 \n    158     ## Load file by absolute filename\n--> 159     with open(filename, 'rb') as fobj:\n    160         X = loads(fobj.read(), compress=compress, **kwargs)\n    161     try:\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2813)()\n    158     ## Load file by absolute filename\n    159     with open(filename, 'rb') as fobj:\n--> 160         X = loads(fobj.read(), compress=compress, **kwargs)\n    161     try:\n    162         X._default_filename = os.path.abspath(filename)\n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7318)()\n    977 \n    978     unpickler = SageUnpickler(io.BytesIO(s), **kwargs)\n--> 979     return unpickler.load()\n    980 \n    981 \n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/rings/integer.pyx in sage.rings.integer.make_integer (build/cythonized/sage/rings/integer.c:43277)()\n   7220     \"\"\"\n   7221     cdef Integer r = PY_NEW(Integer)\n-> 7222     mpz_set_str(r.value, str_to_bytes(s), 32)\n   7223     return r\n   7224 \n\n/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/cpython/string.pxd in sage.cpython.string.str_to_bytes (build/cythonized/sage/rings/integer.c:47648)()\n     90     # compile-time variable. We keep the Cython wrapper to deal with\n     91     # the default arguments.\n---> 92     return _str_to_bytes(s, encoding, errors)\n\nTypeError: expected str, bytes found\n```\nSo, it would mean to change further constructors to be flexible with regards to str and bytes.\n\nThus, question: Shall we try to do this? Shall we just keep the new commit, and add doctests? Further suggestion for the way to proceed?",
    "created_at": "2019-09-05T23:01:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552857",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:53'></a>
Warning: Trying to make bytes encoding work is likely to open a can of worms. Such as:

```
sage: X = load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-1-1bf7b48d4b86> in <module>()
----> 1 X = load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2863)()
    157 
    158     ## Load file by absolute filename
--> 159     with open(filename, 'rb') as fobj:
    160         X = loads(fobj.read(), compress=compress, **kwargs)
    161     try:

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.load (build/cythonized/sage/misc/persist.c:2813)()
    158     ## Load file by absolute filename
    159     with open(filename, 'rb') as fobj:
--> 160         X = loads(fobj.read(), compress=compress, **kwargs)
    161     try:
    162         X._default_filename = os.path.abspath(filename)

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/misc/persist.pyx in sage.misc.persist.loads (build/cythonized/sage/misc/persist.c:7318)()
    977 
    978     unpickler = SageUnpickler(io.BytesIO(s), **kwargs)
--> 979     return unpickler.load()
    980 
    981 

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/rings/integer.pyx in sage.rings.integer.make_integer (build/cythonized/sage/rings/integer.c:43277)()
   7220     """
   7221     cdef Integer r = PY_NEW(Integer)
-> 7222     mpz_set_str(r.value, str_to_bytes(s), 32)
   7223     return r
   7224 

/home/king/Sage/git/py3/local/lib/python3.7/site-packages/sage/cpython/string.pxd in sage.cpython.string.str_to_bytes (build/cythonized/sage/rings/integer.c:47648)()
     90     # compile-time variable. We keep the Cython wrapper to deal with
     91     # the default arguments.
---> 92     return _str_to_bytes(s, encoding, errors)

TypeError: expected str, bytes found
```
So, it would mean to change further constructors to be flexible with regards to str and bytes.

Thus, question: Shall we try to do this? Shall we just keep the new commit, and add doctests? Further suggestion for the way to proceed?



---

archive/issue_comments_552858.json:
```json
{
    "body": "<a id='comment:54'></a>\nI just notice that the function `str_to_bytes` does not require that the input is a `str`. Hence, it may be reasonable to change it so that, if the input is a bytes, it is returned without change.",
    "created_at": "2019-09-05T23:04:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552858",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:54'></a>
I just notice that the function `str_to_bytes` does not require that the input is a `str`. Hence, it may be reasonable to change it so that, if the input is a bytes, it is returned without change.



---

archive/issue_comments_552859.json:
```json
{
    "body": "**Changing commit** from \"[2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d](https://github.com/sagemath/sagetrac-mirror/commit/2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d)\" to \"[1984bc5f2e1d5bd50be697ddad39866b683d5f76](https://github.com/sagemath/sagetrac-mirror/commit/1984bc5f2e1d5bd50be697ddad39866b683d5f76)\".",
    "created_at": "2019-09-05T23:38:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552859",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d](https://github.com/sagemath/sagetrac-mirror/commit/2e0d11e758f4565b718f4cdf8f957fa6ef6b8d7d)" to "[1984bc5f2e1d5bd50be697ddad39866b683d5f76](https://github.com/sagemath/sagetrac-mirror/commit/1984bc5f2e1d5bd50be697ddad39866b683d5f76)".



---

archive/issue_comments_552860.json:
```json
{
    "body": "<a id='comment:55'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1984bc5f2e1d5bd50be697ddad39866b683d5f76\">1984bc5</a></td><td><code>Make str_to_bytes accept str input, and bytes_to_str accept bytes input. Use it in finite field and integer constructor</code></td></tr></table>\n",
    "created_at": "2019-09-05T23:38:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552860",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:55'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1984bc5f2e1d5bd50be697ddad39866b683d5f76">1984bc5</a></td><td><code>Make str_to_bytes accept str input, and bytes_to_str accept bytes input. Use it in finite field and integer constructor</code></td></tr></table>




---

archive/issue_comments_552861.json:
```json
{
    "body": "<a id='comment:56'></a>\nAs a proof of concept, I provide a commit which makes it possible to unpickle my example with `encoding='bytes'`. It works by making `bytes_to_str` accept str input (returning it unchanged) and `str_to_bytes` accept bytes input (returning it unchanged. Also, I used these conversion functions in some integer constructor, finite field constructor, and in `mtx_unpickle`.\n\nHowever, I guess it would be needed to use `bytes_to_str` and `str_to_bytes` in a lot more places, therefore it is not more than a proof of concept. \n\nAnyway, with the new commit, the following things work in Python 3:\n\n```\nsage: load('/home/king/Projekte/coho/tests/Py2.sobj')\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\nsage: load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\nsage: load('/home/king/Projekte/coho/tests/Py3.sobj', encoding='bytes')\n[1 0 0 0 0 0 0 0]\n[0 0 0 1 1 1 1 1]\nsage: from sage.matrix.matrix_gfpn_dense import mtx_unpickle\nsage: class unpickle_old_mtx:\n....:     def __call__(self, *args, **kwds):\n....:         return mtx_unpickle(*args, **kwds)\n....:     \nsage: register_unpickle_override('pGroupCohomology.mtx', 'MTX_unpickle_class', unpickle_old_mtx)\nsage: X = load('/home/king/Projekte/coho/tests/State.sobj')\n```\nOf course, all these examples are using the optional meataxe package.",
    "created_at": "2019-09-05T23:47:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552861",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:56'></a>
As a proof of concept, I provide a commit which makes it possible to unpickle my example with `encoding='bytes'`. It works by making `bytes_to_str` accept str input (returning it unchanged) and `str_to_bytes` accept bytes input (returning it unchanged. Also, I used these conversion functions in some integer constructor, finite field constructor, and in `mtx_unpickle`.

However, I guess it would be needed to use `bytes_to_str` and `str_to_bytes` in a lot more places, therefore it is not more than a proof of concept. 

Anyway, with the new commit, the following things work in Python 3:

```
sage: load('/home/king/Projekte/coho/tests/Py2.sobj')
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
sage: load('/home/king/Projekte/coho/tests/Py2.sobj', encoding='bytes')
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
sage: load('/home/king/Projekte/coho/tests/Py3.sobj', encoding='bytes')
[1 0 0 0 0 0 0 0]
[0 0 0 1 1 1 1 1]
sage: from sage.matrix.matrix_gfpn_dense import mtx_unpickle
sage: class unpickle_old_mtx:
....:     def __call__(self, *args, **kwds):
....:         return mtx_unpickle(*args, **kwds)
....:     
sage: register_unpickle_override('pGroupCohomology.mtx', 'MTX_unpickle_class', unpickle_old_mtx)
sage: X = load('/home/king/Projekte/coho/tests/State.sobj')
```
Of course, all these examples are using the optional meataxe package.



---

archive/issue_comments_552862.json:
```json
{
    "body": "<a id='comment:57'></a>\nWhy try to make `encoding='bytes'` work in so many places? The problem is that pickles travelling over the Py2/Py3 boundary have an issue that  the str/bytes distinction gets squashed (because str in py2 wasn't proper unicode yet). It's pretty clear that str objects are WAY more common in python than bytes objects, so encoding with `bytes` is going to need a LOT of post-processing. It's much more reasonable to assume these objects are in fact (ascii) strings. However, that breaks hard if it obviously isn't. Hence the `latin1` workaround. But then getting bytes objects where they should be of course requires domain-specific knowledge. So the unpickling routines must be made more tolerant and accept a str where it expects a bytes object. But preferably only the unpickling routines! Interpreting a str object as a bytes object via latin1 encoding remains a hack that could mask errors and typos, and make them harder to detect.\n\nIf you want to make things work with 'bytes' encoding *as well as* 'latin1' encoding, I think you're just making extra work for yourself, and if you're making the infrastructure more lax about input types, I think you can end up with masking more errors in the end. Note that the problem you're solving here is very limited: it's JUST to help pickles cross the Py2-to-Py3 boundary (the other direction is not supported at all).\n\nWith the experience we have here now, I think it's pretty clear that with enough work, you can make any pickle decode with latin1 in Py3. You'll just be registering a lot of pickle overrides ...",
    "created_at": "2019-09-06T00:10:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552862",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:57'></a>
Why try to make `encoding='bytes'` work in so many places? The problem is that pickles travelling over the Py2/Py3 boundary have an issue that  the str/bytes distinction gets squashed (because str in py2 wasn't proper unicode yet). It's pretty clear that str objects are WAY more common in python than bytes objects, so encoding with `bytes` is going to need a LOT of post-processing. It's much more reasonable to assume these objects are in fact (ascii) strings. However, that breaks hard if it obviously isn't. Hence the `latin1` workaround. But then getting bytes objects where they should be of course requires domain-specific knowledge. So the unpickling routines must be made more tolerant and accept a str where it expects a bytes object. But preferably only the unpickling routines! Interpreting a str object as a bytes object via latin1 encoding remains a hack that could mask errors and typos, and make them harder to detect.

If you want to make things work with 'bytes' encoding *as well as* 'latin1' encoding, I think you're just making extra work for yourself, and if you're making the infrastructure more lax about input types, I think you can end up with masking more errors in the end. Note that the problem you're solving here is very limited: it's JUST to help pickles cross the Py2-to-Py3 boundary (the other direction is not supported at all).

With the experience we have here now, I think it's pretty clear that with enough work, you can make any pickle decode with latin1 in Py3. You'll just be registering a lot of pickle overrides ...



---

archive/issue_comments_552863.json:
```json
{
    "body": "<a id='comment:58'></a>\nReplying to [nbruin](#comment%3A57):\n> Why try to make `encoding='bytes'` work in so many places?\n\n\nBecause an important datatype, namely numpy arrays with datetime objects, apparently can only be unpickled using `encoding='bytes'`. And of course, a numpy array can be part of a larger structure that also comprises further Sage objects. Therefore it makes sense that these can be unpickled with `encoding='bytes'`, too.\n\n> So the unpickling routines must be made more tolerant and accept a str where it expects a bytes object. But preferably only the unpickling routines!\n\n\nSure. That's what I do in the first commit (in the only place in the Sage library that really uses bytes that I am aware of).\n\n> Interpreting a str object as a bytes object via latin1 encoding remains a hack that could mask errors and typos, and make them harder to detect.\n\n\nYou mean the other way around.\n\n> If you want to make things work with 'bytes' encoding *as well as* 'latin1' encoding, I think you're just making extra work for yourself, and if you're making the infrastructure more lax about input types, I think you can end up with masking more errors in the end.\n\n\nSure. That's why I said it is a proof of concept. I show that making `bytes_to_str` and `str_to_bytes` more tolerant about input and using it more commonly in fact is a way to unpickle with `encoding='bytes'`, showing that with some work there *is* a chance to unpickle complex data structures involving numpy arrays, without patching numpy.\n\nBut probably, it would be easier to just drop the new commit, and then provide some unpickle override for numpy arrays only.\n\n> Note that the problem you're solving here is very limited: it's JUST to help pickles cross the Py2-to-Py3 boundary (the other direction is not supported at all).\n\n\nThe other direction apparently is less critical, as I have shown that the Py-3 pickle corresponding to the ticket description can be unpickled both in Py-2 and Py-3.\n\n> With the experience we have here now, I think it's pretty clear that with enough work, you can make any pickle decode with latin1 in Py3. You'll just be registering a lot of pickle overrides ...\n\n\nNo. I am pretty sure that with latin1 it would be **few** pickle overrides. With bytes it would be *lots* of pickle overrides.",
    "created_at": "2019-09-06T05:59:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552863",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:58'></a>
Replying to [nbruin](#comment%3A57):
> Why try to make `encoding='bytes'` work in so many places?


Because an important datatype, namely numpy arrays with datetime objects, apparently can only be unpickled using `encoding='bytes'`. And of course, a numpy array can be part of a larger structure that also comprises further Sage objects. Therefore it makes sense that these can be unpickled with `encoding='bytes'`, too.

> So the unpickling routines must be made more tolerant and accept a str where it expects a bytes object. But preferably only the unpickling routines!


Sure. That's what I do in the first commit (in the only place in the Sage library that really uses bytes that I am aware of).

> Interpreting a str object as a bytes object via latin1 encoding remains a hack that could mask errors and typos, and make them harder to detect.


You mean the other way around.

> If you want to make things work with 'bytes' encoding *as well as* 'latin1' encoding, I think you're just making extra work for yourself, and if you're making the infrastructure more lax about input types, I think you can end up with masking more errors in the end.


Sure. That's why I said it is a proof of concept. I show that making `bytes_to_str` and `str_to_bytes` more tolerant about input and using it more commonly in fact is a way to unpickle with `encoding='bytes'`, showing that with some work there *is* a chance to unpickle complex data structures involving numpy arrays, without patching numpy.

But probably, it would be easier to just drop the new commit, and then provide some unpickle override for numpy arrays only.

> Note that the problem you're solving here is very limited: it's JUST to help pickles cross the Py2-to-Py3 boundary (the other direction is not supported at all).


The other direction apparently is less critical, as I have shown that the Py-3 pickle corresponding to the ticket description can be unpickled both in Py-2 and Py-3.

> With the experience we have here now, I think it's pretty clear that with enough work, you can make any pickle decode with latin1 in Py3. You'll just be registering a lot of pickle overrides ...


No. I am pretty sure that with latin1 it would be **few** pickle overrides. With bytes it would be *lots* of pickle overrides.



---

archive/issue_comments_552864.json:
```json
{
    "body": "<a id='comment:59'></a>\nReplying to [SimonKing](#comment%3A58):\n> > With the experience we have here now, I think it's pretty clear that with enough work, you can make any pickle decode with latin1 in Py3. You'll just be registering a lot of pickle overrides ...\n\n> \n> No. I am pretty sure that with latin1 it would be **few** pickle overrides. With bytes it would be *lots* of pickle overrides.\n\n\nPerhaps I was confusing \"pickle overrides\" with \"changes in unpickling functions\".\n\nRestating what I mean:\n- If 'latin1' is default encoding, it could very well be that the first commit already is enough to fix the Sage library. With 'bytes', a lot more changes to the Sage library would be needed.\n- If 'latin1' is default encoding, there will of course be places in which we should register a pickle override. So far, we know one case from hearsay, namely `numpy.array`. If 'bytes' is default encoding, I simply don't know how many pickle overrides we'd need to register for non-Sage data types. If I recall correctly, the links discussed above only mention numpy datetime, with the corollary of numpy arrays. But is there more?\n\nFrom the above, I think we can conclude that 'latin1' is the most reasonable default encoding for unpickling. But we should decide to what extent we want to support the 'bytes' encoding for unpickling. From my perspective, it wouldn't really be needed, thus, I'm totally fine with discarding the proof-of-concept commit.",
    "created_at": "2019-09-06T07:09:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552864",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:59'></a>
Replying to [SimonKing](#comment%3A58):
> > With the experience we have here now, I think it's pretty clear that with enough work, you can make any pickle decode with latin1 in Py3. You'll just be registering a lot of pickle overrides ...

> 
> No. I am pretty sure that with latin1 it would be **few** pickle overrides. With bytes it would be *lots* of pickle overrides.


Perhaps I was confusing "pickle overrides" with "changes in unpickling functions".

Restating what I mean:
- If 'latin1' is default encoding, it could very well be that the first commit already is enough to fix the Sage library. With 'bytes', a lot more changes to the Sage library would be needed.
- If 'latin1' is default encoding, there will of course be places in which we should register a pickle override. So far, we know one case from hearsay, namely `numpy.array`. If 'bytes' is default encoding, I simply don't know how many pickle overrides we'd need to register for non-Sage data types. If I recall correctly, the links discussed above only mention numpy datetime, with the corollary of numpy arrays. But is there more?

From the above, I think we can conclude that 'latin1' is the most reasonable default encoding for unpickling. But we should decide to what extent we want to support the 'bytes' encoding for unpickling. From my perspective, it wouldn't really be needed, thus, I'm totally fine with discarding the proof-of-concept commit.



---

archive/issue_comments_552865.json:
```json
{
    "body": "<a id='comment:60'></a>\nEven if we decide to not support 'bytes' encoding, we might want to change `str_to_bytes` and `bytes_to_str` so that the former accepts bytes input and the latter accepts str input, returning the input unaltered in that case. I think it would be useful.",
    "created_at": "2019-09-06T07:12:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552865",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:60'></a>
Even if we decide to not support 'bytes' encoding, we might want to change `str_to_bytes` and `bytes_to_str` so that the former accepts bytes input and the latter accepts str input, returning the input unaltered in that case. I think it would be useful.



---

archive/issue_comments_552866.json:
```json
{
    "body": "<a id='comment:61'></a>\nReplying to [SimonKing](#comment%3A60):\n> Even if we decide to not support 'bytes' encoding, we might want to change `str_to_bytes` and `bytes_to_str` so that the former accepts bytes input and the latter accepts str input, returning the input unaltered in that case. I think it would be useful.\n\n\nYes, that doesn't look too bad. Do we know for certain that datetime is still a problem with latin1? I don't have a problem with it when I do\n\n```\npickle.dumps(datetime(1977,10,10))\n```\nand then load it in Py3 with `pickle.loads(...,encoding=\"latin1\")`. With `encoding=\"bytes\"` it also seems to work. When I look in Python3 Lib/datetime.py, I see reduce and `__new__` methods that very explicitly have comments about \"pickle support\" and calls to `latin1` encoding to deal with string input parameters. So I'm pretty sure this has been fixed in recent python version; not just 3.9.\n\nSo I don't think we have a convincing case where encoding=bytes is required, and we do have convincing evidence that encoding=bytes is very painful. Even in a py3 where latin1 does not work out of the box, one could provide a pickle override to do the preprocessing. Therefore, I don't think you should put extra effort in supporting encoding=bytes at the moment.",
    "created_at": "2019-09-06T07:42:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552866",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:61'></a>
Replying to [SimonKing](#comment%3A60):
> Even if we decide to not support 'bytes' encoding, we might want to change `str_to_bytes` and `bytes_to_str` so that the former accepts bytes input and the latter accepts str input, returning the input unaltered in that case. I think it would be useful.


Yes, that doesn't look too bad. Do we know for certain that datetime is still a problem with latin1? I don't have a problem with it when I do

```
pickle.dumps(datetime(1977,10,10))
```
and then load it in Py3 with `pickle.loads(...,encoding="latin1")`. With `encoding="bytes"` it also seems to work. When I look in Python3 Lib/datetime.py, I see reduce and `__new__` methods that very explicitly have comments about "pickle support" and calls to `latin1` encoding to deal with string input parameters. So I'm pretty sure this has been fixed in recent python version; not just 3.9.

So I don't think we have a convincing case where encoding=bytes is required, and we do have convincing evidence that encoding=bytes is very painful. Even in a py3 where latin1 does not work out of the box, one could provide a pickle override to do the preprocessing. Therefore, I don't think you should put extra effort in supporting encoding=bytes at the moment.



---

archive/issue_comments_552867.json:
```json
{
    "body": "**Changing commit** from \"[1984bc5f2e1d5bd50be697ddad39866b683d5f76](https://github.com/sagemath/sagetrac-mirror/commit/1984bc5f2e1d5bd50be697ddad39866b683d5f76)\" to \"[8c105cdcada53eed019bba4f4d26cf7fe7e72c22](https://github.com/sagemath/sagetrac-mirror/commit/8c105cdcada53eed019bba4f4d26cf7fe7e72c22)\".",
    "created_at": "2019-09-06T13:11:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552867",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[1984bc5f2e1d5bd50be697ddad39866b683d5f76](https://github.com/sagemath/sagetrac-mirror/commit/1984bc5f2e1d5bd50be697ddad39866b683d5f76)" to "[8c105cdcada53eed019bba4f4d26cf7fe7e72c22](https://github.com/sagemath/sagetrac-mirror/commit/8c105cdcada53eed019bba4f4d26cf7fe7e72c22)".



---

archive/issue_comments_552868.json:
```json
{
    "body": "<a id='comment:62'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8c105cdcada53eed019bba4f4d26cf7fe7e72c22\">8c105cd</a></td><td><code>Make str_to_bytes/bytes_to_str accept both str and bytes input.</code></td></tr></table>\n",
    "created_at": "2019-09-06T13:11:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552868",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:62'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8c105cdcada53eed019bba4f4d26cf7fe7e72c22">8c105cd</a></td><td><code>Make str_to_bytes/bytes_to_str accept both str and bytes input.</code></td></tr></table>




---

archive/issue_comments_552869.json:
```json
{
    "body": "<a id='comment:63'></a>\nI replaced the old second commit by a commit that is less invasive: It changes the conversion functions so that they return the input unaltered if its type fits, it uses the conversion functions in `matrix_gfpn_dense` for unpickling (I think that's cleaner than doing a type check there), and it also uses them in `lookup_global`, because if we want to support `encoding='bytes'` at all, we have to make lookup work with that option.\n\nSo, from my perspective, the code itself is ready to be used. But we should add some tests. Ideas how they could look? I could imagine to use a string that was created by `dumps` in Python-2 and demonstrate that the string can be interpreted by `loads`, regardless whether it is Py-2 or Py-3.",
    "created_at": "2019-09-06T13:24:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552869",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:63'></a>
I replaced the old second commit by a commit that is less invasive: It changes the conversion functions so that they return the input unaltered if its type fits, it uses the conversion functions in `matrix_gfpn_dense` for unpickling (I think that's cleaner than doing a type check there), and it also uses them in `lookup_global`, because if we want to support `encoding='bytes'` at all, we have to make lookup work with that option.

So, from my perspective, the code itself is ready to be used. But we should add some tests. Ideas how they could look? I could imagine to use a string that was created by `dumps` in Python-2 and demonstrate that the string can be interpreted by `loads`, regardless whether it is Py-2 or Py-3.



---

archive/issue_comments_552870.json:
```json
{
    "body": "<a id='comment:64'></a>\nCurrently I try to create a doctest as follows: Have a Cython class Foo such that its constructor expects a str. Create a Foo instance f in Python 2 with a non-ascii string, and create a pickle string s with `dumps(f)`. Then, without this ticket, `loads(s)` would fail in Python 3, because the non-ascii string in the pickle cannot be unpickled as a string with the default encoding chosen by Python 3. But WITH this ticket, it can be unpickled, because our default encoding is latin1.\n\nProblem: When I do\n\n```\nsage: cython(\"\"\"\n....: from sage.structure.richcmp import richcmp\n....: cdef class Foo:\n....:     cdef str bar\n....:     def __init__(self, data):\n....:         self.bar = data\n....:     def __richcmp__(self, other, op):\n....:         cdef Foo Other = other\n....:         return richcmp(self.bar, Other.bar, op)\n....:     def __reduce__(self):\n....:         return Foo, (self.bar,)\n....: \"\"\")\n```\nthen the module name of `Foo` is a temporary name that is essentially random. How can I prescribe that the module of `Foo` is `__main__`?",
    "created_at": "2019-09-07T11:20:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552870",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:64'></a>
Currently I try to create a doctest as follows: Have a Cython class Foo such that its constructor expects a str. Create a Foo instance f in Python 2 with a non-ascii string, and create a pickle string s with `dumps(f)`. Then, without this ticket, `loads(s)` would fail in Python 3, because the non-ascii string in the pickle cannot be unpickled as a string with the default encoding chosen by Python 3. But WITH this ticket, it can be unpickled, because our default encoding is latin1.

Problem: When I do

```
sage: cython("""
....: from sage.structure.richcmp import richcmp
....: cdef class Foo:
....:     cdef str bar
....:     def __init__(self, data):
....:         self.bar = data
....:     def __richcmp__(self, other, op):
....:         cdef Foo Other = other
....:         return richcmp(self.bar, Other.bar, op)
....:     def __reduce__(self):
....:         return Foo, (self.bar,)
....: """)
```
then the module name of `Foo` is a temporary name that is essentially random. How can I prescribe that the module of `Foo` is `__main__`?



---

archive/issue_comments_552871.json:
```json
{
    "body": "**Changing commit** from \"[8c105cdcada53eed019bba4f4d26cf7fe7e72c22](https://github.com/sagemath/sagetrac-mirror/commit/8c105cdcada53eed019bba4f4d26cf7fe7e72c22)\" to \"[712e8dd8109e1c6784f405eec86433ae9c1a711d](https://github.com/sagemath/sagetrac-mirror/commit/712e8dd8109e1c6784f405eec86433ae9c1a711d)\".",
    "created_at": "2019-09-07T15:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552871",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[8c105cdcada53eed019bba4f4d26cf7fe7e72c22](https://github.com/sagemath/sagetrac-mirror/commit/8c105cdcada53eed019bba4f4d26cf7fe7e72c22)" to "[712e8dd8109e1c6784f405eec86433ae9c1a711d](https://github.com/sagemath/sagetrac-mirror/commit/712e8dd8109e1c6784f405eec86433ae9c1a711d)".



---

archive/issue_comments_552872.json:
```json
{
    "body": "<a id='comment:65'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/712e8dd8109e1c6784f405eec86433ae9c1a711d\">712e8dd</a></td><td><code>Add tests for #28444</code></td></tr></table>\n",
    "created_at": "2019-09-07T15:39:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552872",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:65'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/712e8dd8109e1c6784f405eec86433ae9c1a711d">712e8dd</a></td><td><code>Add tests for #28444</code></td></tr></table>




---

archive/issue_comments_552873.json:
```json
{
    "body": "**Changing commit** from \"[712e8dd8109e1c6784f405eec86433ae9c1a711d](https://github.com/sagemath/sagetrac-mirror/commit/712e8dd8109e1c6784f405eec86433ae9c1a711d)\" to \"[c8a074883997bfdd5afde3065c4a33002914999b](https://github.com/sagemath/sagetrac-mirror/commit/c8a074883997bfdd5afde3065c4a33002914999b)\".",
    "created_at": "2019-09-07T15:44:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552873",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[712e8dd8109e1c6784f405eec86433ae9c1a711d](https://github.com/sagemath/sagetrac-mirror/commit/712e8dd8109e1c6784f405eec86433ae9c1a711d)" to "[c8a074883997bfdd5afde3065c4a33002914999b](https://github.com/sagemath/sagetrac-mirror/commit/c8a074883997bfdd5afde3065c4a33002914999b)".



---

archive/issue_comments_552874.json:
```json
{
    "body": "<a id='comment:66'></a>\n**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c8a074883997bfdd5afde3065c4a33002914999b\">c8a0748</a></td><td><code>Add tests for #28444</code></td></tr></table>\n",
    "created_at": "2019-09-07T15:44:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552874",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:66'></a>
**Branch pushed to git repo; I updated commit sha1. This was a forced push.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c8a074883997bfdd5afde3065c4a33002914999b">c8a0748</a></td><td><code>Add tests for #28444</code></td></tr></table>




---

archive/issue_comments_552875.json:
```json
{
    "body": "<a id='comment:67'></a>\nThe new commit adds tests. There is also one test that should only be executed in Python-3, and therefore I marked it `# optional: python3`. The tests in `sage.misc.persist` do pass in Sage-with-py3 and Sage-with-py2. However, oddly enough, the Py3 version of Sage adds `python2`, not `python3`, to the doctester. Is that a bug?\n\nAnyway, I now think the ticket can be reviewed.",
    "created_at": "2019-09-07T15:48:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552875",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:67'></a>
The new commit adds tests. There is also one test that should only be executed in Python-3, and therefore I marked it `# optional: python3`. The tests in `sage.misc.persist` do pass in Sage-with-py3 and Sage-with-py2. However, oddly enough, the Py3 version of Sage adds `python2`, not `python3`, to the doctester. Is that a bug?

Anyway, I now think the ticket can be reviewed.



---

archive/issue_comments_552876.json:
```json
{
    "body": "**Changing status** from new to needs_review.",
    "created_at": "2019-09-07T15:48:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552876",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from new to needs_review.



---

archive/issue_comments_552877.json:
```json
{
    "body": "**Author:** Simon King",
    "created_at": "2019-09-07T15:48:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552877",
    "user": "https://github.com/simon-king-jena"
}
```

**Author:** Simon King



---

archive/issue_comments_552878.json:
```json
{
    "body": "<a id='comment:68'></a>\nReplying to [SimonKing](#comment%3A67):\n> However, oddly enough, the Py3 version of Sage adds `python2`, not `python3`, to the doctester.\n\n\nI just tested: With `sage -t --optional=build,ccache,dochtml,frobby,gap_packages,gdb,gfortran,libsemigroups,meataxe,memlimit,mpir,p_group_cohomology,python2,python3,sage src/sage/misc/persist.pyx`, the optional py3-test passes in Sage-with-py3, but fails in Sage-with-py2, which is of course expected, as the `encoding` keyword doesn't exist in Python-2.",
    "created_at": "2019-09-07T15:51:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552878",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:68'></a>
Replying to [SimonKing](#comment%3A67):
> However, oddly enough, the Py3 version of Sage adds `python2`, not `python3`, to the doctester.


I just tested: With `sage -t --optional=build,ccache,dochtml,frobby,gap_packages,gdb,gfortran,libsemigroups,meataxe,memlimit,mpir,p_group_cohomology,python2,python3,sage src/sage/misc/persist.pyx`, the optional py3-test passes in Sage-with-py3, but fails in Sage-with-py2, which is of course expected, as the `encoding` keyword doesn't exist in Python-2.



---

archive/issue_comments_552879.json:
```json
{
    "body": "<a id='comment:69'></a>\nThe python3-only test tag is `#py3`",
    "created_at": "2019-09-07T17:17:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552879",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:69'></a>
The python3-only test tag is `#py3`



---

archive/issue_comments_552880.json:
```json
{
    "body": "**Changing commit** from \"[c8a074883997bfdd5afde3065c4a33002914999b](https://github.com/sagemath/sagetrac-mirror/commit/c8a074883997bfdd5afde3065c4a33002914999b)\" to \"[89ac77aa44fd3bab4399791fa72e088a52058a8e](https://github.com/sagemath/sagetrac-mirror/commit/89ac77aa44fd3bab4399791fa72e088a52058a8e)\".",
    "created_at": "2019-09-07T17:21:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552880",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[c8a074883997bfdd5afde3065c4a33002914999b](https://github.com/sagemath/sagetrac-mirror/commit/c8a074883997bfdd5afde3065c4a33002914999b)" to "[89ac77aa44fd3bab4399791fa72e088a52058a8e](https://github.com/sagemath/sagetrac-mirror/commit/89ac77aa44fd3bab4399791fa72e088a52058a8e)".



---

archive/issue_comments_552881.json:
```json
{
    "body": "<a id='comment:70'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/89ac77aa44fd3bab4399791fa72e088a52058a8e\">89ac77a</a></td><td><code>Fix keyword for py3-only test</code></td></tr></table>\n",
    "created_at": "2019-09-07T17:21:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552881",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:70'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/89ac77aa44fd3bab4399791fa72e088a52058a8e">89ac77a</a></td><td><code>Fix keyword for py3-only test</code></td></tr></table>




---

archive/issue_comments_552882.json:
```json
{
    "body": "<a id='comment:71'></a>\nReplying to [chapoton](#comment%3A69):\n> The python3-only test tag is `#py3`\n\n\nThank you! The latest commit fixes it. I verified that the tests of `persist.pyx` pass both with python-2 and python-3.",
    "created_at": "2019-09-07T17:22:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552882",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:71'></a>
Replying to [chapoton](#comment%3A69):
> The python3-only test tag is `#py3`


Thank you! The latest commit fixes it. I verified that the tests of `persist.pyx` pass both with python-2 and python-3.



---

archive/issue_comments_552883.json:
```json
{
    "body": "<a id='comment:72'></a>\nOops. The doc-builder complains:\n\n```\n[dochtml] [misc     ] docstring of sage.misc.persist.SagePickler:21: WARNING: Inline literal start-string without end-string.\n[dochtml] [misc     ] docstring of sage.misc.persist.loads:52: WARNING: Block quote ends without a blank line; unexpected unindent.\n[dochtml] [misc     ] docstring of sage.misc.persist.loads:52: WARNING: Inline emphasis start-string without end-string.\n```",
    "created_at": "2019-09-11T10:14:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552883",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:72'></a>
Oops. The doc-builder complains:

```
[dochtml] [misc     ] docstring of sage.misc.persist.SagePickler:21: WARNING: Inline literal start-string without end-string.
[dochtml] [misc     ] docstring of sage.misc.persist.loads:52: WARNING: Block quote ends without a blank line; unexpected unindent.
[dochtml] [misc     ] docstring of sage.misc.persist.loads:52: WARNING: Inline emphasis start-string without end-string.
```



---

archive/issue_comments_552884.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2019-09-11T10:14:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552884",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_552885.json:
```json
{
    "body": "**Work_Issues:** Fix doc strings",
    "created_at": "2019-09-11T10:14:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552885",
    "user": "https://github.com/simon-king-jena"
}
```

**Work_Issues:** Fix doc strings



---

archive/issue_comments_552886.json:
```json
{
    "body": "**Changing commit** from \"[89ac77aa44fd3bab4399791fa72e088a52058a8e](https://github.com/sagemath/sagetrac-mirror/commit/89ac77aa44fd3bab4399791fa72e088a52058a8e)\" to \"[36930248d6df66a94fe8a86d411e9105595eb8e9](https://github.com/sagemath/sagetrac-mirror/commit/36930248d6df66a94fe8a86d411e9105595eb8e9)\".",
    "created_at": "2019-09-11T10:18:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552886",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[89ac77aa44fd3bab4399791fa72e088a52058a8e](https://github.com/sagemath/sagetrac-mirror/commit/89ac77aa44fd3bab4399791fa72e088a52058a8e)" to "[36930248d6df66a94fe8a86d411e9105595eb8e9](https://github.com/sagemath/sagetrac-mirror/commit/36930248d6df66a94fe8a86d411e9105595eb8e9)".



---

archive/issue_comments_552887.json:
```json
{
    "body": "<a id='comment:73'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/36930248d6df66a94fe8a86d411e9105595eb8e9\">3693024</a></td><td><code>Fix doc strings in sage.misc.persist</code></td></tr></table>\n",
    "created_at": "2019-09-11T10:18:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552887",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:73'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/36930248d6df66a94fe8a86d411e9105595eb8e9">3693024</a></td><td><code>Fix doc strings in sage.misc.persist</code></td></tr></table>




---

archive/issue_comments_552888.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2019-09-11T10:18:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552888",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_552889.json:
```json
{
    "body": "**Changing work_issues** from \"Fix doc strings\" to \"\".",
    "created_at": "2019-09-11T10:18:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552889",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "Fix doc strings" to "".



---

archive/issue_comments_552890.json:
```json
{
    "body": "<a id='comment:74'></a>\nFixed, I hope.",
    "created_at": "2019-09-11T10:18:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552890",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:74'></a>
Fixed, I hope.



---

archive/issue_comments_552891.json:
```json
{
    "body": "<a id='comment:75'></a>\nOn OS X, all tests pass with both Python 2 and Python 3. I don't have any comments on the actual code.",
    "created_at": "2019-09-13T20:21:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552891",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:75'></a>
On OS X, all tests pass with both Python 2 and Python 3. I don't have any comments on the actual code.



---

archive/issue_comments_552892.json:
```json
{
    "body": "<a id='comment:76'></a>\nPerhaps to improve maintainability for the future, document the uses in unpickling routines by explicitly mentioning something along the lines of\n\n```\n# Legacy pickles from Python 2 do not distinguish between str and bytes type objects.\n# While we expect a \"bytes\" type object here, it could arrive here as a \"str\" object, for instance\n# if unpickle was passed the argument \"encoding='latin1'\". In that case we convert the \"str\" to\n# a \"bytes\" object using \"encoding='latin1'\". If the object is already a \"bytes\" object, then\n# str_to_bytes will return it unchanged.\n```\nbecause the use of \"str_to_bytes\" would indicate for the uninitiated reader that a \"str\" object is expected, whereas the main code path is actually through \"bytes\". The \"str\" case only arises in legacy cases.",
    "created_at": "2019-09-13T22:29:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552892",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:76'></a>
Perhaps to improve maintainability for the future, document the uses in unpickling routines by explicitly mentioning something along the lines of

```
# Legacy pickles from Python 2 do not distinguish between str and bytes type objects.
# While we expect a "bytes" type object here, it could arrive here as a "str" object, for instance
# if unpickle was passed the argument "encoding='latin1'". In that case we convert the "str" to
# a "bytes" object using "encoding='latin1'". If the object is already a "bytes" object, then
# str_to_bytes will return it unchanged.
```
because the use of "str_to_bytes" would indicate for the uninitiated reader that a "str" object is expected, whereas the main code path is actually through "bytes". The "str" case only arises in legacy cases.



---

archive/issue_comments_552893.json:
```json
{
    "body": "<a id='comment:77'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f0828eea650db44b6a5fd6c8f16a8382ff82f04a\">f0828ee</a></td><td><code>Add a comment regarding the expected data type for an unpickle helper</code></td></tr></table>\n",
    "created_at": "2019-09-15T11:39:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552893",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:77'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f0828eea650db44b6a5fd6c8f16a8382ff82f04a">f0828ee</a></td><td><code>Add a comment regarding the expected data type for an unpickle helper</code></td></tr></table>




---

archive/issue_comments_552894.json:
```json
{
    "body": "**Changing commit** from \"[36930248d6df66a94fe8a86d411e9105595eb8e9](https://github.com/sagemath/sagetrac-mirror/commit/36930248d6df66a94fe8a86d411e9105595eb8e9)\" to \"[f0828eea650db44b6a5fd6c8f16a8382ff82f04a](https://github.com/sagemath/sagetrac-mirror/commit/f0828eea650db44b6a5fd6c8f16a8382ff82f04a)\".",
    "created_at": "2019-09-15T11:39:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552894",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[36930248d6df66a94fe8a86d411e9105595eb8e9](https://github.com/sagemath/sagetrac-mirror/commit/36930248d6df66a94fe8a86d411e9105595eb8e9)" to "[f0828eea650db44b6a5fd6c8f16a8382ff82f04a](https://github.com/sagemath/sagetrac-mirror/commit/f0828eea650db44b6a5fd6c8f16a8382ff82f04a)".



---

archive/issue_comments_552895.json:
```json
{
    "body": "<a id='comment:78'></a>\nReplying to [nbruin](#comment%3A76):\n> Perhaps to improve maintainability for the future, document the uses in unpickling routines...\n\n\nIs the new commit ok?",
    "created_at": "2019-09-15T11:40:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552895",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:78'></a>
Replying to [nbruin](#comment%3A76):
> Perhaps to improve maintainability for the future, document the uses in unpickling routines...


Is the new commit ok?



---

archive/issue_comments_552896.json:
```json
{
    "body": "<a id='comment:79'></a>\nReplying to [SimonKing](#comment%3A78):\n> Replying to [nbruin](#comment%3A76):\n> > Perhaps to improve maintainability for the future, document the uses in unpickling routines...\n\n> \n> Is the new commit ok?\n\n\nThere are some language errors in the text, but I think the gist of it is clear.",
    "created_at": "2019-09-16T15:51:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552896",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:79'></a>
Replying to [SimonKing](#comment%3A78):
> Replying to [nbruin](#comment%3A76):
> > Perhaps to improve maintainability for the future, document the uses in unpickling routines...

> 
> Is the new commit ok?


There are some language errors in the text, but I think the gist of it is clear.



---

archive/issue_comments_552897.json:
```json
{
    "body": "<a id='comment:80'></a>\n**Branch pushed to git repo; I updated commit sha1.** **New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ba41ebee5b46fb2fb72eae988678ab0579309dc5\">ba41ebe</a></td><td><code>Fix two typos in a comment</code></td></tr></table>\n",
    "created_at": "2019-09-16T16:10:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552897",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:80'></a>
**Branch pushed to git repo; I updated commit sha1.** **New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ba41ebee5b46fb2fb72eae988678ab0579309dc5">ba41ebe</a></td><td><code>Fix two typos in a comment</code></td></tr></table>




---

archive/issue_comments_552898.json:
```json
{
    "body": "**Changing commit** from \"[f0828eea650db44b6a5fd6c8f16a8382ff82f04a](https://github.com/sagemath/sagetrac-mirror/commit/f0828eea650db44b6a5fd6c8f16a8382ff82f04a)\" to \"[ba41ebee5b46fb2fb72eae988678ab0579309dc5](https://github.com/sagemath/sagetrac-mirror/commit/ba41ebee5b46fb2fb72eae988678ab0579309dc5)\".",
    "created_at": "2019-09-16T16:10:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552898",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

**Changing commit** from "[f0828eea650db44b6a5fd6c8f16a8382ff82f04a](https://github.com/sagemath/sagetrac-mirror/commit/f0828eea650db44b6a5fd6c8f16a8382ff82f04a)" to "[ba41ebee5b46fb2fb72eae988678ab0579309dc5](https://github.com/sagemath/sagetrac-mirror/commit/ba41ebee5b46fb2fb72eae988678ab0579309dc5)".



---

archive/issue_comments_552899.json:
```json
{
    "body": "<a id='comment:81'></a>\nReplying to [nbruin](#comment%3A79):\n> There are some language errors in the text, but I think the gist of it is clear.\n\n\nOops, you are right. I tried to fix it. Is it good now?",
    "created_at": "2019-09-16T16:10:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552899",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:81'></a>
Replying to [nbruin](#comment%3A79):
> There are some language errors in the text, but I think the gist of it is clear.


Oops, you are right. I tried to fix it. Is it good now?



---

archive/issue_comments_552900.json:
```json
{
    "body": "**Changing branch** from \"[u/SimonKing/fix_backwards_incompatibility_of_unpickling_in_python_3](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/fix_backwards_incompatibility_of_unpickling_in_python_3)\" to \"[u/jhpalmieri/fix_backwards_incompatibility_of_unpickling_in_python_3](https://github.com/sagemath/sagetrac-mirror/tree/u/jhpalmieri/fix_backwards_incompatibility_of_unpickling_in_python_3)\".",
    "created_at": "2019-09-16T17:42:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552900",
    "user": "https://github.com/jhpalmieri"
}
```

**Changing branch** from "[u/SimonKing/fix_backwards_incompatibility_of_unpickling_in_python_3](https://github.com/sagemath/sagetrac-mirror/tree/u/SimonKing/fix_backwards_incompatibility_of_unpickling_in_python_3)" to "[u/jhpalmieri/fix_backwards_incompatibility_of_unpickling_in_python_3](https://github.com/sagemath/sagetrac-mirror/tree/u/jhpalmieri/fix_backwards_incompatibility_of_unpickling_in_python_3)".



---

archive/issue_comments_552901.json:
```json
{
    "body": "**Changing commit** from \"[ba41ebee5b46fb2fb72eae988678ab0579309dc5](https://github.com/sagemath/sagetrac-mirror/commit/ba41ebee5b46fb2fb72eae988678ab0579309dc5)\" to \"[d7f170f2a2b8371da13d5577770b80868b21a726](https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726)\".",
    "created_at": "2019-09-16T17:42:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552901",
    "user": "https://github.com/jhpalmieri"
}
```

**Changing commit** from "[ba41ebee5b46fb2fb72eae988678ab0579309dc5](https://github.com/sagemath/sagetrac-mirror/commit/ba41ebee5b46fb2fb72eae988678ab0579309dc5)" to "[d7f170f2a2b8371da13d5577770b80868b21a726](https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726)".



---

archive/issue_comments_552902.json:
```json
{
    "body": "<a id='comment:83'></a>\nHere are two more minor fixes.\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a293427ffd5b788451015208c4c84bd257b108fd\">a293427</a></td><td><code>Pass unpickling options to pickle.load, default encoding 'latin1'. Accept both str and bytes in mtx_unpickle</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5973292aebbcc9160a58b58a6cb17b4d97d350e9\">5973292</a></td><td><code>Make str_to_bytes/bytes_to_str accept both str and bytes input.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/96469481834c3fddc15541a9882e67e7fcebf883\">9646948</a></td><td><code>Add tests for #28444</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bfd64bc6d887951329ca75a0b17b98af6a4c4ca2\">bfd64bc</a></td><td><code>Fix keyword for py3-only test</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7e1de270a79e21c5ea02d3942839649ad872b0a9\">7e1de27</a></td><td><code>Fix doc strings in sage.misc.persist</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f4581b69a1ee8b3069db26b522d823ccd607cef6\">f4581b6</a></td><td><code>Add a comment regarding the expected data type for an unpickle helper</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/c4db899b4ba9272067c7db246b6feeff19360ea7\">c4db899</a></td><td><code>Fix two typos in a comment</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726\">d7f170f</a></td><td><code>trac 28444: fix a few typos.</code></td></tr></table>\n",
    "created_at": "2019-09-16T17:42:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552902",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:83'></a>
Here are two more minor fixes.

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a293427ffd5b788451015208c4c84bd257b108fd">a293427</a></td><td><code>Pass unpickling options to pickle.load, default encoding 'latin1'. Accept both str and bytes in mtx_unpickle</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5973292aebbcc9160a58b58a6cb17b4d97d350e9">5973292</a></td><td><code>Make str_to_bytes/bytes_to_str accept both str and bytes input.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/96469481834c3fddc15541a9882e67e7fcebf883">9646948</a></td><td><code>Add tests for #28444</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bfd64bc6d887951329ca75a0b17b98af6a4c4ca2">bfd64bc</a></td><td><code>Fix keyword for py3-only test</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7e1de270a79e21c5ea02d3942839649ad872b0a9">7e1de27</a></td><td><code>Fix doc strings in sage.misc.persist</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f4581b69a1ee8b3069db26b522d823ccd607cef6">f4581b6</a></td><td><code>Add a comment regarding the expected data type for an unpickle helper</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/c4db899b4ba9272067c7db246b6feeff19360ea7">c4db899</a></td><td><code>Fix two typos in a comment</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726">d7f170f</a></td><td><code>trac 28444: fix a few typos.</code></td></tr></table>




---

archive/issue_comments_552903.json:
```json
{
    "body": "<a id='comment:84'></a>\nlooks good to me...",
    "created_at": "2019-09-16T20:31:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552903",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:84'></a>
looks good to me...



---

archive/issue_comments_552904.json:
```json
{
    "body": "**Changing status** from needs_review to positive_review.",
    "created_at": "2019-09-16T21:04:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552904",
    "user": "https://github.com/nbruin"
}
```

**Changing status** from needs_review to positive_review.



---

archive/issue_comments_552905.json:
```json
{
    "body": "**Reviewer:** Nils Bruin",
    "created_at": "2019-09-16T21:04:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552905",
    "user": "https://github.com/nbruin"
}
```

**Reviewer:** Nils Bruin



---

archive/issue_comments_552906.json:
```json
{
    "body": "<a id='comment:85'></a>\nLet's get this out of the door then",
    "created_at": "2019-09-16T21:04:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552906",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:85'></a>
Let's get this out of the door then



---

archive/issue_events_080588.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2019-09-19T22:35:55Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28444#event-80588"
}
```



---

archive/issue_comments_552907.json:
```json
{
    "body": "**Resolution:** fixed",
    "created_at": "2019-09-19T22:35:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552907",
    "user": "https://github.com/vbraun"
}
```

**Resolution:** fixed



---

archive/issue_comments_552908.json:
```json
{
    "body": "**Changing branch** from \"[u/jhpalmieri/fix_backwards_incompatibility_of_unpickling_in_python_3](https://github.com/sagemath/sagetrac-mirror/tree/u/jhpalmieri/fix_backwards_incompatibility_of_unpickling_in_python_3)\" to \"[d7f170f2a2b8371da13d5577770b80868b21a726](https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726)\".",
    "created_at": "2019-09-19T22:35:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552908",
    "user": "https://github.com/vbraun"
}
```

**Changing branch** from "[u/jhpalmieri/fix_backwards_incompatibility_of_unpickling_in_python_3](https://github.com/sagemath/sagetrac-mirror/tree/u/jhpalmieri/fix_backwards_incompatibility_of_unpickling_in_python_3)" to "[d7f170f2a2b8371da13d5577770b80868b21a726](https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726)".



---

archive/issue_comments_552909.json:
```json
{
    "body": "**Changing commit** from \"[d7f170f2a2b8371da13d5577770b80868b21a726](https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726)\" to \"\".",
    "created_at": "2019-10-16T07:38:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552909",
    "user": "https://github.com/soehms"
}
```

**Changing commit** from "[d7f170f2a2b8371da13d5577770b80868b21a726](https://github.com/sagemath/sagetrac-mirror/commit/d7f170f2a2b8371da13d5577770b80868b21a726)" to "".



---

archive/issue_comments_552910.json:
```json
{
    "body": "<a id='comment:87'></a>\nReplying to [SimonKing](#comment%3A28):\n\n> > Simon, maybe it's the right time to change the format of the saved data?\n\n> \n> As I have demonstrated above, a pickle created with Python-3 can be read both with Python-2 and Python-3. So, that side of the problem isn't really urgent for the p_group_cohomology package, I think.\n\n\n\nHi Simon,\n\nrecently I've experimented with data storage using YAML. I also used your examples for that and documented this in an [jupyter notebook](https://trac.sagemath.org/attachment/ticket/28302/demo_yaml.ipynb) attached to #28302.\nIt would be interesting to hear your comment about that.\n\nI tested with Python 2 and 3 on `8.9.rc0` and `8.9.rc1`. As said in the description of the ticket I could read `Py3.sobj` with Python 2 and `8.9.rc0`. This seems to be broken now with `8.9.rc1` (this also happens with newly saved `sobj`-file from Python 3):\n\n```\nsage: load('Py3.sobj')\nTraceback (most recent call last):\n...\nTypeError: expected bytes, unicode found\n```\n\nShould this be acceptable, right now?",
    "created_at": "2019-10-16T07:38:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552910",
    "user": "https://github.com/soehms"
}
```

<a id='comment:87'></a>
Replying to [SimonKing](#comment%3A28):

> > Simon, maybe it's the right time to change the format of the saved data?

> 
> As I have demonstrated above, a pickle created with Python-3 can be read both with Python-2 and Python-3. So, that side of the problem isn't really urgent for the p_group_cohomology package, I think.



Hi Simon,

recently I've experimented with data storage using YAML. I also used your examples for that and documented this in an [jupyter notebook](https://trac.sagemath.org/attachment/ticket/28302/demo_yaml.ipynb) attached to #28302.
It would be interesting to hear your comment about that.

I tested with Python 2 and 3 on `8.9.rc0` and `8.9.rc1`. As said in the description of the ticket I could read `Py3.sobj` with Python 2 and `8.9.rc0`. This seems to be broken now with `8.9.rc1` (this also happens with newly saved `sobj`-file from Python 3):

```
sage: load('Py3.sobj')
Traceback (most recent call last):
...
TypeError: expected bytes, unicode found
```

Should this be acceptable, right now?



---

archive/issue_comments_552911.json:
```json
{
    "body": "<a id='comment:88'></a>\nReplying to [soehms](#comment%3A87):\n> I tested with Python 2 and 3 on `8.9.rc0` and `8.9.rc1`. As said in the description of the ticket I could read `Py3.sobj` with Python 2 and `8.9.rc0`. This seems to be broken now with `8.9.rc1` (this also happens with newly saved `sobj`-file from Python 3):\n> \n> \n> ```\n> sage: load('Py3.sobj')\n> Traceback (most recent call last):\n> ...\n> TypeError: expected bytes, unicode found\n> ```\n\n\nHow did this suddenly pop up?? Sigh.\n \n> Should this be acceptable, right now?\n\n\nPersonally I don't think so. So, I'd appreciate opening a new ticket.",
    "created_at": "2019-10-16T07:56:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28444",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28444#issuecomment-552911",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:88'></a>
Replying to [soehms](#comment%3A87):
> I tested with Python 2 and 3 on `8.9.rc0` and `8.9.rc1`. As said in the description of the ticket I could read `Py3.sobj` with Python 2 and `8.9.rc0`. This seems to be broken now with `8.9.rc1` (this also happens with newly saved `sobj`-file from Python 3):
> 
> 
> ```
> sage: load('Py3.sobj')
> Traceback (most recent call last):
> ...
> TypeError: expected bytes, unicode found
> ```


How did this suddenly pop up?? Sigh.
 
> Should this be acceptable, right now?


Personally I don't think so. So, I'd appreciate opening a new ticket.
