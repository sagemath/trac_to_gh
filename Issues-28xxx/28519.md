# Issue 28519: Metaticket - Tensor Fields, Scalar Fields and Mixed Forms

archive/issues_028282.json:
```json
{
    "body": "There are too many changes going on at once, so that a merge in the end might be difficult. In order to avoid such difficulties and to keep an overview of things that are happening (for me and others), I use this ticket from now on as a metaticket, where all latest changes are merged together. Cross ticket references are possible.\n\nThis metaticket is mainly devoted to the topic of immutability of algebra elements (see discussion below).\n\nThis ticket is related to manifolds and therefore part of the permanent metaticket #18528.\n\n**Things going on:**\n\n- #28554: Scalar Field Restrictions\n- #28562: Better Zero Treatment\n- #28564: Consistent Naming for Tensor and Scalar Fields\n- #28579: Wedge Product with Scalar Fields\n- #28578: Mixed Forms Code Improvements \n- #28628: Restriction Behaviour of Tensor Fields\n\nCC:  @tscrim @egourgoulhon\n\nKeywords: manifolds, tensor fields, mixed forms, scalar fields\n\nAuthor: Michael Jung\n\nDependencies: #28554, #28562, #28564, #28579, #28578\n\nResolution: worksforme\n\nIssue created by migration from https://trac.sagemath.org/ticket/28519\n\n",
    "closed_at": "2019-11-27T08:25:42Z",
    "created_at": "2019-09-19T09:39:33Z",
    "labels": [
        "component: geometry"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "Metaticket - Tensor Fields, Scalar Fields and Mixed Forms",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/28519",
    "user": "https://github.com/DeRhamSource"
}
```
There are too many changes going on at once, so that a merge in the end might be difficult. In order to avoid such difficulties and to keep an overview of things that are happening (for me and others), I use this ticket from now on as a metaticket, where all latest changes are merged together. Cross ticket references are possible.

This metaticket is mainly devoted to the topic of immutability of algebra elements (see discussion below).

This ticket is related to manifolds and therefore part of the permanent metaticket #18528.

**Things going on:**

- #28554: Scalar Field Restrictions
- #28562: Better Zero Treatment
- #28564: Consistent Naming for Tensor and Scalar Fields
- #28579: Wedge Product with Scalar Fields
- #28578: Mixed Forms Code Improvements 
- #28628: Restriction Behaviour of Tensor Fields

CC:  @tscrim @egourgoulhon

Keywords: manifolds, tensor fields, mixed forms, scalar fields

Author: Michael Jung

Dependencies: #28554, #28562, #28564, #28579, #28578

Resolution: worksforme

Issue created by migration from https://trac.sagemath.org/ticket/28519





---

archive/issue_comments_399024.json:
```json
{
    "body": "Changing keywords from \"\" to \"manifolds, mixed forms\".",
    "created_at": "2019-09-22T10:31:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399024",
    "user": "https://github.com/DeRhamSource"
}
```

Changing keywords from "" to "manifolds, mixed forms".



---

archive/issue_comments_399025.json:
```json
{
    "body": "Changing component from PLEASE CHANGE to geometry.",
    "created_at": "2019-09-22T10:31:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399025",
    "user": "https://github.com/DeRhamSource"
}
```

Changing component from PLEASE CHANGE to geometry.



---

archive/issue_comments_399026.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2019-09-22T10:31:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399026",
    "user": "https://github.com/DeRhamSource"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_399027.json:
```json
{
    "body": "<a id='comment:4'></a>Opinions and feedback to the upcoming changes are welcome. :)",
    "created_at": "2019-09-22T11:01:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399027",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:4'></a>Opinions and feedback to the upcoming changes are welcome. :)



---

archive/issue_comments_399028.json:
```json
{
    "body": "<a id='comment:7'></a>New commits:",
    "created_at": "2019-09-23T00:17:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399028",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:7'></a>New commits:



---

archive/issue_comments_399029.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-09-23T00:17:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399029",
    "user": "https://github.com/DeRhamSource"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_399030.json:
```json
{
    "body": "<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-23T13:04:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399030",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:12'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399031.json:
```json
{
    "body": "<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-23T13:24:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399031",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:14'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399032.json:
```json
{
    "body": "<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-23T13:34:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399032",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:15'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399033.json:
```json
{
    "body": "<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-23T13:39:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399033",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:16'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399034.json:
```json
{
    "body": "<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-23T14:08:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399034",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:17'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399035.json:
```json
{
    "body": "<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-23T14:51:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399035",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:18'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399036.json:
```json
{
    "body": "<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-23T14:52:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399036",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:19'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399037.json:
```json
{
    "body": "<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-23T20:38:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399037",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:21'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399038.json:
```json
{
    "body": "<a id='comment:22'></a>Sorry for the mess. In the new branch, the commits are cleared and squashed.\n\nI'm looking forward to your review. :)",
    "created_at": "2019-09-23T20:47:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399038",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:22'></a>Sorry for the mess. In the new branch, the commits are cleared and squashed.

I'm looking forward to your review. :)



---

archive/issue_comments_399039.json:
```json
{
    "body": "<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-25T08:19:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399039",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:23'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399040.json:
```json
{
    "body": "<a id='comment:24'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-25T08:22:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399040",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:24'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399041.json:
```json
{
    "body": "<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-25T15:15:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399041",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399042.json:
```json
{
    "body": "<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-25T15:37:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399042",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:28'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399043.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-09-25T15:50:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399043",
    "user": "https://github.com/DeRhamSource"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_399044.json:
```json
{
    "body": "<a id='comment:32'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-09-27T08:38:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399044",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:32'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399045.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2019-09-27T08:42:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399045",
    "user": "https://github.com/DeRhamSource"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_399046.json:
```json
{
    "body": "<a id='comment:34'></a>Thanks for these improvements in the code.\n\nA quick question: what is the motivation for returning a copy of the zero element of the parent instead of the zero element itself? Returning the zero element is certainly faster. In which case wouldn't it be safe? Moreover in some cases (scalar fields) the zero element is updated when a new chart is added, which is not the case of the copy.",
    "created_at": "2019-09-27T20:11:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399046",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:34'></a>Thanks for these improvements in the code.

A quick question: what is the motivation for returning a copy of the zero element of the parent instead of the zero element itself? Returning the zero element is certainly faster. In which case wouldn't it be safe? Moreover in some cases (scalar fields) the zero element is updated when a new chart is added, which is not the case of the copy.



---

archive/issue_comments_399047.json:
```json
{
    "body": "<a id='comment:35'></a>Thanks for your reply.\n\n> A quick question: what is the motivation for returning a copy of the zero element of the parent instead of the zero element itself? Returning the zero element is certainly faster. In which case wouldn't it be safe?\n\n\nThe method `zero()` of the parent is cached. It might happen that this zero element could be manipulated after some computation returning zero (due to some user written algorithm). I tried to avoid that. Do you think this scenario is too unlikely? If so, we can give up the copies.\n\n> Moreover in some cases (scalar fields) the zero element is updated when a new chart is added, which is not the case of the copy.\n\n\nOh, I was not aware of that. However, a result of an algebraic operation has *always* been a very new instance, which knows only about the current charts and frames. The user should always be aware of that. At this stage, there is no difference to the previous code and it sounds fairly consistent to me.\n\nWhat do you think, which way is most convenient and user friendly?\n\nBest regards,\nMichael",
    "created_at": "2019-09-28T20:35:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399047",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:35'></a>Thanks for your reply.

> A quick question: what is the motivation for returning a copy of the zero element of the parent instead of the zero element itself? Returning the zero element is certainly faster. In which case wouldn't it be safe?


The method `zero()` of the parent is cached. It might happen that this zero element could be manipulated after some computation returning zero (due to some user written algorithm). I tried to avoid that. Do you think this scenario is too unlikely? If so, we can give up the copies.

> Moreover in some cases (scalar fields) the zero element is updated when a new chart is added, which is not the case of the copy.


Oh, I was not aware of that. However, a result of an algebraic operation has *always* been a very new instance, which knows only about the current charts and frames. The user should always be aware of that. At this stage, there is no difference to the previous code and it sounds fairly consistent to me.

What do you think, which way is most convenient and user friendly?

Best regards,
Michael



---

archive/issue_comments_399048.json:
```json
{
    "body": "<a id='comment:36'></a>Replying to [comment:35 gh-DeRhamSource]:\n> \n> The method `zero()` of the parent is cached. It might happen that this zero element could be manipulated after some computation returning zero (due to some user written algorithm). I tried to avoid that. Do you think this scenario is too unlikely? If so, we can give up the copies.\n\n>\n> ...\n\n>\n> Oh, I was not aware of that. However, a result of an algebraic operation has *always* been a very new instance, which knows only about the current charts and frames. The user should always be aware of that. At this stage, there is no difference to the previous code and it sounds fairly consistent to me.\n> \n> What do you think, which way is most convenient and user friendly?\n> \n\n\nThe more I think about it, the more I'm inclined to agree with you. Travis, do you have any thought about this?\n\nAnother remark: some of the proposed changes regarding scalar fields are actually not improvements but feature changes:\n\n- the method `display()` without any argument currently displays the scalar field in all the top charts where the expression is known; you propose to change it to enforce the display in the greatest (sub)charts where the expression can be computed, even if they are not top charts. I'm not sure to agree with that: in the current setting, the output of `display()` is sufficient to fully characterize the scalar field (no loss of information); the extension you propose adds extra computations and results in longer outputs, which can be cumbersome for complicated scalar fields. If the user would like to know the expression of the scalar field in such a subchart, he/her can get it anyway, by passing the chart as the argument of `display()`. \n- regarding the multiplication of scalar fields `f` and `g`, the LaTeX output is changed from `f g` to `f\\cdot g`. Is this for aesthetic reasons only? Personaly I would prefer `f g`, which sounds more standard notation. Maybe the opinion of a third person (Travis?) would be helpful here.",
    "created_at": "2019-10-01T07:39:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399048",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:36'></a>Replying to [comment:35 gh-DeRhamSource]:
> 
> The method `zero()` of the parent is cached. It might happen that this zero element could be manipulated after some computation returning zero (due to some user written algorithm). I tried to avoid that. Do you think this scenario is too unlikely? If so, we can give up the copies.

>
> ...

>
> Oh, I was not aware of that. However, a result of an algebraic operation has *always* been a very new instance, which knows only about the current charts and frames. The user should always be aware of that. At this stage, there is no difference to the previous code and it sounds fairly consistent to me.
> 
> What do you think, which way is most convenient and user friendly?
> 


The more I think about it, the more I'm inclined to agree with you. Travis, do you have any thought about this?

Another remark: some of the proposed changes regarding scalar fields are actually not improvements but feature changes:

- the method `display()` without any argument currently displays the scalar field in all the top charts where the expression is known; you propose to change it to enforce the display in the greatest (sub)charts where the expression can be computed, even if they are not top charts. I'm not sure to agree with that: in the current setting, the output of `display()` is sufficient to fully characterize the scalar field (no loss of information); the extension you propose adds extra computations and results in longer outputs, which can be cumbersome for complicated scalar fields. If the user would like to know the expression of the scalar field in such a subchart, he/her can get it anyway, by passing the chart as the argument of `display()`. 
- regarding the multiplication of scalar fields `f` and `g`, the LaTeX output is changed from `f g` to `f\cdot g`. Is this for aesthetic reasons only? Personaly I would prefer `f g`, which sounds more standard notation. Maybe the opinion of a third person (Travis?) would be helpful here.



---

archive/issue_comments_399049.json:
```json
{
    "body": "<a id='comment:37'></a>Replying to [comment:36 egourgoulhon]:\n> Another remark: some of the proposed changes regarding scalar fields are actually not improvements but feature changes:\n> \n> - the method `display()` without any argument currently displays the scalar field in all the top charts where the expression is known; you propose to change it to enforce the display in the greatest (sub)charts where the expression can be computed, even if they are not top charts. I'm not sure to agree with that: in the current setting, the output of `display()` is sufficient to fully characterize the scalar field (no loss of information); the extension you propose adds extra computations and results in longer outputs, which can be cumbersome for complicated scalar fields. If the user would like to know the expression of the scalar field in such a subchart, he/her can get it anyway, by passing the chart as the argument of `display()`. \n\n\nI tend not to agree. Take for instance the real line with standard \"top\" chart `x` and a continuous scalar field `f` like `f(x)=0 for x<-1`, `f(x)=x+1 for -1<=x<0`, `f(x)=1-x for 0<=x<1` and `f(x)=0 for x>=1`. Indeed, this scalar field is continuous. However, it has no single expression in the top chart, but four different expressions in four subcharts. At this stage, the `display()` command does not present it properly. Therefore, there is a loss of information about the scalar field, which should not happen. Or did I get something wrong?\n\n\n> - regarding the multiplication of scalar fields `f` and `g`, the LaTeX output is changed from `f g` to `f\\cdot g`. Is this for aesthetic reasons only? Personaly I would prefer `f g`, which sounds more standard notation. Maybe the opinion of a third person (Travis?) would be helpful here.\n\n\nIn general, I agree with you. When I write things down, I don't use the multiplication symbol, too. But in this case (imao), I would prefer it in order to avoid potential misunderstandings in the naming and to clarify multiplications by a scalar field -- especially when formulas get long. In addition, the multiplication symbol is more \"formal\", you know? But yes, it is just an aesthetical aspect. \n\nGreetings,\nMichael",
    "created_at": "2019-10-01T09:28:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399049",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:37'></a>Replying to [comment:36 egourgoulhon]:
> Another remark: some of the proposed changes regarding scalar fields are actually not improvements but feature changes:
> 
> - the method `display()` without any argument currently displays the scalar field in all the top charts where the expression is known; you propose to change it to enforce the display in the greatest (sub)charts where the expression can be computed, even if they are not top charts. I'm not sure to agree with that: in the current setting, the output of `display()` is sufficient to fully characterize the scalar field (no loss of information); the extension you propose adds extra computations and results in longer outputs, which can be cumbersome for complicated scalar fields. If the user would like to know the expression of the scalar field in such a subchart, he/her can get it anyway, by passing the chart as the argument of `display()`. 


I tend not to agree. Take for instance the real line with standard "top" chart `x` and a continuous scalar field `f` like `f(x)=0 for x<-1`, `f(x)=x+1 for -1<=x<0`, `f(x)=1-x for 0<=x<1` and `f(x)=0 for x>=1`. Indeed, this scalar field is continuous. However, it has no single expression in the top chart, but four different expressions in four subcharts. At this stage, the `display()` command does not present it properly. Therefore, there is a loss of information about the scalar field, which should not happen. Or did I get something wrong?


> - regarding the multiplication of scalar fields `f` and `g`, the LaTeX output is changed from `f g` to `f\cdot g`. Is this for aesthetic reasons only? Personaly I would prefer `f g`, which sounds more standard notation. Maybe the opinion of a third person (Travis?) would be helpful here.


In general, I agree with you. When I write things down, I don't use the multiplication symbol, too. But in this case (imao), I would prefer it in order to avoid potential misunderstandings in the naming and to clarify multiplications by a scalar field -- especially when formulas get long. In addition, the multiplication symbol is more "formal", you know? But yes, it is just an aesthetical aspect. 

Greetings,
Michael



---

archive/issue_comments_399050.json:
```json
{
    "body": "<a id='comment:38'></a>Replying to [comment:36 egourgoulhon]:\n> Replying to [comment:35 gh-DeRhamSource]:\n> > \n> > The method `zero()` of the parent is cached. It might happen that this zero element could be manipulated after some computation returning zero (due to some user written algorithm). I tried to avoid that. Do you think this scenario is too unlikely? If so, we can give up the copies.\n\n> >\n> > ...\n\n> >\n> > Oh, I was not aware of that. However, a result of an algebraic operation has *always* been a very new instance, which knows only about the current charts and frames. The user should always be aware of that. At this stage, there is no difference to the previous code and it sounds fairly consistent to me.\n> > \n> > What do you think, which way is most convenient and user friendly?\n> > \n\n> \n> The more I think about it, the more I'm inclined to agree with you. Travis, do you have any thought about this?\n\n\nIn nearly every instance in Sage, elements are considered immutable and (algebraic) operations do produce new elements (but sometimes share information because they are treated as immutable objects and some of their parts do not change with such operations). Really there should not be any functional difference between the result of `P.zero()` and creating a new zero instance, and the cached object should be better as it should retain more intermediate computations (say, its values on different charts). If a computation is actually changing some fundamental data, then that is a bug. So I strongly believe you should be using `P.zero()` instead of creating a new zero instance.",
    "created_at": "2019-10-02T01:22:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399050",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:38'></a>Replying to [comment:36 egourgoulhon]:
> Replying to [comment:35 gh-DeRhamSource]:
> > 
> > The method `zero()` of the parent is cached. It might happen that this zero element could be manipulated after some computation returning zero (due to some user written algorithm). I tried to avoid that. Do you think this scenario is too unlikely? If so, we can give up the copies.

> >
> > ...

> >
> > Oh, I was not aware of that. However, a result of an algebraic operation has *always* been a very new instance, which knows only about the current charts and frames. The user should always be aware of that. At this stage, there is no difference to the previous code and it sounds fairly consistent to me.
> > 
> > What do you think, which way is most convenient and user friendly?
> > 

> 
> The more I think about it, the more I'm inclined to agree with you. Travis, do you have any thought about this?


In nearly every instance in Sage, elements are considered immutable and (algebraic) operations do produce new elements (but sometimes share information because they are treated as immutable objects and some of their parts do not change with such operations). Really there should not be any functional difference between the result of `P.zero()` and creating a new zero instance, and the cached object should be better as it should retain more intermediate computations (say, its values on different charts). If a computation is actually changing some fundamental data, then that is a bug. So I strongly believe you should be using `P.zero()` instead of creating a new zero instance.



---

archive/issue_comments_399051.json:
```json
{
    "body": "<a id='comment:39'></a>Replying to [comment:38 tscrim]:\n> In nearly every instance in Sage, elements are considered immutable and (algebraic) operations do produce new elements (but sometimes share information because they are treated as immutable objects and some of their parts do not change with such operations). Really there should not be any functional difference between the result of `P.zero()` and creating a new zero instance, and the cached object should be better as it should retain more intermediate computations (say, its values on different charts). If a computation is actually changing some fundamental data, then that is a bug. So I strongly believe you should be using `P.zero()` instead of creating a new zero instance.\n\n\nAnd what about keeping an instance of zero internally, changing it internally, and returning a copy of it via `zero()`? Then, the zero is safe, anyway.\n\nHowever, my thoughts on this were the following: Assume someone is filling up a mixed form with zeroes and uses the `set_restriction` method, which invokes all `set_restriction` methods of its components, to get a new form (just for convenience because most of the components of the resulting mixed form shall be zero in the end). Then, this has an effect on the cached zero elements. Because of that, I decided to copy all the components of the mixed form before declaring them. For consistency reasons I changed everything up like it is now.\n\nDo you have a better suggestion for this kind of situation? And how would you manage it: Copies or no copies for mixed forms?",
    "created_at": "2019-10-02T09:10:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399051",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:39'></a>Replying to [comment:38 tscrim]:
> In nearly every instance in Sage, elements are considered immutable and (algebraic) operations do produce new elements (but sometimes share information because they are treated as immutable objects and some of their parts do not change with such operations). Really there should not be any functional difference between the result of `P.zero()` and creating a new zero instance, and the cached object should be better as it should retain more intermediate computations (say, its values on different charts). If a computation is actually changing some fundamental data, then that is a bug. So I strongly believe you should be using `P.zero()` instead of creating a new zero instance.


And what about keeping an instance of zero internally, changing it internally, and returning a copy of it via `zero()`? Then, the zero is safe, anyway.

However, my thoughts on this were the following: Assume someone is filling up a mixed form with zeroes and uses the `set_restriction` method, which invokes all `set_restriction` methods of its components, to get a new form (just for convenience because most of the components of the resulting mixed form shall be zero in the end). Then, this has an effect on the cached zero elements. Because of that, I decided to copy all the components of the mixed form before declaring them. For consistency reasons I changed everything up like it is now.

Do you have a better suggestion for this kind of situation? And how would you manage it: Copies or no copies for mixed forms?



---

archive/issue_comments_399052.json:
```json
{
    "body": "<a id='comment:40'></a>Replying to [comment:39 gh-DeRhamSource]:\n> Replying to [comment:38 tscrim]:\n> > In nearly every instance in Sage, elements are considered immutable and (algebraic) operations do produce new elements (but sometimes share information because they are treated as immutable objects and some of their parts do not change with such operations). Really there should not be any functional difference between the result of `P.zero()` and creating a new zero instance, and the cached object should be better as it should retain more intermediate computations (say, its values on different charts). If a computation is actually changing some fundamental data, then that is a bug. So I strongly believe you should be using `P.zero()` instead of creating a new zero instance.\n\n> \n> And what about keeping an instance of zero internally, changing it internally, and returning a copy of it via `zero()`? Then, the zero is safe, anyway.\n\n\n-1 as that defeats the purpose.\n\n> However, my thoughts on this were the following: Assume someone is filling up a mixed form with zeroes and uses the `set_restriction` method, which invokes all `set_restriction` methods of its components, to get a new form (just for convenience because most of the components of the resulting mixed form shall be zero in the end). Then, this has an effect on the cached zero elements. Because of that, I decided to copy all the components of the mixed form before declaring them. For consistency reasons I changed everything up like it is now.\n\n\nIf that fundamentally changes the zero from what it is intended to representation, which it sounds like you are saying it does (I am a bit out of my depth mathematically here), then that is a bug with the `set_restriction` method. This might a little better/easier for me to see with a more explicit example.\n\n> Do you have a better suggestion for this kind of situation? And how would you manage it: Copies or no copies for mixed forms?\n\n\nIf there really is no other way out of this with keeping the cached behavior, then you have to manually copy the elements when creating the mixed forms.",
    "created_at": "2019-10-02T11:35:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399052",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:40'></a>Replying to [comment:39 gh-DeRhamSource]:
> Replying to [comment:38 tscrim]:
> > In nearly every instance in Sage, elements are considered immutable and (algebraic) operations do produce new elements (but sometimes share information because they are treated as immutable objects and some of their parts do not change with such operations). Really there should not be any functional difference between the result of `P.zero()` and creating a new zero instance, and the cached object should be better as it should retain more intermediate computations (say, its values on different charts). If a computation is actually changing some fundamental data, then that is a bug. So I strongly believe you should be using `P.zero()` instead of creating a new zero instance.

> 
> And what about keeping an instance of zero internally, changing it internally, and returning a copy of it via `zero()`? Then, the zero is safe, anyway.


-1 as that defeats the purpose.

> However, my thoughts on this were the following: Assume someone is filling up a mixed form with zeroes and uses the `set_restriction` method, which invokes all `set_restriction` methods of its components, to get a new form (just for convenience because most of the components of the resulting mixed form shall be zero in the end). Then, this has an effect on the cached zero elements. Because of that, I decided to copy all the components of the mixed form before declaring them. For consistency reasons I changed everything up like it is now.


If that fundamentally changes the zero from what it is intended to representation, which it sounds like you are saying it does (I am a bit out of my depth mathematically here), then that is a bug with the `set_restriction` method. This might a little better/easier for me to see with a more explicit example.

> Do you have a better suggestion for this kind of situation? And how would you manage it: Copies or no copies for mixed forms?


If there really is no other way out of this with keeping the cached behavior, then you have to manually copy the elements when creating the mixed forms.



---

archive/issue_comments_399053.json:
```json
{
    "body": "<a id='comment:41'></a>Here comes an examples, like it is now (without copies):\n\n```\nsage: S2 = Manifold(2, 'S^2')\nsage: U = S2.open_subset('U') ; V = S2.open_subset('V') # complement of the North and South pole, respectively\nsage: S2.declare_union(U,V)\nsage: stereoN.<x,y> = U.chart() # stereographic coordinates from the North pole\nsage: stereoS.<u,v> = V.chart() # stereographic coordinates from the South pole\nsage: xy_to_uv = stereoN.transition_map(stereoS,\n....:                                   (x/(x^2+y^2), y/(x^2+y^2)),\n....:                                   intersection_name='W',\n....:                                   restrictions1= x^2+y^2!=0,\n....:                                   restrictions2= u^2+v^2!=0)\nsage: W = U.intersection(V)\nsage: uv_to_xy = xy_to_uv.inverse()\nsage: omegaU = U.diff_form(1, name='omega')\nsage: omegaU[:] = [2,3]; omegaU.display()\nomega = 2 dx + 3 dy\nsage: FU = U.mixed_form(name='F')\nsage: FU[:] = [1,omegaU,0]\nsage: FU.display()\nF = (unnamed scalar field)  + omega + zero\nsage: F = S2.mixed_form(name='F')\nsage: F[:] = [0,0,0]\nsage: F.set_restriction(FU)\nsage: F.display()\nF = zero + zero + zero\nsage: F[1].display()\nzero = 2 dx + 3 dy\nsage: F[1] is S2.diff_form_module(1).zero()\nTrue\n```\n\nBut now, I see your point. The restriction is called `zero` and this indicates that this **is** the immutable zero element, no matter what. The user should be aware of that.\n\nBut then, the `set_restriction` method is not useful anymore. It was introduced to facilitate things -- setting the restriction of all forms in just one command (for future implementations).\n\nAny ideas how to solve this?",
    "created_at": "2019-10-02T12:03:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399053",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:41'></a>Here comes an examples, like it is now (without copies):

```
sage: S2 = Manifold(2, 'S^2')
sage: U = S2.open_subset('U') ; V = S2.open_subset('V') # complement of the North and South pole, respectively
sage: S2.declare_union(U,V)
sage: stereoN.<x,y> = U.chart() # stereographic coordinates from the North pole
sage: stereoS.<u,v> = V.chart() # stereographic coordinates from the South pole
sage: xy_to_uv = stereoN.transition_map(stereoS,
....:                                   (x/(x^2+y^2), y/(x^2+y^2)),
....:                                   intersection_name='W',
....:                                   restrictions1= x^2+y^2!=0,
....:                                   restrictions2= u^2+v^2!=0)
sage: W = U.intersection(V)
sage: uv_to_xy = xy_to_uv.inverse()
sage: omegaU = U.diff_form(1, name='omega')
sage: omegaU[:] = [2,3]; omegaU.display()
omega = 2 dx + 3 dy
sage: FU = U.mixed_form(name='F')
sage: FU[:] = [1,omegaU,0]
sage: FU.display()
F = (unnamed scalar field)  + omega + zero
sage: F = S2.mixed_form(name='F')
sage: F[:] = [0,0,0]
sage: F.set_restriction(FU)
sage: F.display()
F = zero + zero + zero
sage: F[1].display()
zero = 2 dx + 3 dy
sage: F[1] is S2.diff_form_module(1).zero()
True
```

But now, I see your point. The restriction is called `zero` and this indicates that this **is** the immutable zero element, no matter what. The user should be aware of that.

But then, the `set_restriction` method is not useful anymore. It was introduced to facilitate things -- setting the restriction of all forms in just one command (for future implementations).

Any ideas how to solve this?



---

archive/issue_comments_399054.json:
```json
{
    "body": "<a id='comment:42'></a>But then, one question arises for me: Due to your argument that all algebraic objects are considered immutable, the addition with zero should not return a copy, then:\n\n```\n        # Special cases:\n        if self._is_zero:\n            return other.copy()\n        if other._is_zero:\n            return self.copy()\n```\n \nThis is a snippet from the previous code of `scalarfield.py` in the method `_add_`. This should be changed, right? In addition, returning the very same instance is faster.",
    "created_at": "2019-10-02T17:10:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399054",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:42'></a>But then, one question arises for me: Due to your argument that all algebraic objects are considered immutable, the addition with zero should not return a copy, then:

```
        # Special cases:
        if self._is_zero:
            return other.copy()
        if other._is_zero:
            return self.copy()
```
 
This is a snippet from the previous code of `scalarfield.py` in the method `_add_`. This should be changed, right? In addition, returning the very same instance is faster.



---

archive/issue_comments_399055.json:
```json
{
    "body": "<a id='comment:43'></a>Replying to [comment:42 gh-DeRhamSource]:\n> But then, one question arises for me: Due to your argument that all algebraic objects are considered immutable, the addition with zero should not return a copy, then:\n> \n> \n> ```\n>         # Special cases:\n>         if self._is_zero:\n>             return other.copy()\n>         if other._is_zero:\n>             return self.copy()\n> ```\n>  \n> This is a snippet from the previous code of `scalarfield.py` in the method `_add_`. This should be changed, right? In addition, returning the very same instance is faster. \n\n\nYes, I agree that should be changed to return same instance.\n\nHowever, I am not sure I understand why `set_restriction` is not useful anymore. What about if there are other forms?",
    "created_at": "2019-10-03T01:32:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399055",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:43'></a>Replying to [comment:42 gh-DeRhamSource]:
> But then, one question arises for me: Due to your argument that all algebraic objects are considered immutable, the addition with zero should not return a copy, then:
> 
> 
> ```
>         # Special cases:
>         if self._is_zero:
>             return other.copy()
>         if other._is_zero:
>             return self.copy()
> ```
>  
> This is a snippet from the previous code of `scalarfield.py` in the method `_add_`. This should be changed, right? In addition, returning the very same instance is faster. 


Yes, I agree that should be changed to return same instance.

However, I am not sure I understand why `set_restriction` is not useful anymore. What about if there are other forms?



---

archive/issue_comments_399056.json:
```json
{
    "body": "<a id='comment:44'></a>Replying to [comment:43 tscrim]:\n> Yes, I agree that should be changed to return same instance.\n\n\nI'll change this. \n\n> However, I am not sure I understand why `set_restriction` is not useful anymore. What about if there are other forms?\n\n\nOnce a differential form is established and ready for further use, it shall be considered as immutable, right? When a mixed form is fed by these forms, `set_restriction` alters the as immutable seen forms, which should not happen due to your consideration.\n\nPerhaps it is better to implement a mixed form as an own independent algebraic object which should be initialized in a similar way as differential forms. The components must be set individually anyway. What do you think?",
    "created_at": "2019-10-03T11:13:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399056",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:44'></a>Replying to [comment:43 tscrim]:
> Yes, I agree that should be changed to return same instance.


I'll change this. 

> However, I am not sure I understand why `set_restriction` is not useful anymore. What about if there are other forms?


Once a differential form is established and ready for further use, it shall be considered as immutable, right? When a mixed form is fed by these forms, `set_restriction` alters the as immutable seen forms, which should not happen due to your consideration.

Perhaps it is better to implement a mixed form as an own independent algebraic object which should be initialized in a similar way as differential forms. The components must be set individually anyway. What do you think?



---

archive/issue_comments_399057.json:
```json
{
    "body": "<a id='comment:45'></a>Thanks to both of you for this interesting and constructive discussion. Sorry for the delay in replying (I was AFAK for a while).\n\nReplying to [comment:43 tscrim]:\n> Replying to [comment:42 gh-DeRhamSource]:\n> > But then, one question arises for me: Due to your argument that all algebraic objects are considered immutable, the addition with zero should not return a copy, then:\n> > \n> > \n> > ```\n> >         # Special cases:\n> >         if self._is_zero:\n> >             return other.copy()\n> >         if other._is_zero:\n> >             return self.copy()\n> > ```\n> >  \n> > This is a snippet from the previous code of `scalarfield.py` in the method `_add_`. This should be changed, right? In addition, returning the very same instance is faster. \n\n> \n> Yes, I agree that should be changed to return same instance.\n> \n\n\nThe point is that tensor field objects (including scalar fields and differential forms) are not immutable, except for the zero element. They cannot be made immutable because, in general, they cannot be fully defined at their creation: they are defined \"on the fly\" by adding some piece of information like\n\n```\nsage: s.add_expr(1+x, chart=X)\nsage: t[0,1] = 1+x\n```\nfor a scalar field `s` and a tensor field `t`.\n\nThings are different for the zero elements: they are fully defined at their creation and they should be immutable. This is not enforced though, and we have currently the following garbage in / garbage out  bugs:\n\n```\nsage: M = Manifold(2, 'M')\nsage: X.<x,y> = M.chart()\nsage: zv = M.vector_field_module().zero()\nsage: zv.display()\nzero = 0\nsage: zv[0] = 1 + x  # this should not be allowed!\nsage: zv.display()\nzero = (x + 1) d/dx\nsage: zv is M.vector_field_module().zero()  # ouch!\nTrue\nsage: zs = M.scalar_field_algebra().zero()\nsage: zs.display()\nzero: M --> R\n   (x, y) |--> 0\nsage: zs.set_expr(1 + x)  # this should not be allowed!\nsage: zs.display()\nzero: M --> R\n   (x, y) |--> x + 1\nsage: zs is M.scalar_field_algebra().zero()  # ouch!\nTrue\n```\nThe natural way to enforce the immutability of the zero element would be to subclass the element class. Unfortunately, this turns out to be impossible in Sage's !Parent/Element framework, cf. this [sage-devel discussion](https://groups.google.com/forum/#!topic/sage-devel/tZW9T-AixBQ).\n\n\n> However, I am not sure I understand why `set_restriction` is not useful anymore. What about if there are other forms?\n\n\n`set_restriction` should handle properly the zero case: if some element is a zero element, then it should replace it by an ordinary object which equals to zero and apply the restriction to it, making it no longer equal to zero.",
    "created_at": "2019-10-03T11:21:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399057",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:45'></a>Thanks to both of you for this interesting and constructive discussion. Sorry for the delay in replying (I was AFAK for a while).

Replying to [comment:43 tscrim]:
> Replying to [comment:42 gh-DeRhamSource]:
> > But then, one question arises for me: Due to your argument that all algebraic objects are considered immutable, the addition with zero should not return a copy, then:
> > 
> > 
> > ```
> >         # Special cases:
> >         if self._is_zero:
> >             return other.copy()
> >         if other._is_zero:
> >             return self.copy()
> > ```
> >  
> > This is a snippet from the previous code of `scalarfield.py` in the method `_add_`. This should be changed, right? In addition, returning the very same instance is faster. 

> 
> Yes, I agree that should be changed to return same instance.
> 


The point is that tensor field objects (including scalar fields and differential forms) are not immutable, except for the zero element. They cannot be made immutable because, in general, they cannot be fully defined at their creation: they are defined "on the fly" by adding some piece of information like

```
sage: s.add_expr(1+x, chart=X)
sage: t[0,1] = 1+x
```
for a scalar field `s` and a tensor field `t`.

Things are different for the zero elements: they are fully defined at their creation and they should be immutable. This is not enforced though, and we have currently the following garbage in / garbage out  bugs:

```
sage: M = Manifold(2, 'M')
sage: X.<x,y> = M.chart()
sage: zv = M.vector_field_module().zero()
sage: zv.display()
zero = 0
sage: zv[0] = 1 + x  # this should not be allowed!
sage: zv.display()
zero = (x + 1) d/dx
sage: zv is M.vector_field_module().zero()  # ouch!
True
sage: zs = M.scalar_field_algebra().zero()
sage: zs.display()
zero: M --> R
   (x, y) |--> 0
sage: zs.set_expr(1 + x)  # this should not be allowed!
sage: zs.display()
zero: M --> R
   (x, y) |--> x + 1
sage: zs is M.scalar_field_algebra().zero()  # ouch!
True
```
The natural way to enforce the immutability of the zero element would be to subclass the element class. Unfortunately, this turns out to be impossible in Sage's !Parent/Element framework, cf. this [sage-devel discussion](https://groups.google.com/forum/#!topic/sage-devel/tZW9T-AixBQ).


> However, I am not sure I understand why `set_restriction` is not useful anymore. What about if there are other forms?


`set_restriction` should handle properly the zero case: if some element is a zero element, then it should replace it by an ordinary object which equals to zero and apply the restriction to it, making it no longer equal to zero.



---

archive/issue_comments_399058.json:
```json
{
    "body": "<a id='comment:46'></a>Replying to [comment:37 gh-DeRhamSource]:\n> Replying to [comment:36 egourgoulhon]:\n> > Another remark: some of the proposed changes regarding scalar fields are actually not improvements but feature changes:\n> > \n> > - the method `display()` without any argument currently displays the scalar field in all the top charts where the expression is known; you propose to change it to enforce the display in the greatest (sub)charts where the expression can be computed, even if they are not top charts. I'm not sure to agree with that: in the current setting, the output of `display()` is sufficient to fully characterize the scalar field (no loss of information); the extension you propose adds extra computations and results in longer outputs, which can be cumbersome for complicated scalar fields. If the user would like to know the expression of the scalar field in such a subchart, he/her can get it anyway, by passing the chart as the argument of `display()`. \n \n> \n> I tend not to agree. Take for instance the real line with standard \"top\" chart `x` and a continuous scalar field `f` like `f(x)=0 for x<-1`, `f(x)=x+1 for -1<=x<0`, `f(x)=1-x for 0<=x<1` and `f(x)=0 for x>=1`. Indeed, this scalar field is continuous. However, it has no single expression in the top chart, but four different expressions in four subcharts. At this stage, the `display()` command does not present it properly. Therefore, there is a loss of information about the scalar field, which should not happen. Or did I get something wrong?\n> \n\n\nIn the current implementation, your example scalar field should be defined at the level of the top chart, by something like\n\n```\nf = M.scalar_field( unit_step(x + 1)*unit_step(1 - x)*(1 - abs(x)) )\n```\nIn other words, subcharts are not intended to store key information about piecewise defined functions. Maybe the whole code could be changed to allow for this, since this is certainly more user friendly than the above `unit_step` operations. But this should be done in a different ticket.",
    "created_at": "2019-10-03T11:34:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399058",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:46'></a>Replying to [comment:37 gh-DeRhamSource]:
> Replying to [comment:36 egourgoulhon]:
> > Another remark: some of the proposed changes regarding scalar fields are actually not improvements but feature changes:
> > 
> > - the method `display()` without any argument currently displays the scalar field in all the top charts where the expression is known; you propose to change it to enforce the display in the greatest (sub)charts where the expression can be computed, even if they are not top charts. I'm not sure to agree with that: in the current setting, the output of `display()` is sufficient to fully characterize the scalar field (no loss of information); the extension you propose adds extra computations and results in longer outputs, which can be cumbersome for complicated scalar fields. If the user would like to know the expression of the scalar field in such a subchart, he/her can get it anyway, by passing the chart as the argument of `display()`. 
 
> 
> I tend not to agree. Take for instance the real line with standard "top" chart `x` and a continuous scalar field `f` like `f(x)=0 for x<-1`, `f(x)=x+1 for -1<=x<0`, `f(x)=1-x for 0<=x<1` and `f(x)=0 for x>=1`. Indeed, this scalar field is continuous. However, it has no single expression in the top chart, but four different expressions in four subcharts. At this stage, the `display()` command does not present it properly. Therefore, there is a loss of information about the scalar field, which should not happen. Or did I get something wrong?
> 


In the current implementation, your example scalar field should be defined at the level of the top chart, by something like

```
f = M.scalar_field( unit_step(x + 1)*unit_step(1 - x)*(1 - abs(x)) )
```
In other words, subcharts are not intended to store key information about piecewise defined functions. Maybe the whole code could be changed to allow for this, since this is certainly more user friendly than the above `unit_step` operations. But this should be done in a different ticket.



---

archive/issue_comments_399059.json:
```json
{
    "body": "<a id='comment:47'></a>Replying to [comment:45 egourgoulhon]:\n> The natural way to enforce the immutability of the zero element would be to subclass the element class. Unfortunately, this turns out to be impossible in Sage's !Parent/Element framework, cf. this [sage-devel discussion](https://groups.google.com/forum/#!topic/sage-devel/tZW9T-AixBQ).\n> \n\nSee also [this thread](https://groups.google.com/forum/#!topic/sage-devel/F7DTZXYaw48), which might be relevant.",
    "created_at": "2019-10-03T11:41:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399059",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:47'></a>Replying to [comment:45 egourgoulhon]:
> The natural way to enforce the immutability of the zero element would be to subclass the element class. Unfortunately, this turns out to be impossible in Sage's !Parent/Element framework, cf. this [sage-devel discussion](https://groups.google.com/forum/#!topic/sage-devel/tZW9T-AixBQ).
> 

See also [this thread](https://groups.google.com/forum/#!topic/sage-devel/F7DTZXYaw48), which might be relevant.



---

archive/issue_comments_399060.json:
```json
{
    "body": "<a id='comment:48'></a>Replying to [comment:46 egourgoulhon]:\n> In the current implementation, your example scalar field should be defined at the level of the top chart, by something like\n> \n> ```\n> f = M.scalar_field( unit_step(x + 1)*unit_step(1 - x)*(1 - abs(x)) )\n> ```\n> In other words, subcharts are not intended to store key information about piecewise defined functions. Maybe the whole code could be changed to allow for this, since this is certainly more user friendly than the above `unit_step` operations. But this should be done in a different ticket.\n\n\nCertainly, a `set_restriction` method is way more user friendly and (in my opinion) preferrable -- especially, in order to make the behaviour of scalar fields and tensor fields more consistent. Furthermore, one can use `add_expr_by_continuation` in this case more effectively. \n\nThe `display` method, as it is now in this ticket, can be very slow if the expressions are quite complicated. However, when the user wishes a short computation, he can choose a particular chart in which the caclulation should be done.\n\nThe algorithm I wrote starts from the top chart downwards and immediately stops if an expression is found. So, the computation time depends on how small the scalar field is split. Another approach would be, to display only *known* expressions and compute new expressions only if a particular chart is stated.\n\nI can open a new ticket on this issue if you wish.\n\n(EDIT: I opened a new ticket #28554 regarding this issue.)",
    "created_at": "2019-10-03T16:44:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399060",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:48'></a>Replying to [comment:46 egourgoulhon]:
> In the current implementation, your example scalar field should be defined at the level of the top chart, by something like
> 
> ```
> f = M.scalar_field( unit_step(x + 1)*unit_step(1 - x)*(1 - abs(x)) )
> ```
> In other words, subcharts are not intended to store key information about piecewise defined functions. Maybe the whole code could be changed to allow for this, since this is certainly more user friendly than the above `unit_step` operations. But this should be done in a different ticket.


Certainly, a `set_restriction` method is way more user friendly and (in my opinion) preferrable -- especially, in order to make the behaviour of scalar fields and tensor fields more consistent. Furthermore, one can use `add_expr_by_continuation` in this case more effectively. 

The `display` method, as it is now in this ticket, can be very slow if the expressions are quite complicated. However, when the user wishes a short computation, he can choose a particular chart in which the caclulation should be done.

The algorithm I wrote starts from the top chart downwards and immediately stops if an expression is found. So, the computation time depends on how small the scalar field is split. Another approach would be, to display only *known* expressions and compute new expressions only if a particular chart is stated.

I can open a new ticket on this issue if you wish.

(EDIT: I opened a new ticket #28554 regarding this issue.)



---

archive/issue_comments_399061.json:
```json
{
    "body": "<a id='comment:49'></a>For now, I see two ways to go:\n\n1) We accept that forms are not immutable. Then, copies in every corner are my preferability to avoid unwanted effects.\n\n2) We see forms as immutable **as soon as all components are set** (which seems to make sense).\n\nEither way, we should implement it consistently and make a remark or note in the documentary. What do you say?",
    "created_at": "2019-10-03T17:09:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399061",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:49'></a>For now, I see two ways to go:

1) We accept that forms are not immutable. Then, copies in every corner are my preferability to avoid unwanted effects.

2) We see forms as immutable **as soon as all components are set** (which seems to make sense).

Either way, we should implement it consistently and make a remark or note in the documentary. What do you say?



---

archive/issue_comments_399062.json:
```json
{
    "body": "<a id='comment:52'></a>Adding extra information is not changing the element to me, it is still (suppose to be) representing the same, e.g., tensor field but with more information. Enforcing this is a near impossible task IMO, so we just assume good user input (as I think we should), which preserves the element. Since mathematically we have `x + 0 = x`, a user should not expect that mutating `x+0` is different than mutating `x`.\n\nAlso for the immutability of the zero, ever place you do something that mutates it, just add a check for the `_is_zero` and raise an error if you do mutate it since it is a special element.",
    "created_at": "2019-10-04T00:30:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399062",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:52'></a>Adding extra information is not changing the element to me, it is still (suppose to be) representing the same, e.g., tensor field but with more information. Enforcing this is a near impossible task IMO, so we just assume good user input (as I think we should), which preserves the element. Since mathematically we have `x + 0 = x`, a user should not expect that mutating `x+0` is different than mutating `x`.

Also for the immutability of the zero, ever place you do something that mutates it, just add a check for the `_is_zero` and raise an error if you do mutate it since it is a special element.



---

archive/issue_comments_399063.json:
```json
{
    "body": "<a id='comment:53'></a>Okay. I'm going to create a new branch. Due to our discussion, treating the components of mixed forms as immutable/fixed -- in the sense of our previous argumentation -- is an appropriate way, in my opinion.\n\nThe issues about scalar fields are mainly moved to ticket #28554. I guess, a whole new discussion arises there.\n\nDo you agree?",
    "created_at": "2019-10-04T08:38:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399063",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:53'></a>Okay. I'm going to create a new branch. Due to our discussion, treating the components of mixed forms as immutable/fixed -- in the sense of our previous argumentation -- is an appropriate way, in my opinion.

The issues about scalar fields are mainly moved to ticket #28554. I guess, a whole new discussion arises there.

Do you agree?



---

archive/issue_comments_399064.json:
```json
{
    "body": "<a id='comment:54'></a>Replying to [comment:48 gh-DeRhamSource]:\n> \n> I can open a new ticket on this issue if you wish.\n> \n> (EDIT: I opened a new ticket #28554 regarding this issue.)\n\n\nVery good. I've added it to the metaticket #18528 (btw, feel free to add a link in the metaticket each time you open a ticket related to manifolds).",
    "created_at": "2019-10-04T14:34:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399064",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:54'></a>Replying to [comment:48 gh-DeRhamSource]:
> 
> I can open a new ticket on this issue if you wish.
> 
> (EDIT: I opened a new ticket #28554 regarding this issue.)


Very good. I've added it to the metaticket #18528 (btw, feel free to add a link in the metaticket each time you open a ticket related to manifolds).



---

archive/issue_comments_399065.json:
```json
{
    "body": "<a id='comment:55'></a>Replying to [comment:52 tscrim]:\n> Adding extra information is not changing the element to me, it is still (suppose to be) representing the same, e.g., tensor field but with more information. Enforcing this is a near impossible task IMO, so we just assume good user input (as I think we should), which preserves the element. Since mathematically we have `x + 0 = x`, a user should not expect that mutating `x+0` is different than mutating `x`.\n> \n\n\n+1\n\n> Also for the immutability of the zero, ever place you do something that mutates it, just add a check for the `_is_zero` and raise an error if you do mutate it since it is a special element.\n\n\n+1",
    "created_at": "2019-10-04T14:43:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399065",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:55'></a>Replying to [comment:52 tscrim]:
> Adding extra information is not changing the element to me, it is still (suppose to be) representing the same, e.g., tensor field but with more information. Enforcing this is a near impossible task IMO, so we just assume good user input (as I think we should), which preserves the element. Since mathematically we have `x + 0 = x`, a user should not expect that mutating `x+0` is different than mutating `x`.
> 


+1

> Also for the immutability of the zero, ever place you do something that mutates it, just add a check for the `_is_zero` and raise an error if you do mutate it since it is a special element.


+1



---

archive/issue_comments_399066.json:
```json
{
    "body": "<a id='comment:56'></a>Replying to [comment:53 gh-DeRhamSource]:\n> Okay. I'm going to create a new branch. Due to our discussion, treating the components of mixed forms as immutable/fixed -- in the sense of our previous argumentation -- is an appropriate way, in my opinion.\n> \n> The issues about scalar fields are mainly moved to ticket #28554. I guess, a whole new discussion arises there.\n> \n> Do you agree?\n\n\nYes, it is usually good to split different issues in various tickets.",
    "created_at": "2019-10-04T14:47:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399066",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:56'></a>Replying to [comment:53 gh-DeRhamSource]:
> Okay. I'm going to create a new branch. Due to our discussion, treating the components of mixed forms as immutable/fixed -- in the sense of our previous argumentation -- is an appropriate way, in my opinion.
> 
> The issues about scalar fields are mainly moved to ticket #28554. I guess, a whole new discussion arises there.
> 
> Do you agree?


Yes, it is usually good to split different issues in various tickets.



---

archive/issue_comments_399067.json:
```json
{
    "body": "<a id='comment:57'></a>Replying to [comment:49 gh-DeRhamSource]:\n\n> Either way, we should implement it consistently and make a remark or note in the documentary. What do you say?\n\n\n+1 for consistency and documentation. It's true that scalar fields and tensor fields (including differential forms) have been implemented in separate stages (cf. #18528) and have been subsequently modified in possible different ways. This results in some inconsistencies in the user interface. For instance:\n\n- tensor fields have a method `set_restriction()`, while scalar fields do not (as you noticed)\n- scalar fields have a fast method `is_trivial_zero()`, while tensor fields do not\n\nThanks for having a look into this.",
    "created_at": "2019-10-04T14:59:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399067",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:57'></a>Replying to [comment:49 gh-DeRhamSource]:

> Either way, we should implement it consistently and make a remark or note in the documentary. What do you say?


+1 for consistency and documentation. It's true that scalar fields and tensor fields (including differential forms) have been implemented in separate stages (cf. #18528) and have been subsequently modified in possible different ways. This results in some inconsistencies in the user interface. For instance:

- tensor fields have a method `set_restriction()`, while scalar fields do not (as you noticed)
- scalar fields have a fast method `is_trivial_zero()`, while tensor fields do not

Thanks for having a look into this.



---

archive/issue_comments_399068.json:
```json
{
    "body": "<a id='comment:58'></a>Replying to [comment:52 tscrim]:\n> Also for the immutability of the zero, ever place you do something that mutates it, just add a check for the `_is_zero` and raise an error if you do mutate it since it is a special element.\n\n\nThe `_is_zero` attribute changes whenever a component is changed or `bool` is used. So, I'd prefer something like\n\n```\nif self is self._parent_zero:\n    raise AssertionError(\"...\")\n```\n\nDo you agree? I would do the same thing for the one element of scalar fields.",
    "created_at": "2019-10-04T15:10:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399068",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:58'></a>Replying to [comment:52 tscrim]:
> Also for the immutability of the zero, ever place you do something that mutates it, just add a check for the `_is_zero` and raise an error if you do mutate it since it is a special element.


The `_is_zero` attribute changes whenever a component is changed or `bool` is used. So, I'd prefer something like

```
if self is self._parent_zero:
    raise AssertionError("...")
```

Do you agree? I would do the same thing for the one element of scalar fields.



---

archive/issue_comments_399069.json:
```json
{
    "body": "<a id='comment:59'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2019-10-04T23:19:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399069",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:59'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_399070.json:
```json
{
    "body": "<a id='comment:60'></a>Replying to [comment:58 gh-DeRhamSource]:\n> Replying to [comment:52 tscrim]:\n> > Also for the immutability of the zero, ever place you do something that mutates it, just add a check for the `_is_zero` and raise an error if you do mutate it since it is a special element.\n\n> \n> The `_is_zero` attribute changes whenever a component is changed or `bool` is used. So, I'd prefer something like\n> \n> ```\n> if self is self._parent_zero:\n>     raise AssertionError(\"...\")\n> ```\n> \n> Do you agree? I would do the same thing for the one element of scalar fields.\n\n\nNah. Certainly, this will not work! The zero element is altered by using the component manipulation methods. This will raise an immediate error. By the way, the same problem will arise when we use the `_is_zero` attribute and add a new chart.\n\nMaybe, the zero element should be altered internally via the `_comp` attribute and any invokation of `add_comp`, `set_comp` etc. should be forbidden for this element. What do you say?",
    "created_at": "2019-10-05T09:45:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399070",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:60'></a>Replying to [comment:58 gh-DeRhamSource]:
> Replying to [comment:52 tscrim]:
> > Also for the immutability of the zero, ever place you do something that mutates it, just add a check for the `_is_zero` and raise an error if you do mutate it since it is a special element.

> 
> The `_is_zero` attribute changes whenever a component is changed or `bool` is used. So, I'd prefer something like
> 
> ```
> if self is self._parent_zero:
>     raise AssertionError("...")
> ```
> 
> Do you agree? I would do the same thing for the one element of scalar fields.


Nah. Certainly, this will not work! The zero element is altered by using the component manipulation methods. This will raise an immediate error. By the way, the same problem will arise when we use the `_is_zero` attribute and add a new chart.

Maybe, the zero element should be altered internally via the `_comp` attribute and any invokation of `add_comp`, `set_comp` etc. should be forbidden for this element. What do you say?



---

archive/issue_comments_399071.json:
```json
{
    "body": "<a id='comment:61'></a>Replying to [comment:60 gh-DeRhamSource]:\n> Replying to [comment:58 gh-DeRhamSource]:\n> > \n> > The `_is_zero` attribute changes whenever a component is changed or `bool` is used. So, I'd prefer something like\n> > \n> > ```\n> > if self is self._parent_zero:\n> >     raise AssertionError(\"...\")\n> > ```\n> > \n> > Do you agree? I would do the same thing for the one element of scalar fields.\n\n> \n> Nah. Certainly, this will not work! The zero element is altered by using the component manipulation methods. This will raise an immediate error. By the way, the same problem will arise when we use the `_is_zero` attribute and add a new chart.\n> \n  \nI would have written\n\n```\nif self is self.parent().zero():\n    raise AssertionError(\"...\")\n```\nCan you be more specific about the fact that this would not work?",
    "created_at": "2019-10-05T10:58:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399071",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:61'></a>Replying to [comment:60 gh-DeRhamSource]:
> Replying to [comment:58 gh-DeRhamSource]:
> > 
> > The `_is_zero` attribute changes whenever a component is changed or `bool` is used. So, I'd prefer something like
> > 
> > ```
> > if self is self._parent_zero:
> >     raise AssertionError("...")
> > ```
> > 
> > Do you agree? I would do the same thing for the one element of scalar fields.

> 
> Nah. Certainly, this will not work! The zero element is altered by using the component manipulation methods. This will raise an immediate error. By the way, the same problem will arise when we use the `_is_zero` attribute and add a new chart.
> 
  
I would have written

```
if self is self.parent().zero():
    raise AssertionError("...")
```
Can you be more specific about the fact that this would not work?



---

archive/issue_comments_399072.json:
```json
{
    "body": "<a id='comment:62'></a>Replying to [comment:61 egourgoulhon]:\n> I would have written\n> \n> ```\n> if self is self.parent().zero():\n>     raise AssertionError(\"...\")\n> ```\n> Can you be more specific about the fact that this would not work?\n\n\nYes. In `tensorfield_module.py` the zero element is established by:\n\n```\n        resu = self._element_constructor_(name='zero', latex_name='0')\n        for frame in self._domain._frames:\n            if self._dest_map.restrict(frame._domain) == frame._dest_map:\n                resu.add_comp(frame)\n                # (since new components are initialized to zero)\n```\n\nBut this raises an immediate error when using\n\n```\nif self is self.parent().zero():\n    raise AssertionError(\"...\")\n```\n\nin `add_comp`.\n\nOne can add the components from \"behind\". But using this method is contradictional in this case.",
    "created_at": "2019-10-05T11:17:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399072",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:62'></a>Replying to [comment:61 egourgoulhon]:
> I would have written
> 
> ```
> if self is self.parent().zero():
>     raise AssertionError("...")
> ```
> Can you be more specific about the fact that this would not work?


Yes. In `tensorfield_module.py` the zero element is established by:

```
        resu = self._element_constructor_(name='zero', latex_name='0')
        for frame in self._domain._frames:
            if self._dest_map.restrict(frame._domain) == frame._dest_map:
                resu.add_comp(frame)
                # (since new components are initialized to zero)
```

But this raises an immediate error when using

```
if self is self.parent().zero():
    raise AssertionError("...")
```

in `add_comp`.

One can add the components from "behind". But using this method is contradictional in this case.



---

archive/issue_comments_399073.json:
```json
{
    "body": "<a id='comment:63'></a>Another idea would be, to move the preexisting code to an internal method called `_add_comp` and change everything internally with it. From outside then, you have to use the old `add_comp` method which ensures correct treatment and invokes `_add_comp` after some checking.",
    "created_at": "2019-10-05T11:22:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399073",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:63'></a>Another idea would be, to move the preexisting code to an internal method called `_add_comp` and change everything internally with it. From outside then, you have to use the old `add_comp` method which ensures correct treatment and invokes `_add_comp` after some checking.



---

archive/issue_comments_399074.json:
```json
{
    "body": "<a id='comment:64'></a>Replying to [comment:63 gh-DeRhamSource]:\n\nThanks for provided example, with `add_comp` called on the zero element.\n\n> Another idea would be, to move the preexisting code to an internal method called `_add_comp` and change everything internally with it. From outside then, you have to use the old `add_comp` method which ensures correct treatment and invokes `_add_comp` after some checking.\n\n\nAnother option would be to add the keyword argument `check=True` to `add_comp` and to use it as follows:\n\n```\ndef add_comp(self, basis=None, check=True):\n    if check and self is self.parent().zero():\n        raise RuntimeError(\"...\")\n    ...\n```\nThen in internal code, like in the example of comment:62, one could call `add_comp` with `check=False`. \n\nThat said, I would propose to move the secure manipulation of the zero element to another ticket, possibly investigating further the option of introducing a specific subclass (this would avoid having `if self is self.parent().zero()` cases everywhere).",
    "created_at": "2019-10-05T13:34:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399074",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:64'></a>Replying to [comment:63 gh-DeRhamSource]:

Thanks for provided example, with `add_comp` called on the zero element.

> Another idea would be, to move the preexisting code to an internal method called `_add_comp` and change everything internally with it. From outside then, you have to use the old `add_comp` method which ensures correct treatment and invokes `_add_comp` after some checking.


Another option would be to add the keyword argument `check=True` to `add_comp` and to use it as follows:

```
def add_comp(self, basis=None, check=True):
    if check and self is self.parent().zero():
        raise RuntimeError("...")
    ...
```
Then in internal code, like in the example of comment:62, one could call `add_comp` with `check=False`. 

That said, I would propose to move the secure manipulation of the zero element to another ticket, possibly investigating further the option of introducing a specific subclass (this would avoid having `if self is self.parent().zero()` cases everywhere).



---

archive/issue_comments_399075.json:
```json
{
    "body": "<a id='comment:65'></a>Replying to [comment:64 egourgoulhon]:\n> Another option would be to add the keyword argument `check=True` to `add_comp` and to use it as follows:\n> \n> ```\n> def add_comp(self, basis=None, check=True):\n>     if check and self is self.parent().zero():\n>         raise RuntimeError(\"...\")\n>     ...\n> ```\n> Then in internal code, like in the example of comment:62, one could call `add_comp` with `check=False`. \n\n\nSounds good. That would cause the fewest changes in the whole code.\n\n> That said, I would propose to move the secure manipulation of the zero element to another ticket, possibly investigating further the option of introducing a specific subclass (this would avoid having `if self is self.parent().zero()` cases everywhere).\n\n\nSounds reasonable. Do you open the ticket or should I?",
    "created_at": "2019-10-05T13:43:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399075",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:65'></a>Replying to [comment:64 egourgoulhon]:
> Another option would be to add the keyword argument `check=True` to `add_comp` and to use it as follows:
> 
> ```
> def add_comp(self, basis=None, check=True):
>     if check and self is self.parent().zero():
>         raise RuntimeError("...")
>     ...
> ```
> Then in internal code, like in the example of comment:62, one could call `add_comp` with `check=False`. 


Sounds good. That would cause the fewest changes in the whole code.

> That said, I would propose to move the secure manipulation of the zero element to another ticket, possibly investigating further the option of introducing a specific subclass (this would avoid having `if self is self.parent().zero()` cases everywhere).


Sounds reasonable. Do you open the ticket or should I?



---

archive/issue_comments_399076.json:
```json
{
    "body": "<a id='comment:66'></a>Replying to [comment:65 gh-DeRhamSource]:\n> \n> > That said, I would propose to move the secure manipulation of the zero element to another ticket, possibly investigating further the option of introducing a specific subclass (this would avoid having `if self is self.parent().zero()` cases everywhere).\n\n> \n> Sounds reasonable. Do you open the ticket or should I?\n\n\nPlease go on, open the ticket.",
    "created_at": "2019-10-05T14:24:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399076",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:66'></a>Replying to [comment:65 gh-DeRhamSource]:
> 
> > That said, I would propose to move the secure manipulation of the zero element to another ticket, possibly investigating further the option of introducing a specific subclass (this would avoid having `if self is self.parent().zero()` cases everywhere).

> 
> Sounds reasonable. Do you open the ticket or should I?


Please go on, open the ticket.



---

archive/issue_comments_399077.json:
```json
{
    "body": "<a id='comment:67'></a>Okay, things become quite unhandy now. All changes and modifications we had talked about belong to the very same concept of immutability, so things are highly coupled and connected. That makes a merge in the end quite difficult. Perhaps, I should use this as a meta ticket, where things will be merged together in the end?",
    "created_at": "2019-10-05T19:01:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399077",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:67'></a>Okay, things become quite unhandy now. All changes and modifications we had talked about belong to the very same concept of immutability, so things are highly coupled and connected. That makes a merge in the end quite difficult. Perhaps, I should use this as a meta ticket, where things will be merged together in the end?



---

archive/issue_comments_399078.json:
```json
{
    "body": "<a id='comment:68'></a>Replying to [comment:67 gh-DeRhamSource]:\n> Okay, things become quite unhandy now. All changes and modifications we had talked about belong to the very same concept of immutability, so things are highly coupled and connected. That makes a merge in the end quite difficult. Perhaps, I should use this as a meta ticket, where things will be merged together in the end?",
    "created_at": "2019-10-06T07:33:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399078",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:68'></a>Replying to [comment:67 gh-DeRhamSource]:
> Okay, things become quite unhandy now. All changes and modifications we had talked about belong to the very same concept of immutability, so things are highly coupled and connected. That makes a merge in the end quite difficult. Perhaps, I should use this as a meta ticket, where things will be merged together in the end?



---

archive/issue_comments_399079.json:
```json
{
    "body": "<a id='comment:69'></a>Replying to [comment:67 gh-DeRhamSource]:\n> Okay, things become quite unhandy now. All changes and modifications we had talked about belong to the very same concept of immutability, so things are highly coupled and connected. That makes a merge in the end quite difficult. Perhaps, I should use this as a meta ticket, where things will be merged together in the end?\n\n\nYes there should be a ticket (or metaticket?) entirely devoted to (im)mutability of scalar and tensor fields on manifolds, including the treatment of the zero elements. This is beyond the scope of the current ticket, which, according to its title, is devoted to improvements in differential and mixed forms. Can you still implement some of these improvements without touching the mutability of tensor fields for the moment?",
    "created_at": "2019-10-06T09:18:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399079",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:69'></a>Replying to [comment:67 gh-DeRhamSource]:
> Okay, things become quite unhandy now. All changes and modifications we had talked about belong to the very same concept of immutability, so things are highly coupled and connected. That makes a merge in the end quite difficult. Perhaps, I should use this as a meta ticket, where things will be merged together in the end?


Yes there should be a ticket (or metaticket?) entirely devoted to (im)mutability of scalar and tensor fields on manifolds, including the treatment of the zero elements. This is beyond the scope of the current ticket, which, according to its title, is devoted to improvements in differential and mixed forms. Can you still implement some of these improvements without touching the mutability of tensor fields for the moment?



---

archive/issue_comments_399080.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-10-06T09:37:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399080",
    "user": "https://github.com/DeRhamSource"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_399081.json:
```json
{
    "body": "Changing keywords from \"manifolds, mixed forms\" to \"manifolds, tensor fields, mixed forms, scalar fields\".",
    "created_at": "2019-10-06T09:37:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399081",
    "user": "https://github.com/DeRhamSource"
}
```

Changing keywords from "manifolds, mixed forms" to "manifolds, tensor fields, mixed forms, scalar fields".



---

archive/issue_comments_399082.json:
```json
{
    "body": "<a id='comment:76'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-06T15:01:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399082",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:76'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399083.json:
```json
{
    "body": "<a id='comment:77'></a>I hope, the latest changes are now correctly splitted into the tickets and merged together appropriately. Please check.",
    "created_at": "2019-10-06T15:03:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399083",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:77'></a>I hope, the latest changes are now correctly splitted into the tickets and merged together appropriately. Please check.



---

archive/issue_comments_399084.json:
```json
{
    "body": "<a id='comment:79'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-07T20:17:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399084",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:79'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399085.json:
```json
{
    "body": "<a id='comment:80'></a>#28562 and #28564 updated.",
    "created_at": "2019-10-07T20:18:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399085",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:80'></a>#28562 and #28564 updated.



---

archive/issue_comments_399086.json:
```json
{
    "body": "<a id='comment:84'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:",
    "created_at": "2019-10-12T18:41:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399086",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:84'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:



---

archive/issue_comments_399087.json:
```json
{
    "body": "<a id='comment:85'></a>#28579 merged, #28562 overwritten.",
    "created_at": "2019-10-12T18:44:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399087",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:85'></a>#28579 merged, #28562 overwritten.



---

archive/issue_comments_399088.json:
```json
{
    "body": "<a id='comment:86'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-12T20:00:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399088",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:86'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399089.json:
```json
{
    "body": "<a id='comment:87'></a>#28578 updated and (manually) merged.",
    "created_at": "2019-10-12T20:01:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399089",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:87'></a>#28578 updated and (manually) merged.



---

archive/issue_comments_399090.json:
```json
{
    "body": "<a id='comment:90'></a>Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2019-10-27T13:48:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399090",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:90'></a>Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_399091.json:
```json
{
    "body": "<a id='comment:91'></a>Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2019-10-27T15:50:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399091",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:91'></a>Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_399092.json:
```json
{
    "body": "<a id='comment:92'></a>All updated and merge conflicts solved.",
    "created_at": "2019-10-27T15:50:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399092",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:92'></a>All updated and merge conflicts solved.



---

archive/issue_comments_399093.json:
```json
{
    "body": "<a id='comment:93'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-16T21:41:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399093",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:93'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_399094.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2019-11-25T15:19:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399094",
    "user": "https://github.com/DeRhamSource"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_399095.json:
```json
{
    "body": "<a id='comment:94'></a>Since all subtickets are merged, this ticket can be seen as finished and merged as-well. Please close.",
    "created_at": "2019-11-25T15:19:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399095",
    "user": "https://github.com/DeRhamSource"
}
```

<a id='comment:94'></a>Since all subtickets are merged, this ticket can be seen as finished and merged as-well. Please close.



---

archive/issue_comments_399096.json:
```json
{
    "body": "<a id='comment:95'></a>Replying to [comment:94 gh-DeRhamSource]:\n> Since all subtickets are merged, this ticket can be seen as finished and merged as-well. Please close.\n\n\nI guess all the code is included in the previously merged tickets, so maybe you should remove the branch attached to the current ticket to avoid any confusion. Also, I think the ticket type should be set to \"task\" instead of \"enhancement\".",
    "created_at": "2019-11-25T15:26:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399096",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:95'></a>Replying to [comment:94 gh-DeRhamSource]:
> Since all subtickets are merged, this ticket can be seen as finished and merged as-well. Please close.


I guess all the code is included in the previously merged tickets, so maybe you should remove the branch attached to the current ticket to avoid any confusion. Also, I think the ticket type should be set to "task" instead of "enhancement".



---

archive/issue_comments_399097.json:
```json
{
    "body": "Changing type from enhancement to task.",
    "created_at": "2019-11-25T15:46:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399097",
    "user": "https://github.com/DeRhamSource"
}
```

Changing type from enhancement to task.



---

archive/issue_comments_399098.json:
```json
{
    "body": "Resolution: worksforme",
    "created_at": "2019-11-27T08:25:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399098",
    "user": "https://github.com/fchapoton"
}
```

Resolution: worksforme



---

archive/issue_events_071522.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2019-11-27T08:25:42Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28519#event-71522"
}
```



---

archive/issue_events_071523.json:
```json
{
    "actor": "https://github.com/fchapoton",
    "created_at": "2019-11-27T08:25:42Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28519#event-71523"
}
```



---

archive/issue_comments_399099.json:
```json
{
    "body": "<a id='comment:97'></a>not sure how to handle this kind of ticket. Closing as \"works for me\".",
    "created_at": "2019-11-27T08:25:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28519",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28519#issuecomment-399099",
    "user": "https://github.com/fchapoton"
}
```

<a id='comment:97'></a>not sure how to handle this kind of ticket. Closing as "works for me".
