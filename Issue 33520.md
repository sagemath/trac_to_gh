# Issue 33520: commutativity test

Issue created by migration from https://trac.sagemath.org/ticket/33757

Original creator: vdelecroix

Original creation time: 2022-04-25 10:15:16

CC:  mantepse tscrim caruso

In several places the commutativity of a ring is tested via `isinstance(base_ring, sage.rings.ring.CommutativeRing)` rather than `base_ring in sage.categories.commutative_rings.CommutativeRings()`. This makes it impossible to have a nicely interacting ring that would just inherit from `Parent`.

Note that the answers from `ring.is_commutative()` and `ring in CommutativeRings()` could be different : the former tests the category initialization whether the second could involve some (possibly costly) checks.

See also #32810


---

Comment by chapoton created at 2022-07-03 20:24:58

New commits:


---

Comment by chapoton created at 2022-07-03 20:24:58

Changing status from new to needs_review.


---

Comment by git created at 2022-07-04 06:49:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-04 07:46:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-04 12:08:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-04 14:37:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-04 14:42:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-04 19:50:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-07-05 06:24:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2022-07-05 09:24:49

remains only an issue with lazy rings..


---

Comment by chapoton created at 2022-07-05 09:31:42

any idea about the issue in lazy series ?


---

Comment by chapoton created at 2022-07-05 15:45:36

maybe because in vanilla sage:

```
sage: A.<t> = LazyLaurentSeriesRing(QQ)
sage: A in Rings()
True
sage: A in Rings().Commutative()
True
sage: A in CommutativeRings()
True
sage: isinstance(A, CommutativeRing)
False
sage: isinstance(A, Ring)
False
```

compare to

```
sage: A.<t> = LaurentSeriesRing(QQ)
sage: A in CommutativeRings()
True
sage: A in Rings().Commutative()
True
sage: isinstance(A, Ring)
True
sage: isinstance(A, CommutativeRing)
True
```



---

Comment by mantepse created at 2022-07-05 19:52:33

As a first step:

```
sage: A.<t> = LazyLaurentSeriesRing(QQ)
sage: PolynomialRing(A, "x")
```

fails, but I don't understand why.


---

Comment by chapoton created at 2022-07-06 07:05:31

Indeed, it's the same problem, that seems to be an issue in constructing the coercion from the base ring. On the other hand, this works with polynomials in several variables

```
sage: PolynomialRing(A,'x,y')
Multivariate Polynomial Ring in x, y over Lazy Laurent Series Ring in t over Rational Field
sage: x,y=_.gens()
sage: x*y
x*y
```



---

Comment by mantepse created at 2022-07-06 08:59:11

A tiny step forward:

with (!) your patch, we are calling `Polynomial_generic_dense_inexact.__normalize` (which fails!), whereas without your patch, we are calling `Polynomial_generic_dense.__normalize` (which succeeds).


---

Comment by mantepse created at 2022-07-07 12:48:30

Yet another tiny step, probably already noticed by Frederic:

Without the patch, after the function `PolynomialRing` delegates to `_single_variate`, we check

```
        if not isinstance(base_ring, ring.CommutativeRing):
            constructor = polynomial_ring.PolynomialRing_general
```

which succeeds, because `A.<t> = LazyLaurentSeriesRing(QQ)` does not inherit from `CommutativeRing`.

With the patch, however, we have instead

```
        if base_ring not in _CommutativeRings:
            constructor = polynomial_ring.PolynomialRing_general
        elif base_ring in _CompleteDiscreteValuationRings:
            constructor = polynomial_ring.PolynomialRing_cdvr
        elif base_ring in _CompleteDiscreteValuationFields:
            constructor = polynomial_ring.PolynomialRing_cdvf
```

and, since `A in _CommutativeRings`, it is the last check here which succeeds.

It is only afterwards that things go wrong: the `element_class` of `PolynomialRing_cdvf` in the dense case is `Polynomial_generic_dense_cdvf`.  This class inherits from `Polynomial_generic_dense_inexact`, which looks wrong to me, because `LazyLaurentSeriesRing(QQ)` is an exact ring.

I don't know whom to ask at this point.  More precisely:

* why does `Polynomial_generic_dense_cdvf` inherit from `Polynomial_generic_dense_inexact` rather than `Polynomial_generic_dense`?  Note that this seems to be the only place where `Polynomial_generic_dense_inexact` is used.

* even if this is wrong, I think that this is only masking a further bug - `LazyLaurentSeriesRing` should work just the same over inexact rings.


---

Comment by chapoton created at 2022-07-07 13:32:40

Maybe Xavier will have an opinion..


---

Comment by mantepse created at 2022-07-07 13:57:25

I tried to make `LazyCauchyProductSeries` inherit from `RingElement`, but this causes sage to crash:

```
sage: L.<z> = LazyLaurentSeriesRing(ZZ)
sage: 2*z
boom
```



---

Comment by mantepse created at 2022-07-11 19:30:24

Changing status from needs_review to needs_work.


---

Comment by git created at 2022-08-08 12:53:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2022-08-15 06:05:14

In my opinion, all this says that there must be something rather wrong in Lazy Laurent ring.

Maybe Travis would know better how to fix things ?


---

Comment by tscrim created at 2022-08-15 06:37:23

I know Martin showed me what he did, but I cannot reproduce comment:20. I am doing on top of this ticket:

```diff
diff --git a/src/sage/rings/lazy_series.py b/src/sage/rings/lazy_series.py
index c5034928ab..19657c5559 100644
--- a/src/sage/rings/lazy_series.py
+++ b/src/sage/rings/lazy_series.py
@@ -87,7 +87,7 @@ AUTHORS:
 #                  https://www.gnu.org/licenses/
 # ****************************************************************************
 
-from sage.structure.element import Element, parent
+from sage.structure.element import Element, parent, ModuleElement, RingElement
 from sage.structure.richcmp import op_EQ, op_NE
 from sage.functions.other import factorial
 from sage.arith.power import generic_power
@@ -114,7 +114,7 @@ from sage.data_structures.stream import (
     Stream_dirichlet_invert
 )
 
-class LazyModuleElement(Element):
+class LazyModuleElement(ModuleElement):
     r"""
     A lazy sequence with a module structure given by term-wise
     addition and scalar multiplication.
@@ -1974,7 +1974,7 @@ class LazyModuleElement(Element):
         return self ** (1/ZZ(2))
 
 
-class LazyCauchyProductSeries(LazyModuleElement):
+class LazyCauchyProductSeries(RingElement, LazyModuleElement):
     r"""
     A class for series where multiplication is the Cauchy product.
 
```



---

Comment by git created at 2022-08-18 07:55:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2022-08-18 13:41:20

hhmm, one then meets something like this

```
File "src/sage/rings/lazy_series.py", line 3375, in sage.rings.lazy_series.LazyDirichletSeries._format_series
Failed example:
    f = D([2, 0, 1/(1-z), 3]); f
Expected:
    (2)/1^s + ((1+z+z^2+z^3+z^4+z^5+z^6+O(z^7))/3^s) + (3)/4^s
Got:
    Traceback (most recent call last):
      File "sage/structure/element.pyx", line 1112, in sage.structure.element.Element.__richcmp__
      File "sage/structure/coerce.pyx", line 1981, in sage.structure.coerce.CoercionModel.richcmp
      File "sage/structure/element.pyx", line 1110, in sage.structure.element.Element.__richcmp__
      File "sage/structure/element.pyx", line 1114, in sage.structure.element.Element._richcmp_
      File "/home/chapoton/sage/src/sage/rings/lazy_series.py", line 512, in _richcmp_
        raise ValueError("undecidable")
etc...
```



---

Comment by tscrim created at 2022-08-19 05:40:18

My guess is that is coming from `_lmul_`/`_rmul_` versus `_acted_upon_` not playing nicely. There are some annoying subtle incompatibilities that come up when dealing with `ModuleElement` and some Cython behaviors IIRC.


---

Comment by git created at 2022-09-01 07:26:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-10-01 11:29:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-11-30 14:05:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by chapoton created at 2022-11-30 16:07:21

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2022-11-30 16:07:21

and the bot is green !! if the github badge is also green in a few hours, one may want to jump on the occasion


---

Comment by tscrim created at 2022-12-01 00:07:02

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-12-01 00:07:02

Let it be so.


---

Comment by vbraun created at 2022-12-11 11:11:43

Resolution: fixed
