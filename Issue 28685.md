# Issue 28685: Function fields: allow uniformizing variable to be specified in a completion

archive/issues_028685.json:
```json
{
    "body": "Keywords: function field\n\nThis patch adds an optional `uvar` argument to `FunctionField`'s `completion()` method.  It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.\n\nIf the specified element is not a uniformizing variable at the given place, an exception is raised.\n\nIssue created by migration from https://trac.sagemath.org/ticket/28922\n\n",
    "created_at": "2019-12-29T01:29:15Z",
    "labels": [
        "component: algebraic geometry",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Function fields: allow uniformizing variable to be specified in a completion",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/28685",
    "user": "https://github.com/BrentBaccala"
}
```
Keywords: function field

This patch adds an optional `uvar` argument to `FunctionField`'s `completion()` method.  It accepts either a function field element or an element of the Symbolic Ring constructed from a root of a function field element.  This allows, for example, `sqrt(x)` to be specified as a uniformizing variable without knowing a specific function field element that is a square root of `x`.

If the specified element is not a uniformizing variable at the given place, an exception is raised.

Issue created by migration from https://trac.sagemath.org/ticket/28922





---

archive/issue_comments_404690.json:
```json
{
    "body": "New commits:",
    "created_at": "2020-01-03T21:46:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404690",
    "user": "https://github.com/BrentBaccala"
}
```

New commits:



---

archive/issue_comments_404691.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-01-06T01:39:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404691",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_404692.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-01-06T01:46:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404692",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_404693.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-01-06T01:47:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404693",
    "user": "https://github.com/BrentBaccala"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_404694.json:
```json
{
    "body": "> 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n\nWhy is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?",
    "created_at": "2020-01-06T07:12:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404694",
    "user": "https://github.com/kwankyu"
}
```

> 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 

Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?



---

archive/issue_comments_404695.json:
```json
{
    "body": "Replying to [comment:6 klee]:\n> > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n> \n> Why is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?  \n\nTaylor and Laurent series expansions in the Symbolic Ring are specified using absolute precision.\n\n\n```\nsage: var('x')\nx\n\nsage: sin(x).series(x,4)\n1*x + (-1/6)*x^3 + Order(x^4)\n\nsage: (1/(x^2+x)).series(x,4)\n1*x^(-1) + (-1) + 1*x + (-1)*x^2 + 1*x^3 + Order(x^4)\n\n```\n\n\nI am not aware of any other examples.",
    "created_at": "2020-01-06T15:54:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404695",
    "user": "https://github.com/BrentBaccala"
}
```

Replying to [comment:6 klee]:
> > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 
> 
> Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?  

Taylor and Laurent series expansions in the Symbolic Ring are specified using absolute precision.


```
sage: var('x')
x

sage: sin(x).series(x,4)
1*x + (-1/6)*x^3 + Order(x^4)

sage: (1/(x^2+x)).series(x,4)
1*x^(-1) + (-1) + 1*x + (-1)*x^2 + 1*x^3 + Order(x^4)

```


I am not aware of any other examples.



---

archive/issue_comments_404696.json:
```json
{
    "body": "Replying to [comment:6 klee]:\n> > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n> \n> Why is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?  \n\nHave you already written a lot of code that uses relative precision?",
    "created_at": "2020-01-06T17:06:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404696",
    "user": "https://github.com/BrentBaccala"
}
```

Replying to [comment:6 klee]:
> > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 
> 
> Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?  

Have you already written a lot of code that uses relative precision?



---

archive/issue_comments_404697.json:
```json
{
    "body": "Replying to [comment:8 gh-BrentBaccala]:\n> Replying to [comment:6 klee]:\n> > > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n> > \n> > Why is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?  \n> \n> Have you already written a lot of code that uses relative precision?\n\nNo. But no change to an existing interface should be made without a compelling reason.",
    "created_at": "2020-01-08T02:39:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404697",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:8 gh-BrentBaccala]:
> Replying to [comment:6 klee]:
> > > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 
> > 
> > Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?  
> 
> Have you already written a lot of code that uses relative precision?

No. But no change to an existing interface should be made without a compelling reason.



---

archive/issue_comments_404698.json:
```json
{
    "body": "Replying to [comment:9 klee]:\n> Replying to [comment:8 gh-BrentBaccala]:\n> > Replying to [comment:6 klee]:\n> > > > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. \n> > > \n> > > Why is \"absolute precision\" more aligned with the rest of Sage? What is the evidence?  \n> > \n> > Have you already written a lot of code that uses relative precision?\n> \n> No. But no change to an existing interface should be made without a compelling reason.\n\nI agree.  I suggest making this change now, since I believe that a uniform interface is a compelling reason.",
    "created_at": "2020-01-08T04:06:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404698",
    "user": "https://github.com/BrentBaccala"
}
```

Replying to [comment:9 klee]:
> Replying to [comment:8 gh-BrentBaccala]:
> > Replying to [comment:6 klee]:
> > > > 3. The precision is now specified as absolute precision, instead of relative.  This is a **backwards incompatible** change made to bring the function field code into alignment with the rest of Sage. 
> > > 
> > > Why is "absolute precision" more aligned with the rest of Sage? What is the evidence?  
> > 
> > Have you already written a lot of code that uses relative precision?
> 
> No. But no change to an existing interface should be made without a compelling reason.

I agree.  I suggest making this change now, since I believe that a uniform interface is a compelling reason.



---

archive/issue_comments_404699.json:
```json
{
    "body": "Another reason to use absolute precision is that a common construction is to calculate the principal part of the series expansion (i.e, the negative powers).  With absolute precision, it's easier to specify: `prec=0` instead of `prec=-A.valuation(pl)(f)`.",
    "created_at": "2020-01-12T18:56:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404699",
    "user": "https://github.com/BrentBaccala"
}
```

Another reason to use absolute precision is that a common construction is to calculate the principal part of the series expansion (i.e, the negative powers).  With absolute precision, it's easier to specify: `prec=0` instead of `prec=-A.valuation(pl)(f)`.



---

archive/issue_comments_404700.json:
```json
{
    "body": "My comments:\n\n4. Function field elements can now be raised to fractional powers. \n\nAs far as I understand, fractional power, as an operation, is not well defined for elements of an algebraic function field. It may not even exist, and then you return a symbolic ring element. I don't get this. In general, I object to the idea of injecting symbolic ring stuff into exact function field computation.\n\n2. If a series expansion is exact, the `O(s^n)` is dropped. \n\nWhy slow down series expansion computation to check if it is exact? If you want an exact result for your computation, you can check it and get it. This does not make sense to me.\n\n1. The uniformizing variable can be specified\n\nOk. But please use the name `local_uniformizer`or shortly `uniformizer` for consistency. This is only acceptable if you do not clutter the series expansion code with the fractional power stuff.\n\n3. The precision is now specified as absolute precision, instead of relative. \n\nOk. But this need a deprecation warning as it is an user interface change.",
    "created_at": "2020-01-13T07:35:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404700",
    "user": "https://github.com/kwankyu"
}
```

My comments:

4. Function field elements can now be raised to fractional powers. 

As far as I understand, fractional power, as an operation, is not well defined for elements of an algebraic function field. It may not even exist, and then you return a symbolic ring element. I don't get this. In general, I object to the idea of injecting symbolic ring stuff into exact function field computation.

2. If a series expansion is exact, the `O(s^n)` is dropped. 

Why slow down series expansion computation to check if it is exact? If you want an exact result for your computation, you can check it and get it. This does not make sense to me.

1. The uniformizing variable can be specified

Ok. But please use the name `local_uniformizer`or shortly `uniformizer` for consistency. This is only acceptable if you do not clutter the series expansion code with the fractional power stuff.

3. The precision is now specified as absolute precision, instead of relative. 

Ok. But this need a deprecation warning as it is an user interface change.



---

archive/issue_comments_404701.json:
```json
{
    "body": "Replying to [comment:12 klee]:\n> My comments:\n> \n> 4. Function field elements can now be raised to fractional powers. \n> \n> As far as I understand, fractional power, as an operation, is not well defined for elements of an algebraic function field. It may not even exist, and then you return a symbolic ring element. I don't get this. In general, I object to the idea of injecting symbolic ring stuff into exact function field computation.\n\\\\\nOK, I'll drop the symbolic ring stuff, and only return fractional powers if they actually exist, otherwise raise an exception.\n\nI did the symbolic ring stuff so that a uniformizing variable could be specified as something like `sqrt(x)` even if such an element didn't actually exist.\n\\\\\\\\\n> 2. If a series expansion is exact, the `O(s^n)` is dropped. \n> \n> Why slow down series expansion computation to check if it is exact? If you want an exact result for your computation, you can check it and get it. This does not make sense to me.\n\n\n```\nsage: var('x')\nx\nsage: x.series(x)\n1*x + Order(x^20)\n```\n\n\n\nOK, not what I expected, but it's consistent with what you propose.\n\\\\\\\\\n> 1. The uniformizing variable can be specified\n> \n> Ok. But please use the name `local_uniformizer`or shortly `uniformizer` for consistency. This is only acceptable if you do not clutter the series expansion code with the fractional power stuff.\n\\\\\nOK, I'll go with `local_uniformizer`.  I'll rip the fractional power stuff out of the series expansion code and require an actual function field element to be specified as the `local_uniformizer`.\n\\\\\\\\\n> 3. The precision is now specified as absolute precision, instead of relative. \n> \n> Ok. But this need a deprecation warning as it is an user interface change.\n\n\n\nI'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.",
    "created_at": "2020-01-14T03:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404701",
    "user": "https://github.com/BrentBaccala"
}
```

Replying to [comment:12 klee]:
> My comments:
> 
> 4. Function field elements can now be raised to fractional powers. 
> 
> As far as I understand, fractional power, as an operation, is not well defined for elements of an algebraic function field. It may not even exist, and then you return a symbolic ring element. I don't get this. In general, I object to the idea of injecting symbolic ring stuff into exact function field computation.
\\
OK, I'll drop the symbolic ring stuff, and only return fractional powers if they actually exist, otherwise raise an exception.

I did the symbolic ring stuff so that a uniformizing variable could be specified as something like `sqrt(x)` even if such an element didn't actually exist.
\\\\
> 2. If a series expansion is exact, the `O(s^n)` is dropped. 
> 
> Why slow down series expansion computation to check if it is exact? If you want an exact result for your computation, you can check it and get it. This does not make sense to me.


```
sage: var('x')
x
sage: x.series(x)
1*x + Order(x^20)
```



OK, not what I expected, but it's consistent with what you propose.
\\\\
> 1. The uniformizing variable can be specified
> 
> Ok. But please use the name `local_uniformizer`or shortly `uniformizer` for consistency. This is only acceptable if you do not clutter the series expansion code with the fractional power stuff.
\\
OK, I'll go with `local_uniformizer`.  I'll rip the fractional power stuff out of the series expansion code and require an actual function field element to be specified as the `local_uniformizer`.
\\\\
> 3. The precision is now specified as absolute precision, instead of relative. 
> 
> Ok. But this need a deprecation warning as it is an user interface change.



I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.



---

archive/issue_comments_404702.json:
```json
{
    "body": "> > Ok. But this need a deprecation warning as it is an user interface change.\n> \n> \n\n> I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.\n> \n\nIt would suffice to warn the user:\n\n\n```\nsage.misc.superseded.warning(28922, \"Mind that prec now means absolute precision.\")\n```\n",
    "created_at": "2020-01-14T05:35:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404702",
    "user": "https://github.com/kwankyu"
}
```

> > Ok. But this need a deprecation warning as it is an user interface change.
> 
> 

> I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.
> 

It would suffice to warn the user:


```
sage.misc.superseded.warning(28922, "Mind that prec now means absolute precision.")
```




---

archive/issue_comments_404703.json:
```json
{
    "body": "Replying to [comment:14 klee]:\n> > > Ok. But this need a deprecation warning as it is an user interface change.\n> > \n> > \n\n> > I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.\n> > \n> \n> It would suffice to warn the user:\n> \n> {{{\n> sage.misc.superseded.warning(28922, \"Mind that prec now means absolute precision.\")\n> }}}\n\nI don't like that user interface.  It seems like the only way to disable the warning is to disable all warnings.  Since the Trac number is included in the message, it would be nice to have a feature where warnings associated with given tickets are silenced, but that's another feature entirely.\n\nI'll just drop this change.",
    "created_at": "2020-01-14T20:59:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404703",
    "user": "https://github.com/BrentBaccala"
}
```

Replying to [comment:14 klee]:
> > > Ok. But this need a deprecation warning as it is an user interface change.
> > 
> > 

> > I'm not sure how to do that.  The current deprecation warnings are for entire methods that have been dropped.  I don't think we have anything to announce that an existing method has changed its interpretation of its arguments, nor can I think of a good way to implement such a warning, since the code could never tell which interpretation was intended.
> > 
> 
> It would suffice to warn the user:
> 
> {{{
> sage.misc.superseded.warning(28922, "Mind that prec now means absolute precision.")
> }}}

I don't like that user interface.  It seems like the only way to disable the warning is to disable all warnings.  Since the Trac number is included in the message, it would be nice to have a feature where warnings associated with given tickets are silenced, but that's another feature entirely.

I'll just drop this change.



---

archive/issue_comments_404704.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-01-15T01:40:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404704",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_404705.json:
```json
{
    "body": "Is the algorithm for computing the fractional power correct? I don't see how `root` has the divisor you want.",
    "created_at": "2020-01-15T08:35:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404705",
    "user": "https://github.com/kwankyu"
}
```

Is the algorithm for computing the fractional power correct? I don't see how `root` has the divisor you want.



---

archive/issue_comments_404706.json:
```json
{
    "body": "Replying to [comment:17 klee]:\n> Is the algorithm for computing the fractional power correct? I don't see how `root` has the divisor you want.\n\n\n```\n191         numer = right.numerator()\n192         denom = right.denominator()\n193 \n194         if denom == 1:\n195             return self._pow_int(right)\n196         else:\n197             try:\n198                 D = self.divisor()\n199                 Droot = sum([Integer(m*right)*pl for pl,m in D.dict().items()])\n200                 basis = (-Droot).basis_function_space()\n201                 root = basis[0]\n202                 coeff = self.parent().constant_base_field()(self**numer)/(root**denom))**(1/denom)\n203                 return coeff*root\n204             except (TypeError, IndexError):\n205                 pass\n206             raise ValueError(\"not a %s power\"%Integer(denom).ordinal_str())\n```\n\n\nThe algorithm's logic runs like this:\n\n1. Valuations are multiplicative homomorphisms, i.e, \u03bc(fg) = \u03bc(f) + \u03bc(g)\n2. This implies \u03bc(f<sup>n</sup>) = n\u03bc(f)\n3. So if the divisor of f is \u2211mP, the divisor of f<sup>n</sup> is \u2211nmP\n4. All of the nm products have to be integers for this to be a well-formed divisor\n5. This yields line 199, with `TypeError` raised if any of nm's aren't integers\n6. `Droot` has total degree zero, so `basis` will have either zero or one elements\n7. If it has zero elements, line 201 will raise `IndexError`\n8. If we make it to line 202, we've found an element with the correct divisor\n\nIs there a flaw in any of this?",
    "created_at": "2020-01-15T20:43:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404706",
    "user": "https://github.com/BrentBaccala"
}
```

Replying to [comment:17 klee]:
> Is the algorithm for computing the fractional power correct? I don't see how `root` has the divisor you want.


```
191         numer = right.numerator()
192         denom = right.denominator()
193 
194         if denom == 1:
195             return self._pow_int(right)
196         else:
197             try:
198                 D = self.divisor()
199                 Droot = sum([Integer(m*right)*pl for pl,m in D.dict().items()])
200                 basis = (-Droot).basis_function_space()
201                 root = basis[0]
202                 coeff = self.parent().constant_base_field()(self**numer)/(root**denom))**(1/denom)
203                 return coeff*root
204             except (TypeError, IndexError):
205                 pass
206             raise ValueError("not a %s power"%Integer(denom).ordinal_str())
```


The algorithm's logic runs like this:

1. Valuations are multiplicative homomorphisms, i.e, μ(fg) = μ(f) + μ(g)
2. This implies μ(f<sup>n</sup>) = nμ(f)
3. So if the divisor of f is ∑mP, the divisor of f<sup>n</sup> is ∑nmP
4. All of the nm products have to be integers for this to be a well-formed divisor
5. This yields line 199, with `TypeError` raised if any of nm's aren't integers
6. `Droot` has total degree zero, so `basis` will have either zero or one elements
7. If it has zero elements, line 201 will raise `IndexError`
8. If we make it to line 202, we've found an element with the correct divisor

Is there a flaw in any of this?



---

archive/issue_comments_404707.json:
```json
{
    "body": "Replying to [comment:18 gh-BrentBaccala]:\n\n> The algorithm's logic runs like this:\n> \n> 1. Valuations are multiplicative homomorphisms, i.e, \u03bc(fg) = \u03bc(f) + \u03bc(g)\n> 2. This implies \u03bc(f<sup>n</sup>) = n\u03bc(f)\n> 3. So if the divisor of f is \u2211mP, the divisor of f<sup>n</sup> is \u2211nmP\n> 4. All of the nm products have to be integers for this to be a well-formed divisor\n> 5. This yields line 199, with `TypeError` raised if any of nm's aren't integers\n> 6. `Droot` has total degree zero, so `basis` will have either zero or one elements\n> 7. If it has zero elements, line 201 will raise `IndexError`\n> 8. If we make it to line 202, we've found an element with the correct divisor\n\nI see. Thanks. \n\nIt seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.",
    "created_at": "2020-01-16T04:47:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404707",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:18 gh-BrentBaccala]:

> The algorithm's logic runs like this:
> 
> 1. Valuations are multiplicative homomorphisms, i.e, μ(fg) = μ(f) + μ(g)
> 2. This implies μ(f<sup>n</sup>) = nμ(f)
> 3. So if the divisor of f is ∑mP, the divisor of f<sup>n</sup> is ∑nmP
> 4. All of the nm products have to be integers for this to be a well-formed divisor
> 5. This yields line 199, with `TypeError` raised if any of nm's aren't integers
> 6. `Droot` has total degree zero, so `basis` will have either zero or one elements
> 7. If it has zero elements, line 201 will raise `IndexError`
> 8. If we make it to line 202, we've found an element with the correct divisor

I see. Thanks. 

It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.



---

archive/issue_comments_404708.json:
```json
{
    "body": "Replying to [comment:19 klee]:\n\n> I see. Thanks. \n> \n> It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.\n\nThat's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?",
    "created_at": "2020-01-16T04:53:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404708",
    "user": "https://github.com/BrentBaccala"
}
```

Replying to [comment:19 klee]:

> I see. Thanks. 
> 
> It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.

That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?



---

archive/issue_comments_404709.json:
```json
{
    "body": "Replying to [comment:20 gh-BrentBaccala]:\n> Replying to [comment:19 klee]:\n> \n> > I see. Thanks. \n> > \n> > It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.\n> \n> That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?\n> \n\n`self`/`root^n` is in the full constant field, which is the Riemann-Roch space of zero divisor.",
    "created_at": "2020-01-16T05:09:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404709",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:20 gh-BrentBaccala]:
> Replying to [comment:19 klee]:
> 
> > I see. Thanks. 
> > 
> > It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.
> 
> That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?
> 

`self`/`root^n` is in the full constant field, which is the Riemann-Roch space of zero divisor.



---

archive/issue_comments_404710.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-01-16T20:06:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404710",
    "user": "https://github.com/BrentBaccala"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_404711.json:
```json
{
    "body": "Replying to [comment:21 klee]:\n> Replying to [comment:20 gh-BrentBaccala]:\n> > Replying to [comment:19 klee]:\n> > \n> > > I see. Thanks. \n> > > \n> > > It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.\n> > \n> > That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?\n> > \n> \n> `self`/`root^n` is in the full constant field, which is the Riemann-Roch space of zero divisor.\n\nOK, I see.\n\nThank you.\n\nI spent quite a while convincing myself that the homomorphism logic in steps 1-5 was correct, but I never considered for a minute that the zero divisor might have dimension greater than one.",
    "created_at": "2020-01-16T20:06:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404711",
    "user": "https://github.com/BrentBaccala"
}
```

Replying to [comment:21 klee]:
> Replying to [comment:20 gh-BrentBaccala]:
> > Replying to [comment:19 klee]:
> > 
> > > I see. Thanks. 
> > > 
> > > It seems you are assuming the constant field is full, that is, the base constant field is the algebraic closure of itself. Right? Then perhaps you can develop the algorithm further such that it works without that assumption. Moreover this would be a prerequisite for `is_square` to work correctly.
> > 
> > That's very likely.  I work almost exclusively with algebraically closed constant fields.  Where is the problem, exactly?  I'm guessing it has to do with the behavior of the divisors?
> > 
> 
> `self`/`root^n` is in the full constant field, which is the Riemann-Roch space of zero divisor.

OK, I see.

Thank you.

I spent quite a while convincing myself that the homomorphism logic in steps 1-5 was correct, but I never considered for a minute that the zero divisor might have dimension greater than one.



---

archive/issue_events_073195.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-04-14T19:41:51Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73195"
}
```



---

archive/issue_comments_404712.json:
```json
{
    "body": "Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404712",
    "user": "https://github.com/mkoeppe"
}
```

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_comments_404713.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-03T02:42:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404713",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_events_073196.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-09-05T19:21:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73196"
}
```



---

archive/issue_events_073197.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-09-05T19:21:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73197"
}
```



---

archive/issue_comments_404714.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404714",
    "user": "https://github.com/mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_073198.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73198"
}
```



---

archive/issue_events_073199.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73199"
}
```



---

archive/issue_events_073200.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T00:44:56Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73200"
}
```



---

archive/issue_events_073201.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T00:44:56Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73201"
}
```



---

archive/issue_comments_404715.json:
```json
{
    "body": "Setting a new milestone for this ticket based on a cursory review.",
    "created_at": "2021-07-19T00:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/28685#issuecomment-404715",
    "user": "https://github.com/mkoeppe"
}
```

Setting a new milestone for this ticket based on a cursory review.



---

archive/issue_events_073202.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73202"
}
```



---

archive/issue_events_073203.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73203"
}
```



---

archive/issue_events_073204.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-02T20:27:49Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73204"
}
```



---

archive/issue_events_073205.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-02T20:27:49Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73205"
}
```



---

archive/issue_events_073206.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73206"
}
```



---

archive/issue_events_073207.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/28685",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/28685#event-73207"
}
```
