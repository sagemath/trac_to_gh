# Issue 29429: Serious precision problems with heights of elliptic curve points over number fields

archive/issues_029429.json:
```json
{
    "body": "Despite previous efforts (e.g. #19276) there are still some serious problems as this example shows:\n\n```\nsage: R.<x> = PolynomialRing(QQ)\nsage: K.<a> = NumberField(R([2, -6, -1, 1]))\nsage: E = EllipticCurve([1, -a^2 + 2*a + 4, 0, -6056450500590472699700624*a^2 - 11239394326797569935861742*a +\n 4241549693833829432516231, 1904879037869682826729875958079326124520*a^2 + 3535022146945771697732350459284777382011*a -\n 1334055169621036218710397707677347972626])\nsage: P1 = E([1033399668533*a^2 + 1917754693229*a - 723726883800 , 12536493059202326563*a^2 + 23264879148900575548*a - 8779756111574815918 , 1]) \nsage: for prec in [10,20..200]:\n....:     print(prec, P1.height(prec))\n....:     \n10 17.\n20 16.620\n30 16.619907\n40 16.619907032\n50 16.619907031677\n60 8.7860489589580907\n70 7.7649234818341632146\n80 6.5365802821832537306149\n90 7.9728912527681114103313822\n100 4.3462291553491442990108762467\n110 3.3534893510263762201830023153742\n120 1.8972786552833774350039228733451397\n130 0.76755916182124405980786821505083402887\n140 0.30027490173859287882375493391920822491403\n150 0.29731882974921394153073422563919073022382936\n160 0.29731883342476655120600978411239946674891521498\n170 0.29731883342476341805960817173016631745497351356210\n180 0.29731883342476341806143743339545956447208969491908220\n190 0.29731883342476341806143743594520165921949459290099174097\n200 0.29731883342476341806143743594519935578637011185707031676571\n```\n\nThis is probably relevant:\n\n```\nsage: [e(E.discriminant()) for e in K.places(prec=200)]\n[-1.0389206262313219470131200000000000000000000000000000000000e23,\n 0.00000000000000000000000000000000000000000000000000000000000,\n -2.5498416851229851332757328044549300829980182654773955313551e83]\nsage: [e(E.discriminant()) for e in K.places(prec=300)]\n[5.21540641784667968750000000000000000000000000000000000000000000000000000000000000000000000e-8,\n 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,\n -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000e83]\nsage: [e(E.discriminant()) for e in K.places(prec=400)]\n[-5.87747175411143753984368268611122838909332778386043760754375853139208629727363586425781250000000000000000000000000000000e-39,\n 1.19967197152724610443557536891297700192109537178372587239508217926697852817596867680549621582031250000000000000000000000e-30,\n -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000000000000000000000000001199672e83]\n\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/29666\n\n",
    "created_at": "2020-05-08T17:04:07Z",
    "labels": [
        "elliptic curves",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.2",
    "title": "Serious precision problems with heights of elliptic curve points over number fields",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/29429",
    "user": "@JohnCremona"
}
```
Despite previous efforts (e.g. #19276) there are still some serious problems as this example shows:

```
sage: R.<x> = PolynomialRing(QQ)
sage: K.<a> = NumberField(R([2, -6, -1, 1]))
sage: E = EllipticCurve([1, -a^2 + 2*a + 4, 0, -6056450500590472699700624*a^2 - 11239394326797569935861742*a +
 4241549693833829432516231, 1904879037869682826729875958079326124520*a^2 + 3535022146945771697732350459284777382011*a -
 1334055169621036218710397707677347972626])
sage: P1 = E([1033399668533*a^2 + 1917754693229*a - 723726883800 , 12536493059202326563*a^2 + 23264879148900575548*a - 8779756111574815918 , 1]) 
sage: for prec in [10,20..200]:
....:     print(prec, P1.height(prec))
....:     
10 17.
20 16.620
30 16.619907
40 16.619907032
50 16.619907031677
60 8.7860489589580907
70 7.7649234818341632146
80 6.5365802821832537306149
90 7.9728912527681114103313822
100 4.3462291553491442990108762467
110 3.3534893510263762201830023153742
120 1.8972786552833774350039228733451397
130 0.76755916182124405980786821505083402887
140 0.30027490173859287882375493391920822491403
150 0.29731882974921394153073422563919073022382936
160 0.29731883342476655120600978411239946674891521498
170 0.29731883342476341805960817173016631745497351356210
180 0.29731883342476341806143743339545956447208969491908220
190 0.29731883342476341806143743594520165921949459290099174097
200 0.29731883342476341806143743594519935578637011185707031676571
```

This is probably relevant:

```
sage: [e(E.discriminant()) for e in K.places(prec=200)]
[-1.0389206262313219470131200000000000000000000000000000000000e23,
 0.00000000000000000000000000000000000000000000000000000000000,
 -2.5498416851229851332757328044549300829980182654773955313551e83]
sage: [e(E.discriminant()) for e in K.places(prec=300)]
[5.21540641784667968750000000000000000000000000000000000000000000000000000000000000000000000e-8,
 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
 -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000e83]
sage: [e(E.discriminant()) for e in K.places(prec=400)]
[-5.87747175411143753984368268611122838909332778386043760754375853139208629727363586425781250000000000000000000000000000000e-39,
 1.19967197152724610443557536891297700192109537178372587239508217926697852817596867680549621582031250000000000000000000000e-30,
 -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000000000000000000000000001199672e83]

```


Issue created by migration from https://trac.sagemath.org/ticket/29666





---

archive/issue_comments_417642.json:
```json
{
    "body": "The global height is a sum of local heights (and computed as such).  There is no issue at finite places where the local contributions is a  multiple of log(p), but infinte places need more care.  In the case the field is totally real and there are 3 real embeddings:\n\n```\nsage: embs = K.embeddings(RR)\nsage: [e(K.gen()) for e in embs]\n[-2.17740968089928, 0.321637174263296, 2.85577250663599]\n```\n\nNow the discriminant of E is simply an algebraic integer:\n\n```\nsage: D = E.discriminant(); D; D.norm()\n-19991287349994488914322180080178857301351914144709306138686586366056899791936307016*a^2 - 37099281436379604148954748263411386302240095123428398479719073021636668957565550383*a + 14000616158003148902523269620081174306671050818969941715711662302858908561703333067\n3145728\n```\n\nBut we see very unstable output if we embedd this into RR with different precisions:\n\n```\nsage: [e(E.discriminant()) for e in K.embeddings(RealField(100))]\n[1.1972621413014756705924586150e52,\n 1.1972621413014756705924586150e52,\n -2.5498416851229851332757328045e83]\nsage: prod(_)\n-3.6550364848895988246196751830e187\n```\n\n\n```\nsage: [e(E.discriminant()) for e in K.embeddings(RealField(200))]\n[-1.0389206262313219470131200000000000000000000000000000000000e23,\n 0.00000000000000000000000000000000000000000000000000000000000,\n -2.5498416851229851332757328044549300829980182654773955313551e83]\nsage: prod(_)\n0.00000000000000000000000000000000000000000000000000000000000\n```\n\n\n```\nsage: [e(E.discriminant()) for e in K.embeddings(RealField(300))]\n[5.21540641784667968750000000000000000000000000000000000000000000000000000000000000000000000e-8,\n 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,\n -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000e83]\nsage: prod(_)\n-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n```\n\n\n```\nsage: [e(E.discriminant()) for e in K.embeddings(RealField(400))]\n[-5.87747175411143753984368268611122838909332778386043760754375853139208629727363586425781250000000000000000000000000000000e-39,\n 1.19967197152724610443557536891297700192109537178372587239508217926697852817596867680549621582031250000000000000000000000e-30,\n -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000000000000000000000000001199672e83]\nsage: prod(_)\n1.79790309392350732848690864572206677717818189868154256817200640429980762813934488672498727223336825025776184716171423587e15\n```\n\n\n```\nsage: [e(E.discriminant()) for e in K.embeddings(RealField(500))]\n[-1.02836062362383903446201358553694451609354837652734655386699431770881652577358035457436134706493646193784251390220282588708835016381686468071865458995e-47,\n 1.19967197135162494834211130426690041743320135255353586996976763492805726045166065175695778065139672523415438336448636473738742436862131974103160827426e-30,\n -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000000000000000000000000001199671971351624938058505068028510073e83]\nsage: prod(_)\n3.14572799999999999999545416152340674357389478493501489436625135129782344509972991461680590493746918925984818487665855965606319294503167996938126286045e6\n```\n\nSo it takes 500 bits of precision until we get the norm right to about 20 digits.\n\nTo me this reveals a problem which is not just about elliptic curve computations.  There's no problem in embedding the discriminant in another way, but computing its minimal polynomial and find the roots of that:\n\n```\nsage: Dpol = D.minpoly(); Dpol\nx^3 + 254984168512298513327573280445493008299801826547739553135509708871799640567627542390*x^2 - 305897360102604087683095989110285584325438094905009621*x - 3145728\nsage: Dpol.roots(RealField(100), multiplicities=False)\n[-2.5498416851229851332757328045e83,\n -1.0283606236238390344634996521e-47,\n 1.1996719713516249483421113043e-30]\nsage: prod(_)\n3.1457280000000000000000000000e6\n```\n\n\nThe code for computing the local height is in ell_point.py in the method archimidean_local_height, and after some previous bug-fixing we already keep doubling the precision until the image of the discriminant under the embedding is not (apparantly) 0.  But as the examples here show, that it not guarantee at all thet the image of the discriminant under the embedding is correct.  The computation is carried out entirely in RealField(prec) where prec is the precision decided on this way, after embedding the curve's coefficients and the point's x-coordinate into it.\n\nI have already made considerable improvement by using refine_embedding() to extend the embedding into AA, using that to embed the numbers we need (curve coefficients and x-coordinate) and then coercing back to RealField with a suitable finite precision.  To be continued...",
    "created_at": "2020-05-10T15:39:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417642",
    "user": "@JohnCremona"
}
```

The global height is a sum of local heights (and computed as such).  There is no issue at finite places where the local contributions is a  multiple of log(p), but infinte places need more care.  In the case the field is totally real and there are 3 real embeddings:

```
sage: embs = K.embeddings(RR)
sage: [e(K.gen()) for e in embs]
[-2.17740968089928, 0.321637174263296, 2.85577250663599]
```

Now the discriminant of E is simply an algebraic integer:

```
sage: D = E.discriminant(); D; D.norm()
-19991287349994488914322180080178857301351914144709306138686586366056899791936307016*a^2 - 37099281436379604148954748263411386302240095123428398479719073021636668957565550383*a + 14000616158003148902523269620081174306671050818969941715711662302858908561703333067
3145728
```

But we see very unstable output if we embedd this into RR with different precisions:

```
sage: [e(E.discriminant()) for e in K.embeddings(RealField(100))]
[1.1972621413014756705924586150e52,
 1.1972621413014756705924586150e52,
 -2.5498416851229851332757328045e83]
sage: prod(_)
-3.6550364848895988246196751830e187
```


```
sage: [e(E.discriminant()) for e in K.embeddings(RealField(200))]
[-1.0389206262313219470131200000000000000000000000000000000000e23,
 0.00000000000000000000000000000000000000000000000000000000000,
 -2.5498416851229851332757328044549300829980182654773955313551e83]
sage: prod(_)
0.00000000000000000000000000000000000000000000000000000000000
```


```
sage: [e(E.discriminant()) for e in K.embeddings(RealField(300))]
[5.21540641784667968750000000000000000000000000000000000000000000000000000000000000000000000e-8,
 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
 -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000e83]
sage: prod(_)
-0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
```


```
sage: [e(E.discriminant()) for e in K.embeddings(RealField(400))]
[-5.87747175411143753984368268611122838909332778386043760754375853139208629727363586425781250000000000000000000000000000000e-39,
 1.19967197152724610443557536891297700192109537178372587239508217926697852817596867680549621582031250000000000000000000000e-30,
 -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000000000000000000000000001199672e83]
sage: prod(_)
1.79790309392350732848690864572206677717818189868154256817200640429980762813934488672498727223336825025776184716171423587e15
```


```
sage: [e(E.discriminant()) for e in K.embeddings(RealField(500))]
[-1.02836062362383903446201358553694451609354837652734655386699431770881652577358035457436134706493646193784251390220282588708835016381686468071865458995e-47,
 1.19967197135162494834211130426690041743320135255353586996976763492805726045166065175695778065139672523415438336448636473738742436862131974103160827426e-30,
 -2.54984168512298513327573280445493008299801826547739553135509708871799640567627542390000000000000000000000000000001199671971351624938058505068028510073e83]
sage: prod(_)
3.14572799999999999999545416152340674357389478493501489436625135129782344509972991461680590493746918925984818487665855965606319294503167996938126286045e6
```

So it takes 500 bits of precision until we get the norm right to about 20 digits.

To me this reveals a problem which is not just about elliptic curve computations.  There's no problem in embedding the discriminant in another way, but computing its minimal polynomial and find the roots of that:

```
sage: Dpol = D.minpoly(); Dpol
x^3 + 254984168512298513327573280445493008299801826547739553135509708871799640567627542390*x^2 - 305897360102604087683095989110285584325438094905009621*x - 3145728
sage: Dpol.roots(RealField(100), multiplicities=False)
[-2.5498416851229851332757328045e83,
 -1.0283606236238390344634996521e-47,
 1.1996719713516249483421113043e-30]
sage: prod(_)
3.1457280000000000000000000000e6
```


The code for computing the local height is in ell_point.py in the method archimidean_local_height, and after some previous bug-fixing we already keep doubling the precision until the image of the discriminant under the embedding is not (apparantly) 0.  But as the examples here show, that it not guarantee at all thet the image of the discriminant under the embedding is correct.  The computation is carried out entirely in RealField(prec) where prec is the precision decided on this way, after embedding the curve's coefficients and the point's x-coordinate into it.

I have already made considerable improvement by using refine_embedding() to extend the embedding into AA, using that to embed the numbers we need (curve coefficients and x-coordinate) and then coercing back to RealField with a suitable finite precision.  To be continued...



---

archive/issue_comments_417643.json:
```json
{
    "body": "With the the patch I am about to push the output is rather better:\n\n```\n10 0.37\n20 0.29757\n30 0.29731859\n40 0.29731883360\n50 0.29731883342441\n60 0.29731883342476347\n70 0.29731883342476341763\n80 0.29731883342476341806145\n90 0.29731883342476341806143714\n100 0.29731883342476341806143743626\n110 0.29731883342476341806143743594493\n120 0.29731883342476341806143743594519954\n130 0.29731883342476341806143743594519935568\n140 0.29731883342476341806143743594519935578697\n150 0.29731883342476341806143743594519935578696539\n160 0.29731883342476341806143743594519935578696537758\n170 0.29731883342476341806143743594519935578696537745287\n180 0.29731883342476341806143743594519935578696537745294689\n190 0.29731883342476341806143743594519935578696537745294661842\n200 0.29731883342476341806143743594519935578696537745294661858983\n```\n\nThe idea is this, at each real or complex place:  embed the curve coefficients and point coordinates into Qbar (or AA for a real place), then coerce them into fixed precision to do the iteration.  I am currently using prec+100 as working precision, where prec is the precision specified.  At the end it cuts back to precision prec.",
    "created_at": "2020-05-10T16:44:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417643",
    "user": "@JohnCremona"
}
```

With the the patch I am about to push the output is rather better:

```
10 0.37
20 0.29757
30 0.29731859
40 0.29731883360
50 0.29731883342441
60 0.29731883342476347
70 0.29731883342476341763
80 0.29731883342476341806145
90 0.29731883342476341806143714
100 0.29731883342476341806143743626
110 0.29731883342476341806143743594493
120 0.29731883342476341806143743594519954
130 0.29731883342476341806143743594519935568
140 0.29731883342476341806143743594519935578697
150 0.29731883342476341806143743594519935578696539
160 0.29731883342476341806143743594519935578696537758
170 0.29731883342476341806143743594519935578696537745287
180 0.29731883342476341806143743594519935578696537745294689
190 0.29731883342476341806143743594519935578696537745294661842
200 0.29731883342476341806143743594519935578696537745294661858983
```

The idea is this, at each real or complex place:  embed the curve coefficients and point coordinates into Qbar (or AA for a real place), then coerce them into fixed precision to do the iteration.  I am currently using prec+100 as working precision, where prec is the precision specified.  At the end it cuts back to precision prec.



---

archive/issue_comments_417644.json:
```json
{
    "body": "New commits:",
    "created_at": "2020-05-10T16:45:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417644",
    "user": "@JohnCremona"
}
```

New commits:



---

archive/issue_comments_417645.json:
```json
{
    "body": "The branch u/cremona/29666 was based on u/cremona/29645 which has a positive review at #29645.  I hope that is OK.",
    "created_at": "2020-05-10T16:47:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417645",
    "user": "@JohnCremona"
}
```

The branch u/cremona/29666 was based on u/cremona/29645 which has a positive review at #29645.  I hope that is OK.



---

archive/issue_comments_417646.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-05-11T11:18:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417646",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417647.json:
```json
{
    "body": "OK this is ready for review.  Since the earlier commit I have added a suitable doctest and adjusted two others.  (In one case a height to default precision was asked for but the old code gave it to a hgher precision; in the other, the final digit has changed and I checked that the new final digit is correct.)\n\nI also tweaked the code slightly: when the overall archimedean height contribution is computed by adding up the local ones, they are computed to an extra 10 bits of precision before being summed, which helps with rounding.\n\nFor the record, the output from the original test at the top of this ticket is now\n\n```\n10 0.30\n20 0.29732\n30 0.29731883\n40 0.29731883342\n50 0.29731883342476\n60 0.29731883342476342\n70 0.29731883342476341806\n80 0.29731883342476341806144\n90 0.29731883342476341806143744\n100 0.29731883342476341806143743595\n110 0.29731883342476341806143743594520\n120 0.29731883342476341806143743594519935\n130 0.29731883342476341806143743594519935579\n140 0.29731883342476341806143743594519935578697\n150 0.29731883342476341806143743594519935578696538\n160 0.29731883342476341806143743594519935578696537745\n170 0.29731883342476341806143743594519935578696537745295\n180 0.29731883342476341806143743594519935578696537745294662\n190 0.29731883342476341806143743594519935578696537745294661859\n200 0.29731883342476341806143743594519935578696537745294661858984\n```\n\nwhich as well as looking good even at low precisions, has the proprty that each line rounds correctly to the line above (at least it looks that way -- I did not check every one, but I did check precisions 900,910,..1000 as well).",
    "created_at": "2020-05-11T11:26:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417647",
    "user": "@JohnCremona"
}
```

OK this is ready for review.  Since the earlier commit I have added a suitable doctest and adjusted two others.  (In one case a height to default precision was asked for but the old code gave it to a hgher precision; in the other, the final digit has changed and I checked that the new final digit is correct.)

I also tweaked the code slightly: when the overall archimedean height contribution is computed by adding up the local ones, they are computed to an extra 10 bits of precision before being summed, which helps with rounding.

For the record, the output from the original test at the top of this ticket is now

```
10 0.30
20 0.29732
30 0.29731883
40 0.29731883342
50 0.29731883342476
60 0.29731883342476342
70 0.29731883342476341806
80 0.29731883342476341806144
90 0.29731883342476341806143744
100 0.29731883342476341806143743595
110 0.29731883342476341806143743594520
120 0.29731883342476341806143743594519935
130 0.29731883342476341806143743594519935579
140 0.29731883342476341806143743594519935578697
150 0.29731883342476341806143743594519935578696538
160 0.29731883342476341806143743594519935578696537745
170 0.29731883342476341806143743594519935578696537745295
180 0.29731883342476341806143743594519935578696537745294662
190 0.29731883342476341806143743594519935578696537745294661859
200 0.29731883342476341806143743594519935578696537745294661858984
```

which as well as looking good even at low precisions, has the proprty that each line rounds correctly to the line above (at least it looks that way -- I did not check every one, but I did check precisions 900,910,..1000 as well).



---

archive/issue_comments_417648.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-05-11T11:26:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417648",
    "user": "@JohnCremona"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_417649.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2020-05-13T10:01:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417649",
    "user": "@JohnCremona"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_417650.json:
```json
{
    "body": "There are still problems as this example shows:\n\n```\nsage: K.<a> = NumberField(x^3 - 11*x - 2)\nsage: E = EllipticCurve(K, [1/2*a^2 + 1/2*a - 4, 1/2*a^2 - 1/2*a - 4, 1/2*a^2 + 1/2*a - 4, -175547756798077635/2*a^2 - 597911553601244757/2*a - 52115963829319749, -48633812364864755077688629*a^2 - 165550316123739355308695664*a -28569387847927247747905799])\nsage: P = E([216510916*a^2 + 740533851*a + 138549919 , 14942427856549*a^2 + 50869087118512*a + 8793261582543 , 1])\nsage: for p in [10,20,..200]:\n....:     print(p, P.height(precision=p))\n....:     \n10 5.3\n20 4.5973\n30 4.0196775\n40 3.5575793871\n50 2.8644322065830\n60 2.4023340862292265\n70 1.8585001977915169701\n80 1.2470893717442980993743\n90 0.61196260604253651402976340\n100 0.11885418849685232253505629801\n110 0.18584331419595729055609000495906\n120 0.18579464492706277356919880290937759\n130 0.18579470097816733698170674233787149028\n140 0.18579470101424408780248594867643433582473\n150 0.18579470101419596246299581127586844966536691\n160 0.18579470101419596892541663256863510163968062908\n170 0.18579470101419596898145849386339826920477669822442\n180 0.18579470101419596898150747494973620913043882504245702\n190 0.18579470101419596898150741983112513041527366866158255744\n200 0.18579470101419596898150741981019547127777498636559786638561\n```\n",
    "created_at": "2020-05-13T10:01:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417650",
    "user": "@JohnCremona"
}
```

There are still problems as this example shows:

```
sage: K.<a> = NumberField(x^3 - 11*x - 2)
sage: E = EllipticCurve(K, [1/2*a^2 + 1/2*a - 4, 1/2*a^2 - 1/2*a - 4, 1/2*a^2 + 1/2*a - 4, -175547756798077635/2*a^2 - 597911553601244757/2*a - 52115963829319749, -48633812364864755077688629*a^2 - 165550316123739355308695664*a -28569387847927247747905799])
sage: P = E([216510916*a^2 + 740533851*a + 138549919 , 14942427856549*a^2 + 50869087118512*a + 8793261582543 , 1])
sage: for p in [10,20,..200]:
....:     print(p, P.height(precision=p))
....:     
10 5.3
20 4.5973
30 4.0196775
40 3.5575793871
50 2.8644322065830
60 2.4023340862292265
70 1.8585001977915169701
80 1.2470893717442980993743
90 0.61196260604253651402976340
100 0.11885418849685232253505629801
110 0.18584331419595729055609000495906
120 0.18579464492706277356919880290937759
130 0.18579470097816733698170674233787149028
140 0.18579470101424408780248594867643433582473
150 0.18579470101419596246299581127586844966536691
160 0.18579470101419596892541663256863510163968062908
170 0.18579470101419596898145849386339826920477669822442
180 0.18579470101419596898150747494973620913043882504245702
190 0.18579470101419596898150741983112513041527366866158255744
200 0.18579470101419596898150741981019547127777498636559786638561
```




---

archive/issue_comments_417651.json:
```json
{
    "body": "OK, so the one ad hoc thing I had done was to use a working precision of prec+100, after successfully dealing with the issue that the only safe way to embed the algebraic numbers was via AA.  In this case we have \n\n```\nsage: D = E.discriminant()\nsage: embs = K.embeddings(AA)\nsage: [RealField(200)(e(D)) for e in embs]\n[7.0491994169742768935512238851115920893264218704504833097937e-92,\n 1.4444238971841122231128115759525667950015607234369406528990e44,\n 4.6921619927568823947770481784336605497256794941139787036563e54]\n```\n\nso one of the embedded curves is very close to being singular over RR (which is always when problems arise).  In this case, adding 200 to the working precision is OK, but clearly it is no good as a strategy so add a constant.\n\nI have a more intelligent strategy, see next comment.",
    "created_at": "2020-05-13T11:08:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417651",
    "user": "@JohnCremona"
}
```

OK, so the one ad hoc thing I had done was to use a working precision of prec+100, after successfully dealing with the issue that the only safe way to embed the algebraic numbers was via AA.  In this case we have 

```
sage: D = E.discriminant()
sage: embs = K.embeddings(AA)
sage: [RealField(200)(e(D)) for e in embs]
[7.0491994169742768935512238851115920893264218704504833097937e-92,
 1.4444238971841122231128115759525667950015607234369406528990e44,
 4.6921619927568823947770481784336605497256794941139787036563e54]
```

so one of the embedded curves is very close to being singular over RR (which is always when problems arise).  In this case, adding 200 to the working precision is OK, but clearly it is no good as a strategy so add a constant.

I have a more intelligent strategy, see next comment.



---

archive/issue_comments_417652.json:
```json
{
    "body": "Instead of just adding 100 to prec to get working_prec the code now does the following.  It looks at the nearest integer to the absolute value of the discriminant (in the current embedding).  If that is 0 it adds 100 as before, but otherwise it adds the number of bits i nthe rounded absolute value of 1/D, plus 10.  In the previous example this means that even when prec=10 the working precision used at the first embedding (the nasty one) is 333, and the computed height is OK.  This is perhaps overkill but the iteration itself is fast, and at least we will now automatically increase teh working precision by more when the curve is even closer to being singular.\n\nOutput of the previous example is now\n\n```\n10 0.19\n20 0.18579\n30 0.18579470\n40 0.18579470101\n50 0.18579470101419\n60 0.18579470101419597\n70 0.18579470101419596898\n80 0.18579470101419596898151\n90 0.18579470101419596898150742\n100 0.18579470101419596898150741981\n110 0.18579470101419596898150741981027\n120 0.18579470101419596898150741981027436\n130 0.18579470101419596898150741981027436036\n140 0.18579470101419596898150741981027436036416\n150 0.18579470101419596898150741981027436036416099\n160 0.18579470101419596898150741981027436036416099219\n170 0.18579470101419596898150741981027436036416099218750\n180 0.18579470101419596898150741981027436036416099218749964\n190 0.18579470101419596898150741981027436036416099218749964397\n200 0.18579470101419596898150741981027436036416099218749964396637\n```\n\n(and now the analytic order of Sha for this curve is actually 1 to high precision, which is what I was computing when I hit this bad case).",
    "created_at": "2020-05-13T11:16:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417652",
    "user": "@JohnCremona"
}
```

Instead of just adding 100 to prec to get working_prec the code now does the following.  It looks at the nearest integer to the absolute value of the discriminant (in the current embedding).  If that is 0 it adds 100 as before, but otherwise it adds the number of bits i nthe rounded absolute value of 1/D, plus 10.  In the previous example this means that even when prec=10 the working precision used at the first embedding (the nasty one) is 333, and the computed height is OK.  This is perhaps overkill but the iteration itself is fast, and at least we will now automatically increase teh working precision by more when the curve is even closer to being singular.

Output of the previous example is now

```
10 0.19
20 0.18579
30 0.18579470
40 0.18579470101
50 0.18579470101419
60 0.18579470101419597
70 0.18579470101419596898
80 0.18579470101419596898151
90 0.18579470101419596898150742
100 0.18579470101419596898150741981
110 0.18579470101419596898150741981027
120 0.18579470101419596898150741981027436
130 0.18579470101419596898150741981027436036
140 0.18579470101419596898150741981027436036416
150 0.18579470101419596898150741981027436036416099
160 0.18579470101419596898150741981027436036416099219
170 0.18579470101419596898150741981027436036416099218750
180 0.18579470101419596898150741981027436036416099218749964
190 0.18579470101419596898150741981027436036416099218749964397
200 0.18579470101419596898150741981027436036416099218749964396637
```

(and now the analytic order of Sha for this curve is actually 1 to high precision, which is what I was computing when I hit this bad case).



---

archive/issue_comments_417653.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2020-05-13T11:22:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417653",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_417654.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2020-05-13T11:23:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417654",
    "user": "@JohnCremona"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_417655.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-05-19T08:57:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417655",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417656.json:
```json
{
    "body": "Still \"needs review\".  The last commit adds similar improvement to computation of lower height bounds (needed for upper bound of index in saturation) which behaved badly for curves where the image of the discriminant under an embedding was extremely small.",
    "created_at": "2020-05-19T08:59:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417656",
    "user": "@JohnCremona"
}
```

Still "needs review".  The last commit adds similar improvement to computation of lower height bounds (needed for upper bound of index in saturation) which behaved badly for curves where the image of the discriminant under an embedding was extremely small.



---

archive/issue_comments_417657.json:
```json
{
    "body": "failing doctests:\n\n```\nsage -t --long src/sage/schemes/elliptic_curves/heegner.py\n**********************************************************************\nFile \"src/sage/schemes/elliptic_curves/heegner.py\", line 3282, in sage.schemes.elliptic_curves.heegner.HeegnerPointOnEllipticCurve.numerical_approx\nFailed example:\n    numerical_approx(P)\nExpected:\n    (0.675507556926806 + 0.344749649302635*I : -0.377142931401887 + 0.843366227137146*I : 1.00000000000000)\nGot:\n    (0.675507556926807 + 0.344749649302635*I : -0.377142931401887 + 0.843366227137146*I : 1.00000000000000)\n**********************************************************************\nFile \"src/sage/schemes/elliptic_curves/heegner.py\", line 4300, in sage.schemes.elliptic_curves.heegner.KolyvaginPoint._recognize_point_over_QQ\nFailed example:\n    PP = P.numerical_approx(); PP\nExpected:\n    (...e-16 : -1.00000000000000 : 1.00000000000000)\nGot:\n    (0.000000000000000 : -1.00000000000000 : 1.00000000000000)\n**********************************************************************\n```\n",
    "created_at": "2020-05-19T11:37:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417657",
    "user": "@fchapoton"
}
```

failing doctests:

```
sage -t --long src/sage/schemes/elliptic_curves/heegner.py
**********************************************************************
File "src/sage/schemes/elliptic_curves/heegner.py", line 3282, in sage.schemes.elliptic_curves.heegner.HeegnerPointOnEllipticCurve.numerical_approx
Failed example:
    numerical_approx(P)
Expected:
    (0.675507556926806 + 0.344749649302635*I : -0.377142931401887 + 0.843366227137146*I : 1.00000000000000)
Got:
    (0.675507556926807 + 0.344749649302635*I : -0.377142931401887 + 0.843366227137146*I : 1.00000000000000)
**********************************************************************
File "src/sage/schemes/elliptic_curves/heegner.py", line 4300, in sage.schemes.elliptic_curves.heegner.KolyvaginPoint._recognize_point_over_QQ
Failed example:
    PP = P.numerical_approx(); PP
Expected:
    (...e-16 : -1.00000000000000 : 1.00000000000000)
Got:
    (0.000000000000000 : -1.00000000000000 : 1.00000000000000)
**********************************************************************
```




---

archive/issue_comments_417658.json:
```json
{
    "body": "OK, I will fix that.",
    "created_at": "2020-05-19T12:48:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417658",
    "user": "@JohnCremona"
}
```

OK, I will fix that.



---

archive/issue_comments_417659.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-05-19T13:11:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417659",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_417660.json:
```json
{
    "body": "ok, not a mathematical review, but you will be trusted as an expert of this stuff",
    "created_at": "2020-05-21T09:07:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417660",
    "user": "@fchapoton"
}
```

ok, not a mathematical review, but you will be trusted as an expert of this stuff



---

archive/issue_comments_417661.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-05-21T09:07:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417661",
    "user": "@fchapoton"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_417662.json:
```json
{
    "body": "Thanks FC.  I am really quite confident that the height precision issue now has a good solution, unlike the last time I fixed it very crudely.  The computations I am now doing (on many hundreds of thousands of curves) give  some confidence since the heights come into the Birch--Swinnerton-Dyer formula which predicts that a certain real number, which is not in general proved even to be rational, is a positive integer and a perfect square.  In most cases I cam computing that as 1.000000000 with a warning if it is not very close to a square integer, and all is going smoothly so I am confident that now all the heights are bing computed reliably -- which was certainly not the case before.",
    "created_at": "2020-05-21T10:34:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417662",
    "user": "@JohnCremona"
}
```

Thanks FC.  I am really quite confident that the height precision issue now has a good solution, unlike the last time I fixed it very crudely.  The computations I am now doing (on many hundreds of thousands of curves) give  some confidence since the heights come into the Birch--Swinnerton-Dyer formula which predicts that a certain real number, which is not in general proved even to be rational, is a positive integer and a perfect square.  In most cases I cam computing that as 1.000000000 with a warning if it is not very close to a square integer, and all is going smoothly so I am confident that now all the heights are bing computed reliably -- which was certainly not the case before.



---

archive/issue_comments_417663.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. This was a forced push. New commits:",
    "created_at": "2020-05-28T13:45:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417663",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. This was a forced push. New commits:



---

archive/issue_comments_417664.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2020-05-28T13:45:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417664",
    "user": "git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_417665.json:
```json
{
    "body": "I merged in the current develop (sage 9.1) and did a forced push so unfortunately the ticket has gone back to \"needs review\".",
    "created_at": "2020-05-28T13:46:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417665",
    "user": "@JohnCremona"
}
```

I merged in the current develop (sage 9.1) and did a forced push so unfortunately the ticket has gone back to "needs review".



---

archive/issue_comments_417666.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-05-28T14:09:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417666",
    "user": "@fchapoton"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_417667.json:
```json
{
    "body": "well, this is a case where you could feel allowed to set back to positive",
    "created_at": "2020-05-28T14:09:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417667",
    "user": "@fchapoton"
}
```

well, this is a case where you could feel allowed to set back to positive



---

archive/issue_comments_417668.json:
```json
{
    "body": "Replying to [comment:21 chapoton]:\n> well, this is a case where you could feel allowed to set back to positive\nThanks again.",
    "created_at": "2020-05-29T07:53:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417668",
    "user": "@JohnCremona"
}
```

Replying to [comment:21 chapoton]:
> well, this is a case where you could feel allowed to set back to positive
Thanks again.



---

archive/issue_comments_417669.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2020-05-29T21:16:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29429",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29429#issuecomment-417669",
    "user": "@vbraun"
}
```

Resolution: fixed
