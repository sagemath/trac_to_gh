# Issue 25454: Faster Composition.complement() using naive method

archive/issues_025454.json:
```json
{
    "body": "Keywords: days94\n\nFor compositions of `n` greater than about 55, it seems that the naive method of constructing the complement composition using the difference of sets is faster. This obviously also can affect the conjugate() method.\n\nIn the attached branch, I added a \"complement_naive\" method. Few timings:\n\n```\nsage: C = Compositions(20)\nsage: A = [C.random_element() for i in range(300)]\nsage: %timeit B = [c.complement() for c in A]\n100 loops, best of 3: 5.29 ms per loop\nsage: %timeit B = [c.complement_naive() for c in A]\n100 loops, best of 3: 8.48 ms per loop\n\nsage: C = Compositions(50)\nsage: A = [C.random_element() for i in range(300)]\nsage: %timeit B = [c.complement() for c in A]\n100 loops, best of 3: 10.1 ms per loop\nsage: %timeit B = [c.complement_naive() for c in A]\n100 loops, best of 3: 10.3 ms per loop\n\nsage: C = Compositions(55)\nsage: A = [C.random_element() for i in range(300)]\nsage: %timeit B = [c.complement() for c in A]\n100 loops, best of 3: 10.9 ms per loop\nsage: %timeit B = [c.complement_naive() for c in A]\n100 loops, best of 3: 10.5 ms per loop\n\nsage: C = Compositions(100)\nsage: A = [C.random_element() for i in range(200)]\nsage: %timeit B = [c.complement() for c in A]\n100 loops, best of 3: 12.6 ms per loop\nsage: %timeit B = [c.complement_naive() for c in A]\n100 loops, best of 3: 8.44 ms per loop\n\nsage: C = Compositions(200)\nsage: A = [C.random_element() for i in range(300)]\nsage: %timeit B = [c.complement() for c in A]\n10 loops, best of 3: 39.8 ms per loop\nsage: %timeit B = [c.complement_naive() for c in A]\n100 loops, best of 3: 17.2 ms per loop\n\nsage: C = Compositions(1000)\nsage: A = [C.random_element() for i in range(300)]\nsage: %timeit B = [c.complement() for c in A]\n1 loop, best of 3: 396 ms per loop\nsage: %timeit B = [c.complement_naive() for c in A]\n10 loops, best of 3: 59.9 ms per loop\n```\n\n\nThis happens probably because a random composition of `n` have \"many\" small parts\n\nIssue created by migration from https://trac.sagemath.org/ticket/25691\n\n",
    "created_at": "2018-06-28T15:58:40Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "title": "Faster Composition.complement() using naive method",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25454",
    "user": "mathzeta2"
}
```
Keywords: days94

For compositions of `n` greater than about 55, it seems that the naive method of constructing the complement composition using the difference of sets is faster. This obviously also can affect the conjugate() method.

In the attached branch, I added a "complement_naive" method. Few timings:

```
sage: C = Compositions(20)
sage: A = [C.random_element() for i in range(300)]
sage: %timeit B = [c.complement() for c in A]
100 loops, best of 3: 5.29 ms per loop
sage: %timeit B = [c.complement_naive() for c in A]
100 loops, best of 3: 8.48 ms per loop

sage: C = Compositions(50)
sage: A = [C.random_element() for i in range(300)]
sage: %timeit B = [c.complement() for c in A]
100 loops, best of 3: 10.1 ms per loop
sage: %timeit B = [c.complement_naive() for c in A]
100 loops, best of 3: 10.3 ms per loop

sage: C = Compositions(55)
sage: A = [C.random_element() for i in range(300)]
sage: %timeit B = [c.complement() for c in A]
100 loops, best of 3: 10.9 ms per loop
sage: %timeit B = [c.complement_naive() for c in A]
100 loops, best of 3: 10.5 ms per loop

sage: C = Compositions(100)
sage: A = [C.random_element() for i in range(200)]
sage: %timeit B = [c.complement() for c in A]
100 loops, best of 3: 12.6 ms per loop
sage: %timeit B = [c.complement_naive() for c in A]
100 loops, best of 3: 8.44 ms per loop

sage: C = Compositions(200)
sage: A = [C.random_element() for i in range(300)]
sage: %timeit B = [c.complement() for c in A]
10 loops, best of 3: 39.8 ms per loop
sage: %timeit B = [c.complement_naive() for c in A]
100 loops, best of 3: 17.2 ms per loop

sage: C = Compositions(1000)
sage: A = [C.random_element() for i in range(300)]
sage: %timeit B = [c.complement() for c in A]
1 loop, best of 3: 396 ms per loop
sage: %timeit B = [c.complement_naive() for c in A]
10 loops, best of 3: 59.9 ms per loop
```


This happens probably because a random composition of `n` have "many" small parts

Issue created by migration from https://trac.sagemath.org/ticket/25691





---

archive/issue_comments_359148.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2018-06-28T16:03:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25454",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25454#issuecomment-359148",
    "user": "mathzeta2"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_359149.json:
```json
{
    "body": "Changing status from needs_info to needs_work.",
    "created_at": "2018-06-29T13:42:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25454",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25454#issuecomment-359149",
    "user": "mathzeta2"
}
```

Changing status from needs_info to needs_work.
