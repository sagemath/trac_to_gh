# Issue 23982: critical bug in comparison between RealField and QQ

Issue created by migration from Trac.

Original creator: zimmerma

Original creation time: 2017-11-15 14:07:06

CC:  jdemeyer


```
sage: t = RealField(2)(1)
sage: t >= 5/4
True
```

This is clearly wrong. My guess is that `5/4` is first converted to a 2-bit
floating-point number, which is `1` in mode to nearest, then the comparison is made.

The fix is either to convert `5/4` with directed rounding (here toward +infinity),
or to convert `t` to rational using `exact_rational`.


---

Comment by chapoton created at 2017-11-15 14:37:22


```
sage: t
1.0
sage: RealField(2)(5/4)
1.0
```

So this is not really a bug


---

Comment by zimmerma created at 2017-11-15 15:00:02

I did not ask `t >= RealField(2)(5/4)`, but `t >= 5/4`.
Does the following convince you? Note that 6*t is exactly representable in 2-bit precision.

```
sage: t = RealField(2)(1)
sage: t >= 7/6
True
sage: 6*t >= 7
False
```



---

Comment by chapoton created at 2017-11-15 15:04:14

Well, comparison happens after coercion, and coercion can only lose precision. If you want comparison that makes sense, you should avoid using such a small precision.


---

Comment by zimmerma created at 2017-11-15 15:19:41

where is it documented that comparison happens after coercion? Is the user warned about that?
And why is the coercion done in the direction QQ to RealField and not the converse, which would not lose any information?


---

Comment by chapoton created at 2017-11-15 15:22:08

Coercion is supposed to be exact (mathematically), so it can not guess anything from an approximate real number. Going from R to QQ is a conversion.

```
sage: R = RealField(2)
sage: R.coerce_map_from(QQ)

Generic map:
  From: Rational Field
  To:   Real Field with 2 bits of precision
sage: QQ.coerce_map_from(R)
```



---

Comment by chapoton created at 2017-11-15 15:26:28

For your first question, see 

http://doc.sagemath.org/html/en/reference/coercion/index.html

and

http://doc.sagemath.org/html/en/reference/structure/sage/structure/element.html


---

Comment by zimmerma created at 2017-11-15 15:45:23

the issue can be simplified to:

```
sage: RealField(2)(7) == 10
True
```



---

Comment by jdemeyer created at 2017-11-16 08:49:59

Changing component from basic arithmetic to coercion.


---

Comment by jdemeyer created at 2017-11-16 08:49:59

The behaviour that you see is by design, so by definition it's a feature and not a bug.

Note also that what you see is consistent with subtraction, which is a good thing:

```
sage: RealField(2)(1) - 5/4
0.00
```


I don't see a simple fix here... it would require substantial changes to the coercion model.


---

Comment by zimmerma created at 2017-11-16 16:23:38

> I don't see a simple fix here... 

why no simply forbid comparison involving floating-point numbers, if it can result in mathematically wrong results? Then the user would have to do:

```
sage: RealField(2)(7).exact_rational() == 10
False
```



---

Comment by jdemeyer created at 2017-11-16 18:37:14

Replying to [comment:9 zimmerma]:
> > I don't see a simple fix here... 
> 
> why no simply forbid comparison involving floating-point numbers

I don't think that's realistic. I'm pretty sure that a lot of stuff in Sage would break if we did that.


---

Comment by tscrim created at 2017-11-16 21:53:14

I don't quite see it as a mathematically wrong result as it is correct up to the estimate bounds. If we did that, then I feel this would have to return `False` by the same argument:

```
sage: bool(pi.n() == pi)
True
```

since `pi.n()` is an inexact floating point number. Also, we have this doctest in `exact_rational`:

```
sage: RR(3^60).exact_rational() - 3^60
6125652559
```



---

Comment by zimmerma created at 2017-11-16 22:50:53

Replying to [comment:11 tscrim]:
> I don't quite see it as a mathematically wrong result as it is correct up to the estimate bounds. If we did that, then I feel this would have to return `False` by the same argument:
> {{{
> sage: bool(pi.n() == pi)
> True
> }}}
> since `pi.n()` is an inexact floating point number.

it would indeed be correct to return False, since `pi.n()` is a well-defined rational number, namely `884279719003555/2^48`, and it is well known that `pi` is not rational, thus we cannot get equality.

Anyway, since I'm alone to consider this as a bug, I will simply use `exact_rational` whenever I want correct comparisons with floating-point numbers.


---

Comment by jdemeyer created at 2018-03-08 10:04:31

Resolution: wontfix
