# Issue 18660: Memory leak in eigenvalues method

archive/issues_018660.json:
```json
{
    "body": "CC:  simonking jmantysalo\n\nThis method, inspired from the code of Nils Bruin posted in the sage-devel post [Memory leaks on matrix creation?](https://groups.google.com/d/msg/sage-devel/Jqi5f60j_lY/M7esZcJliZoJ), shows some leak in the eigenvalues method for 4x4 and 5x5 integer matrices. Examples are below.\n\n\n```python\ndef test(L, dim):\n    import gc\n    from collections import Counter\n    gc.collect()\n    pre={id(c) for c in gc.get_objects()}\n    for _ in range(100):\n        matrix(dim, L).eigenvalues()\n    gc.collect()\n    post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n    return [(k,v) for (k,v) in post.iteritems() if v>10]\n```\n\n\nAn example with no leak::\n\n```python\n    sage: L = [1,0,0,1,0,0,1,1,0,0,0,1,2,0,0,1,0,0,2,0,0,0,0,0,1]\n    sage: test(L, 5)\n    []\n```\n\nFive forgotten polynomials::\n\n```python\n    sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\n    sage: test(L, 5)\n    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]\n```\n\nTwelve forgotten polynomials::\n\n\n```python\n    sage: L = [0,1,2,0,0,2,1,2,1,1,1,0,1,1,2,1,1,1,2,0,0,2,0,2,0]\n    sage: test(L, 5)\n    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 1200)]\n```\n\nA 4 by 4 matrix with five forgotten polynomials::\n\n```python\n    sage: L = [0, 2, 0, 2, 2, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1]\n    sage: test(L, 4)\n    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]\n```\n\n\nRandom ones::\n\n\n```python\n    sage: test([randint(0,100) for _ in range(9)], 3)\n    []\n    sage: test([randint(0,100) for _ in range(16)], 4)\n    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]\n    sage: test([randint(0,2) for _ in range(25)], 5)\n    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]\n    sage: test([randint(0,2) for _ in range(25)], 5)\n    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 1200)]\n    sage: test([randint(0,2) for _ in range(25)], 5)\n    []\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/18897\n\n",
    "created_at": "2015-07-14T09:02:44Z",
    "labels": [
        "memleak",
        "major",
        "bug"
    ],
    "title": "Memory leak in eigenvalues method",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/18660",
    "user": "slabbe"
}
```
CC:  simonking jmantysalo

This method, inspired from the code of Nils Bruin posted in the sage-devel post [Memory leaks on matrix creation?](https://groups.google.com/d/msg/sage-devel/Jqi5f60j_lY/M7esZcJliZoJ), shows some leak in the eigenvalues method for 4x4 and 5x5 integer matrices. Examples are below.


```python
def test(L, dim):
    import gc
    from collections import Counter
    gc.collect()
    pre={id(c) for c in gc.get_objects()}
    for _ in range(100):
        matrix(dim, L).eigenvalues()
    gc.collect()
    post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
    return [(k,v) for (k,v) in post.iteritems() if v>10]
```


An example with no leak::

```python
    sage: L = [1,0,0,1,0,0,1,1,0,0,0,1,2,0,0,1,0,0,2,0,0,0,0,0,1]
    sage: test(L, 5)
    []
```

Five forgotten polynomials::

```python
    sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
    sage: test(L, 5)
    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]
```

Twelve forgotten polynomials::


```python
    sage: L = [0,1,2,0,0,2,1,2,1,1,1,0,1,1,2,1,1,1,2,0,0,2,0,2,0]
    sage: test(L, 5)
    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 1200)]
```

A 4 by 4 matrix with five forgotten polynomials::

```python
    sage: L = [0, 2, 0, 2, 2, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1]
    sage: test(L, 4)
    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]
```


Random ones::


```python
    sage: test([randint(0,100) for _ in range(9)], 3)
    []
    sage: test([randint(0,100) for _ in range(16)], 4)
    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]
    sage: test([randint(0,2) for _ in range(25)], 5)
    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]
    sage: test([randint(0,2) for _ in range(25)], 5)
    [(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 1200)]
    sage: test([randint(0,2) for _ in range(25)], 5)
    []
```


Issue created by migration from https://trac.sagemath.org/ticket/18897





---

archive/issue_comments_254114.json:
```json
{
    "body": "It seems to come from the factor method applied on the charpoly after changing the ring to `AlgebraicField`.\n\n\n```python\ndef test(L, dim):\n    import gc\n    from collections import Counter\n    gc.collect()\n    pre={id(c) for c in gc.get_objects()}\n    for _ in range(100):\n        matrix(dim, L).charpoly().change_ring(QQbar).factor()\n    gc.collect()\n    post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n    return [(k,v) for (k,v) in post.iteritems() if v>10]\n```\n\nWe get:\n\n```python\nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: test(L, 5)\n[(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 1000)]\n```\n",
    "created_at": "2015-07-14T09:36:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254114",
    "user": "slabbe"
}
```

It seems to come from the factor method applied on the charpoly after changing the ring to `AlgebraicField`.


```python
def test(L, dim):
    import gc
    from collections import Counter
    gc.collect()
    pre={id(c) for c in gc.get_objects()}
    for _ in range(100):
        matrix(dim, L).charpoly().change_ring(QQbar).factor()
    gc.collect()
    post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
    return [(k,v) for (k,v) in post.iteritems() if v>10]
```

We get:

```python
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: test(L, 5)
[(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 1000)]
```




---

archive/issue_comments_254115.json:
```json
{
    "body": "Ok, so it seems to come from calling `roots` on an element of the `Univariate Polynomial Ring in x over Algebraic Field` :\n\n\n```python\ndef test():\n    import gc\n    from collections import Counter\n    gc.collect()\n    pre={id(c) for c in gc.get_objects()}\n    R.<x> = QQbar['x']\n    p = x^5 - 8*x^4 + 21*x^3 - 22*x^2 + 9*x - 1\n    for _ in range(100):\n        #p.factor()                              # which then calls:\n        #QQbar._factor_univariate_polynomial(p)  # which then calls:\n        p.roots()\n    gc.collect()\n    post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n    return [(k,v) for (k,v) in post.iteritems() if v>10]\n```\n\nWe get:\n\n```python\nsage: test()\n[(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 1000)]\n```\n",
    "created_at": "2015-07-14T10:03:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254115",
    "user": "slabbe"
}
```

Ok, so it seems to come from calling `roots` on an element of the `Univariate Polynomial Ring in x over Algebraic Field` :


```python
def test():
    import gc
    from collections import Counter
    gc.collect()
    pre={id(c) for c in gc.get_objects()}
    R.<x> = QQbar['x']
    p = x^5 - 8*x^4 + 21*x^3 - 22*x^2 + 9*x - 1
    for _ in range(100):
        #p.factor()                              # which then calls:
        #QQbar._factor_univariate_polynomial(p)  # which then calls:
        p.roots()
    gc.collect()
    post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
    return [(k,v) for (k,v) in post.iteritems() if v>10]
```

We get:

```python
sage: test()
[(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 1000)]
```




---

archive/issue_comments_254116.json:
```json
{
    "body": "Those `univar_pd` are created in the class `CompiledPolynomialFunction` which provides an easy way to create the problem:\n\n\n```python\ndef test():\n    from sage.rings.polynomial.polynomial_compiled import CompiledPolynomialFunction\n    import gc\n    from collections import Counter\n    gc.collect()\n    pre={id(c) for c in gc.get_objects()}\n    L = [-1, 9, -22, 21, -8, 1]\n    for _ in range(100):\n        CompiledPolynomialFunction(L)\n    gc.collect()\n    post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n    return [(k,v) for (k,v) in post.iteritems() if v>10]\n```\n\nand we get:\n\n```python\nsage: test()\n[(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 100)]\n```\n",
    "created_at": "2015-07-14T14:27:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254116",
    "user": "slabbe"
}
```

Those `univar_pd` are created in the class `CompiledPolynomialFunction` which provides an easy way to create the problem:


```python
def test():
    from sage.rings.polynomial.polynomial_compiled import CompiledPolynomialFunction
    import gc
    from collections import Counter
    gc.collect()
    pre={id(c) for c in gc.get_objects()}
    L = [-1, 9, -22, 21, -8, 1]
    for _ in range(100):
        CompiledPolynomialFunction(L)
    gc.collect()
    post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
    return [(k,v) for (k,v) in post.iteritems() if v>10]
```

and we get:

```python
sage: test()
[(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 100)]
```




---

archive/issue_comments_254117.json:
```json
{
    "body": "Ok, so this goes now beyond my knowledge. Somebody else will need to check why the univar_pd are not garbage collected.\n\nhttps://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/polynomial_compiled.pyx#L402",
    "created_at": "2015-07-14T14:53:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254117",
    "user": "slabbe"
}
```

Ok, so this goes now beyond my knowledge. Somebody else will need to check why the univar_pd are not garbage collected.

https://github.com/sagemath/sage/blob/master/src/sage/rings/polynomial/polynomial_compiled.pyx#L402



---

archive/issue_comments_254118.json:
```json
{
    "body": "During initialisation of a compiled polynomial, `_parse_structure()` is called, which creates a `sage.misc.binary_tree.BinaryTree`. Into this binary tree, a `univar_pd` is inserted.\n\nWhen finishing initialisation of a compiled polynomial, the binary tree gets deallocated. However, the `univar_pd` does *not* get deallocated. I don't know why it isn't, but rather clearly that's where the leak is occurring.",
    "created_at": "2015-07-14T19:30:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254118",
    "user": "SimonKing"
}
```

During initialisation of a compiled polynomial, `_parse_structure()` is called, which creates a `sage.misc.binary_tree.BinaryTree`. Into this binary tree, a `univar_pd` is inserted.

When finishing initialisation of a compiled polynomial, the binary tree gets deallocated. However, the `univar_pd` does *not* get deallocated. I don't know why it isn't, but rather clearly that's where the leak is occurring.



---

archive/issue_comments_254119.json:
```json
{
    "body": "Got it!\n\nIt seems that a binary tree is NEVER completely deallocated. When calling `binary_tree_dealloc(node)`, then the left and right descendants of `node` are deallocated, but not `node` itself.",
    "created_at": "2015-07-14T19:51:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254119",
    "user": "SimonKing"
}
```

Got it!

It seems that a binary tree is NEVER completely deallocated. When calling `binary_tree_dealloc(node)`, then the left and right descendants of `node` are deallocated, but not `node` itself.



---

archive/issue_comments_254120.json:
```json
{
    "body": "Replying to [comment:9 SimonKing]:\n> It seems that a binary tree is NEVER completely deallocated. When calling `binary_tree_dealloc(node)`, then the left and right descendants of `node` are deallocated, but not `node` itself.\n\nTo be precise: The pointer to `node` is freed, but one should call `free_binary_tree_node(node)` instead.",
    "created_at": "2015-07-14T19:53:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254120",
    "user": "SimonKing"
}
```

Replying to [comment:9 SimonKing]:
> It seems that a binary tree is NEVER completely deallocated. When calling `binary_tree_dealloc(node)`, then the left and right descendants of `node` are deallocated, but not `node` itself.

To be precise: The pointer to `node` is freed, but one should call `free_binary_tree_node(node)` instead.



---

archive/issue_comments_254121.json:
```json
{
    "body": "I used your test to show that the memory leak is fixed. Note, however, that the fix is in the deallocation of binary trees and has nothing to do with compiled polynomials.\n----\nNew commits:",
    "created_at": "2015-07-14T20:10:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254121",
    "user": "SimonKing"
}
```

I used your test to show that the memory leak is fixed. Note, however, that the fix is in the deallocation of binary trees and has nothing to do with compiled polynomials.
----
New commits:



---

archive/issue_comments_254122.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-07-14T20:10:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254122",
    "user": "SimonKing"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_254123.json:
```json
{
    "body": "Replying to [comment:10 SimonKing]:\n> Replying to [comment:9 SimonKing]:\n> > It seems that a binary tree is NEVER completely deallocated. When calling `binary_tree_dealloc(node)`, then the left and right descendants of `node` are deallocated, but not `node` itself.\n> \n> To be precise: The pointer to `node` is freed, but one should call `free_binary_tree_node(node)` instead.\n\nthe following looks more logical to me (diff over your patch):\n\n```\ndiff --git a/src/sage/misc/binary_tree.pyx b/src/sage/misc/binary_tree.pyx\nindex 984ef57..c637d91 100644\n--- a/src/sage/misc/binary_tree.pyx\n+++ b/src/sage/misc/binary_tree.pyx\n@@ -25,13 +25,11 @@ cdef void free_binary_tree_node(binary_tree_node *self):\n     sage_free(self)\n \n cdef void binary_tree_dealloc(binary_tree_node *self):\n-    # deallocate the descendants of self, but NOT self\n     if self.left != NULL:\n         binary_tree_dealloc(self.left)\n-        free_binary_tree_node(self.left)\n     if self.right != NULL:\n         binary_tree_dealloc(self.right)\n-        free_binary_tree_node(self.right)\n+    free_binary_tree_node(self)\n \n \n cdef void binary_tree_insert(binary_tree_node *self, int key, object value):\n@@ -210,7 +208,6 @@ cdef class BinaryTree:\n         \"\"\"\n         if self.head != NULL:\n             binary_tree_dealloc(self.head)\n-            free_binary_tree_node(self.head)\n \n     def insert(BinaryTree self, object key, object value = None):\n         \"\"\"\n```\n",
    "created_at": "2015-07-15T08:30:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254123",
    "user": "dimpase"
}
```

Replying to [comment:10 SimonKing]:
> Replying to [comment:9 SimonKing]:
> > It seems that a binary tree is NEVER completely deallocated. When calling `binary_tree_dealloc(node)`, then the left and right descendants of `node` are deallocated, but not `node` itself.
> 
> To be precise: The pointer to `node` is freed, but one should call `free_binary_tree_node(node)` instead.

the following looks more logical to me (diff over your patch):

```
diff --git a/src/sage/misc/binary_tree.pyx b/src/sage/misc/binary_tree.pyx
index 984ef57..c637d91 100644
--- a/src/sage/misc/binary_tree.pyx
+++ b/src/sage/misc/binary_tree.pyx
@@ -25,13 +25,11 @@ cdef void free_binary_tree_node(binary_tree_node *self):
     sage_free(self)
 
 cdef void binary_tree_dealloc(binary_tree_node *self):
-    # deallocate the descendants of self, but NOT self
     if self.left != NULL:
         binary_tree_dealloc(self.left)
-        free_binary_tree_node(self.left)
     if self.right != NULL:
         binary_tree_dealloc(self.right)
-        free_binary_tree_node(self.right)
+    free_binary_tree_node(self)
 
 
 cdef void binary_tree_insert(binary_tree_node *self, int key, object value):
@@ -210,7 +208,6 @@ cdef class BinaryTree:
         """
         if self.head != NULL:
             binary_tree_dealloc(self.head)
-            free_binary_tree_node(self.head)
 
     def insert(BinaryTree self, object key, object value = None):
         """
```




---

archive/issue_comments_254124.json:
```json
{
    "body": "The fix proposed by Simon fixes all the way to create the bug I saw yesterday. To me it is a positive review. I added a reference to the ticket in the doctest and posted that on public/18897.\n\n(the comment of dimpase just appeared as I was writing this comment)\n----\nNew commits:",
    "created_at": "2015-07-15T08:48:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254124",
    "user": "slabbe"
}
```

The fix proposed by Simon fixes all the way to create the bug I saw yesterday. To me it is a positive review. I added a reference to the ticket in the doctest and posted that on public/18897.

(the comment of dimpase just appeared as I was writing this comment)
----
New commits:



---

archive/issue_comments_254125.json:
```json
{
    "body": "I am now running tests with the change I proposed (which I like as it makes code shorter and more readable), just to be 100% sure.",
    "created_at": "2015-07-15T08:58:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254125",
    "user": "dimpase"
}
```

I am now running tests with the change I proposed (which I like as it makes code shorter and more readable), just to be 100% sure.



---

archive/issue_comments_254126.json:
```json
{
    "body": "Replying to [comment:14 dimpase]:\n> the following looks more logical to me (diff over your patch):\n\nI wanted the change to be as small as possible. But I wouldn't oppose to have all checks done in `binary_tree_dealloc`:\n\n```python\ncdef void binary_tree_dealloc(binary_tree_node *self):\n    if self == NULL:\n        return\n    binary_tree_dealloc(self.left)\n    binary_tree_dealloc(self.right)\n    free_binary_tree_node(self)\n```\n",
    "created_at": "2015-07-15T09:09:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254126",
    "user": "SimonKing"
}
```

Replying to [comment:14 dimpase]:
> the following looks more logical to me (diff over your patch):

I wanted the change to be as small as possible. But I wouldn't oppose to have all checks done in `binary_tree_dealloc`:

```python
cdef void binary_tree_dealloc(binary_tree_node *self):
    if self == NULL:
        return
    binary_tree_dealloc(self.left)
    binary_tree_dealloc(self.right)
    free_binary_tree_node(self)
```




---

archive/issue_comments_254127.json:
```json
{
    "body": "Replying to [comment:18 SimonKing]:\n> Replying to [comment:14 dimpase]:\n> > the following looks more logical to me (diff over your patch):\n> \n> I wanted the change to be as small as possible. But I wouldn't oppose to have all checks done in `binary_tree_dealloc`:\n\nPS: And then of course `BinaryTree.__dealloc__` simply becomes\n\n```python\n    def __dealloc__(self):\n        binary_tree_dealloc(self.head)\n```\n",
    "created_at": "2015-07-15T09:11:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254127",
    "user": "SimonKing"
}
```

Replying to [comment:18 SimonKing]:
> Replying to [comment:14 dimpase]:
> > the following looks more logical to me (diff over your patch):
> 
> I wanted the change to be as small as possible. But I wouldn't oppose to have all checks done in `binary_tree_dealloc`:

PS: And then of course `BinaryTree.__dealloc__` simply becomes

```python
    def __dealloc__(self):
        binary_tree_dealloc(self.head)
```




---

archive/issue_comments_254128.json:
```json
{
    "body": "PS: I am doing this change now. Also, I am changing `__init__` into `__cinit__`.\n\nRationale: The current `__init__` just sets the pointer `self.head = NULL`. But initialising c-data (pointers etc.) is the job of `__cinit__`: It should initialise the c-data to such extend that `__dealloc__` can not crash. With the current code, there may be circumstances under which the `__init__` is not called, so that `__dealloc__` will fail with a segmentation fault.",
    "created_at": "2015-07-15T09:19:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254128",
    "user": "SimonKing"
}
```

PS: I am doing this change now. Also, I am changing `__init__` into `__cinit__`.

Rationale: The current `__init__` just sets the pointer `self.head = NULL`. But initialising c-data (pointers etc.) is the job of `__cinit__`: It should initialise the c-data to such extend that `__dealloc__` can not crash. With the current code, there may be circumstances under which the `__init__` is not called, so that `__dealloc__` will fail with a segmentation fault.



---

archive/issue_comments_254129.json:
```json
{
    "body": "Replying to [comment:18 SimonKing]:\n> Replying to [comment:14 dimpase]:\n> > the following looks more logical to me (diff over your patch):\n> \n> I wanted the change to be as small as possible. But I wouldn't oppose to have all checks done in `binary_tree_dealloc`:\n> {{{\n> #!python\n> cdef void binary_tree_dealloc(binary_tree_node *self):\n>     if self == NULL:\n>         return\n>     binary_tree_dealloc(self.left)\n>     binary_tree_dealloc(self.right)\n>     free_binary_tree_node(self)\n> }}}\n\nor even \n\n\n```python\ncdef void binary_tree_dealloc(binary_tree_node *self):\n    if self != NULL:\n        binary_tree_dealloc(self.left)\n        binary_tree_dealloc(self.right)\n        free_binary_tree_node(self)\n```\n",
    "created_at": "2015-07-15T09:28:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254129",
    "user": "dimpase"
}
```

Replying to [comment:18 SimonKing]:
> Replying to [comment:14 dimpase]:
> > the following looks more logical to me (diff over your patch):
> 
> I wanted the change to be as small as possible. But I wouldn't oppose to have all checks done in `binary_tree_dealloc`:
> {{{
> #!python
> cdef void binary_tree_dealloc(binary_tree_node *self):
>     if self == NULL:
>         return
>     binary_tree_dealloc(self.left)
>     binary_tree_dealloc(self.right)
>     free_binary_tree_node(self)
> }}}

or even 


```python
cdef void binary_tree_dealloc(binary_tree_node *self):
    if self != NULL:
        binary_tree_dealloc(self.left)
        binary_tree_dealloc(self.right)
        free_binary_tree_node(self)
```




---

archive/issue_comments_254130.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-07-15T09:35:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254130",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_254131.json:
```json
{
    "body": "Something completely different: Shouldn't `BinaryTree` be moved to `sage.data_structures`?\n----\nNew commits:\n----\nNew commits:",
    "created_at": "2015-07-15T09:37:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254131",
    "user": "SimonKing"
}
```

Something completely different: Shouldn't `BinaryTree` be moved to `sage.data_structures`?
----
New commits:
----
New commits:



---

archive/issue_comments_254132.json:
```json
{
    "body": "Replying to [comment:21 dimpase]:\n> or even \n> \n> {{{\n> #!python\n> cdef void binary_tree_dealloc(binary_tree_node *self):\n>     if self != NULL:\n>         binary_tree_dealloc(self.left)\n>         binary_tree_dealloc(self.right)\n>         free_binary_tree_node(self)\n> }}}\n\nRight. Before I change that: Should the module be moved to data_structures? After all, it is a general data structure that does not rely on sage-specific structures (i.e., not on parents and elements).",
    "created_at": "2015-07-15T09:38:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254132",
    "user": "SimonKing"
}
```

Replying to [comment:21 dimpase]:
> or even 
> 
> {{{
> #!python
> cdef void binary_tree_dealloc(binary_tree_node *self):
>     if self != NULL:
>         binary_tree_dealloc(self.left)
>         binary_tree_dealloc(self.right)
>         free_binary_tree_node(self)
> }}}

Right. Before I change that: Should the module be moved to data_structures? After all, it is a general data structure that does not rely on sage-specific structures (i.e., not on parents and elements).



---

archive/issue_comments_254133.json:
```json
{
    "body": "PPS: Why is the implementation of binary trees in sage.combinat.binary_tree totally orthogonal to the one in sage.misc.binary_tree?\n\nI'll ask on sage.combinat, and I suppose moving to sage.data_structure and unification of the two implementations should be on a separate ticket. So, I'll do the additional simplification now, and everything else is for later.",
    "created_at": "2015-07-15T09:43:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254133",
    "user": "SimonKing"
}
```

PPS: Why is the implementation of binary trees in sage.combinat.binary_tree totally orthogonal to the one in sage.misc.binary_tree?

I'll ask on sage.combinat, and I suppose moving to sage.data_structure and unification of the two implementations should be on a separate ticket. So, I'll do the additional simplification now, and everything else is for later.



---

archive/issue_comments_254134.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-07-15T09:45:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254134",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_254135.json:
```json
{
    "body": "I just tried the example in the ticket description, both on unpatched and patched, and got\nthe following disturbing output:\n\n```\n$ sage\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SageMath Version 6.8.beta8, Release Date: 2015-07-10               \u2502\n\u2502 Type \"notebook()\" for the browser-based notebook interface.        \u2502\n\u2502 Type \"help()\" for help.                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Warning: this is a prerelease version, and it may be unstable.     \u2503\n\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\nsage: def test(L, dim):                                      \n        import gc\n        from collections import Counter\n        gc.collect()\n        pre={id(c) for c in gc.get_objects()}\n        for _ in range(100):\n                matrix(dim, L).eigenvalues()\n        gc.collect()\n        post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n        return [(k,v) for (k,v) in post.iteritems() if v>10]\n....:     \nsage: L = [1,0,0,1,0,0,1,1,0,0,0,1,2,0,0,1,0,0,2,0,0,0,0,0,1]\nsage: test(L, 5)\n[(<class 'sage.structure.dynamic_class.DynamicMetaclass'>, 11),\n (<type 'instance'>, 106),\n (<type 'function'>, 1680),\n (<type 'dict'>, 271),\n (<type 'type'>, 78),\n (<type 'method_descriptor'>, 195),\n (<type 'wrapper_descriptor'>, 403),\n (<type 'property'>, 37),\n (<type 'classobj'>, 13),\n (<type 'module'>, 83),\n (<type 'list'>, 262),\n (<type 'sage.misc.constant_function.ConstantFunction'>, 21),\n (<type 'tuple'>, 264),\n (<type 'getset_descriptor'>, 199),\n (<class 'weakref.KeyedRef'>, 64),\n (<class 'numpy.testing.nosetester.NoseTester'>, 19),\n (<type 'staticmethod'>, 50),\n (<type 'member_descriptor'>, 12),\n (<type 'builtin_function_or_method'>, 177),\n (<type 'weakref'>, 152),\n (<type 'instancemethod'>, 22),\n (<type 'cell'>, 40)]\nsage: \n```\n\n\nif I re-run stuff, it works as it should; on the patched system:\n\n```\nsage: test(L, 5) # as before the fix:\n[]\nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: test(L, 5) # did not work before the fix:\n[]\nsage: \n```\n\n\non the unpatched system:\n\n```\nsage: test(L, 5)\n[]\nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: test(L, 5)\n[(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]\nsage: \n```\n\n\nIn short: something happens on the 1st call... \nPerhaps it is harmless, I don't know.",
    "created_at": "2015-07-15T09:58:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254135",
    "user": "dimpase"
}
```

I just tried the example in the ticket description, both on unpatched and patched, and got
the following disturbing output:

```
$ sage
┌────────────────────────────────────────────────────────────────────┐
│ SageMath Version 6.8.beta8, Release Date: 2015-07-10               │
│ Type "notebook()" for the browser-based notebook interface.        │
│ Type "help()" for help.                                            │
└────────────────────────────────────────────────────────────────────┘
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Warning: this is a prerelease version, and it may be unstable.     ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
sage: def test(L, dim):                                      
        import gc
        from collections import Counter
        gc.collect()
        pre={id(c) for c in gc.get_objects()}
        for _ in range(100):
                matrix(dim, L).eigenvalues()
        gc.collect()
        post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
        return [(k,v) for (k,v) in post.iteritems() if v>10]
....:     
sage: L = [1,0,0,1,0,0,1,1,0,0,0,1,2,0,0,1,0,0,2,0,0,0,0,0,1]
sage: test(L, 5)
[(<class 'sage.structure.dynamic_class.DynamicMetaclass'>, 11),
 (<type 'instance'>, 106),
 (<type 'function'>, 1680),
 (<type 'dict'>, 271),
 (<type 'type'>, 78),
 (<type 'method_descriptor'>, 195),
 (<type 'wrapper_descriptor'>, 403),
 (<type 'property'>, 37),
 (<type 'classobj'>, 13),
 (<type 'module'>, 83),
 (<type 'list'>, 262),
 (<type 'sage.misc.constant_function.ConstantFunction'>, 21),
 (<type 'tuple'>, 264),
 (<type 'getset_descriptor'>, 199),
 (<class 'weakref.KeyedRef'>, 64),
 (<class 'numpy.testing.nosetester.NoseTester'>, 19),
 (<type 'staticmethod'>, 50),
 (<type 'member_descriptor'>, 12),
 (<type 'builtin_function_or_method'>, 177),
 (<type 'weakref'>, 152),
 (<type 'instancemethod'>, 22),
 (<type 'cell'>, 40)]
sage: 
```


if I re-run stuff, it works as it should; on the patched system:

```
sage: test(L, 5) # as before the fix:
[]
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: test(L, 5) # did not work before the fix:
[]
sage: 
```


on the unpatched system:

```
sage: test(L, 5)
[]
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: test(L, 5)
[(<type 'sage.rings.polynomial.polynomial_compiled.univar_pd'>, 500)]
sage: 
```


In short: something happens on the 1st call... 
Perhaps it is harmless, I don't know.



---

archive/issue_comments_254136.json:
```json
{
    "body": "Changing priority from major to critical.",
    "created_at": "2015-07-15T09:58:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254136",
    "user": "dimpase"
}
```

Changing priority from major to critical.



---

archive/issue_comments_254137.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-07-15T09:58:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254137",
    "user": "dimpase"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_254138.json:
```json
{
    "body": "perhaps `matrix` leaks in other places, too; on the patched system:\n\n```\n$ sage\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SageMath Version 6.8.beta8, Release Date: 2015-07-10               \u2502\n\u2502 Type \"notebook()\" for the browser-based notebook interface.        \u2502\n\u2502 Type \"help()\" for help.                                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Warning: this is a prerelease version, and it may be unstable.     \u2503\n\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\nsage: matrix(5,[1]*25);                                  \nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: def test(L, dim):                                      \n        import gc\n        from collections import Counter\n        gc.collect()\n        pre={id(c) for c in gc.get_objects()}\n        for _ in range(100):\n                matrix(dim, L).eigenvalues()\n        gc.collect()\n        post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n        return [(k,v) for (k,v) in post.iteritems() if v>10]\n....:     \nsage: test(L, 5)\n[(<type 'function'>, 13),\n (<type 'dict'>, 18),\n (<class 'sage.structure.dynamic_class.DynamicMetaclass'>, 11),\n (<type 'list'>, 34),\n (<type 'sage.misc.constant_function.ConstantFunction'>, 21),\n (<type 'tuple'>, 88),\n (<type 'cell'>, 24),\n (<class 'weakref.KeyedRef'>, 64),\n (<type 'staticmethod'>, 12),\n (<type 'weakref'>, 27)]\nsage: test(L, 5)\n[]\nsage: \n```\n",
    "created_at": "2015-07-15T10:15:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254138",
    "user": "dimpase"
}
```

perhaps `matrix` leaks in other places, too; on the patched system:

```
$ sage
┌────────────────────────────────────────────────────────────────────┐
│ SageMath Version 6.8.beta8, Release Date: 2015-07-10               │
│ Type "notebook()" for the browser-based notebook interface.        │
│ Type "help()" for help.                                            │
└────────────────────────────────────────────────────────────────────┘
┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃ Warning: this is a prerelease version, and it may be unstable.     ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
sage: matrix(5,[1]*25);                                  
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: def test(L, dim):                                      
        import gc
        from collections import Counter
        gc.collect()
        pre={id(c) for c in gc.get_objects()}
        for _ in range(100):
                matrix(dim, L).eigenvalues()
        gc.collect()
        post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
        return [(k,v) for (k,v) in post.iteritems() if v>10]
....:     
sage: test(L, 5)
[(<type 'function'>, 13),
 (<type 'dict'>, 18),
 (<class 'sage.structure.dynamic_class.DynamicMetaclass'>, 11),
 (<type 'list'>, 34),
 (<type 'sage.misc.constant_function.ConstantFunction'>, 21),
 (<type 'tuple'>, 88),
 (<type 'cell'>, 24),
 (<class 'weakref.KeyedRef'>, 64),
 (<type 'staticmethod'>, 12),
 (<type 'weakref'>, 27)]
sage: test(L, 5)
[]
sage: 
```




---

archive/issue_comments_254139.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2015-07-15T10:16:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254139",
    "user": "SimonKing"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_254140.json:
```json
{
    "body": "Replying to [comment:27 dimpase]:\n> In short: something happens on the 1st call... \n> Perhaps it is harmless, I don't know.\n\nWell, if something is only there in the first run, then it is not accumulating, and thus by definition it is not a leak, and thus not critical.",
    "created_at": "2015-07-15T10:16:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254140",
    "user": "SimonKing"
}
```

Replying to [comment:27 dimpase]:
> In short: something happens on the 1st call... 
> Perhaps it is harmless, I don't know.

Well, if something is only there in the first run, then it is not accumulating, and thus by definition it is not a leak, and thus not critical.



---

archive/issue_comments_254141.json:
```json
{
    "body": "On the other hand: What happens if you are also iterating over different base rings?",
    "created_at": "2015-07-15T10:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254141",
    "user": "SimonKing"
}
```

On the other hand: What happens if you are also iterating over different base rings?



---

archive/issue_comments_254142.json:
```json
{
    "body": "\n```\nsage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]\nsage: def test(L, dim):\n....:     import gc\n....:     from collections import Counter\n....:     gc.collect()\n....:     pre={id(c) for c in gc.get_objects()}\n....:     m = matrix(dim, L)\n....:     for p in range(2,102):\n....:         m.change_ring(GF(nth_prime(p))).eigenvalues()\n....:     gc.collect()\n....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)\n....:     return [(k,v) for (k,v) in post.iteritems() if v>10]\n....: \nsage: test(L, 5)\n[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>,\n  100),\n (<type 'sage.libs.ntl.ntl_ZZ_pX.ntl_ZZ_pX'>, 76),\n (<type 'sage.rings.polynomial.polynomial_zmod_flint.Polynomial_zmod_flint'>,\n  2494),\n (<class 'sage.rings.finite_rings.homset.FiniteFieldHomset_with_category'>,\n  76),\n (<type 'sage.categories.morphism.IdentityMorphism'>, 153),\n (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100),\n (<type 'weakref'>, 3700),\n (<type 'sage.categories.map.FormalCompositeMap'>, 200),\n (<class 'sage.rings.finite_rings.finite_field_givaro.FiniteField_givaro_with_category'>,\n  16),\n (<class 'sage.modules.free_module.FreeModule_ambient_field_with_category'>,\n  60),\n (<type 'sage.libs.ntl.ntl_ZZ_pEContext.ntl_ZZ_pEContext_class'>, 75),\n (<type 'sage.categories.morphism.CallMorphism'>, 197),\n (<class 'sage.rings.polynomial.polynomial_ring.PolynomialRing_dense_mod_p_with_category'>,\n  176),\n (<type 'list'>, 8080),\n (<type 'sage.rings.finite_rings.element_givaro.FiniteField_givaroElement'>,\n  523),\n (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),\n (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),\n (<type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>, 382),\n (<type 'sage.misc.constant_function.ConstantFunction'>, 3050),\n (<class 'sage.rings.ideal.Ideal_pid'>, 100),\n (<type 'sage.rings.finite_rings.hom_prime_finite_field.FiniteFieldHomomorphism_prime'>,\n  76),\n (<class 'sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category'>,\n  100),\n (<class 'sage.structure.sequence.Sequence_generic'>, 75),\n (<type 'dict'>, 2034),\n (<type 'sage.misc.cachefunc.CachedMethodCaller'>, 123),\n (<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>,\n  100),\n (<type 'staticmethod'>, 132),\n (<type 'cell'>, 204),\n (<type 'sage.structure.element.NamedBinopMethod'>, 13),\n (<type 'sage.rings.finite_rings.integer_mod.Integer_to_IntegerMod'>, 176),\n (<type 'sage.rings.finite_rings.element_givaro.Cache_givaro'>, 16),\n (<type 'sage.rings.polynomial.polynomial_element.PolynomialBaseringInjection'>,\n  200),\n (<type 'classobj'>, 13),\n (<type 'function'>, 1817),\n (<type 'property'>, 37),\n (<class 'sage.rings.finite_rings.finite_field_pari_ffelt.FiniteField_pari_ffelt_with_category'>,\n  60),\n (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),\n (<class 'sage.structure.dynamic_class.DynamicMetaclass'>, 72),\n (<type 'frozenset'>, 33),\n (<type 'sage.structure.coerce_dict.MonoDictEraser'>, 2087),\n (<type 'sage.structure.coerce_dict.TripleDict'>, 1043),\n (<type 'instancemethod'>, 609),\n (<type 'sage.rings.finite_rings.element_pari_ffelt.FiniteFieldElement_pari_ffelt'>,\n  180),\n (<class 'sage.structure.dynamic_class.DynamicClasscallMetaclass'>, 21),\n (<type 'wrapper_descriptor'>, 513),\n (<type 'instance'>, 106),\n (<type 'sage.libs.ntl.ntl_ZZ_pContext.ntl_ZZ_pContext_class'>, 76),\n (<type 'getset_descriptor'>, 202),\n (<class 'sage.rings.finite_rings.homset.FiniteFieldHomset_with_category'>,\n  76),\n (<type 'sage.structure.coerce_dict.MonoDict'>, 2087),\n (<type 'sage.structure.coerce_maps.DefaultConvertMap_unique'>, 1090),\n (<type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>, 21566),\n (<class 'weakref.KeyedRef'>, 10447),\n (<type 'builtin_function_or_method'>, 428),\n (<type 'member_descriptor'>, 12),\n (<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category.element_class'>,\n  76),\n (<type 'sage.rings.morphism.RingHomomorphism_cover'>, 76),\n (<class 'sage.categories.homset.Homset_with_category'>, 176),\n (<type 'method_descriptor'>, 360),\n (<type 'module'>, 94),\n (<type 'tuple'>, 2688),\n (<type 'sage.libs.pari.gen.gen'>, 60),\n (<type 'sage.structure.coerce_dict.TripleDictEraser'>, 1043),\n (<class 'numpy.testing.nosetester.NoseTester'>, 19),\n (<type 'type'>, 82),\n (<type 'sage.rings.morphism.RingMap_lift'>, 76)]\nsage: test(L, 5)\n[]\n```\n\n\nSo, that looks like a different kind of leak: Some objects are not deallocated when they aren't used (output of the first `test(L, 5)`), but at least they are still available for future use (output of the second `test(L, 5)`).\n\nThe patch from this ticket has fixes one leak, and I'd say that the other leak should be addressed on a different ticket.",
    "created_at": "2015-07-15T10:32:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254142",
    "user": "SimonKing"
}
```


```
sage: L = [1,1,0,1,0,1,2,1,1,0,0,1,2,0,0,1,1,0,2,0,0,0,0,0,1]
sage: def test(L, dim):
....:     import gc
....:     from collections import Counter
....:     gc.collect()
....:     pre={id(c) for c in gc.get_objects()}
....:     m = matrix(dim, L)
....:     for p in range(2,102):
....:         m.change_ring(GF(nth_prime(p))).eigenvalues()
....:     gc.collect()
....:     post=Counter(type(o) for o in gc.get_objects() if id(o) not in pre)
....:     return [(k,v) for (k,v) in post.iteritems() if v>10]
....: 
sage: test(L, 5)
[(<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category'>,
  100),
 (<type 'sage.libs.ntl.ntl_ZZ_pX.ntl_ZZ_pX'>, 76),
 (<type 'sage.rings.polynomial.polynomial_zmod_flint.Polynomial_zmod_flint'>,
  2494),
 (<class 'sage.rings.finite_rings.homset.FiniteFieldHomset_with_category'>,
  76),
 (<type 'sage.categories.morphism.IdentityMorphism'>, 153),
 (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100),
 (<type 'weakref'>, 3700),
 (<type 'sage.categories.map.FormalCompositeMap'>, 200),
 (<class 'sage.rings.finite_rings.finite_field_givaro.FiniteField_givaro_with_category'>,
  16),
 (<class 'sage.modules.free_module.FreeModule_ambient_field_with_category'>,
  60),
 (<type 'sage.libs.ntl.ntl_ZZ_pEContext.ntl_ZZ_pEContext_class'>, 75),
 (<type 'sage.categories.morphism.CallMorphism'>, 197),
 (<class 'sage.rings.polynomial.polynomial_ring.PolynomialRing_dense_mod_p_with_category'>,
  176),
 (<type 'list'>, 8080),
 (<type 'sage.rings.finite_rings.element_givaro.FiniteField_givaroElement'>,
  523),
 (<type 'sage.rings.finite_rings.integer_mod.NativeIntStruct'>, 100),
 (<type 'sage.rings.finite_rings.integer_mod.Int_to_IntegerMod'>, 200),
 (<type 'sage.misc.cachefunc.CachedMethodCallerNoArgs'>, 382),
 (<type 'sage.misc.constant_function.ConstantFunction'>, 3050),
 (<class 'sage.rings.ideal.Ideal_pid'>, 100),
 (<type 'sage.rings.finite_rings.hom_prime_finite_field.FiniteFieldHomomorphism_prime'>,
  76),
 (<class 'sage.rings.finite_rings.finite_field_prime_modn.FiniteField_prime_modn_with_category'>,
  100),
 (<class 'sage.structure.sequence.Sequence_generic'>, 75),
 (<type 'dict'>, 2034),
 (<type 'sage.misc.cachefunc.CachedMethodCaller'>, 123),
 (<class 'sage.rings.finite_rings.conway_polynomials.PseudoConwayLattice'>,
  100),
 (<type 'staticmethod'>, 132),
 (<type 'cell'>, 204),
 (<type 'sage.structure.element.NamedBinopMethod'>, 13),
 (<type 'sage.rings.finite_rings.integer_mod.Integer_to_IntegerMod'>, 176),
 (<type 'sage.rings.finite_rings.element_givaro.Cache_givaro'>, 16),
 (<type 'sage.rings.polynomial.polynomial_element.PolynomialBaseringInjection'>,
  200),
 (<type 'classobj'>, 13),
 (<type 'function'>, 1817),
 (<type 'property'>, 37),
 (<class 'sage.rings.finite_rings.finite_field_pari_ffelt.FiniteField_pari_ffelt_with_category'>,
  60),
 (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),
 (<class 'sage.structure.dynamic_class.DynamicMetaclass'>, 72),
 (<type 'frozenset'>, 33),
 (<type 'sage.structure.coerce_dict.MonoDictEraser'>, 2087),
 (<type 'sage.structure.coerce_dict.TripleDict'>, 1043),
 (<type 'instancemethod'>, 609),
 (<type 'sage.rings.finite_rings.element_pari_ffelt.FiniteFieldElement_pari_ffelt'>,
  180),
 (<class 'sage.structure.dynamic_class.DynamicClasscallMetaclass'>, 21),
 (<type 'wrapper_descriptor'>, 513),
 (<type 'instance'>, 106),
 (<type 'sage.libs.ntl.ntl_ZZ_pContext.ntl_ZZ_pContext_class'>, 76),
 (<type 'getset_descriptor'>, 202),
 (<class 'sage.rings.finite_rings.homset.FiniteFieldHomset_with_category'>,
  76),
 (<type 'sage.structure.coerce_dict.MonoDict'>, 2087),
 (<type 'sage.structure.coerce_maps.DefaultConvertMap_unique'>, 1090),
 (<type 'sage.rings.finite_rings.integer_mod.IntegerMod_int'>, 21566),
 (<class 'weakref.KeyedRef'>, 10447),
 (<type 'builtin_function_or_method'>, 428),
 (<type 'member_descriptor'>, 12),
 (<class 'sage.rings.algebraic_closure_finite_field.AlgebraicClosureFiniteField_pseudo_conway_with_category.element_class'>,
  76),
 (<type 'sage.rings.morphism.RingHomomorphism_cover'>, 76),
 (<class 'sage.categories.homset.Homset_with_category'>, 176),
 (<type 'method_descriptor'>, 360),
 (<type 'module'>, 94),
 (<type 'tuple'>, 2688),
 (<type 'sage.libs.pari.gen.gen'>, 60),
 (<type 'sage.structure.coerce_dict.TripleDictEraser'>, 1043),
 (<class 'numpy.testing.nosetester.NoseTester'>, 19),
 (<type 'type'>, 82),
 (<type 'sage.rings.morphism.RingMap_lift'>, 76)]
sage: test(L, 5)
[]
```


So, that looks like a different kind of leak: Some objects are not deallocated when they aren't used (output of the first `test(L, 5)`), but at least they are still available for future use (output of the second `test(L, 5)`).

The patch from this ticket has fixes one leak, and I'd say that the other leak should be addressed on a different ticket.



---

archive/issue_comments_254143.json:
```json
{
    "body": "\n```\n...\n (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100),\n...\n (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),\n...\n```\n\nI guess that's the culprit.",
    "created_at": "2015-07-15T10:47:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254143",
    "user": "SimonKing"
}
```


```
...
 (<class 'sage.rings.homset.RingHomset_quo_ring_with_category'>, 100),
...
 (<class 'sage.rings.homset.RingHomset_generic_with_category'>, 100),
...
```

I guess that's the culprit.



---

archive/issue_comments_254144.json:
```json
{
    "body": "I opened #18905 to work on the latest leaks. Otherwise, it's good to go.",
    "created_at": "2015-07-15T10:50:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254144",
    "user": "dimpase"
}
```

I opened #18905 to work on the latest leaks. Otherwise, it's good to go.



---

archive/issue_comments_254145.json:
```json
{
    "body": "Replying to [comment:27 dimpase]:\n> In short: something happens on the 1st call... \n> Perhaps it is harmless, I don't know.\n\nYes, I noticed the same thing yesterday. There is stuff that is there the first execution, but never after. I did not look deeper into that...",
    "created_at": "2015-07-15T10:51:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254145",
    "user": "slabbe"
}
```

Replying to [comment:27 dimpase]:
> In short: something happens on the 1st call... 
> Perhaps it is harmless, I don't know.

Yes, I noticed the same thing yesterday. There is stuff that is there the first execution, but never after. I did not look deeper into that...



---

archive/issue_comments_254146.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-07-15T10:51:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254146",
    "user": "dimpase"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_254147.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-07-16T22:51:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/18660",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/18660#issuecomment-254147",
    "user": "vbraun"
}
```

Resolution: fixed
