# Issue 17478: AsymptoticTerm

Issue created by migration from Trac.

Original creator: behackl

Original creation time: 2015-02-02 18:31:07

CC:  dkrenn cheuberg ncohen vdelecroix tmonteil

Keywords: asymptotics

Asymptotic terms are expressions like O(n<sup>2</sup>), 7 * n * 2<sup>n</sup>, or 42 * n * log(n). They build upon the asymptotic growth elements from #17600, which are elements like n<sup>2</sup>, n*2<sup>n</sup> and n * log(n) (that is, they handle only the asymptotic growth). 

All asymptotic terms have an attribute 'growth' (which is some growth element), and then they may have additional information (like, for example, a coefficient in the case of exact terms).

Currently, we implemented the following asymptotic terms (plus their monoid parents):

 GenericTerm::
    Implements the base structure of asymptotic terms.

 OTerm::
    Class for big O terms. These terms may "absorb" other asymptotic terms with weaker or equal growth.

 TermWithCoefficient::
    Generic base class for asymptotic terms with coefficient. Base class for asymptotic exact terms and asymptotic L terms.

 ExactTerm::
    Class for asymptotic exact terms. These terms correspond to symbolic expressions like, for example, 2 * x<sup>3</sup>,  7 * x<sup>-2/5</sup>, or 42 * x<sup>1/3</sup> * log(x).

 LTermGeneric::
    Base class for asymptotic L terms, that is, asymptotic terms that behave like an O term, but with a specified constant and starting point.

Asymptotic terms may be multiplied and absorbed; addition will be handled by AsymptoticExpression.

See meta-ticket #17601 for the planned structure.


---

Comment by git created at 2015-05-26 19:30:42

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by git created at 2015-05-26 19:58:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-05 22:05:16

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2015-06-14 12:21:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-18 20:42:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-06-26 14:47:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-07-02 14:17:26

Last 10 new commits:


---

Comment by behackl created at 2015-07-14 13:01:12

Last 10 new commits:


---

Comment by behackl created at 2015-07-14 13:01:12

Changing keywords from "asymptotics" to "asymptotics, gsoc15".


---

Comment by git created at 2015-07-14 13:02:16

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2015-07-14 20:55:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-07-15 16:34:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-07-21 13:40:11

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2015-07-21 16:07:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-08-12 11:21:00

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2015-08-12 17:11:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-08-13 20:07:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-08-14 14:17:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2015-08-20 07:51:26

Changing status from new to needs_review.


---

Comment by dkrenn created at 2015-08-20 08:05:59

During the project #17601 (the last months in course of GSOC2015 as mentor) I did a very careful reviewing of all code. This includes the code of this ticket. Now this is clearly a positive_review from my side.


---

Comment by git created at 2015-08-20 17:15:00

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2015-08-21 17:55:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2015-09-09 14:59:22

Merge 6.9.beta5
----
New commits:


---

Comment by dkrenn created at 2015-09-15 17:26:56

Changing component from symbolics to asymptotic expansions.


---

Comment by cheuberg created at 2015-09-16 18:16:33


```
$ ./sage -docbuild -u file=src/sage/rings/asymptotic/term_monoid.py html
...
Error building the documentation.
...
Traceback (most recent call last):
...
OSError: [html     ] /home/sci/cheuberg/.sage/docbuild/term_monoid/source/term_monoid.py:docstring of term_monoid.OTermMonoid._coerce_map_from_:33: WARNING: Inline interpreted text or phrase reference start-string without end-string.
```



---

Comment by cheuberg created at 2015-09-16 18:16:33

Changing status from needs_review to needs_work.


---

Comment by behackl created at 2015-09-16 20:40:44

Fixed the docbuild-issue, made some small documentation-related changes, and merged the latest version of #18930 into this branch. Back to `needs_review`.
----
Last 10 new commits:


---

Comment by behackl created at 2015-09-16 20:40:44

Changing status from needs_work to needs_review.


---

Comment by cheuberg created at 2015-09-18 11:42:40

Changing status from needs_review to needs_work.


---

Comment by cheuberg created at 2015-09-18 11:42:40

I reviewed this ticket, added a few reviewer commits and have a few comments:
- `absorption`: One-Sentence-Description should describe what this function _does_. What happens if the elements are not comparable (documentation; probably only possible in a follow-up ticket)?
- `can_absorb`: One-Sentence-Description, then NOTE section would be superfluous.
- `GenericTerm.__init__`: Provide doctests for error conditions
- `GenericTerm.can_absorb` and `GenericTerm._can_absorb_`: Why _two_ methods?
- `GenericTerm.absorb`: what happens if `check` is not set? Why would one want to call that?
- `GenericTerm.absorb`, last 3 lines of code: isn't it quite confusing to override `self` and `other` in the `lambda` expression?
- `GenericTerm._absorb_`: the method is never called in the doctests, in particular, the `NotImplementedError` does not show up.
- `GenericTermMonoid.__init__`: see [#17600, comment 40](http://trac.sagemath.org/ticket/17600#comment:40): handling of tuples as parameter `category`, `__classcall__` for parameter `category`; same question for derived classes?
- `GenericTermMonoid.__init__`: documentation says that `growth_group` has to be a "partially ordered group" with a `GenericGrowthGroup` only listed as an example; code explicitly requires a `GenericGrowthGroup`.
- `GenericTermMonoid._element_constructor_`: why example `T_QQ.coerce(term1)` instead of `T_QQ(term1)`?
- `GenericTermMonoid._element_constructor_`: why `type(data) == self.element_class` and not `isinstance(data, self.element_class)` ? Similarly for other parents.
- `OTermMonoid._coerce_map_from_`: documentation does not agree with code: according to the documentation, `S` must be an `OTermMonoid` or an `ExactTermMonoid`. However, the code does not enforce the former.
- `TermWithCoefficient._le_`: The comparison of coefficients is not documented. Apart from that, do we really want that `x <= 2*I*x` when the coefficient ring is complex?
- `TermWithCoefficientMonoid._init_`: check error condition
- `TermWithCoefficientMonoid.base_ring`: why is this a property instead of a function? Compare with ring of polynomials.
- `TermWithCoefficientMonoid._coerce_map_from_`: documentation mentions "this exact term monoid", but this is a `TermWithCoefficientMonoid`.
- `ExactTerm._repr_`: I do not like the check `self.growth._raw_element_ == 0`, `self.growth` is the identity element of that group, so we should check for that.
- I'd prefer `.is_zero()` over `== 0`.
- `TermMonoidFactory.create_key_and_extra_args`: test error conditions
----
New commits:


---

Comment by behackl created at 2015-09-19 10:26:45

Hello Clemens!

Replying to [comment:34 cheuberg]:
> I reviewed this ticket, added a few reviewer commits and have a few comments:
> - `absorption`: One-Sentence-Description should describe what this function _does_. What happens if the elements are not comparable (documentation; probably only possible in a follow-up ticket)?

I adapted the short description and slightly adapted the code, such that a different ArithmeticError is raised. (This **should** not introduce a merge conflict, this code did not change up to (and including) the cleanup ticket #19083.)

> - `can_absorb`: One-Sentence-Description, then NOTE section would be superfluous.

Done.

> - `GenericTerm.__init__`: Provide doctests for error conditions

I did introduce some tests -- however, only for those errors that are also raised on the cleanup ticket #19083 (... one less thing to think about when merging the changes into there). If you would prefer a full error coverage on this ticket as well, let me know.

> - `GenericTerm.can_absorb` and `GenericTerm._can_absorb_`: Why _two_ methods?

As far as I can remember, we wanted `can_absorb` to be a publicly accessible function, but in the documentation it should not apper too often. Thus, we wrote one public (well-documented) function that calls `_can_absorb_`, and implemented `_can_absorb_` in the derived classes only. 

In any case, I suppose we could change that, as we documented all the "technical" `_can_absorb_`-functions also quite well. What do you think would be cleaner?

> - `GenericTerm.absorb`: what happens if `check` is not set? Why would one want to call that?

At some point we wanted an option to surpress this check because in the `AsymptoticRing`, the `MutablePoset` calls `can_absorb` really **very** often, which makes it a bottleneck, up to some degree. In certain cases, for example when adding an `O`-term into a `MutablePoset`, then the poset first needs to do some comparisons in order to place the `O`-term correctly---and then, in a second step, the `O`-term absorbs all predecessors (without additional comparison!), because `O`-terms can absorb anything with weaker growth.

This was the motivation to have some option that allows to skip the test. Actually doing this optimization is--however--still on our TODO-list.

> - `GenericTerm.absorb`, last 3 lines of code: isn't it quite confusing to override `self` and `other` in the `lambda` expression?

Yes, it really is. Changed to `left` and `right`.

> - `GenericTerm._absorb_`: the method is never called in the doctests, in particular, the `NotImplementedError` does not show up.

Added a doctest that directly calls `GenericTerm._absorb_`.

> - `GenericTermMonoid.__init__`: see [#17600, comment 40](http://trac.sagemath.org/ticket/17600#comment:40): handling of tuples as parameter `category`, `__classcall__` for parameter `category`; same question for derived classes?

Like with the `GrowthGroup`, this is already fixed in #19083. Thus, I'd leave this as is.

> - `GenericTermMonoid.__init__`: documentation says that `growth_group` has to be a "partially ordered group" with a `GenericGrowthGroup` only listed as an example; code explicitly requires a `GenericGrowthGroup`.

This has been partially changed in #19083. There, the growth group only has to be a parent -- but we should probably also check, whether the category of the passed growth group is a subcategory of `Posets()`. This would also fit to the suggested changes in #18223.

In any case, as this ticket enforces the growth group to be derived from `GenericGrowthGroup`, the category is also a subcategory of `Posets()`. Thus, I'd also vote for leaving this as is.

> - `GenericTermMonoid._element_constructor_`: why example `T_QQ.coerce(term1)` instead of `T_QQ(term1)`?

Changed.

> - `GenericTermMonoid._element_constructor_`: why `type(data) == self.element_class` and not `isinstance(data, self.element_class)` ? Similarly for other parents.

Changed.

> - `OTermMonoid._coerce_map_from_`: documentation does not agree with code: according to the documentation, `S` must be an `OTermMonoid` or an `ExactTermMonoid`. However, the code does not enforce the former.

Yes, it does---however, it's not really obvious. Calling 

```
super(OTermMonoid, self)._coerce_map_from_(S)
```

enforces this, as we check `isinstance(S, self.__class__)` there.

> - `TermWithCoefficient._le_`: The comparison of coefficients is not documented. Apart from that, do we really want that `x <= 2*I*x` when the coefficient ring is complex?

This is problematic. For now, I've included a check for the imaginary part---but if the coefficient ring is not ordered, this still causes problems.

I suppose that we could discuss removing `_le_` for these terms altogether, or make terms of equal growth always incomparable: terms of equal growth are not handled via comparison, but via absorption...

> - `TermWithCoefficientMonoid._init_`: check error condition

Rewritten. Now checks whether `base_ring` is in `Rings()`.

> - `TermWithCoefficientMonoid.base_ring`: why is this a property instead of a function? Compare with ring of polynomials.

I believe that this makes some of the code in #19083 that handles the pushout-stuff (... changing the base ring ...) easier. Also, I think that having this as a property is overall cleaner.

Let me know if you think that we should enforce consistency with the `PolynomialRing`.

> - `TermWithCoefficientMonoid._coerce_map_from_`: documentation mentions "this exact term monoid", but this is a `TermWithCoefficientMonoid`.

Fixed.

> - `ExactTerm._repr_`: I do not like the check `self.growth._raw_element_ == 0`, `self.growth` is the identity element of that group, so we should check for that.

Fixed in #19083.

> - I'd prefer `.is_zero()` over `== 0`.

Changed everywhere in #19083.

> - `TermMonoidFactory.create_key_and_extra_args`: test error conditions

Added some more tests.


I pushed my changes to this ticket; please cross-review them and let me know how you want to proceed regarding the open questions.

Thanks for the review!

Benjamin
----
Last 10 new commits:


---

Comment by behackl created at 2015-09-19 10:26:45

Changing status from needs_work to needs_review.


---

Comment by cheuberg created at 2015-09-20 05:41:42

Changing status from needs_review to needs_info.


---

Comment by cheuberg created at 2015-09-20 05:41:42

Replying to [comment:35 behackl]:
> > - `GenericTerm.can_absorb` and `GenericTerm._can_absorb_`: Why _two_ methods?
> 
> As far as I can remember, we wanted `can_absorb` to be a publicly accessible function, but in the documentation it should not apper too often. Thus, we wrote one public (well-documented) function that calls `_can_absorb_`, and implemented `_can_absorb_` in the derived classes only. 
> 
> In any case, I suppose we could change that, as we documented all the "technical" `_can_absorb_`-functions also quite well. What do you think would be cleaner?

My impression when reviewing this ticket was that absorption is explained many times. Perhaps these explanations and examples could have been collected in one place (either in the module documentation or in the relevant methods in the base class). Then the documentation of all overriden classes could have included a link to the general explanation and only explain the particularities of the respective class. Having the explanation in the docstring of a method of the base class would have the advantage that users of `method?` could also access it.

This module is of rather technical nature anyway and the end user will hopefully rarely look into it. Thus reducing the number of occurrences of `can_absorb` in the reference manual does not concern me too much.

IMHO, having `can_absorb` as a trivial wrapper around `_can_absorb_` has a (very slight) performance penalty and makes future reading of the code somewhat harder.

> 
> > - `GenericTerm.absorb`: what happens if `check` is not set? Why would one want to call that?
> 
> At some point we wanted an option to surpress this check because in the `AsymptoticRing`, the `MutablePoset` calls `can_absorb` really **very** often, which makes it a bottleneck, up to some degree. In certain cases, for example when adding an `O`-term into a `MutablePoset`, then the poset first needs to do some comparisons in order to place the `O`-term correctly---and then, in a second step, the `O`-term absorbs all predecessors (without additional comparison!), because `O`-terms can absorb anything with weaker growth.
> 
> This was the motivation to have some option that allows to skip the test. Actually doing this optimization is--however--still on our TODO-list.

Could you add one sentence to the documentation? Something like "Setting `check=False` is meant to be used in cases where the truth of `can_absorb` has been checked in advance to avoid duplicate checking."

> > - `GenericTermMonoid.__init__`: documentation says that `growth_group` has to be a "partially ordered group" with a `GenericGrowthGroup` only listed as an example; code explicitly requires a `GenericGrowthGroup`.
> 
> This has been partially changed in #19083. There, the growth group only has to be a parent -- but we should probably also check, whether the category of the passed growth group is a subcategory of `Posets()`. This would also fit to the suggested changes in #18223.
> 
> In any case, as this ticket enforces the growth group to be derived from `GenericGrowthGroup`, the category is also a subcategory of `Posets()`. Thus, I'd also vote for leaving this as is.

I think that if the current code expects the growth group to be a `GenericGrowthGroup`, then the documentation should state that.

> 
> > - `GenericTermMonoid._element_constructor_`: why example `T_QQ.coerce(term1)` instead of `T_QQ(term1)`?
> 
> Changed.

The attached comment should also be changed. Having a look again, I now partially understand why `coerce` was called in the first place: it seems to explain why comparison in the line above could work. However, in the `_element_constructor_` method, I expected to see an example of conversion.
Perhaps both could be included: first conversion, then comparison and the explanation that coercion did actually work.

> > - `TermWithCoefficient._le_`: The comparison of coefficients is not documented. Apart from that, do we really want that `x <= 2*I*x` when the coefficient ring is complex?
> 
> This is problematic. For now, I've included a check for the imaginary part---but if the coefficient ring is not ordered, this still causes problems.
> 
> I suppose that we could discuss removing `_le_` for these terms altogether, or make terms of equal growth always incomparable: terms of equal growth are not handled via comparison, but via absorption...

I do not know yet what the usecase for comparison of elements of equal growth was supposed to be.
For me, only comparing the growth would be sufficient. Mixing the order of the growth group and the order of the base ring seems to be some kind of overkill, if at all possible.

I am not sure, though, whether `x <= 2*x` and `2*x <= x` should hold. Or what about mixing exact terms and `O` terms.

Are distinct conventions for `_le_` and `can_absorb` necessary?

> > - `TermWithCoefficientMonoid.base_ring`: why is this a property instead of a function? Compare with ring of polynomials.
> 
> I believe that this makes some of the code in #19083 that handles the pushout-stuff (... changing the base ring ...) easier.

Could someone elaborate on that?

> Also, I think that having this as a property is overall cleaner.

Why?

Including this ticket, we have 74 classes with `base_ring`,

```
$rgrep 'def base_ring' | wc
     74     230    4186
```

and one of them (this ticket) has it as a property:

```
$ rgrep -C1 'def base_ring' . |grep property
./rings/asymptotic/term_monoid.py-    `@`property
```


> Let me know if you think that we should enforce consistency with the `PolynomialRing`.

I'd like to see more convincing arguments before breaking consistency with 73 other sage modules.

> I pushed my changes to this ticket; please cross-review them and let me know how you want to proceed regarding the open questions.

done.

I have one further question not discussed so far:

- `absorb` uses the coercion framework before calling `_absorb_` with guaranteed equal parents.
  `can_absorb` does not. Is there a reason for that? Does only the growth group play a role here,
  so that different parents do not really matter?


---

Comment by git created at 2015-09-20 14:42:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2015-09-20 14:44:35

Changing status from needs_info to needs_review.


---

Comment by behackl created at 2015-09-20 14:44:35

Replying to [comment:36 cheuberg]:
> My impression when reviewing this ticket was that absorption is explained many times. Perhaps these explanations and examples could have been collected in one place (either in the module documentation or in the relevant methods in the base class). Then the documentation of all overriden classes could have included a link to the general explanation and only explain the particularities of the respective class. Having the explanation in the docstring of a method of the base class would have the advantage that users of `method?` could also access it.
> 
> This module is of rather technical nature anyway and the end user will hopefully rarely look into it. Thus reducing the number of occurrences of `can_absorb` in the reference manual does not concern me too much.
> 
> IMHO, having `can_absorb` as a trivial wrapper around `_can_absorb_` has a (very slight) performance penalty and makes future reading of the code somewhat harder.

I think that you are right. I've collected the documentation for `absorb` and `can_absorb` and put it in a section of the module description. The respective methods now only have a short documentation (explaining their own behavior), and a reference to that section.
> > 
> > > - `GenericTerm.absorb`: what happens if `check` is not set? Why would one want to call that?
> > 
> > At some point we wanted an option to surpress this check because in the `AsymptoticRing`, the `MutablePoset` calls `can_absorb` really **very** often, which makes it a bottleneck, up to some degree. In certain cases, for example when adding an `O`-term into a `MutablePoset`, then the poset first needs to do some comparisons in order to place the `O`-term correctly---and then, in a second step, the `O`-term absorbs all predecessors (without additional comparison!), because `O`-terms can absorb anything with weaker growth.
> > 
> > This was the motivation to have some option that allows to skip the test. Actually doing this optimization is--however--still on our TODO-list.
> 
> Could you add one sentence to the documentation? Something like "Setting `check=False` is meant to be used in cases where the truth of `can_absorb` has been checked in advance to avoid duplicate checking."

Done.

> > > - `GenericTermMonoid.__init__`: documentation says that `growth_group` has to be a "partially ordered group" with a `GenericGrowthGroup` only listed as an example; code explicitly requires a `GenericGrowthGroup`.
> > 
> > This has been partially changed in #19083. There, the growth group only has to be a parent -- but we should probably also check, whether the category of the passed growth group is a subcategory of `Posets()`. This would also fit to the suggested changes in #18223.
> > 
> > In any case, as this ticket enforces the growth group to be derived from `GenericGrowthGroup`, the category is also a subcategory of `Posets()`. Thus, I'd also vote for leaving this as is.
> 
> I think that if the current code expects the growth group to be a `GenericGrowthGroup`, then the documentation should state that.
> 

It does so now.

> > 
> > > - `GenericTermMonoid._element_constructor_`: why example `T_QQ.coerce(term1)` instead of `T_QQ(term1)`?
> > 
> > Changed.
> 
> The attached comment should also be changed. Having a look again, I now partially understand why `coerce` was called in the first place: it seems to explain why comparison in the line above could work. However, in the `_element_constructor_` method, I expected to see an example of conversion.
> Perhaps both could be included: first conversion, then comparison and the explanation that coercion did actually work.

I don't think that _conversion_ is at work in this particular section---in any case, I've rewritten these doctests slightly in order to better reflect what we want to demonstrate.

> 
> > > - `TermWithCoefficient._le_`: The comparison of coefficients is not documented. Apart from that, do we really want that `x <= 2*I*x` when the coefficient ring is complex?
> > 
> > This is problematic. For now, I've included a check for the imaginary part---but if the coefficient ring is not ordered, this still causes problems.
> > 
> > I suppose that we could discuss removing `_le_` for these terms altogether, or make terms of equal growth always incomparable: terms of equal growth are not handled via comparison, but via absorption...
> 
> I do not know yet what the usecase for comparison of elements of equal growth was supposed to be.
> For me, only comparing the growth would be sufficient. Mixing the order of the growth group and the order of the base ring seems to be some kind of overkill, if at all possible.
> 
> I am not sure, though, whether `x <= 2*x` and `2*x <= x` should hold. Or what about mixing exact terms and `O` terms.
> 
> Are distinct conventions for `_le_` and `can_absorb` necessary?

In fact, we only need the comparison of the underlying growth. I've deleted `TermWithCoefficient._le_` and rewritten the documentation of `GenericTerm.__le__` and `GenericTerm._le_` in order to reflect that.

As this is--as you already said--a rather technical class, I think that it can be justified if `<=` only compares growth. However, if we follow this approach, then `x <= 2*x` and `2*x <= x` would both yield `True`, but `x == 2*x` would be false (because as far as I can remember, we need `==` to actually check if the coefficients are the same too, somewhere in the `AsymptoticRing`). Any thoughts?

> 
> > > - `TermWithCoefficientMonoid.base_ring`: why is this a property instead of a function? Compare with ring of polynomials.
> > 
> > I believe that this makes some of the code in #19083 that handles the pushout-stuff (... changing the base ring ...) easier.
> 
> Could someone elaborate on that?
> 
> > Also, I think that having this as a property is overall cleaner.
> 
> Why?
> 
> Including this ticket, we have 74 classes with `base_ring`,
> {{{
> $rgrep 'def base_ring' | wc
>      74     230    4186
> }}}
> and one of them (this ticket) has it as a property:
> {{{
> $ rgrep -C1 'def base_ring' . |grep property
> ./rings/asymptotic/term_monoid.py-    `@`property
> }}}
> 
> > Let me know if you think that we should enforce consistency with the `PolynomialRing`.
> 
> I'd like to see more convincing arguments before breaking consistency with 73 other sage modules.
> 

Mea culpa, I was wrong. Later on, we renamed `base_ring` to `coefficient_ring`---but as far as I've looked up, we never acutally **set** the property outside of initialization. So this could easily become a function (which is what I also changed here).

> > I pushed my changes to this ticket; please cross-review them and let me know how you want to proceed regarding the open questions.
> 
> done.
> 
> I have one further question not discussed so far:
> 
> - `absorb` uses the coercion framework before calling `_absorb_` with guaranteed equal parents.
>   `can_absorb` does not. Is there a reason for that? Does only the growth group play a role here,
>   so that different parents do not really matter?

Well, we currently only have three cases when `t1.can_absorb(t2)` is called:
- `t1` is a term from an abstract base class. These cannot absorb anything, so `False` is returned. No need to ask the coercion framework.
- `t1` is an `O`-term. In this case, `can_absorb` tests `t1 <= t2`, which in turn asks the coercion framework for help.
- `t1` is an exact term. Here, `t2` can be absorbed if and only if `t2` is an exact term as well, and the growth needs to coincide as well. I don't think that the coercion framework should be involved in this case.

Benjamin


---

Comment by cheuberg created at 2015-09-20 17:35:20

Replying to [comment:38 behackl]:
> In fact, we only need the comparison of the underlying growth. I've deleted `TermWithCoefficient._le_` and rewritten the documentation of `GenericTerm.__le__` and `GenericTerm._le_` in order to reflect that.
> 
> As this is--as you already said--a rather technical class, I think that it can be justified if `<=` only compares growth. However, if we follow this approach, then `x <= 2*x` and `2*x <= x` would both yield `True`, but `x == 2*x` would be false (because as far as I can remember, we need `==` to actually check if the coefficients are the same too, somewhere in the `AsymptoticRing`). Any thoughts?

First, I do not know what the next tickets want to see, whether `<=` has to be antisymmetric or not.
On the other hand, elements of equal growth will always absorb each other and not be elements of the same asymptotic expansion, anyway?

Second, where is the implementation of equality of growth terms?

If in doubt, I would say that `x` and `2x` are incomparable in order to save antisymmetry.

Apart from that, I reviewed your changes, added a few reviewer commits (please cross-review).
----
New commits:


---

Comment by cheuberg created at 2015-09-20 17:35:20

Changing status from needs_review to needs_info.


---

Comment by behackl created at 2015-09-20 18:21:30

Replying to [comment:40 cheuberg]:
> Replying to [comment:38 behackl]:
> > In fact, we only need the comparison of the underlying growth. I've deleted `TermWithCoefficient._le_` and rewritten the documentation of `GenericTerm.__le__` and `GenericTerm._le_` in order to reflect that.
> > 
> > As this is--as you already said--a rather technical class, I think that it can be justified if `<=` only compares growth. However, if we follow this approach, then `x <= 2*x` and `2*x <= x` would both yield `True`, but `x == 2*x` would be false (because as far as I can remember, we need `==` to actually check if the coefficients are the same too, somewhere in the `AsymptoticRing`). Any thoughts?
> 
> First, I do not know what the next tickets want to see, whether `<=` has to be antisymmetric or not.
> On the other hand, elements of equal growth will always absorb each other and not be elements of the same asymptotic expansion, anyway?
> 

I agree, once again. We should preserve that `<=` is antisymmetric, and I propose the following: 
- For terms **without** coefficient, we simply compare the growth with `<=` like we do now.
- For terms **with** coefficient, we check if `term1.growth < term.growth` (still like above), and in case we have `term1.growth == term2.growth`, we return `True` if and only if the terms are the same, i.e. if the coefficient coincides. Otherwise, the terms are incomparable.

I've added this, as well as a short note in the module description how terms are compared.

> Second, where is the implementation of equality of growth terms?
> 
> If in doubt, I would say that `x` and `2x` are incomparable in order to save antisymmetry.

Ah! These did not exist on this ticket -- I have added them as well, as they logically belong here.

> 
> Apart from that, I reviewed your changes, added a few reviewer commits (please cross-review).

I reviewed your changes, and added the points from above (please cross-review again `:-)`).

Benjamin
----
Last 10 new commits:


---

Comment by behackl created at 2015-09-20 18:21:30

Changing status from needs_info to needs_review.


---

Comment by cheuberg created at 2015-09-21 07:23:46

Changing status from needs_review to positive_review.


---

Comment by cheuberg created at 2015-09-21 07:23:46

I added one more trivial language-related commit. Everything is fine for me now. Doctests pass, documentation builds.

Again, the module will only become useful only once at least #17716 is merged.
----
New commits:


---

Comment by vbraun created at 2015-09-22 14:49:15

Resolution: fixed
