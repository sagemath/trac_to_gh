# Issue 31546: Comparison of morphisms is not reliable  and may give wrong answers

archive/issues_031546.json:
```json
{
    "body": "CC:  klee @mwageringel tscrim roed\n\nThe current generic implementation of `_richcmp_` of morphisms assumes cancellation property on the scalar multiplication of the domain. This assumption that does not hold in general opens the door to mathematically wrong answers. For example, \n\n\n```\nsage: S.<a,b> = QQ['a,b'].quotient('a*b')\nsage: R.<x> = S[]\nsage: f = R.hom([b], R)\nsage: g = R.hom([b], R) * R.hom(S.hom([-a, b], S), R)\nsage: f == g  # should be False\nTrue\n```\n\n\nThe aim of this ticket is to reimplement or refactor morphism infrastructure to make comparison of morphisms robust.\n\nThis is a sequel to #28617.\n\nIssue created by migration from https://trac.sagemath.org/ticket/31783\n\n",
    "created_at": "2021-05-06T00:13:26Z",
    "labels": [
        "algebra",
        "major",
        "bug"
    ],
    "title": "Comparison of morphisms is not reliable  and may give wrong answers",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/31546",
    "user": "klee"
}
```
CC:  klee @mwageringel tscrim roed

The current generic implementation of `_richcmp_` of morphisms assumes cancellation property on the scalar multiplication of the domain. This assumption that does not hold in general opens the door to mathematically wrong answers. For example, 


```
sage: S.<a,b> = QQ['a,b'].quotient('a*b')
sage: R.<x> = S[]
sage: f = R.hom([b], R)
sage: g = R.hom([b], R) * R.hom(S.hom([-a, b], S), R)
sage: f == g  # should be False
True
```


The aim of this ticket is to reimplement or refactor morphism infrastructure to make comparison of morphisms robust.

This is a sequel to #28617.

Issue created by migration from https://trac.sagemath.org/ticket/31783





---

archive/issue_comments_450859.json:
```json
{
    "body": "I set this ticket to \"needs review\" in order to get feedback from the patchbot.",
    "created_at": "2021-05-06T23:21:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450859",
    "user": "caruso"
}
```

I set this ticket to "needs review" in order to get feedback from the patchbot.



---

archive/issue_comments_450860.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2021-05-06T23:21:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450860",
    "user": "caruso"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_450861.json:
```json
{
    "body": "Well, maybe the class `RingHomomorphism` is not the right place to add this code since I realized that a lot of ring homomorphisms do not derive for this class. Here are a few examples:\n\n\n```\nsage: from sage.rings.morphism import RingHomomorphism\nsage: isinstance(ZZ.hom(Zmod(6)), RingHomomorphism)\nFalse\n\nsage: R.<x> = ZZ[]\nsage: isinstance(R.coerce_map_from(ZZ), RingHomomorphism)\nFalse\n```\n\n\nShould we change this? Or put the comparison code at the level of categories? Other ideas?",
    "created_at": "2021-05-08T08:11:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450861",
    "user": "caruso"
}
```

Well, maybe the class `RingHomomorphism` is not the right place to add this code since I realized that a lot of ring homomorphisms do not derive for this class. Here are a few examples:


```
sage: from sage.rings.morphism import RingHomomorphism
sage: isinstance(ZZ.hom(Zmod(6)), RingHomomorphism)
False

sage: R.<x> = ZZ[]
sage: isinstance(R.coerce_map_from(ZZ), RingHomomorphism)
False
```


Should we change this? Or put the comparison code at the level of categories? Other ideas?



---

archive/issue_comments_450862.json:
```json
{
    "body": "With the following, this also fixes the problem of #28617, which is really about ring homomorphisms.\n\n```diff\n \n-    def _richcmp_(self, other, int op):\n+    cpdef _richcmp_(self, other, int op):\n         r\"\"\"\n         Compare this ring morphism with ``other``.\n \n-        This is the generic implementation:\n-        we check if both morphisms agree on the generators of the\n-        domain (including generators of successive base rings).\n+        This is a generic implementation. We check if both morphisms agree on\n+        the generators of the domain, including generators of successive base\n+        rings.\n \n         TESTS:\n```\n",
    "created_at": "2021-05-10T09:45:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450862",
    "user": "klee"
}
```

With the following, this also fixes the problem of #28617, which is really about ring homomorphisms.

```diff
 
-    def _richcmp_(self, other, int op):
+    cpdef _richcmp_(self, other, int op):
         r"""
         Compare this ring morphism with ``other``.
 
-        This is the generic implementation:
-        we check if both morphisms agree on the generators of the
-        domain (including generators of successive base rings).
+        This is a generic implementation. We check if both morphisms agree on
+        the generators of the domain, including generators of successive base
+        rings.
 
         TESTS:
```




---

archive/issue_comments_450863.json:
```json
{
    "body": "Replying to [comment:5 caruso]:\n> Well, maybe the class `RingHomomorphism` is not the right place to add this code since I realized that a lot of ring homomorphisms do not derive for this class. Here are a few examples:\n\nI think it is the right place. Other ring homomorphisms may gradually(later) move to the `RingHomomorphism` class.",
    "created_at": "2021-05-10T09:48:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450863",
    "user": "klee"
}
```

Replying to [comment:5 caruso]:
> Well, maybe the class `RingHomomorphism` is not the right place to add this code since I realized that a lot of ring homomorphisms do not derive for this class. Here are a few examples:

I think it is the right place. Other ring homomorphisms may gradually(later) move to the `RingHomomorphism` class.



---

archive/issue_comments_450864.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-12T10:08:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450864",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_450865.json:
```json
{
    "body": "The logic in the class hierarchy of morphisms is sometimes a bit strange (at least I don't always understand it).\n\nIn particular, I cannot understand the difference between the classes `Map` and `Morphism`. At first, I thought that the latter was reserved for mappings preserving some structure whereas the former was used for set-theoretical mappings. But it doesn't seem to be that obvious: for instance, `RingMap` (which is explicitly defined as the set of set-theoretic maps between rings in the documentation) derives from `Morphism` and not from `Map`. Is this a bug or is there some subtlely behind it?",
    "created_at": "2021-05-12T10:16:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450865",
    "user": "caruso"
}
```

The logic in the class hierarchy of morphisms is sometimes a bit strange (at least I don't always understand it).

In particular, I cannot understand the difference between the classes `Map` and `Morphism`. At first, I thought that the latter was reserved for mappings preserving some structure whereas the former was used for set-theoretical mappings. But it doesn't seem to be that obvious: for instance, `RingMap` (which is explicitly defined as the set of set-theoretic maps between rings in the documentation) derives from `Morphism` and not from `Map`. Is this a bug or is there some subtlely behind it?



---

archive/issue_comments_450866.json:
```json
{
    "body": "Replying to [comment:9 caruso]:\n> The logic in the class hierarchy of morphisms is sometimes a bit strange (at least I don't always understand it).\n> \n> In particular, I cannot understand the difference between the classes `Map` and `Morphism`. At first, I thought that the latter was reserved for mappings preserving some structure whereas the former was used for set-theoretical mappings. But it doesn't seem to be that obvious: for instance, `RingMap` (which is explicitly defined as the set of set-theoretic maps between rings in the documentation) derives from `Morphism` and not from `Map`. Is this a bug or is there some subtlely behind it?\n\n`RingMap` is there just to provide the common name \"Set-theoretic ring\". I think the adjective \"set-theoretic\" is meaningless as all ring morphisms are set-theoretic. I guess `RingMap` could equally be `RingMorphism` but the author seems to have preferred `RingMap` as the class name.",
    "created_at": "2021-05-12T11:23:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450866",
    "user": "klee"
}
```

Replying to [comment:9 caruso]:
> The logic in the class hierarchy of morphisms is sometimes a bit strange (at least I don't always understand it).
> 
> In particular, I cannot understand the difference between the classes `Map` and `Morphism`. At first, I thought that the latter was reserved for mappings preserving some structure whereas the former was used for set-theoretical mappings. But it doesn't seem to be that obvious: for instance, `RingMap` (which is explicitly defined as the set of set-theoretic maps between rings in the documentation) derives from `Morphism` and not from `Map`. Is this a bug or is there some subtlely behind it?

`RingMap` is there just to provide the common name "Set-theoretic ring". I think the adjective "set-theoretic" is meaningless as all ring morphisms are set-theoretic. I guess `RingMap` could equally be `RingMorphism` but the author seems to have preferred `RingMap` as the class name.



---

archive/issue_comments_450867.json:
```json
{
    "body": "Both `RingMap` and `RingHomomorphism` exist. Reading the documentation, I've understood that `RingMap` should be used for morphism between rings which are not ring homomorphisms (a typical example is the map `GF(p) -> ZZ` taking an integer mod p to its smallest representative).\n\nHowever, I'm not sure there is a real interest to distinguish between `RingMap` and just `Map`.",
    "created_at": "2021-05-12T11:56:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450867",
    "user": "caruso"
}
```

Both `RingMap` and `RingHomomorphism` exist. Reading the documentation, I've understood that `RingMap` should be used for morphism between rings which are not ring homomorphisms (a typical example is the map `GF(p) -> ZZ` taking an integer mod p to its smallest representative).

However, I'm not sure there is a real interest to distinguish between `RingMap` and just `Map`.



---

archive/issue_comments_450868.json:
```json
{
    "body": "Replying to [comment:11 caruso]:\n> However, I'm not sure there is a real interest to distinguish between `RingMap` and just `Map`.\n\nThere could be a performance reason for it as we really want some important rings to have really fast maps (but not necessarily morphisms) between them. I don't know of an explicit example of this, but this might be a reason. Another is that it is just old code that is in need of cleanup.",
    "created_at": "2021-05-13T00:21:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450868",
    "user": "tscrim"
}
```

Replying to [comment:11 caruso]:
> However, I'm not sure there is a real interest to distinguish between `RingMap` and just `Map`.

There could be a performance reason for it as we really want some important rings to have really fast maps (but not necessarily morphisms) between them. I don't know of an explicit example of this, but this might be a reason. Another is that it is just old code that is in need of cleanup.



---

archive/issue_comments_450869.json:
```json
{
    "body": "I had a discussion with David Roe on zulip about this ticket.\n\nThe starting point of our discussion is the observation that there are currently two concurrent systems for handling the different types of morphisms provided by Sage: the class hierarchy and the category framework. This causes confusion and sometimes contradiction.\n\nWe believe that it would be great to clarify the situation and clearly separate the roles of these two systems. Roughly speaking, our proposal is to use the class hierarchy to handle different types of implementations and let the category stuff handle mathematical properties of the morphisms.\n\nIn this perspective, we do not want to keep the class `RingHomomorphism` for instance, but want to move the methods therein to the category. Contrarily having special classes for coercion maps or for maps whose domains are polynomial rings continues to make sense.\n\nAny class can implement its own `_richcmp_` method if there is a good reason for (typically a very simple way to compare morphisms of this type). However, a `_richcmp_` method should be also provided by the category and it will be used as a fallback if the class does not provide any specific implementation (or if it returns `NotImplemented`). (Maybe it would be a good idea to have different names for those methods, e.g. `_richcmp_class` and `_richcmp_category`, especially since inheritence with the special method `_richcmp_` seems to work very bizarrely.)\n\nThe same approach could also be used for compositions.\n\nSince this touches a lot of things in the structure of morphisms in Sage, I would appreciate to have your feedback before starting to write code.",
    "created_at": "2021-05-13T22:13:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450869",
    "user": "caruso"
}
```

I had a discussion with David Roe on zulip about this ticket.

The starting point of our discussion is the observation that there are currently two concurrent systems for handling the different types of morphisms provided by Sage: the class hierarchy and the category framework. This causes confusion and sometimes contradiction.

We believe that it would be great to clarify the situation and clearly separate the roles of these two systems. Roughly speaking, our proposal is to use the class hierarchy to handle different types of implementations and let the category stuff handle mathematical properties of the morphisms.

In this perspective, we do not want to keep the class `RingHomomorphism` for instance, but want to move the methods therein to the category. Contrarily having special classes for coercion maps or for maps whose domains are polynomial rings continues to make sense.

Any class can implement its own `_richcmp_` method if there is a good reason for (typically a very simple way to compare morphisms of this type). However, a `_richcmp_` method should be also provided by the category and it will be used as a fallback if the class does not provide any specific implementation (or if it returns `NotImplemented`). (Maybe it would be a good idea to have different names for those methods, e.g. `_richcmp_class` and `_richcmp_category`, especially since inheritence with the special method `_richcmp_` seems to work very bizarrely.)

The same approach could also be used for compositions.

Since this touches a lot of things in the structure of morphisms in Sage, I would appreciate to have your feedback before starting to write code.



---

archive/issue_comments_450870.json:
```json
{
    "body": "An additional remark I just noticed: related questions were already discussed in #23204.",
    "created_at": "2021-05-13T22:43:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450870",
    "user": "caruso"
}
```

An additional remark I just noticed: related questions were already discussed in #23204.



---

archive/issue_comments_450871.json:
```json
{
    "body": "Short version, see comment:12.\n\nLong version, overall, I think this would be a great thing to do, but there are a few things to be very careful about in terms of speed regressions. Examples of some rings that should have fast-as-possible maps are polynomial rings and finite fields. Granted, comparing morphism is unlikely to be a bottleneck, but if the whole hierarchy is being redone, some of the methods might get swept up in this as well.\n\nOne sticking point could be that it is very hard to implement generic comparisons at the category level because these comparisons depend strongly on the specific implementation of the morphisms. There is the related issue with the homset parents not having a unique element class as you can want morphisms that behave very differently or needing varying internal structures.\n\nNote that `_richcmp_` is not a special method (as opposed to `__richcmp__`); it follows the usual inheritance. However, many of the morphisms are extension classes, so these actual morphism instances are not dynamically created classes and some magic needs to be done with `__getattr__` in order to check stuff in the category.\n\nMy suggestion would be to map out a little bit about the class and category hierarchy that you want to have with the morphisms for the rings. It doesn't need to be complete, but having a bit of a plan before starting to code could be useful.",
    "created_at": "2021-05-13T23:12:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450871",
    "user": "tscrim"
}
```

Short version, see comment:12.

Long version, overall, I think this would be a great thing to do, but there are a few things to be very careful about in terms of speed regressions. Examples of some rings that should have fast-as-possible maps are polynomial rings and finite fields. Granted, comparing morphism is unlikely to be a bottleneck, but if the whole hierarchy is being redone, some of the methods might get swept up in this as well.

One sticking point could be that it is very hard to implement generic comparisons at the category level because these comparisons depend strongly on the specific implementation of the morphisms. There is the related issue with the homset parents not having a unique element class as you can want morphisms that behave very differently or needing varying internal structures.

Note that `_richcmp_` is not a special method (as opposed to `__richcmp__`); it follows the usual inheritance. However, many of the morphisms are extension classes, so these actual morphism instances are not dynamically created classes and some magic needs to be done with `__getattr__` in order to check stuff in the category.

My suggestion would be to map out a little bit about the class and category hierarchy that you want to have with the morphisms for the rings. It doesn't need to be complete, but having a bit of a plan before starting to code could be useful.



---

archive/issue_comments_450872.json:
```json
{
    "body": "Replying to [comment:15 tscrim]:\n> Short version, see comment:12.\n\nOh yes, I saw your comment but forgot to answer.\nSince basically the class `RingMap` does nothing more than `Map` except redefining `_repr_type`, I can't believe there is a performance issue here.\n\nBut I agree with you that in general we have to be very careful about this.\n \n> Long version, overall, I think this would be a great thing to do, but there are a few things to be very careful about in terms of speed regressions. Examples of some rings that should have fast-as-possible maps are polynomial rings and finite fields. Granted, comparing morphism is unlikely to be a bottleneck, but if the whole hierarchy is being redone, some of the methods might get swept up in this as well.\n\nThat's a good point.\nEspecially since I've understood (but I might be wrong) that it's not possible to have cython methods in the category. Is this correct?\n\n> One sticking point could be that it is very hard to implement generic comparisons at the category level because these comparisons depend strongly on the specific implementation of the morphisms. There is the related issue with the homset parents not having a unique element class as you can want morphisms that behave very differently or needing varying internal structures.\n\nI think it makes sense at least for some categories.\nFor instance, equalities of ring homomorphisms can be checked by comparing the images of the generators. Again, I might be wrong but I suspect that in most cases, the objects in Sage are finitely generated, so if we have enough information about the underlying structure (which is a priori encoded in the category), implementing a reliable comparison test sounds feasible.\n\n> Note that `_richcmp_` is not a special method (as opposed to `__richcmp__`); it follows the usual inheritance. However, many of the morphisms are extension classes, so these actual morphism instances are not dynamically created classes and some magic needs to be done with `__getattr__` in order to check stuff in the category.\n\nOK. Thanks for the clarification.\nI previously encountered several issues with inheritance of rich comparisons, but it was probably because I was using directly `__richcmp__`.\n\n> My suggestion would be to map out a little bit about the class and category hierarchy that you want to have with the morphisms for the rings. It doesn't need to be complete, but having a bit of a plan before starting to code could be useful.\n\nThat's a good idea. Thanks.",
    "created_at": "2021-05-14T07:57:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450872",
    "user": "caruso"
}
```

Replying to [comment:15 tscrim]:
> Short version, see comment:12.

Oh yes, I saw your comment but forgot to answer.
Since basically the class `RingMap` does nothing more than `Map` except redefining `_repr_type`, I can't believe there is a performance issue here.

But I agree with you that in general we have to be very careful about this.
 
> Long version, overall, I think this would be a great thing to do, but there are a few things to be very careful about in terms of speed regressions. Examples of some rings that should have fast-as-possible maps are polynomial rings and finite fields. Granted, comparing morphism is unlikely to be a bottleneck, but if the whole hierarchy is being redone, some of the methods might get swept up in this as well.

That's a good point.
Especially since I've understood (but I might be wrong) that it's not possible to have cython methods in the category. Is this correct?

> One sticking point could be that it is very hard to implement generic comparisons at the category level because these comparisons depend strongly on the specific implementation of the morphisms. There is the related issue with the homset parents not having a unique element class as you can want morphisms that behave very differently or needing varying internal structures.

I think it makes sense at least for some categories.
For instance, equalities of ring homomorphisms can be checked by comparing the images of the generators. Again, I might be wrong but I suspect that in most cases, the objects in Sage are finitely generated, so if we have enough information about the underlying structure (which is a priori encoded in the category), implementing a reliable comparison test sounds feasible.

> Note that `_richcmp_` is not a special method (as opposed to `__richcmp__`); it follows the usual inheritance. However, many of the morphisms are extension classes, so these actual morphism instances are not dynamically created classes and some magic needs to be done with `__getattr__` in order to check stuff in the category.

OK. Thanks for the clarification.
I previously encountered several issues with inheritance of rich comparisons, but it was probably because I was using directly `__richcmp__`.

> My suggestion would be to map out a little bit about the class and category hierarchy that you want to have with the morphisms for the rings. It doesn't need to be complete, but having a bit of a plan before starting to code could be useful.

That's a good idea. Thanks.



---

archive/issue_comments_450873.json:
```json
{
    "body": "Replying to [comment:16 caruso]:\n> Especially since I've understood (but I might be wrong) that it's not possible to have cython methods in the category. Is this correct?\n\nYes, that's correct since categories have to by in Python (IIRC, I think there is a limitation with how things get converted into Cython. Much more certainly, categories cannot be extension classes.)",
    "created_at": "2021-05-17T04:54:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450873",
    "user": "tscrim"
}
```

Replying to [comment:16 caruso]:
> Especially since I've understood (but I might be wrong) that it's not possible to have cython methods in the category. Is this correct?

Yes, that's correct since categories have to by in Python (IIRC, I think there is a limitation with how things get converted into Cython. Much more certainly, categories cannot be extension classes.)



---

archive/issue_comments_450874.json:
```json
{
    "body": "Are you going to do this restructuring for this ticket or on a followup ticket?\n\nOne change for this ticket:\n\n```diff\n-Implemented only when the domain has methods `gens` and `base_ring`.\n+Implemented only when the domain has methods ``gens`` and ``base_ring``.\n```\n\n\nBefore the patchbot will run, the ticket needs an author.",
    "created_at": "2021-05-17T04:58:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450874",
    "user": "tscrim"
}
```

Are you going to do this restructuring for this ticket or on a followup ticket?

One change for this ticket:

```diff
-Implemented only when the domain has methods `gens` and `base_ring`.
+Implemented only when the domain has methods ``gens`` and ``base_ring``.
```


Before the patchbot will run, the ticket needs an author.



---

archive/issue_comments_450875.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-18T06:17:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450875",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_450876.json:
```json
{
    "body": "My initial plan was to put all the changes in this ticket but, thinking again at it, I think you're right, it's better to open a new ticket.",
    "created_at": "2021-05-18T06:19:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450876",
    "user": "caruso"
}
```

My initial plan was to put all the changes in this ticket but, thinking again at it, I think you're right, it's better to open a new ticket.



---

archive/issue_comments_450877.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-18T07:03:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450877",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_450878.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-18T07:17:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450878",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_450879.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-19T11:59:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450879",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_450880.json:
```json
{
    "body": "OK, patchbot now looks happy with the ticket.\n\nSo, I'd say that the ticket is ready for review.",
    "created_at": "2021-05-20T03:20:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450880",
    "user": "caruso"
}
```

OK, patchbot now looks happy with the ticket.

So, I'd say that the ticket is ready for review.



---

archive/issue_comments_450881.json:
```json
{
    "body": "This seems good to me overall. I don't immediately see the need for the `is_coercion_map()` method. Yet, that could benefit from having a quick check to see if `self is` the coercion map:\n\n```diff\n-        if not self.codomain().has_coerce_map_from(domain):\n+        f = self.codomain()._internal_coerce_map_from(domain)\n+        if f is None:\n             return False\n+        if f is self:\n+            return True\n```\n\nAlso, there is a bunch of duplicate code with `is_coercion_map()` and `is_identity()`. I think `is_identity()` can simply call `is_coercion_map()` after checking the domain equals the codomain.",
    "created_at": "2021-05-22T08:52:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450881",
    "user": "tscrim"
}
```

This seems good to me overall. I don't immediately see the need for the `is_coercion_map()` method. Yet, that could benefit from having a quick check to see if `self is` the coercion map:

```diff
-        if not self.codomain().has_coerce_map_from(domain):
+        f = self.codomain()._internal_coerce_map_from(domain)
+        if f is None:
             return False
+        if f is self:
+            return True
```

Also, there is a bunch of duplicate code with `is_coercion_map()` and `is_identity()`. I think `is_identity()` can simply call `is_coercion_map()` after checking the domain equals the codomain.



---

archive/issue_comments_450882.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-05-22T09:48:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450882",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_450883.json:
```json
{
    "body": "Replying to [comment:25 tscrim]:\n> I don't immediately see the need for the `is_coercion_map()` method.\n\nWell, I don't have any very good reason but I'd say that it's natural to have this method in sage where coercion maps play a central role.\n\n> Yet, that could benefit from having a quick check to see if `self is` the coercion map:\n> {{{#!diff\n> -        if not self.codomain().has_coerce_map_from(domain):\n> +        f = self.codomain()._internal_coerce_map_from(domain)\n> +        if f is None:\n>              return False\n> +        if f is self:\n> +            return True\n> }}}\n> Also, there is a bunch of duplicate code with `is_coercion_map()` and `is_identity()`. I think `is_identity()` can simply call `is_coercion_map()` after checking the domain equals the codomain.\nYou're right. I made the modifications.",
    "created_at": "2021-05-22T10:02:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450883",
    "user": "caruso"
}
```

Replying to [comment:25 tscrim]:
> I don't immediately see the need for the `is_coercion_map()` method.

Well, I don't have any very good reason but I'd say that it's natural to have this method in sage where coercion maps play a central role.

> Yet, that could benefit from having a quick check to see if `self is` the coercion map:
> {{{#!diff
> -        if not self.codomain().has_coerce_map_from(domain):
> +        f = self.codomain()._internal_coerce_map_from(domain)
> +        if f is None:
>              return False
> +        if f is self:
> +            return True
> }}}
> Also, there is a bunch of duplicate code with `is_coercion_map()` and `is_identity()`. I think `is_identity()` can simply call `is_coercion_map()` after checking the domain equals the codomain.
You're right. I made the modifications.



---

archive/issue_comments_450884.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-05-23T05:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450884",
    "user": "tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_450885.json:
```json
{
    "body": "Then let it be so.",
    "created_at": "2021-05-23T05:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450885",
    "user": "tscrim"
}
```

Then let it be so.



---

archive/issue_comments_450886.json:
```json
{
    "body": "Merge conflict with latest beta.",
    "created_at": "2021-06-02T02:24:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450886",
    "user": "klee"
}
```

Merge conflict with latest beta.



---

archive/issue_comments_450887.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2021-06-02T02:24:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/31546",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/31546#issuecomment-450887",
    "user": "klee"
}
```

Changing status from positive_review to needs_work.
