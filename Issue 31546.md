# Issue 31546: Comparison of morphisms is not reliable  and may give wrong answers

Issue created by migration from https://trac.sagemath.org/ticket/31783

Original creator: klee

Original creation time: 2021-05-06 00:13:26

CC:  klee @mwageringel tscrim roed

The current generic implementation of `_richcmp_` of morphisms assumes cancellation property on the scalar multiplication of the domain. This assumption that does not hold in general opens the door to mathematically wrong answers. For example, 


```
sage: S.<a,b> = QQ['a,b'].quotient('a*b')
sage: R.<x> = S[]
sage: f = R.hom([b], R)
sage: g = R.hom([b], R) * R.hom(S.hom([-a, b], S), R)
sage: f == g  # should be False
True
```


The aim of this ticket is to reimplement or refactor morphism infrastructure to make comparison of morphisms robust.

This is a sequel to #28617.


---

Comment by caruso created at 2021-05-06 23:21:09

I set this ticket to "needs review" in order to get feedback from the patchbot.


---

Comment by caruso created at 2021-05-06 23:21:09

Changing status from new to needs_review.


---

Comment by caruso created at 2021-05-08 08:11:23

Well, maybe the class `RingHomomorphism` is not the right place to add this code since I realized that a lot of ring homomorphisms do not derive for this class. Here are a few examples:


```
sage: from sage.rings.morphism import RingHomomorphism
sage: isinstance(ZZ.hom(Zmod(6)), RingHomomorphism)
False

sage: R.<x> = ZZ[]
sage: isinstance(R.coerce_map_from(ZZ), RingHomomorphism)
False
```


Should we change this? Or put the comparison code at the level of categories? Other ideas?


---

Comment by klee created at 2021-05-10 09:45:34

With the following, this also fixes the problem of #28617, which is really about ring homomorphisms.

```diff
 
-    def _richcmp_(self, other, int op):
+    cpdef _richcmp_(self, other, int op):
         r"""
         Compare this ring morphism with ``other``.
 
-        This is the generic implementation:
-        we check if both morphisms agree on the generators of the
-        domain (including generators of successive base rings).
+        This is a generic implementation. We check if both morphisms agree on
+        the generators of the domain, including generators of successive base
+        rings.
 
         TESTS:
```



---

Comment by klee created at 2021-05-10 09:48:29

Replying to [comment:5 caruso]:
> Well, maybe the class `RingHomomorphism` is not the right place to add this code since I realized that a lot of ring homomorphisms do not derive for this class. Here are a few examples:

I think it is the right place. Other ring homomorphisms may gradually(later) move to the `RingHomomorphism` class.


---

Comment by git created at 2021-05-12 10:08:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2021-05-12 10:16:03

The logic in the class hierarchy of morphisms is sometimes a bit strange (at least I don't always understand it).

In particular, I cannot understand the difference between the classes `Map` and `Morphism`. At first, I thought that the latter was reserved for mappings preserving some structure whereas the former was used for set-theoretical mappings. But it doesn't seem to be that obvious: for instance, `RingMap` (which is explicitly defined as the set of set-theoretic maps between rings in the documentation) derives from `Morphism` and not from `Map`. Is this a bug or is there some subtlely behind it?


---

Comment by klee created at 2021-05-12 11:23:29

Replying to [comment:9 caruso]:
> The logic in the class hierarchy of morphisms is sometimes a bit strange (at least I don't always understand it).
> 
> In particular, I cannot understand the difference between the classes `Map` and `Morphism`. At first, I thought that the latter was reserved for mappings preserving some structure whereas the former was used for set-theoretical mappings. But it doesn't seem to be that obvious: for instance, `RingMap` (which is explicitly defined as the set of set-theoretic maps between rings in the documentation) derives from `Morphism` and not from `Map`. Is this a bug or is there some subtlely behind it?

`RingMap` is there just to provide the common name "Set-theoretic ring". I think the adjective "set-theoretic" is meaningless as all ring morphisms are set-theoretic. I guess `RingMap` could equally be `RingMorphism` but the author seems to have preferred `RingMap` as the class name.


---

Comment by caruso created at 2021-05-12 11:56:24

Both `RingMap` and `RingHomomorphism` exist. Reading the documentation, I've understood that `RingMap` should be used for morphism between rings which are not ring homomorphisms (a typical example is the map `GF(p) -> ZZ` taking an integer mod p to its smallest representative).

However, I'm not sure there is a real interest to distinguish between `RingMap` and just `Map`.


---

Comment by tscrim created at 2021-05-13 00:21:50

Replying to [comment:11 caruso]:
> However, I'm not sure there is a real interest to distinguish between `RingMap` and just `Map`.

There could be a performance reason for it as we really want some important rings to have really fast maps (but not necessarily morphisms) between them. I don't know of an explicit example of this, but this might be a reason. Another is that it is just old code that is in need of cleanup.


---

Comment by caruso created at 2021-05-13 22:13:00

I had a discussion with David Roe on zulip about this ticket.

The starting point of our discussion is the observation that there are currently two concurrent systems for handling the different types of morphisms provided by Sage: the class hierarchy and the category framework. This causes confusion and sometimes contradiction.

We believe that it would be great to clarify the situation and clearly separate the roles of these two systems. Roughly speaking, our proposal is to use the class hierarchy to handle different types of implementations and let the category stuff handle mathematical properties of the morphisms.

In this perspective, we do not want to keep the class `RingHomomorphism` for instance, but want to move the methods therein to the category. Contrarily having special classes for coercion maps or for maps whose domains are polynomial rings continues to make sense.

Any class can implement its own `_richcmp_` method if there is a good reason for (typically a very simple way to compare morphisms of this type). However, a `_richcmp_` method should be also provided by the category and it will be used as a fallback if the class does not provide any specific implementation (or if it returns `NotImplemented`). (Maybe it would be a good idea to have different names for those methods, e.g. `_richcmp_class` and `_richcmp_category`, especially since inheritence with the special method `_richcmp_` seems to work very bizarrely.)

The same approach could also be used for compositions.

Since this touches a lot of things in the structure of morphisms in Sage, I would appreciate to have your feedback before starting to write code.


---

Comment by caruso created at 2021-05-13 22:43:40

An additional remark I just noticed: related questions were already discussed in #23204.


---

Comment by tscrim created at 2021-05-13 23:12:40

Short version, see comment:12.

Long version, overall, I think this would be a great thing to do, but there are a few things to be very careful about in terms of speed regressions. Examples of some rings that should have fast-as-possible maps are polynomial rings and finite fields. Granted, comparing morphism is unlikely to be a bottleneck, but if the whole hierarchy is being redone, some of the methods might get swept up in this as well.

One sticking point could be that it is very hard to implement generic comparisons at the category level because these comparisons depend strongly on the specific implementation of the morphisms. There is the related issue with the homset parents not having a unique element class as you can want morphisms that behave very differently or needing varying internal structures.

Note that `_richcmp_` is not a special method (as opposed to `__richcmp__`); it follows the usual inheritance. However, many of the morphisms are extension classes, so these actual morphism instances are not dynamically created classes and some magic needs to be done with `__getattr__` in order to check stuff in the category.

My suggestion would be to map out a little bit about the class and category hierarchy that you want to have with the morphisms for the rings. It doesn't need to be complete, but having a bit of a plan before starting to code could be useful.


---

Comment by caruso created at 2021-05-14 07:57:14

Replying to [comment:15 tscrim]:
> Short version, see comment:12.

Oh yes, I saw your comment but forgot to answer.
Since basically the class `RingMap` does nothing more than `Map` except redefining `_repr_type`, I can't believe there is a performance issue here.

But I agree with you that in general we have to be very careful about this.
 
> Long version, overall, I think this would be a great thing to do, but there are a few things to be very careful about in terms of speed regressions. Examples of some rings that should have fast-as-possible maps are polynomial rings and finite fields. Granted, comparing morphism is unlikely to be a bottleneck, but if the whole hierarchy is being redone, some of the methods might get swept up in this as well.

That's a good point.
Especially since I've understood (but I might be wrong) that it's not possible to have cython methods in the category. Is this correct?

> One sticking point could be that it is very hard to implement generic comparisons at the category level because these comparisons depend strongly on the specific implementation of the morphisms. There is the related issue with the homset parents not having a unique element class as you can want morphisms that behave very differently or needing varying internal structures.

I think it makes sense at least for some categories.
For instance, equalities of ring homomorphisms can be checked by comparing the images of the generators. Again, I might be wrong but I suspect that in most cases, the objects in Sage are finitely generated, so if we have enough information about the underlying structure (which is a priori encoded in the category), implementing a reliable comparison test sounds feasible.

> Note that `_richcmp_` is not a special method (as opposed to `__richcmp__`); it follows the usual inheritance. However, many of the morphisms are extension classes, so these actual morphism instances are not dynamically created classes and some magic needs to be done with `__getattr__` in order to check stuff in the category.

OK. Thanks for the clarification.
I previously encountered several issues with inheritance of rich comparisons, but it was probably because I was using directly `__richcmp__`.

> My suggestion would be to map out a little bit about the class and category hierarchy that you want to have with the morphisms for the rings. It doesn't need to be complete, but having a bit of a plan before starting to code could be useful.

That's a good idea. Thanks.


---

Comment by tscrim created at 2021-05-17 04:54:03

Replying to [comment:16 caruso]:
> Especially since I've understood (but I might be wrong) that it's not possible to have cython methods in the category. Is this correct?

Yes, that's correct since categories have to by in Python (IIRC, I think there is a limitation with how things get converted into Cython. Much more certainly, categories cannot be extension classes.)


---

Comment by tscrim created at 2021-05-17 04:58:53

Are you going to do this restructuring for this ticket or on a followup ticket?

One change for this ticket:

```diff
-Implemented only when the domain has methods `gens` and `base_ring`.
+Implemented only when the domain has methods ``gens`` and ``base_ring``.
```


Before the patchbot will run, the ticket needs an author.


---

Comment by git created at 2021-05-18 06:17:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2021-05-18 06:19:19

My initial plan was to put all the changes in this ticket but, thinking again at it, I think you're right, it's better to open a new ticket.


---

Comment by git created at 2021-05-18 07:03:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-05-18 07:17:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-05-19 11:59:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2021-05-20 03:20:52

OK, patchbot now looks happy with the ticket.

So, I'd say that the ticket is ready for review.


---

Comment by tscrim created at 2021-05-22 08:52:26

This seems good to me overall. I don't immediately see the need for the `is_coercion_map()` method. Yet, that could benefit from having a quick check to see if `self is` the coercion map:

```diff
-        if not self.codomain().has_coerce_map_from(domain):
+        f = self.codomain()._internal_coerce_map_from(domain)
+        if f is None:
             return False
+        if f is self:
+            return True
```

Also, there is a bunch of duplicate code with `is_coercion_map()` and `is_identity()`. I think `is_identity()` can simply call `is_coercion_map()` after checking the domain equals the codomain.


---

Comment by git created at 2021-05-22 09:48:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by caruso created at 2021-05-22 10:02:40

Replying to [comment:25 tscrim]:
> I don't immediately see the need for the `is_coercion_map()` method.

Well, I don't have any very good reason but I'd say that it's natural to have this method in sage where coercion maps play a central role.

> Yet, that could benefit from having a quick check to see if `self is` the coercion map:
> {{{#!diff
> -        if not self.codomain().has_coerce_map_from(domain):
> +        f = self.codomain()._internal_coerce_map_from(domain)
> +        if f is None:
>              return False
> +        if f is self:
> +            return True
> }}}
> Also, there is a bunch of duplicate code with `is_coercion_map()` and `is_identity()`. I think `is_identity()` can simply call `is_coercion_map()` after checking the domain equals the codomain.
You're right. I made the modifications.


---

Comment by tscrim created at 2021-05-23 05:21:43

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2021-05-23 05:21:43

Then let it be so.


---

Comment by klee created at 2021-06-02 02:24:42

Merge conflict with latest beta.


---

Comment by klee created at 2021-06-02 02:24:42

Changing status from positive_review to needs_work.
