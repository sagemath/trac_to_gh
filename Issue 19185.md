# Issue 19185: A new structure for Punctured Codes

archive/issues_019185.json:
```json
{
    "body": "CC:  wdj ppurka\n\nThis ticket proposes a new implementation for punctured codes.\n\nIt contains:\n\n- a new code class, `PuncturedCode`\n\n- a dedicated encoder to compute the generator matrix of a Punctured Code.\n\nThis new structure presents the following advantages:\n\n- it keeps track of the code it comes from. If one punctures a code A, the punctured code he gets will remember it comes from A.\n\n- This allows to perform several operations, like encoding or picking a random element without constructing the generator matrix for the punctured code, thus saving time and memory.\n\n- Later on, it will also allow to decode words using a decoder over the original code of the punctured code.\n\nIssue created by migration from https://trac.sagemath.org/ticket/19422\n\n",
    "created_at": "2015-10-16T13:43:28Z",
    "labels": [
        "coding theory",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-7.3",
    "title": "A new structure for Punctured Codes",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19185",
    "user": "dlucas"
}
```
CC:  wdj ppurka

This ticket proposes a new implementation for punctured codes.

It contains:

- a new code class, `PuncturedCode`

- a dedicated encoder to compute the generator matrix of a Punctured Code.

This new structure presents the following advantages:

- it keeps track of the code it comes from. If one punctures a code A, the punctured code he gets will remember it comes from A.

- This allows to perform several operations, like encoding or picking a random element without constructing the generator matrix for the punctured code, thus saving time and memory.

- Later on, it will also allow to decode words using a decoder over the original code of the punctured code.

Issue created by migration from https://trac.sagemath.org/ticket/19422





---

archive/issue_comments_263221.json:
```json
{
    "body": "Content available, it's now ready for review.\n----\nNew commits:",
    "created_at": "2015-10-16T13:47:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263221",
    "user": "dlucas"
}
```

Content available, it's now ready for review.
----
New commits:



---

archive/issue_comments_263222.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-10-16T13:47:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263222",
    "user": "dlucas"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_263223.json:
```json
{
    "body": "`AbstractLinearCode` has a method `punctured`. Shouldn't this return a `PuncturedCode` object after this patch?",
    "created_at": "2015-10-18T16:28:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263223",
    "user": "jsrn"
}
```

`AbstractLinearCode` has a method `punctured`. Shouldn't this return a `PuncturedCode` object after this patch?



---

archive/issue_comments_263224.json:
```json
{
    "body": "I chose to keep this method as it directly returns a `LinearCode` object.\nSo if one wants to puncture and immediately get the `LinearCode` representation of his punctured code, he can thanks to this method. I plan to change it when the mechanism to get another representation of a punctured code (e.g. get a RS code from a punctured RS code) will be ready.",
    "created_at": "2015-10-19T07:38:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263224",
    "user": "dlucas"
}
```

I chose to keep this method as it directly returns a `LinearCode` object.
So if one wants to puncture and immediately get the `LinearCode` representation of his punctured code, he can thanks to this method. I plan to change it when the mechanism to get another representation of a punctured code (e.g. get a RS code from a punctured RS code) will be ready.



---

archive/issue_comments_263225.json:
```json
{
    "body": "I think the default should always be to retain as much structure as possible. The `C.punctured()` method is certainly the \"default\" a user would call.\n\nFurthermore, having a `PuncturedCode` should never get in the way for users who are simply interested in the unstructured linear code representation: it advertises exactly the same methods (plus some more). So I don't think there is any deprecation needed.",
    "created_at": "2015-10-19T10:03:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263225",
    "user": "jsrn"
}
```

I think the default should always be to retain as much structure as possible. The `C.punctured()` method is certainly the "default" a user would call.

Furthermore, having a `PuncturedCode` should never get in the way for users who are simply interested in the unstructured linear code representation: it advertises exactly the same methods (plus some more). So I don't think there is any deprecation needed.



---

archive/issue_comments_263226.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-19T10:32:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263226",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263227.json:
```json
{
    "body": "Ok, I agree with you.\n\nChanges have been made and pushed.",
    "created_at": "2015-10-19T10:33:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263227",
    "user": "dlucas"
}
```

Ok, I agree with you.

Changes have been made and pushed.



---

archive/issue_comments_263228.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-13T10:08:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263228",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263229.json:
```json
{
    "body": "A few updates on this ticket:\n\n- it's now under the latest beta\n- as we now have the structure for decoders in Sage, I added a dedicated decoder for punctured codes\n- as we now have GRS codes in Sage, which still are GRS codes after puncturing, I introduced a mechanism which allows one to get the most specific representation possible for a punctured code, based on the original code.\n\nThis is still open for review.",
    "created_at": "2016-01-13T10:13:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263229",
    "user": "dlucas"
}
```

A few updates on this ticket:

- it's now under the latest beta
- as we now have the structure for decoders in Sage, I added a dedicated decoder for punctured codes
- as we now have GRS codes in Sage, which still are GRS codes after puncturing, I introduced a mechanism which allows one to get the most specific representation possible for a punctured code, based on the original code.

This is still open for review.



---

archive/issue_comments_263230.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-01-27T16:21:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263230",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263231.json:
```json
{
    "body": "I updated this ticket to latest beta, and fixed merge conflict.\nIt's still open for review.",
    "created_at": "2016-01-27T16:21:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263231",
    "user": "dlucas"
}
```

I updated this ticket to latest beta, and fixed merge conflict.
It's still open for review.



---

archive/issue_comments_263232.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2016-02-22T13:41:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263232",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_263233.json:
```json
{
    "body": "I fixed a few typos, updated deprecated imports which were breaking doctests.\nI also completely rewrote doctests and documentation of the decoder, using GRS decoders introduced in #19653.\n\nThis is still open for review.",
    "created_at": "2016-02-22T13:42:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263233",
    "user": "dlucas"
}
```

I fixed a few typos, updated deprecated imports which were breaking doctests.
I also completely rewrote doctests and documentation of the decoder, using GRS decoders introduced in #19653.

This is still open for review.



---

archive/issue_comments_263234.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2016-02-26T14:37:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263234",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_263235.json:
```json
{
    "body": "I updated this ticket to the latest beta and fixed conflicts. This is still open for review.",
    "created_at": "2016-02-26T14:38:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263235",
    "user": "dlucas"
}
```

I updated this ticket to the latest beta and fixed conflicts. This is still open for review.



---

archive/issue_comments_263236.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-31T13:39:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263236",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263237.json:
```json
{
    "body": "I updated this ticket to 7.2beta1 and fixed a broken doctest.\nThis is still open for review.",
    "created_at": "2016-03-31T13:41:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263237",
    "user": "dlucas"
}
```

I updated this ticket to 7.2beta1 and fixed a broken doctest.
This is still open for review.



---

archive/issue_comments_263238.json:
```json
{
    "body": "I start the review even though the ticket is not updated to the latest beta. Despite my comments, note that I realize that building this framework must have been a huge work, and that I found it really user-friendly =)\n\n*** General remarks ***\n\n* As I read the (quite long) name of the canonical decoder of your punctured code (`PuncturedCodeOriginalCodeDecoder`), I asked myself the following question: if I understand well your naming convention, decoders are named `Code`+`DecoderName`. Is it necessary to have the `Code` suffix ? My point is that it could be sufficient to only keep `DecoderName`, because if a user wants to know what kind of code the decoder is applied to, he just needs to call `Dec.code()`.\n* You consider puncturing points as a list. Would it be better (and more confortable to compute unions and intersections) to consider them a set ?\n\n*** index.rst ***\n\n* why do you remove `sage/coding/source_coding/huffman` ?\n\n*** src/sage/coding/grs.py ***\n\n* The method `_punctured_form(self, points)` doesn't work if `points` is not sorted (e.g. `C_grs._punctured_form([4,3])`). That's due to your strange way to select the evaluation points and multipliers. I think you should remove the block:\n\n```\nstart = 0\nfor i in points:\n    punctured_alphas += alphas[start:i]\n    punctured_col_mults += col_mults[start:i]\n    start = i + 1\n    punctured_alphas += alphas[start:n]\n    punctured_col_mults += col_mults[start:n]\n```\n\n\nand replace it by something like (that's only a suggestion):\n\n\n```\npunctured_alphas = [ alphas[i] for i in range(n) if i not in points ]\npunctured_col_mults = [ col_mults[i] for i in range(n) if i not in points ]\n```\n\n* In the same method, if I understand it well, this block:\n\n```\nif G.rank() != dimension:\n    G = G.echelon_form()\n    for i in range(dimension):\n        if G[i] == 0:\n        dimension -= 1\n```\n\n\naims at computing the code dimension (stored in `dimension`). In fact, you already computed it in `G.rank()`.\n\n*** src/sage/coding/linear_code.py ***\n\n* in `_punctured_form` method, `G.echelon_form()` puts all the zero lines at the bottom of the new matrix. Thus, if you want to get the non-zero part of the matrix, I think you could simply write\n\n```\n    k = G.rank()\n    return LinearCode(G[:k])\n```\n",
    "created_at": "2016-04-16T11:58:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263238",
    "user": "jlavauzelle"
}
```

I start the review even though the ticket is not updated to the latest beta. Despite my comments, note that I realize that building this framework must have been a huge work, and that I found it really user-friendly =)

*** General remarks ***

* As I read the (quite long) name of the canonical decoder of your punctured code (`PuncturedCodeOriginalCodeDecoder`), I asked myself the following question: if I understand well your naming convention, decoders are named `Code`+`DecoderName`. Is it necessary to have the `Code` suffix ? My point is that it could be sufficient to only keep `DecoderName`, because if a user wants to know what kind of code the decoder is applied to, he just needs to call `Dec.code()`.
* You consider puncturing points as a list. Would it be better (and more confortable to compute unions and intersections) to consider them a set ?

*** index.rst ***

* why do you remove `sage/coding/source_coding/huffman` ?

*** src/sage/coding/grs.py ***

* The method `_punctured_form(self, points)` doesn't work if `points` is not sorted (e.g. `C_grs._punctured_form([4,3])`). That's due to your strange way to select the evaluation points and multipliers. I think you should remove the block:

```
start = 0
for i in points:
    punctured_alphas += alphas[start:i]
    punctured_col_mults += col_mults[start:i]
    start = i + 1
    punctured_alphas += alphas[start:n]
    punctured_col_mults += col_mults[start:n]
```


and replace it by something like (that's only a suggestion):


```
punctured_alphas = [ alphas[i] for i in range(n) if i not in points ]
punctured_col_mults = [ col_mults[i] for i in range(n) if i not in points ]
```

* In the same method, if I understand it well, this block:

```
if G.rank() != dimension:
    G = G.echelon_form()
    for i in range(dimension):
        if G[i] == 0:
        dimension -= 1
```


aims at computing the code dimension (stored in `dimension`). In fact, you already computed it in `G.rank()`.

*** src/sage/coding/linear_code.py ***

* in `_punctured_form` method, `G.echelon_form()` puts all the zero lines at the bottom of the new matrix. Thus, if you want to get the non-zero part of the matrix, I think you could simply write

```
    k = G.rank()
    return LinearCode(G[:k])
```




---

archive/issue_comments_263239.json:
```json
{
    "body": "*** src/sage/coding/punctured_code.py ***\n--- function `puncture` ---\n- same strange way to compute the non-punctured positions than in grs.py. For example, it doesn't work with:\n\n```\nC = codes.RandomLinearCode(11, 5, GF(7))\nCp = codes.PuncturedCode(C, [4,3])\nv = vector(GF(7), (2,3,0,2,1,5,1,5,6,5,3))\nsage.coding.punctured_code.puncture(v, [4,3], Cp)\n```\n\n\n--- class `PuncturedCode` ---\n- constructor:\n`positions = list(set(positions))` is a short (maybe dirty) way to do:\n\n```\nunique_positions = set()\nfor i in positions:\n    unique_positions.add(i)\npositions = []\nfor i in unique_positions:\n   positions.append(i)\n```\n\nand it looks to sort the elements as well =) Also remark that you don't have this \"multiplicity\" issue when using Python sets (instead of lists) for storing puncturing points.\n- in encode() method, you missed parentheses after `self.punctured_positions` in `return puncture(c, self.punctured_positions, self)`\n- in structured_representation(self) method: in the doc, you wrote \"A punctured GRS code is still a punctured code\" but I think you meant \"still a GRS code\". Moreover, I don't understand what you mean by \"Which is not the case for generic linear codes\": punctured linear codes are still linear codes.\n- still in structured_representation(self) method, I tried this:\n\n```\nsage: C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)\nsage: P = codes.PuncturedCode(C, [1,3])\nsage: Q = codes.PuncturedCode(P, [1,3])\nsage: P.length()\n5\nsage: Q.length()\n3\nsage: P.structured_representation()\n[5, 4, 2] Generalized Reed-Solomon Code over Finite Field of size 7\nsage: Q.structured_representation()\n[5, 3, 3] Generalized Reed-Solomon Code over Finite Field of size 7\n```\n\nSo, double puncturing works well (`Q` seems to be the right code), but `structured_representation()` doesn't build the right Reed-Solomon code.\n\n--- class `PuncturedCodePuncturedMatrixEncoder` ---\n- in `GeneratorMatrix`: same comment as in linear_code.py, I think echelon_form()do the job and you just need to keep the `k` first rows.\n\n--- class `PuncturedCodeOriginalCodeDecoder` ---\n- sage is stuck (infinite loop ?) when I run this:\n\n```\nsage: R = codes.RandomLinearCode(11, 5, GF(7))\nsage: P = codes.PuncturedCode(R, [1,3])\nsage: P.decoder()\n```\n\n- l.444: you wrote ``'random_values'`` instead of ``'random-values'``\n- in the constructor: you have a test variable `error_erasure` to which you assign `0` and `1`. Maybe `True` and `False` are more explicit.\n- in `decode_to_code`: l.600, I think you forgot to increment `shift` (otherwise I misunderstood the use of `shift`)\n- maybe add an `elif self._strategy == 'try-all'` at line 643.\n- l.670: `ValueError(\"The number of erasures exceed decoding capability\")` --> exceeds\n- l.672: decoding capability must be:\n\n```\n    return (diff - punctured -1) // 2\n```\n\n- l.665; you could have negative radius with:\n\n```\nif self._strategy != 'try-all' and \"error-erasure\" not in D.decoder_type():\n    return D.decoding_radius() - punctured\n```\n\n- I don't understand the last `return D.decoding_radius()`, line 675. To which case does it apply ?",
    "created_at": "2016-04-16T12:01:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263239",
    "user": "jlavauzelle"
}
```

*** src/sage/coding/punctured_code.py ***
--- function `puncture` ---
- same strange way to compute the non-punctured positions than in grs.py. For example, it doesn't work with:

```
C = codes.RandomLinearCode(11, 5, GF(7))
Cp = codes.PuncturedCode(C, [4,3])
v = vector(GF(7), (2,3,0,2,1,5,1,5,6,5,3))
sage.coding.punctured_code.puncture(v, [4,3], Cp)
```


--- class `PuncturedCode` ---
- constructor:
`positions = list(set(positions))` is a short (maybe dirty) way to do:

```
unique_positions = set()
for i in positions:
    unique_positions.add(i)
positions = []
for i in unique_positions:
   positions.append(i)
```

and it looks to sort the elements as well =) Also remark that you don't have this "multiplicity" issue when using Python sets (instead of lists) for storing puncturing points.
- in encode() method, you missed parentheses after `self.punctured_positions` in `return puncture(c, self.punctured_positions, self)`
- in structured_representation(self) method: in the doc, you wrote "A punctured GRS code is still a punctured code" but I think you meant "still a GRS code". Moreover, I don't understand what you mean by "Which is not the case for generic linear codes": punctured linear codes are still linear codes.
- still in structured_representation(self) method, I tried this:

```
sage: C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)
sage: P = codes.PuncturedCode(C, [1,3])
sage: Q = codes.PuncturedCode(P, [1,3])
sage: P.length()
5
sage: Q.length()
3
sage: P.structured_representation()
[5, 4, 2] Generalized Reed-Solomon Code over Finite Field of size 7
sage: Q.structured_representation()
[5, 3, 3] Generalized Reed-Solomon Code over Finite Field of size 7
```

So, double puncturing works well (`Q` seems to be the right code), but `structured_representation()` doesn't build the right Reed-Solomon code.

--- class `PuncturedCodePuncturedMatrixEncoder` ---
- in `GeneratorMatrix`: same comment as in linear_code.py, I think echelon_form()do the job and you just need to keep the `k` first rows.

--- class `PuncturedCodeOriginalCodeDecoder` ---
- sage is stuck (infinite loop ?) when I run this:

```
sage: R = codes.RandomLinearCode(11, 5, GF(7))
sage: P = codes.PuncturedCode(R, [1,3])
sage: P.decoder()
```

- l.444: you wrote ``'random_values'`` instead of ``'random-values'``
- in the constructor: you have a test variable `error_erasure` to which you assign `0` and `1`. Maybe `True` and `False` are more explicit.
- in `decode_to_code`: l.600, I think you forgot to increment `shift` (otherwise I misunderstood the use of `shift`)
- maybe add an `elif self._strategy == 'try-all'` at line 643.
- l.670: `ValueError("The number of erasures exceed decoding capability")` --> exceeds
- l.672: decoding capability must be:

```
    return (diff - punctured -1) // 2
```

- l.665; you could have negative radius with:

```
if self._strategy != 'try-all' and "error-erasure" not in D.decoder_type():
    return D.decoding_radius() - punctured
```

- I don't understand the last `return D.decoding_radius()`, line 675. To which case does it apply ?



---

archive/issue_comments_263240.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-04-16T12:01:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263240",
    "user": "jlavauzelle"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_263241.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-16T15:07:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263241",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263242.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-04-16T15:14:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263242",
    "user": "dlucas"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_263243.json:
```json
{
    "body": "Hello Julien,\n\nThanks for your thorough review!\n\nI followed all your suggestions (good idea to change the set of points to a list!).\nSome remarks/answers follow:\n\n- As `positions` is now a set, the test of duplicate positions in the constructor is no longer needed.\n- Open question: now that I changed `positions` to a set, the `str` methods return the ugly str format of a set: `set([3,4])` for `{3, 4}`. Which means the string representation of a punctured code now states `PuncturedCode coming from ... punctured in position(s) set([pos])` which is quite ugly... So, do you think I should keep that, or, only for these `str` methods return a list while it might be a bit confusing for the user because he/she entered a set a got a list?\n\n> sage is stuck (infinite loop ?) when I run this: \n\nOh, yes, it's not an infinite loop! It's because it builds the original decoder of your code, namely a `SyndromeDecoder` for a linear code over GF(7), length 11, dimension 5... Which takes a while because of the table of syndromes which is heavy to build.\n\nBest,\n\nDavid",
    "created_at": "2016-04-16T15:14:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263243",
    "user": "dlucas"
}
```

Hello Julien,

Thanks for your thorough review!

I followed all your suggestions (good idea to change the set of points to a list!).
Some remarks/answers follow:

- As `positions` is now a set, the test of duplicate positions in the constructor is no longer needed.
- Open question: now that I changed `positions` to a set, the `str` methods return the ugly str format of a set: `set([3,4])` for `{3, 4}`. Which means the string representation of a punctured code now states `PuncturedCode coming from ... punctured in position(s) set([pos])` which is quite ugly... So, do you think I should keep that, or, only for these `str` methods return a list while it might be a bit confusing for the user because he/she entered a set a got a list?

> sage is stuck (infinite loop ?) when I run this: 

Oh, yes, it's not an infinite loop! It's because it builds the original decoder of your code, namely a `SyndromeDecoder` for a linear code over GF(7), length 11, dimension 5... Which takes a while because of the table of syndromes which is heavy to build.

Best,

David



---

archive/issue_comments_263244.json:
```json
{
    "body": "I'd prefer it if the user could enter either a set or a list of punctured positions, or a single position. The internal representation as a set probably makes sense though. I consider str and repr as just pretty-printing, so formatting as a (sorted) list make sense.",
    "created_at": "2016-04-16T16:13:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263244",
    "user": "jsrn"
}
```

I'd prefer it if the user could enter either a set or a list of punctured positions, or a single position. The internal representation as a set probably makes sense though. I consider str and repr as just pretty-printing, so formatting as a (sorted) list make sense.



---

archive/issue_comments_263245.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-18T09:19:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263245",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263246.json:
```json
{
    "body": "Hello,\n\nThe user can now pass either an Integer, an int, a list or a set to `PuncturedCode`. The internal representation is a set. I added a few extra sanitization tests, so if one passes a list/set of anything but ints/Integers, an exception is raised.\n\nI also reinstated the list representation of the punctured positions for str methods.\n\nRemark:\n\nfor now, `punctured_positions` (the getter for `positions`) always return a set, even if one passed an int/Integer/list at construction time. I think it's fine like that, but if you think it can be confusing/annoying for the user, I can change its behaviour so it returns the exact data one passed at construction time.\n\nThis is still open for review.\n\nBest,\n\nDavid",
    "created_at": "2016-04-18T09:23:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263246",
    "user": "dlucas"
}
```

Hello,

The user can now pass either an Integer, an int, a list or a set to `PuncturedCode`. The internal representation is a set. I added a few extra sanitization tests, so if one passes a list/set of anything but ints/Integers, an exception is raised.

I also reinstated the list representation of the punctured positions for str methods.

Remark:

for now, `punctured_positions` (the getter for `positions`) always return a set, even if one passed an int/Integer/list at construction time. I think it's fine like that, but if you think it can be confusing/annoying for the user, I can change its behaviour so it returns the exact data one passed at construction time.

This is still open for review.

Best,

David



---

archive/issue_comments_263247.json:
```json
{
    "body": "Awesome!\n\n> for now, `punctured_positions` (the getter for `positions`) always return a set, even if one passed an int/Integer/list at construction time. I think it's fine like that, but if you think it can be confusing/annoying for the user, I can change its behaviour so it returns the exact data one passed at construction time.\n\nI think this makes complete sense.",
    "created_at": "2016-04-18T11:34:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263247",
    "user": "jsrn"
}
```

Awesome!

> for now, `punctured_positions` (the getter for `positions`) always return a set, even if one passed an int/Integer/list at construction time. I think it's fine like that, but if you think it can be confusing/annoying for the user, I can change its behaviour so it returns the exact data one passed at construction time.

I think this makes complete sense.



---

archive/issue_comments_263248.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-19T12:12:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263248",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263249.json:
```json
{
    "body": "Hello,\n\nI fixed a bug: Punctured Code's decoder was not working if its original decoder was a list decoder.\nI changed `puncture` method (which is BTW now called `_puncture` as it's a helper function): it can now puncture a list of vectors or a vector. This takes care of the list-decoding issue.\n\nBest,\n\nDavid",
    "created_at": "2016-04-19T12:14:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263249",
    "user": "dlucas"
}
```

Hello,

I fixed a bug: Punctured Code's decoder was not working if its original decoder was a list decoder.
I changed `puncture` method (which is BTW now called `_puncture` as it's a helper function): it can now puncture a list of vectors or a vector. This takes care of the list-decoding issue.

Best,

David



---

archive/issue_comments_263250.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-19T14:54:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263250",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263251.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2016-04-19T14:59:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263251",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_263252.json:
```json
{
    "body": "Sorry, I messed up with my git branches in the push before that.\nAnyway, my last commit fixes a bug related to `decode_to_code`: the loops I was using to insert elements in lists were failing because they were expecting to receive the positions to insert as a sorted list of positions.\nI wrote a helper functions to deal with this, and it now works fine.\nThis is still open for review (and this time, I cannot find any more issues).\n\nBest,\n\nDavid",
    "created_at": "2016-04-19T15:02:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263252",
    "user": "dlucas"
}
```

Sorry, I messed up with my git branches in the push before that.
Anyway, my last commit fixes a bug related to `decode_to_code`: the loops I was using to insert elements in lists were failing because they were expecting to receive the positions to insert as a sorted list of positions.
I wrote a helper functions to deal with this, and it now works fine.
This is still open for review (and this time, I cannot find any more issues).

Best,

David



---

archive/issue_comments_263253.json:
```json
{
    "body": "Hi David,\n\nA few remarks -- the last ones, I hope:\n\n\n- in `structured_representation` method: it doesn't work when one concatenates puncturings. For example, the following script\n\n```\n    C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)\n    P = codes.PuncturedCode(C, [0,6])\n    D = P.structured_representation()\n    P2 = codes.PuncturedCode(P, [0,4])\n    D2 = P2.structured_representation()\n```\n\nfails at fifth line (so double puncturing actually works, only `structured_representation` crashes). From the crash log, it seems that you don't build the right set of `pts`.\n\n- in `PuncturedCodePuncturedMatrixEncoder`, one can construct this encoder while passing as argument a code which is not a punctured one. As a direct consequence, this scripts fails:\n\n```\n    C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)\n    E = codes.encoders.PuncturedCodePuncturedMatrixEncoder(C)\n    G = E.generator_matrix()\n```\n\nThe question is: is it the user's mistake, or should the code handle it ? Maybe it's reasonable to throw an error.\n\n\n- same remark for your decoder: one can pass a non-punctured code as parameter.\n\n- in `__init__` function of `PuncturedCodeOriginalCodeDecoder`, maybe it is better to use `True/False` boolean values instead of `error_erasure = 0` and `error_erasure = 1`.\n\n- I also prefer the compact notation:\n\n```\n    e_list = [ one if i in pts else zero for i in range(Cor.length()) ]\n```\n\ninstead of:\n\n```\n    e_list = []\n    for i in range(Cor.length()):\n        if i in pts:\n            e_list.append(one)\n        else:\n            e_list.append(zero)\n```\n\n\n\n- finally, a typo, l.441 : default instead of dafault\n\nI did not perform exhaustive tests of all the combinations of codes/encoders/decoders/strategies, because it is too long. So given the complexity of the feature you're trying to implement, it's still possible there remains some minor errors -- especially with extreme settings -- but maybe a real deep use of this class (by actual users) could make them appear more easily.\n\nThus, when you're done fixing the previous errors, I give the green light.\n\nJulien",
    "created_at": "2016-05-22T13:03:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263253",
    "user": "jlavauzelle"
}
```

Hi David,

A few remarks -- the last ones, I hope:


- in `structured_representation` method: it doesn't work when one concatenates puncturings. For example, the following script

```
    C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)
    P = codes.PuncturedCode(C, [0,6])
    D = P.structured_representation()
    P2 = codes.PuncturedCode(P, [0,4])
    D2 = P2.structured_representation()
```

fails at fifth line (so double puncturing actually works, only `structured_representation` crashes). From the crash log, it seems that you don't build the right set of `pts`.

- in `PuncturedCodePuncturedMatrixEncoder`, one can construct this encoder while passing as argument a code which is not a punctured one. As a direct consequence, this scripts fails:

```
    C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)
    E = codes.encoders.PuncturedCodePuncturedMatrixEncoder(C)
    G = E.generator_matrix()
```

The question is: is it the user's mistake, or should the code handle it ? Maybe it's reasonable to throw an error.


- same remark for your decoder: one can pass a non-punctured code as parameter.

- in `__init__` function of `PuncturedCodeOriginalCodeDecoder`, maybe it is better to use `True/False` boolean values instead of `error_erasure = 0` and `error_erasure = 1`.

- I also prefer the compact notation:

```
    e_list = [ one if i in pts else zero for i in range(Cor.length()) ]
```

instead of:

```
    e_list = []
    for i in range(Cor.length()):
        if i in pts:
            e_list.append(one)
        else:
            e_list.append(zero)
```



- finally, a typo, l.441 : default instead of dafault

I did not perform exhaustive tests of all the combinations of codes/encoders/decoders/strategies, because it is too long. So given the complexity of the feature you're trying to implement, it's still possible there remains some minor errors -- especially with extreme settings -- but maybe a real deep use of this class (by actual users) could make them appear more easily.

Thus, when you're done fixing the previous errors, I give the green light.

Julien



---

archive/issue_comments_263254.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-05-22T13:03:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263254",
    "user": "jlavauzelle"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_263255.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-23T13:16:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263255",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263256.json:
```json
{
    "body": "Hello Julien,\n\nThanks for your comments!\n\nI fixed the bug in `structured_representation`. I also fixed a bug I found while compiling the documentation, added input sanitization in the encoder and the decoder (speaking of which, these checks are missing almost everywhere... I'll open a new ticket to fix that in other classes).\n\nI also removed non-Pythonic syntax (fun fact: four lines below the ones you noticed, `error_erasure` was set to `True` or `False`... Consistency, I haz it).\n\nShould be ok now.\nFYI, I tested locally `error-erasure`, `list-decoder` and \"classical\" decoders, standard decoding tests passed.\n\nDavid",
    "created_at": "2016-05-23T13:26:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263256",
    "user": "dlucas"
}
```

Hello Julien,

Thanks for your comments!

I fixed the bug in `structured_representation`. I also fixed a bug I found while compiling the documentation, added input sanitization in the encoder and the decoder (speaking of which, these checks are missing almost everywhere... I'll open a new ticket to fix that in other classes).

I also removed non-Pythonic syntax (fun fact: four lines below the ones you noticed, `error_erasure` was set to `True` or `False`... Consistency, I haz it).

Should be ok now.
FYI, I tested locally `error-erasure`, `list-decoder` and "classical" decoders, standard decoding tests passed.

David



---

archive/issue_comments_263257.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-05-23T13:27:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263257",
    "user": "dlucas"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_263258.json:
```json
{
    "body": "Hi David,\n\nYour fix of `structured_representation` doesn't work. Try this:\n\n```\n    C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)\n    Cp = codes.PuncturedCode(C, [5,6])\n    Cp2 = codes.PuncturedCode(Cp, [1,2])\n```\n\nIf you print `list_pts` at the end of the method, you'll see it is not `[1,2,5,6]` as expected.\n\nHere is a piece of code which should work:\n\n```\n        while(isinstance(C, PuncturedCode)):\n            cur_pts = list(C.punctured_positions())\n            list_len = len(list_pts)\n            for p in cur_pts:\n                for i in range(list_len):\n                    if (p <= list_pts[i]):\n                        list_pts[i] += 1\n            list_pts += cur_pts\n            C = C.original_code()\n        return C._punctured_form(set(list_pts))\n```\n\nI'm not satisfied about its algorithmic complexity, so you're free to improve it, even though I cannot believe that this piece of code will ever become a bottleneck of any algorithm.\n\nI agree with the other fixes :)\n\nJulien",
    "created_at": "2016-05-23T15:34:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263258",
    "user": "jlavauzelle"
}
```

Hi David,

Your fix of `structured_representation` doesn't work. Try this:

```
    C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)
    Cp = codes.PuncturedCode(C, [5,6])
    Cp2 = codes.PuncturedCode(Cp, [1,2])
```

If you print `list_pts` at the end of the method, you'll see it is not `[1,2,5,6]` as expected.

Here is a piece of code which should work:

```
        while(isinstance(C, PuncturedCode)):
            cur_pts = list(C.punctured_positions())
            list_len = len(list_pts)
            for p in cur_pts:
                for i in range(list_len):
                    if (p <= list_pts[i]):
                        list_pts[i] += 1
            list_pts += cur_pts
            C = C.original_code()
        return C._punctured_form(set(list_pts))
```

I'm not satisfied about its algorithmic complexity, so you're free to improve it, even though I cannot believe that this piece of code will ever become a bottleneck of any algorithm.

I agree with the other fixes :)

Julien



---

archive/issue_comments_263259.json:
```json
{
    "body": "> If you print `list_pts` at the end of the method, you'll see it is not `[1,2,5,6]` as expected.\n\nOh yes you're right, my solution only works if one erases the same coordinates repeatedly...",
    "created_at": "2016-05-23T15:40:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263259",
    "user": "dlucas"
}
```

> If you print `list_pts` at the end of the method, you'll see it is not `[1,2,5,6]` as expected.

Oh yes you're right, my solution only works if one erases the same coordinates repeatedly...



---

archive/issue_comments_263260.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-23T15:45:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263260",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_263261.json:
```json
{
    "body": "I took your solution and tested it on several instances.\nI'm fine with it, even if it's not perfect.\n\nDavid",
    "created_at": "2016-05-23T15:47:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263261",
    "user": "dlucas"
}
```

I took your solution and tested it on several instances.
I'm fine with it, even if it's not perfect.

David



---

archive/issue_comments_263262.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-05-23T16:00:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263262",
    "user": "jlavauzelle"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_263263.json:
```json
{
    "body": "Now that's ok for me. Great job again !\n\nJulien",
    "created_at": "2016-05-23T16:00:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263263",
    "user": "jlavauzelle"
}
```

Now that's ok for me. Great job again !

Julien



---

archive/issue_comments_263264.json:
```json
{
    "body": "Amazing, thanks!",
    "created_at": "2016-05-23T16:54:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263264",
    "user": "dlucas"
}
```

Amazing, thanks!



---

archive/issue_comments_263265.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-05-24T07:06:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19185",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19185#issuecomment-263265",
    "user": "vbraun"
}
```

Resolution: fixed
