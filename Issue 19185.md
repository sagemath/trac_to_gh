# Issue 19185: A new structure for Punctured Codes

Issue created by migration from https://trac.sagemath.org/ticket/19422

Original creator: dlucas

Original creation time: 2015-10-16 13:43:28

CC:  wdj ppurka

This ticket proposes a new implementation for punctured codes.

It contains:

- a new code class, `PuncturedCode`

- a dedicated encoder to compute the generator matrix of a Punctured Code.

This new structure presents the following advantages:

- it keeps track of the code it comes from. If one punctures a code A, the punctured code he gets will remember it comes from A.

- This allows to perform several operations, like encoding or picking a random element without constructing the generator matrix for the punctured code, thus saving time and memory.

- Later on, it will also allow to decode words using a decoder over the original code of the punctured code.


---

Comment by dlucas created at 2015-10-16 13:47:24

Content available, it's now ready for review.
----
New commits:


---

Comment by dlucas created at 2015-10-16 13:47:24

Changing status from new to needs_review.


---

Comment by jsrn created at 2015-10-18 16:28:36

`AbstractLinearCode` has a method `punctured`. Shouldn't this return a `PuncturedCode` object after this patch?


---

Comment by dlucas created at 2015-10-19 07:38:57

I chose to keep this method as it directly returns a `LinearCode` object.
So if one wants to puncture and immediately get the `LinearCode` representation of his punctured code, he can thanks to this method. I plan to change it when the mechanism to get another representation of a punctured code (e.g. get a RS code from a punctured RS code) will be ready.


---

Comment by jsrn created at 2015-10-19 10:03:05

I think the default should always be to retain as much structure as possible. The `C.punctured()` method is certainly the "default" a user would call.

Furthermore, having a `PuncturedCode` should never get in the way for users who are simply interested in the unstructured linear code representation: it advertises exactly the same methods (plus some more). So I don't think there is any deprecation needed.


---

Comment by git created at 2015-10-19 10:32:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2015-10-19 10:33:35

Ok, I agree with you.

Changes have been made and pushed.


---

Comment by git created at 2016-01-13 10:08:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-01-13 10:13:52

A few updates on this ticket:

- it's now under the latest beta
- as we now have the structure for decoders in Sage, I added a dedicated decoder for punctured codes
- as we now have GRS codes in Sage, which still are GRS codes after puncturing, I introduced a mechanism which allows one to get the most specific representation possible for a punctured code, based on the original code.

This is still open for review.


---

Comment by git created at 2016-01-27 16:21:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-01-27 16:21:48

I updated this ticket to latest beta, and fixed merge conflict.
It's still open for review.


---

Comment by git created at 2016-02-22 13:41:02

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dlucas created at 2016-02-22 13:42:31

I fixed a few typos, updated deprecated imports which were breaking doctests.
I also completely rewrote doctests and documentation of the decoder, using GRS decoders introduced in #19653.

This is still open for review.


---

Comment by git created at 2016-02-26 14:37:01

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dlucas created at 2016-02-26 14:38:09

I updated this ticket to the latest beta and fixed conflicts. This is still open for review.


---

Comment by git created at 2016-03-31 13:39:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-03-31 13:41:37

I updated this ticket to 7.2beta1 and fixed a broken doctest.
This is still open for review.


---

Comment by jlavauzelle created at 2016-04-16 11:58:31

I start the review even though the ticket is not updated to the latest beta. Despite my comments, note that I realize that building this framework must have been a huge work, and that I found it really user-friendly =)

*** General remarks ***

 * As I read the (quite long) name of the canonical decoder of your punctured code (`PuncturedCodeOriginalCodeDecoder`), I asked myself the following question: if I understand well your naming convention, decoders are named `Code`+`DecoderName`. Is it necessary to have the `Code` suffix ? My point is that it could be sufficient to only keep `DecoderName`, because if a user wants to know what kind of code the decoder is applied to, he just needs to call `Dec.code()`.
 * You consider puncturing points as a list. Would it be better (and more confortable to compute unions and intersections) to consider them a set ?

*** index.rst ***

 * why do you remove `sage/coding/source_coding/huffman` ?

*** src/sage/coding/grs.py ***

 * The method `_punctured_form(self, points)` doesn't work if `points` is not sorted (e.g. `C_grs._punctured_form([4,3])`). That's due to your strange way to select the evaluation points and multipliers. I think you should remove the block:

```
start = 0
for i in points:
    punctured_alphas += alphas[start:i]
    punctured_col_mults += col_mults[start:i]
    start = i + 1
    punctured_alphas += alphas[start:n]
    punctured_col_mults += col_mults[start:n]
```


and replace it by something like (that's only a suggestion):


```
punctured_alphas = [ alphas[i] for i in range(n) if i not in points ]
punctured_col_mults = [ col_mults[i] for i in range(n) if i not in points ]
```

 * In the same method, if I understand it well, this block:

```
if G.rank() != dimension:
    G = G.echelon_form()
    for i in range(dimension):
        if G[i] == 0:
        dimension -= 1
```


aims at computing the code dimension (stored in `dimension`). In fact, you already computed it in `G.rank()`.

*** src/sage/coding/linear_code.py ***

 * in `_punctured_form` method, `G.echelon_form()` puts all the zero lines at the bottom of the new matrix. Thus, if you want to get the non-zero part of the matrix, I think you could simply write

```
    k = G.rank()
    return LinearCode(G[:k])
```



---

Comment by jlavauzelle created at 2016-04-16 12:01:28

*** src/sage/coding/punctured_code.py ***
--- function `puncture` ---
- same strange way to compute the non-punctured positions than in grs.py. For example, it doesn't work with:

```
C = codes.RandomLinearCode(11, 5, GF(7))
Cp = codes.PuncturedCode(C, [4,3])
v = vector(GF(7), (2,3,0,2,1,5,1,5,6,5,3))
sage.coding.punctured_code.puncture(v, [4,3], Cp)
```


--- class `PuncturedCode` ---
- constructor:
`positions = list(set(positions))` is a short (maybe dirty) way to do:

```
unique_positions = set()
for i in positions:
    unique_positions.add(i)
positions = []
for i in unique_positions:
   positions.append(i)
```

and it looks to sort the elements as well =) Also remark that you don't have this "multiplicity" issue when using Python sets (instead of lists) for storing puncturing points.
- in encode() method, you missed parentheses after `self.punctured_positions` in `return puncture(c, self.punctured_positions, self)`
- in structured_representation(self) method: in the doc, you wrote "A punctured GRS code is still a punctured code" but I think you meant "still a GRS code". Moreover, I don't understand what you mean by "Which is not the case for generic linear codes": punctured linear codes are still linear codes.
- still in structured_representation(self) method, I tried this:

```
sage: C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)
sage: P = codes.PuncturedCode(C, [1,3])
sage: Q = codes.PuncturedCode(P, [1,3])
sage: P.length()
5
sage: Q.length()
3
sage: P.structured_representation()
[5, 4, 2] Generalized Reed-Solomon Code over Finite Field of size 7
sage: Q.structured_representation()
[5, 3, 3] Generalized Reed-Solomon Code over Finite Field of size 7
```

So, double puncturing works well (`Q` seems to be the right code), but `structured_representation()` doesn't build the right Reed-Solomon code.

--- class `PuncturedCodePuncturedMatrixEncoder` ---
- in `GeneratorMatrix`: same comment as in linear_code.py, I think echelon_form()do the job and you just need to keep the `k` first rows.

--- class `PuncturedCodeOriginalCodeDecoder` ---
- sage is stuck (infinite loop ?) when I run this:

```
sage: R = codes.RandomLinearCode(11, 5, GF(7))
sage: P = codes.PuncturedCode(R, [1,3])
sage: P.decoder()
```

- l.444: you wrote ``'random_values'`` instead of ``'random-values'``
- in the constructor: you have a test variable `error_erasure` to which you assign `0` and `1`. Maybe `True` and `False` are more explicit.
- in `decode_to_code`: l.600, I think you forgot to increment `shift` (otherwise I misunderstood the use of `shift`)
- maybe add an `elif self._strategy == 'try-all'` at line 643.
- l.670: `ValueError("The number of erasures exceed decoding capability")` --> exceeds
- l.672: decoding capability must be:

```
    return (diff - punctured -1) // 2
```

- l.665; you could have negative radius with:

```
if self._strategy != 'try-all' and "error-erasure" not in D.decoder_type():
    return D.decoding_radius() - punctured
```

- I don't understand the last `return D.decoding_radius()`, line 675. To which case does it apply ?


---

Comment by jlavauzelle created at 2016-04-16 12:01:28

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-04-16 15:07:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-04-16 15:14:38

Changing status from needs_work to needs_review.


---

Comment by dlucas created at 2016-04-16 15:14:38

Hello Julien,

Thanks for your thorough review!

I followed all your suggestions (good idea to change the set of points to a list!).
Some remarks/answers follow:

- As `positions` is now a set, the test of duplicate positions in the constructor is no longer needed.
- Open question: now that I changed `positions` to a set, the `str` methods return the ugly str format of a set: `set([3,4])` for `{3, 4}`. Which means the string representation of a punctured code now states `PuncturedCode coming from ... punctured in position(s) set([pos])` which is quite ugly... So, do you think I should keep that, or, only for these `str` methods return a list while it might be a bit confusing for the user because he/she entered a set a got a list?

> sage is stuck (infinite loop ?) when I run this: 

Oh, yes, it's not an infinite loop! It's because it builds the original decoder of your code, namely a `SyndromeDecoder` for a linear code over GF(7), length 11, dimension 5... Which takes a while because of the table of syndromes which is heavy to build.

Best,

David


---

Comment by jsrn created at 2016-04-16 16:13:34

I'd prefer it if the user could enter either a set or a list of punctured positions, or a single position. The internal representation as a set probably makes sense though. I consider str and repr as just pretty-printing, so formatting as a (sorted) list make sense.


---

Comment by git created at 2016-04-18 09:19:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-04-18 09:23:01

Hello,

The user can now pass either an Integer, an int, a list or a set to `PuncturedCode`. The internal representation is a set. I added a few extra sanitization tests, so if one passes a list/set of anything but ints/Integers, an exception is raised.

I also reinstated the list representation of the punctured positions for str methods.

Remark:

for now, `punctured_positions` (the getter for `positions`) always return a set, even if one passed an int/Integer/list at construction time. I think it's fine like that, but if you think it can be confusing/annoying for the user, I can change its behaviour so it returns the exact data one passed at construction time.

This is still open for review.

Best,

David


---

Comment by jsrn created at 2016-04-18 11:34:40

Awesome!

> for now, `punctured_positions` (the getter for `positions`) always return a set, even if one passed an int/Integer/list at construction time. I think it's fine like that, but if you think it can be confusing/annoying for the user, I can change its behaviour so it returns the exact data one passed at construction time.

I think this makes complete sense.


---

Comment by git created at 2016-04-19 12:12:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-04-19 12:14:11

Hello,

I fixed a bug: Punctured Code's decoder was not working if its original decoder was a list decoder.
I changed `puncture` method (which is BTW now called `_puncture` as it's a helper function): it can now puncture a list of vectors or a vector. This takes care of the list-decoding issue.

Best,

David


---

Comment by git created at 2016-04-19 14:54:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-04-19 14:59:34

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dlucas created at 2016-04-19 15:02:37

Sorry, I messed up with my git branches in the push before that.
Anyway, my last commit fixes a bug related to `decode_to_code`: the loops I was using to insert elements in lists were failing because they were expecting to receive the positions to insert as a sorted list of positions.
I wrote a helper functions to deal with this, and it now works fine.
This is still open for review (and this time, I cannot find any more issues).

Best,

David


---

Comment by jlavauzelle created at 2016-05-22 13:03:40

Hi David,

A few remarks -- the last ones, I hope:


- in `structured_representation` method: it doesn't work when one concatenates puncturings. For example, the following script

```
    C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)
    P = codes.PuncturedCode(C, [0,6])
    D = P.structured_representation()
    P2 = codes.PuncturedCode(P, [0,4])
    D2 = P2.structured_representation()
```

fails at fifth line (so double puncturing actually works, only `structured_representation` crashes). From the crash log, it seems that you don't build the right set of `pts`.

- in `PuncturedCodePuncturedMatrixEncoder`, one can construct this encoder while passing as argument a code which is not a punctured one. As a direct consequence, this scripts fails:

```
    C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)
    E = codes.encoders.PuncturedCodePuncturedMatrixEncoder(C)
    G = E.generator_matrix()
```

The question is: is it the user's mistake, or should the code handle it ? Maybe it's reasonable to throw an error.


- same remark for your decoder: one can pass a non-punctured code as parameter.

- in `__init__` function of `PuncturedCodeOriginalCodeDecoder`, maybe it is better to use `True/False` boolean values instead of `error_erasure = 0` and `error_erasure = 1`.

- I also prefer the compact notation:

```
    e_list = [ one if i in pts else zero for i in range(Cor.length()) ]
```

instead of:

```
    e_list = []
    for i in range(Cor.length()):
        if i in pts:
            e_list.append(one)
        else:
            e_list.append(zero)
```



- finally, a typo, l.441 : default instead of dafault

I did not perform exhaustive tests of all the combinations of codes/encoders/decoders/strategies, because it is too long. So given the complexity of the feature you're trying to implement, it's still possible there remains some minor errors -- especially with extreme settings -- but maybe a real deep use of this class (by actual users) could make them appear more easily.

Thus, when you're done fixing the previous errors, I give the green light.

Julien


---

Comment by jlavauzelle created at 2016-05-22 13:03:40

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-05-23 13:16:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-05-23 13:26:51

Hello Julien,

Thanks for your comments!

I fixed the bug in `structured_representation`. I also fixed a bug I found while compiling the documentation, added input sanitization in the encoder and the decoder (speaking of which, these checks are missing almost everywhere... I'll open a new ticket to fix that in other classes).

I also removed non-Pythonic syntax (fun fact: four lines below the ones you noticed, `error_erasure` was set to `True` or `False`... Consistency, I haz it).

Should be ok now.
FYI, I tested locally `error-erasure`, `list-decoder` and "classical" decoders, standard decoding tests passed.

David


---

Comment by dlucas created at 2016-05-23 13:27:02

Changing status from needs_work to needs_review.


---

Comment by jlavauzelle created at 2016-05-23 15:34:14

Hi David,

Your fix of `structured_representation` doesn't work. Try this:

```
    C = codes.GeneralizedReedSolomonCode(GF(7).list(), 4)
    Cp = codes.PuncturedCode(C, [5,6])
    Cp2 = codes.PuncturedCode(Cp, [1,2])
```

If you print `list_pts` at the end of the method, you'll see it is not `[1,2,5,6]` as expected.

Here is a piece of code which should work:

```
        while(isinstance(C, PuncturedCode)):
            cur_pts = list(C.punctured_positions())
            list_len = len(list_pts)
            for p in cur_pts:
                for i in range(list_len):
                    if (p <= list_pts[i]):
                        list_pts[i] += 1
            list_pts += cur_pts
            C = C.original_code()
        return C._punctured_form(set(list_pts))
```

I'm not satisfied about its algorithmic complexity, so you're free to improve it, even though I cannot believe that this piece of code will ever become a bottleneck of any algorithm.

I agree with the other fixes :)

Julien


---

Comment by dlucas created at 2016-05-23 15:40:57

> If you print `list_pts` at the end of the method, you'll see it is not `[1,2,5,6]` as expected.

Oh yes you're right, my solution only works if one erases the same coordinates repeatedly...


---

Comment by git created at 2016-05-23 15:45:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-05-23 15:47:51

I took your solution and tested it on several instances.
I'm fine with it, even if it's not perfect.

David


---

Comment by jlavauzelle created at 2016-05-23 16:00:39

Changing status from needs_review to positive_review.


---

Comment by jlavauzelle created at 2016-05-23 16:00:39

Now that's ok for me. Great job again !

Julien


---

Comment by dlucas created at 2016-05-23 16:54:46

Amazing, thanks!


---

Comment by vbraun created at 2016-05-24 07:06:34

Resolution: fixed
