# Issue 19576: VectorSpace basis() is mutable

archive/issues_019576.json:
```json
{
    "body": "CC:  @mjungmath @tscrim\n\nI don't even:\n\n\n```\nsage: b = VectorSpace(QQ,3).basis()\nsage: b += [\"Hello, world!\"]\nsage: VectorSpace(QQ,3).basis()\n[\n(1, 0, 0),\n(0, 1, 0),\n(0, 0, 1),\n'Hello, world!'\n]\n```\n\n\nSee also #19251.\n\nIssue created by migration from https://trac.sagemath.org/ticket/19813\n\n",
    "created_at": "2015-12-31T02:05:29Z",
    "labels": [
        "linear algebra",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "VectorSpace basis() is mutable",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19576",
    "user": "@orlitzky"
}
```
CC:  @mjungmath @tscrim

I don't even:


```
sage: b = VectorSpace(QQ,3).basis()
sage: b += ["Hello, world!"]
sage: VectorSpace(QQ,3).basis()
[
(1, 0, 0),
(0, 1, 0),
(0, 0, 1),
'Hello, world!'
]
```


See also #19251.

Issue created by migration from https://trac.sagemath.org/ticket/19813





---

archive/issue_comments_268927.json:
```json
{
    "body": "It makes sense to me that a vector basis should be mutable. For example, what if you wanted to normalize the basis, order it or replace a basis vector? The resulting contents of the instance could still be a valid basis. There could also be some abstract vector spaces whose basis vectors make sense as strings.",
    "created_at": "2015-12-31T02:28:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268927",
    "user": "DayneSorvisto"
}
```

It makes sense to me that a vector basis should be mutable. For example, what if you wanted to normalize the basis, order it or replace a basis vector? The resulting contents of the instance could still be a valid basis. There could also be some abstract vector spaces whose basis vectors make sense as strings.



---

archive/issue_comments_268928.json:
```json
{
    "body": "No, this is indeed quite a bad bug, since VectorSpaces are UniqueRepresentation:\n\n```\nsage: V=VectorSpace(QQ,3)\nsage: W=VectorSpace(QQ,3)\nsage: b=V.basis()\nsage: b+=\"a\"\nsage: len(W.basis())\n4\n```\n\nNote that V and W are (to the user) obtained independently, so a change on one should not affect the other.\n\nAlso note that some effort is undertaken to make the thing immutable:\n\n```\nsage: b.append(\"a\")\nValueError: object is immutable; please change a copy instead.\nsage: type(b)\n<class 'sage.structure.sequence.Sequence_generic'>\nsage: b.is_mutable()\nFalse\nsage: type(b).__iadd__\n<slot wrapper '__iadd__' of 'list' objects>\n```\n\nSo it seems we just failed to shadow the \"__iadd__\" method.",
    "created_at": "2015-12-31T02:46:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268928",
    "user": "@nbruin"
}
```

No, this is indeed quite a bad bug, since VectorSpaces are UniqueRepresentation:

```
sage: V=VectorSpace(QQ,3)
sage: W=VectorSpace(QQ,3)
sage: b=V.basis()
sage: b+="a"
sage: len(W.basis())
4
```

Note that V and W are (to the user) obtained independently, so a change on one should not affect the other.

Also note that some effort is undertaken to make the thing immutable:

```
sage: b.append("a")
ValueError: object is immutable; please change a copy instead.
sage: type(b)
<class 'sage.structure.sequence.Sequence_generic'>
sage: b.is_mutable()
False
sage: type(b).__iadd__
<slot wrapper '__iadd__' of 'list' objects>
```

So it seems we just failed to shadow the "__iadd__" method.



---

archive/issue_comments_268929.json:
```json
{
    "body": "Introspection seems to indicate:\n`__iadd__`, `__imul__`,`__delitem__`,`__delslice__` should be intercepted.\nGleaned from:\n\n```\nsage: T=sage.structure.sequence.Sequence_generic\nsage: [m for m in dir(T) if str(getattr(T,m)).find(\"list\") >=0]\n```\n",
    "created_at": "2015-12-31T07:28:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268929",
    "user": "@nbruin"
}
```

Introspection seems to indicate:
`__iadd__`, `__imul__`,`__delitem__`,`__delslice__` should be intercepted.
Gleaned from:

```
sage: T=sage.structure.sequence.Sequence_generic
sage: [m for m in dir(T) if str(getattr(T,m)).find("list") >=0]
```




---

archive/issue_comments_268930.json:
```json
{
    "body": "Looks like all Sage objects which define a '+' and can be immutable are failing. I tried matrices and graphs, and both have it.\n\nNathann",
    "created_at": "2015-12-31T09:11:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268930",
    "user": "@nathanncohen"
}
```

Looks like all Sage objects which define a '+' and can be immutable are failing. I tried matrices and graphs, and both have it.

Nathann



---

archive/issue_comments_268931.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-01T05:12:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268931",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268932.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-01T05:18:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268932",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268933.json:
```json
{
    "body": "Replying to [comment:3 nbruin]:\n> Introspection seems to indicate:\n> `__iadd__`, `__imul__`,`__delitem__`,`__delslice__` should be intercepted.\n\nDone (except for `__delslice__`, which does not exist any more in Python 3).",
    "created_at": "2021-09-01T05:19:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268933",
    "user": "@mkoeppe"
}
```

Replying to [comment:3 nbruin]:
> Introspection seems to indicate:
> `__iadd__`, `__imul__`,`__delitem__`,`__delslice__` should be intercepted.

Done (except for `__delslice__`, which does not exist any more in Python 3).



---

archive/issue_comments_268934.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2021-09-01T05:19:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268934",
    "user": "@mkoeppe"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_268935.json:
```json
{
    "body": "Note that Python's semantics for `A += B` are very close to `A = A + B`. The default is really that it is the latter (and NOT that `A += B` is an error). Some mutable types change the meaning to mutating behaviour instead of binding to a fresh object. Consider this:\n\n```\nsage: t1 = (1,2,3)\nsage: t2 = t1\nsage: t2 += (4,5,6) #this binds t2 to a new tuple\nsage: t1\n(1, 2, 3)\nsage: t2\n(1, 2, 3, 4, 5, 6)\nsage: l1 = [1,2,3]\nsage: l2 = l1\nsage: l2 += [4,5,6] #this mutates the list that l2 is bound to.\nsage: l1\n[1, 2, 3, 4, 5, 6]\nsage: l2\n[1, 2, 3, 4, 5, 6]\n```\n",
    "created_at": "2021-09-01T06:56:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268935",
    "user": "@nbruin"
}
```

Note that Python's semantics for `A += B` are very close to `A = A + B`. The default is really that it is the latter (and NOT that `A += B` is an error). Some mutable types change the meaning to mutating behaviour instead of binding to a fresh object. Consider this:

```
sage: t1 = (1,2,3)
sage: t2 = t1
sage: t2 += (4,5,6) #this binds t2 to a new tuple
sage: t1
(1, 2, 3)
sage: t2
(1, 2, 3, 4, 5, 6)
sage: l1 = [1,2,3]
sage: l2 = l1
sage: l2 += [4,5,6] #this mutates the list that l2 is bound to.
sage: l1
[1, 2, 3, 4, 5, 6]
sage: l2
[1, 2, 3, 4, 5, 6]
```




---

archive/issue_comments_268936.json:
```json
{
    "body": "Replying to [comment:11 nbruin]:\n> Note that Python's semantics for `A += B` are very close to `A = A + B`. The default is really that it is the latter (and NOT that `A += B` is an error). Some mutable types change the meaning to mutating behaviour instead of binding to a fresh object.\n\nSpecifically, in this case, the python docs (https://docs.python.org/3/library/operator.html) say that `x += y` is equivalent to `x = operator.iadd(x, y)`, and `Sequence_generic` is a subclass of `list`, which implements the in-place `iadd` via mutation.\n\nI guess we should fix the default value of `immutable` too, one way or the other:\n\n\n```python\nclass Sequence_generic(sage.structure.sage_object.SageObject, list):\n    \"\"\"\n    ...\n        - ``immutable`` - (default: True) whether or not this sequence is           \n          immutable\n    ...\n    \"\"\"\n    def __init__(self, x, universe=None, check=True, immutable=False,\n                 cr=False, cr_str=None, use_sage_types=False):\n```\n",
    "created_at": "2021-09-01T12:45:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268936",
    "user": "@orlitzky"
}
```

Replying to [comment:11 nbruin]:
> Note that Python's semantics for `A += B` are very close to `A = A + B`. The default is really that it is the latter (and NOT that `A += B` is an error). Some mutable types change the meaning to mutating behaviour instead of binding to a fresh object.

Specifically, in this case, the python docs (https://docs.python.org/3/library/operator.html) say that `x += y` is equivalent to `x = operator.iadd(x, y)`, and `Sequence_generic` is a subclass of `list`, which implements the in-place `iadd` via mutation.

I guess we should fix the default value of `immutable` too, one way or the other:


```python
class Sequence_generic(sage.structure.sage_object.SageObject, list):
    """
    ...
        - ``immutable`` - (default: True) whether or not this sequence is           
          immutable
    ...
    """
    def __init__(self, x, universe=None, check=True, immutable=False,
                 cr=False, cr_str=None, use_sage_types=False):
```




---

archive/issue_comments_268937.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2021-09-01T18:26:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268937",
    "user": "@mkoeppe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_268938.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-01T18:31:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268938",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268939.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-01T18:35:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268939",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268940.json:
```json
{
    "body": "Thanks for the comments! Here's a better version",
    "created_at": "2021-09-01T18:36:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268940",
    "user": "@mkoeppe"
}
```

Thanks for the comments! Here's a better version



---

archive/issue_comments_268941.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2021-09-01T18:36:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268941",
    "user": "@mkoeppe"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_268942.json:
```json
{
    "body": "The following sentence (with some fuzz) appears three times in `sequence.py`: \"A mutable sequence of elements with a common guaranteed category, which can be set immutable.\" The universe is not what can be set immutable, though; it's the sequence. I would suggest something like \"An (optionally mutable) sequence of elements with a common parent universe.\"",
    "created_at": "2021-09-01T22:55:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268942",
    "user": "@orlitzky"
}
```

The following sentence (with some fuzz) appears three times in `sequence.py`: "A mutable sequence of elements with a common guaranteed category, which can be set immutable." The universe is not what can be set immutable, though; it's the sequence. I would suggest something like "An (optionally mutable) sequence of elements with a common parent universe."



---

archive/issue_comments_268943.json:
```json
{
    "body": "The delegation behavior of `iadd` and `imul` is reasonable, but I think the docs should mention that they'll give you back a copy when `immutable=True`.\n\nBut before we address **that**... there's actually another bug that the description highlights: should these methods always return another sequence? And when they do, what should its universe be? The immutable behavior now returns a list, which I personally would not expect:\n\n\n```python\nsage: s = Sequence([1,2], immutable=True)                                                                                                                                    \nsage: s += [3]                                                                                                                                                               \nsage: type(s)                                                                                                                                                                \n<class 'list'>\n```\n\n\nThe mutable behavior, on the other hand, can invalidate the universe:\n\n\n```python\nsage: s = Sequence([ZZ(1),ZZ(2)])                                                                                                                                            \nsage: s.universe()                                                                                                                                                           \nInteger Ring\nsage: s += [x]                                                                                                                                                               \nsage: s                                                                                                                                                                      \n[1, 2, x]\nsage: s.universe()                                                                                                                                                           \nInteger Ring\n```\n\n\nWe should probably think about that before worrying about the wording of the docs.",
    "created_at": "2021-09-01T22:56:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268943",
    "user": "@orlitzky"
}
```

The delegation behavior of `iadd` and `imul` is reasonable, but I think the docs should mention that they'll give you back a copy when `immutable=True`.

But before we address **that**... there's actually another bug that the description highlights: should these methods always return another sequence? And when they do, what should its universe be? The immutable behavior now returns a list, which I personally would not expect:


```python
sage: s = Sequence([1,2], immutable=True)                                                                                                                                    
sage: s += [3]                                                                                                                                                               
sage: type(s)                                                                                                                                                                
<class 'list'>
```


The mutable behavior, on the other hand, can invalidate the universe:


```python
sage: s = Sequence([ZZ(1),ZZ(2)])                                                                                                                                            
sage: s.universe()                                                                                                                                                           
Integer Ring
sage: s += [x]                                                                                                                                                               
sage: s                                                                                                                                                                      
[1, 2, x]
sage: s.universe()                                                                                                                                                           
Integer Ring
```


We should probably think about that before worrying about the wording of the docs.



---

archive/issue_comments_268944.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2021-09-01T23:43:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268944",
    "user": "@mkoeppe"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_268945.json:
```json
{
    "body": "Right, and also the following does not even work:\n\n```\nsage: M = Sequence([1, 2, 3], immutable=False) \nsage: M * 2\nTypeError: unbound method SageObject.category() needs an argument\n```\n",
    "created_at": "2021-09-02T19:13:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268945",
    "user": "@mkoeppe"
}
```

Right, and also the following does not even work:

```
sage: M = Sequence([1, 2, 3], immutable=False) 
sage: M * 2
TypeError: unbound method SageObject.category() needs an argument
```




---

archive/issue_comments_268946.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-03T22:48:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268946",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268947.json:
```json
{
    "body": "Here's another iteration for `__add__`, `__iadd__`...",
    "created_at": "2021-09-03T22:49:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268947",
    "user": "@mkoeppe"
}
```

Here's another iteration for `__add__`, `__iadd__`...



---

archive/issue_comments_268948.json:
```json
{
    "body": "Replying to [comment:22 mkoeppe]:\n> Here's another iteration for `__add__`, `__iadd__`...\n\nLooks good. Is `list.add(self,other)` any faster than `list(self) + list(other)`?\n\nSomething similar for multiplication would work. Finally, we should document that adding sequences will choose a new \"universe\" that encompasses both arguments, while multiplication will reuse the existing universe.",
    "created_at": "2021-09-04T13:22:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268948",
    "user": "@orlitzky"
}
```

Replying to [comment:22 mkoeppe]:
> Here's another iteration for `__add__`, `__iadd__`...

Looks good. Is `list.add(self,other)` any faster than `list(self) + list(other)`?

Something similar for multiplication would work. Finally, we should document that adding sequences will choose a new "universe" that encompasses both arguments, while multiplication will reuse the existing universe.



---

archive/issue_comments_268949.json:
```json
{
    "body": "Replying to [comment:23 mjo]:\n\n> Something similar for multiplication would work. Finally, we should document that adding sequences will choose a new \"universe\" that encompasses both arguments,\n\nWe should probably specify how that common parent is constructed. I suspect it should be whatever `coercion_maps(universe(seq1), universe(seq2))` comes up with. For one thing, it should not be driven by the parents of the elements (think of joining sequences of length 0).\n\nIt looks like the present version just rederives the universe from the concatenation of lists of elements. That's not what we need. Instead, we need something like:\n\n```\nL = Sequence([1/2,2,3])                                                     \nM = Sequence([x,1])                                                         \nu,v = coercion_model.coercion_maps(L.universe(),M.universe())               \nimport itertools                                                          \nLplusM = Sequence(itertools.chain(map(u,L),map(v,M)),universe=u.codomain(),check=False)                          \n```\n\n(A reasonable defensive programming step might be to leave check True). The sole reason for existence of Sequences is that their universe manipulations can be derived from explicit information, rather than derive it from elements. The feature that Sequence allows the universe to be not specified explicitly is only for user convenience. Any systematic use should specify the universe explicitly. That will be much faster too, because the coercion framework doesn't have to scan through individual elements.",
    "created_at": "2021-09-04T15:35:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268949",
    "user": "@nbruin"
}
```

Replying to [comment:23 mjo]:

> Something similar for multiplication would work. Finally, we should document that adding sequences will choose a new "universe" that encompasses both arguments,

We should probably specify how that common parent is constructed. I suspect it should be whatever `coercion_maps(universe(seq1), universe(seq2))` comes up with. For one thing, it should not be driven by the parents of the elements (think of joining sequences of length 0).

It looks like the present version just rederives the universe from the concatenation of lists of elements. That's not what we need. Instead, we need something like:

```
L = Sequence([1/2,2,3])                                                     
M = Sequence([x,1])                                                         
u,v = coercion_model.coercion_maps(L.universe(),M.universe())               
import itertools                                                          
LplusM = Sequence(itertools.chain(map(u,L),map(v,M)),universe=u.codomain(),check=False)                          
```

(A reasonable defensive programming step might be to leave check True). The sole reason for existence of Sequences is that their universe manipulations can be derived from explicit information, rather than derive it from elements. The feature that Sequence allows the universe to be not specified explicitly is only for user convenience. Any systematic use should specify the universe explicitly. That will be much faster too, because the coercion framework doesn't have to scan through individual elements.



---

archive/issue_comments_268950.json:
```json
{
    "body": "Replying to [comment:23 mjo]:\n> Is `list.add(self,other)` any faster than `list(self) + list(other)`?\nThere is no such method",
    "created_at": "2021-09-04T17:28:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268950",
    "user": "@mkoeppe"
}
```

Replying to [comment:23 mjo]:
> Is `list.add(self,other)` any faster than `list(self) + list(other)`?
There is no such method



---

archive/issue_comments_268951.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-04T18:00:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268951",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268952.json:
```json
{
    "body": "The `Sequence` constructor uses `sage.structure.element.canonical_coercion` on adjacent elements from left to right.\n\nIt could probably be simplified using `coercion_model.common_parent`, but the constructor's parameter `use_sage_types=False` and fallbacks for non-coercible inputs are a complication",
    "created_at": "2021-09-04T18:16:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268952",
    "user": "@mkoeppe"
}
```

The `Sequence` constructor uses `sage.structure.element.canonical_coercion` on adjacent elements from left to right.

It could probably be simplified using `coercion_model.common_parent`, but the constructor's parameter `use_sage_types=False` and fallbacks for non-coercible inputs are a complication



---

archive/issue_comments_268953.json:
```json
{
    "body": "Replying to [comment:27 mkoeppe]:\n> The `Sequence` constructor uses `sage.structure.element.canonical_coercion` on adjacent elements from left to right.\n\nYes, it does that *if no universe is specified*. However, if a universe is specified, then it just coerces the elements into the universe specified. There is no \"common parent discovery\" necessary in that case anymore.\n\nI maintain that operations on sequences should *not* look at individual elements (since a sequence of length 0 does not have any), but derive the universe from the universes of the input sequences.\n\nIn particular, I think it's fine to have:\n\n```\nSequence(list1) + Sequence(list2) != Sequence(list1+list2)\n```\n\n(although I'm pretty sure it will actually hold anyway in most/all reasonable cases)\n\n> It could probably be simplified using `coercion_model.common_parent`, but the constructor's parameter `use_sage_types=False` and fallbacks for non-coercible inputs are a complication\n\nYou should be able to tell those cases from the universes of the inputs. Perhaps if one of the input universes does not play nice with `coercion_maps`, other fallbacks are necessary (and perhaps just generate an error that no common parent can be found).\n\nGiven that previously these operations just generated a list (clearly not desirable), I don't think you need to be worried about backwards compatibility. So better start out with restrictive, well-defined behaviour. It'll become more relaxed and messy by incremental patching afterwards anyway.",
    "created_at": "2021-09-04T18:45:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268953",
    "user": "@nbruin"
}
```

Replying to [comment:27 mkoeppe]:
> The `Sequence` constructor uses `sage.structure.element.canonical_coercion` on adjacent elements from left to right.

Yes, it does that *if no universe is specified*. However, if a universe is specified, then it just coerces the elements into the universe specified. There is no "common parent discovery" necessary in that case anymore.

I maintain that operations on sequences should *not* look at individual elements (since a sequence of length 0 does not have any), but derive the universe from the universes of the input sequences.

In particular, I think it's fine to have:

```
Sequence(list1) + Sequence(list2) != Sequence(list1+list2)
```

(although I'm pretty sure it will actually hold anyway in most/all reasonable cases)

> It could probably be simplified using `coercion_model.common_parent`, but the constructor's parameter `use_sage_types=False` and fallbacks for non-coercible inputs are a complication

You should be able to tell those cases from the universes of the inputs. Perhaps if one of the input universes does not play nice with `coercion_maps`, other fallbacks are necessary (and perhaps just generate an error that no common parent can be found).

Given that previously these operations just generated a list (clearly not desirable), I don't think you need to be worried about backwards compatibility. So better start out with restrictive, well-defined behaviour. It'll become more relaxed and messy by incremental patching afterwards anyway.



---

archive/issue_comments_268954.json:
```json
{
    "body": "Replying to [comment:28 nbruin]:\n> I maintain that operations on sequences should *not* look at individual elements (since a sequence of length 0 does not have any), but derive the universe from the universes of the input sequences.\n\nYes, I agree with you and have been working on the implementation.",
    "created_at": "2021-09-04T18:46:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268954",
    "user": "@mkoeppe"
}
```

Replying to [comment:28 nbruin]:
> I maintain that operations on sequences should *not* look at individual elements (since a sequence of length 0 does not have any), but derive the universe from the universes of the input sequences.

Yes, I agree with you and have been working on the implementation.



---

archive/issue_comments_268955.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-04T18:51:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268955",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268956.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-04T19:20:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268956",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268957.json:
```json
{
    "body": "Here's a new version that implements this. I haven't tested ill-behaved elements yet.\n\nNext is to generalize the `Sequence` constructor so it can accept generators",
    "created_at": "2021-09-04T19:22:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268957",
    "user": "@mkoeppe"
}
```

Here's a new version that implements this. I haven't tested ill-behaved elements yet.

Next is to generalize the `Sequence` constructor so it can accept generators



---

archive/issue_comments_268958.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-04T20:07:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268958",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268959.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-04T20:26:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268959",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268960.json:
```json
{
    "body": "Given that you're using the coercion maps in a coercion environment, I don't think you need to copy them. Maps in the coercion system are special since they try to reference their domain and codomain weakly whenever possible, so that there's still a chance these are garbage collected (the maps are globally cached, so if this would not be done, any structure that participates in the coercion system would become immortal. Even with this hack, it's still often the case structures are unexpectedly prevented from being deleted due to the coercion system -- the implementation of maps often hold references to domain and/or codomain as well). In your case, you already know you're holding a reference to the domains.\n\nI guess there may be a very small chance that the codomain is deleted just before you can get a hold of it (but the \"copy\" does not exclude that, because the codomain could vanish between the return of coercion_maps and the invocation of \"copy\"), so you could try and look if instead of coercion_maps, there is a routine that also returns the common parent (the codomain) explicitly with a strong reference. It looks like this low-probability event has been ignored and it hasn't led to big trouble (and in any case, your \"copy\" doesn't address it any better than just capturing the codomain explicitly). If you look in `discover_coercion` you see that `Z=pushout(R,S)` constructs the common parent, but that after that, internal coercion maps from R and S into Z are computed and that, upon return, the explicit reference to Z is dropped. So I suspect that `coerce_R` and `coerce_S` could be defunct once the return has completed, but I don't think it's ever been observed to happen.\n\nIn any case, watch out that `None` as a coercion map means identity map, so `coercion_maps(ZZ,ZZ)==(None,None)`.\n\nYes, the coercion model is a nasty beast to work with and has been a source of endless memory leaks.\n\nThe warning about copying the maps internal to the coercion system is only for the case when someone wants to extract a morphism for a longer time and expects that holding on to the morphism will keep domain and codomain alive.",
    "created_at": "2021-09-04T20:55:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268960",
    "user": "@nbruin"
}
```

Given that you're using the coercion maps in a coercion environment, I don't think you need to copy them. Maps in the coercion system are special since they try to reference their domain and codomain weakly whenever possible, so that there's still a chance these are garbage collected (the maps are globally cached, so if this would not be done, any structure that participates in the coercion system would become immortal. Even with this hack, it's still often the case structures are unexpectedly prevented from being deleted due to the coercion system -- the implementation of maps often hold references to domain and/or codomain as well). In your case, you already know you're holding a reference to the domains.

I guess there may be a very small chance that the codomain is deleted just before you can get a hold of it (but the "copy" does not exclude that, because the codomain could vanish between the return of coercion_maps and the invocation of "copy"), so you could try and look if instead of coercion_maps, there is a routine that also returns the common parent (the codomain) explicitly with a strong reference. It looks like this low-probability event has been ignored and it hasn't led to big trouble (and in any case, your "copy" doesn't address it any better than just capturing the codomain explicitly). If you look in `discover_coercion` you see that `Z=pushout(R,S)` constructs the common parent, but that after that, internal coercion maps from R and S into Z are computed and that, upon return, the explicit reference to Z is dropped. So I suspect that `coerce_R` and `coerce_S` could be defunct once the return has completed, but I don't think it's ever been observed to happen.

In any case, watch out that `None` as a coercion map means identity map, so `coercion_maps(ZZ,ZZ)==(None,None)`.

Yes, the coercion model is a nasty beast to work with and has been a source of endless memory leaks.

The warning about copying the maps internal to the coercion system is only for the case when someone wants to extract a morphism for a longer time and expects that holding on to the morphism will keep domain and codomain alive.



---

archive/issue_comments_268961.json:
```json
{
    "body": "Replying to [comment:35 nbruin]:\n> watch out that `None` as a coercion map means identity map, so `coercion_maps(ZZ,ZZ)==(None,None)`.\n\nYes, the code is handling that already",
    "created_at": "2021-09-04T20:57:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268961",
    "user": "@mkoeppe"
}
```

Replying to [comment:35 nbruin]:
> watch out that `None` as a coercion map means identity map, so `coercion_maps(ZZ,ZZ)==(None,None)`.

Yes, the code is handling that already



---

archive/issue_comments_268962.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-09-04T21:07:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268962",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_268963.json:
```json
{
    "body": "Replying to [comment:35 nbruin]:\n> Given that you're using the coercion maps in a coercion environment, I don't think you need to copy them. [...]\n\nThanks for the explanation, I agree.",
    "created_at": "2021-09-04T21:08:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268963",
    "user": "@mkoeppe"
}
```

Replying to [comment:35 nbruin]:
> Given that you're using the coercion maps in a coercion environment, I don't think you need to copy them. [...]

Thanks for the explanation, I agree.



---

archive/issue_comments_268964.json:
```json
{
    "body": "I think in the failing testcase of `3 * M`, `Integer.__mul__` calls `coercion_model.bin_op`, which seems to get confused by `M` being a `Parent`, not an `Element`",
    "created_at": "2021-09-04T21:11:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268964",
    "user": "@mkoeppe"
}
```

I think in the failing testcase of `3 * M`, `Integer.__mul__` calls `coercion_model.bin_op`, which seems to get confused by `M` being a `Parent`, not an `Element`



---

archive/issue_comments_268965.json:
```json
{
    "body": "(`3r * M` works.)",
    "created_at": "2021-09-04T21:11:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268965",
    "user": "@mkoeppe"
}
```

(`3r * M` works.)



---

archive/issue_comments_268966.json:
```json
{
    "body": "I think I need some help with this ticket",
    "created_at": "2021-10-13T17:02:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268966",
    "user": "@mkoeppe"
}
```

I think I need some help with this ticket



---

archive/issue_comments_268967.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:",
    "created_at": "2022-08-30T23:13:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19576#issuecomment-268967",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:
