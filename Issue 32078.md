# Issue 32078: Enumerated ConditionSet

Issue created by migration from https://trac.sagemath.org/ticket/32315

Original creator: @mjungmath

Original creation time: 2021-07-30 15:14:25

CC:  mkoeppe tscrim tkarn

We implement a sub-class of `ConditionSet` (see #32089) supporting enumerated sets.


---

Comment by git created at 2021-07-30 17:01:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-07-30 17:03:39

Changing status from new to needs_review.


---

Comment by @mjungmath created at 2021-07-30 17:03:39

Feel free to add more examples or make some changes. I removed the pre-processing with `__private_classcall__` and shifted it to a factory method.

If you agree with the changes, it's ready for review.


---

Comment by git created at 2021-07-30 17:06:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-07-30 21:08:02

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2021-07-30 21:08:02

Strong -1 on factory functions. It further separates the code from what it works on and now you don't have a natural "isinstance"


---

Comment by @mjungmath created at 2021-07-30 21:15:25

The problem I faced was that `__private_classcall__` should delegate to the enumerated sub-class version. But then the whole code in `__private_classcall__` should be copied to the sub-class again. This is bad for maintenance.

Do you have a better idea?


---

Comment by tscrim created at 2021-07-30 21:18:13

If it does need to be used by subclasses, then it should be `__classcall__`. However, you can do all of thebpreprocessing in the private version, then pass off to the correct subclass. What I am saying is it would be your factory function.

Also, thank you for adding this feature.


---

Comment by @mjungmath created at 2021-07-30 21:21:20

And leave a note that the sub-class, i.e. enumerated version, is not intended to be used by the end-user?


---

Comment by @mjungmath created at 2021-07-30 21:22:16

Otherwise, if `__classcall__` delegates to the sub-class and is used by the sub-class again, this leads to an infinite loop...


---

Comment by tscrim created at 2021-07-30 21:23:35

They are never meant to be called directly, no. Although I don't necessarily see why we need a subclass. I also don't get how you are getting an infinite loop. It is how function inheritance works.


---

Comment by @mjungmath created at 2021-07-30 21:27:46

Replying to [comment:7 tscrim]:
> Also, thank you for adding this feature.

Thank you Travis for suggesting this, and your help in general! :)

Replying to [comment:10 tscrim]:
> They are never meant to be called directly, no. Although I don't necessarily see why we need a subclass.

A non-enumerated set is not supposed to have an `__iter__` method, no? That's why I thought that sub-classing is necessary. Or what would have been your approach?

> I also don't get how you are getting an infinite loop. It is how function inheritance works.

Well, `__classcall__` of the base-class returns an invokation of the enumerated class. But that invokes the same `__classcall__` method, invoking the class constructor again... Or do I have a flaw in my thinking?


---

Comment by tscrim created at 2021-07-30 21:49:14

Replying to [comment:11 gh-mjungmath]:
> > They are never meant to be called directly, no. Although I don't necessarily see why we need a subclass.
> 
> A non-enumerated set is not supposed to have an `__iter__` method, no? That's why I thought that sub-classing is necessary. Or what would have been your approach?

`set` also has an iterator. It just doesn't promise anything precise about the iteration order.

> > I also don't get how you are getting an infinite loop. It is how function inheritance works.
> 
> Well, `__classcall__` of the base-class returns an invokation of the enumerated class. But that invokes the same `__classcall__` method, invoking the class constructor again... Or do I have a flaw in my thinking?

You would likely have a `__classcall_private__` to handle delegating to which subclass, then the processing of the input is done in `__classcall__`. Although another option is just a `_process_inputs` type method.


---

Comment by @mjungmath created at 2021-07-30 21:57:39

I see, then no sub-classing is necessary. That makes this ticket indeed minimal-invasive.

The latter is good to know. Does `__classcall_private__` always go over `__classcall__`?


---

Comment by tscrim created at 2021-07-30 22:01:50

I am actually sure if a class has both of them implemented what happens. If it is in a base class, then the order is clear I think.


---

Comment by git created at 2021-07-30 22:13:08

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by @mjungmath created at 2021-07-30 22:14:21

Changing status from needs_work to needs_review.


---

Comment by @mjungmath created at 2021-07-30 22:14:21

Alright. Small misunderstanding, huge impact.

This should be fine now.


---

Comment by @mjungmath created at 2021-07-30 22:17:14

Thank you Travis for pointing these things out.


---

Comment by tscrim created at 2021-07-31 08:01:15

Thanks. LGTM.


---

Comment by tscrim created at 2021-07-31 08:01:15

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2021-08-01 17:46:57

Thanks for implementing this!


---

Comment by vbraun created at 2021-09-05 21:38:40

Resolution: fixed
