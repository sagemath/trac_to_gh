# Issue 20210: Wrong result from delsarte_bound_additive_hamming_space with GLPK exact simplex

archive/issues_020210.json:
```json
{
    "body": "CC:  @dimpase\n\nKeywords: lp\n\n(Using #20406)\n\n```\nsage: delsarte_bound_additive_hamming_space(19,15,7,isinteger=False)\n3\nsage: from sage.numerical.backends.generic_backend import get_solver\nsage: def glpk_exact_solver():                                               \n        b = get_solver(solver=\"GLPK\")\n        b.solver_parameter(\"simplex_or_intopt\", \"exact_simplex_only\")\n        return b\nsage: delsarte_bound_additive_hamming_space(19,15,7,solver=glpk_exact_solver,isinteger=False)\nglp_exact: 54 rows, 20 columns, 795 non-zeros\n...\n2\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/20447\n\n",
    "created_at": "2016-04-14T22:51:03Z",
    "labels": [
        "component: coding theory",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-wishlist",
    "title": "Wrong result from delsarte_bound_additive_hamming_space with GLPK exact simplex",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/20210",
    "user": "https://github.com/mkoeppe"
}
```
CC:  @dimpase

Keywords: lp

(Using #20406)

```
sage: delsarte_bound_additive_hamming_space(19,15,7,isinteger=False)
3
sage: from sage.numerical.backends.generic_backend import get_solver
sage: def glpk_exact_solver():                                               
        b = get_solver(solver="GLPK")
        b.solver_parameter("simplex_or_intopt", "exact_simplex_only")
        return b
sage: delsarte_bound_additive_hamming_space(19,15,7,solver=glpk_exact_solver,isinteger=False)
glp_exact: 54 rows, 20 columns, 795 non-zeros
...
2
```


Issue created by migration from https://trac.sagemath.org/ticket/20447





---

archive/issue_comments_278219.json:
```json
{
    "body": "(See #20406 where this was discovered.)",
    "created_at": "2016-04-14T22:53:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278219",
    "user": "https://github.com/mkoeppe"
}
```

(See #20406 where this was discovered.)



---

archive/issue_comments_278220.json:
```json
{
    "body": "the function performs the following, in a loop: maximises the sum of variables, gets the value of this maximum, say M, then rounds M down to the closest m:=7<sup>d</sup>, adds a constraint that the sum of the variables is at most m, and repeats. In the case of rational variables, this process obviously must stop after one iteration (it need not stop if all the variables are integers). When it stops, it returns the latest d.\n\n```\nglp_exact: 54 rows, 20 columns, 795 non-zeros\nGNU MP bignum library is being used\n      0:   infsum =                      1   (14)\n      1:   infsum =                      0   (14)\n*     1:   objval =                      1   (14)\n*    19:   objval =       1671.30573248408   (0)\nOPTIMAL SOLUTION FOUND\nglp_exact: 54 rows, 20 columns, 795 non-zeros\nGNU MP bignum library is being used\n      0:   infsum =                      1   (14)\n      1:   infsum =                      0   (14)\n*     1:   objval =                      1   (14)\n*    17:   objval =                    343   (0)\nOPTIMAL SOLUTION FOUND\n```\n\n\nhere it should have been done, and return 3 (as 7<sup>3</sup>=343), but it is not!\n\n\n```\nglp_exact: 54 rows, 20 columns, 795 non-zeros\nGNU MP bignum library is being used\n      0:   infsum =                      1   (14)\n      1:   infsum =                      0   (14)\n*     1:   objval =                      1   (14)\n*    16:   objval =                     49   (0)\nOPTIMAL SOLUTION FOUND\n2\n```\n",
    "created_at": "2016-04-15T11:06:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278220",
    "user": "https://github.com/dimpase"
}
```

the function performs the following, in a loop: maximises the sum of variables, gets the value of this maximum, say M, then rounds M down to the closest m:=7<sup>d</sup>, adds a constraint that the sum of the variables is at most m, and repeats. In the case of rational variables, this process obviously must stop after one iteration (it need not stop if all the variables are integers). When it stops, it returns the latest d.

```
glp_exact: 54 rows, 20 columns, 795 non-zeros
GNU MP bignum library is being used
      0:   infsum =                      1   (14)
      1:   infsum =                      0   (14)
*     1:   objval =                      1   (14)
*    19:   objval =       1671.30573248408   (0)
OPTIMAL SOLUTION FOUND
glp_exact: 54 rows, 20 columns, 795 non-zeros
GNU MP bignum library is being used
      0:   infsum =                      1   (14)
      1:   infsum =                      0   (14)
*     1:   objval =                      1   (14)
*    17:   objval =                    343   (0)
OPTIMAL SOLUTION FOUND
```


here it should have been done, and return 3 (as 7<sup>3</sup>=343), but it is not!


```
glp_exact: 54 rows, 20 columns, 795 non-zeros
GNU MP bignum library is being used
      0:   infsum =                      1   (14)
      1:   infsum =                      0   (14)
*     1:   objval =                      1   (14)
*    16:   objval =                     49   (0)
OPTIMAL SOLUTION FOUND
2
```




---

archive/issue_comments_278221.json:
```json
{
    "body": "in its infinite wisdom, GLPK returns the result of an exact computation as a float. And then the line \n\n```\n      if q_base**(m+1) == bd:\n```\n\ncompares, for equality, the exact value, 343=7<sup>3</sup>, with the float 342.999999999999943, and founds them unequal. Whereas for the correct functioning of the algorithm, they must be equal. \n\nNot sure whether this is an upstream bug, or an upstream feature...",
    "created_at": "2016-04-15T11:36:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278221",
    "user": "https://github.com/dimpase"
}
```

in its infinite wisdom, GLPK returns the result of an exact computation as a float. And then the line 

```
      if q_base**(m+1) == bd:
```

compares, for equality, the exact value, 343=7<sup>3</sup>, with the float 342.999999999999943, and founds them unequal. Whereas for the correct functioning of the algorithm, they must be equal. 

Not sure whether this is an upstream bug, or an upstream feature...



---

archive/issue_comments_278222.json:
```json
{
    "body": "Changing status from new to needs_info.",
    "created_at": "2016-04-15T11:36:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278222",
    "user": "https://github.com/dimpase"
}
```

Changing status from new to needs_info.



---

archive/issue_comments_278223.json:
```json
{
    "body": "How come you never run into trouble with the floating-point based solvers with this kind of code?\n\nIt is certainly ironic that the exact solver has more floating-point fuzz than the floating-point solvers. But your code cannot be correct if solver is a floating-point solver.\n\nAnd there is an apparent upstream issue with GLPK. I wouldn't call it a bug, but given the design decision to return the exact values as double-floats, it should at least be improved to return all integers that have an exact representation in double-float as such.",
    "created_at": "2016-04-15T20:08:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278223",
    "user": "https://github.com/mkoeppe"
}
```

How come you never run into trouble with the floating-point based solvers with this kind of code?

It is certainly ironic that the exact solver has more floating-point fuzz than the floating-point solvers. But your code cannot be correct if solver is a floating-point solver.

And there is an apparent upstream issue with GLPK. I wouldn't call it a bug, but given the design decision to return the exact values as double-floats, it should at least be improved to return all integers that have an exact representation in double-float as such.



---

archive/issue_comments_278224.json:
```json
{
    "body": "Replying to [comment:5 mkoeppe]:\n> How come you never run into trouble with the floating-point based solvers with this kind of code?\n\nof course I did, and docs explicitly say that as soon as you specify another solver, you are on your own.\n\n```\n- solver \u2013 the LP/ILP solver to be used. Defaults to PPL. It is arbitrary precision, thus there will be no rounding errors. With other solvers (see MixedIntegerLinearProgram for the list), you are on your own!\n```\n\n> \n> It is certainly ironic that the exact solver has more floating-point fuzz than the floating-point solvers. But your code cannot be correct if solver is a floating-point solver.\n\nI don't think there is an API to check whether a solver is exact, and so I never bothered to check this in the code.\n\n> \n> And there is an apparent upstream issue with GLPK. I wouldn't call it a bug, but given the design decision to return the exact values as double-floats, it should at least be improved to return all integers that have an exact representation in double-float as such.\n> \nthis design is called lazyness, in CS, and not only :-)",
    "created_at": "2016-04-15T20:19:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278224",
    "user": "https://github.com/dimpase"
}
```

Replying to [comment:5 mkoeppe]:
> How come you never run into trouble with the floating-point based solvers with this kind of code?

of course I did, and docs explicitly say that as soon as you specify another solver, you are on your own.

```
- solver â€“ the LP/ILP solver to be used. Defaults to PPL. It is arbitrary precision, thus there will be no rounding errors. With other solvers (see MixedIntegerLinearProgram for the list), you are on your own!
```

> 
> It is certainly ironic that the exact solver has more floating-point fuzz than the floating-point solvers. But your code cannot be correct if solver is a floating-point solver.

I don't think there is an API to check whether a solver is exact, and so I never bothered to check this in the code.

> 
> And there is an apparent upstream issue with GLPK. I wouldn't call it a bug, but given the design decision to return the exact values as double-floats, it should at least be improved to return all integers that have an exact representation in double-float as such.
> 
this design is called lazyness, in CS, and not only :-)



---

archive/issue_comments_278225.json:
```json
{
    "body": "Replying to [comment:6 dimpase]:\n> I don't think there is an API to check whether a solver is exact, and so I never bothered to check this in the code.\n\nYou can query the `base_ring` of the MIP and then ask `is_exact`.",
    "created_at": "2016-04-15T20:22:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278225",
    "user": "https://github.com/mkoeppe"
}
```

Replying to [comment:6 dimpase]:
> I don't think there is an API to check whether a solver is exact, and so I never bothered to check this in the code.

You can query the `base_ring` of the MIP and then ask `is_exact`.



---

archive/issue_comments_278226.json:
```json
{
    "body": "Replying to [comment:7 mkoeppe]:\n> Replying to [comment:6 dimpase]:\n> > I don't think there is an API to check whether a solver is exact, and so I never bothered to check this in the code.\n> \n> You can query the `base_ring` of the MIP and then ask `is_exact`.\n\nwell, `is_exact` is a bit too much to ask, one merely needs extra precision.\n(one can figure out how much, in fact). \nSo you can use a backend that allows you to set the base ring to e.g. `RealField(2000)`.\n\nBesides, I don't think there are places in Sage that forbid doing things cause they are \"risky\".",
    "created_at": "2016-04-15T20:39:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278226",
    "user": "https://github.com/dimpase"
}
```

Replying to [comment:7 mkoeppe]:
> Replying to [comment:6 dimpase]:
> > I don't think there is an API to check whether a solver is exact, and so I never bothered to check this in the code.
> 
> You can query the `base_ring` of the MIP and then ask `is_exact`.

well, `is_exact` is a bit too much to ask, one merely needs extra precision.
(one can figure out how much, in fact). 
So you can use a backend that allows you to set the base ring to e.g. `RealField(2000)`.

Besides, I don't think there are places in Sage that forbid doing things cause they are "risky".



---

archive/issue_comments_278227.json:
```json
{
    "body": "Replying to [comment:8 dimpase]:\n> Replying to [comment:7 mkoeppe]:\n> > Replying to [comment:6 dimpase]:\n> > > I don't think there is an API to check whether a solver is exact, and so I never bothered to check this in the code.\n> > \n> > You can query the `base_ring` of the MIP and then ask `is_exact`.\n> \n> well, `is_exact` is a bit too much to ask, one merely needs extra precision.\n> (one can figure out how much, in fact). \n> So you can use a backend that allows you to set the base ring to e.g. `RealField(2000)`.\n\nPerhaps you mean a `RealIntervalField` here, because certainly `RealField(2000)` does not guarantee that the result of some unspecified numerical algorithm such as the implementation of the simplex method in the solver leads to results with 2000 correct bits, just like double-floats don't guarantee 53 correct bits.\n\n> Besides, I don't think there are places in Sage that forbid doing things cause they are \"risky\".\n\nI think there more places should forbid things like that, or at least display a warning. For example, the polyhedral code in Sage is written in a way that it assumes exact arithmetic -- and if fed with floating point numbers, leads to mysterious errors. One would usually assume from algorithms that accept floating point numbers that they have some (however naive) accommodation for floating point fuzz, in the form of some epsilons.",
    "created_at": "2016-04-15T23:05:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278227",
    "user": "https://github.com/mkoeppe"
}
```

Replying to [comment:8 dimpase]:
> Replying to [comment:7 mkoeppe]:
> > Replying to [comment:6 dimpase]:
> > > I don't think there is an API to check whether a solver is exact, and so I never bothered to check this in the code.
> > 
> > You can query the `base_ring` of the MIP and then ask `is_exact`.
> 
> well, `is_exact` is a bit too much to ask, one merely needs extra precision.
> (one can figure out how much, in fact). 
> So you can use a backend that allows you to set the base ring to e.g. `RealField(2000)`.

Perhaps you mean a `RealIntervalField` here, because certainly `RealField(2000)` does not guarantee that the result of some unspecified numerical algorithm such as the implementation of the simplex method in the solver leads to results with 2000 correct bits, just like double-floats don't guarantee 53 correct bits.

> Besides, I don't think there are places in Sage that forbid doing things cause they are "risky".

I think there more places should forbid things like that, or at least display a warning. For example, the polyhedral code in Sage is written in a way that it assumes exact arithmetic -- and if fed with floating point numbers, leads to mysterious errors. One would usually assume from algorithms that accept floating point numbers that they have some (however naive) accommodation for floating point fuzz, in the form of some epsilons.



---

archive/issue_comments_278228.json:
```json
{
    "body": "The relevant code is in GLPK's glpapi07.c; it's using `mpq_get_d` to store the rational results in a double.",
    "created_at": "2016-04-16T07:36:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278228",
    "user": "https://github.com/mkoeppe"
}
```

The relevant code is in GLPK's glpapi07.c; it's using `mpq_get_d` to store the rational results in a double.



---

archive/issue_comments_278229.json:
```json
{
    "body": "Actually, storing the rational results as doubles is fine, in fact I have a test in `glpk_backend` for that.\nThe error is happening when the big coefficients are converted into doubles, and then reconstructed by GLPK's exact simplex.\n\nSo there's no upstream bug to be reported -- except that we still really want GLPK to make the interface to glpssx.h public (#18765).\n\nGuarding your code against floating-point fuzz is a wishlist item -- I'm marking this ticket as such.",
    "created_at": "2016-04-16T16:08:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278229",
    "user": "https://github.com/mkoeppe"
}
```

Actually, storing the rational results as doubles is fine, in fact I have a test in `glpk_backend` for that.
The error is happening when the big coefficients are converted into doubles, and then reconstructed by GLPK's exact simplex.

So there's no upstream bug to be reported -- except that we still really want GLPK to make the interface to glpssx.h public (#18765).

Guarding your code against floating-point fuzz is a wishlist item -- I'm marking this ticket as such.



---

archive/issue_comments_278230.json:
```json
{
    "body": "So isn't this essentially a duplicate of #18765 then?",
    "created_at": "2017-08-31T15:18:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278230",
    "user": "https://github.com/jdemeyer"
}
```

So isn't this essentially a duplicate of #18765 then?



---

archive/issue_comments_278231.json:
```json
{
    "body": "No, #18765 is about making a \"proper\" rational GLPK API available.\n\nI've changed the description of the present ticket to say what should be done.",
    "created_at": "2017-09-01T05:44:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278231",
    "user": "https://github.com/mkoeppe"
}
```

No, #18765 is about making a "proper" rational GLPK API available.

I've changed the description of the present ticket to say what should be done.



---

archive/issue_comments_278232.json:
```json
{
    "body": "Changing status from needs_info to needs_work.",
    "created_at": "2017-09-01T05:47:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/20210",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/20210#issuecomment-278232",
    "user": "https://github.com/mkoeppe"
}
```

Changing status from needs_info to needs_work.
