# Issue 19226: A coding/two_weight_db module

Issue created by migration from Trac.

Original creator: ncohen

Original creation time: 2015-10-23 15:05:04

CC:  jsrn dlucas dimpase

This ticket creates a new coding/two_weight_db module.

In it are stored all codes that were stored in graphs/strongly_regular_db.pyx. I expect that this file will change heavily, if we end up enriching our list of two weight codes for their own sake.

A first commit moves out of the `strongly_regular_graph` function the code that builds the database of small strongly regular graphs. Which turned out to be a good idea later, as building this list actually takes some time in order to guess the parameters of the SRG from the 2-weight code.

Nathann


---

Comment by ncohen created at 2015-10-23 15:11:12

What the hell. I made a mistake and was dead sure I had deleted that branch that took me hours. Praise the Lord for 'git reflog' [1] `O_o`

Nathann

[1] http://stackoverflow.com/questions/3640764/can-i-recover-branch-after-its-deletion-in-git
----
New commits:


---

Comment by ncohen created at 2015-10-23 15:11:12

Changing status from new to needs_review.


---

Comment by dimpase created at 2015-10-24 13:21:44

in [BJ03], you get name wrong; it is
Iliya Bouyukliev, Juriaan Simonis, i.e. the 1st names are Iliya and Juriaan.
(Juriaan is not so uncommon given Dutch name, Simonis is a relatively rare !Dutch/Flemish surname).


---

Comment by dimpase created at 2015-10-24 13:57:23

The code should be capable of telling whether an SRG with such and such parameters can be constructed merely from  knowledge of parameters of two-weight codes available in the DB. Currently this is not implemented, partly due to an error in the formulas on http://moodle.tec.hkr.se/~chen/research/2-weight-codes/index.htm


---

Comment by vdelecroix created at 2015-10-25 00:45:13

Isn't there a simpler way of getting the set of weights than

```
_,w1,w2 = sorted(set([x.hamming_weight() for x in LinearCode(M)]))
```

You are going through the whole set of vectors! But I admit that the module is not imported on sage startup.

One possibility: hard code the values + add a (long) doctest that checks that these values are indeed correct?


---

Comment by vdelecroix created at 2015-10-25 01:07:28

... and note that there is `WeightDistribution` in the guava GAP package (very efficiently written in C).


---

Comment by git created at 2015-10-25 07:05:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-10-25 07:34:32

> in [BJ03], you get name wrong

Fixed.

> Isn't there a simpler way of getting the set of weights than

I now call `LinearCode.weight_distribution`.

> One possibility: hard code the values + add a (long) doctest that checks that these values are indeed correct?

That was done in an early version of this patch. I removed it to not see data repeated. I guess that it cannot hurt... All this code may eventually be wiped out however, if we start adding generic code constructions instead of fixed-size examples. That will probably change all the design, but well. We'll see.

Nathann


---

Comment by git created at 2015-10-25 07:34:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jsrn created at 2015-10-25 11:29:27

Replying to [comment:4 vdelecroix]:
> Isn't there a simpler way of getting the set of weights than
> {{{
> _,w1,w2 = sorted(set([x.hamming_weight() for x in LinearCode(M)]))
> }}}
> You are going through the whole set of vectors! But I admit that the module is not imported on sage startup.
> 
> One possibility: hard code the values + add a (long) doctest that checks that these values are indeed correct?

I was thinking that it would be nice to refactor the DB by creating a class `TwoWeightCode`; a two-weight code has, after all, rather special properties and certain properties could be computed much faster for it.

I would give this class a flag at construction time `verify = True`. When this is true, it computes the weight distribution and verifies the code is two-weight. When it is false, the code is assumed two-weight: the two weights could either be given to the constructor, or they could be inferred very easily by running through the code until two distinct weights had been encountered. This can be expected to happen very quickly. A long test could then run a `verify_is_two_weight` in the codes or something.

Johan


---

Comment by ncohen created at 2015-10-25 11:35:41

> I was thinking that it would be nice to refactor the DB by creating a class `TwoWeightCode`; a two-weight code has, after all, rather special properties and certain properties could be computed much faster for it.

I have no objection to that if you plan to do it yourself.

Nathann


---

Comment by ncohen created at 2015-10-25 11:39:57

To be more precise: this is a trac ticket. What is going here is a review, and I read anything that is written here as a comment about my code. When somebody says here that "it would be cool if your code did this/that" I read it as a comment from a reviewer. Could you make it clear whether you were asking me to implement it, or is it a random idea you were throwing here?

Nathann


---

Comment by jsrn created at 2015-10-25 12:06:59

I wrote it as a "random idea". I am somewhat motivated to do it myself, but realistically, I might well not find time to do it. I have no objections to your code if no one else wants to implement my suggestion.

It was also a comment to Vincent's suggestion. Something like: what he suggests opens up a few questions IMHO, and to properly cater all that, one needs a more invasive restructuring of your code. In that sense it was a defence of your code as it's currently written.

Johan


---

Comment by ncohen created at 2015-10-25 12:25:44

> It was also a comment to Vincent's suggestion. Something like: what he suggests opens up a few questions IMHO, and to properly cater all that, one needs a more invasive restructuring of your code. In that sense it was a defence of your code as it's currently written.

I expect all this code to be totally wiped out and rewritten in the future.

As you saw in the emails I sent about 2-weight codes the plan is to make it the 'new database' for those objects, and from what Eric Chen was saying it seems that all these codes belong to known families that we will be able to generate easily later.

I do not know what this code will look like, if it will totally replace what we have or only replace it partially, and how soon this will be implemented.

What I did here is extract the codes from the strongly regular graph module, in what will eventually become an independent database. Which, for the moment, is nothing but a dictionary with a bit of doc.

Nathann


---

Comment by jsrn created at 2015-10-25 16:41:51

> As you saw in the emails I sent about 2-weight codes the plan is to make it the 'new database' for those objects, and from what Eric Chen was saying it seems that all these codes belong to known families that we will be able to generate easily later.

My suggestion would make even more sense in this case, almost no matter how the future code will be written. Encapsulating the two-weight code properties and algorithms in a class is much more tidy and more easily supports computing things on demand.


---

Comment by ncohen created at 2015-10-25 17:01:20

> My suggestion would make even more sense in this case, almost no matter how the future code will be written. Encapsulating the two-weight code properties and algorithms in a class is much more tidy and more easily supports computing things on demand.

Which properties and algorithms are you talking about?

Nathann


---

Comment by dimpase created at 2015-10-25 18:02:28

Replying to [comment:15 ncohen]:
> > My suggestion would make even more sense in this case, almost no matter how the future code will be written. Encapsulating the two-weight code properties and algorithms in a class is much more tidy and more easily supports computing things on demand.
> 
> Which properties and algorithms are you talking about?

see the examples in http://pages.uoregon.edu/kantor/PAPERS/2-WeightCodes.pdf
Most of them are infinite series. It's 30 years old paper, one should check if there is a newer survey...


---

Comment by ncohen created at 2015-10-25 18:06:42

I just love conversing with you guys. I ask one person what properties/algorithms he would expect to see in a `TwoWeightCode` class and I am answered with a survey on those codes.

If you have any question about the code under review here, I will be glad to help.

Nathann


---

Comment by dimpase created at 2015-10-25 18:14:03

Replying to [comment:17 ncohen]:
> I just love conversing with you guys. I ask one person what properties/algorithms he would expect to see in a `TwoWeightCode` class and I am answered with a survey on those codes.

well, I meant algorithms to build all these...
One further bunch of algorithms would be constructing these complementary and projective duals...

Disclaimer: I am not a coding theorist and I know almost nothing about all these marvellous practical things about decoding/encoding, etc...


---

Comment by ncohen created at 2015-10-25 18:17:10

> well, I meant algorithms to build all these...

Oh. Well, that was not the topic. As you can read, we were discussing the usefulness of a specific class for two weight codes. While I hold nothing against it, I wondered why Johan thought that it would be useful: I personally just need the codes to build strongly regular graphs. I don't know which properties/methods we would attach to them if we had such a class.

Nathann


---

Comment by dimpase created at 2015-10-25 18:41:48

Probably it makes sense to make a sub-class for projective codes, for a q-ary [n,k]-projective code naturally corresponds to a set in PG(k-1, q), to which one can do things not possible with general codes. But 2-distance? Well, I don't know.


---

Comment by jsrn created at 2015-10-26 08:50:33

Replying to [comment:19 ncohen]:
> > well, I meant algorithms to build all these...
> 
> While I hold nothing against it, I wondered why Johan thought that it would be useful: I personally just need the codes to build strongly regular graphs. I don't know which properties/methods we would attach to them if we had such a class.

A class is just a dictionary with code attached to it :-) Two-weight codes are special codes that allow certain properties to be calculated much faster than the general exponential bounds. Such as, obviously, minimum distance and which hamming weights are in the code, but there's surely more. Since such codes are apparently interesting in graph theory and combinatorics, it seems likely that someone might want to play around with them as codes, before you build graphs. "playing around" would then be computing stuff on them. Making them a class would give a natural place to put this code. By just making them `LinearCode`s, we miss out on the opportunity of putting these fast algorithms in a natural place. I'm not really talking about encoding/decoding, since I don't know that anyone should be interested in that.

One concrete example in your use where a class might be useful is in lazy computation of the two weights, using the faster, probabilistic algorithm.

The constructions of families that Dima talks about could be either functions that instantiate `TwoWeightCode` or subclasses, depending on whether the first would be overkill or not.

I concede that it might look like over-engineering from your point of view, however. From my point of view, this is a very special class of codes that is seemingly useful and (now) used in Sage. Therefore its natural that it should have a class :-)


---

Comment by git created at 2015-10-31 16:15:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-11-24 11:39:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-11-24 11:41:13

Just merged this branch with the latest beta, as it was in conflict. This branch moves a long list of constructors, and there is a need to double-check everything every time this list gets modified by another patch.

Nathann


---

Comment by git created at 2015-11-25 17:46:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-11-26 13:30:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2015-11-26 14:37:20

take the last commit from `public/19463` to avoid the following:


```
$ sage -btp src/sage/coding/two_weight_db.py
python -u setup.py install
Updating Cython code....
Enabling Cython debugging support
Compiling sage/graphs/strongly_regular_db.pyx because it changed.
[1/1] Cythonizing sage/graphs/strongly_regular_db.pyx

Error compiling Cython file:
------------------------------------------------------------
...
        sage: G = SRG_630_85_20_10()                    # long time
        sage: G.is_strongly_regular(parameters=True)    # long time
        (630, 85, 20, 10)
    """
    from sage.graphs.generators.intersection import IntersectionGraph
    hs = HoffmanSingletonGraph()
                             ^
------------------------------------------------------------

sage/graphs/strongly_regular_db.pyx:2340:30: undeclared name not builtin: HoffmanSingletonGraph
...
```



---

Comment by git created at 2015-11-26 14:41:06

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by ncohen created at 2015-11-26 14:41:48

......................................

NEVER use one of Dima's branches.


---

Comment by git created at 2015-11-26 14:42:43

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by ncohen created at 2015-11-26 14:43:05

Fixed. Thanks,

Nathann


---

Comment by dimpase created at 2015-11-26 14:49:11

Replying to [comment:32 ncohen]:
> ......................................
> 
> NEVER use one of Dima's branches.

I told you - take the last commit :-)


---

Comment by dimpase created at 2015-11-26 15:09:42

I don't quite understand the new design, but it seems to work.


---

Comment by dimpase created at 2015-11-26 15:09:42

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-11-27 22:26:54

Merge conflict


---

Comment by vbraun created at 2015-11-27 22:26:54

Changing status from positive_review to needs_work.


---

Comment by dimpase created at 2015-11-27 23:05:37

Changing status from needs_work to needs_review.


---

Comment by dimpase created at 2015-11-27 23:05:37

the merge conflict was in the .rst file, trivial to resolve. I hope I didn't screw up the branch I propose...


---

Comment by git created at 2015-11-28 09:18:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-11-28 09:19:37

This new commit only merges it with beta6, and not with anything else.


---

Comment by ncohen created at 2015-11-28 09:19:37

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2015-11-29 12:12:07

Resolution: fixed


---

Comment by dimpase created at 2015-11-29 16:51:53

There is still a two-weight code left in `graphs/strongly_regular_graphs_db`, namely, in 
`SRG_729_336_153_156` there is matrix `L`, which gives

```
sage: [w for w,f in enumerate(LinearCode(L.T).weight_distribution()) if w and f]
[108, 117]
sage: LinearCode(L.T)
Linear code of length 168, dimension 6 over Finite Field of size 3
```



---

Comment by dimpase created at 2015-11-29 16:58:50

I didn't know that commenting on closed tickets looks like it nukes commits. I think it's actually just a wrong message, as I can still see this commit just fine.
