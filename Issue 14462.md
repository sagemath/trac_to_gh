# Issue 14462: Test if a weight function is generic for a given matroid

Issue created by migration from Trac.

Original creator: Stefan

Original creation time: 2013-05-30 18:16:00

Assignee: sage-combinat

CC:  darij yomcat

Keywords: matroid, weight function

Reported by darij on http://trac.sagemath.org/sage_trac/ticket/7477 :

Feature suggestion, if not already implemented: a method to test if a given weight function is generic, i. e., has exactly one maximizing basis. Of course, this is easy thanks to the exchange graph, as one only needs to find a maximizing basis and then check that all its exchange neighbours have strictly smaller weight. This function is useful to some Hopf-algebraic constructions.


---

Comment by Stefan created at 2013-09-13 13:50:01

Changing component from combinatorics to matroid theory.


---

Comment by Stefan created at 2013-09-13 13:50:01

Changing assignee from sage-combinat to Stefanf.


---

Comment by tara created at 2016-04-09 01:30:56

New commits:


---

Comment by tara created at 2016-04-09 01:30:56

Changing status from new to needs_review.


---

Comment by darij created at 2016-04-09 06:51:06

Thank you! May I ask a couple questions before I look deeper into the code?

- What is the difference between the two functions?

- What exactly is `X` used for? I assume the answer somehow depends on `X`. Is it just restricting the matroid to `X`?


---

Comment by tara created at 2016-04-09 14:49:58

Hi Darij,

We decided to avoid the suggestion given in the ticket, because it would require checking if up to $r(|E|$-r)$ additional sets were independent. (This could have been reduced, by only checking exchanges where the two elements had the same weight.) Our strategy was whenever we decided not to put an element $e$ into our basis $B$, we checked if would have been allowed to put it in if we had done so as soon as possible. In the case where we were not passed a weight function, this amounts to checking whether or not $\{e\}$ is independent. If we were passed a weight function, we check if the set smres is independent, where smres is all the things in res which have strictly more weight than $e$ together with $e$.

Essentially what I did was to copy the code for max_weight_independent() and modify it to see if it through out something that could have been kept in some application of the greedy algorithm. Other than declaring smres and changing the return statements to give booleans, I added the code following code to the case where I wanted to discard $e$. The only difference between is_max_weight_independent_generic() and is_max_weight_coindependent_generic() is that 'rank' was replaced with 'corank' in both places.

I agree that $X$ is just restricting the matroid to $X$.


                smres=res
                if weights is None:
                    if self._rank(set([e]))>0:
                        return False
                    else:
                        for f in res:
                            if weights(e)==weights(f):
                                smres.discard(f)
                smres.add(e)
                if self._rank(smres) > len(smres)-1:
                    return False


Cheers,
Tara


---

Comment by tara created at 2016-04-09 15:26:28

I realized, as I was writing that last comment, that I was doing more work than necessary, because I was re-building smres each time it was needed, instead of keeping it updated. I re-wrote the code to avoid that. I also moved the conditional if weights(e)==weights(f) to the outside of the for-loop, so that it wasn't asked each time. I think that this also improves code readability, but I'm not entirely sure about that.


---

Comment by git created at 2016-04-09 15:38:33

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-04-11 19:37:59

New commits:


---

Comment by darij created at 2016-04-11 19:41:34

I've made some changes (NB: branch change!), particularly documenting one of the undocumented codepaths (namely, passing a dictionary for `weight`). However, it exposed a bug: The algorithm assumes `weight` to be a function.

My suggestion here would be to change the way dictionaries are handled. Rather than doing the `try/except`s, I'd check whether `weight` is a dictionary, and then define a function `weight_fun` to send each `e` to `weight[e]`. Otherwise, I'd just set `weight_fun = weight`. All other uses of `weight` in the code should then be replaced by `weight_fun`. Does this sound reasonable to you? (I haven't done any speed comparisons or other tests, so this might not actually be a good idea.)

Also, the algorithm looks nice and clean. I haven't proven it yet. Is it easy or should I know something it follows from?

Thanks for the good work!


---

Comment by darij created at 2016-04-11 19:45:09

Also, I'm not fully sure about what goes on here:

```
        if weights is None:
            for e in Y:
                res.append(e)
                if self._rank(res) > r:
                    r += 1
                else:
                    del res[-1]
                    smres.append(e)
                    if self._rank(smres) >= 1:
                        return False
                    else:
                        del smres[-1]
            return True
```

Am I seeing it right that `smres` never has length >1 ? So you are essentially checking that `e` is a loop; if it isn't, then you return `False`? Do you really need an array for that?


---

Comment by tara created at 2016-04-11 21:09:28

The algorithm follows from the idea that whenever we apply the greedy algorithm, we get a maximal basis, and we can get each maximal basis by using the greedy algorithm. A maximal weighted basis `B` is unique if and only if for every `e\in E(M)-B`, we have `e` is in the closure of `{b\in B|w(b)>w(e)}`. In other words, `B` is unique, if when using the greedy algorithm, we never were able to choose an element of `E(M)-B`.

We don't need an array for `smres` in the weights is None case. I had originally put both cases in one for loop, until I realized that that was gross, and I didn't notice, when I changed it, that `smres` is now pointless in that case.


---

Comment by darij created at 2016-04-12 18:43:10

OK, that's a nice algorithm! That said, I don't really understand the way you implemented it; the concrete meaning of `smres` is unclear to me (some loop invariants might be helpful).

The two methods are really supposed to do the same thing, just in different ways? Are the ways really functionally different, i.e. one is a lot faster in some situations and the other in others?

I'd also be indebted if you could do the fixes I suggested in my previous post. I don't trust myself that much with cpdefs...


---

Comment by Stefan created at 2016-04-12 19:14:55

Replying to [comment:14 darij]:
> I've made some changes (NB: branch change!), particularly documenting one of the undocumented codepaths (namely, passing a dictionary for `weight`). However, it exposed a bug: The algorithm assumes `weight` to be a function.
> 
> My suggestion here would be to change the way dictionaries are handled. Rather than doing the `try/except`s, I'd check whether `weight` is a dictionary, and then define a function `weight_fun` to send each `e` to `weight[e]`. Otherwise, I'd just set `weight_fun = weight`. All other uses of `weight` in the code should then be replaced by `weight_fun`. Does this sound reasonable to you? (I haven't done any speed comparisons or other tests, so this might not actually be a good idea.)

In Python, any object can implement the square bracket and round bracket notation. Your suggestion would make it impossible to have a matroid with ground set 0..n and weight function just a list.

This code was borrowed from the max_weight_independent method, where in the examples both dictionary and function specifications are tested. Do you have an example of when your bug occurs?


---

Comment by Stefan created at 2016-04-12 19:15:41

Replying to [comment:17 darij]:
> OK, that's a nice algorithm! That said, I don't really understand the way you implemented it; the concrete meaning of `smres` is unclear to me (some loop invariants might be helpful).
> 
> The two methods are really supposed to do the same thing, just in different ways? Are the ways really functionally different, i.e. one is a lot faster in some situations and the other in others?
> 
> I'd also be indebted if you could do the fixes I suggested in my previous post. I don't trust myself that much with cpdefs...

I would expect the second function to be the dual of the first. Is that the case here?


---

Comment by darij created at 2016-04-12 19:16:16

Yes, I've added such an example in my commit -- if you run the doctests, you'll see it fail.

What do you mean by "the dual"?


---

Comment by Stefan created at 2016-04-12 19:20:24

Replying to [comment:20 darij]:
> Yes, I've added such an example in my commit -- if you run the doctests, you'll see it fail.
> 
> What do you mean by "the dual"?

I mean that I'd expect

M.is_max_weight_coindependent_generic

to return the output of

M.dual().is_max_weight_independent_generic


---

Comment by darij created at 2016-04-12 19:23:17

Oh. But if so, the doc should be different!


---

Comment by Stefan created at 2016-04-12 19:32:12

Replying to [comment:22 darij]:
> Oh. But if so, the doc should be different!

Agreed


---

Comment by Stefan created at 2016-04-12 20:18:42

Replying to [comment:20 darij]:
> Yes, I've added such an example in my commit -- if you run the doctests, you'll see it fail.
> 
> What do you mean by "the dual"?

I see it. The problem is that the user input variable "weights" is used down the line, as opposed to the object created in the try/except blocks. The list `wt` is not so useful, so I would probably define something that's guaranteed to be a function, like so:


```
if callable(weights):
    wts = weights
else:
    wts = lambda x: weights[x]
```

Then use wts instead of weights down the line.

For the record, to test a file, run (from the top `sage` directory):


```
./sage -t src/sage/matroids/matroid.pyx
```



---

Comment by tara created at 2016-04-13 04:00:05

Replying to [comment:24 Stefan]:

> 
> I see it. The problem is that the user input variable "weights" is used down the line, as opposed to the object created in the try/except blocks. The list `wt` is not so useful, so I would probably define something that's guaranteed to be a function, like so:
> 
> {{{
> if callable(weights):
>     wts = weights
> else:
>     wts = lambda x: weights[x]
> }}}
> Then use wts instead of weights down the line.
> 

The reason that `wt` is currently useful, is that it is used to sort the elements in decreasing order of weight. I'm not sure how to do that with only a function `wts`. I tried adding the function wts, but I ended up having it not compile. I'll look at it again tomorrow.


---

Comment by Stefan created at 2016-04-13 11:52:05

What's the error? Maybe callable() isn't supported in Cython?

Yeah, you'll need both. Since you need the output in order, you can't just call the max_weight_independent function either, unfortunately.


---

Comment by tara created at 2016-04-13 20:49:29

Replying to [comment:26 Stefan]:
> What's the error? Maybe callable() isn't supported in Cython?
> 

It won't compile when I have the line 

```
wts = lambda x: weights[x]
```


It will, however, compile when I have

```
if callable(weights):
                wts = weights
            else:
                return True
```


So for some reason, that I don't understand, we're not allowed to use lambda in this way. Functions in other places in the file use lambda inside a function call, and I don't see a difference in the syntax that we are using. I have also tried using
`def wts(x) : return weights[x]`.


---

Comment by darij created at 2016-04-13 21:56:08

Does Cython actually know lambda at all? And if so, does it allow functions without specified input and output types?

(This is not a rhetorical question; I really have no idea.)


---

Comment by Stefan created at 2016-04-15 15:35:36

Ah, you can have them inside a def but not inside a cpdef.

So you're going to need a less elegant solution. Easiest but least elegant is to repeat the code twice, once with () and once with [].


---

Comment by Stefan created at 2016-04-15 15:35:36

Changing status from needs_review to needs_work.


---

Comment by darij created at 2016-04-15 17:50:03

What about a def frontend and a cpdef backend? Of course, we'd need to figure out whether the backend should take a dict or a function... Is it possible to wrap up a dict in a function and send it to the backend, or will the backend not accept such a function?


---

Comment by git created at 2016-05-09 13:34:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tara created at 2016-05-09 16:47:45

Changing status from needs_work to needs_review.


---

Comment by darij created at 2016-05-10 06:38:01

Nice, this looks a lot better. But I still struggle to find a mental model for `smres`. From your description of the algorithm, it should be the list containing all elements of `res` having higher weight than `e`, and `e` itself. But from the code, it seems to be the list containing all elements of `res` having higher weight than `e`, and the first element of `res` that has the same weight as `e` (because `e` does not get appended to `smres` unless `e` sets a negative weight record). Am I reading the code right, and is this an actual issue? Thank you!


---

Comment by tara created at 2016-05-10 15:15:02

Replying to [comment:34 darij]:
> Nice, this looks a lot better. But I still struggle to find a mental model for `smres`. From your description of the algorithm, it should be the list containing all elements of `res` having higher weight than `e`, and `e` itself. But from the code, it seems to be the list containing all elements of `res` having higher weight than `e`, and the first element of `res` that has the same weight as `e` (because `e` does not get appended to `smres` unless `e` sets a negative weight record). Am I reading the code right, and is this an actual issue? Thank you!

You're correct, there was a problem with `smres`. I wasn't adding `e` to it all the time. I had moved some things about to make it read nicer, and introduced that bug.


---

Comment by git created at 2016-05-10 15:15:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-05-11 03:20:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-05-11 03:22:02

Thank you!

I've made my own changes. (Only one change to the code proper: The `is_max_weight_coindependent_generic` function was doing the same as `is_max_weight_independent_generic` but for the dual matroid of `self` instead of `self`. Now it does what it claims to do.) If the result looks good to you, please set this to positive_review. Thanks again for implementing this!

Also, if your "we" includes some other authors, I guess they should go into the author field as well.


---

Comment by darij created at 2016-05-11 03:23:23

PS. I replaced your "iterable" by "list, tuple or set" because I don't think an iterator would have worked. (That said, I haven't tried.)


---

Comment by git created at 2016-05-11 03:30:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tara created at 2016-05-11 23:27:38

The only thing that looks like a problem is in edb1a33, you changed `wt = sorted(wt, reverse=True)` to `wt = sorted(wt)` in line 6667. And later changed `if wt_dic[e] < wt_dic[res[-1]]:` to `if wt_dic[e] > wt_dic[res[-1]]:`. It seems like this would test if a minimum cobasis was generic rather than a maximum cobasis. I would expect `M.is_max_weight_coindependent_generic()` to give the same results as `M*.is_max_weight_independent_generic()`, where `M*` is the dual of `M`. 

My "we" sometimes included Stefan. He and I are both at LSU, and he's given recommendations. He might have avoided writing code so that he would be free to review it.


---

Comment by darij created at 2016-05-11 23:28:53

Oh! But then you should not be claiming that the two methods are doing the same thing. I changed the methods to achieve precisely this effect.


---

Comment by tara created at 2016-05-13 02:51:45

Replying to [comment:42 darij]:
> Oh! But then you should not be claiming that the two methods are doing the same thing. I changed the methods to achieve precisely this effect.

When I execute the following code, using the current version, I get `True` and then `False`. We should expect `True` in both cases, because `{3,4}` is the only maximum weighted basis of `M`. 

```
from sage.matroids.advanced import setprint 
M=matroids.Uniform(2,5) 
wt={0: 1, 1: 1, 2: 1, 3: 2, 4: 2}
M.is_max_weight_independent_generic(weights=wt)
M.dual().is_max_weight_coindependent_generic(weights=wt)
```


However, when I change those two lines back, I get `True` for both outputs. Furthermore, the code in `is_max_weight_coindependent_generic` looking the same as `is_max_weight_independent_generic`, excepting that `rank` is changed to `corank` makes intuitive sense to me.


---

Comment by darij created at 2016-05-13 02:54:26

Feel free to change this back... but then please rewrite this documentation:

```
+        The method :meth:`is_max_weight_coindependent_generic`
+        computes the same function using a different algorithm.
```

(and the similar claim on the other method). "The same function", in my eyes, means literally the same function, not the same function on the dual matroid!


---

Comment by git created at 2016-05-13 02:59:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-05-13 03:01:34

PS. This:

```
+    cpdef is_max_weight_coindependent_generic(self, X=None, weights=None):
+        r"""
+        Test if only one basis of the subset ``X`` has maximal
+        weight.
```

also should have "cobasis" rather than "basis", right?


---

Comment by git created at 2016-05-13 03:10:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tara created at 2016-05-13 03:13:55

Replying to [comment:44 darij]:
> Feel free to change this back... but then please rewrite this documentation:
> {{{
> +        The method :meth:`is_max_weight_coindependent_generic`
> +        computes the same function using a different algorithm.
> }}}
> (and the similar claim on the other method). "The same function", in my eyes, means literally the same function, not the same function on the dual matroid!

You're right, that sentence is confusing. I haven't been checking the documentation as well as I should have been doing. I think that i was trying to say there is covered in the Algorithm section, and I didn't see other functions having a method section, so I don't know why I put that in in the first place. Thanks for being so scrupulous. 
----
New commits:


---

Comment by darij created at 2016-05-13 07:28:08

Sorry for continuous annoyance, but please also see comment:46. (I would do this myself, but I'll probably have a negative amount of spare time today...) Once you've fixed the doc, you have my positive review!


---

Comment by git created at 2016-05-13 11:38:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-05-13 14:24:27

Wonderful!


---

Comment by darij created at 2016-05-13 14:24:27

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-05-22 07:40:58

Doctests fail as evident in the patchbot report


---

Comment by vbraun created at 2016-05-22 07:40:58

Changing status from positive_review to needs_work.


---

Comment by git created at 2016-05-22 17:05:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2016-05-22 17:05:55

Oops! Fallout from our previous misunderstanding about what the two functions were supposed to do. Should be correct now.


---

Comment by darij created at 2016-05-22 17:05:55

Changing status from needs_work to positive_review.


---

Comment by vbraun created at 2016-05-23 22:23:30

Resolution: fixed
