# Issue 28805: Remove sorting of dicts

Issue created by migration from https://trac.sagemath.org/ticket/29042

Original creator: arojas

Original creation time: 2020-01-18 23:11:28

CC:  jhpalmieri dimpase tscrim arojas




---

Comment by arojas created at 2020-01-18 23:15:50

New commits:


---

Comment by arojas created at 2020-01-18 23:15:50

Changing type from PLEASE CHANGE to enhancement.


---

Comment by arojas created at 2020-01-18 23:15:50

Changing component from PLEASE CHANGE to refactoring.


---

Comment by nbruin created at 2020-01-19 00:44:42

This is going to be quite fragile, because now you're encoding a rather arbitrary dictionary order into the doctests, where no order matters (in py3 it's probably insertion order; a change in code somewhere that changes insertion order would break tests again!).

Why not introduce a little utility function `print_dict_sorted` that recovers the sorted dictionaries? It would amount to

```
sorted( D.items(), key=lambda t:t[0])
```

but with an appropriate routine you could print the result in a more dict-compatible way so that you can fix each doctest with a single-line edit.

That way you end up with a more future-proof fix, and it makes total sense to insert such a print routine at least into the doctest namespace (but then almost by necessity also in the interactive namespace)


---

Comment by arojas created at 2020-01-25 13:09:24

Sounds reasonable but that's beyond my ability, so someone else will have to do it.


---

Comment by @mwageringel created at 2020-01-25 21:02:55

The idiom `sorted(D.items())` is already used in several places in the doctests. Alternatively,

```
sage: from pprint import pprint
sage: pprint(D)
```

could be used to print a dict sorted by keys, which also seems to take care of nested dictionaries.

On the other hand, if one really wants to keep the sorted output of dicts in general, another solution would be to add a displayhook during doctests that imitates what is currently done by IPython. This would be more robust than using `pprint` everywhere, as it is likely that new doctests depending on insertion order would be introduced in the long run otherwise.


---

Comment by nbruin created at 2020-01-26 04:15:57

Replying to [comment:5 gh-mwageringel]:
> The idiom `sorted(D.items())` is already used in several places in the doctests. Alternatively,
> {{{
> sage: from pprint import pprint
> sage: pprint(D)
> }}}
> could be used to print a dict sorted by keys, which also seems to take care of nested dictionaries

Thanks for the suggestion! The routine I was thinking about already exists!. I think in "examples" doctests, the `pprint` is a little more desirable, because its output looks like a dictionary: reading the example with the printed output barely has any additional cognitive load. For that purpose, it might be worth considering to inject `pprint` in the global namespace by default. I think it serves a real purpose now that IPython dict printing is no longer sorted.

> On the other hand, if one really wants to keep the sorted output of dicts in general, another solution would be to add a displayhook during doctests that imitates what is currently done by IPython. This would be more robust than using `pprint` everywhere, as it is likely that new doctests depending on insertion order would be introduced in the long run otherwise.

True, but that would cause a deviation between doctest output and the output that the actual example in the command line would give. The `IPython` reason for dispensing with sorting dictionaries is a good one, so I would not be in favour of bringing back that hook in general.

I also think that there are legitimate reasons to make doctests that do print the dict in the "Py3" order, for instance if used to compare with the iteration order. In those cases it would be possible to formulate the doctests differently, no doubt, but I would rather not preempt such use. I think putting up with having to use `pprint` is reasonable, with the price that it's a magnet for fragile doctests (but in reality, doctests for lots of more complicated routines are hard to make non-fragile. By comparison I think the dict issue is relatively mild.


---

Comment by @mwageringel created at 2020-01-26 17:11:36

Replying to [comment:6 nbruin]:
> For that purpose, it might be worth considering to inject `pprint` in the global namespace by default. I think it serves a real purpose now that IPython dict printing is no longer sorted.

In that case, rather than injecting `pprint`, it might be better to improve the pretty print function that already exists in the global namespace, for example by adding a new keyword `pretty_print(D, sort=True)`. IMO, this makes it clearer why the pretty printing is used. This is synonymous to `show(D, sort=True)`.

> True, but that would cause a deviation between doctest output and the output that the actual example in the command line would give. The `IPython` reason for dispensing with sorting dictionaries is a good one, so I would not be in favour of bringing back that hook in general.

This deviation already exists, as the IPython sorting of dicts is only active during doctests. That said though, I do not have a strong preference for either solution â€“ though I agree it is generally desirable to keep doctest output as close as possible to the actual output.


---

Comment by nbruin created at 2020-01-27 02:43:13

Replying to [comment:7 gh-mwageringel]:

> In that case, rather than injecting `pprint`, it might be better to improve the pretty print function that already exists in the global namespace, for example by adding a new keyword `pretty_print(D, sort=True)`. IMO, this makes it clearer why the pretty printing is used. This is synonymous to `show(D, sort=True)`.

It seems pretty_print aims at a different target: its default is latex output in the command line (that's a bad default), and in general "this function chooses the highest-quality output supported by the user interface", so that doesn't quite hit the goals of doctests (which should be concise and human-readable).

If we do

```
dm = get_display_manager()
dm.preferences.text='plain'
```

we end up with better results for our doctesting purposes. But that would be worse than `from pprint import pprint`.


---

Comment by @mwageringel created at 2020-01-27 18:43:28

Replying to [comment:8 nbruin]:
> It seems pretty_print aims at a different target: its default is latex output in the command line (that's a bad default), and in general "this function chooses the highest-quality output supported by the user interface", so that doesn't quite hit the goals of doctests (which should be concise and human-readable).

I fail to see the rationale behind defaulting to latex, or the intended use case of `pretty_print`. Making a distinction between `%display plain` and `%display None` is bizarre and seems wrong to me. The usual REPL output at least does not make such a distinction (implemented in `sage.repl.rich_output.display_manager.DisplayManager._preferred_text_formatter`).

Should we add `pprint` to the global namespace then? I am not sure this is the best thing to do, but it seems practical. Or just add explicit `from pprint import pprint` statements in the doctests?


---

Comment by mantepse created at 2020-01-27 21:32:25

It seems to me that it would be good to discuss this at sage-devel, because it affects all developers.

Let me add that it is unclear to me what the best solution is.  Initially, I liked the idea of `pretty_print(D, sort=True)`.  I think that yet another pretty print function is a bad idea, I find the existence of `show`, `pretty_print`, `ascii_art`, `.pp()` and possibly others confusing enough.


---

Comment by git created at 2020-02-03 07:49:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-03-02 21:05:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-03-08 18:09:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-03-11 21:29:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by fbissey created at 2020-03-29 01:55:36

This needs rebasing. My own thinking is that calling the structure dictionary lead humans to have an expectation for it to be ordered the way the physical object is. In fact we have look up tables which are very handy for the computer to manipulate but not necessarily  meant for full display. In most case sorting doesn't matter objectively. 

So I am not sure we should compare whole dictionaries for doctests. Size of the dictionary and some key elements should be enough.


---

Comment by git created at 2020-03-29 08:26:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-03-29 14:17:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mwageringel created at 2020-04-05 14:22:03

Replying to [comment:15 fbissey]:
> My own thinking is that calling the structure dictionary lead humans to have an expectation for it to be ordered the way the physical object is. In fact we have look up tables which are very handy for the computer to manipulate but not necessarily  meant for full display. In most case sorting doesn't matter objectively. 
> 
> So I am not sure we should compare whole dictionaries for doctests. Size of the dictionary and some key elements should be enough.

I agree that generally doctests should be focussed on testing very specific things rather than entire dictionaries. Rewriting all these doctests case-by-case so that dictionaries are not printed anymore seems like a huge task though.

As the current patch also seems to fail with 32-bit, it still seems to me that the simplest approach to move forward with this is to extend `pretty_print` by a sort keyword. A first step for this is #29136, needing review, which stops `pretty_print` from outputting latex on the command line.

For reference, this problem was discussed in this [thread on devel](https://groups.google.com/d/msg/sage-devel/fXrv4JC6NEI/LwIcVb5EEwAJ) and there does not seem to be much disagreement about this.


---

Comment by git created at 2020-04-13 15:37:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-04-14 19:41:51

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.


---

Comment by git created at 2020-04-23 16:26:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2020-04-23 16:33:21

Is there really not a better way to do these doctest updates that can be agreed on? Using `sorted(D.items())` as suggested early on this ticket seems much more reasonable


---

Comment by git created at 2020-05-05 07:02:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by fbissey created at 2020-05-22 08:21:52

Replying to [comment:22 mkoeppe]:
> Is there really not a better way to do these doctest updates that can be agreed on? Using `sorted(D.items())` as suggested early on this ticket seems much more reasonable

It is a quite economical way to do things. But we have to document somewhere how dictionaries have to tested going forward. As far as I can see people still want or keep testing full dictionaries. Which leaves two options
* `sorted` if we are sure it does the job in every case
* since we are typing the whole dictionary anyway, create a `expected_dict` populated with expected value and compare it to the result dictionary we get. I would hope dictionary comparison doesn't care about sorting.


---

Comment by fbissey created at 2020-05-22 08:42:08

And I think we may want to remove that one altogether

```
File "/usr/lib/python3.7/site-packages/sage/repl/display/pretty_print.py", line 85, in sage.repl.display.pretty_print.SagePrettyPrinter.__init__
Failed example:
    dict(zzz=123, aaa=99, xab=10)    # sorted by keys
Expected:
    {'aaa': 99, 'xab': 10, 'zzz': 123}
Got:
    {'zzz': 123, 'aaa': 99, 'xab': 10}
```

Which comes from

```
        IPython pretty printers::

            sage: set({1, 2, 3})
            {1, 2, 3}
            sage: dict(zzz=123, aaa=99, xab=10)    # sorted by keys
            {'aaa': 99, 'xab': 10, 'zzz': 123}
```

Pretty print no more.


---

Comment by fbissey created at 2020-05-22 09:50:27

I am looking at some stuff in .rst file. It is both doctests and documentation. For example in `doc/en/prep/Advanced-2DPlotting.rst`

```
Here are the options for contour plots.

- They are given as an "attribute" \- no parentheses \- of the
  ``contour_plot`` object.

- They are given as a dictionary (see :ref:`the programming tutorial
  <Advanced>`).

::

    sage: contour_plot.options
    {'aspect_ratio': 1,
     'axes': False,
     'colorbar': False,
     'contours': None,
     'fill': True,
     'frame': True,
     'labels': False,
     'legend_label': None,
     'linestyles': None,
     'linewidths': None,
     'plot_points': 100,
     'region': None}
```

the documentation aspect doesn't really care about the sorting. It is just displaying. But this is doctested as well which does. Using an `expected_dict` variable doesn't make sense in this context. If we use `sorted` we have to make a note about it in the documentation that it is just to make presentation consistent. If we just reproduce the output, the order may change unexpectedly.


---

Comment by jhpalmieri created at 2020-05-22 17:30:01

Maybe we should just label that as "random".


---

Comment by fbissey created at 2020-05-22 20:05:04

Replying to [comment:29 jhpalmieri]:
> Maybe we should just label that as "random".

I thought about that. Does it show in generated html/pdf?


---

Comment by jhpalmieri created at 2020-05-22 21:14:00

Replying to [comment:30 fbissey]:
> Replying to [comment:29 jhpalmieri]:
> > Maybe we should just label that as "random".
> 
> I thought about that. Does it show in generated html/pdf?

It does. We could add a remark beforehand: `The following is marked "random" because Python may print dictionaries in an unpredictable order`. I think I've done this sort of thing with other doctests tagged `random`.


---

Comment by tscrim created at 2020-05-23 00:50:03

The problem is that it also accepts something like `2` as being equal. I am -1 a strong on marking things as `# random` and instead replacing them with more meaningful doctests (like comparing the result to a fixed dictionary, or getting specific values in the result, etc.).


---

Comment by fbissey created at 2020-05-23 01:16:20

Replying to [comment:32 tscrim]:
> The problem is that it also accepts something like `2` as being equal. 

You are losing me here. Can you expand?

> I am -1 a strong on marking things as `# random` and instead replacing them with more meaningful doctests (like comparing the result to a fixed dictionary, or getting specific values in the result, etc.).

We are talking about only putting `random` in specific documentation where it doesn't matter and ordering would look weird. But even there I would agree on getting as specific as possible to avoid having to do it. For example, in the same file as comment:28 and after it we have

```
sage: contour_plot.options["fill"]=False
sage: contour_plot.options
{'aspect_ratio': 1,
 'axes': False,
 'colorbar': False,
 'contours': None,
 'fill': False,
 'frame': True,
 'labels': False,
 'legend_label': None,
 'linestyles': None,
 'linewidths': None,
 'plot_points': 100,
 'region': None}
```

Where we could look specifically at the concerned dictionary element. But the one in comment:28 is part of an exposition of a feature. It feels ridicule to compare the output or to to artificially order it as opposed to just mentioning that the elements are not always in that order.

We have to use some common sense on what is appropriate and what isn't.


---

Comment by tscrim created at 2020-05-23 02:11:13

Replying to [comment:33 fbissey]:
> Replying to [comment:32 tscrim]:
> > The problem is that it also accepts something like `2` as being equal. 
> 
> You are losing me here. Can you expand?

If you have

```
sage: foo  # random
2 + 2
```

this also will pass even if `foo` is a `dict` or `'fish'` (i.e. I can make `2 + 2 = 'fish'`).

> > I am -1 a strong on marking things as `# random` and instead replacing them with more meaningful doctests (like comparing the result to a fixed dictionary, or getting specific values in the result, etc.).
> 
> We are talking about only putting `random` in specific documentation where it doesn't matter and ordering would look weird. But even there I would agree on getting as specific as possible to avoid having to do it. For example, in the same file as comment:28

Ah, I see. I misinterpreted what you were asking about. I was thinking it was being made as a more broad statement. Sorry.

> Where we could look specifically at the concerned dictionary element. But the one in comment:28 is part of an exposition of a feature. It feels ridicule to compare the output or to to artificially order it as opposed to just mentioning that the elements are not always in that order.
> 
> We have to use some common sense on what is appropriate and what isn't.

I guess in this case because it is meant to be for an illustrative purpose that it is fine for a `# random` with an explanation.


---

Comment by jhpalmieri created at 2020-05-23 03:30:31

Yes, I was only talking about this specific doctest, not all of these. I think we're in agreement, but to make it explicit: my approach is to try to understand what the doctest is testing. If it's merely illustrative, I don't mind tagging it with `random`. This is especially true if the same functionality is tested robustly elsewhere, although to be honest, I didn't check that in this case. Of course a `random` tag is no good if you're actually trying to test the output.


---

Comment by fbissey created at 2020-05-23 09:11:39

It is much tougher than I expected. What do you do with cases like that?

```
Representatives of all divisor classes with nontrivial homology::

    sage: p = S.betti_complexes()
    sage: p[0]
    [{0: -8, 1: 5, 2: 4, 3: 1},
     Simplicial complex with vertex set (1, 2, 3) and facets {(3,), (1, 2)}]
```

in `src/doc/en/thematic_tutorials/sandpile.rst`.  A list with a dictionary as an element and I don't want to destroy the exposition element.


---

Comment by @mwageringel created at 2020-05-23 09:22:25


```
sage: from pprint import pprint
sage: pprint(p[0])
[{0: -8, 1: 5, 2: 4, 3: 1},
 Simplicial complex with vertex set (1, 2, 3) and facets {(3,), (1, 2)}]
```



---

Comment by fbissey created at 2020-05-23 09:27:11

Yes, it is probably best here. And while they weren't apparently broken by ipython >= 7.10 there are other instances in that file that probably should be `pprint`-ed.


---

Comment by fbissey created at 2020-05-23 10:28:01

Attaching a WIP branch for people to comment on. I tried to use an appropriate method depending on the context. The branch focuses on the `.rst` files under `src/doc` with the idea that they may present a good sample of issues.
----
New commits:


---

Comment by fbissey created at 2020-06-01 09:46:23

I have not as much time to deal with this as I thought. If someone wants to take over or go back to arojas' branch, it is fine by me.


---

Comment by arojas created at 2020-06-01 09:59:56

I am maintaining the patch downstream anyway, so I can push it here for other packagers  to use it until someone makes a decision on this (I'm not planning to work on implementing a different solution myself)


---

Comment by arojas created at 2020-06-01 10:03:28

Also, I don't see the need to give a final solution to this *now*. We could just merge my patch to unblock the ipython upgrade, and keep this open to implement a different solution when someone has time/willingness to work on it.

EDIT: Actually, I forgot about 32-bit, so it seems the patch can't be merged as-is anyway


---

Comment by fbissey created at 2020-06-01 10:50:22

Darn 32-bit. I otherwise agree with you. We can make this better at a later stage.


---

Comment by dimpase created at 2020-06-01 11:28:06

I don't quite understand what this ticket is about:
` This will break the affected doctests (but not functionality) on python2`

9.2 has nothing to do with python2. We can break it, why not?


---

Comment by arojas created at 2020-06-01 11:31:19

Replying to [comment:45 dimpase]:
> I don't quite understand what this ticket is about:
> ` This will break the affected doctests (but not functionality) on python2`
> 
> 9.2 has nothing to do with python2. We can break it, why not?

This was opened in January


---

Comment by dimpase created at 2020-06-01 11:50:09

is anything needed here for py3 ?


---

Comment by arojas created at 2020-06-01 11:52:07

Yes - this is meant to fix the breakage that will happen in tests when upgrading ipython. "This will break the affected doctests (but not functionality) on python2" refers to the proposed patch at the time.


---

Comment by dimpase created at 2020-06-01 11:56:40

Could someone knowledgeable about the ticket please amend its description?


---

Comment by @kliem created at 2020-06-05 09:03:29

Maybe removing the sorting of dictionaries isn't necessary. We can just overwrite the pretty print function during testing:


```diff
+++ b/src/sage/doctest/forker.py
@@ -61,6 +61,7 @@ from .parsing import SageOutputChecker, pre_hash, get_source
 from sage.repl.user_globals import set_globals
 from sage.cpython.atexit import restore_atexit
 from sage.cpython.string import bytes_to_str, str_to_bytes
+import IPython.lib.pretty
 
 
 # All doctests run as if the following future imports are present
@@ -86,6 +87,27 @@ _OSError_SUBCLASSES = [
        exc is not OSError
 ]
 
+def _sorted_dict_pprinter_factory(start, end):
+    """
+    Factory that returns a pprint function used by the default pprint of
+    dicts and dict proxies.
+    """
+    def inner(obj, p, cycle):
+        if cycle:
+            return p.text('{...}')
+        step = len(start)
+        p.begin_group(step, start)
+        keys = obj.keys()
+        keys = IPython.lib.pretty._sorted_for_pprint(keys)
+        for idx, key in p._enumerate(keys):
+            if idx:
+                p.text(',')
+                p.breakable()
+            p.pretty(key)
+            p.text(': ')
+            p.pretty(obj[key])
+        p.end_group(step, end)
+    return inner
 
 
 def init_sage():
@@ -185,11 +207,11 @@ def init_sage():
     # IPython's pretty printer sorts the repr of dicts by their keys by default
     # (or their keys' str() if they are not otherwise orderable).  However, it
     # disables this for CPython 3.6+ opting to instead display dicts' "natural"
-    # insertion order, which is preserved in those versions).  This makes for
-    # inconsistent results with Python 2 tests that return dicts, so here we
-    # force the Python 2 style dict printing
-    import IPython.lib.pretty
-    IPython.lib.pretty.DICT_IS_ORDERED = False
+    # insertion order, which is preserved in those versions).
+    # However, this order is random in some instances.
+    # Also code changes may change the order, but the result stays correct.
+    # So we force sorting the dictionary.
+    IPython.lib.pretty.for_type(dict, _sorted_dict_pprinter_factory('{', '}'))
 
     # Switch on extra debugging
     from sage.structure.debug_options import debug
```


This appears to do the job. I'm testing the entire library now.


---

Comment by @kliem created at 2020-06-05 10:48:53

`sage -t --long --all` passes for me with this branch.
----
New commits:


---

Comment by @kliem created at 2020-06-05 10:48:53

Changing status from new to needs_review.


---

Comment by fbissey created at 2020-06-05 11:05:27

I can do some testing tomorrow. It looks so much simpler.


---

Comment by @kliem created at 2020-06-05 12:38:47

I was suprised how easy this actually is. Took me a number of hours to figure out though.


---

Comment by dimpase created at 2020-06-05 12:45:12

Does this need new iPython?


---

Comment by @kliem created at 2020-06-05 12:54:13

No, I didn't upgrade and it worked for me.

The function `_sorted_for_pprint` that it uses requires iPython at least 5:

https://github.com/ipython/ipython/blob/5.x/IPython/lib/pretty.py

If that is a problem or if this is ever removed, we can just copy paste this tiny function.

The function `for_type` has been in their since IPython version 1. So I hope that it is somewhat stable.


---

Comment by fbissey created at 2020-06-06 03:27:47

Works for me. That's one of the things I would like to see merged soon.


---

Comment by fbissey created at 2020-06-06 03:27:47

Changing status from needs_review to positive_review.


---

Comment by @kliem created at 2020-06-06 07:42:00

Thank you.


---

Comment by dimpase created at 2020-06-06 09:30:04

Changing priority from major to critical.


---

Comment by dimpase created at 2020-06-06 09:30:04

hopefully it simplifies the thankless task of allowing multiple versions of pari/gp, etc.


---

Comment by vbraun created at 2020-06-21 22:37:31

Resolution: fixed
