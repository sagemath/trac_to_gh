# Issue 28444: Construction of (A#A)+(A#A) fails for CombinatorialFreeModules

Issue created by migration from https://trac.sagemath.org/ticket/28681

Original creator: cnassau

Original creation time: 2019-10-31 06:48:58

The following happened with [SageMath](SageMath) 9.0.beta3 / Python 3

```
sage: F=CombinatorialFreeModule(ZZ,ZZ)
sage: FF=tensor((F,F))
sage: cartesian_product([FF,FF])
KeyError                                  Traceback (most recent call last)
...
TypeError: <class 'sage.sets.family.TrivialFamily_with_category'> is not hashable and does not implement _cache_key()
```



---

Comment by @mwageringel created at 2019-10-31 10:48:01

This works with Python 2.

```
sage: cartesian_product([FF,FF])
Free module generated by Integer Ring over Integer Ring # Free module generated by Integer Ring over Integer Ring (+) Free module generated by Integer Ring over Integer Ring # Free module generated by Integer Ring over Integer Ring
```



---

Comment by @mwageringel created at 2019-10-31 11:58:14

See also #26731 which fails with a similar error, even in Python 2.


---

Comment by cnassau created at 2019-11-01 16:02:09

The following reveals a relevant difference. This is with Python 2:

```
sage: F=CombinatorialFreeModule(ZZ,ZZ)
sage: FF=tensor((F,F))
sage: I=FF.basis().keys()
sage: type(I)
<class 'sage.combinat.combinat.MapCombinatorialClass'>
sage: I.__hash__
<method-wrapper '__hash__' of MapCombinatorialClass object at 0x7f58b5a22338>
```

With Python 3 the `I.__hash__` is None.

This appears to be explained here: https://stackoverflow.com/questions/53518981/inheritance-hash-sets-to-none-in-a-subclass


---

Comment by cnassau created at 2019-11-01 23:00:24

As explained in "the docs" (and found here https://stackoverflow.com/questions/53518981/inheritance-hash-sets-to-none-in-a-subclass ), a class that defines __eq__ or other comparison functions does no longer inherit the __hash__ from its base classes. In python2 the (long deprecated) CombinatorialClass inherited its hash from CategoryObject (where it is computed from the string representation).

My patch adds an explicit __hash__ for CombinatorialClass objects, also based on the string representation. This seems to fix the issue.


---

Comment by cnassau created at 2019-11-01 23:01:11

Changing status from new to needs_review.


---

Comment by cnassau created at 2019-11-01 23:12:06

New commits:


---

Comment by @mwageringel created at 2019-11-03 20:26:19

Ok, this seems to work and with Python 2 the hashes seem to be the same as before. The implementation of `__eq__` calls `repr()` instead of `str()` though, so ideally the same should be done in the hash function. Moreover, I think it would be good to mention the number of this ticket and add a doctest about the initial problem with cartesian products.


---

Comment by cnassau created at 2019-11-03 21:20:10

New commits:


---

Comment by cnassau created at 2019-11-03 21:21:56

Replying to [comment:9 gh-mwageringel]:
> Ok, this seems to work and with Python 2 the hashes seem to be the same as before. The implementation of `__eq__` calls `repr()` instead of `str()` though, so ideally the same should be done in the hash function. Moreover, I think it would be good to mention the number of this ticket and add a doctest about the initial problem with cartesian products.

Thanks for looking into this!  I have now added a test for the original failure in `free_modules.py` and also changed the definition of `__hash__` to use `repr` rather than `str`.


---

Comment by @mwageringel created at 2019-11-04 08:00:18

Changing status from needs_review to positive_review.


---

Comment by @mwageringel created at 2019-11-04 08:00:18

Thank you. This looks good to me now.


---

Comment by vbraun created at 2019-11-07 23:29:57

Resolution: fixed
