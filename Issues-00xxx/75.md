# Issue 75: specify charpoly polynomial ring

archive/issues_000075.json:
```json
{
    "body": "Joe Wetherell's idea:\n\nOn Fri, 22 Sep 2006 00:51:17 -0700, Joseph L Wetherell <jlwether`@`alum.mit.edu> wrote:\n\n>> I really want to agree with you, but I also want to know: what do we\n>> do in the situations I outlined before? For example, if you do\n\n{{{\n>>\n>> sage: M = Matrix(QQ, 2, 2, range(4))\n>> sage: f = M.charpoly()\n>> sage: g = M.charpoly()\n\n}}}\n>> Now f and g have different parents, but you *can't* coerce g to the\n>> parent of f (or vice versa), because you can't assume the generators\n>> match up.\n\n>\n> OK, so perhaps the problem is that charpoly needs another argument\n> -- namely the variable in which the characteristic polynomial\n> is to be expressed.\n\n\nThat's a great idea.  Having an optional\n\n```\n   f = M.charpoly(x)\n```\nand/or\n\n```\n   f = M.charpoly(PolynomialRing(ZZ))\n```\nwouldn't break anything (it's optional), and would be easy \nto implement, and really just makes sense.  I like it. \n\nAssignee: somebody\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/75\n\n",
    "closed_at": "2007-12-01T17:40:11Z",
    "created_at": "2006-09-22T13:04:13Z",
    "labels": [
        "component: basic arithmetic",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-2.8.15",
    "title": "specify charpoly polynomial ring",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/75",
    "user": "https://github.com/williamstein"
}
```
Joe Wetherell's idea:

On Fri, 22 Sep 2006 00:51:17 -0700, Joseph L Wetherell <jlwether`@`alum.mit.edu> wrote:

>> I really want to agree with you, but I also want to know: what do we
>> do in the situations I outlined before? For example, if you do

{{{
>>
>> sage: M = Matrix(QQ, 2, 2, range(4))
>> sage: f = M.charpoly()
>> sage: g = M.charpoly()

}}}
>> Now f and g have different parents, but you *can't* coerce g to the
>> parent of f (or vice versa), because you can't assume the generators
>> match up.

>
> OK, so perhaps the problem is that charpoly needs another argument
> -- namely the variable in which the characteristic polynomial
> is to be expressed.


That's a great idea.  Having an optional

```
   f = M.charpoly(x)
```
and/or

```
   f = M.charpoly(PolynomialRing(ZZ))
```
wouldn't break anything (it's optional), and would be easy 
to implement, and really just makes sense.  I like it. 

Assignee: somebody

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/75





---

archive/issue_comments_000403.json:
```json
{
    "body": "<a id='comment:1'></a>\n```\n> I like this idea. What you're really saying is: evaluate charpoly on\n> some ring element that I hand you. If that ring element is the\n> generator of some polynomial ring, then the charpoly code should be\n> smart enough to work in that ring from the beginning. You can\n> actually do something like this already, with pretty neat notation,\n> at the loss of some efficiency:\n>\n> sage: M = Matrix(QQ, 2, 2, range(4))\n> sage: f = M.charpoly()\n> sage: f\n>   x^2 - 3*x - 2\n> sage: R.<y> = PolynomialRing(QQ)\n> sage: f.parent() is R\n> False\n> sage: f(y)\n>   y^2 - 3*y - 2\n> sage: f(y).parent() is R\n> True\n>\n> Actually the efficiency loss maybe isn't too bad, if the __call__\n> method is smart enough to recognise when it's passed the ring\n> generator, it can just copy the coefficients (faster than computing\n> charpoly!! at least for large degree).\n\nIn fact, we could make\n    M.charpoly(z)\nwork for any z in any ring at all.\n\n> But you're right, it would be good if you could supply the variable\n> directly. Should we put this on trac?\n\n```",
    "created_at": "2006-09-22T13:22:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/75",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/75#issuecomment-403",
    "user": "https://github.com/williamstein"
}
```

<a id='comment:1'></a>
```
> I like this idea. What you're really saying is: evaluate charpoly on
> some ring element that I hand you. If that ring element is the
> generator of some polynomial ring, then the charpoly code should be
> smart enough to work in that ring from the beginning. You can
> actually do something like this already, with pretty neat notation,
> at the loss of some efficiency:
>
> sage: M = Matrix(QQ, 2, 2, range(4))
> sage: f = M.charpoly()
> sage: f
>   x^2 - 3*x - 2
> sage: R.<y> = PolynomialRing(QQ)
> sage: f.parent() is R
> False
> sage: f(y)
>   y^2 - 3*y - 2
> sage: f(y).parent() is R
> True
>
> Actually the efficiency loss maybe isn't too bad, if the __call__
> method is smart enough to recognise when it's passed the ring
> generator, it can just copy the coefficients (faster than computing
> charpoly!! at least for large degree).

In fact, we could make
    M.charpoly(z)
work for any z in any ring at all.

> But you're right, it would be good if you could supply the variable
> directly. Should we put this on trac?

```



---

archive/issue_comments_000404.json:
```json
{
    "body": "<a id='comment:2'></a>\n```\nSay I'm doing some calculations in a power series ring with default\nprecision = N. Then I call some subroutine that happens to do some\npower series ring calculations too. It's possible that the subroutine\nwill change the precision for its own purposes. When it returns, my\nprecision has mysteriously changed to M. This can lead to all kinds\nof subtle bugs. Basically it would mean that if you use the\nglobalised ring, then you don't have any assurances that its\nprecision won't change from one step to the next. Unless you mean to\nstore a separate ring for each possible precision? Or maybe you mean\nto force the precision to remain constant for the globalised ring?\n \nGlobalized rings should be immutable, so all defining properties such\nas default precision, variable print name, etc., should be fixed.\nSAGE currently doesn't have any mutability stuff for rings yet, but it\nshould, exactly for this reason.\n }}}\n\n\nDefault precision shouldn't be changeable anyways, though. (It is, but\nit shouldn't be.)\nIt would suck if you call a function and suddenly the default precision\nof your ring gets changed.\n \nWilliam",
    "created_at": "2006-09-22T14:16:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/75",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/75#issuecomment-404",
    "user": "https://github.com/williamstein"
}
```

<a id='comment:2'></a>
```
Say I'm doing some calculations in a power series ring with default
precision = N. Then I call some subroutine that happens to do some
power series ring calculations too. It's possible that the subroutine
will change the precision for its own purposes. When it returns, my
precision has mysteriously changed to M. This can lead to all kinds
of subtle bugs. Basically it would mean that if you use the
globalised ring, then you don't have any assurances that its
precision won't change from one step to the next. Unless you mean to
store a separate ring for each possible precision? Or maybe you mean
to force the precision to remain constant for the globalised ring?
 
Globalized rings should be immutable, so all defining properties such
as default precision, variable print name, etc., should be fixed.
SAGE currently doesn't have any mutability stuff for rings yet, but it
should, exactly for this reason.
 }}}


Default precision shouldn't be changeable anyways, though. (It is, but
it shouldn't be.)
It would suck if you call a function and suddenly the default precision
of your ring gets changed.
 
William



---

archive/issue_comments_000405.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2007-12-01T17:40:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/75",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/75#issuecomment-405",
    "user": "https://github.com/williamstein"
}
```

Resolution: fixed



---

archive/issue_events_000163.json:
```json
{
    "actor": "https://github.com/williamstein",
    "created_at": "2007-12-01T17:40:11Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/75",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/75#event-163"
}
```



---

archive/issue_events_000164.json:
```json
{
    "actor": "https://github.com/williamstein",
    "created_at": "2007-12-01T17:40:18Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/75",
    "milestone": "sage-2.8.15",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/75#event-164"
}
```



---

archive/issue_comments_000406.json:
```json
{
    "body": "<a id='comment:6'></a>In current Sage, you can already set the name of the variable (although not the ring).  Also, the problem in the original description (\"f and g have different parents\") is no longer true; in current Sage, f and g have the same parent.\n\nSo we're closing this ticket.",
    "created_at": "2007-12-01T17:43:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/75",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/75#issuecomment-406",
    "user": "https://trac.sagemath.org/admin/accounts/users/cwitty"
}
```

<a id='comment:6'></a>In current Sage, you can already set the name of the variable (although not the ring).  Also, the problem in the original description ("f and g have different parents") is no longer true; in current Sage, f and g have the same parent.

So we're closing this ticket.
