# Issue 172: memory leak in pyrex

archive/issues_000172.json:
```json
{
    "body": "\n```\nOn Thu, 30 Nov 2006 08:49:48 -0800, Igor Khavkine <igor.kh@gmail.com> wrote:\n\n> I've recently run into the following bug in Pyrex's code generation.\n> Consider the following .pyx file:\n>\n> ---- bug.pyx ----\n> cdef class T:\n>     cdef int i\n>     cdef int j\n>     cdef int a[1]\n> \n> cdef void leak (void *obj):\n>     cdef T t\n>     (<T> obj).j = 1\n>     (<T> obj).i = (<T> obj).i + 1\n>     (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF\n>     t = <T> obj\n>     t.a[0] = t.a[0] + 1\n> -----------------\n>\n> The C code generated by Pyrex 0.9.3 lacks a Py_DECREF at the place of\n> the indicated line. Thus, every time the function leak() is run, the\n> object pointed to by obj gets an extra reference count. All the other\n> lines in leak() produce correct code.\n>\n> Funny enough, the only way I noticed this bug when the reference counter\n> on one of my objects overflowed and became negative, which caused some\n> mysterious deallocations to take place when the garbage collector was\n> invoked.\n>\n> This bug sounds similar in spirit to the one reported by Jonathan Doda,\n> which is marked fixed in the 0.9.4 release notes. However, I have not\n> tested with that version and am not sure whether that fix also applies\n> to this bug.\n\nI just tested your example with what I think is the latest version\nof Pyrex with all patches I know of applied, and the bug is definitely\nstill there.  You can actually try it all out interactively on this web\npage:   http://modular.math.washington.edu:8101/leak\n\nWilliam\n```\n\n\n == leak ==\n\n\n\n```\n%pyrex\n\ncdef extern from \"Python.h\":\n   void Py_DECREF(PyObject* o)\n\ncdef class T:\n    cdef int i\n    cdef int j\n    cdef int a[10000]\n \ncdef void leak (void *obj, int decref):\n    cdef T t\n    (<T> obj).j = 1\n    (<T> obj).i = (<T> obj).i + 1\n    (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF\n    if decref:\n        Py_DECREF(<PyObject*>obj)\n    t = <T> obj\n    t.a[0] = t.a[0] + 1\n\ndef test(int n, int decref):\n    cdef int i\n    cdef T t\n    for i from 0 <= i < n:\n       t = T()\n       leak(<void*> t, decref)\n```\n\n```\nget_memory_usage()\n///\n355.19921875\n```\n\n```\ntest(1000,0)\n```\n\n```\nget_memory_usage()\n///\n393.40625\n```\n\n```\ntest(1000,1)\n```\n\n```\nget_memory_usage()\n///\n393.40625\n```\n\n```\n\n```\n\nAssignee: @williamstein\n\nResolution: invalid\n\nIssue created by migration from https://trac.sagemath.org/ticket/172\n\n",
    "closed_at": "2008-08-24T17:07:46Z",
    "created_at": "2006-11-30T17:12:59Z",
    "labels": [
        "component: packages: standard",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "memory leak in pyrex",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/172",
    "user": "https://github.com/williamstein"
}
```

```
On Thu, 30 Nov 2006 08:49:48 -0800, Igor Khavkine <igor.kh@gmail.com> wrote:

> I've recently run into the following bug in Pyrex's code generation.
> Consider the following .pyx file:
>
> ---- bug.pyx ----
> cdef class T:
>     cdef int i
>     cdef int j
>     cdef int a[1]
> 
> cdef void leak (void *obj):
>     cdef T t
>     (<T> obj).j = 1
>     (<T> obj).i = (<T> obj).i + 1
>     (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
>     t = <T> obj
>     t.a[0] = t.a[0] + 1
> -----------------
>
> The C code generated by Pyrex 0.9.3 lacks a Py_DECREF at the place of
> the indicated line. Thus, every time the function leak() is run, the
> object pointed to by obj gets an extra reference count. All the other
> lines in leak() produce correct code.
>
> Funny enough, the only way I noticed this bug when the reference counter
> on one of my objects overflowed and became negative, which caused some
> mysterious deallocations to take place when the garbage collector was
> invoked.
>
> This bug sounds similar in spirit to the one reported by Jonathan Doda,
> which is marked fixed in the 0.9.4 release notes. However, I have not
> tested with that version and am not sure whether that fix also applies
> to this bug.

I just tested your example with what I think is the latest version
of Pyrex with all patches I know of applied, and the bug is definitely
still there.  You can actually try it all out interactively on this web
page:   http://modular.math.washington.edu:8101/leak

William
```


 == leak ==



```
%pyrex

cdef extern from "Python.h":
   void Py_DECREF(PyObject* o)

cdef class T:
    cdef int i
    cdef int j
    cdef int a[10000]
 
cdef void leak (void *obj, int decref):
    cdef T t
    (<T> obj).j = 1
    (<T> obj).i = (<T> obj).i + 1
    (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
    if decref:
        Py_DECREF(<PyObject*>obj)
    t = <T> obj
    t.a[0] = t.a[0] + 1

def test(int n, int decref):
    cdef int i
    cdef T t
    for i from 0 <= i < n:
       t = T()
       leak(<void*> t, decref)
```

```
get_memory_usage()
///
355.19921875
```

```
test(1000,0)
```

```
get_memory_usage()
///
393.40625
```

```
test(1000,1)
```

```
get_memory_usage()
///
393.40625
```

```

```

Assignee: @williamstein

Resolution: invalid

Issue created by migration from https://trac.sagemath.org/ticket/172





---

archive/issue_comments_000858.json:
```json
{
    "body": "<a id='comment:1'></a>\n```\nGreg Ewing does not consider this a bug.  I still do.\n\nIgor Khavkine wrote:\n \n> cdef void leak (void *obj):\n> \tcdef T t\n> \t(<T> obj).j = 1\n> \t(<T> obj).i = (<T> obj).i + 1\n> \t(<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF\n> \tt = <T> obj\n> \tt.a[0] = t.a[0] + 1\n \nIs there any reason you couldn't write this as\n \n   cdef void leak (T obj):\n     obj.j = 1\n     obj.i = obj.i + 1\n     obj.a[0] = obj.a[0] + 1\n \nThe reference counting behaviour of typecasts involving\nobject references is not well defined, and you do it at\nyour own risk. It's much better to declare things as\nhaving the appropriate type wherever possible.\n \nIf you really must use a typecast, it's safest to just\ndo one of them and put the result into an appropriately\ntyped local as soon as possible, e.g.\n \n   cdef void leak (void *obj):\n     cdef T t\n     t = <T>obj\n     t.j = 1\n     t.i = t.i + 1\n     t.a[0] = t.a[0] + 1\n \n--\nGreg\n \n```",
    "created_at": "2006-12-01T00:33:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/172#issuecomment-858",
    "user": "https://github.com/williamstein"
}
```

<a id='comment:1'></a>
```
Greg Ewing does not consider this a bug.  I still do.

Igor Khavkine wrote:
 
> cdef void leak (void *obj):
> 	cdef T t
> 	(<T> obj).j = 1
> 	(<T> obj).i = (<T> obj).i + 1
> 	(<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
> 	t = <T> obj
> 	t.a[0] = t.a[0] + 1
 
Is there any reason you couldn't write this as
 
   cdef void leak (T obj):
     obj.j = 1
     obj.i = obj.i + 1
     obj.a[0] = obj.a[0] + 1
 
The reference counting behaviour of typecasts involving
object references is not well defined, and you do it at
your own risk. It's much better to declare things as
having the appropriate type wherever possible.
 
If you really must use a typecast, it's safest to just
do one of them and put the result into an appropriately
typed local as soon as possible, e.g.
 
   cdef void leak (void *obj):
     cdef T t
     t = <T>obj
     t.j = 1
     t.i = t.i + 1
     t.a[0] = t.a[0] + 1
 
--
Greg
 
```



---

archive/issue_comments_000859.json:
```json
{
    "body": "<a id='comment:2'></a>\n```\nOn 11/30/06, Greg Ewing <greg.ewing@canterbury.ac.nz> wrote:\n> Igor Khavkine wrote:\n>  \n> > cdef void leak (void *obj):\n> >       cdef T t\n> >       (<T> obj).j = 1\n> >       (<T> obj).i = (<T> obj).i + 1\n> >       (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF\n> >       t = <T> obj\n> >       t.a[0] = t.a[0] + 1\n>  \n> Is there any reason you couldn't write this as\n>  \n>    cdef void leak (T obj):\n>      obj.j = 1\n>      obj.i = obj.i + 1\n>      obj.a[0] = obj.a[0] + 1\n \nThe only reason (albeit not an insurmountable one) is that leak()\nwould be called from C code and have its argument as an opaque object\nhandle (void *).\n \n> If you really must use a typecast, it's safest to just\n> do one of them and put the result into an appropriately\n> typed local as soon as possible, e.g.\n>  \n>    cdef void leak (void *obj):\n>      cdef T t\n>      t = <T>obj\n>      t.j = 1\n>      t.i = t.i + 1\n>      t.a[0] = t.a[0] + 1\n \nThat's the solution that I've already adopted. And I've already\nchecked that the code generated from the last two lines of my example\nis correct.\n \n> The reference counting behaviour of typecasts involving\n> object references is not well defined, and you do it at\n> your own risk.\n \nThat's somewhat misleading. Each line in my example, except the\nindicated one, produces correct code. I think anyone, who's seen that\nthe first two assignments in leak() work properly, would expect the\nthird one to work as well. That's why it's a bug.\n \nIgor\n```",
    "created_at": "2006-12-01T01:12:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/172#issuecomment-859",
    "user": "https://github.com/williamstein"
}
```

<a id='comment:2'></a>
```
On 11/30/06, Greg Ewing <greg.ewing@canterbury.ac.nz> wrote:
> Igor Khavkine wrote:
>  
> > cdef void leak (void *obj):
> >       cdef T t
> >       (<T> obj).j = 1
> >       (<T> obj).i = (<T> obj).i + 1
> >       (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
> >       t = <T> obj
> >       t.a[0] = t.a[0] + 1
>  
> Is there any reason you couldn't write this as
>  
>    cdef void leak (T obj):
>      obj.j = 1
>      obj.i = obj.i + 1
>      obj.a[0] = obj.a[0] + 1
 
The only reason (albeit not an insurmountable one) is that leak()
would be called from C code and have its argument as an opaque object
handle (void *).
 
> If you really must use a typecast, it's safest to just
> do one of them and put the result into an appropriately
> typed local as soon as possible, e.g.
>  
>    cdef void leak (void *obj):
>      cdef T t
>      t = <T>obj
>      t.j = 1
>      t.i = t.i + 1
>      t.a[0] = t.a[0] + 1
 
That's the solution that I've already adopted. And I've already
checked that the code generated from the last two lines of my example
is correct.
 
> The reference counting behaviour of typecasts involving
> object references is not well defined, and you do it at
> your own risk.
 
That's somewhat misleading. Each line in my example, except the
indicated one, produces correct code. I think anyone, who's seen that
the first two assignments in leak() work properly, would expect the
third one to work as well. That's why it's a bug.
 
Igor
```



---

archive/issue_comments_000860.json:
```json
{
    "body": "Changing type from defect to enhancement.",
    "created_at": "2007-01-13T02:38:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/172#issuecomment-860",
    "user": "https://github.com/williamstein"
}
```

Changing type from defect to enhancement.



---

archive/issue_comments_000861.json:
```json
{
    "body": "<a id='comment:3'></a>This is pretty weird and subtle...  Change to enhancement...",
    "created_at": "2007-01-13T02:38:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/172#issuecomment-861",
    "user": "https://github.com/williamstein"
}
```

<a id='comment:3'></a>This is pretty weird and subtle...  Change to enhancement...



---

archive/issue_events_000317.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/mabshoff",
    "created_at": "2007-09-11T02:15:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "milestone": "sage-wishlist",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/172#event-317"
}
```



---

archive/issue_comments_000862.json:
```json
{
    "body": "<a id='comment:5'></a>This is fixed by Cython:\n\n```\nsage: get_memory_usage()\n664.1328125\nsage: test(1000,0)\nsage: get_memory_usage()\n664.1328125\n```\nI'm voting for **invalid**.",
    "created_at": "2008-08-23T23:16:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/172#issuecomment-862",
    "user": "https://github.com/malb"
}
```

<a id='comment:5'></a>This is fixed by Cython:

```
sage: get_memory_usage()
664.1328125
sage: test(1000,0)
sage: get_memory_usage()
664.1328125
```
I'm voting for **invalid**.



---

archive/issue_comments_000863.json:
```json
{
    "body": "Resolution: invalid",
    "created_at": "2008-08-24T17:07:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/172#issuecomment-863",
    "user": "https://trac.sagemath.org/admin/accounts/users/mabshoff"
}
```

Resolution: invalid



---

archive/issue_events_000318.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/mabshoff",
    "created_at": "2008-08-24T17:07:46Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/172#event-318"
}
```



---

archive/issue_comments_000864.json:
```json
{
    "body": "<a id='comment:6'></a>Yes, invalid it is.\n\nCheers,\n\nMichael",
    "created_at": "2008-08-24T17:07:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/172#issuecomment-864",
    "user": "https://trac.sagemath.org/admin/accounts/users/mabshoff"
}
```

<a id='comment:6'></a>Yes, invalid it is.

Cheers,

Michael



---

archive/issue_events_000319.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/mabshoff",
    "created_at": "2008-08-24T17:07:46Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "milestone": "sage-wishlist",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/172#event-319"
}
```



---

archive/issue_comments_000865.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -7,17 +7,17 @@\n >\n > ---- bug.pyx ----\n > cdef class T:\n-> \tcdef int i\n-> \tcdef int j\n-> \tcdef int a[1]\n->\n+>     cdef int i\n+>     cdef int j\n+>     cdef int a[1]\n+> \n > cdef void leak (void *obj):\n-> \tcdef T t\n-> \t(<T> obj).j = 1\n-> \t(<T> obj).i = (<T> obj).i + 1\n-> \t(<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF\n-> \tt = <T> obj\n-> \tt.a[0] = t.a[0] + 1\n+>     cdef T t\n+>     (<T> obj).j = 1\n+>     (<T> obj).i = (<T> obj).i + 1\n+>     (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF\n+>     t = <T> obj\n+>     t.a[0] = t.a[0] + 1\n > -----------------\n >\n > The C code generated by Pyrex 0.9.3 lacks a Py_DECREF at the place of\n``````\n",
    "created_at": "2015-09-06T17:33:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/172#issuecomment-865",
    "user": "https://github.com/fchapoton"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -7,17 +7,17 @@
 >
 > ---- bug.pyx ----
 > cdef class T:
-> 	cdef int i
-> 	cdef int j
-> 	cdef int a[1]
->
+>     cdef int i
+>     cdef int j
+>     cdef int a[1]
+> 
 > cdef void leak (void *obj):
-> 	cdef T t
-> 	(<T> obj).j = 1
-> 	(<T> obj).i = (<T> obj).i + 1
-> 	(<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
-> 	t = <T> obj
-> 	t.a[0] = t.a[0] + 1
+>     cdef T t
+>     (<T> obj).j = 1
+>     (<T> obj).i = (<T> obj).i + 1
+>     (<T> obj).a[0] = (<T> obj).a[0] + 1   # <-- Missing Py_DECREF
+>     t = <T> obj
+>     t.a[0] = t.a[0] + 1
 > -----------------
 >
 > The C code generated by Pyrex 0.9.3 lacks a Py_DECREF at the place of
``````




---

archive/issue_comments_000866.json:
```json
{
    "body": "Changing upstream from \"\" to \"N/A\"",
    "created_at": "2015-09-06T17:33:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/172",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/172#issuecomment-866",
    "user": "https://github.com/fchapoton"
}
```

Changing upstream from "" to "N/A"
