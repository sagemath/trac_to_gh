# Issue 853: Add a pslq implementation to Sage

archive/issues_000853.json:
```json
{
    "body": "David Bailey's ARPREC package http://crd.lbl.gov/~dhbailey/mpdist/\nincludes several implementations of PSLQ, written in C++, and is\nlicensed under BSD. However, ARPREC raw multi arithmetic timings\ndon't look too favorable http://pari.math.u-bordeaux.fr/benchs/timings-mpfr.html and one has the same fix-x86 issues as quad-double.\nIt looks like, however, one of the advantages of PSLQ is that it does\nnot require full-precision at many of the intermediate steps. (that's\nwhat this two-level stuff is about in his package--most operations\nare performed with machine-double arithmetic).\n\nZimmermann also has a GPL implementation, based on gmp, which is only 1000 lines long. No idea yet how speeds compare.\n\nhttps://members.loria.fr/PZimmermann/software/pslq-1.1.c\n\nAssignee: @williamstein\n\nCC:  @burcin @robertwb\n\nWork Issues: need advice on interface\n\nReviewer: David Kirkby\n\nAuthor: Paul Zimmermann, Alex Ghitza\n\nStatus: needs_info\n\nIssue created by migration from https://trac.sagemath.org/ticket/853\n\n",
    "created_at": "2007-10-12T00:27:12Z",
    "labels": [
        "component: number theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-wishlist",
    "title": "Add a pslq implementation to Sage",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/853",
    "user": "https://github.com/williamstein"
}
```
David Bailey's ARPREC package http://crd.lbl.gov/~dhbailey/mpdist/
includes several implementations of PSLQ, written in C++, and is
licensed under BSD. However, ARPREC raw multi arithmetic timings
don't look too favorable http://pari.math.u-bordeaux.fr/benchs/timings-mpfr.html and one has the same fix-x86 issues as quad-double.
It looks like, however, one of the advantages of PSLQ is that it does
not require full-precision at many of the intermediate steps. (that's
what this two-level stuff is about in his package--most operations
are performed with machine-double arithmetic).

Zimmermann also has a GPL implementation, based on gmp, which is only 1000 lines long. No idea yet how speeds compare.

https://members.loria.fr/PZimmermann/software/pslq-1.1.c

Assignee: @williamstein

CC:  @burcin @robertwb

Work Issues: need advice on interface

Reviewer: David Kirkby

Author: Paul Zimmermann, Alex Ghitza

Status: needs_info

Issue created by migration from https://trac.sagemath.org/ticket/853





---

archive/issue_comments_005525.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,5 +1,3 @@\n-\n-```\n David Bailey's ARPREC package http://crd.lbl.gov/~dhbailey/mpdist/\n includes several implementations of PSLQ, written in C++, and is\n licensed under BSD. However, ARPREC raw multi arithmatic timings\n@@ -13,4 +11,3 @@\n Zimmermann also has a GPL implementation, based on gmp, which is only\n 1000 lines long. http://www.loria.fr/~zimmerma/free/ No idea yet how\n speeds compare.\n-```\n``````\n",
    "created_at": "2007-10-12T00:27:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5525",
    "user": "https://github.com/williamstein"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,5 +1,3 @@
-
-```
 David Bailey's ARPREC package http://crd.lbl.gov/~dhbailey/mpdist/
 includes several implementations of PSLQ, written in C++, and is
 licensed under BSD. However, ARPREC raw multi arithmatic timings
@@ -13,4 +11,3 @@
 Zimmermann also has a GPL implementation, based on gmp, which is only
 1000 lines long. http://www.loria.fr/~zimmerma/free/ No idea yet how
 speeds compare.
-```
``````




---

archive/issue_comments_005526.json:
```json
{
    "body": "<a id='comment:2'></a>\nDamien Stehle did some comparisons between the PSLQ implementation of Bailey and his FPLLL, and\nFPLLL was much faster. Of course it would be good to have an independent comparison, but it might\nbe that PSLQ does not outperform LLL when searching for linear relations.",
    "created_at": "2007-11-16T23:30:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5526",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:2'></a>
Damien Stehle did some comparisons between the PSLQ implementation of Bailey and his FPLLL, and
FPLLL was much faster. Of course it would be good to have an independent comparison, but it might
be that PSLQ does not outperform LLL when searching for linear relations.



---

archive/issue_comments_005527.json:
```json
{
    "body": "<a id='comment:3'></a>\nTo be precise, Zimmerman's code is at http://www.loria.fr/~zimmerma/free/pslq-1.0.c and is licensed under the GPLv2+.",
    "created_at": "2009-05-07T15:00:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5527",
    "user": "https://github.com/wdjoyner"
}
```

<a id='comment:3'></a>
To be precise, Zimmerman's code is at http://www.loria.fr/~zimmerma/free/pslq-1.0.c and is licensed under the GPLv2+.



---

archive/issue_comments_005528.json:
```json
{
    "body": "<a id='comment:4'></a>\nI've attached the code/paper that was attached to the following email.\n\n```\nagnes.jany@googlemail.com>\nto\twstein@gmail.com\ndate\tMon, Aug 10, 2009 at 2:16 PM\nsubject\tPSLQ implementation\nmailed-by\tgooglemail.com\n\t\nhide details 2:16 PM (1 hour ago)\n\t\n\t\nReply\n\t\n\tFollow up message\nDear Mr Stein,\n\nI'm a mathematics student at the Johannes-Gutenberg University of Mainz, Germany.\nAs a part of my diploma thesis, I have implemented PSLQ to SAGE. You can find\nthe code, a worksheet and a documentation in the attachment of this email. Maybe\nyou can use my work for your project.\n\nYours sincerely,\nAgnes Jany\n```",
    "created_at": "2009-08-10T23:03:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5528",
    "user": "https://github.com/williamstein"
}
```

<a id='comment:4'></a>
I've attached the code/paper that was attached to the following email.

```
agnes.jany@googlemail.com>
to	wstein@gmail.com
date	Mon, Aug 10, 2009 at 2:16 PM
subject	PSLQ implementation
mailed-by	googlemail.com
	
hide details 2:16 PM (1 hour ago)
	
	
Reply
	
	Follow up message
Dear Mr Stein,

I'm a mathematics student at the Johannes-Gutenberg University of Mainz, Germany.
As a part of my diploma thesis, I have implemented PSLQ to SAGE. You can find
the code, a worksheet and a documentation in the attachment of this email. Maybe
you can use my work for your project.

Yours sincerely,
Agnes Jany
```



---

archive/issue_events_002906.json:
```json
{
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "rename": {
        "from": "Add a pslq implementation to Sage",
        "to": "[with patch] Add a pslq implementation to Sage"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/853#event-2906"
}
```



---

archive/issue_comments_005529.json:
```json
{
    "body": "<a id='comment:5'></a>\nAttachment [pslqimplementation.zip](tarball://root/attachments/some-uuid/ticket853/pslqimplementation.zip) by @aghitza created at 2009-11-29 03:01:50\n\nNote that mpmath, which is now a standard Sage package, contains an implementation of pslq:\n\n```\n----------------------------------------------------------------------\n----------------------------------------------------------------------\nsage: import sage.libs.mpmath.all as mpmath\nsage: mpmath.mp.dps = 30\nsage: mpmath.pslq([sqrt(n) for n in range(2, 8+1)])\n[2, 0, 0, 0, 0, 0, -1]\nsage: mpmath.pslq([pi/4, acot(5), acot(239)])\n[1, -4, 1]\n```\n| Sage Version 4.2.1, Release Date: 2009-11-14                       |\n| Type notebook() for the GUI, and license() for information.        |\n\nThe examples are from the mpmath documentation, see http://mpmath.googlecode.com/svn/trunk/doc/build/identification.html\n\nThe first one says that the only integer relation between the square roots of 2,3,...,8 is `2\\sqrt{2}-\\sqrt{8}=0`.  The second is one of the cool formulas expressing pi as a combination of arccotangents.",
    "created_at": "2009-11-29T03:01:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5529",
    "user": "https://github.com/aghitza"
}
```

<a id='comment:5'></a>
Attachment [pslqimplementation.zip](tarball://root/attachments/some-uuid/ticket853/pslqimplementation.zip) by @aghitza created at 2009-11-29 03:01:50

Note that mpmath, which is now a standard Sage package, contains an implementation of pslq:

```
----------------------------------------------------------------------
----------------------------------------------------------------------
sage: import sage.libs.mpmath.all as mpmath
sage: mpmath.mp.dps = 30
sage: mpmath.pslq([sqrt(n) for n in range(2, 8+1)])
[2, 0, 0, 0, 0, 0, -1]
sage: mpmath.pslq([pi/4, acot(5), acot(239)])
[1, -4, 1]
```
| Sage Version 4.2.1, Release Date: 2009-11-14                       |
| Type notebook() for the GUI, and license() for information.        |

The examples are from the mpmath documentation, see http://mpmath.googlecode.com/svn/trunk/doc/build/identification.html

The first one says that the only integer relation between the square roots of 2,3,...,8 is `2\sqrt{2}-\sqrt{8}=0`.  The second is one of the cool formulas expressing pi as a combination of arccotangents.



---

archive/issue_comments_005530.json:
```json
{
    "body": "Changing upstream from \"\" to \"N/A\"",
    "created_at": "2009-11-29T03:01:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5530",
    "user": "https://github.com/aghitza"
}
```

Changing upstream from "" to "N/A"



---

archive/issue_comments_005531.json:
```json
{
    "body": "<a id='comment:6'></a>\nIt would still be worth it to wrap Paul Zimmermann's C implementation, since it's fast.  I tried it together with the mpmath implementation on the real life example given at the top of http://www.cecm.sfu.ca/organics/papers/bailey/paper/html/node6.html\n\nBoth give the right answer (yay!).  According to timeit:\n\nZimmermann's C implementation:\n\n```\n25 loops, best of 3: 13.6 ms per loop\n```\n\nmpmath's implementation:\n\n```\n5 loops, best of 3: 267 ms per loop\n```\n\nSo the C code is 20 times faster in this example.",
    "created_at": "2009-11-29T03:51:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5531",
    "user": "https://github.com/aghitza"
}
```

<a id='comment:6'></a>
It would still be worth it to wrap Paul Zimmermann's C implementation, since it's fast.  I tried it together with the mpmath implementation on the real life example given at the top of http://www.cecm.sfu.ca/organics/papers/bailey/paper/html/node6.html

Both give the right answer (yay!).  According to timeit:

Zimmermann's C implementation:

```
25 loops, best of 3: 13.6 ms per loop
```

mpmath's implementation:

```
5 loops, best of 3: 267 ms per loop
```

So the C code is 20 times faster in this example.



---

archive/issue_comments_005532.json:
```json
{
    "body": "<a id='comment:7'></a>\nThe mpmath implementation should be correct, but it doesn't implement all the stopping criteria, and sometimes the precision, tolerance and iteration settings need fiddling with to give the right result. So even ignoring speed, it would be desirable for Sage to use an implementation that gives good control over all the settings.\n\nThe 20x difference actually sounds a bit high (though not unrealistic). I wonder if the number of iterations is the same for both implementations (it could be quite different depending just on small implementation details). Also, on my computer, PSLQ runs about twice as fast with mpmath+gmpy than mpmath+Sage.\n\nI don't know how the other implementations compare, but I would favor adding e.g. Paul Zimmermann's implementation to Sage. It should be trivial to wrap mpmath.pslq as well, so perhaps it could be provided as an optional algorithm.",
    "created_at": "2009-11-30T16:41:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5532",
    "user": "https://github.com/fredrik-johansson"
}
```

<a id='comment:7'></a>
The mpmath implementation should be correct, but it doesn't implement all the stopping criteria, and sometimes the precision, tolerance and iteration settings need fiddling with to give the right result. So even ignoring speed, it would be desirable for Sage to use an implementation that gives good control over all the settings.

The 20x difference actually sounds a bit high (though not unrealistic). I wonder if the number of iterations is the same for both implementations (it could be quite different depending just on small implementation details). Also, on my computer, PSLQ runs about twice as fast with mpmath+gmpy than mpmath+Sage.

I don't know how the other implementations compare, but I would favor adding e.g. Paul Zimmermann's implementation to Sage. It should be trivial to wrap mpmath.pslq as well, so perhaps it could be provided as an optional algorithm.



---

archive/issue_comments_005533.json:
```json
{
    "body": "Changing author from \"\" to \"Paul Zimmermann, Alex Ghitza\"",
    "created_at": "2010-02-21T12:05:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5533",
    "user": "https://github.com/aghitza"
}
```

Changing author from "" to "Paul Zimmermann, Alex Ghitza"



---

archive/issue_comments_005534.json:
```json
{
    "body": "<a id='comment:9'></a>\nI have created an spkg for Paul Zimmermann's C implementation of PSLQ, see\n\nhttp://sage.math.washington.edu/home/ghitza/pslq-1.0.spkg\n\nI have also started writing an interface for using this from Sage, see the attached patch `trac_853.patch`.  This is obviously not done: for one, there should be way more docstrings and doctests.  However, I would like some feedback on the interface before I put much more work into this.  If somebody has a cleaner way of using PSLQ from Sage, I'm happy to listen and throw away what I've done so far.\n\nI'm about to ask for feedback on sage-devel.",
    "created_at": "2010-02-21T12:05:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5534",
    "user": "https://github.com/aghitza"
}
```

<a id='comment:9'></a>
I have created an spkg for Paul Zimmermann's C implementation of PSLQ, see

http://sage.math.washington.edu/home/ghitza/pslq-1.0.spkg

I have also started writing an interface for using this from Sage, see the attached patch `trac_853.patch`.  This is obviously not done: for one, there should be way more docstrings and doctests.  However, I would like some feedback on the interface before I put much more work into this.  If somebody has a cleaner way of using PSLQ from Sage, I'm happy to listen and throw away what I've done so far.

I'm about to ask for feedback on sage-devel.



---

archive/issue_events_002907.json:
```json
{
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "rename": {
        "from": "[with patch] Add a pslq implementation to Sage",
        "to": "Add a pslq implementation to Sage"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/853#event-2907"
}
```



---

archive/issue_comments_005535.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2010-02-21T12:05:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5535",
    "user": "https://github.com/aghitza"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_events_002908.json:
```json
{
    "actor": "https://github.com/aghitza",
    "created_at": "2010-02-21T12:05:33Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "milestone": "sage-4.3.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/853#event-2908"
}
```



---

archive/issue_comments_005536.json:
```json
{
    "body": "Changing work_issues from \"\" to \"need advice on interface\"",
    "created_at": "2010-02-21T12:05:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5536",
    "user": "https://github.com/aghitza"
}
```

Changing work_issues from "" to "need advice on interface"



---

archive/issue_comments_005537.json:
```json
{
    "body": "Attachment [trac_853.patch](tarball://root/attachments/some-uuid/ticket853/trac_853.patch) by @aghitza created at 2010-02-21 12:06:16\n\napply after installing pslq-1.0.spkg",
    "created_at": "2010-02-21T12:06:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5537",
    "user": "https://github.com/aghitza"
}
```

Attachment [trac_853.patch](tarball://root/attachments/some-uuid/ticket853/trac_853.patch) by @aghitza created at 2010-02-21 12:06:16

apply after installing pslq-1.0.spkg



---

archive/issue_events_002909.json:
```json
{
    "actor": "https://github.com/aghitza",
    "created_at": "2010-02-21T12:21:24Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "milestone": "sage-4.3.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/853#event-2909"
}
```



---

archive/issue_events_002910.json:
```json
{
    "actor": "https://github.com/aghitza",
    "created_at": "2010-02-21T12:21:24Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "milestone": "sage-wishlist",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/853#event-2910"
}
```



---

archive/issue_comments_005538.json:
```json
{
    "body": "<a id='comment:10'></a>\nPS (not LQ): I do think that we should also eventually have `implementation=\"mpmath\"` as an option, if only for verification purposes; but I would prefer not to overload this ticket, since it's already two years old.\n\nPPS: I'll change the milestone back to sage-wishlist until this is ready for review.",
    "created_at": "2010-02-21T12:21:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5538",
    "user": "https://github.com/aghitza"
}
```

<a id='comment:10'></a>
PS (not LQ): I do think that we should also eventually have `implementation="mpmath"` as an option, if only for verification purposes; but I would prefer not to overload this ticket, since it's already two years old.

PPS: I'll change the milestone back to sage-wishlist until this is ready for review.



---

archive/issue_comments_005539.json:
```json
{
    "body": "Changing reviewer from \"\" to \"David Kirkby\"",
    "created_at": "2010-02-21T13:17:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5539",
    "user": "https://trac.sagemath.org/admin/accounts/users/drkirkby"
}
```

Changing reviewer from "" to "David Kirkby"



---

archive/issue_comments_005540.json:
```json
{
    "body": "<a id='comment:11'></a>\nIt's good to see you have tested this on Solaris, though there is a potential Solaris issue:\n\n```\nif [ `uname` = \"Darwin\" -a \"$SAGE64\" = \"yes\" ]; then \n    echo \"64 bit MacIntel\" \n    CFLAGS=\"$CFLAGS -m64 \"; export CFLAGS \nfi\n```\n\nshould, at the very least, be replaced by \n\n```\nif [ \"x`uname`\" = xyes ]; then \n    echo \"Building a 64-bit version of pslq\" \n    CFLAGS=\"$CFLAGS -m64 \"; export CFLAGS \n    LDFLAGS=\"$LDFLAGS -m64 \"; export LDFLAGS \nfi\n```\n\n\nIt is in general safer to put an x in front of the `uname` and then test for whatever we want, with an x in front of that. (This is for maximum portability, using any shell, and is not essential, but I think a good habit to get into). There is no need to quote \"xyes\" as we know it has no spaces in it. \n\nWithout removing the Darwin restriction, it would be impossible to build a 64-bit version on Solaris, OpenSolaris or other system such as HP-UX where both 32-bit and 64-bit executables are supported.\n\nWhether LDFLAGS is necessary or not depends on the package. I've not tried building this 64-bit Solaris. I'll have a look at that later, but I do not think setting LDFLAGS ever appears to do any harm, and is sometimes essential. \n\nActually, better still would be \n\n```\nif [ -z \"$CFLAG64\" ] ; then\n  CFLAG64=-m64\nfi\n\nif [ \"x`uname`\" = xyes ]; then \n    echo \"Building a 64-bit of pslq\" \n    CFLAGS=\"$CFLAGS  $CFLAG64\"\n    LDFLAGS=\"$LDFLAGS $CFLAG64\"\nfi\n\nif [ \"x`$SAGE_LOCAL/bin/testcc.sh`\" = xGNU ] ; then\n  CFLAGS=\"$CFLAGS -Wall -pedantic\"\nfi\n\nexport CFLAGS\nexport LDFLAGS\n\n```\n\nas that would \n* Allow the variable CFLAG64 to be set to whatever compiler flag is necessary to build 64-bit code, which is not -m64 for all compilers. (CFLAG64 has been used in other packages for this purpose, to increase portability). \n* Add the compiler options -Wall and -pedantic if using gcc. \n\nCompiling with the -Wall -pedantic options I get:\n\n```\ndrkirkby@hawk:/tmp/pslq-1.0/src$ gcc -Wall -pedantic -c pslq-1.0.c \npslq-1.0.c: In function \u2018print_column\u2019:\npslq-1.0.c:175: warning: format \u2018%u\u2019 expects type \u2018unsigned int\u2019, but argument 2 has type \u2018long unsigned int\u2019\npslq-1.0.c: In function \u2018print_relation\u2019:\npslq-1.0.c:224: warning: format \u2018%u\u2019 expects type \u2018unsigned int\u2019, but argument 3 has type \u2018long unsigned int\u2019\npslq-1.0.c: In function \u2018print_matrix\u2019:\npslq-1.0.c:240: warning: format \u2018%u\u2019 expects type \u2018unsigned int\u2019, but argument 2 has type \u2018long unsigned int\u2019\npslq-1.0.c: In function \u2018pslq\u2019:\npslq-1.0.c:855: warning: format \u2018%u\u2019 expects type \u2018unsigned int\u2019, but argument 2 has type \u2018long int\u2019\npslq-1.0.c:858: warning: format \u2018%u\u2019 expects type \u2018unsigned int\u2019, but argument 2 has type \u2018long int\u2019\npslq-1.0.c:860: warning: format \u2018%d\u2019 expects type \u2018int\u2019, but argument 2 has type \u2018long int\u2019\npslq-1.0.c:870: warning: format \u2018%u\u2019 expects type \u2018unsigned int\u2019, but argument 2 has type \u2018long int\u2019\npslq-1.0.c:892: warning: format \u2018%u\u2019 expects type \u2018unsigned int\u2019, but argument 2 has type \u2018long int\u2019\npslq-1.0.c: In function \u2018main\u2019:\npslq-1.0.c:972: warning: implicit declaration of function \u2018strcmp\u2019\npslq-1.0.c:1040: warning: format \u2018%u\u2019 expects type \u2018unsigned int\u2019, but argument 2 has type \u2018long unsigned int\u2019\npslq-1.0.c:1044: warning: format \u2018%u\u2019 expects type \u2018unsigned int *\u2019, but argument 2 has type \u2018long unsigned int *\u2019\npslq-1.0.c:1055: warning: format \u2018%u\u2019 expects type \u2018unsigned int\u2019, but argument 2 has type \u2018long unsigned int\u2019\n```\n\nSome of those warnings would lead me to believe a 64-bit build of this would not work as expected. In that case, 'unsigned int' would be 4 bytes, but 'long unsigned int' would be 8 bytes. That could go very pear shaped. \n\nThe function strcmp() is defined in strings.h on Solaris, so I would suggest adding\n\n```\n#include <strings.h>\n```\n\nI can't comment on the maths aspect of it - I'm not a mathematician. \n\nSome of these issues need reporting upstream, some are problems with spkg-install. \n\n\n**I would note that all of the above code snippets I wrote were untested, so would need testing**\n\nDave",
    "created_at": "2010-02-21T13:17:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5540",
    "user": "https://trac.sagemath.org/admin/accounts/users/drkirkby"
}
```

<a id='comment:11'></a>
It's good to see you have tested this on Solaris, though there is a potential Solaris issue:

```
if [ `uname` = "Darwin" -a "$SAGE64" = "yes" ]; then 
    echo "64 bit MacIntel" 
    CFLAGS="$CFLAGS -m64 "; export CFLAGS 
fi
```

should, at the very least, be replaced by 

```
if [ "x`uname`" = xyes ]; then 
    echo "Building a 64-bit version of pslq" 
    CFLAGS="$CFLAGS -m64 "; export CFLAGS 
    LDFLAGS="$LDFLAGS -m64 "; export LDFLAGS 
fi
```


It is in general safer to put an x in front of the `uname` and then test for whatever we want, with an x in front of that. (This is for maximum portability, using any shell, and is not essential, but I think a good habit to get into). There is no need to quote "xyes" as we know it has no spaces in it. 

Without removing the Darwin restriction, it would be impossible to build a 64-bit version on Solaris, OpenSolaris or other system such as HP-UX where both 32-bit and 64-bit executables are supported.

Whether LDFLAGS is necessary or not depends on the package. I've not tried building this 64-bit Solaris. I'll have a look at that later, but I do not think setting LDFLAGS ever appears to do any harm, and is sometimes essential. 

Actually, better still would be 

```
if [ -z "$CFLAG64" ] ; then
  CFLAG64=-m64
fi

if [ "x`uname`" = xyes ]; then 
    echo "Building a 64-bit of pslq" 
    CFLAGS="$CFLAGS  $CFLAG64"
    LDFLAGS="$LDFLAGS $CFLAG64"
fi

if [ "x`$SAGE_LOCAL/bin/testcc.sh`" = xGNU ] ; then
  CFLAGS="$CFLAGS -Wall -pedantic"
fi

export CFLAGS
export LDFLAGS

```

as that would 
* Allow the variable CFLAG64 to be set to whatever compiler flag is necessary to build 64-bit code, which is not -m64 for all compilers. (CFLAG64 has been used in other packages for this purpose, to increase portability). 
* Add the compiler options -Wall and -pedantic if using gcc. 

Compiling with the -Wall -pedantic options I get:

```
drkirkby@hawk:/tmp/pslq-1.0/src$ gcc -Wall -pedantic -c pslq-1.0.c 
pslq-1.0.c: In function ‘print_column’:
pslq-1.0.c:175: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘long unsigned int’
pslq-1.0.c: In function ‘print_relation’:
pslq-1.0.c:224: warning: format ‘%u’ expects type ‘unsigned int’, but argument 3 has type ‘long unsigned int’
pslq-1.0.c: In function ‘print_matrix’:
pslq-1.0.c:240: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘long unsigned int’
pslq-1.0.c: In function ‘pslq’:
pslq-1.0.c:855: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘long int’
pslq-1.0.c:858: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘long int’
pslq-1.0.c:860: warning: format ‘%d’ expects type ‘int’, but argument 2 has type ‘long int’
pslq-1.0.c:870: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘long int’
pslq-1.0.c:892: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘long int’
pslq-1.0.c: In function ‘main’:
pslq-1.0.c:972: warning: implicit declaration of function ‘strcmp’
pslq-1.0.c:1040: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘long unsigned int’
pslq-1.0.c:1044: warning: format ‘%u’ expects type ‘unsigned int *’, but argument 2 has type ‘long unsigned int *’
pslq-1.0.c:1055: warning: format ‘%u’ expects type ‘unsigned int’, but argument 2 has type ‘long unsigned int’
```

Some of those warnings would lead me to believe a 64-bit build of this would not work as expected. In that case, 'unsigned int' would be 4 bytes, but 'long unsigned int' would be 8 bytes. That could go very pear shaped. 

The function strcmp() is defined in strings.h on Solaris, so I would suggest adding

```
#include <strings.h>
```

I can't comment on the maths aspect of it - I'm not a mathematician. 

Some of these issues need reporting upstream, some are problems with spkg-install. 


**I would note that all of the above code snippets I wrote were untested, so would need testing**

Dave



---

archive/issue_comments_005541.json:
```json
{
    "body": "<a id='comment:13'></a>\nI'd like to review that patch (now at SD20 in Marseilles) however I've downloaded sage 4.3.3.alpha1\na few days ago and compiled it on my laptop (Core 2 Duo under Fedora 12), and sage -t * gives\n593 Segfaults (without any patch applied). With this, I don't see how I could seriously review\nthat patch. I hope the final 4.3.3 release is better (now compiling). Is this problem on Fedora 12\nbeing analyzed currently? I can send the complete log from sage -t * with 4.3.3.alpha1 if needed.\n\nPaul",
    "created_at": "2010-02-22T20:31:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5541",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:13'></a>
I'd like to review that patch (now at SD20 in Marseilles) however I've downloaded sage 4.3.3.alpha1
a few days ago and compiled it on my laptop (Core 2 Duo under Fedora 12), and sage -t * gives
593 Segfaults (without any patch applied). With this, I don't see how I could seriously review
that patch. I hope the final 4.3.3 release is better (now compiling). Is this problem on Fedora 12
being analyzed currently? I can send the complete log from sage -t * with 4.3.3.alpha1 if needed.

Paul



---

archive/issue_comments_005542.json:
```json
{
    "body": "<a id='comment:14'></a>\nHi Paul,\n\nI'm in a similar situation, and currently having to build sage-4.3.3 on my laptop since I messed up my 4.3.3.alpha1.  I suggest you send an email to sage-devel about the Fedora 12 issues, with a link to the test log (and maybe also to the build log).\n\nSince you're looking at reviewing this, I will try to finish up the documentation and other things today (most likely tonight...  Australian time).",
    "created_at": "2010-02-22T22:06:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5542",
    "user": "https://github.com/aghitza"
}
```

<a id='comment:14'></a>
Hi Paul,

I'm in a similar situation, and currently having to build sage-4.3.3 on my laptop since I messed up my 4.3.3.alpha1.  I suggest you send an email to sage-devel about the Fedora 12 issues, with a link to the test log (and maybe also to the build log).

Since you're looking at reviewing this, I will try to finish up the documentation and other things today (most likely tonight...  Australian time).



---

archive/issue_comments_005543.json:
```json
{
    "body": "<a id='comment:15'></a>\nI did a comparison of my PSLQ implementation (within Sage) with fpLLL with a knapsack matrix.\nWith Bailey's \"node6\" example, fpLLL is 14 times faster:\n\n```\nsage: m = matrix(9,10)\nsage: for i in range(9):\n    m[i,i]=1\nsage: for i in range(9):\n    m[i,9]=ZZ(num_list[i]*RealField(200)(2)^180)//2^10\n\nsage: L=m.LLL()\nsage: L.row(0)\n(-480, 1920, 0, -16, -255, -660, 840, 160, -360, 219687)\nsage: p.coefficients()\n(480, -1920, 0, 16, 255, 660, -840, -160, 360)\n\nsage: %timeit L=m.LLL()\n625 loops, best of 3: 1.41 ms per loop\n\nsage: %timeit p=PSLQ(num_list, prec=167)\n25 loops, best of 3: 19.8 ms per loop\n```\nThus apart from historical reasons (or comparison with fpLLL) I don't see any point to add PSLQ in Sage. Or the default PSLQ mode should be to call fpLLL. However maybe I'm biased because\nfpLLL was designed by a former student of mine.",
    "created_at": "2010-02-23T17:30:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5543",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:15'></a>
I did a comparison of my PSLQ implementation (within Sage) with fpLLL with a knapsack matrix.
With Bailey's "node6" example, fpLLL is 14 times faster:

```
sage: m = matrix(9,10)
sage: for i in range(9):
    m[i,i]=1
sage: for i in range(9):
    m[i,9]=ZZ(num_list[i]*RealField(200)(2)^180)//2^10

sage: L=m.LLL()
sage: L.row(0)
(-480, 1920, 0, -16, -255, -660, 840, 160, -360, 219687)
sage: p.coefficients()
(480, -1920, 0, 16, 255, 660, -840, -160, 360)

sage: %timeit L=m.LLL()
625 loops, best of 3: 1.41 ms per loop

sage: %timeit p=PSLQ(num_list, prec=167)
25 loops, best of 3: 19.8 ms per loop
```
Thus apart from historical reasons (or comparison with fpLLL) I don't see any point to add PSLQ in Sage. Or the default PSLQ mode should be to call fpLLL. However maybe I'm biased because
fpLLL was designed by a former student of mine.



---

archive/issue_comments_005544.json:
```json
{
    "body": "<a id='comment:16'></a>\n> Or the default PSLQ mode should be to call fpLLL. \n\n\nin fact, it would be cleaner to have a function `linear_relation`, which could have\nalgorithm=LLL (default) or algorithm=PSLQ.",
    "created_at": "2010-02-23T17:33:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5544",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:16'></a>
> Or the default PSLQ mode should be to call fpLLL. 


in fact, it would be cleaner to have a function `linear_relation`, which could have
algorithm=LLL (default) or algorithm=PSLQ.



---

archive/issue_comments_005545.json:
```json
{
    "body": "<a id='comment:17'></a>\nI got some more information about PSLQ by David Bailey, who agreed that I forward it to the Sage\ndevelopers (the references [1] and [2] are those from pslq-1.0.c):\n\n```\nComments:  Reference [1] in your note is the original PSLQ paper, but\nthe algorithm as presented there is quite cumbersome, as it involves\n(needlessly) many full-matrix operations.  Reference [2] stated an\nabbreviated but equivalent version; unfortunately, however, it includes\none bug.  Thus I strongly suggest that you base your implementation on\nthe following paper:\n\nDavid H. Bailey and David J. Broadhurst, \"Parallel Integer Relation\nDetection: Techniques and Applications,\" /Mathematics of Computation/,\nvol. 70, no. 236 (Oct 2000), pg. 1719-1736.  Our preprint copy is\navailable at:\nhttp://crd.lbl.gov/~dhbailey/dhbpapers/ppslq.pdf\n\nThe basic PSLQ algorithm is stated on page 2, and should work well as\nstated (please let me know if you have any problems).  A two-level and a\nthree-level variant are also described, which are faster but quite a bit\nmore complicated.\n\nHowever, if you are really serious, I suggest that you try the\n\"multi-pair\" variant of PSLQ, which is presented in the above paper\nbeginning on page 10.  Although we devised this scheme originally to be\nsuitable for parallel processing, we have found that even on a single\nprocessor system it runs significantly faster, and is significantly more\neffective in recovering relations when the input data is given only to\nlimited precision.  Two- and a three-level variants of the multi-pair\nscheme, in analogy to the two- and three-level versions of the regular\nPSLQ, are also given in the paper.  These are much faster than the basic\nmulti-pair PSLQ scheme, because they perform most operations using\nordinary double-precision arithmetic, updating the multi-precision\narrays only occasionally when needed.\n\nIn my own work, I always use the multi-pair PSLQ.  I use the basic\nmulti-pair PSLQ for n up to 10 or 20 and for modest precision.  For\nlarger n, and, say, 500-digit or more precision, I generally use\ntwo-level multi-pair scheme.  For truly \"heroic\" calculations (e.g., n >\n100 and precision level > 2000 digits), I use the three-level multi-pair\nscheme, since it has advantages for very large calculations and runs\nwell on a parallel system -- see some case studies mentioned in the\nabove paper.\n\nPlease let me know if it works for you.  And if you have any questions,\nI would be pleased to respond.  If you wish, you can look at the\nimplementations of PSLQ and the multi-pair PSLQ schemes (in both C++ and\nFortran-90) that we have bundled with our ARPREC package:\nhttp://crd.lbl.gov/~dhbailey/mpdist\n```\nI will try to modify my code to use the \"basic PSLQ algorithm\" described in the paper\nmentioned above. However in the short term I won't be able to implement the multi-pair\nvariant. Thus if somebody wants to do it, please proceed. Alternatively, one might use\nthe PSLQ variants from ARPREC (if the license is ok).",
    "created_at": "2010-02-24T07:10:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5545",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:17'></a>
I got some more information about PSLQ by David Bailey, who agreed that I forward it to the Sage
developers (the references [1] and [2] are those from pslq-1.0.c):

```
Comments:  Reference [1] in your note is the original PSLQ paper, but
the algorithm as presented there is quite cumbersome, as it involves
(needlessly) many full-matrix operations.  Reference [2] stated an
abbreviated but equivalent version; unfortunately, however, it includes
one bug.  Thus I strongly suggest that you base your implementation on
the following paper:

David H. Bailey and David J. Broadhurst, "Parallel Integer Relation
Detection: Techniques and Applications," /Mathematics of Computation/,
vol. 70, no. 236 (Oct 2000), pg. 1719-1736.  Our preprint copy is
available at:
http://crd.lbl.gov/~dhbailey/dhbpapers/ppslq.pdf

The basic PSLQ algorithm is stated on page 2, and should work well as
stated (please let me know if you have any problems).  A two-level and a
three-level variant are also described, which are faster but quite a bit
more complicated.

However, if you are really serious, I suggest that you try the
"multi-pair" variant of PSLQ, which is presented in the above paper
beginning on page 10.  Although we devised this scheme originally to be
suitable for parallel processing, we have found that even on a single
processor system it runs significantly faster, and is significantly more
effective in recovering relations when the input data is given only to
limited precision.  Two- and a three-level variants of the multi-pair
scheme, in analogy to the two- and three-level versions of the regular
PSLQ, are also given in the paper.  These are much faster than the basic
multi-pair PSLQ scheme, because they perform most operations using
ordinary double-precision arithmetic, updating the multi-precision
arrays only occasionally when needed.

In my own work, I always use the multi-pair PSLQ.  I use the basic
multi-pair PSLQ for n up to 10 or 20 and for modest precision.  For
larger n, and, say, 500-digit or more precision, I generally use
two-level multi-pair scheme.  For truly "heroic" calculations (e.g., n >
100 and precision level > 2000 digits), I use the three-level multi-pair
scheme, since it has advantages for very large calculations and runs
well on a parallel system -- see some case studies mentioned in the
above paper.

Please let me know if it works for you.  And if you have any questions,
I would be pleased to respond.  If you wish, you can look at the
implementations of PSLQ and the multi-pair PSLQ schemes (in both C++ and
Fortran-90) that we have bundled with our ARPREC package:
http://crd.lbl.gov/~dhbailey/mpdist
```
I will try to modify my code to use the "basic PSLQ algorithm" described in the paper
mentioned above. However in the short term I won't be able to implement the multi-pair
variant. Thus if somebody wants to do it, please proceed. Alternatively, one might use
the PSLQ variants from ARPREC (if the license is ok).



---

archive/issue_comments_005546.json:
```json
{
    "body": "<a id='comment:18'></a>\nJust a note on ARPREC's license, since Paul brought it up: it is not BSD as stated in this ticket's description, rather BSD-LBNL.  However, this is apparently compatible with both GPLv2 and GPLv3, according to the table \"Good licenses\" at\n\nhttp://fedoraproject.org/wiki/Licensing\n\nSo there should be no legal obstacles to using ARPREC.",
    "created_at": "2010-02-24T11:30:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5546",
    "user": "https://github.com/aghitza"
}
```

<a id='comment:18'></a>
Just a note on ARPREC's license, since Paul brought it up: it is not BSD as stated in this ticket's description, rather BSD-LBNL.  However, this is apparently compatible with both GPLv2 and GPLv3, according to the table "Good licenses" at

http://fedoraproject.org/wiki/Licensing

So there should be no legal obstacles to using ARPREC.



---

archive/issue_comments_005547.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,8 +1,7 @@\n David Bailey's ARPREC package http://crd.lbl.gov/~dhbailey/mpdist/\n includes several implementations of PSLQ, written in C++, and is\n-licensed under BSD. However, ARPREC raw multi arithmatic timings\n-don't look too favorable http://pari.math.u-bordeaux.fr/benchs/\n-timings-mpfr.html and one has the same fix-x86 issues as quad-double.\n+licensed under BSD. However, ARPREC raw multi arithmetic timings\n+don't look too favorable http://pari.math.u-bordeaux.fr/benchs/timings-mpfr.html and one has the same fix-x86 issues as quad-double.\n It looks like, however, one of the advantages of PSLQ is that it does\n not require full-precision at many of the intermediate steps. (that's\n what this two-level stuff is about in his package--most operations\n``````\n",
    "created_at": "2011-09-10T05:30:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5547",
    "user": "https://github.com/aghitza"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,8 +1,7 @@
 David Bailey's ARPREC package http://crd.lbl.gov/~dhbailey/mpdist/
 includes several implementations of PSLQ, written in C++, and is
-licensed under BSD. However, ARPREC raw multi arithmatic timings
-don't look too favorable http://pari.math.u-bordeaux.fr/benchs/
-timings-mpfr.html and one has the same fix-x86 issues as quad-double.
+licensed under BSD. However, ARPREC raw multi arithmetic timings
+don't look too favorable http://pari.math.u-bordeaux.fr/benchs/timings-mpfr.html and one has the same fix-x86 issues as quad-double.
 It looks like, however, one of the advantages of PSLQ is that it does
 not require full-precision at many of the intermediate steps. (that's
 what this two-level stuff is about in his package--most operations
``````




---

archive/issue_comments_005548.json:
```json
{
    "body": "<a id='comment:20'></a>\nHi Paul,\n\nHow much work would that be to interface your C code with Sage ? Do you have a proof of concept ?\n\nFlorent",
    "created_at": "2012-06-20T19:03:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5548",
    "user": "https://github.com/hivert"
}
```

<a id='comment:20'></a>
Hi Paul,

How much work would that be to interface your C code with Sage ? Do you have a proof of concept ?

Florent



---

archive/issue_comments_005549.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [hivert](#comment%3A20):\n> How much work would that be to interface your C code with Sage ? Do you have a proof of concept ?\n\n\nno idea. Why do you ask? See comment [comment:2]. I see no reason to interface PSLQ.\n\nPaul",
    "created_at": "2012-06-20T19:58:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5549",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:21'></a>
Replying to [hivert](#comment%3A20):
> How much work would that be to interface your C code with Sage ? Do you have a proof of concept ?


no idea. Why do you ask? See comment [comment:2]. I see no reason to interface PSLQ.

Paul



---

archive/issue_comments_005550.json:
```json
{
    "body": "<a id='comment:22'></a>\nReplying to [zimmerma](#comment%3A21):\n> Replying to [hivert](#comment%3A20):\n> > How much work would that be to interface your C code with Sage ? Do you have a proof of concept ?\n\n> \n> no idea. Why do you ask? See comment [comment:2]. I see no reason to interface PSLQ.\n\n\nI'm at a small workshop and there is someone which is currently using Maple and is considering to switch to Sage.. Maple has both LLL and PSLQ. He told me that, he has some stability problem with LLL, in the sense that removing some precision digits gives drastically different results. Apparently PSLQ doesn't. I've no idea if it's a problem with the algorithms or the implementation.",
    "created_at": "2012-06-20T21:14:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5550",
    "user": "https://github.com/hivert"
}
```

<a id='comment:22'></a>
Replying to [zimmerma](#comment%3A21):
> Replying to [hivert](#comment%3A20):
> > How much work would that be to interface your C code with Sage ? Do you have a proof of concept ?

> 
> no idea. Why do you ask? See comment [comment:2]. I see no reason to interface PSLQ.


I'm at a small workshop and there is someone which is currently using Maple and is considering to switch to Sage.. Maple has both LLL and PSLQ. He told me that, he has some stability problem with LLL, in the sense that removing some precision digits gives drastically different results. Apparently PSLQ doesn't. I've no idea if it's a problem with the algorithms or the implementation.



---

archive/issue_comments_005551.json:
```json
{
    "body": "<a id='comment:23'></a>\nI'm curious seeing an example with some stability problem with LLL.\n\nPaul",
    "created_at": "2012-06-20T21:40:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5551",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:23'></a>
I'm curious seeing an example with some stability problem with LLL.

Paul



---

archive/issue_comments_005552.json:
```json
{
    "body": "<a id='comment:24'></a>\nThis past January, a student of mine and I have run some experiments comparing fpLLL and the PSLQ implementations from ARPREC (we wanted to take the best current implementations to get a realistic comparison).  In the examples we ran, we found almost no reason to use PSLQ instead of fpLLL for finding integer relations.  The only situation where PSLQ might be more appropriate is when it is extremely expensive to generate extra digits in the input floating point numbers.  PSLQ has a slight edge here because it tends to require fewer digits of precision than fpLLL.  Most of the time this is of no consequence because fpLLL is much faster.  We'll try to write something up describing our experiments and results, but I don't know how soon I'll find time for that.\n\nIn terms of \"stability\", our experiments indicate that PSLQ tends to stick with the correct answer once it finds it, as you add more digits of precision.  With fpLLL, you sometimes hit the right answer with, say 190 digits, but then you get different answers for a short while (say, 191 to 197 digits), and then it stabilises on the right answer again.  Paul, I can dig up an explicit example of this if you are interested.  Again, I don't see this as an issue from a practical point of view -- I would run the algorithm until I get the exact same answer with 3 or 5 different precisions.",
    "created_at": "2012-06-21T01:37:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5552",
    "user": "https://github.com/aghitza"
}
```

<a id='comment:24'></a>
This past January, a student of mine and I have run some experiments comparing fpLLL and the PSLQ implementations from ARPREC (we wanted to take the best current implementations to get a realistic comparison).  In the examples we ran, we found almost no reason to use PSLQ instead of fpLLL for finding integer relations.  The only situation where PSLQ might be more appropriate is when it is extremely expensive to generate extra digits in the input floating point numbers.  PSLQ has a slight edge here because it tends to require fewer digits of precision than fpLLL.  Most of the time this is of no consequence because fpLLL is much faster.  We'll try to write something up describing our experiments and results, but I don't know how soon I'll find time for that.

In terms of "stability", our experiments indicate that PSLQ tends to stick with the correct answer once it finds it, as you add more digits of precision.  With fpLLL, you sometimes hit the right answer with, say 190 digits, but then you get different answers for a short while (say, 191 to 197 digits), and then it stabilises on the right answer again.  Paul, I can dig up an explicit example of this if you are interested.  Again, I don't see this as an issue from a practical point of view -- I would run the algorithm until I get the exact same answer with 3 or 5 different precisions.



---

archive/issue_comments_005553.json:
```json
{
    "body": "<a id='comment:25'></a>\nAlex,\n\n> I can dig up an explicit example of this if you are interested.\n\n\nyes please do! Such explicit examples are extremely useful.\n\nPaul",
    "created_at": "2012-06-21T07:30:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5553",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:25'></a>
Alex,

> I can dig up an explicit example of this if you are interested.


yes please do! Such explicit examples are extremely useful.

Paul



---

archive/issue_comments_005554.json:
```json
{
    "body": "<a id='comment:26'></a>\nAny news on this ticket?",
    "created_at": "2014-11-19T17:17:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5554",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:26'></a>
Any news on this ticket?



---

archive/issue_comments_005555.json:
```json
{
    "body": "<a id='comment:27'></a>\n> Any news on this ticket?\n\n\nI don't know what information was missing in comment [comment:9], but the following reference might be useful: http://dl.acm.org/citation.cfm?id=2465936\n\nPaul",
    "created_at": "2014-11-19T18:42:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5555",
    "user": "https://github.com/zimmermann6"
}
```

<a id='comment:27'></a>
> Any news on this ticket?


I don't know what information was missing in comment [comment:9], but the following reference might be useful: http://dl.acm.org/citation.cfm?id=2465936

Paul



---

archive/issue_comments_005556.json:
```json
{
    "body": "<a id='comment:28'></a>\nSee also http://math.stackexchange.com/questions/853339/ which seems quite relevant.\n\nDo we actually *have* one in Sage currently, by the way?  A new user implied we might, just not a very powerful one.",
    "created_at": "2014-12-19T01:52:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5556",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:28'></a>
See also http://math.stackexchange.com/questions/853339/ which seems quite relevant.

Do we actually *have* one in Sage currently, by the way?  A new user implied we might, just not a very powerful one.



---

archive/issue_comments_005557.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -7,6 +7,6 @@\n what this two-level stuff is about in his package--most operations\n are performed with machine-double arithmetic).\n \n-Zimmermann also has a GPL implementation, based on gmp, which is only\n-1000 lines long. http://www.loria.fr/~zimmerma/free/ No idea yet how\n-speeds compare.\n+Zimmermann also has a GPL implementation, based on gmp, which is only 1000 lines long. No idea yet how speeds compare.\n+\n+https://members.loria.fr/PZimmermann/software/pslq-1.1.c\n``````\n",
    "created_at": "2020-05-13T11:11:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/853",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/853#issuecomment-5557",
    "user": "https://github.com/fchapoton"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -7,6 +7,6 @@
 what this two-level stuff is about in his package--most operations
 are performed with machine-double arithmetic).
 
-Zimmermann also has a GPL implementation, based on gmp, which is only
-1000 lines long. http://www.loria.fr/~zimmerma/free/ No idea yet how
-speeds compare.
+Zimmermann also has a GPL implementation, based on gmp, which is only 1000 lines long. No idea yet how speeds compare.
+
+https://members.loria.fr/PZimmermann/software/pslq-1.1.c
``````

