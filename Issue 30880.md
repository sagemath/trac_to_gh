# Issue 30880: Improve Breadth First Search in c_graph.pyx

Issue created by migration from https://trac.sagemath.org/ticket/31117

Original creator: dcoudert

Original creation time: 2020-12-27 17:32:35

CC:  @kliem vdelecroix chaperon dimpase

Currently, method `breadth_first_search` in `c_graph.pyx` implements a queue using a list and removes element at position 0. This is ok on small graphs, but for large graphs, This is really slow.

I'm using the following function to benchmark. When `report_distance` is `False`, it calls the code from `c_graph.pyx`, and when it is `True`,  is uses a Python implementation from `generic_graph.py`.

```sage
def comp(): 
    for n in [5, 10, 50, 100, 500, 1000]: 
        G = graphs.Grid2dGraph(n, n) 
        print(G) 
        %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=False))
        %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=True))
```



Before:

```
sage: comp()                                                                                                                                        
2D Grid Graph for [5, 5]
17.9 µs ± 470 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
72.8 µs ± 6 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
2D Grid Graph for [10, 10]
58.5 µs ± 1.2 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
269 µs ± 13.8 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [50, 50]
1.92 ms ± 165 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
8.12 ms ± 263 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
2D Grid Graph for [100, 100]
9.63 ms ± 232 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
36.2 ms ± 1.43 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
2D Grid Graph for [500, 500]
397 ms ± 18 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
1.12 s ± 27.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
2D Grid Graph for [1000, 1000]
32.3 s ± 1.1 s per loop (mean ± std. dev. of 7 runs, 1 loop each)
5.64 s ± 414 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```



After:

```
sage: comp()                                                                                                                                        
2D Grid Graph for [5, 5]
17.3 µs ± 349 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
66.6 µs ± 1.49 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
2D Grid Graph for [10, 10]
58.5 µs ± 1.43 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
268 µs ± 16 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [50, 50]
1.73 ms ± 31.2 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
8.26 ms ± 245 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
2D Grid Graph for [100, 100]
7.49 ms ± 137 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
34.7 ms ± 1.91 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
2D Grid Graph for [500, 500]
211 ms ± 8.18 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
1.09 s ± 24 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
2D Grid Graph for [1000, 1000]
1.01 s ± 27.1 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
5.27 s ± 206 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```


A possible improvement is to avoid using `in_neighbors` and `out_neighbors` since these methods return lists of vertices and behind we have some mallocs of arrays. So a lot of operations that could be avoided.


---

Comment by dcoudert created at 2020-12-27 17:33:42

Changing status from new to needs_review.


---

Comment by dcoudert created at 2020-12-27 17:33:42

New commits:


---

Comment by git created at 2020-12-27 17:55:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-12-27 17:56:07

This last commit is not very nice, but it's now way faster.


---

Comment by git created at 2020-12-28 01:35:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-12-28 01:38:01

I had to remove last commit because method `next_out_neighbor_unsafe` is not implemented in `static_sparse_backend.pyx`, and I don't know yet how to add such method to this backend.


---

Comment by @kliem created at 2020-12-28 10:32:04

First of all:

I can confirm an enourmous improvement (something like a factor 2 or 3), but I can't reproduce the 32 seconds for your before `2D Grid Graph for [1000, 1000]`. Looks to me like you went into swap or similar.


---

Comment by dcoudert created at 2020-12-28 11:00:58

I tested on a desktop with more memory than my laptop (which has already 16G Ram), and I don't get such huge slowdown anymore. So it's certainly a swap problem.

Actually, the way BFS is implementented in `c_graph`, we start pushing vertices to the queue, and then we say that a vertex is seen if it has already been extracted from the queue. An alternative, which is what is done in `generic_graph` is to say that a vertex is seen if already added to the queue. In the first case, the queue can have up to O(m) vertices, while in the second case, it's at most O(n).
I will try the second option in `c_graph`.


---

Comment by @kliem created at 2020-12-28 11:06:18

A swap problem is certainly also an implementation problem. If we can use less memory with better implementation that is certainly an improvement.


---

Comment by @kliem created at 2020-12-28 11:13:30

`CGraph.out_neighbors` etc are still lists. If you really want it to be fast, you should use `CGraph.next_out_neighbor` etc as:


```diff
diff --git a/src/sage/graphs/base/c_graph.pyx b/src/sage/graphs/base/c_graph.pyx
index 47fe5b2b90..92b16ab283 100644
--- a/src/sage/graphs/base/c_graph.pyx
+++ b/src/sage/graphs/base/c_graph.pyx
@@ -4837,6 +4837,8 @@ cdef class Search_iterator:
         """
         cdef int v_int
         cdef int w_int
+        cdef int l
+        cdef CGraph cg = self.graph.cg()
 
         while not self.fifo.empty():
             v_int = self.fifo.front()
@@ -4847,11 +4849,15 @@ cdef class Search_iterator:
                 bitset_add(self.seen, v_int)
 
                 if self.test_out:
-                    for w_int in self.graph.cg().out_neighbors(v_int):
+                    w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)
+                    while w_int != -1:
                         self.fifo.push(w_int)
+                        w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)
                 if self.test_in:
-                    for w_int in self.in_neighbors(v_int):
+                    w_int = cg.next_in_neighbor_unsafe(v_int, -1, &l)
+                    while w_int != -1:
                         self.fifo.push(w_int)
+                        w_int = cg.next_in_neighbor_unsafe(v_int, w_int, &l)
```



---

Comment by dcoudert created at 2020-12-28 11:18:32

I tried that but it's not compatible with `static_sparse_backend.pyx` (don't have `next_out_neighbor_unsafe`).
An option is to implement a specific BFS for `static_sparse_backend.pyx`.


---

Comment by @kliem created at 2020-12-28 11:24:27

Replying to [comment:11 dcoudert]:
> I tried that but it's not compatible with `static_sparse_backend.pyx` (don't have `next_out_neighbor_unsafe`).
> An option is to implement a specific BFS for `static_sparse_backend.pyx`.

Ok. I'll think about how this can be fixed.


---

Comment by @kliem created at 2020-12-28 11:29:15

I don't see an improvement in factoring out `next_depth...`.

The compiler optimzes things fine for me, if I distinct everywhere with `self.direction == 0` and `self.direction != 0`. Then one can right away change the data type for lifo to https://en.cppreference.com/w/cpp/container/stack
as well.

This is how my overall diff looks to your branch:


```diff
diff --git a/src/sage/graphs/base/c_graph.pyx b/src/sage/graphs/base/c_graph.pyx
index 47fe5b2b90..daf9bc8af5 100644
--- a/src/sage/graphs/base/c_graph.pyx
+++ b/src/sage/graphs/base/c_graph.pyx
@@ -48,6 +48,7 @@ from sage.rings.integer cimport Integer
 from sage.arith.long cimport pyobject_to_long
 from libcpp.queue cimport priority_queue
 from libcpp.queue cimport queue
+from libcpp.stack cimport stack
 from libcpp.pair cimport pair
 from sage.rings.integer_ring import ZZ
 from cysignals.memory cimport check_allocarray, sig_free
@@ -4716,7 +4717,7 @@ cdef class Search_iterator:
 
     cdef CGraphBackend graph
     cdef int direction
-    cdef list stack
+    cdef stack[int] lifo
     cdef queue[int] fifo
     cdef bitset_t seen
     cdef bint test_out
@@ -4794,7 +4795,7 @@ cdef class Search_iterator:
         if direction == 0:
             self.fifo.push(v_id)
         else:
-            self.stack = [v_id]
+            self.lifo.push(v_id)
 
         if not self.graph._directed:
             ignore_direction = False
@@ -4823,7 +4824,7 @@ cdef class Search_iterator:
         """
         return self
 
-    def next_breadth_first_search(self):
+    def __next__(self):
         r"""
         Return the next vertex in a breadth first search traversal of a graph.
 
@@ -4837,53 +4838,38 @@ cdef class Search_iterator:
         """
         cdef int v_int
         cdef int w_int
+        cdef int l
+        cdef CGraph cg = self.graph.cg()
 
-        while not self.fifo.empty():
-            v_int = self.fifo.front()
-            self.fifo.pop()
-
-            if bitset_not_in(self.seen, v_int):
-                value = self.graph.vertex_label(v_int)
-                bitset_add(self.seen, v_int)
-
-                if self.test_out:
-                    for w_int in self.graph.cg().out_neighbors(v_int):
-                        self.fifo.push(w_int)
-                if self.test_in:
-                    for w_int in self.in_neighbors(v_int):
-                        self.fifo.push(w_int)
-
-                break
-        else:
-            raise StopIteration
-
-        return value
-
-    def next_depth_first_search(self):
-        r"""
-        Return the next vertex in a depth first search traversal of a graph.
-
-        EXAMPLES::
-
-            sage: g = graphs.PetersenGraph()
-            sage: g.depth_first_search(0)
-            <generator object ...depth_first_search at ...
-            sage: next(g.depth_first_search(0))
-            0
-        """
-        cdef int v_int
-
-        while self.stack:
-            v_int = self.stack.pop()
+        while ((self.direction == 0 and not self.fifo.empty())
+                or self.direction != 0 and not self.lifo.empty()):
+            if self.direction == 0:
+                v_int = self.fifo.front()
+                self.fifo.pop()
+            else:
+                v_int = self.lifo.top()
+                self.lifo.pop()
 
             if bitset_not_in(self.seen, v_int):
                 value = self.graph.vertex_label(v_int)
                 bitset_add(self.seen, v_int)
 
                 if self.test_out:
-                    self.stack.extend(self.graph.cg().out_neighbors(v_int))
+                    w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)
+                    while w_int != -1:
+                        if self.direction == 0:
+                            self.fifo.push(w_int)
+                        else:
+                            self.lifo.push(w_int)
+                        w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)
                 if self.test_in:
-                    self.stack.extend(self.in_neighbors(v_int))
+                    w_int = cg.next_in_neighbor_unsafe(v_int, -1, &l)
+                    while w_int != -1:
+                        if self.direction == 0:
+                            self.fifo.push(w_int)
+                        else:
+                            self.lifo.push(w_int)
+                        w_int = cg.next_in_neighbor_unsafe(v_int, w_int, &l)
 
                 break
         else:
@@ -4891,22 +4877,6 @@ cdef class Search_iterator:
 
         return value
 
-    def __next__(self):
-        r"""
-        Return the next vertex in a breadth first search traversal of a graph.
-
-        EXAMPLES::
-
-            sage: g = graphs.PetersenGraph()
-            sage: g.breadth_first_search(0)
-            <generator object ...breadth_first_search at ...
-            sage: next(g.breadth_first_search(0))
-            0
-        """
-        if self.direction == 0:
-            return self.next_breadth_first_search()
-        return self.next_depth_first_search()
-
 ##############################
 # Functions to simplify edge iterator.
 ##############################
```


However, as mentioned above, I need to figure out something yet for sparse graphs.

And there seems to exist no depth-first doctest for static sparse, at least not in `sage/src/sage/graphs`.


---

Comment by @kliem created at 2020-12-28 12:16:46

Never mind my last comment. I think it is a good first step to seperate `next_breadth...` and `next_depth...` for the following reason:

I don't think queue is a good implementation in the long run. The thing is, we know exactly which values things in queue can take and we don't want anything twice, so we might as well implement the queue as `int*` of length number of active vertices (one needs to realloc to segmentation fault, in case someone adds vertices while we perform the depth first search, but I assume non-optimal runtime is okay in this case).
- And each vertex points to the next in the queue (initial value -1).
- We need also keep track of first and last of the queue.
- We only add a vertex to the queue, if it doesn't have a next value yet (and is not the last one).

Later on, we can also report the distance easily.


---

Comment by git created at 2020-12-28 14:40:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-12-28 14:47:45

I rebased the branch on 9.3.beta5 and use `int*` to implement the queue. I have let the `in_neighbors` and `out_neighbors` to have a functional branch. 

Ideally, we should implement (un)safe iterators over the in/out neighbors of all backends. Currently, some backends have neighbor iterators that first build the list of neighbors and then iterate over that list...


---

Comment by @kliem created at 2020-12-28 17:00:38

Ok, I implemented `next_out_neighbor_unsafe` for static sparse graph. It doesn't accept labels, because the labels are only known to the backend.

I pushed it to `u/gh-kliem/next_out_neighbor_for_static_sparse`, not yet a ticket, but with this thing you can apply my suggestion from comment:10.

Does this appear reasonable to you?

Before applying comment comment:10


```
sage: sage: def comp():  
....:     ....:     for n in [5, 10, 50, 100, 500, 1000]:  
....:         ....:         G = graphs.Grid2dGraph(n, n)   
....:         ....:         print(G)   
....:         ....:         %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=False))  
....:         ....:         G = G.copy(sparse=True, immutable=True) 
....:         ....:         %timeit _ = list(G.breadth_first_search(start=(0, 0), report_distance=False))   
....:          
....:                                                                                                                                 
sage: comp()                                                                                                                          
2D Grid Graph for [5, 5]
8.35 µs ± 36.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
6.46 µs ± 17 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
2D Grid Graph for [10, 10]
25.8 µs ± 39 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
18.3 µs ± 105 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
2D Grid Graph for [50, 50]
796 µs ± 3.01 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
605 µs ± 344 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [100, 100]
3.27 ms ± 17.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
2.46 ms ± 1.42 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
2D Grid Graph for [500, 500]
104 ms ± 45 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
78.4 ms ± 31.6 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
2D Grid Graph for [1000, 1000]
445 ms ± 328 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
319 ms ± 725 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
```


After:

```
sage: comp()                                                                                                                                                                                                                                                                                                                                                               
2D Grid Graph for [5, 5]
6.26 µs ± 14.6 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
5.58 µs ± 8.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
2D Grid Graph for [10, 10]
17.2 µs ± 12.3 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
14.1 µs ± 36.5 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
2D Grid Graph for [50, 50]
484 µs ± 3.59 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
388 µs ± 189 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [100, 100]
2.05 ms ± 4.4 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
1.59 ms ± 1.35 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
2D Grid Graph for [500, 500]
72.9 ms ± 30.8 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
55.4 ms ± 22.7 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
2D Grid Graph for [1000, 1000]
289 ms ± 71.7 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
228 ms ± 120 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)
```


As mentioned, we can also easily add a method that reports the distance of the current vertex as to replace the python method. Do you want to do this here or in an extra ticket.

comment:10 can of course also be an extra ticket and then I can quickly just review this here.


---

Comment by @kliem created at 2020-12-28 18:09:46

Btw, my idea for the queue imitation does not seem to make a difference, but for limiting the maximum memory usage. What might be simpler (and actually use less memory in some cases) is to use the standard queue implementation with the new setup for seen: Mark a vertex as seen as soon as we add it to the queue.

Its appears to be all the same speed but this would avoid reinventing the wheel while still reducing the memory usage.

When we also keep track of the current distance, we will need to change the base type for queue, but that wouldn't be a problem.

And on some follow up ticket, we can also allow a list of vertices for the cython implementation.


---

Comment by dcoudert created at 2020-12-28 18:19:02

Feel free to modify this ticket and merge your proposals (including using queue to not reinvent the wheel). 

For reporting distances, my only concern is whether we should do all in a single method or if we should design specific methods to save some tests.

Observe that we can use the data structure for distances to report edges.

I agree that in another ticket we can have list of vertices as input.

I still think that it would be nice to have low level neighbor iterators in backends, but this is another story.


---

Comment by @kliem created at 2020-12-28 18:27:02

Replying to [comment:19 dcoudert]:
> [...]
> I still think that it would be nice to have low level neighbor iterators in backends, but this is another story.

I implemented `next_out_neighbor_unsafe` for static sparse. What do you mean by low level neighbor iterators? Python iterators?


---

Comment by dcoudert created at 2020-12-28 18:57:43

currently, we use `out_neighbors`. it returns a list, and to build it, it calls `out_neighbors_unsafe` with a local array, which itself calls `next_out_neighbor_unsafe`.  When we just want to iterate over the out neighbors once, may be we can combine several operations done in `next_out_neighbor_unsafe` in a method called `out_neighbor_iterator_unsafe` that yields  out neighbors. 

We are going to call directly `next_out_neighbor_unsafe`, but again, inside this method, several operations could be done only once for yielding all the out neighbors of a vertex.


---

Comment by git created at 2020-12-28 21:00:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-12-28 21:14:01

I only noticed now that what I suggested in comment:10 is what you have tried before on this ticket and then have fallen back.


---

Comment by @kliem created at 2020-12-28 22:47:44

Replying to [comment:21 dcoudert]:
> currently, we use `out_neighbors`. it returns a list, and to build it, it calls `out_neighbors_unsafe` with a local array, which itself calls `next_out_neighbor_unsafe`.  When we just want to iterate over the out neighbors once, may be we can combine several operations done in `next_out_neighbor_unsafe` in a method called `out_neighbor_iterator_unsafe` that yields  out neighbors. 
> 
> We are going to call directly `next_out_neighbor_unsafe`, but again, inside this method, several operations could be done only once for yielding all the out neighbors of a vertex.

I think `next_out_neighbor_unsafe` is a pretty good solution to make it work for all backends with one function name.

I tried implementing an iterator in sparse graph and this takes twice as much (I don't know how to make it significantly faster):


```diff
diff --git a/src/sage/graphs/base/c_graph.pyx b/src/sage/graphs/base/c_graph.pyx
index 63a024e37a..15b070ed7c 100644
--- a/src/sage/graphs/base/c_graph.pyx
+++ b/src/sage/graphs/base/c_graph.pyx
@@ -1122,6 +1122,9 @@ cdef class CGraph:
     cdef int next_in_neighbor_unsafe(self, int v, int u, int* l) except -2:
         raise NotImplementedError()
 
+    def out_neighbor_iterator_unsafe(self, int u):
+        raise NotImplementedError
+
     cdef adjacency_sequence_out(self, int n, int *vertices, int v, int* sequence):
         r"""
         Return the adjacency sequence corresponding to a list of vertices and a
@@ -4848,12 +4851,13 @@ cdef class Search_iterator:
             value = self.graph.vertex_label(v_int)
 
             if self.test_out:
-                w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)
-                while w_int != -1:
+                for w_int in cg.out_neighbor_iterator_unsafe(v_int):
+                #w_int = cg.next_out_neighbor_unsafe(v_int, -1, &l)
+                #while w_int != -1:
                     if bitset_not_in(self.seen, w_int):
                         bitset_add(self.seen, w_int)
                         self.fifo.push(w_int)
-                    w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)
+                    #w_int = cg.next_out_neighbor_unsafe(v_int, w_int, &l)
             if self.test_in:
                 w_int = cg.next_in_neighbor_unsafe(v_int, -1, &l)
                 while w_int != -1:
diff --git a/src/sage/graphs/base/sparse_graph.pyx b/src/sage/graphs/base/sparse_graph.pyx
index 19006ceb80..220fcab123 100644
--- a/src/sage/graphs/base/sparse_graph.pyx
+++ b/src/sage/graphs/base/sparse_graph.pyx
@@ -191,11 +191,14 @@ for both of these uses.
 
 
 from libc.string cimport memset
-from cysignals.memory cimport check_malloc, check_allocarray, sig_free
+from cysignals.memory cimport check_malloc, check_realloc, check_allocarray, sig_free
 
 from sage.data_structures.bitset_base cimport *
 from sage.data_structures.bitset cimport *
 
+cdef extern from "Python.h":
+    int unlikely(int) nogil  # Defined by Cython
+
 cdef enum:
     BT_REORDERING_CONSTANT = 145533211
     # Since the binary tree will often see vertices coming in already sorted,
@@ -706,6 +709,37 @@ cdef class SparseGraph(CGraph):
             return temp
         return NULL
 
+    def out_neighbor_iterator_unsafe(self, int u):
+        cdef int i
+        cdef SparseGraphBTNode* v
+        cdef SparseGraphBTNode** lifo = <SparseGraphBTNode**> check_malloc(2*self.hash_length*sizeof(SparseGraphBTNode*))
+        cdef int lifo_index = 0
+        cdef size_t lifo_size = self.hash_length*2
+
+        for i in range(u * self.hash_length, (u+1) * self.hash_length):
+            if not self.vertices[i]:
+                continue
+            lifo[lifo_index] = self.vertices[i]
+            lifo_index += 1
+
+        while lifo_index:
+            lifo_index -= 1
+            v = lifo[lifo_index]
+            if unlikely(lifo_size < lifo_index + 2):
+                lifo = <SparseGraphBTNode**> check_realloc(lifo, 2*lifo_size*sizeof(SparseGraphBTNode*))
+                lifo_size *= 2
+
+            if v.left:
+                lifo[lifo_index] = v.left
+                lifo_index += 1
+            if v.right:
+                lifo[lifo_index] = v.right
+                lifo_index += 1
+            yield v.vertex
+
+
+        sig_free(lifo)
```


It is a python function after all.

The advantage of creating the list of all neighbors is that we need less often to traverse the tree of neighbors. However, for a sparse graph, this should usually be a very fast operation. This seems to be the only thing that can be improved in `next_out_neighbor` for sparse graphs (and I don't see anything for dense graphs at all).


---

Comment by dcoudert created at 2020-12-29 00:16:29

Then we should let this for another ticket. Further cleaning / improvements / implications in the backends may lead to other / faster solutions.


---

Comment by @kliem created at 2020-12-29 08:21:23

I'm happy with the ticket.


---

Comment by git created at 2020-12-29 08:41:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @kliem created at 2020-12-29 08:43:37

Inlining makes a difference. More than 10 percent for any of those test instances.

Please update the timings in the ticket description.


---

Comment by git created at 2020-12-29 11:56:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2020-12-29 11:57:31

There was an error in method ` next_in_neighbor_unsafe` of `static_sparse_backend.pyx`:

```diff
-        cdef int degree = self.g_rev.neighbors[u+1] - self.g.neighbors[u]
+        cdef int degree = self.g_rev.neighbors[u+1] - self.g_rev.neighbors[u]
```

The segfaults reported by the patchbot for #31129 are all due to this error.

I changed to the safer / cleaner version

```diff
-        cdef int degree = self.g_rev.neighbors[u+1] - self.g.neighbors[u]
+        cdef int degree = out_degree(self.g_rev, u)
```



---

Comment by dcoudert created at 2020-12-29 16:59:33

We now have green bot. If you agree, we can set this ticket to positive review. We have significant improvements !


---

Comment by @kliem created at 2020-12-29 21:10:03

Changing status from needs_review to positive_review.


---

Comment by @kliem created at 2020-12-29 21:10:03

Yes, I agree.


---

Comment by vbraun created at 2021-01-03 12:15:16

Resolution: fixed
