# Issue 17627: Popen.terminate not working on cygwin

Issue created by migration from https://trac.sagemath.org/ticket/17864

Original creator: gouezel

Original creation time: 2015-02-26 20:40:40

CC:  jpflori

The implementation of signals on `cygwin` is so deficient that Popened processes with an stdout pipe can not be terminated using signals if they still have something to output. This is a known problem. For instance:

```
>>> from subprocess import Popen, PIPE
>>> p = Popen(['cat', 'setup.py'], stdout=PIPE)
>>> p.stdout.readline()
'#!/usr/bin/env python\n'
>>> p.terminate()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/subprocess.py", line 1551, in terminate
    self.send_signal(signal.SIGTERM)
  File "/usr/lib/python2.7/subprocess.py", line 1546, in send_signal
    os.kill(self.pid, sig)
OSError: [Errno 3] No such process
```


The palp library is called in sage precisely in this way. There are already workarounds in `sage/geometry/lattice_polytope.py`:

```
# We program around an issue with subprocess (this so far seems to
# only be an issue on Cygwin).
try:
    p.terminate()
except OSError:
    pass
```

but the result is that the process is left dangling forever. And there is also one place without the workaround, resulting in the exception (and a failing doctest).


---

Comment by gouezel created at 2015-02-28 15:11:06

Adding and using a generic function to terminate Popened childs that also works on cygwin. I put it in sage.misc.misc, which is maybe not very good, any better idea welcome.
----
New commits:


---

Comment by gouezel created at 2015-02-28 15:11:06

Changing status from new to needs_review.


---

Comment by jdemeyer created at 2015-03-03 08:47:32

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2015-03-03 08:47:32

I don't like

```
p.terminate()
if p.poll() is not None:
    return p.returncode

p.kill()
if p.poll() is not None:
    return p.returncode

raise RuntimeError('Process could not be terminated')
```

You need to give the process some time to die.

Also: why do you return the returncode? It seems none of the current applications need that.

Therefore, I think the block I quoted above can be replaced by

```
p.terminate()
```



---

Comment by git created at 2015-03-04 20:05:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by gouezel created at 2015-03-04 20:11:30

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2015-03-09 09:35:53

It seems the process is no longer terminated on Cygwin. Also, can this be implemented in a platform-independent way please? I don't like explicit platform tests if it can be avoided.


---

Comment by jdemeyer created at 2015-03-09 09:35:53

Changing status from needs_review to needs_work.


---

Comment by gouezel created at 2015-03-09 10:15:26

The python function `communicate` does the following: read everything that the process has to output, then terminate the process and wait until it is properly terminated (see https://docs.python.org/2/library/subprocess.html). In particular, communicate always terminates the process. This works on cygwin (contrary to the simple signal sent by `p.terminate()`) but it has two drawbacks: 
- if the process still has a lot to output, it means that a lot of useless work is done, and a lot of useless data is transferred back to `sage` (and dumped right away).
- if the process takes time to properly terminate, we will be waiting for it, for no reason.

To me, it means that the simple method using `p.terminate()` is preferable whenever it is available.

I can make it platform-independent by first trying `p.terminate()` and using `communicate` if an exception is raised.


---

Comment by jdemeyer created at 2015-03-09 14:34:10

I understand your explanation, but the problem is that there is really no guarantee that the process will actually be terminated. Waiting for the process to finish by itself is _very different_ from terminating the process. Therefore, I think that `communicate` is not the right solution to the problem (I don't know Cygwin, so I don't know what the right solution is).


---

Comment by jdemeyer created at 2015-03-09 14:38:40

I have no idea, but would using a different signal work?


---

Comment by git created at 2015-03-09 20:30:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by gouezel created at 2015-03-09 21:01:17

Changing status from needs_work to needs_review.


---

Comment by gouezel created at 2015-03-09 21:01:17

No signal can work, it is impossible to send any signal to the child process while it is busy waiting to output something... I don't see any other approach than communicate. For the use case we have currently (calls to the palp database), it works perfectly, and in general it should work if the program we call is not buggy.

Modified patch with try/except block, to make it more platform-agnostic. If cygwin's signals improve in the future, this means the exception will not be raised and `terminate` will be used as it should be also on cygwin.


The patch should not change anything on sane platforms where signals work properly. It solves the issue on cygwin for our current use case, and if there are further issues they will get noticed with the patch, contrary to the current code with `except: pass`.  So, I'd rather get it merged, and open a followup ticket if necessary.


---

Comment by jdemeyer created at 2015-04-21 09:14:23

Here is a different idea: is it _really_ important to terminate the child process? What about just not terminating the process if that fails? Or something like: close stdin, try to terminate, wait 1 second, try again, give up.


---

Comment by jdemeyer created at 2015-04-21 09:15:30

Replying to [comment:10 gouezel]:
> For the use case we have currently (calls to the palp database), it works perfectly
Then why not simply use `communicate()` always on every platform in that use case?


---

Comment by jdemeyer created at 2015-05-12 12:48:38

Changing status from needs_review to needs_info.


---

Comment by jpflori created at 2015-09-02 08:40:20

I guess it's still better to try to properly terminate the process first.
IMHO it's just cleaner.


---

Comment by jdemeyer created at 2015-09-02 09:07:01

Replying to [comment:15 jpflori]:
> I guess it's still better to try to properly terminate the process first.
If there are two ways A and B to achieve X, where A works on some platforms but B always works, we should just do B.

In this case: X = end the PALP process, A = call `terminate()`, B = use `communicate`.


---

Comment by jpflori created at 2015-09-02 09:19:21

Note that Python doc says:

```
communicate
...
Note

The data read is buffered in memory, so do not use this method if the data size is large or unlimited. 
```



---

Comment by jdemeyer created at 2015-09-02 09:26:34

Replying to [comment:17 jpflori]:
> Note that Python doc says:
> {{{
> communicate
> ...
> Note
> 
> The data read is buffered in memory, so do not use this method if the data size is large or unlimited. 
> }}}
If the output is too large (no idea if this is the case for PALP), you can `read()` in a loop instead.


---

Comment by embray created at 2016-08-10 18:27:57

With apologies, I haven't read through all the comments on this ticket yet, but I feel like the explanation in the ticket's original description is off.  It doesn't seem to have anything to do with if the process still has something to input.  For example:


```
>>> p = Popen(['echo'], stdout=PIPE)
>>> p.stdout.read()
'\n'
>>> p.stdout.close()
>>> p.terminate()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/subprocess.py", line 1559, in terminate
    self.send_signal(signal.SIGTERM)
  File "/usr/lib/python2.7/subprocess.py", line 1554, in send_signal
    os.kill(self.pid, sig)
OSError: [Errno 3] No such process
```


I even made a test program called `noop` with an empty main function and:


```
>>> p = Popen(['./noop'])
>>> p.terminate()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/subprocess.py", line 1559, in terminate
    self.send_signal(signal.SIGTERM)
  File "/usr/lib/python2.7/subprocess.py", line 1554, in send_signal
    os.kill(self.pid, sig)
OSError: [Errno 3] No such process
```


On Linux the difference is subtle:


```
>>> p = Popen(['./noop'])
>>> p.terminate()
>>> p.wait()
0
>>> p.terminate()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/subprocess.py", line 1551, in terminate
    self.send_signal(signal.SIGTERM)
  File "/usr/lib/python2.7/subprocess.py", line 1546, in send_signal
    os.kill(self.pid, sig)
OSError: [Errno 3] No such process
```


This is because before the `wait()` call the process still exists in a zombie state and it's not an error to send it a signal (I think this is an implementation detail though--on Linux the struct representing the relevant `task_struct` for the process gets an awaiting signal set on it, but of course it's never acted on).  

On Windows of course the semantics are totally different.  The signal emulation is handled by a thread that's spun up when the process starts.  When the process ends and [`ExitProcess`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682658(v=vs.85).aspx) is called, all threads are stopped, so there's nothing to "handle" signals sent to that process, so any attempt to do so results in an error.  Cygwin could probably be more robust here--it also holds on to a process in its internal process list until `wait()` is called, and the process has exited.  It could check before attempting to signal a process if it's already exited and waiting to be reaped.  I don't know if there's an POSIX requirement of this though--it may just be considered an implementation detail.

Long story short, it's not portable to called `terminate()` or `kill()` _at least_ before a `poll()` call if the process has already exited.


---

Comment by embray created at 2016-08-11 09:08:21

Replying to [comment:19 embray]:
> Cygwin could probably be more robust here--it also holds on to a process in its internal process list until `wait()` is called, and the process has exited.  It could check before attempting to signal a process if it's already exited and waiting to be reaped.  I don't know if there's an POSIX requirement of this though--it may just be considered an implementation detail.

To follow up on this, according to http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html :

> Existing implementations vary on the result of a kill() with pid indicating an inactive process (a terminated process that has not been waited for by its parent). Some indicate success on such a call (subject to permission checking), while others give an error of [ESRCH]. Since the definition of process lifetime in this volume of POSIX.1-2008 covers inactive processes, the [ESRCH] error as described is inappropriate in this case. In particular, this means that an application cannot have a parent process check for termination of a particular child with kill(). (Usually this is done with the null signal; this can be done reliably with waitpid().)

So Cygwin is definitely wrong here.  I'll bring this up with them.  Looking at the Cygwin implementation I see no obvious reason why it couldn't have better behavior here.  Nonetheless it's acknowledged above that existing implementations have varying behavior, and Cygwin may not be the only culprit.  So best is to not send signals to exited processes (and also be prepared to handle `ESRCH` if the process exits between the last poll and the `kill()` call).


---

Comment by embray created at 2017-04-13 10:11:20

Going ahead and closing this since it's been superseded by #21206 (which is a duplicate of this issue, but closer to being resolved).


---

Comment by embray created at 2017-04-13 10:11:20

Resolution: wontfix
