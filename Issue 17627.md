# Issue 17627: Popen.terminate not working on cygwin

archive/issues_017627.json:
```json
{
    "body": "CC:  jpflori\n\nThe implementation of signals on `cygwin` is so deficient that Popened processes with an stdout pipe can not be terminated using signals if they still have something to output. This is a known problem. For instance:\n\n```\n>>> from subprocess import Popen, PIPE\n>>> p = Popen(['cat', 'setup.py'], stdout=PIPE)\n>>> p.stdout.readline()\n'#!/usr/bin/env python\\n'\n>>> p.terminate()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/lib/python2.7/subprocess.py\", line 1551, in terminate\n    self.send_signal(signal.SIGTERM)\n  File \"/usr/lib/python2.7/subprocess.py\", line 1546, in send_signal\n    os.kill(self.pid, sig)\nOSError: [Errno 3] No such process\n```\n\n\nThe palp library is called in sage precisely in this way. There are already workarounds in `sage/geometry/lattice_polytope.py`:\n\n```\n# We program around an issue with subprocess (this so far seems to\n# only be an issue on Cygwin).\ntry:\n    p.terminate()\nexcept OSError:\n    pass\n```\n\nbut the result is that the process is left dangling forever. And there is also one place without the workaround, resulting in the exception (and a failing doctest).\n\nIssue created by migration from https://trac.sagemath.org/ticket/17864\n\n",
    "created_at": "2015-02-26T20:40:40Z",
    "labels": [
        "porting: Cygwin",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "Popen.terminate not working on cygwin",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/17627",
    "user": "gouezel"
}
```
CC:  jpflori

The implementation of signals on `cygwin` is so deficient that Popened processes with an stdout pipe can not be terminated using signals if they still have something to output. This is a known problem. For instance:

```
>>> from subprocess import Popen, PIPE
>>> p = Popen(['cat', 'setup.py'], stdout=PIPE)
>>> p.stdout.readline()
'#!/usr/bin/env python\n'
>>> p.terminate()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/subprocess.py", line 1551, in terminate
    self.send_signal(signal.SIGTERM)
  File "/usr/lib/python2.7/subprocess.py", line 1546, in send_signal
    os.kill(self.pid, sig)
OSError: [Errno 3] No such process
```


The palp library is called in sage precisely in this way. There are already workarounds in `sage/geometry/lattice_polytope.py`:

```
# We program around an issue with subprocess (this so far seems to
# only be an issue on Cygwin).
try:
    p.terminate()
except OSError:
    pass
```

but the result is that the process is left dangling forever. And there is also one place without the workaround, resulting in the exception (and a failing doctest).

Issue created by migration from https://trac.sagemath.org/ticket/17864





---

archive/issue_comments_235576.json:
```json
{
    "body": "Adding and using a generic function to terminate Popened childs that also works on cygwin. I put it in sage.misc.misc, which is maybe not very good, any better idea welcome.\n----\nNew commits:",
    "created_at": "2015-02-28T15:11:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235576",
    "user": "gouezel"
}
```

Adding and using a generic function to terminate Popened childs that also works on cygwin. I put it in sage.misc.misc, which is maybe not very good, any better idea welcome.
----
New commits:



---

archive/issue_comments_235577.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2015-02-28T15:11:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235577",
    "user": "gouezel"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_235578.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-03-03T08:47:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235578",
    "user": "@jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_235579.json:
```json
{
    "body": "I don't like\n\n```\np.terminate()\nif p.poll() is not None:\n    return p.returncode\n\np.kill()\nif p.poll() is not None:\n    return p.returncode\n\nraise RuntimeError('Process could not be terminated')\n```\n\nYou need to give the process some time to die.\n\nAlso: why do you return the returncode? It seems none of the current applications need that.\n\nTherefore, I think the block I quoted above can be replaced by\n\n```\np.terminate()\n```\n",
    "created_at": "2015-03-03T08:47:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235579",
    "user": "@jdemeyer"
}
```

I don't like

```
p.terminate()
if p.poll() is not None:
    return p.returncode

p.kill()
if p.poll() is not None:
    return p.returncode

raise RuntimeError('Process could not be terminated')
```

You need to give the process some time to die.

Also: why do you return the returncode? It seems none of the current applications need that.

Therefore, I think the block I quoted above can be replaced by

```
p.terminate()
```




---

archive/issue_comments_235580.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-04T20:05:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235580",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235581.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-03-04T20:11:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235581",
    "user": "gouezel"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_235582.json:
```json
{
    "body": "It seems the process is no longer terminated on Cygwin. Also, can this be implemented in a platform-independent way please? I don't like explicit platform tests if it can be avoided.",
    "created_at": "2015-03-09T09:35:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235582",
    "user": "@jdemeyer"
}
```

It seems the process is no longer terminated on Cygwin. Also, can this be implemented in a platform-independent way please? I don't like explicit platform tests if it can be avoided.



---

archive/issue_comments_235583.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2015-03-09T09:35:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235583",
    "user": "@jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_235584.json:
```json
{
    "body": "The python function `communicate` does the following: read everything that the process has to output, then terminate the process and wait until it is properly terminated (see https://docs.python.org/2/library/subprocess.html). In particular, communicate always terminates the process. This works on cygwin (contrary to the simple signal sent by `p.terminate()`) but it has two drawbacks: \n- if the process still has a lot to output, it means that a lot of useless work is done, and a lot of useless data is transferred back to `sage` (and dumped right away).\n- if the process takes time to properly terminate, we will be waiting for it, for no reason.\n\nTo me, it means that the simple method using `p.terminate()` is preferable whenever it is available.\n\nI can make it platform-independent by first trying `p.terminate()` and using `communicate` if an exception is raised.",
    "created_at": "2015-03-09T10:15:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235584",
    "user": "gouezel"
}
```

The python function `communicate` does the following: read everything that the process has to output, then terminate the process and wait until it is properly terminated (see https://docs.python.org/2/library/subprocess.html). In particular, communicate always terminates the process. This works on cygwin (contrary to the simple signal sent by `p.terminate()`) but it has two drawbacks: 
- if the process still has a lot to output, it means that a lot of useless work is done, and a lot of useless data is transferred back to `sage` (and dumped right away).
- if the process takes time to properly terminate, we will be waiting for it, for no reason.

To me, it means that the simple method using `p.terminate()` is preferable whenever it is available.

I can make it platform-independent by first trying `p.terminate()` and using `communicate` if an exception is raised.



---

archive/issue_comments_235585.json:
```json
{
    "body": "I understand your explanation, but the problem is that there is really no guarantee that the process will actually be terminated. Waiting for the process to finish by itself is *very different* from terminating the process. Therefore, I think that `communicate` is not the right solution to the problem (I don't know Cygwin, so I don't know what the right solution is).",
    "created_at": "2015-03-09T14:34:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235585",
    "user": "@jdemeyer"
}
```

I understand your explanation, but the problem is that there is really no guarantee that the process will actually be terminated. Waiting for the process to finish by itself is *very different* from terminating the process. Therefore, I think that `communicate` is not the right solution to the problem (I don't know Cygwin, so I don't know what the right solution is).



---

archive/issue_comments_235586.json:
```json
{
    "body": "I have no idea, but would using a different signal work?",
    "created_at": "2015-03-09T14:38:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235586",
    "user": "@jdemeyer"
}
```

I have no idea, but would using a different signal work?



---

archive/issue_comments_235587.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-09T20:30:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235587",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_235588.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2015-03-09T21:01:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235588",
    "user": "gouezel"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_235589.json:
```json
{
    "body": "No signal can work, it is impossible to send any signal to the child process while it is busy waiting to output something... I don't see any other approach than communicate. For the use case we have currently (calls to the palp database), it works perfectly, and in general it should work if the program we call is not buggy.\n\nModified patch with try/except block, to make it more platform-agnostic. If cygwin's signals improve in the future, this means the exception will not be raised and `terminate` will be used as it should be also on cygwin.\n\n\nThe patch should not change anything on sane platforms where signals work properly. It solves the issue on cygwin for our current use case, and if there are further issues they will get noticed with the patch, contrary to the current code with `except: pass`.  So, I'd rather get it merged, and open a followup ticket if necessary.",
    "created_at": "2015-03-09T21:01:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235589",
    "user": "gouezel"
}
```

No signal can work, it is impossible to send any signal to the child process while it is busy waiting to output something... I don't see any other approach than communicate. For the use case we have currently (calls to the palp database), it works perfectly, and in general it should work if the program we call is not buggy.

Modified patch with try/except block, to make it more platform-agnostic. If cygwin's signals improve in the future, this means the exception will not be raised and `terminate` will be used as it should be also on cygwin.


The patch should not change anything on sane platforms where signals work properly. It solves the issue on cygwin for our current use case, and if there are further issues they will get noticed with the patch, contrary to the current code with `except: pass`.  So, I'd rather get it merged, and open a followup ticket if necessary.



---

archive/issue_comments_235590.json:
```json
{
    "body": "Here is a different idea: is it *really* important to terminate the child process? What about just not terminating the process if that fails? Or something like: close stdin, try to terminate, wait 1 second, try again, give up.",
    "created_at": "2015-04-21T09:14:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235590",
    "user": "@jdemeyer"
}
```

Here is a different idea: is it *really* important to terminate the child process? What about just not terminating the process if that fails? Or something like: close stdin, try to terminate, wait 1 second, try again, give up.



---

archive/issue_comments_235591.json:
```json
{
    "body": "Replying to [comment:10 gouezel]:\n> For the use case we have currently (calls to the palp database), it works perfectly\nThen why not simply use `communicate()` always on every platform in that use case?",
    "created_at": "2015-04-21T09:15:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235591",
    "user": "@jdemeyer"
}
```

Replying to [comment:10 gouezel]:
> For the use case we have currently (calls to the palp database), it works perfectly
Then why not simply use `communicate()` always on every platform in that use case?



---

archive/issue_comments_235592.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2015-05-12T12:48:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235592",
    "user": "@jdemeyer"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_235593.json:
```json
{
    "body": "I guess it's still better to try to properly terminate the process first.\nIMHO it's just cleaner.",
    "created_at": "2015-09-02T08:40:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235593",
    "user": "jpflori"
}
```

I guess it's still better to try to properly terminate the process first.
IMHO it's just cleaner.



---

archive/issue_comments_235594.json:
```json
{
    "body": "Replying to [comment:15 jpflori]:\n> I guess it's still better to try to properly terminate the process first.\nIf there are two ways A and B to achieve X, where A works on some platforms but B always works, we should just do B.\n\nIn this case: X = end the PALP process, A = call `terminate()`, B = use `communicate`.",
    "created_at": "2015-09-02T09:07:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235594",
    "user": "@jdemeyer"
}
```

Replying to [comment:15 jpflori]:
> I guess it's still better to try to properly terminate the process first.
If there are two ways A and B to achieve X, where A works on some platforms but B always works, we should just do B.

In this case: X = end the PALP process, A = call `terminate()`, B = use `communicate`.



---

archive/issue_comments_235595.json:
```json
{
    "body": "Note that Python doc says:\n\n```\ncommunicate\n...\nNote\n\nThe data read is buffered in memory, so do not use this method if the data size is large or unlimited. \n```\n",
    "created_at": "2015-09-02T09:19:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235595",
    "user": "jpflori"
}
```

Note that Python doc says:

```
communicate
...
Note

The data read is buffered in memory, so do not use this method if the data size is large or unlimited. 
```




---

archive/issue_comments_235596.json:
```json
{
    "body": "Replying to [comment:17 jpflori]:\n> Note that Python doc says:\n> {{{\n> communicate\n> ...\n> Note\n> \n> The data read is buffered in memory, so do not use this method if the data size is large or unlimited. \n> }}}\nIf the output is too large (no idea if this is the case for PALP), you can `read()` in a loop instead.",
    "created_at": "2015-09-02T09:26:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235596",
    "user": "@jdemeyer"
}
```

Replying to [comment:17 jpflori]:
> Note that Python doc says:
> {{{
> communicate
> ...
> Note
> 
> The data read is buffered in memory, so do not use this method if the data size is large or unlimited. 
> }}}
If the output is too large (no idea if this is the case for PALP), you can `read()` in a loop instead.



---

archive/issue_comments_235597.json:
```json
{
    "body": "With apologies, I haven't read through all the comments on this ticket yet, but I feel like the explanation in the ticket's original description is off.  It doesn't seem to have anything to do with if the process still has something to input.  For example:\n\n\n```\n>>> p = Popen(['echo'], stdout=PIPE)\n>>> p.stdout.read()\n'\\n'\n>>> p.stdout.close()\n>>> p.terminate()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/lib/python2.7/subprocess.py\", line 1559, in terminate\n    self.send_signal(signal.SIGTERM)\n  File \"/usr/lib/python2.7/subprocess.py\", line 1554, in send_signal\n    os.kill(self.pid, sig)\nOSError: [Errno 3] No such process\n```\n\n\nI even made a test program called `noop` with an empty main function and:\n\n\n```\n>>> p = Popen(['./noop'])\n>>> p.terminate()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/lib/python2.7/subprocess.py\", line 1559, in terminate\n    self.send_signal(signal.SIGTERM)\n  File \"/usr/lib/python2.7/subprocess.py\", line 1554, in send_signal\n    os.kill(self.pid, sig)\nOSError: [Errno 3] No such process\n```\n\n\nOn Linux the difference is subtle:\n\n\n```\n>>> p = Popen(['./noop'])\n>>> p.terminate()\n>>> p.wait()\n0\n>>> p.terminate()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/lib/python2.7/subprocess.py\", line 1551, in terminate\n    self.send_signal(signal.SIGTERM)\n  File \"/usr/lib/python2.7/subprocess.py\", line 1546, in send_signal\n    os.kill(self.pid, sig)\nOSError: [Errno 3] No such process\n```\n\n\nThis is because before the `wait()` call the process still exists in a zombie state and it's not an error to send it a signal (I think this is an implementation detail though--on Linux the struct representing the relevant `task_struct` for the process gets an awaiting signal set on it, but of course it's never acted on).  \n\nOn Windows of course the semantics are totally different.  The signal emulation is handled by a thread that's spun up when the process starts.  When the process ends and [`ExitProcess`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682658(v=vs.85).aspx) is called, all threads are stopped, so there's nothing to \"handle\" signals sent to that process, so any attempt to do so results in an error.  Cygwin could probably be more robust here--it also holds on to a process in its internal process list until `wait()` is called, and the process has exited.  It could check before attempting to signal a process if it's already exited and waiting to be reaped.  I don't know if there's an POSIX requirement of this though--it may just be considered an implementation detail.\n\nLong story short, it's not portable to called `terminate()` or `kill()` *at least* before a `poll()` call if the process has already exited.",
    "created_at": "2016-08-10T18:27:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235597",
    "user": "@embray"
}
```

With apologies, I haven't read through all the comments on this ticket yet, but I feel like the explanation in the ticket's original description is off.  It doesn't seem to have anything to do with if the process still has something to input.  For example:


```
>>> p = Popen(['echo'], stdout=PIPE)
>>> p.stdout.read()
'\n'
>>> p.stdout.close()
>>> p.terminate()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/subprocess.py", line 1559, in terminate
    self.send_signal(signal.SIGTERM)
  File "/usr/lib/python2.7/subprocess.py", line 1554, in send_signal
    os.kill(self.pid, sig)
OSError: [Errno 3] No such process
```


I even made a test program called `noop` with an empty main function and:


```
>>> p = Popen(['./noop'])
>>> p.terminate()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/subprocess.py", line 1559, in terminate
    self.send_signal(signal.SIGTERM)
  File "/usr/lib/python2.7/subprocess.py", line 1554, in send_signal
    os.kill(self.pid, sig)
OSError: [Errno 3] No such process
```


On Linux the difference is subtle:


```
>>> p = Popen(['./noop'])
>>> p.terminate()
>>> p.wait()
0
>>> p.terminate()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/subprocess.py", line 1551, in terminate
    self.send_signal(signal.SIGTERM)
  File "/usr/lib/python2.7/subprocess.py", line 1546, in send_signal
    os.kill(self.pid, sig)
OSError: [Errno 3] No such process
```


This is because before the `wait()` call the process still exists in a zombie state and it's not an error to send it a signal (I think this is an implementation detail though--on Linux the struct representing the relevant `task_struct` for the process gets an awaiting signal set on it, but of course it's never acted on).  

On Windows of course the semantics are totally different.  The signal emulation is handled by a thread that's spun up when the process starts.  When the process ends and [`ExitProcess`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682658(v=vs.85).aspx) is called, all threads are stopped, so there's nothing to "handle" signals sent to that process, so any attempt to do so results in an error.  Cygwin could probably be more robust here--it also holds on to a process in its internal process list until `wait()` is called, and the process has exited.  It could check before attempting to signal a process if it's already exited and waiting to be reaped.  I don't know if there's an POSIX requirement of this though--it may just be considered an implementation detail.

Long story short, it's not portable to called `terminate()` or `kill()` *at least* before a `poll()` call if the process has already exited.



---

archive/issue_comments_235598.json:
```json
{
    "body": "Replying to [comment:19 embray]:\n> Cygwin could probably be more robust here--it also holds on to a process in its internal process list until `wait()` is called, and the process has exited.  It could check before attempting to signal a process if it's already exited and waiting to be reaped.  I don't know if there's an POSIX requirement of this though--it may just be considered an implementation detail.\n\nTo follow up on this, according to http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html :\n\n> Existing implementations vary on the result of a kill() with pid indicating an inactive process (a terminated process that has not been waited for by its parent). Some indicate success on such a call (subject to permission checking), while others give an error of [ESRCH]. Since the definition of process lifetime in this volume of POSIX.1-2008 covers inactive processes, the [ESRCH] error as described is inappropriate in this case. In particular, this means that an application cannot have a parent process check for termination of a particular child with kill(). (Usually this is done with the null signal; this can be done reliably with waitpid().)\n\nSo Cygwin is definitely wrong here.  I'll bring this up with them.  Looking at the Cygwin implementation I see no obvious reason why it couldn't have better behavior here.  Nonetheless it's acknowledged above that existing implementations have varying behavior, and Cygwin may not be the only culprit.  So best is to not send signals to exited processes (and also be prepared to handle `ESRCH` if the process exits between the last poll and the `kill()` call).",
    "created_at": "2016-08-11T09:08:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235598",
    "user": "@embray"
}
```

Replying to [comment:19 embray]:
> Cygwin could probably be more robust here--it also holds on to a process in its internal process list until `wait()` is called, and the process has exited.  It could check before attempting to signal a process if it's already exited and waiting to be reaped.  I don't know if there's an POSIX requirement of this though--it may just be considered an implementation detail.

To follow up on this, according to http://pubs.opengroup.org/onlinepubs/9699919799/functions/kill.html :

> Existing implementations vary on the result of a kill() with pid indicating an inactive process (a terminated process that has not been waited for by its parent). Some indicate success on such a call (subject to permission checking), while others give an error of [ESRCH]. Since the definition of process lifetime in this volume of POSIX.1-2008 covers inactive processes, the [ESRCH] error as described is inappropriate in this case. In particular, this means that an application cannot have a parent process check for termination of a particular child with kill(). (Usually this is done with the null signal; this can be done reliably with waitpid().)

So Cygwin is definitely wrong here.  I'll bring this up with them.  Looking at the Cygwin implementation I see no obvious reason why it couldn't have better behavior here.  Nonetheless it's acknowledged above that existing implementations have varying behavior, and Cygwin may not be the only culprit.  So best is to not send signals to exited processes (and also be prepared to handle `ESRCH` if the process exits between the last poll and the `kill()` call).



---

archive/issue_comments_235599.json:
```json
{
    "body": "Going ahead and closing this since it's been superseded by #21206 (which is a duplicate of this issue, but closer to being resolved).",
    "created_at": "2017-04-13T10:11:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235599",
    "user": "@embray"
}
```

Going ahead and closing this since it's been superseded by #21206 (which is a duplicate of this issue, but closer to being resolved).



---

archive/issue_comments_235600.json:
```json
{
    "body": "Resolution: wontfix",
    "created_at": "2017-04-13T10:11:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/17627",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/17627#issuecomment-235600",
    "user": "@embray"
}
```

Resolution: wontfix
