# Issue 19863: A new structure for Cyclic codes

Issue created by migration from Trac.

Original creator: dlucas

Original creation time: 2016-02-23 13:58:42

CC:  jsrn cpernet

This ticket proposes a new implementation for cyclic codes.

It contains:

- a new code class, `CyclicCode`,
- a dedicated encoder to compute the generator matrix of a Cyclic Code, and 
- an encoder whose message space is a polynomial ring.

This new structure has the following features:

- it is now possible to build a cyclic code in three different ways:
  - either by using the generator polynomial, which is passed as an argument,
  - either by using the defining set, which is passed as an argument (and can even be partial), or
  - by passing a linear code as argument. In that case, a generator polynomial will be computed (if possible) and used to reformat the input code as a cyclic code.
- it also comes with a method to compute the BCH bound, either from a constructed code or directly from the necessary parameters. 




---

Comment by dlucas created at 2016-02-24 09:13:39

I pushed my work, as it is almost done.
There's still one bug to fix, documented in `defining_set`'s broken docstring.
----
Last 10 new commits:


---

Comment by git created at 2016-02-24 09:38:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-02-24 09:38:52

Ok, found it and fixed it. It's now open for review.


---

Comment by dlucas created at 2016-02-24 09:38:52

Changing status from new to needs_review.


---

Comment by git created at 2016-03-02 12:45:01

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dlucas created at 2016-03-02 12:45:41

I merged with latest beta, fixed conflicts with GRS branch, this is still open for review.


---

Comment by git created at 2016-03-23 13:59:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-03-23 14:02:06

I fixed the broken doctests in `code_constructions.py`. 
They occured because the old implementation of `CyclicCode` allowed to use generator polynomials which do not divide `x^n - 1`, `n` being the length of the code.
I fixed this by replacing these polynomials (say, `g`) by `gcd(g, x^n - 1)`.

This is still open for review.


---

Comment by git created at 2016-03-31 09:05:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-03-31 09:07:13

I updated to the latest beta.
I also added a new optional argument: `primitive_element`. If filled, it will be used as the "base root" for the consecutive root sequence of the generator polynomial over the splitting field.


---

Comment by git created at 2016-06-28 12:22:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dlucas created at 2016-06-28 12:25:57

Hello,

I updated this ticket to latest beta version (7.3b5) and made some changes:

- I removed dependency to #20039.
- I improved documentation in many places, by defining terms more precisely.
- I removed now useless `__ne__` methods
- I changed helper methods and made them private methods.

This is open for review.

David


---

Comment by jsrn created at 2016-08-11 09:30:09

Fixed merge conflicts.
----
New commits:


---

Comment by git created at 2016-08-22 12:05:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-08-23 21:19:42

Hi,

As some sd75 participants may want to follow this ticket, I push some changes:
  - I fixed some typos;
  - I removed the probabilistic algorithm from the `find_generator_polynomial()` method, because it didn't always output the right result;
  - As we discussed quickly with Johan, only single-root cyclic codes are now implemented (that is, `n` and `q` must be coprimes);
  - I removed your local `_cyclotomic_cosets()` method;
  - I added some sanity checks;
  - maybe other things

That's still a work in progress. Especially, it remarked that (non exhaustive):
  - `__eq__` sometimes gives fake negatives (or type II errors). For example, when building cyclic codes from the same (mathematically speaking) generator polynomial, but belonging to two different instances of `PolynomialRing`.
  - I don't remember why we let the user choose the primitive element (does the code really depend on that?)
  - BCH bound computation will be hard to review :)
  - the defining set looks to depend on the choice of `beta`, the n-th root of unity.
  - I don't understand what is the `_known_generator_matrix` attribute
  - it seems weird that the `CyclicCodeVectorEncoder` encodes with a polynomial multiplication.

As I said, it's definitely a WIP.

Julien
----
New commits:


---

Comment by jlavauzelle created at 2016-08-23 21:19:42

Changing status from needs_review to needs_work.


---

Comment by git created at 2016-08-25 08:27:53

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2016-08-25 12:48:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-08-25 12:55:09

Hi,

I made some minor changes after merging the right 'develop' branch. I think now it compiles well (at least, in my machine; Joe Fields reported a compiling problem with guava in the previous push that I couldn't reproduce).

I reviewed almost all the code, i.e. all but the BCH bound. It looks quite fine now, but as it's a quite big patch, it clearly need a second review (besides, someone must review my own commits).

Julien


---

Comment by jlavauzelle created at 2016-08-25 13:21:42

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-08-25 14:03:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by danielaugot created at 2016-08-26 10:39:25

Hi David and Julien,

Using `codes.CyclicCode.<TAB>` I went through all methods which are worth mentionning. I will just first make a few remarks about them and their associated  docstrings.

* `codes.CyclicCode?`
  * "generator_pol" : in the sentence "the unique monic polynomial which divides every codeword" the meaning of "divides" is not mathematically clear. If you mean division in `F[X]/(X^n-1)`, then you need to furthermore say it has lowest degree to make it unique.
  * "D": recall it is a set of (positive ? reduced mod n ?) integers
  * method (3): a few words should be said about the default root of unity used in building the generator polynomial
* `codes.CyclicCode.bch_bound?`
  * is it possible to use `BCH_bound` to honor the authors ?
* `codes.CyclicCode.defining_set?` is very neat. For more completeness, I think it would be nice to briefly recall it depends on the choice of the primitive root (which is not shown or discussed in the examples).
* `codes.CyclicCode.dual_code()` not a docstring problem, and more a design problem. As I just tested it, the resulting code is not a member of the `CyclicCode class`.
* `codes.CyclicCode.primitive_element?` in the string "Returns the primitive element that was used as a root  the   generator polynomial over the extension field.", the words "that was used" are not very clear, since it is not mentionned by which method it has been used. For instance it should be clear from the docstring what is the result  when calling `codes.CyclicCode` using an arbritrary code.
* somehow the class inherits `C.variable_name`. Wouldn't it be a neat to use it to get the variable for the underlying polynomial ring ? 

I will go through the implementation this afternoon.

Daniel


---

Comment by danielaugot created at 2016-08-26 11:56:55

Proper test for the base ring to be finite field.
----
New commits:


---

Comment by git created at 2016-08-26 13:01:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-08-26 13:10:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-08-26 13:12:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by danielaugot created at 2016-08-26 15:45:05

About the internals and the implementation (I)

* `codes.CyclicCode`, case (3). Why do you check if primitive_element is nice ? Why do not you force it, since the user did not provide any such element in case (3)?

* `find_generator_polynomial` I would be happy to have a proof that the proposed algorithm is correct.

* `find_generator_polynomial` should return a monic polynomial. That would avoid doing the work in the constructor.

* `parity_check_matrix` is cached in the case of cyclic codes and not for general linear codes.

* `defining_set`: it would be nice to be able to give an alternate root as an argument, to see the defining set in another disguise.

* In many places, we have the following unpleasant code

```
            s = 1
            while not (q ** s - 1) % n == 0:
                s += 1
```

   to find the degree of the extension field where lies the nth-root of unity. Sage can compute the splitting field by itself, as follows

```
sage: K.<x>=PolynomialRing(GF(2))
sage: pol=x^31-1
sage: F=pol.splitting_field('y')
sage: F
Finite Field in y of size 2^5
```

  I guess this could be used to have a more pleasant and mathematicall oriented coding style.

C'est tout pour ce soir.

Daniel


---

Comment by git created at 2016-08-26 15:45:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Attachment

A proof of the cyclic code criteria in the "find_generator_polynomial()" method.


---

Comment by jlavauzelle created at 2016-08-29 12:22:55

Hi,

I merged the latest beta (7.4.beta2). I also improved the doc according to Daniel's comments.

About your remarks:
- calling the method `BCH_bound` instead of `bch_bound` would not respect naming conventions;
- I didn't made the `dual_code()` fix yet;
- the problem with the variable name is not easy. A solution could be to internally force it to be `x` (however the code is built), but we don't want this to happen:

```
sage: R = PolynomialRing(GF(2), 'y')
sage: y = R.gen()
sage: g = y + 1
sage: C = codesCyclicCode(g, 5)
sage: C.generator_polynomial() == g
False
```

- in the third construction (3), the user can provide a `primitive_element`;
- I give a proof of my criteria in attachment;
- I agree for the optional alternate root as an argument of `defining_set`. Not done yet;
- concerning the use of the `splitting_field()` method, I'm worrying about its computation cost, as we may only want the extension degree. But I agree your code is more pleasant to read.

Still a WIP (but reviews are welcome).

Julien
----
New commits:


---

Comment by jsrn created at 2016-08-29 13:15:41

Replying to [comment:34 jlavauzelle]:
> - concerning the use of the `splitting_field()` method, I'm worrying about its computation cost, as we may only want the extension degree. But I agree your code is more pleasant to read.

In all places where we computate `s`, we immediately construct the splitting field as well, AFAICS. So we could indeed just use Daniel's loop (otherwise you are right, Julien, that computing the degree is much much faster. But in that case the loop should be wrapped as a function call).

Best,
Johan


---

Comment by git created at 2016-08-31 10:41:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-08-31 10:45:50

Hi,

I fixed issues in `defining_set()` and in `primitive_element()`. I also completely changed `bch_bound()` because it was not very clear and not that much efficient. I think now it's a bit faster.

Now it's really open for review.

Julien


---

Comment by jsrn created at 2016-08-31 11:53:20

Writing a BCH-bound algorithm that is compact and fast yet readable is a fun challenge :-) Here is my proposal, which is shorter than yours and to my mind more readable. I also added the small optimisation that the arithmetic step size doesn't need to be considered beyond `n/2`.

On a related note, shouldn't `bch_bound` always just output `bch_parameters`?


```
def bch_bound(n, D, arithmetic=False):
    def longest_streak(step):
        max_len = 1
        max_offset = 0
        j = 0
        while j < n:
            h = j
            while isD[h*step % n]:
                h += 1
            if h - j > max_len:
                max_offset = j
                max_len = h - j
            j = h + 1
        return (max_len, max_offset)

    isD = [ 1 if d in D else 0 for d in range(n) ]
    if not arithmetic:
        one_len, offset = longest_streak(1)
        return (one_len + 1, (1, offset))
    else:
        step, (max_len, offset) = max([ (step, longest_streak(step)) for step in range(1,n//2) ],
                                      key=lambda (step,(step_len,_)): step_len)
        return (max_len + 1, (step, offset))
```


(This is not a review: I didn't look much at the rest of the code.)


---

Comment by ylchapuy created at 2016-08-31 15:27:17

For both implementation of the `bch_bound`, I could be annoying and set `D = range(n)` ...


---

Comment by jsrn created at 2016-08-31 15:57:03

Replying to [comment:39 ylchapuy]:
> For both implementation of the `bch_bound`, I could be annoying and set `D = range(n)` ...

In which case, in `O(n^2)`, the algorithm returns n+1 as minimum distance of the corresponding code. That input doesn't make much sense from a coding point of view, since it corresponds to the zero code of length n. Which according to some definitions has minimum distance n+1.


---

Comment by danielaugot created at 2016-08-31 16:19:35

Hi

I am a bit concerned with the terminology `primitive_element` where I think it should be `primitive_root` or `primitive_root_of_unity`.

In the finite field realm, `primitive_element` really means a generator of the  cyclic group of all invertible elements. 

Even wikipedia says so https://en.wikipedia.org/wiki/Primitive_element_(finite_field).

On the other side, https://en.wikipedia.org/wiki/Root_of_unity#primitive really means what you want.

So `primitive_element` here does not respect the standard finite field terminology.

Daniel


---

Comment by ylchapuy created at 2016-08-31 16:25:38

Replying to [comment:40 jsrn]:
> Replying to [comment:39 ylchapuy]:
> > For both implementation of the `bch_bound`, I could be annoying and set `D = range(n)` ...
> 
> In which case, in `O(n^2)`, the algorithm returns n+1 as minimum distance of the corresponding code. That input doesn't make much sense from a coding point of view, since it corresponds to the zero code of length n. Which according to some definitions has minimum distance n+1.

You may have to wait a bit more than `O(n^2)`: ` while table_D[i*j % n] == 1: ...` and `table_D` is all `1`

From a coding point of view, I do agree this doesn't make sense, but is the user aware of that?


---

Comment by danielaugot created at 2016-08-31 16:27:23

Hi Yann

thank you for looking at this ! And please be annoying : since our codes may be tortured with various operations for combining codes, it could well happen that someone ends with such a situation.

Concerning the cyclic code on length `n` which are `{0}`, I think n+1 is a correct math answer for the minimum distance d. At least it gives the MDS bound k+d=n+1. 

So both Yann's remark and Johan's answer are correct.

Best,

Daniel


---

Comment by jsrn created at 2016-09-01 07:02:04

Replying to [comment:42 ylchapuy]:
> You may have to wait a bit more than `O(n^2)`: ` while table_D[i*j % n] == 1: ...` and `table_D` is all `1`

Hehe, yeah good point :-)


---

Comment by git created at 2016-09-01 08:02:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-09-01 08:11:19

Hi,

Thanks for all your comments! According to them, I made some changes:
- Johan, I picked your proposal (a way more readable, I didn't know it was possible to add optional parameters to the `max()` function, that's nice :)). I just replaced `n//2` by `n//2+1` in a loop.
- I added some sanity-checks and fixed the problem raised by Yann (thanks!). As you said, `n+1` seems a good bound (at least) for the minimum distance of the zero code.
- I replaced `primitive_element` by `primitive_root`.

Still open for review.

Julien


---

Comment by ylchapuy created at 2016-09-01 08:48:19

You may still come to an infinite loop if you skip the `gcd`. Try e.g. `bch_bound(6, [0,2,4], True)`. Also the `key` trick is nice but useless, just reorder the tuple to `(longest_streak(step), step)` and be happy with the lexicographic order.

I might read the rest of this if I find some more time.


---

Comment by ylchapuy created at 2016-09-01 12:47:27

Some remarks:
 * arguments are silently ignored if you feed `__init__` too much (e.g. give a polynomial and a code)
 * line continuations are considered bad style in Python, prefer parentheses, braces, etc (see [https://www.python.org/dev/peps/pep-0008/#id19](https://www.python.org/dev/peps/pep-0008/#id19))
 * use sorted instead of .sort() when possible
 * why do your own caching and not using ``@`cached_method` (e.g. for check_polynomial)
 * instead of `self._known_generator_matrix` you could just check `self.generator_matrix.cache is not None`


---

Comment by git created at 2016-09-02 10:13:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-09-02 10:16:19

Hi Yann,

Thanks again for you helpful comments (especially concerning the python/sage tricks). I pushed the corresponding fixes.

I also merged with the latest beta.

Julien


---

Comment by danielaugot created at 2016-09-06 12:03:12

So much for the 7.4beta3. develop does not compile, because linbox fails to compile on my fedora24. I can not test the ticket.


---

Comment by danielaugot created at 2016-09-16 15:56:28

Hi

Line 425, there is this:

```
            if primitive_root is not None:
                if (primitive_root not in Fsplit or
                    multiplicative_order(primitive_root) != n):
                    raise ValueError("primitive_root has to be an element of multiplicative order n in the extension field used to compute the generator polynomial")
```


where `primitive_root` has been provided by the user in case (3) of the constructor. But `Fsplit ` has been constructed line 420:

```
            while not (q ** s - 1) % n == 0:
                s += 1

            if s == 1: # splitting field is F
                Fsplit = F
            else: # must compute a splitting field
                Fsplit, F_to_Fsplit = F.extension(Integer(s), map = True)
```

this implies that the user may have provided his own, mathematically correct `primitive_root` with his own finite field, which then will not be accepted by the code on line 425, because `Fsplit` may be different from the field of user's `primitive_root` (from sage point of view)

The following example triggers the problem

```
sage: F=GF(16,'a')
sage: K=GF(256,'X')
sage: alpha=K.primitive_element()
sage: C=codes.CyclicCode(length = 255, field = F, D = [1,2], primitive_root=alpha)
```

and casts the error

```
ValueError: primitive_root has to be an element of multiplicative order n in the extension field used to compute the generator polynomial
```


It would be better to check first for the `primitive_root`, and then build `Fsplit` according to the one given by the user and build `Fsplit` later if needed.

Daniel


---

Comment by git created at 2016-09-21 08:43:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-09-21 08:44:57

Hi Daniel,

Thanks for the comment. You're completely right, I fixed the bug and merged with the latest beta.

Still open for review.

Julien


---

Comment by git created at 2016-09-21 08:50:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-09-21 08:51:47

Well, I forgot to fix doctests. Done now.


---

Comment by ylchapuy created at 2016-09-21 12:05:42

Hi,

* futurize imports (see e.g. #20945)
* you should avoid bare except (even if `RelativeFiniteFieldExtension(GF(5), GF(7))` fails in a strange way, which should probably be another ticket), at least check assertions with `AssertionError`
* you should add doctests for exceptions too

finally other more cosmetic remarks:
* `_complete_list` is always used after `.coefficients(sparse = False)`, you could go one step further with 

```python
def _to_complete_list(poly, list_len):
    L = poly.coefficients(sparse = False)
    return L + [poly.base_ring().zero()] * (list_len - len(L))
```

 ( for `parity_check_polynomial` try `h.reverse()`)
* regarding comment:31 , why not `Zmod(n)(q).multiplicative_order()`
* use `root.log(alpha)` (special cased for each field) instead of `discrete_log` (generic)
* here are some one liner you could use:
 - `g = gcd(R(row.list()) for row in G)`
 - `if any(vector(c[k:] + c[:k]) not in code for k in range(n)):`
 - `H = matrix([l[-i:] + l[:-i] for i in range(n-k)])`
 - `G = matrix([l[-i:] + l[:-i] for i in range(k)])`


---

Comment by git created at 2016-09-21 13:41:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-09-21 13:43:43

Hi Yann,

Thanks again for the helpful comments. I did the modification.

Julien


---

Comment by ylchapuy created at 2016-09-22 07:34:57

Hi,

almost good, here are some more remarks:

* line 413, probably `ValueError as e` but what is the point of catching an exception to reraise it?

* found with [flake8](https://pypi.python.org/pypi/flake8):

```sh
cyclic_code.py:60:1: F401 '.decoder.Decoder' imported but unused
cyclic_code.py:66:1: F401 'sage.rings.polynomial.polynomial_ring.PolynomialRing_general' imported but unused
cyclic_code.py:67:1: F401 'sage.rings.finite_rings.finite_field_constructor.GF' imported but unused
cyclic_code.py:69:1: F401 'sage.categories.homset.Hom' imported but unused
cyclic_code.py:70:1: F401 'sage.groups.generic.discrete_log' imported but unused
cyclic_code.py:71:1: F401 'sage.misc.functional.multiplicative_order' imported but unused
cyclic_code.py:103:5: F841 local variable 'x' is assigned to but never used
cyclic_code.py:433:13: F841 local variable 'x' is assigned to but never used
cyclic_code.py:725:9: F841 local variable 'R' is assigned to but never used
```


plus many [PEP8](https://www.python.org/dev/peps/pep-0008/) comments, mainly:
* no space around `=` for keyword arguments
* whitespace after `[` or before `]`


---

Comment by git created at 2016-09-23 12:39:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-09-23 12:44:09

Hi Yann,

I didn't know flake8, great tool. I improved the coding style according to it.

Julien


---

Comment by git created at 2016-09-25 17:07:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-09-25 17:08:21

Hi,

I updated to the latest beta (7.4.beta6).

Still open for review.

Julien


---

Comment by jlavauzelle created at 2016-09-25 17:08:21

Changing keywords from "" to "sd75".


---

Comment by git created at 2016-10-19 12:30:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ylchapuy created at 2016-10-20 16:06:39

Changing status from needs_review to positive_review.


---

Comment by ylchapuy created at 2016-10-20 16:06:39

Previous comments have been taken into account, tests pass (failures on gentoo seem unrelated), coverage for the new file is 100%, doc builds and looks OK.

All good for me.


---

Comment by vbraun created at 2016-10-20 22:02:46

Conflicts; Please wait for next beta and then fix the references:

```
[dochtml] [coding   ] /mnt/disk/home/release/Sage/local/lib/python2.7/site-packages/sage/coding/cyclic_code.py:docstring of sage.coding.cyclic_code:1: WARNING: citation not found: R06
[dochtml] [coding   ] /mnt/disk/home/release/Sage/local/lib/python2.7/site-packages/sage/coding/cyclic_code.py:docstring of sage.coding.cyclic_code:24: WARNING: citation not found: R06
```



---

Comment by vbraun created at 2016-10-20 22:02:46

Changing status from positive_review to needs_work.


---

Comment by git created at 2016-10-22 21:39:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-10-23 08:06:11

Changing status from needs_work to needs_review.


---

Comment by git created at 2016-11-10 14:03:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jlavauzelle created at 2016-11-10 14:07:55

Hi,

I updated to the latest beta (7.5.beta2) and fixed conflicts.

Following #21691, I also produced shorter printing for cyclic codes (basically, I removed the generator polynomial which can have a quite long printing).

Best,

Julien


---

Comment by danielaugot created at 2017-01-03 09:14:45

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-01-18 20:39:55

Resolution: fixed
