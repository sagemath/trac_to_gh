# Issue 12246: adding Delsarte bound for codes

Issue created by migration from https://trac.sagemath.org/ticket/12418

Original creator: dimpase

Original creation time: 2012-02-03 08:08:17

Assignee: wdj

CC:  jpang kini wdj ncohen ppurka ptrrsn_1

Delsarte bound for codes, aka Linear Programming bound, is easy to implement in Sage.
Here is a quick and dirty code that does it; so the problem would be to integrate this properly.

```
def Kra(n,q,l,i): # K^{n,q}_l(i), i.e Krawtchouk polynomial
   return sum([((-1)**j)*((q-1)**(l-j))*binomial(i,j)*binomial(n-i,l-j) 
                              for j in range(l+1)])

def roundres(x): # this is a quick and unsafe way to round the result...
   import math
   tol = 0.0001
   if math.ceil(x)-x < tol:
      return int(math.ceil(x))
   if x-math.floor(x) < tol:
      return int(math.floor(x))
   return x

# @cached_function
def delsarte_bound(n, q, d, d_star=1, q_base=0, return_log=True,\
                    isinteger=False, return_data=False):
   p = MixedIntegerLinearProgram(maximization=True)
   A = p.new_variable(integer=isinteger) # A>=0 is assumed
   p.set_objective(sum([A[r] for r in range(n+1)])) 
   p.add_constraint(A[0]==1)
   for i in range(1,d):
      p.add_constraint(A[i]==0)
   for j in range(1,n+1): 
      rhs = sum([Kra(n,q,j,r)*A[r] for r in range(n+1)])
      if j >= d_star: 
        p.add_constraint(0*A[0] <= rhs) 
      else: # rhs is proportional to j-th weight of the dual code
        p.add_constraint(0*A[0] == rhs) 
   try:
      bd=p.solve()
   except sage.numerical.mip.MIPSolverException, exc:
      print "Solver exception: ", exc, exc.args
      if return_data:
         return A,p,False
      return False
   if q_base > 0: # rounding the bound down to the nearest power of q_base,
                  # for q=q_base^m
#      qb = factor(q).radical()
#      if len(qb) == 1:
#         base = qb.expand()
#         bd = base^int(log(bd, base=base))
         if return_log: 
#            bd = int(log(roundres(bd), base=q_base)) # unsafe: 
                                                      # loss of precision
            bd = roundres(log(bd, base=q_base))
         else:
#            bd = q_base^int(log(roundres(bd), base=q_base))
            bd = q_base^roundres(log(bd, base=q_base))
   if return_data:
      return A,p,bd
   return bd
```


d_star is the minimal distance  of the dual code (if it exists at all) 
If q_base is 0, just compute the upper bound.
If q_base is >0, it is assumed to be a prime power, and the code assumed
to be additive over this field (i.e. the dual code exists,and its weight enumerator is
obtained by applying `MacWilliams transform` --- the matrix A of the LP times the
weight enumerator of our code), then the output is the corr. dimension, i.e. 
`floor(log(bound, q_base))`.


---

Comment by ncohen created at 2012-02-06 12:12:10

(GLPK can solve non-integer rational LP. It is not exposed, but may not be too hard either)


---

Comment by ppurka created at 2012-02-07 14:22:47

The function named `delsarte_bound` should be renamed to something like `delsarte_bound_hamming_space`. This is so that in future other functions like `delsarte_bound_johnson_space`, `delsarte_bound_permutation_space`, etc can be added easily, without having inconsistencies in naming.


---

Comment by dimpase created at 2012-06-08 14:47:15

a prototype implementation


---

Attachment


---

Comment by dimpase created at 2012-10-28 16:39:58

Changing status from new to needs_review.


---

Comment by ppurka created at 2012-11-07 10:26:04

I think the `Krawtchouk` polynomial could be computed explicitly by not making repeated calls to `binomial`. This should speed it up. I have something like this in mind:

```
def Krawtchouk2(n,q,l,i):
    # Use the expression in equation (55) of MacWilliams & Sloane, pg 151
    # We write jth term = some_factor * (j-1)th term
    kraw = jth_term = (q-1)**l * binomial(n, l) # j=0
    for j in range(1,l+1):
        jth_term *= -q*(l-j+1)*(i-j+1)/((q-1)*j*(n-j+1))
        kraw += jth_term
    return kraw

n,q,l,i = 10,8,7,5
timeit('Krawtchouk2(n,q,l,i)')
timeit('Krawtchouk (n,q,l,i)')
print Krawtchouk2(n,q,l,i) == Krawtchouk(n,q,l,i)

625 loops, best of 3: 53.3 µs per loop
625 loops, best of 3: 205 µs per loop
True
```


I noticed that sage handles nonintegral components in the binomial, so the expression for the `Krawtchouk` already works with nonintegral `n` and `x`.

```
n,q,l,i = 10.6,8,7,5.4
#timeit('Krawtchouk3(n,q,l,i)')
timeit('Krawtchouk2(n,q,l,i)')
timeit('Krawtchouk (n,q,l,i)')
print Krawtchouk2(n,q,l,i) == Krawtchouk(n,q,l,i)
print Krawtchouk2(n,q,l,i), Krawtchouk(n,q,l,i)

625 loops, best of 3: 382 µs per loop
125 loops, best of 3: 4.74 ms per loop
False
93582.0160001147 93582.0159999999
```



---

Comment by ppurka created at 2012-11-07 10:40:40

Can you mention when it guarantees a weight spectrum? Would doing an `ILP` make it a proper weight spectrum?

```
   - ``return_data`` -- if ``True``, return a weights vector, which actually need not 
     be a proper weight enumerator, or even have integer entries, and the LP. 
```


Also, I think the term `weight enumerator` refers to the `weight enumerator polynomial`. Perhaps using `weight distribution` or `distance distribution` is more appropriate here.


---

Comment by dimpase created at 2012-11-07 14:26:36

Replying to [comment:12 ppurka]:
> I think the `Krawtchouk` polynomial could be computed explicitly by not making repeated calls to `binomial`. This should speed it up. 

It's probably even faster to compute by using recurrence relations, but I don't think it's important here: LP solving timing clearly dominates the rest. 

By the way, would it be interesting to include an option to compute bounds on codes with a prescribed forbidden 
set of distances, rather than just [1..d] ? It's a trivial add-on.
I did this in a prototype code for Johnson schemes, [here](http://mathoverflow.net/questions/111603/intersecting-4-sets/111647#111647).

Any other interesting schemes to include? (Johnson scheme takes care of constant weight binary codes, as you know.)


---

Comment by ppurka created at 2012-11-07 14:59:39

Replying to [comment:14 dimpase]:
> Replying to [comment:12 ppurka]:
> > I think the `Krawtchouk` polynomial could be computed explicitly by not making repeated calls to `binomial`. This should speed it up. 
> 
> It's probably even faster to compute by using recurrence relations, but I don't think it's important here: LP solving timing clearly dominates the rest.

The point is that someone might try to use these polynomials more generally in a separate context. They are not defined anywhere else in Sage, so anyone who tries to use them will use this one.
 
> By the way, would it be interesting to include an option to compute bounds on codes with a prescribed forbidden 
> set of distances, rather than just [1..d] ? It's a trivial add-on.
> I did this in a prototype code for Johnson schemes, [here](http://mathoverflow.net/questions/111603/intersecting-4-sets/111647#111647).

Wow! You have the Johnson scheme too?! Sure, add them all in!! Do you use the polynomials used by Aaltonen?

> Any other interesting schemes to include? (Johnson scheme takes care of constant weight binary codes, as you know.)

LP for permutation codes would be interesting. There are not too many good results known there. IIRC, it uses Charlier polynomials.

EDIT: FWIW, it is Charlier polynomials.


---

Comment by ppurka created at 2012-11-07 15:10:11

Oh, I forgot to add. Forbidden distances will be nice as well. I think only some special cases achieve the closed form solutions. In general, still not much is known. It looks like you only need to drop distances `d_1,...,d_m` instead of `1,...,d`, right?

How about introducing an extra keyword called `forbidden_distances` or `exclude_distances`, which defaults to `1,...,d`?


---

Comment by dimpase created at 2012-11-07 15:18:37

Replying to [comment:16 ppurka]:
> Replying to [comment:14 dimpase]:
> > Replying to [comment:12 ppurka]:
> > > I think the `Krawtchouk` polynomial could be computed explicitly by not making repeated calls to `binomial`. This should speed it up. 
> > 
> > It's probably even faster to compute by using recurrence relations, but I don't think it's important here: LP solving timing clearly dominates the rest.
> 
> The point is that someone might try to use these polynomials more generally in a separate context. They are not defined anywhere else in Sage, so anyone who tries to use them will use this one.

Actually, I have most discrete orthogonal polynomials arising in the classical P- and Q- polynomial schemes 
[implemented](https://bitbucket.org/dimpase/qcode/src/9e3b79dc71992aa2a8ea170dbd13f9f373772411/aw.sage?at=default), although it's neither polished nor optimized.

[
>  
> > By the way, would it be interesting to include an option to compute bounds on codes with a prescribed forbidden 
> > set of distances, rather than just [1..d] ? It's a trivial add-on.
> > I did this in a prototype code for Johnson schemes, [here](http://mathoverflow.net/questions/111603/intersecting-4-sets/111647#111647).
> 
> Wow! You have the Johnson scheme too?! Sure, add them all in!! Do you use the polynomials used by Aaltonen?

I [use](https://bitbucket.org/dimpase/qcode/src/9e3b79dc71992aa2a8ea170dbd13f9f373772411/aw.sage?at=default) the descriptions in the book "Algebraic Combinatorics I" by E.Bannai and T.Ito.  
Something known as [Eberlein polynomials](http://mathworld.wolfram.com/EberleinPolynomial.html).

> 
> > Any other interesting schemes to include? (Johnson scheme takes care of constant weight binary codes, as you know.)
> 
> LP for permutation codes would be interesting. There are not too many good results known there. IIRC, it uses Chebychev polynomials(?).

yes, this should be perfectly doable.


---

Comment by ppurka created at 2012-11-07 15:23:58

Replying to [comment:18 dimpase]:
> I [use](https://bitbucket.org/dimpase/qcode/src/9e3b79dc71992aa2a8ea170dbd13f9f373772411/aw.sage?at=default) the descriptions in the book "Algebraic Combinatorics I" by E.Bannai and T.Ito.  
> Something known as [Eberlein polynomials](http://mathworld.wolfram.com/EberleinPolynomial.html).

That's for the binary case. For the q-ary case it is a product of Krawtchouk and Hahn, if I recall properly. Let me fish out the paper; I will send it to you.


---

Comment by dimpase created at 2013-01-07 06:44:48

Replying to [comment:12 ppurka]:
> I think the `Krawtchouk` polynomial could be computed explicitly by not making repeated calls to `binomial`. This should speed it up. I have something like this in mind:

This can be further optimized by using Horner's rule. I'll do this, and leave the rest (other schemes) for another ticket, OK?


---

Comment by ppurka created at 2013-01-07 07:01:41

Replying to [comment:20 dimpase]:
> This can be further optimized by using Horner's rule. I'll do this, and leave the rest (other schemes) for another ticket, OK?

Yes, yes. One space/polynomial at a time. Just Hamming space in this ticket is OK.


---

Attachment

update of the patch - for reviewing only


---

Comment by dimpase created at 2013-01-08 03:37:14

Please review. I added a Kravchouck speedup, and cleaned up docstrings as requested.


---

Comment by dimpase created at 2013-01-08 05:29:35

improved docstrings for `return_data`


---

Comment by ppurka created at 2013-01-08 09:28:25

Thanks for the update. I have some general comments. Will look into this patch in more detail too.
1. There are lot of trailing whitespaces. The patchbot will complain. :)
2. What is the point of this portion of the code? Can't it be replaced by `kk = ZZ(log(q, q_base))`?

```python
   kk = 0
   while q_base**kk < q:
      kk += 1
```

3. There is another bit further down:

```python
      m = -1
      while q_base**(m+1) < bd:
        m += 1
      if q_base**(m+1) == bd:
        m += 1
```

4. Also, I don't think this deprecation is necessary any more. The ticket you cited is over 2 years old.

```diff
-def dimension_upper_bound(n,d,q):
+@rename_keyword(deprecation=6094, method="algorithm")
+def dimension_upper_bound(n,d,q,algorithm=None):
```


*Edit:* Sorry. It seems `ZZ` doesn't work but `int(log(..))` does work.


---

Comment by dimpase created at 2013-01-08 13:25:52

Replying to [comment:24 ppurka]:
> Thanks for the update. I have some general comments. Will look into this patch in more detail too.
> 1. There are lot of trailing whitespaces. The patchbot will complain. :)
I've just uploaded an update with all the trailing spaces removed.

> 2. What is the point of this portion of the code? Can't it be replaced by `kk = ZZ(log(q, q_base))`?
> {{{#!python
>    kk = 0
>    while q_base**kk < q:
>       kk += 1
> }}}
> 3. There is another bit further down:
> {{{#!python
>       m = -1
>       while q_base**(m+1) < bd:
>         m += 1
>       if q_base**(m+1) == bd:
>         m += 1
> }}}

this came from an older piece of plain Python. Then I struggled with log() quite a bit, and finally gave up on it and rolled my own. 


> 4. Also, I don't think this deprecation is necessary any more. The ticket you cited is over 2 years old.
> {{{#!diff
> -def dimension_upper_bound(n,d,q):
> +`@`rename_keyword(deprecation=6094, method="algorithm")
> +def dimension_upper_bound(n,d,q,algorithm=None):
> }}}

I blindly copied from `sage/coding/code_bounds.py`
Should the whole file be cleaned out of these?
By the way, plural `methods` slipped through this decorator...


> 
> *Edit:* Sorry. It seems `ZZ` doesn't work but `int(log(..))` does work.


---

Comment by dimpase created at 2013-01-10 12:40:51

Replying to [comment:24 ppurka]:
> Thanks for the update. I have some general comments. Will look into this patch in more detail too.

> 2. What is the point of this portion of the code? Can't it be replaced by `kk = ZZ(log(q, q_base))`?

yes, it is basically what it does; this is also needed to do a Gomory-style cut which might be available due to the corresponding rounding.


---

Comment by ppurka created at 2013-01-24 11:37:11

Ok. I am finally getting some time to look into this again. Here are some comments.
1. `Krawtchouk` is missing a doctest.
2. There is no need of `\` in `def delsarte_bound_...`
3. There are still many trailing whitespaces. If you use vim then you can try this command `:%s/[ ]\+$//`
4. `   - ``q`` -- the length of the alphabet` -- this should be "the _size_ of the alphabet"
    Also I think the the options `q` and `d` can be swapped to be in the order in which they appear
    in the function definition.
5. `- ``solver`` -- the LP/ILP solved ` --- this should be _solver_.
   What other solvers are present? They should be listed as options in this
   variable.
6. `The bound on the size of the F_2-codes` --- this should be _``F_2``_
7.  ` - ``return_data`` ` --- As it is currently written in the description, it is unclear what this is returning. It looks like the first component is an MIP variable (and not a vector), and the second component is the MILP itself. At a first glance in your doctests, it looks like we need to understand how the MILP works in order to get the values of the weight distribution. Should we just return the weight distribution itself?  A weight distribution vector can be returned by doing `p.get_values(a).values()`.
8. The backend should automatically handle "isinteger=True" at least so that it is functional. Currently I get a very generic Exception (why is this only "Exception"?). Maybe it is automatically handled in a later version of sage? I will have to check against 5.6.beta1 and higher:

```
Exception: This backend does not handle integer variables ! Read the doc !
```

9. Why do we need the second function? We already discussed this off-ticket - I will wait for your generic function.
10. `(**this option is currenly disabled, cf. trac #13667**). ` --- it should be _`:trac:`13667``_ since it will be in the documentation.
11. `    Parameter "algorithm" has the same meaning as in codesize_upper_bound() ` --- This should be _`:func:`codesize_upper_bound``_.
12. `      print "Wrong q_base=", q_base, " for q=", q, kk` --- This can be formatted python3 style as

```
      print "Wrong q_base={} for q={} {}".format(q_base, q, kk)
```

13. According to the patchbot this needs rebasing against some higher version of 5.6. I have only beta0 here; I will check it against rc1 after I have compiled that.
14. EDIT: I forgot.. the deprecation notice should go. It has been two years. If code_bounds needs to be cleaned then I can do that.

EDIT: Update backticks in 6., 10., 11.


---

Comment by knsam created at 2013-02-20 16:45:16

Changing status from needs_review to needs_work.


---

Comment by knsam created at 2013-02-20 16:45:16

This patch needs to address referee's comments. I am changing this to `needs_work` in the meanwhile.


---

Attachment

rebased for Sage 5.10 and fixed some outstanding issues


---

Comment by dimpase created at 2013-06-15 13:53:03

Replying to [comment:27 ppurka]:

rebased to Sage 5.10 and fixed the following:
> 1. `Krawtchouk` is missing a doctest.
> 2. There is no need of `\` in `def delsarte_bound_...`
> 3. There are still many trailing whitespaces. If you use vim then you can try this command `:%s/[ ]\+$//`
> 4. `   - ``q`` -- the length of the alphabet` -- this should be "the _size_ of the alphabet"
>     Also I think the the options `q` and `d` can be swapped to be in the order in which they appear
>     in the function definition.
I swapped the docstrings instead.

> 5. `- ``solver`` -- the LP/ILP solved ` --- this should be _solver_.
>    What other solvers are present? They should be listed as options in this
>    variable.
> 6. `The bound on the size of the F_2-codes` --- this should be _``F_2``_
(and other `F_`)

> 8. The backend should automatically handle "isinteger=True" at least so that it is functional. Currently I get a very generic Exception (why is this only "Exception"?). Maybe it is automatically handled in a later version of sage? I will have to check against 5.6.beta1 and higher:

The PPL backend does not handle ILP. One might want to improve the way it reports this error, but not on this ticket.



> {{{
> Exception: This backend does not handle integer variables ! Read the doc !
> }}}

> 11. `    Parameter "algorithm" has the same meaning as in codesize_upper_bound() ` --- This should be _`:func:`codesize_upper_bound``_.
> 13. According to the patchbot this needs rebasing against some higher version of 5.6. I have only beta0 here; I will check it against rc1 after I have compiled that.
Rebased.


---

Comment by ppurka created at 2013-06-22 08:27:48

Replying to [comment:30 dimpase]:
> Work issues set to code refactoring

Oh good. I was wondering if you didn't want to do that in this patch.


---

Comment by dimpase created at 2013-07-01 14:30:55

rebased for Sage 5.10 and fixed some outstanding issues


---

Attachment

code refactoring - for review only


---

Comment by dimpase created at 2013-07-01 14:33:49

Changing status from needs_work to needs_review.


---

Comment by chapoton created at 2013-07-05 15:21:01

instructions for the bot:

apply 12418_delsart_bounds.patch


---

Comment by chapoton created at 2013-07-05 18:12:06

Changing status from needs_review to needs_work.


---

Comment by chapoton created at 2013-07-05 18:12:06

* doctest covering is not 100%

* you can use the wikipedia role for example `:wikipedia:`Togo``

* it would be better to lazy_import the new functions, maybe ?


---

Comment by dimpase created at 2013-07-05 19:06:29

Replying to [comment:34 chapoton]:
> * doctest covering is not 100%

hmm, what function do you mean? there is an internal function which is not exported; I don't think it needs a doctest, does it?

> 
> * you can use the wikipedia role for example `:wikipedia:`Togo``

where?

> 
> * it would be better to lazy_import the new functions, maybe ?

I have no idea. Is there a stated policy on this?
Having said this, perhaps it's better to re-lazy_import the whole `sage/coding`, something for another ticket?


---

Comment by chapoton created at 2013-07-05 19:33:31

* well, the bot complains about the missing doctest, so I guess that the internal function needs one indeed

* instead of ``en.wikipedia.org/wiki/Kravchuk_polynomials <http://en.wikipedia.org/wiki/Kravchuk_polynomials>`_`

you can write `:wikipedia:`Kravchuk_polynomials``

* the bot is not happy either on adding something new in the global namespace. It is better for the startup time of sage to try and make the bot happy on this point, imho.


---

Attachment

update to fix the remaining issues


---

Comment by dimpase created at 2013-07-06 22:01:52

Changing status from needs_work to needs_review.


---

Comment by ppurka created at 2013-07-18 07:45:03

The patch looks OK to me now. Though I would have really liked the Q-matrix to be passed to the linear program (for instance to the delsarte LP building function), this can be done in a future patch when LP for other spaces are introduced.


---

Comment by ppurka created at 2013-07-18 07:45:03

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2013-08-16 21:10:45

Resolution: fixed
