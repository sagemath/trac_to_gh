# Issue 11589: faster zero matrix creation

archive/issues_011417.json:
```json
{
    "body": "Currently, we perform a matrix copy whenever we create a new zero matrix. This is undesirable for two reasons:\n\n* it is slower than creating a new matrix from scratch for some matrices\n* it eats up RAM (we create two instead of one matrix)\n\nSee also the discussion on [sage-devel]:\nhttp://groups.google.com/group/sage-devel/browse_thread/thread/478fb19ecb724be0\n\nApply all three patches.\n\nAssignee: jason, was\n\nCC:  simonking\n\nResolution: fixed\n\nAuthor: Martin Albrecht, Simon King\n\nReviewer: Simon King, Martin Albrecht\n\nMerged: sage-4.7.2.alpha1\n\nIssue created by migration from https://trac.sagemath.org/ticket/11589\n\n",
    "closed_at": "2011-08-02T19:47:01Z",
    "created_at": "2011-07-11T20:16:50Z",
    "labels": [
        "component: linear algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-4.7.2",
    "title": "faster zero matrix creation",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11589",
    "user": "https://github.com/malb"
}
```
Currently, we perform a matrix copy whenever we create a new zero matrix. This is undesirable for two reasons:

* it is slower than creating a new matrix from scratch for some matrices
* it eats up RAM (we create two instead of one matrix)

See also the discussion on [sage-devel]:
http://groups.google.com/group/sage-devel/browse_thread/thread/478fb19ecb724be0

Apply all three patches.

Assignee: jason, was

CC:  simonking

Resolution: fixed

Author: Martin Albrecht, Simon King

Reviewer: Simon King, Martin Albrecht

Merged: sage-4.7.2.alpha1

Issue created by migration from https://trac.sagemath.org/ticket/11589





---

archive/issue_comments_155314.json:
```json
{
    "body": "Changing author from \"\" to \"Martin Albrecht, Simon King\"",
    "created_at": "2011-07-11T20:44:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155314",
    "user": "https://github.com/malb"
}
```

Changing author from "" to "Martin Albrecht, Simon King"



---

archive/issue_comments_155315.json:
```json
{
    "body": "<a id='comment:1'></a>Timings on my machine:\n\n**with patch**\n\n```python\nsage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 104 \u00b5s per loop\n625 loops, best of 3: 108 \u00b5s per loop\n625 loops, best of 3: 115 \u00b5s per loop\n\nsage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 100 \u00b5s per loop\n625 loops, best of 3: 448 \u00b5s per loop\n125 loops, best of 3: 1.65 ms per loop\n```\n\n**without patch**\n\n```python\nsage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 97.6 \u00b5s per loop\n625 loops, best of 3: 108 \u00b5s per loop\n625 loops, best of 3: 128 \u00b5s per loop\n\nsage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 94.1 \u00b5s per loop\n625 loops, best of 3: 502 \u00b5s per loop\n125 loops, best of 3: 2.48 ms per loop\nsage: \n\n```",
    "created_at": "2011-07-11T20:44:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155315",
    "user": "https://github.com/malb"
}
```

<a id='comment:1'></a>Timings on my machine:

**with patch**

```python
sage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 104 µs per loop
625 loops, best of 3: 108 µs per loop
625 loops, best of 3: 115 µs per loop

sage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 100 µs per loop
625 loops, best of 3: 448 µs per loop
125 loops, best of 3: 1.65 ms per loop
```

**without patch**

```python
sage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 97.6 µs per loop
625 loops, best of 3: 108 µs per loop
625 loops, best of 3: 128 µs per loop

sage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 94.1 µs per loop
625 loops, best of 3: 502 µs per loop
125 loops, best of 3: 2.48 ms per loop
sage: 

```



---

archive/issue_comments_155316.json:
```json
{
    "body": "<a id='comment:2'></a>Hi Martin,\n\nThank you for creating the patch!\n\nI don't like that the timings became a little slower for small matrices. We should try to find out why that happens.\n\nI think we should use calloc *only* when the argument `entries` is not a list. Namely, *if* it is a list then the matrix will be initialised by direct assignments anyway. Hence, in that case there is no need to initialise with calloc.\n\nDid you carefully determine the threshold for which calloc becomes faster than copying? Or is \"nrows, ncols > 100\" just a guess?\n\nCheers,\n\nSimon",
    "created_at": "2011-07-11T21:32:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155316",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>Hi Martin,

Thank you for creating the patch!

I don't like that the timings became a little slower for small matrices. We should try to find out why that happens.

I think we should use calloc *only* when the argument `entries` is not a list. Namely, *if* it is a list then the matrix will be initialised by direct assignments anyway. Hence, in that case there is no need to initialise with calloc.

Did you carefully determine the threshold for which calloc becomes faster than copying? Or is "nrows, ncols > 100" just a guess?

Cheers,

Simon



---

archive/issue_comments_155317.json:
```json
{
    "body": "<a id='comment:3'></a>Replying to [SimonKing](#comment%3A2):\n> I don't like that the timings became a little slower for small matrices. We should try to find out why that happens.\n\n\nWe'll also have to do more careful timings to establish there really was a regression. I'm not 100% sure it's not a fluke.\n\n> I think we should use calloc *only* when the argument `entries` is not a list. Namely, *if* it is a list then the matrix will be initialised by direct assignments anyway. Hence, in that case there is no need to initialise with calloc.\n\n\nGood point.\n\n> Did you carefully determine the threshold for which calloc becomes faster than copying? Or is \"nrows, ncols > 100\" just a guess?\n\n\nAn educated guess, i.e. I did look at some timings but it's not carefully tuned (and probably machine dependent).",
    "created_at": "2011-07-11T22:10:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155317",
    "user": "https://github.com/malb"
}
```

<a id='comment:3'></a>Replying to [SimonKing](#comment%3A2):
> I don't like that the timings became a little slower for small matrices. We should try to find out why that happens.


We'll also have to do more careful timings to establish there really was a regression. I'm not 100% sure it's not a fluke.

> I think we should use calloc *only* when the argument `entries` is not a list. Namely, *if* it is a list then the matrix will be initialised by direct assignments anyway. Hence, in that case there is no need to initialise with calloc.


Good point.

> Did you carefully determine the threshold for which calloc becomes faster than copying? Or is "nrows, ncols > 100" just a guess?


An educated guess, i.e. I did look at some timings but it's not carefully tuned (and probably machine dependent).



---

archive/issue_comments_155318.json:
```json
{
    "body": "<a id='comment:4'></a>Attachment [trac_11589.patch](tarball://root/attachments/some-uuid/ticket11589/trac_11589.patch) by @malb created at 2011-07-11 22:11:42\n\nI updated the patch to use malloc() if entries is no list.",
    "created_at": "2011-07-11T22:11:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155318",
    "user": "https://github.com/malb"
}
```

<a id='comment:4'></a>Attachment [trac_11589.patch](tarball://root/attachments/some-uuid/ticket11589/trac_11589.patch) by @malb created at 2011-07-11 22:11:42

I updated the patch to use malloc() if entries is no list.



---

archive/issue_comments_155319.json:
```json
{
    "body": "<a id='comment:5'></a>Replying to [malb](#comment%3A4):\n> I updated the patch to use malloc() if entries is no list.\n\n\nYou mean: Use malloc *if* (and only if) it is a list. At least that is what you do in the patch (and coincides with what I had done as well).",
    "created_at": "2011-07-11T23:20:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155319",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>Replying to [malb](#comment%3A4):
> I updated the patch to use malloc() if entries is no list.


You mean: Use malloc *if* (and only if) it is a list. At least that is what you do in the patch (and coincides with what I had done as well).



---

archive/issue_comments_155320.json:
```json
{
    "body": "<a id='comment:6'></a>Sorry, yes ... where's my head",
    "created_at": "2011-07-11T23:50:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155320",
    "user": "https://github.com/malb"
}
```

<a id='comment:6'></a>Sorry, yes ... where's my head



---

archive/issue_comments_155321.json:
```json
{
    "body": "<a id='comment:7'></a>Hi Martin,\n\nI have a guess why the patch isn't as quick as it should be: It is the line\n\n```\n    return self.__matrix_class(self, 0, coerce=coerce, copy=copy) \n```\nIf you pass the value 0, then the matrix is initialised as a diagonal matrix with 0 on the diagonal -- which means that time is wasted by initialising the diagonal twice.\n\nBetter would be to pass `self, None, coerce=coerce, copy=copy`. I will change that and then do some tests, concerning the threshold and also concerning other base rings.",
    "created_at": "2011-07-12T07:35:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155321",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>Hi Martin,

I have a guess why the patch isn't as quick as it should be: It is the line

```
    return self.__matrix_class(self, 0, coerce=coerce, copy=copy) 
```
If you pass the value 0, then the matrix is initialised as a diagonal matrix with 0 on the diagonal -- which means that time is wasted by initialising the diagonal twice.

Better would be to pass `self, None, coerce=coerce, copy=copy`. I will change that and then do some tests, concerning the threshold and also concerning other base rings.



---

archive/issue_comments_155322.json:
```json
{
    "body": "<a id='comment:8'></a>I was wrong in assuming that `entries=0` would provoke a second initialisation of the diagonal.\n\nHowever, using None as default argument does have a tiny advantage: The test `if entries is None or entries==0` is a tad faster if it is actually None.\n\nWith `entries=None` as default in the `__call__` method of matrix spaces, timings do improve, and I obtain a threshold `nrows==ncols==40`: For larger matrices, over GF(p) with p>2, creation from scratch is faster, while for smaller matrices copying is faster.\n\nHowever, with the original patch, I find a big surprise: Over GF(2), copying is *always* faster! For GF(p), p>2, I can confirm your statement that the threshold seems to be around 100.\n\nThere is one problem with default `entries=None`, though: Some matrix classes (used for matrices over the reals or symbolics) don't accept `entries=None`. So, their init methods should be adapted as well.\n\nQuestion: Is it worth it?\n\nUsing None, I obtain for example:\n\n```\nsage: timeit(\"M = matrix(GF(2),30,30)\", number=10000)\n10000 loops, best of 3: 105 \u00b5s per loop\nsage: timeit(\"M = matrix(GF(2),300,300)\", number=10000)\n10000 loops, best of 3: 107 \u00b5s per loop\nsage: timeit(\"M = matrix(GF(3),30,30)\", number=10000)\n10000 loops, best of 3: 102 \u00b5s per loop\nsage: timeit(\"M = matrix(GF(3),300,300)\", number=10000)\n10000 loops, best of 3: 210 \u00b5s per loop\n```\n\nUsing 0, I obtain:\n\n```\nsage: timeit(\"M = matrix(GF(2),30,30)\", number=10000)\n10000 loops, best of 3: 113 \u00b5s per loop\nsage: timeit(\"M = matrix(GF(2),300,300)\", number=10000)\n10000 loops, best of 3: 123 \u00b5s per loop\nsage: timeit(\"M = matrix(GF(3),30,30)\", number=10000)\n10000 loops, best of 3: 102 \u00b5s per loop\nsage: timeit(\"M = matrix(GF(3),300,300)\", number=10000)\n10000 loops, best of 3: 215 \u00b5s per loop\n```\n\nThe difference is small, but it seems quite reproducible (not flaky) for me. So, my suggestion is to go through the matrix classes and allow `entries=None`.",
    "created_at": "2011-07-12T09:32:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155322",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>I was wrong in assuming that `entries=0` would provoke a second initialisation of the diagonal.

However, using None as default argument does have a tiny advantage: The test `if entries is None or entries==0` is a tad faster if it is actually None.

With `entries=None` as default in the `__call__` method of matrix spaces, timings do improve, and I obtain a threshold `nrows==ncols==40`: For larger matrices, over GF(p) with p>2, creation from scratch is faster, while for smaller matrices copying is faster.

However, with the original patch, I find a big surprise: Over GF(2), copying is *always* faster! For GF(p), p>2, I can confirm your statement that the threshold seems to be around 100.

There is one problem with default `entries=None`, though: Some matrix classes (used for matrices over the reals or symbolics) don't accept `entries=None`. So, their init methods should be adapted as well.

Question: Is it worth it?

Using None, I obtain for example:

```
sage: timeit("M = matrix(GF(2),30,30)", number=10000)
10000 loops, best of 3: 105 µs per loop
sage: timeit("M = matrix(GF(2),300,300)", number=10000)
10000 loops, best of 3: 107 µs per loop
sage: timeit("M = matrix(GF(3),30,30)", number=10000)
10000 loops, best of 3: 102 µs per loop
sage: timeit("M = matrix(GF(3),300,300)", number=10000)
10000 loops, best of 3: 210 µs per loop
```

Using 0, I obtain:

```
sage: timeit("M = matrix(GF(2),30,30)", number=10000)
10000 loops, best of 3: 113 µs per loop
sage: timeit("M = matrix(GF(2),300,300)", number=10000)
10000 loops, best of 3: 123 µs per loop
sage: timeit("M = matrix(GF(3),30,30)", number=10000)
10000 loops, best of 3: 102 µs per loop
sage: timeit("M = matrix(GF(3),300,300)", number=10000)
10000 loops, best of 3: 215 µs per loop
```

The difference is small, but it seems quite reproducible (not flaky) for me. So, my suggestion is to go through the matrix classes and allow `entries=None`.



---

archive/issue_comments_155323.json:
```json
{
    "body": "<a id='comment:9'></a>I made all matrices accept \"None\" as an argument.\n\nI tried to determine the threshold for copying versus creating a zero matrix, using the following test function:\n\n```\nsage: def tests(R):\n....:     BetterCopy = []\n....:     for d in srange(10,511,20):\n....:         MS = MatrixSpace(R,d)\n....:         MS._copy_zero = True\n....:         globals()['d'] = d\n....:         globals()['R'] = R\n....:         TCopy = timeit.eval(\"M = matrix(R,d,d)\",number=1000)\n....:         MS._copy_zero = False\n....:         TNoCopy = timeit.eval(\"M = matrix(R,d,d)\",number=1000)\n....:         if TCopy.stats[3] < TNoCopy.stats[3]:\n....:             BetterCopy.append((d,TCopy,TNoCopy))\n....:     return BetterCopy\n....: \n```\n\nIt turns out that with both patches applied, copying is not a good idea over GF(2) and over the rationals:\n\n```\nsage: tests(GF(2))\n[]\nsage: tests(QQ)\n[]\n```\nNote that I observed that the memory consumption for the test over the rationals constantly increased: Perhaps there is a memory leak.\n\nHowever, in all other cases I studied, copying was better, for matrices of up to 30 rows and columns:\n\n```\nsage: tests(GF(3))\n[(10, 1000 loops, best of 3: 48.2 \u00b5s per loop, 1000 loops, best of 3: 49 \u00b5s per loop), (30, 1000 loops, best of 3: 50 \u00b5s per loop, 1000 loops, best of 3: 50.9 \u00b5s per loop)]\nsage: tests(GF(1019))\n[(10, 1000 loops, best of 3: 48.3 \u00b5s per loop, 1000 loops, best of 3: 49.2 \u00b5s per loop)]\nsage: tests(GF(625,'a'))\n[(10, 1000 loops, best of 3: 45.1 \u00b5s per loop, 1000 loops, best of 3: 63.1 \u00b5s per loop), (30, 1000 loops, best of 3: 62.9 \u00b5s per loop, 1000 loops, best of 3: 68 \u00b5s per loop), (230, 1000 loops, best of 3: 1.15 ms per loop, 1000 loops, best of 3: 367 \u00b5s per loop), (250, 1000 loops, best of 3: 1.35 ms per loop, 1000 loops, best of 3: 423 \u00b5s per loop), (270, 1000 loops, best of 3: 1.71 ms per loop, 1000 loops, best of 3: 618 \u00b5s per loop), (290, 1000 loops, best of 3: 1.95 ms per loop, 1000 loops, best of 3: 701 \u00b5s per loop), (310, 1000 loops, best of 3: 2.23 ms per loop, 1000 loops, best of 3: 791 \u00b5s per loop), (330, 1000 loops, best of 3: 2.52 ms per loop, 1000 loops, best of 3: 883 \u00b5s per loop), (350, 1000 loops, best of 3: 2.82 ms per loop, 1000 loops, best of 3: 988 \u00b5s per loop)]\nsage: tests(ZZ)\n[(10, 625 loops, best of 3: 48.6 \u00b5s per loop, 625 loops, best of 3: 56.5 \u00b5s per loop), (30, 625 loops, best of 3: 111 \u00b5s per loop, 625 loops, best of 3: 118 \u00b5s per loop), (50, 625 loops, best of 3: 230 \u00b5s per loop, 625 loops, best of 3: 235 \u00b5s per loop)]\n```\n\nTherefore, I modified the threshold in `_copy_zero` a bit. There is no special case for `Matrix_modn_dense`, but for `Matrix_rational_dense`.\n\nHere are timings similar to the ones you did above (adding another test case).\n\nWith both patches:\n\n```\nsage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 105 \u00b5s per loop\n625 loops, best of 3: 108 \u00b5s per loop\n625 loops, best of 3: 116 \u00b5s per loop\nsage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 103 \u00b5s per loop\n625 loops, best of 3: 403 \u00b5s per loop\n625 loops, best of 3: 1.3 ms per loop\nsage: for n in (50,500,1000): timeit('A=matrix(GF(625,\"a\"),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 198 \u00b5s per loop\n125 loops, best of 3: 1.97 ms per loop\n125 loops, best of 3: 7.29 ms per loop\n```\n\nWithout patches:\n\n```\nsage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 108 \u00b5s per loop\n625 loops, best of 3: 116 \u00b5s per loop\n625 loops, best of 3: 137 \u00b5s per loop\nsage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 103 \u00b5s per loop\n625 loops, best of 3: 566 \u00b5s per loop\n125 loops, best of 3: 2.46 ms per loop\nsage: for n in (50,500,1000): timeit('A=matrix(GF(625,\"a\"),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 225 \u00b5s per loop\n125 loops, best of 3: 5.95 ms per loop\n25 loops, best of 3: 22.9 ms per loop\n```\n\nSo, with both patches applied, the timings consistently improve.\n\n**__Reviewing__**\n\nI am not sure how the reviewing should be done, as we are both authors. Do you think it is ok if I review the first patch and you review the second patch? I need to run all long doctests, though; so far, I only did the tests in sage/matrix.\n\n**__TODO__**\n\nOn a different ticket, the potential memory leak for rational dense matrices should be studied.\n\nI recall that in some arithmetic routines of matrices, zero matrices are created at the beginning. I am not sure whether that is done \"the official way\" or by *always* copying a zero matrix, but I think it was the latter. That might be worth while to fix as well.",
    "created_at": "2011-07-12T10:43:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155323",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>I made all matrices accept "None" as an argument.

I tried to determine the threshold for copying versus creating a zero matrix, using the following test function:

```
sage: def tests(R):
....:     BetterCopy = []
....:     for d in srange(10,511,20):
....:         MS = MatrixSpace(R,d)
....:         MS._copy_zero = True
....:         globals()['d'] = d
....:         globals()['R'] = R
....:         TCopy = timeit.eval("M = matrix(R,d,d)",number=1000)
....:         MS._copy_zero = False
....:         TNoCopy = timeit.eval("M = matrix(R,d,d)",number=1000)
....:         if TCopy.stats[3] < TNoCopy.stats[3]:
....:             BetterCopy.append((d,TCopy,TNoCopy))
....:     return BetterCopy
....: 
```

It turns out that with both patches applied, copying is not a good idea over GF(2) and over the rationals:

```
sage: tests(GF(2))
[]
sage: tests(QQ)
[]
```
Note that I observed that the memory consumption for the test over the rationals constantly increased: Perhaps there is a memory leak.

However, in all other cases I studied, copying was better, for matrices of up to 30 rows and columns:

```
sage: tests(GF(3))
[(10, 1000 loops, best of 3: 48.2 µs per loop, 1000 loops, best of 3: 49 µs per loop), (30, 1000 loops, best of 3: 50 µs per loop, 1000 loops, best of 3: 50.9 µs per loop)]
sage: tests(GF(1019))
[(10, 1000 loops, best of 3: 48.3 µs per loop, 1000 loops, best of 3: 49.2 µs per loop)]
sage: tests(GF(625,'a'))
[(10, 1000 loops, best of 3: 45.1 µs per loop, 1000 loops, best of 3: 63.1 µs per loop), (30, 1000 loops, best of 3: 62.9 µs per loop, 1000 loops, best of 3: 68 µs per loop), (230, 1000 loops, best of 3: 1.15 ms per loop, 1000 loops, best of 3: 367 µs per loop), (250, 1000 loops, best of 3: 1.35 ms per loop, 1000 loops, best of 3: 423 µs per loop), (270, 1000 loops, best of 3: 1.71 ms per loop, 1000 loops, best of 3: 618 µs per loop), (290, 1000 loops, best of 3: 1.95 ms per loop, 1000 loops, best of 3: 701 µs per loop), (310, 1000 loops, best of 3: 2.23 ms per loop, 1000 loops, best of 3: 791 µs per loop), (330, 1000 loops, best of 3: 2.52 ms per loop, 1000 loops, best of 3: 883 µs per loop), (350, 1000 loops, best of 3: 2.82 ms per loop, 1000 loops, best of 3: 988 µs per loop)]
sage: tests(ZZ)
[(10, 625 loops, best of 3: 48.6 µs per loop, 625 loops, best of 3: 56.5 µs per loop), (30, 625 loops, best of 3: 111 µs per loop, 625 loops, best of 3: 118 µs per loop), (50, 625 loops, best of 3: 230 µs per loop, 625 loops, best of 3: 235 µs per loop)]
```

Therefore, I modified the threshold in `_copy_zero` a bit. There is no special case for `Matrix_modn_dense`, but for `Matrix_rational_dense`.

Here are timings similar to the ones you did above (adding another test case).

With both patches:

```
sage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 105 µs per loop
625 loops, best of 3: 108 µs per loop
625 loops, best of 3: 116 µs per loop
sage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 103 µs per loop
625 loops, best of 3: 403 µs per loop
625 loops, best of 3: 1.3 ms per loop
sage: for n in (50,500,1000): timeit('A=matrix(GF(625,"a"),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 198 µs per loop
125 loops, best of 3: 1.97 ms per loop
125 loops, best of 3: 7.29 ms per loop
```

Without patches:

```
sage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 108 µs per loop
625 loops, best of 3: 116 µs per loop
625 loops, best of 3: 137 µs per loop
sage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 103 µs per loop
625 loops, best of 3: 566 µs per loop
125 loops, best of 3: 2.46 ms per loop
sage: for n in (50,500,1000): timeit('A=matrix(GF(625,"a"),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 225 µs per loop
125 loops, best of 3: 5.95 ms per loop
25 loops, best of 3: 22.9 ms per loop
```

So, with both patches applied, the timings consistently improve.

**__Reviewing__**

I am not sure how the reviewing should be done, as we are both authors. Do you think it is ok if I review the first patch and you review the second patch? I need to run all long doctests, though; so far, I only did the tests in sage/matrix.

**__TODO__**

On a different ticket, the potential memory leak for rational dense matrices should be studied.

I recall that in some arithmetic routines of matrices, zero matrices are created at the beginning. I am not sure whether that is done "the official way" or by *always* copying a zero matrix, but I think it was the latter. That might be worth while to fix as well.



---

archive/issue_comments_155324.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2011-07-12T10:43:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155324",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_155325.json:
```json
{
    "body": "<a id='comment:10'></a>PS: It seems to me that several doc tests from sage/matrix are considerably faster with the patches. I hope that can be confirmed.",
    "created_at": "2011-07-12T10:48:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155325",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:10'></a>PS: It seems to me that several doc tests from sage/matrix are considerably faster with the patches. I hope that can be confirmed.



---

archive/issue_comments_155326.json:
```json
{
    "body": "<a id='comment:11'></a>Replying to [SimonKing](#comment%3A9):\n> I made all matrices accept \"None\" as an argument.\n\n\nCool, you are fast!\n \n> **__Reviewing__**\n> \n> I am not sure how the reviewing should be done, as we are both authors. Do you think it is ok if I review the first patch and you review the second patch? I need to run all long doctests, though; so far, I only did the tests in sage/matrix.\n\n\nYes, as far as I know it's okay if we cross-review. So I'll take a look at your patch.",
    "created_at": "2011-07-12T10:52:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155326",
    "user": "https://github.com/malb"
}
```

<a id='comment:11'></a>Replying to [SimonKing](#comment%3A9):
> I made all matrices accept "None" as an argument.


Cool, you are fast!
 
> **__Reviewing__**
> 
> I am not sure how the reviewing should be done, as we are both authors. Do you think it is ok if I review the first patch and you review the second patch? I need to run all long doctests, though; so far, I only did the tests in sage/matrix.


Yes, as far as I know it's okay if we cross-review. So I'll take a look at your patch.



---

archive/issue_comments_155327.json:
```json
{
    "body": "<a id='comment:12'></a>Here are timings on my machine (Macbook Pro, i7):\n\n__no patch__\n\n```python\nsage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 98.1 \u00b5s per loop\n625 loops, best of 3: 115 \u00b5s per loop\n625 loops, best of 3: 130 \u00b5s per loop\n\nsage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 93.3 \u00b5s per loop\n625 loops, best of 3: 538 \u00b5s per loop\n125 loops, best of 3: 2.41 ms per loop\n\nsage: for n in (50,500,1000): timeit('A=matrix(GF(625,\"a\"),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 189 \u00b5s per loop\n125 loops, best of 3: 3.7 ms per loop\n25 loops, best of 3: 14.1 ms per loop\n```\n\n__first only__\n\n```python\nsage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 104 \u00b5s per loop\n625 loops, best of 3: 108 \u00b5s per loop\n625 loops, best of 3: 112 \u00b5s per loop\n\nsage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 95.5 \u00b5s per loop\n625 loops, best of 3: 442 \u00b5s per loop\n625 loops, best of 3: 1.48 ms per loop\n\nsage: for n in (50,500,1000): timeit('A=matrix(GF(625,\"a\"),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 184 \u00b5s per loop\n125 loops, best of 3: 3.7 ms per loop\n25 loops, best of 3: 13.8 ms per loop\n```\n\n__with both__\n\n```python\nsage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 94.5 \u00b5s per loop\n625 loops, best of 3: 98.9 \u00b5s per loop\n625 loops, best of 3: 108 \u00b5s per loop\n\nsage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 95 \u00b5s per loop\n625 loops, best of 3: 438 \u00b5s per loop\n625 loops, best of 3: 1.49 ms per loop\n\nsage: for n in (50,500,1000): timeit('A=matrix(GF(625,\"a\"),%d,%d)'%(n,n))\n....: \n625 loops, best of 3: 176 \u00b5s per loop\n125 loops, best of 3: 1.74 ms per loop\n125 loops, best of 3: 6.24 ms per loop\n```\n\nMy take: it's definitely faster for large-ish matrices and undecided for small matrices, i.e. my timings for 50x50 are rather unstable.",
    "created_at": "2011-07-12T11:26:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155327",
    "user": "https://github.com/malb"
}
```

<a id='comment:12'></a>Here are timings on my machine (Macbook Pro, i7):

__no patch__

```python
sage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 98.1 µs per loop
625 loops, best of 3: 115 µs per loop
625 loops, best of 3: 130 µs per loop

sage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 93.3 µs per loop
625 loops, best of 3: 538 µs per loop
125 loops, best of 3: 2.41 ms per loop

sage: for n in (50,500,1000): timeit('A=matrix(GF(625,"a"),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 189 µs per loop
125 loops, best of 3: 3.7 ms per loop
25 loops, best of 3: 14.1 ms per loop
```

__first only__

```python
sage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 104 µs per loop
625 loops, best of 3: 108 µs per loop
625 loops, best of 3: 112 µs per loop

sage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 95.5 µs per loop
625 loops, best of 3: 442 µs per loop
625 loops, best of 3: 1.48 ms per loop

sage: for n in (50,500,1000): timeit('A=matrix(GF(625,"a"),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 184 µs per loop
125 loops, best of 3: 3.7 ms per loop
25 loops, best of 3: 13.8 ms per loop
```

__with both__

```python
sage: for n in (50,500,1000): timeit('A=matrix(GF(2),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 94.5 µs per loop
625 loops, best of 3: 98.9 µs per loop
625 loops, best of 3: 108 µs per loop

sage: for n in (50,500,1000): timeit('A=matrix(GF(3),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 95 µs per loop
625 loops, best of 3: 438 µs per loop
625 loops, best of 3: 1.49 ms per loop

sage: for n in (50,500,1000): timeit('A=matrix(GF(625,"a"),%d,%d)'%(n,n))
....: 
625 loops, best of 3: 176 µs per loop
125 loops, best of 3: 1.74 ms per loop
125 loops, best of 3: 6.24 ms per loop
```

My take: it's definitely faster for large-ish matrices and undecided for small matrices, i.e. my timings for 50x50 are rather unstable.



---

archive/issue_comments_155328.json:
```json
{
    "body": "Some fine tuning for the creation of zero matrices",
    "created_at": "2011-07-12T12:02:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155328",
    "user": "https://github.com/simon-king-jena"
}
```

Some fine tuning for the creation of zero matrices



---

archive/issue_comments_155329.json:
```json
{
    "body": "<a id='comment:13'></a>Attachment [trac_11589_copy_vs_creation_of_zero.patch](tarball://root/attachments/some-uuid/ticket11589/trac_11589_copy_vs_creation_of_zero.patch) by @simon-king-jena created at 2011-07-12 12:04:42\n\nSorry, I had to replace my patch, since apparently I forgot to change the doctests of _copy_zero. Actually, the new patch version adds some tests, as there is now a special case for matrices over the rationals.\n\nFWIW, with the old patch version all long tests except matrix_space.py pass, and with the new patch version (that only fixes the failing doctest) matrix_space.py passes as well.",
    "created_at": "2011-07-12T12:04:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155329",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:13'></a>Attachment [trac_11589_copy_vs_creation_of_zero.patch](tarball://root/attachments/some-uuid/ticket11589/trac_11589_copy_vs_creation_of_zero.patch) by @simon-king-jena created at 2011-07-12 12:04:42

Sorry, I had to replace my patch, since apparently I forgot to change the doctests of _copy_zero. Actually, the new patch version adds some tests, as there is now a special case for matrices over the rationals.

FWIW, with the old patch version all long tests except matrix_space.py pass, and with the new patch version (that only fixes the failing doctest) matrix_space.py passes as well.



---

archive/issue_comments_155330.json:
```json
{
    "body": "<a id='comment:14'></a>Replying to [SimonKing](#comment%3A9):\n> I recall that in some arithmetic routines of matrices, zero matrices are created at the beginning. I am not sure whether that is done \"the official way\" or by *always* copying a zero matrix, but I think it was the latter. That might be worth while to fix as well.\n\n\nI found it. It is the `_multiply_strassen` method in `matrix2.pyx`, which says:\n\n```\n        if self.is_sparse():\n            output = self.matrix_space(self._nrows, right._ncols, sparse = True)(0)\n        else:\n            output = self.matrix_space(self._nrows, right._ncols, sparse = False).zero_matrix().__copy__()\n```\n\nI think that ought to be improved, but that would better be on another ticket.",
    "created_at": "2011-07-12T13:00:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155330",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>Replying to [SimonKing](#comment%3A9):
> I recall that in some arithmetic routines of matrices, zero matrices are created at the beginning. I am not sure whether that is done "the official way" or by *always* copying a zero matrix, but I think it was the latter. That might be worth while to fix as well.


I found it. It is the `_multiply_strassen` method in `matrix2.pyx`, which says:

```
        if self.is_sparse():
            output = self.matrix_space(self._nrows, right._ncols, sparse = True)(0)
        else:
            output = self.matrix_space(self._nrows, right._ncols, sparse = False).zero_matrix().__copy__()
```

I think that ought to be improved, but that would better be on another ticket.



---

archive/issue_comments_155331.json:
```json
{
    "body": "<a id='comment:15'></a>I added a third patch, that applies the faster way of creating a zero matrix to `_multiply_strassen`. With the third patch, all tests from sage/matrix still pass. I have no benchmark that shows a noticeable difference to the old behaviour. But I think it won't hurt to use an optimised procedure for the creation of a zero matrix, rather than to hard-wire the copying of a zero matrix in the current version of _multiply_strassen.\n\nI think that the third patch is small enough to be discussed here. However, note that there already is an open ticket on improving matrix multiplication: #8096. There is no activity for 16 months now! I think it would be worth while to invest some work there. It seems to me that a part of the issues of that old ticket are already resolved.\n\nConcerning reviews: I believe that the first patch is fine, and I give it a positive review. I have already mentioned that the tests pass, and the improvement of the timings (in particular when the second patch is added) is clear.",
    "created_at": "2011-07-12T13:38:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155331",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:15'></a>I added a third patch, that applies the faster way of creating a zero matrix to `_multiply_strassen`. With the third patch, all tests from sage/matrix still pass. I have no benchmark that shows a noticeable difference to the old behaviour. But I think it won't hurt to use an optimised procedure for the creation of a zero matrix, rather than to hard-wire the copying of a zero matrix in the current version of _multiply_strassen.

I think that the third patch is small enough to be discussed here. However, note that there already is an open ticket on improving matrix multiplication: #8096. There is no activity for 16 months now! I think it would be worth while to invest some work there. It seems to me that a part of the issues of that old ticket are already resolved.

Concerning reviews: I believe that the first patch is fine, and I give it a positive review. I have already mentioned that the tests pass, and the improvement of the timings (in particular when the second patch is added) is clear.



---

archive/issue_comments_155332.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2011-07-12T15:50:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155332",
    "user": "https://github.com/malb"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_155333.json:
```json
{
    "body": "<a id='comment:16'></a>> Concerning reviews: I believe that the first patch is fine, and I give it a positive review. I have already mentioned that the tests pass, and the improvement of the timings (in particular when the second patch is added) is clear.\n\n\nI give your two patches a positive review as well.",
    "created_at": "2011-07-12T15:50:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155333",
    "user": "https://github.com/malb"
}
```

<a id='comment:16'></a>> Concerning reviews: I believe that the first patch is fine, and I give it a positive review. I have already mentioned that the tests pass, and the improvement of the timings (in particular when the second patch is added) is clear.


I give your two patches a positive review as well.



---

archive/issue_comments_155334.json:
```json
{
    "body": "Changing reviewer from \"\" to \"Simon King, Martin Albrecht\"",
    "created_at": "2011-07-12T15:50:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155334",
    "user": "https://github.com/malb"
}
```

Changing reviewer from "" to "Simon King, Martin Albrecht"



---

archive/issue_comments_155335.json:
```json
{
    "body": "<a id='comment:17'></a>Note that the patch for Strassen-Winograd multiplication at #11610 benefits from the patches here as well, because many matrix spaces are created during the iteration.",
    "created_at": "2011-07-18T21:29:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155335",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:17'></a>Note that the patch for Strassen-Winograd multiplication at #11610 benefits from the patches here as well, because many matrix spaces are created during the iteration.



---

archive/issue_comments_155336.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2011-07-28T10:48:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155336",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_155337.json:
```json
{
    "body": "<a id='comment:18'></a>Please state which patches have to be applied...",
    "created_at": "2011-07-28T10:48:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155337",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:18'></a>Please state which patches have to be applied...



---

archive/issue_comments_155338.json:
```json
{
    "body": "Use the mecanisms from the preceding patches in Strassen multiplication",
    "created_at": "2011-07-28T11:19:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155338",
    "user": "https://github.com/simon-king-jena"
}
```

Use the mecanisms from the preceding patches in Strassen multiplication



---

archive/issue_comments_155339.json:
```json
{
    "body": "<a id='comment:19'></a>Attachment [trac_11589_apply_zero_creation_to_strassen.patch](tarball://root/attachments/some-uuid/ticket11589/trac_11589_apply_zero_creation_to_strassen.patch) by @simon-king-jena created at 2011-07-28 11:21:17\n\nReplying to [jdemeyer](#comment%3A18):\n> Please state which patches have to be applied...\n\n\nIf nothing is stated then, I thought, *all* patches are to be applied.\n\nI used the occasion to replace the third patch: A commit message was missing.",
    "created_at": "2011-07-28T11:21:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155339",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'></a>Attachment [trac_11589_apply_zero_creation_to_strassen.patch](tarball://root/attachments/some-uuid/ticket11589/trac_11589_apply_zero_creation_to_strassen.patch) by @simon-king-jena created at 2011-07-28 11:21:17

Replying to [jdemeyer](#comment%3A18):
> Please state which patches have to be applied...


If nothing is stated then, I thought, *all* patches are to be applied.

I used the occasion to replace the third patch: A commit message was missing.



---

archive/issue_comments_155340.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2011-07-28T11:21:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155340",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_155341.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2011-07-28T11:21:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155341",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_155342.json:
```json
{
    "body": "<a id='comment:20'></a>... and back to positive review.",
    "created_at": "2011-07-28T11:21:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155342",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:20'></a>... and back to positive review.



---

archive/issue_comments_155343.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -4,5 +4,6 @@\n * it eats up RAM (we create two instead of one matrix)\n \n See also the discussion on [sage-devel]:\n+http://groups.google.com/group/sage-devel/browse_thread/thread/478fb19ecb724be0\n \n-http://groups.google.com/group/sage-devel/browse_thread/thread/478fb19ecb724be0\n+Apply all three patches.\n``````\n",
    "created_at": "2011-07-28T16:51:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155343",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -4,5 +4,6 @@
 * it eats up RAM (we create two instead of one matrix)
 
 See also the discussion on [sage-devel]:
+http://groups.google.com/group/sage-devel/browse_thread/thread/478fb19ecb724be0
 
-http://groups.google.com/group/sage-devel/browse_thread/thread/478fb19ecb724be0
+Apply all three patches.
``````




---

archive/issue_comments_155344.json:
```json
{
    "body": "<a id='comment:21'></a>Replying to [SimonKing](#comment%3A19):\n> If nothing is stated then, I thought, *all* patches are to be applied.\n\n\nFor safety, I prefer not to make any such assumptions.  In the few cases where it is unclear (like here), I prefer simply asking.",
    "created_at": "2011-07-28T16:51:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155344",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:21'></a>Replying to [SimonKing](#comment%3A19):
> If nothing is stated then, I thought, *all* patches are to be applied.


For safety, I prefer not to make any such assumptions.  In the few cases where it is unclear (like here), I prefer simply asking.



---

archive/issue_comments_155345.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2011-08-02T19:47:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155345",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_030398.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-08-02T19:47:01Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11589#event-30398"
}
```



---

archive/issue_comments_155346.json:
```json
{
    "body": "Changing merged from \"\" to \"sage-4.7.2.alpha1\"",
    "created_at": "2011-08-02T19:47:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11589",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11589#issuecomment-155346",
    "user": "https://github.com/jdemeyer"
}
```

Changing merged from "" to "sage-4.7.2.alpha1"
