# Issue 11255: Enhance the e_one_star.Patch class

archive/issues_011083.json:
```json
{
    "assignees": [],
    "body": "A few enhancements for the Patch class:\n\n* `remove` method;\n* `__hash__` method;\n* deal more cleanly with construction of new patches (sometimes the same Face belonged to different patches, which caused problems with colors, for example).\n\nFor the patchbot (this info must be put here instead of below):\n\nApply:\n* [attachment: trac-11255-tj.patch](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj.patch.gz)\n* [attachment: trac-11255-tj-modifs.patch](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj-modifs.patch.gz)\n* [attachment: trac_11255_reviewer-sl.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-sl.patch.gz)\n* [attachment: trac_11255_modifs2-tj.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_modifs2-tj.patch.gz)\n* [attachment: trac_11255_reviewer-2nd-sl.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-2nd-sl.patch.gz)\n\nCC:  @seblabbe\n\nComponent: **combinatorics**\n\nAuthor: **Timo Jolivet**\n\nReviewer: **S\u00e9bastien Labb\u00e9**\n\nMerged: **sage-4.7.1.alpha3**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/11255_\n\n",
    "closed_at": "2011-06-08T07:13:36Z",
    "created_at": "2011-04-26T06:58:07Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20combinatorics",
        "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-4.7.1",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Enhance the e_one_star.Patch class",
    "type": "issue",
    "updated_at": "2011-06-08T07:13:36Z",
    "url": "https://github.com/sagemath/sage/issues/11255",
    "user": "https://github.com/sagetrac-tjolivet"
}
```
A few enhancements for the Patch class:

* `remove` method;
* `__hash__` method;
* deal more cleanly with construction of new patches (sometimes the same Face belonged to different patches, which caused problems with colors, for example).

For the patchbot (this info must be put here instead of below):

Apply:
* [attachment: trac-11255-tj.patch](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj.patch.gz)
* [attachment: trac-11255-tj-modifs.patch](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj-modifs.patch.gz)
* [attachment: trac_11255_reviewer-sl.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-sl.patch.gz)
* [attachment: trac_11255_modifs2-tj.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_modifs2-tj.patch.gz)
* [attachment: trac_11255_reviewer-2nd-sl.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-2nd-sl.patch.gz)

CC:  @seblabbe

Component: **combinatorics**

Author: **Timo Jolivet**

Reviewer: **Sébastien Labbé**

Merged: **sage-4.7.1.alpha3**

_Issue created by migration from https://trac.sagemath.org/ticket/11255_





---

archive/issue_events_149173.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-04-26T06:58:07Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "milestone_number": null,
    "milestone_title": "sage-4.7.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149173"
}
```



---

archive/issue_events_149174.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-04-26T06:58:07Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20combinatorics",
    "label_color": "0000ff",
    "label_name": "c: combinatorics",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149174"
}
```



---

archive/issue_events_149175.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-04-26T06:58:07Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/p%3A%203%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p: 3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149175"
}
```



---

archive/issue_events_149176.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-04-26T06:58:07Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149176"
}
```



---

archive/issue_events_149177.json:
```json
{
    "actor": "https://github.com/sagetrac-sage-combinat",
    "created_at": "2011-04-26T06:58:07Z",
    "event": "assigned",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "subject": "https://github.com/sagetrac-tjolivet",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149177"
}
```



---

archive/issue_comments_112723.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nAttachment: **[trac-11255-tj.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj.patch.gz)**\n\nFor the patchbot :\n\nApply trac-11255-tj.patch",
    "created_at": "2011-05-03T12:49:46Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112723",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:1" align="right">comment:1</div>

Attachment: **[trac-11255-tj.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj.patch.gz)**

For the patchbot :

Apply trac-11255-tj.patch



---

archive/issue_comments_112724.json:
```json
{
    "body": "Salut Timo,\n\nBelow are my comments.\n\n> * `remove` method;\n\nInstead of writing a sentence about the input, I prefer if we follow the Sage Developper's Guide and write an INPUT section.\n\nNo need to import E1Star in the doctest of the remove method.\n\n> * `__hash__` method;\n\nI have some concerns about adding a hash method to the Patch class. Since a patch can be modified (by using the remove method for instance), strange behavior can occur like the following :\n\n```\nsage: P = Patch(...)\nsage: Q = copy(P)\nsage: S = set()\nsage: S.add(P)\nsage: P.remove(some face A)\nsage: Q.remove(some face A)\nsage: Q in S\nFalse      \nsage: Q == S.pop()\nTrue\n```\n\nAny serious Python or Sage object is either mutable and unhashable or immutable and hashable. In Sage, matrices and vector are allowed to pass from one state to the other using methods like `set_immutable` and `set_mutable`. This issue must be fixed.\n\n> * deal more cleanly with construction of new patches (sometimes the same Face belonged to different patches, which caused problems with colors, for example).\n\nCan you provide an example that justifies the modification? Without an example, I can not say that I agree with the solution. I feel like the solution is doing too much copies. But, I can't suggest an alternative, since I do not know what the problem really is.\n\nOnce the problem is solved, such an example illustrating the problem you mention must be added as a doctest.\n\n\n\nAnd finally, I do not understand this modification :\n\n```diff\n-       return (isinstance(other, Patch) and set(self) == set(other)) \n+ \treturn (isinstance(other, Patch) and set(self._faces) == set(other._faces)) \n```",
    "created_at": "2011-05-04T00:12:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112724",
    "user": "https://github.com/seblabbe"
}
```

Salut Timo,

Below are my comments.

> * `remove` method;

Instead of writing a sentence about the input, I prefer if we follow the Sage Developper's Guide and write an INPUT section.

No need to import E1Star in the doctest of the remove method.

> * `__hash__` method;

I have some concerns about adding a hash method to the Patch class. Since a patch can be modified (by using the remove method for instance), strange behavior can occur like the following :

```
sage: P = Patch(...)
sage: Q = copy(P)
sage: S = set()
sage: S.add(P)
sage: P.remove(some face A)
sage: Q.remove(some face A)
sage: Q in S
False      
sage: Q == S.pop()
True
```

Any serious Python or Sage object is either mutable and unhashable or immutable and hashable. In Sage, matrices and vector are allowed to pass from one state to the other using methods like `set_immutable` and `set_mutable`. This issue must be fixed.

> * deal more cleanly with construction of new patches (sometimes the same Face belonged to different patches, which caused problems with colors, for example).

Can you provide an example that justifies the modification? Without an example, I can not say that I agree with the solution. I feel like the solution is doing too much copies. But, I can't suggest an alternative, since I do not know what the problem really is.

Once the problem is solved, such an example illustrating the problem you mention must be added as a doctest.



And finally, I do not understand this modification :

```diff
-       return (isinstance(other, Patch) and set(self) == set(other)) 
+ 	return (isinstance(other, Patch) and set(self._faces) == set(other._faces)) 
```



---

archive/issue_events_149178.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2011-05-04T00:12:23Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149178"
}
```



---

archive/issue_events_149179.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2011-05-04T00:12:35Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149179"
}
```



---

archive/issue_events_149180.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2011-05-04T00:12:35Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149180"
}
```



---

archive/issue_comments_112725.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nReplying to [@seblabbe](#comment:2):\n\n> Instead of writing a sentence about the input, I prefer if we follow the Sage Developper's Guide and write an INPUT section.\n\nI agree, I corrected this.\n\n\n> No need to import E1Star in the doctest of the remove method.\n\nThanks for mentionning this. I corrected many other instances of the same issue.\n\n\n> I have some concerns about adding a hash method to the Patch class. Since a patch can be modified (by using the remove method for instance), strange behavior can occur like the following :\n> \n> ```\n> sage: P = Patch(...)\n> sage: Q = copy(P)\n> sage: S = set()\n> sage: S.add(P)\n> sage: P.remove(some face A)\n> sage: Q.remove(some face A)\n> sage: Q in S\n> False      \n> sage: Q == S.pop()\n> True\n> ```\n> \n> Any serious Python or Sage object is either mutable and unhashable or immutable and hashable. In Sage, matrices and vector are allowed to pass from one state to the other using methods like `set_immutable` and `set_mutable`. This issue must be fixed.\n\nHere is why I added a `__hash__` method to Patch:\n\n```\nsage: P = Patch([Face([0,0,0],1), Face([0,0,0],2)])\nsage: Q = Patch([Face([0,0,0],2), Face([0,0,0],1)])\nsage: P == Q\nTrue\nsage: hash(P)\n1297676529065262660\nsage: hash(Q)\n-8173426908364432914\n```\n\nI had a lot of problems because of this when I used some `DiGraphs` whose vertices were `Patches`. If you have a better solution, let me know. I added it in the doctest under a TEST section.\n\n\n> Can you provide an example that justifies the modification? Without an example, I can not say that I agree with the solution. I feel like the solution is doing too much copies. But, I can't suggest an alternative, since I do not know what the problem really is.\n> \n> Once the problem is solved, such an example illustrating the problem you mention must be added as a doctest.\n\nHere is the problem with colors if we don't create new faces in Patch.__init__:\n\n```\nsage: P = Patch([Face([0,0,0],1), Face([0,0,0],2)])\nsage: Q = Patch(P)\nsage: P[0].color()\nRGB color (1.0, 0.0, 0.0)\nsage: Q[0].color('yellow')\nsage: P[0].color()\nRGB color (1.0, 1.0, 0.0)\n```\n\nLet me know if you have a better solution. I added it in the doctest under a TEST section.\n\n\n> And finally, I do not understand this modification :\n> \n> ```diff\n> -       return (isinstance(other, Patch) and set(self) == set(other)) \n> +     return (isinstance(other, Patch) and set(self._faces) == set(other._faces)) \n> ```\n\nOK, I reverted this useless modification (something I had tested but forgot to remove).\n\n\nPlease tell me if you agree with what I said concerning the main two issues you raised (`__hash__` and creating new faces in `Patch.__init__`). I will upload a new patch if you confirm.\n\nAlso, do you think the following code of `Patch.remove` can be made better? (It looks pretty naive but I'm not sure if using `set` would be more efficient...):\n\n```\nif isinstance(faces, Face):\n    while faces in self._faces:\n        self._faces.remove(faces)\nelse:\n    for f in faces:\n        while f in self._faces:\n            self._faces.remove(f)\n```",
    "created_at": "2011-05-04T12:06:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112725",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:5" align="right">comment:5</div>

Replying to [@seblabbe](#comment:2):

> Instead of writing a sentence about the input, I prefer if we follow the Sage Developper's Guide and write an INPUT section.

I agree, I corrected this.


> No need to import E1Star in the doctest of the remove method.

Thanks for mentionning this. I corrected many other instances of the same issue.


> I have some concerns about adding a hash method to the Patch class. Since a patch can be modified (by using the remove method for instance), strange behavior can occur like the following :
> 
> ```
> sage: P = Patch(...)
> sage: Q = copy(P)
> sage: S = set()
> sage: S.add(P)
> sage: P.remove(some face A)
> sage: Q.remove(some face A)
> sage: Q in S
> False      
> sage: Q == S.pop()
> True
> ```
> 
> Any serious Python or Sage object is either mutable and unhashable or immutable and hashable. In Sage, matrices and vector are allowed to pass from one state to the other using methods like `set_immutable` and `set_mutable`. This issue must be fixed.

Here is why I added a `__hash__` method to Patch:

```
sage: P = Patch([Face([0,0,0],1), Face([0,0,0],2)])
sage: Q = Patch([Face([0,0,0],2), Face([0,0,0],1)])
sage: P == Q
True
sage: hash(P)
1297676529065262660
sage: hash(Q)
-8173426908364432914
```

I had a lot of problems because of this when I used some `DiGraphs` whose vertices were `Patches`. If you have a better solution, let me know. I added it in the doctest under a TEST section.


> Can you provide an example that justifies the modification? Without an example, I can not say that I agree with the solution. I feel like the solution is doing too much copies. But, I can't suggest an alternative, since I do not know what the problem really is.
> 
> Once the problem is solved, such an example illustrating the problem you mention must be added as a doctest.

Here is the problem with colors if we don't create new faces in Patch.__init__:

```
sage: P = Patch([Face([0,0,0],1), Face([0,0,0],2)])
sage: Q = Patch(P)
sage: P[0].color()
RGB color (1.0, 0.0, 0.0)
sage: Q[0].color('yellow')
sage: P[0].color()
RGB color (1.0, 1.0, 0.0)
```

Let me know if you have a better solution. I added it in the doctest under a TEST section.


> And finally, I do not understand this modification :
> 
> ```diff
> -       return (isinstance(other, Patch) and set(self) == set(other)) 
> +     return (isinstance(other, Patch) and set(self._faces) == set(other._faces)) 
> ```

OK, I reverted this useless modification (something I had tested but forgot to remove).


Please tell me if you agree with what I said concerning the main two issues you raised (`__hash__` and creating new faces in `Patch.__init__`). I will upload a new patch if you confirm.

Also, do you think the following code of `Patch.remove` can be made better? (It looks pretty naive but I'm not sure if using `set` would be more efficient...):

```
if isinstance(faces, Face):
    while faces in self._faces:
        self._faces.remove(faces)
else:
    for f in faces:
        while f in self._faces:
            self._faces.remove(f)
```



---

archive/issue_comments_112726.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\n> Here is why I added a `__hash__` method to Patch:\n> \n> ```\n> sage: P = Patch([Face([0,0,0],1), Face([0,0,0],2)])\n> sage: Q = Patch([Face([0,0,0],2), Face([0,0,0],1)])\n> sage: P == Q\n> True\n> sage: hash(P)\n> 1297676529065262660\n> sage: hash(Q)\n> -8173426908364432914\n> ```\n> \n> I had a lot of problems because of this when I used some `DiGraphs` whose\n> vertices were `Patches`. If you have a better solution, let me know. I added it\n> in the doctest under a TEST section.\n\nIf we want Patches to be keys of dictionnary, vertices of graphs or elements of\nsets, it must be hashable. The easiest solution I see is that an object Patch\nbe always hashable and never mutable. That means we made a mistake earlier by\nallowing to modify a Patch. I am responsible for this as I remember I disliked\nmethods like `apply_substitution` but I were not able to verbalize it and\nrelate this with the ability of hashing the object.\n\nThere are three methods that change self : `add`, `apply_substitution`\nand `repaint`. I think we can keep `repaint` as it does not change the\nmathematical object and hence won't affect the result of the hash method (a\ndoctest making sure of that the hash method is independant of color changes\nshould be added).  Surprisingly, we did not made the mistake with the method\n`translate` which does not change self and return a new patch. I think it\nis easy to remove the method `apply_substitution` since (1) one can apply a\nsubstitution by just applying a substiution directly on it : ``E(P)`` and (2)\nthe only reason I can understand the existence of the method\n`apply_substitution` is that it is faster than doing ``E(P)`` which is not\nthe case anyway since it calls ``E(P)`` anyway. I also think the method\n`add` can be easily removed. We should replace it by a method `__add__` or `union` which adds two patches and return a new patch.\n\nNow, the method `adds` and `apply_substitution` should not be removed\nright now. Deprecation warnings should be added. Well usually, a deprecation\nwarning should be raised for one year before removing the method. But, since I\nbelieve fixing the immutable/hashable issue is very important. I think their\nbehavior could be changed now. A deprecation warning saying something like :\n\"Object sage.combinat.e_one_star.Patch are immutable since Sage-4.7.1. Use the\nusual addition instead which returns a new object: P + Q.\" A similar warning\nshould be added to the method `apply_substitution`.\n\n> Here is the problem with colors if we don't create new faces in Patch.__init__:\n> \n> ```\n> sage: P = Patch([Face([0,0,0],1), Face([0,0,0],2)])\n> sage: Q = Patch(P)\n> sage: P[0].color()\n> RGB color (1.0, 0.0, 0.0)\n> sage: Q[0].color('yellow')\n> sage: P[0].color()\n> RGB color (1.0, 1.0, 0.0)\n> ```\n> \n> Let me know if you have a better solution. I added it in the doctest under a TEST section.\n\nOne can create a Patch from a (1) iterable of faces or (2) from a Patch. The\nproblem comes from the case (2) were a copy should be done.  Here is my first\nsuggestion: \n\n```\nif isinstance(faces, Patch):\n    self._faces = [Face(f.vector(), f.type(), f.color()) for f in faces]\nelse:\n    self._faces = list(faces)\n```\n\n> Please tell me if you agree with what I said concerning the main two issues you raised (`__hash__` and creating new faces in `Patch.__init__`). I will upload a new patch if you confirm.\n> \n> Also, do you think the following code of `Patch.remove` can be made better? (It looks pretty naive but I'm not sure if using `set` would be more efficient...):\n> \n> ```\n> if isinstance(faces, Face):\n>     while faces in self._faces:\n>         self._faces.remove(faces)\n> else:\n>     for f in faces:\n>         while f in self._faces:\n>             self._faces.remove(f)\n> ```\n\nFirst, there is a problem with the method `remove` because it changes the\nPatch. Compare the methods and their name of the mutable unhashable Python set\nand the immutable and hashable Python frozenset :\n\n```\nsage: python_set = set([])\nsage: [method for method in dir(python_set) if not method.startswith('_')]\n['add', 'clear', 'copy', 'difference', 'difference_update', 'discard',\n'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset',\n'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update',\n'union', 'update']\nsage: frozen_set = frozenset()\nsage: [method for method in dir(frozen_set) if not method.startswith('_')]\n['copy', 'difference', 'intersection', 'isdisjoint', 'issubset', 'issuperset',\n'symmetric_difference', 'union']\n```\n\nHence, I suggest to implement a method called `difference` which returns a\nnew Patch instead of the method remove.\n\nMy last question concerns the representation of the Patch. Now, we represent a\npatch as a list of faces. I think this choice was made because we wanted an\nobject Patch to be mutable without loosing time on unicity of faces concerns\nwhich did not bothered us, since it is guarenteed mathematically (well at least\nfor the application of E1Stars). But, if a Patch is now immutable, maybe a\nPython frozenset or maybe a Sage Set (also immutable) would be better. \n\n```\nsage: sage_set = Set([])\nsage: [method for method in dir(sage_set) if not method.startswith('_')]\n['CartesianProduct', 'Hom', 'algebra', 'an_element', 'base', 'base_ring',\n'cardinality', 'cartesian_product', 'categories', 'category', 'coerce',\n'coerce_embedding', 'coerce_map_from', 'construction', 'convert_map_from',\n'db', 'difference', 'dump', 'dumps', 'element_class', 'frozenset', 'gens_dict',\n'get_action', 'has_base', 'has_coerce_map_from', 'hom', 'inject_variables',\n'injvar', 'intersection', 'is_exact', 'is_finite', 'latex_name',\n'latex_variable_names', 'list', 'normalize_names', 'object', 'objgen',\n'objgens', 'register_action', 'register_coercion', 'register_conversion',\n'register_embedding', 'rename', 'reset_name', 'save', 'set', 'some_elements',\n'subsets', 'symmetric_difference', 'union', 'variable_name', 'variable_names',\n'version']\n```\n\nWhat do you think?\n\nS\u00e9bastien",
    "created_at": "2011-05-04T14:03:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112726",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:6" align="right">comment:6</div>

> Here is why I added a `__hash__` method to Patch:
> 
> ```
> sage: P = Patch([Face([0,0,0],1), Face([0,0,0],2)])
> sage: Q = Patch([Face([0,0,0],2), Face([0,0,0],1)])
> sage: P == Q
> True
> sage: hash(P)
> 1297676529065262660
> sage: hash(Q)
> -8173426908364432914
> ```
> 
> I had a lot of problems because of this when I used some `DiGraphs` whose
> vertices were `Patches`. If you have a better solution, let me know. I added it
> in the doctest under a TEST section.

If we want Patches to be keys of dictionnary, vertices of graphs or elements of
sets, it must be hashable. The easiest solution I see is that an object Patch
be always hashable and never mutable. That means we made a mistake earlier by
allowing to modify a Patch. I am responsible for this as I remember I disliked
methods like `apply_substitution` but I were not able to verbalize it and
relate this with the ability of hashing the object.

There are three methods that change self : `add`, `apply_substitution`
and `repaint`. I think we can keep `repaint` as it does not change the
mathematical object and hence won't affect the result of the hash method (a
doctest making sure of that the hash method is independant of color changes
should be added).  Surprisingly, we did not made the mistake with the method
`translate` which does not change self and return a new patch. I think it
is easy to remove the method `apply_substitution` since (1) one can apply a
substitution by just applying a substiution directly on it : ``E(P)`` and (2)
the only reason I can understand the existence of the method
`apply_substitution` is that it is faster than doing ``E(P)`` which is not
the case anyway since it calls ``E(P)`` anyway. I also think the method
`add` can be easily removed. We should replace it by a method `__add__` or `union` which adds two patches and return a new patch.

Now, the method `adds` and `apply_substitution` should not be removed
right now. Deprecation warnings should be added. Well usually, a deprecation
warning should be raised for one year before removing the method. But, since I
believe fixing the immutable/hashable issue is very important. I think their
behavior could be changed now. A deprecation warning saying something like :
"Object sage.combinat.e_one_star.Patch are immutable since Sage-4.7.1. Use the
usual addition instead which returns a new object: P + Q." A similar warning
should be added to the method `apply_substitution`.

> Here is the problem with colors if we don't create new faces in Patch.__init__:
> 
> ```
> sage: P = Patch([Face([0,0,0],1), Face([0,0,0],2)])
> sage: Q = Patch(P)
> sage: P[0].color()
> RGB color (1.0, 0.0, 0.0)
> sage: Q[0].color('yellow')
> sage: P[0].color()
> RGB color (1.0, 1.0, 0.0)
> ```
> 
> Let me know if you have a better solution. I added it in the doctest under a TEST section.

One can create a Patch from a (1) iterable of faces or (2) from a Patch. The
problem comes from the case (2) were a copy should be done.  Here is my first
suggestion: 

```
if isinstance(faces, Patch):
    self._faces = [Face(f.vector(), f.type(), f.color()) for f in faces]
else:
    self._faces = list(faces)
```

> Please tell me if you agree with what I said concerning the main two issues you raised (`__hash__` and creating new faces in `Patch.__init__`). I will upload a new patch if you confirm.
> 
> Also, do you think the following code of `Patch.remove` can be made better? (It looks pretty naive but I'm not sure if using `set` would be more efficient...):
> 
> ```
> if isinstance(faces, Face):
>     while faces in self._faces:
>         self._faces.remove(faces)
> else:
>     for f in faces:
>         while f in self._faces:
>             self._faces.remove(f)
> ```

First, there is a problem with the method `remove` because it changes the
Patch. Compare the methods and their name of the mutable unhashable Python set
and the immutable and hashable Python frozenset :

```
sage: python_set = set([])
sage: [method for method in dir(python_set) if not method.startswith('_')]
['add', 'clear', 'copy', 'difference', 'difference_update', 'discard',
'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset',
'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update',
'union', 'update']
sage: frozen_set = frozenset()
sage: [method for method in dir(frozen_set) if not method.startswith('_')]
['copy', 'difference', 'intersection', 'isdisjoint', 'issubset', 'issuperset',
'symmetric_difference', 'union']
```

Hence, I suggest to implement a method called `difference` which returns a
new Patch instead of the method remove.

My last question concerns the representation of the Patch. Now, we represent a
patch as a list of faces. I think this choice was made because we wanted an
object Patch to be mutable without loosing time on unicity of faces concerns
which did not bothered us, since it is guarenteed mathematically (well at least
for the application of E1Stars). But, if a Patch is now immutable, maybe a
Python frozenset or maybe a Sage Set (also immutable) would be better. 

```
sage: sage_set = Set([])
sage: [method for method in dir(sage_set) if not method.startswith('_')]
['CartesianProduct', 'Hom', 'algebra', 'an_element', 'base', 'base_ring',
'cardinality', 'cartesian_product', 'categories', 'category', 'coerce',
'coerce_embedding', 'coerce_map_from', 'construction', 'convert_map_from',
'db', 'difference', 'dump', 'dumps', 'element_class', 'frozenset', 'gens_dict',
'get_action', 'has_base', 'has_coerce_map_from', 'hom', 'inject_variables',
'injvar', 'intersection', 'is_exact', 'is_finite', 'latex_name',
'latex_variable_names', 'list', 'normalize_names', 'object', 'objgen',
'objgens', 'register_action', 'register_coercion', 'register_conversion',
'register_embedding', 'rename', 'reset_name', 'save', 'set', 'some_elements',
'subsets', 'symmetric_difference', 'union', 'variable_name', 'variable_names',
'version']
```

What do you think?

Sébastien



---

archive/issue_comments_112727.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\n> Also, do you think the following code of `Patch.remove` can be made better? (It looks pretty naive but I'm not sure if using `set` would be more efficient...):\n\nThis problem would be solved by using a frozenset instead of a list for representing a Patch.",
    "created_at": "2011-05-04T14:04:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112727",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:7" align="right">comment:7</div>

> Also, do you think the following code of `Patch.remove` can be made better? (It looks pretty naive but I'm not sure if using `set` would be more efficient...):

This problem would be solved by using a frozenset instead of a list for representing a Patch.



---

archive/issue_comments_112728.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nReplying to [@seblabbe](#comment:6):\n> If we want Patches to be keys of dictionnary, vertices of graphs or elements of\n> sets, it must be hashable. The easiest solution I see is that an object Patch\n> be always hashable and never mutable. That means we made a mistake earlier by\n> allowing to modify a Patch. I am responsible for this as I remember I disliked\n> methods like `apply_substitution` but I were not able to verbalize it and\n> relate this with the ability of hashing the object.\n> \n> There are three methods that change self : `add`, `apply_substitution`\n> and `repaint`. I think we can keep `repaint` as it does not change the\n> mathematical object and hence won't affect the result of the hash method (a\n> doctest making sure of that the hash method is independant of color changes\n> should be added).  Surprisingly, we did not made the mistake with the method\n> `translate` which does not change self and return a new patch. I think it\n> is easy to remove the method `apply_substitution` since (1) one can apply a\n> substitution by just applying a substiution directly on it : ``E(P)`` and (2)\n> the only reason I can understand the existence of the method\n> `apply_substitution` is that it is faster than doing ``E(P)`` which is not\n> the case anyway since it calls ``E(P)`` anyway. I also think the method\n> `add` can be easily removed. We should replace it by a method `__add__` or `union` which adds two patches and return a new patch.\n> \n> Now, the method `adds` and `apply_substitution` should not be removed\n> right now. Deprecation warnings should be added. Well usually, a deprecation\n> warning should be raised for one year before removing the method. But, since I\n> believe fixing the immutable/hashable issue is very important. I think their\n> behavior could be changed now. A deprecation warning saying something like :\n> \"Object sage.combinat.e_one_star.Patch are immutable since Sage-4.7.1. Use the\n> usual addition instead which returns a new object: P + Q.\" A similar warning\n> should be added to the method `apply_substitution`.\n\nOK, these methods now return a new patch, along with a deprecation warning.\nI changed the doc in favor of using `E1Star.__call__` insead of `apply_substitution`.\n\n> One can create a Patch from a (1) iterable of faces or (2) from a Patch. The\n> problem comes from the case (2) were a copy should be done.  Here is my first\n> suggestion: \n> \n> ```\n> if isinstance(faces, Patch):\n>     self._faces = [Face(f.vector(), f.type(), f.color()) for f in faces]\n> else:\n>     self._faces = list(faces)\n> ```\n\nThis is a good solution, I use it.\n\n> First, there is a problem with the method `remove` because it changes the\n> Patch. Compare the methods and their name of the mutable unhashable Python set\n> and the immutable and hashable Python frozenset :\n> \n> ```\n> sage: python_set = set([])\n> sage: [method for method in dir(python_set) if not method.startswith('_')]\n> ['add', 'clear', 'copy', 'difference', 'difference_update', 'discard',\n> 'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset',\n> 'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update',\n> 'union', 'update']\n> sage: frozen_set = frozenset()\n> sage: [method for method in dir(frozen_set) if not method.startswith('_')]\n> ['copy', 'difference', 'intersection', 'isdisjoint', 'issubset', 'issuperset',\n> 'symmetric_difference', 'union']\n> ```\n> \n> Hence, I suggest to implement a method called `difference` which returns a\n> new Patch instead of the method remove.\n\nOK, I this is also a better solution. I also added a `union` method, that does the job that `Patch.add` was supposed to do (so that the deprecation warning of `add` is not annoying when `__add__` is used). The method `remove` no longer exists.\n\n> My last question concerns the representation of the Patch. Now, we represent a\n> patch as a list of faces. I think this choice was made because we wanted an\n> object Patch to be mutable without loosing time on unicity of faces concerns\n> which did not bothered us, since it is guarenteed mathematically (well at least\n> for the application of E1Stars). But, if a Patch is now immutable, maybe a\n> Python frozenset or maybe a Sage Set (also immutable) would be better. \n> \n> ```\n> sage: sage_set = Set([])\n> sage: [method for method in dir(sage_set) if not method.startswith('_')]\n> ['CartesianProduct', 'Hom', 'algebra', 'an_element', 'base', 'base_ring',\n> 'cardinality', 'cartesian_product', 'categories', 'category', 'coerce',\n> 'coerce_embedding', 'coerce_map_from', 'construction', 'convert_map_from',\n> 'db', 'difference', 'dump', 'dumps', 'element_class', 'frozenset', 'gens_dict',\n> 'get_action', 'has_base', 'has_coerce_map_from', 'hom', 'inject_variables',\n> 'injvar', 'intersection', 'is_exact', 'is_finite', 'latex_name',\n> 'latex_variable_names', 'list', 'normalize_names', 'object', 'objgen',\n> 'objgens', 'register_action', 'register_coercion', 'register_conversion',\n> 'register_embedding', 'rename', 'reset_name', 'save', 'set', 'some_elements',\n> 'subsets', 'symmetric_difference', 'union', 'variable_name', 'variable_names',\n> 'version']\n> ```\n> \n> What do you think?\n\nEverything is cleaner if we use sets instead of lists, you're right. I submitted a new patch that uses frozenset and made the according changes in the doc and everywhere, which means quite a lot of stuff as you will see in my new patch, which applies over the previous one.\n\nAlso, I added an option in `E1Star.__init__`: we can now choose between the 'suffix' or 'prefix' version of the dual substitution. The default one ('suffix') is the one that was used before. Adding this is important because both versions are widely used in the literature. (I also moved `_base_iter` from a method to a direct creation in `__init__`, the gain of time given by `@lazy_attribute` was really negligible.)\n\nThank you for your very useful corrections.\n\nFor the patchbot :\n\nApply trac-11255-tj.patch\n\nApply trac-11255-tj-modifs.patch",
    "created_at": "2011-05-05T11:16:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112728",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:8" align="right">comment:8</div>

Replying to [@seblabbe](#comment:6):
> If we want Patches to be keys of dictionnary, vertices of graphs or elements of
> sets, it must be hashable. The easiest solution I see is that an object Patch
> be always hashable and never mutable. That means we made a mistake earlier by
> allowing to modify a Patch. I am responsible for this as I remember I disliked
> methods like `apply_substitution` but I were not able to verbalize it and
> relate this with the ability of hashing the object.
> 
> There are three methods that change self : `add`, `apply_substitution`
> and `repaint`. I think we can keep `repaint` as it does not change the
> mathematical object and hence won't affect the result of the hash method (a
> doctest making sure of that the hash method is independant of color changes
> should be added).  Surprisingly, we did not made the mistake with the method
> `translate` which does not change self and return a new patch. I think it
> is easy to remove the method `apply_substitution` since (1) one can apply a
> substitution by just applying a substiution directly on it : ``E(P)`` and (2)
> the only reason I can understand the existence of the method
> `apply_substitution` is that it is faster than doing ``E(P)`` which is not
> the case anyway since it calls ``E(P)`` anyway. I also think the method
> `add` can be easily removed. We should replace it by a method `__add__` or `union` which adds two patches and return a new patch.
> 
> Now, the method `adds` and `apply_substitution` should not be removed
> right now. Deprecation warnings should be added. Well usually, a deprecation
> warning should be raised for one year before removing the method. But, since I
> believe fixing the immutable/hashable issue is very important. I think their
> behavior could be changed now. A deprecation warning saying something like :
> "Object sage.combinat.e_one_star.Patch are immutable since Sage-4.7.1. Use the
> usual addition instead which returns a new object: P + Q." A similar warning
> should be added to the method `apply_substitution`.

OK, these methods now return a new patch, along with a deprecation warning.
I changed the doc in favor of using `E1Star.__call__` insead of `apply_substitution`.

> One can create a Patch from a (1) iterable of faces or (2) from a Patch. The
> problem comes from the case (2) were a copy should be done.  Here is my first
> suggestion: 
> 
> ```
> if isinstance(faces, Patch):
>     self._faces = [Face(f.vector(), f.type(), f.color()) for f in faces]
> else:
>     self._faces = list(faces)
> ```

This is a good solution, I use it.

> First, there is a problem with the method `remove` because it changes the
> Patch. Compare the methods and their name of the mutable unhashable Python set
> and the immutable and hashable Python frozenset :
> 
> ```
> sage: python_set = set([])
> sage: [method for method in dir(python_set) if not method.startswith('_')]
> ['add', 'clear', 'copy', 'difference', 'difference_update', 'discard',
> 'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset',
> 'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update',
> 'union', 'update']
> sage: frozen_set = frozenset()
> sage: [method for method in dir(frozen_set) if not method.startswith('_')]
> ['copy', 'difference', 'intersection', 'isdisjoint', 'issubset', 'issuperset',
> 'symmetric_difference', 'union']
> ```
> 
> Hence, I suggest to implement a method called `difference` which returns a
> new Patch instead of the method remove.

OK, I this is also a better solution. I also added a `union` method, that does the job that `Patch.add` was supposed to do (so that the deprecation warning of `add` is not annoying when `__add__` is used). The method `remove` no longer exists.

> My last question concerns the representation of the Patch. Now, we represent a
> patch as a list of faces. I think this choice was made because we wanted an
> object Patch to be mutable without loosing time on unicity of faces concerns
> which did not bothered us, since it is guarenteed mathematically (well at least
> for the application of E1Stars). But, if a Patch is now immutable, maybe a
> Python frozenset or maybe a Sage Set (also immutable) would be better. 
> 
> ```
> sage: sage_set = Set([])
> sage: [method for method in dir(sage_set) if not method.startswith('_')]
> ['CartesianProduct', 'Hom', 'algebra', 'an_element', 'base', 'base_ring',
> 'cardinality', 'cartesian_product', 'categories', 'category', 'coerce',
> 'coerce_embedding', 'coerce_map_from', 'construction', 'convert_map_from',
> 'db', 'difference', 'dump', 'dumps', 'element_class', 'frozenset', 'gens_dict',
> 'get_action', 'has_base', 'has_coerce_map_from', 'hom', 'inject_variables',
> 'injvar', 'intersection', 'is_exact', 'is_finite', 'latex_name',
> 'latex_variable_names', 'list', 'normalize_names', 'object', 'objgen',
> 'objgens', 'register_action', 'register_coercion', 'register_conversion',
> 'register_embedding', 'rename', 'reset_name', 'save', 'set', 'some_elements',
> 'subsets', 'symmetric_difference', 'union', 'variable_name', 'variable_names',
> 'version']
> ```
> 
> What do you think?

Everything is cleaner if we use sets instead of lists, you're right. I submitted a new patch that uses frozenset and made the according changes in the doc and everywhere, which means quite a lot of stuff as you will see in my new patch, which applies over the previous one.

Also, I added an option in `E1Star.__init__`: we can now choose between the 'suffix' or 'prefix' version of the dual substitution. The default one ('suffix') is the one that was used before. Adding this is important because both versions are widely used in the literature. (I also moved `_base_iter` from a method to a direct creation in `__init__`, the gain of time given by `@lazy_attribute` was really negligible.)

Thank you for your very useful corrections.

For the patchbot :

Apply trac-11255-tj.patch

Apply trac-11255-tj-modifs.patch



---

archive/issue_events_149181.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-05-05T11:16:39Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149181"
}
```



---

archive/issue_events_149182.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-05-05T11:16:39Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149182"
}
```



---

archive/issue_comments_112729.json:
```json
{
    "body": "applies over the first patch",
    "created_at": "2011-05-06T11:22:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112729",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

applies over the first patch



---

archive/issue_comments_112730.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nAttachment: **[trac-11255-tj-modifs.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj-modifs.patch.gz)**\n\nDear S\u00e9bastien, I just added a `Patch.__sub__` method, which acts as `Patch.__difference__`, I overrode trac-11255-tj-modifs.patch.",
    "created_at": "2011-05-06T11:26:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112730",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:9" align="right">comment:9</div>

Attachment: **[trac-11255-tj-modifs.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj-modifs.patch.gz)**

Dear Sébastien, I just added a `Patch.__sub__` method, which acts as `Patch.__difference__`, I overrode trac-11255-tj-modifs.patch.



---

archive/issue_comments_112731.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -3,3 +3,7 @@\n * `remove` method;\n * `__hash__` method;\n * deal more cleanly with construction of new patches (sometimes the same Face belonged to different patches, which caused problems with colors, for example).\n+\n+For the patchbot (this info must be put here instead of below):\n+\n+Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch\n``````\n",
    "created_at": "2011-05-11T21:47:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112731",
    "user": "https://github.com/seblabbe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -3,3 +3,7 @@
 * `remove` method;
 * `__hash__` method;
 * deal more cleanly with construction of new patches (sometimes the same Face belonged to different patches, which caused problems with colors, for example).
+
+For the patchbot (this info must be put here instead of below):
+
+Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch
``````




---

archive/issue_comments_112732.json:
```json
{
    "body": "Attachment: **[trac_11255_reviewer-sl.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-sl.patch.gz)**\n\nApplies over the precedent 2 patches",
    "created_at": "2011-05-11T21:48:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112732",
    "user": "https://github.com/seblabbe"
}
```

Attachment: **[trac_11255_reviewer-sl.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-sl.patch.gz)**

Applies over the precedent 2 patches



---

archive/issue_comments_112733.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nI just added a reviewer patch which applies over the precedent two. There was doctest errors with the hash method (I obtain different hash results on my machine).\n\nI still have concerns with two things before giving a positive review : (1) I think the method `Patch.__getitem__` should be removed as the result can be different on other machine and (2) the ordering of the iter method of a Patch is not guarenteed. So the result of the tikz method may change on other machine which may lead to doctest problem later. So I suggest not to change the tikz method, but rather change the way we test them.",
    "created_at": "2011-05-11T21:54:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112733",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:11" align="right">comment:11</div>

I just added a reviewer patch which applies over the precedent two. There was doctest errors with the hash method (I obtain different hash results on my machine).

I still have concerns with two things before giving a positive review : (1) I think the method `Patch.__getitem__` should be removed as the result can be different on other machine and (2) the ordering of the iter method of a Patch is not guarenteed. So the result of the tikz method may change on other machine which may lead to doctest problem later. So I suggest not to change the tikz method, but rather change the way we test them.



---

archive/issue_events_149183.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2011-05-11T21:54:08Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149183"
}
```



---

archive/issue_events_149184.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2011-05-11T21:54:08Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149184"
}
```



---

archive/issue_comments_112734.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nHi, thanks for you corrections and your patch.\n\n> I still have concerns with two things before giving a positive review : (1) I think the method `Patch.__getitem__` should be removed as the result can be different on other machine and (2) the ordering of the iter method of a Patch is not guarenteed. So the result of the tikz method may change on other machine which may lead to doctest problem later. So I suggest not to change the tikz method, but rather change the way we test them. \n\nI would like to keep the `__getitem__` method because we use it often when we need to pick an arbitrary face of a patch. But we should in this case write a WARNING in the doc, I agree that the result changing from machine to machine can be confusing.\n\nI will soon make the changes to the doc to prevent the `__iter__` ordering problems. (Should be easy by comparing strings or by using `__sorted__`. How do you think should the tikz output be tested to prevent these problems?",
    "created_at": "2011-05-12T12:11:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112734",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:12" align="right">comment:12</div>

Hi, thanks for you corrections and your patch.

> I still have concerns with two things before giving a positive review : (1) I think the method `Patch.__getitem__` should be removed as the result can be different on other machine and (2) the ordering of the iter method of a Patch is not guarenteed. So the result of the tikz method may change on other machine which may lead to doctest problem later. So I suggest not to change the tikz method, but rather change the way we test them. 

I would like to keep the `__getitem__` method because we use it often when we need to pick an arbitrary face of a patch. But we should in this case write a WARNING in the doc, I agree that the result changing from machine to machine can be confusing.

I will soon make the changes to the doc to prevent the `__iter__` ordering problems. (Should be easy by comparing strings or by using `__sorted__`. How do you think should the tikz output be tested to prevent these problems?



---

archive/issue_comments_112735.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -6,4 +6,4 @@\n \n For the patchbot (this info must be put here instead of below):\n \n-Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch\n+Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch trac_11255_modifs2-tj.patch\n``````\n",
    "created_at": "2011-05-19T13:38:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112735",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -6,4 +6,4 @@
 
 For the patchbot (this info must be put here instead of below):
 
-Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch
+Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch trac_11255_modifs2-tj.patch
``````




---

archive/issue_events_149185.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-05-19T13:38:32Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149185"
}
```



---

archive/issue_events_149186.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-05-19T13:38:32Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149186"
}
```



---

archive/issue_comments_112736.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nHi,\n\nFour things:\n\nI have solved all the doc problems related to the fact that `Patch.__getitem__` doesn't necessarily return the same result from machine to machine. I would like to keep this convenient method (it is used in various other methods and I use it personally for some other tasks). I wrote a WARNING in the doc about this fact.\n\nThe `plot_tikz` doctesting problem related to the non-order of `Patch.__iter__` has been solved.\n\nI optimized a little the `plot_tikz` method, by printing a `\\definecolor` only when a new color is needed.\n\nAlso, I have been more careful about making new Faces when creating new Patches. It is not enough to create new Faces only when `isinstance(other, Patch)` in `Patch.__add__`: for example, if we get a list L of faces that belong to a patch P, and then create the patch Q + L, the faces of L have to be copied, otherwise changing the color of Q will also change some colors of P. I have solved all instances of this potential problem.",
    "created_at": "2011-05-19T13:38:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112736",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:13" align="right">comment:13</div>

Hi,

Four things:

I have solved all the doc problems related to the fact that `Patch.__getitem__` doesn't necessarily return the same result from machine to machine. I would like to keep this convenient method (it is used in various other methods and I use it personally for some other tasks). I wrote a WARNING in the doc about this fact.

The `plot_tikz` doctesting problem related to the non-order of `Patch.__iter__` has been solved.

I optimized a little the `plot_tikz` method, by printing a `\definecolor` only when a new color is needed.

Also, I have been more careful about making new Faces when creating new Patches. It is not enough to create new Faces only when `isinstance(other, Patch)` in `Patch.__add__`: for example, if we get a list L of faces that belong to a patch P, and then create the patch Q + L, the faces of L have to be copied, otherwise changing the color of Q will also change some colors of P. I have solved all instances of this potential problem.



---

archive/issue_events_149187.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2011-05-20T13:46:32Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149187"
}
```



---

archive/issue_events_149188.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2011-05-20T13:46:32Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149188"
}
```



---

archive/issue_comments_112737.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nSalut Timo,\n\nExcuse-moi pour la derni\u00e8re semaine, j'aurais d\u00fb te r\u00e9pondre avant.\n\n> I have solved all the doc problems related to the fact that `Patch.__getitem__` doesn't necessarily return the same result from machine to machine. I would like to keep this convenient method (it is used in various other methods and I use it personally for some other tasks). I wrote a WARNING in the doc about this fact.\n\nI still have problem with that. By implementing `__getitem__` you kind of tell the user that this is a good method to use. Indeed it is practical to use the square bracquets. The problem is that the method is very slow. It makes a list everytime it is called. Suppose for instance the user use getitem 5 times in a row (which is natural). This will create 5 times the same list. I still believe the method `__getitem__` should be removed. If the user wants to get the 5th element, he will create the list himself and that's it. This is better and avoids misunderstanding of the representation. It is a set. It behaves as a set. And if you want the i-th element of a python set, what do you do? The same thing.\n\nI have another argument. Not only it may affect the doctests depending on the machine as I said earlier. But also, and more importantly, it affects the fiability of the code someone write. I know you know the warning. But such a warning is not natural for the method getitem. Hence, some user will write code, send it to a friend, and it might be broken.\n\nIn other words, implement `__getitem__` only if it constant time and of course if its result is guarenteed...\n\n> The `plot_tikz` doctesting problem related to the non-order of `Patch.__iter__` has been solved.\n\nYou solved it by just adding ` # not tested ` right? You should add ` # random ` instead so the code will be tested (makes sure no error) but not the result.\n\n> I optimized a little the `plot_tikz` method, by printing a `\\definecolor` only when a new color is needed.\n\nOK\n\n> Also, I have been more careful about making new Faces when creating new Patches. It is not enough to create new Faces only when `isinstance(other, Patch)` in `Patch.__add__`: for example, if we get a list L of faces that belong to a patch P, and then create the patch Q + L, the faces of L have to be copied, otherwise changing the color of Q will also change some colors of P. I have solved all instances of this potential problem.\n\nOK. Fine. But now, I think we are doing too much. How many copies of copies do we need to be safe? I think one is enough. For instance, here :\n\n```diff\n- return Patch(self._faces.difference(other)) \n+ P = Patch(self) \n+ Q = Patch(other) \n+ return Patch(P._faces.difference(Q)) \n```\n\nThe line `return Patch(self._faces.difference(other))` is OK if the copy is always done by the `__init__` method. Note that this is done at least 3 times in the code.",
    "created_at": "2011-05-20T13:46:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112737",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:14" align="right">comment:14</div>

Salut Timo,

Excuse-moi pour la dernière semaine, j'aurais dû te répondre avant.

> I have solved all the doc problems related to the fact that `Patch.__getitem__` doesn't necessarily return the same result from machine to machine. I would like to keep this convenient method (it is used in various other methods and I use it personally for some other tasks). I wrote a WARNING in the doc about this fact.

I still have problem with that. By implementing `__getitem__` you kind of tell the user that this is a good method to use. Indeed it is practical to use the square bracquets. The problem is that the method is very slow. It makes a list everytime it is called. Suppose for instance the user use getitem 5 times in a row (which is natural). This will create 5 times the same list. I still believe the method `__getitem__` should be removed. If the user wants to get the 5th element, he will create the list himself and that's it. This is better and avoids misunderstanding of the representation. It is a set. It behaves as a set. And if you want the i-th element of a python set, what do you do? The same thing.

I have another argument. Not only it may affect the doctests depending on the machine as I said earlier. But also, and more importantly, it affects the fiability of the code someone write. I know you know the warning. But such a warning is not natural for the method getitem. Hence, some user will write code, send it to a friend, and it might be broken.

In other words, implement `__getitem__` only if it constant time and of course if its result is guarenteed...

> The `plot_tikz` doctesting problem related to the non-order of `Patch.__iter__` has been solved.

You solved it by just adding ` # not tested ` right? You should add ` # random ` instead so the code will be tested (makes sure no error) but not the result.

> I optimized a little the `plot_tikz` method, by printing a `\definecolor` only when a new color is needed.

OK

> Also, I have been more careful about making new Faces when creating new Patches. It is not enough to create new Faces only when `isinstance(other, Patch)` in `Patch.__add__`: for example, if we get a list L of faces that belong to a patch P, and then create the patch Q + L, the faces of L have to be copied, otherwise changing the color of Q will also change some colors of P. I have solved all instances of this potential problem.

OK. Fine. But now, I think we are doing too much. How many copies of copies do we need to be safe? I think one is enough. For instance, here :

```diff
- return Patch(self._faces.difference(other)) 
+ P = Patch(self) 
+ Q = Patch(other) 
+ return Patch(P._faces.difference(Q)) 
```

The line `return Patch(self._faces.difference(other))` is OK if the copy is always done by the `__init__` method. Note that this is done at least 3 times in the code.



---

archive/issue_comments_112738.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\n> for example, if we get a list L of faces that belong to a patch P, and then create the patch Q + L, the faces of L have to be copied, otherwise changing the color of Q will also change some colors of P. \n\nAgain, add such an example in the doctests.\n\nS\u00e9bastien",
    "created_at": "2011-05-20T13:54:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112738",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:15" align="right">comment:15</div>

> for example, if we get a list L of faces that belong to a patch P, and then create the patch Q + L, the faces of L have to be copied, otherwise changing the color of Q will also change some colors of P. 

Again, add such an example in the doctests.

Sébastien



---

archive/issue_events_149189.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-05-22T09:36:49Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149189"
}
```



---

archive/issue_events_149190.json:
```json
{
    "actor": "https://github.com/sagetrac-tjolivet",
    "created_at": "2011-05-22T09:36:49Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149190"
}
```



---

archive/issue_comments_112739.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nReplying to [@seblabbe](#comment:14):\n> I still have problem with that. By implementing `__getitem__` you kind of tell the user that this is a good method to use. Indeed it is practical to use the square bracquets. The problem is that the method is very slow. It makes a list everytime it is called. Suppose for instance the user use getitem 5 times in a row (which is natural). This will create 5 times the same list. I still believe the method `__getitem__` should be removed. If the user wants to get the 5th element, he will create the list himself and that's it. This is better and avoids misunderstanding of the representation. It is a set. It behaves as a set. And if you want the i-th element of a python set, what do you do? The same thing.\n\n>\n> I have another argument. Not only it may affect the doctests depending on the machine as I said earlier. But also, and more importantly, it affects the fiability of the code someone write. I know you know the warning. But such a warning is not natural for the method getitem. Hence, some user will write code, send it to a friend, and it might be broken.\n>\n> In other words, implement `__getitem__` only if it constant time and of course if its result is guarenteed...\n>\n\nOK, there is no more `Patch.__getitem__` method. The only thing that bugs me is that we have to create a whole iterable to pick a single element of a Patch: the best way I can think of is `list(P)[0]`. Using `random.choice` is of course overkill, and there is no `frozenst.pick_arbitrary` method (which would be nice...). I have added a `Patch.dimension()` method to avoid picking a face everytime we want to check the dimension of Patch. Hence, faces are \"picked\" two times in the code: in `Patch.__init__`, and in `Patch.occurences_of`.\n\n\n> > The `plot_tikz` doctesting problem related to the non-order of `Patch.__iter__` has been solved.\n\n>\n> You solved it by just adding ` # not tested ` right? You should add ` # random ` instead so the code will be tested (makes sure no error) but not the result.\n>\n\nNo, the code is tested as it should (even the length of the returned string is tested). Only `print s` is not tested.\n\n\n> > Also, I have been more careful about making new Faces when creating new Patches. It is not enough to create new Faces only when `isinstance(other, Patch)` in `Patch.__add__`: for example, if we get a list L of faces that belong to a patch P, and then create the patch Q + L, the faces of L have to be copied, otherwise changing the color of Q will also change some colors of P. I have solved all instances of this potential problem.\n\n>\n>OK. Fine. But now, I think we are doing too much. How many copies of copies do we need to be safe? I think one is enough. For instance, here :\n>\n> ```diff\n> - return Patch(self._faces.difference(other))\n> + P = Patch(self)\n> + Q = Patch(other)\n> + return Patch(P._faces.difference(Q))\n> ```\n>\n> The line `return Patch(self._faces.difference(other))` is OK if the copy is always done by the `__init__` method. Note that this is done at least 3 times in the code.\n\nThere were indeed too many copies, I changed that.\n\nI uploaded a new version of the last patch.\n\nCheers,\nTimo",
    "created_at": "2011-05-22T09:36:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112739",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:16" align="right">comment:16</div>

Replying to [@seblabbe](#comment:14):
> I still have problem with that. By implementing `__getitem__` you kind of tell the user that this is a good method to use. Indeed it is practical to use the square bracquets. The problem is that the method is very slow. It makes a list everytime it is called. Suppose for instance the user use getitem 5 times in a row (which is natural). This will create 5 times the same list. I still believe the method `__getitem__` should be removed. If the user wants to get the 5th element, he will create the list himself and that's it. This is better and avoids misunderstanding of the representation. It is a set. It behaves as a set. And if you want the i-th element of a python set, what do you do? The same thing.

>
> I have another argument. Not only it may affect the doctests depending on the machine as I said earlier. But also, and more importantly, it affects the fiability of the code someone write. I know you know the warning. But such a warning is not natural for the method getitem. Hence, some user will write code, send it to a friend, and it might be broken.
>
> In other words, implement `__getitem__` only if it constant time and of course if its result is guarenteed...
>

OK, there is no more `Patch.__getitem__` method. The only thing that bugs me is that we have to create a whole iterable to pick a single element of a Patch: the best way I can think of is `list(P)[0]`. Using `random.choice` is of course overkill, and there is no `frozenst.pick_arbitrary` method (which would be nice...). I have added a `Patch.dimension()` method to avoid picking a face everytime we want to check the dimension of Patch. Hence, faces are "picked" two times in the code: in `Patch.__init__`, and in `Patch.occurences_of`.


> > The `plot_tikz` doctesting problem related to the non-order of `Patch.__iter__` has been solved.

>
> You solved it by just adding ` # not tested ` right? You should add ` # random ` instead so the code will be tested (makes sure no error) but not the result.
>

No, the code is tested as it should (even the length of the returned string is tested). Only `print s` is not tested.


> > Also, I have been more careful about making new Faces when creating new Patches. It is not enough to create new Faces only when `isinstance(other, Patch)` in `Patch.__add__`: for example, if we get a list L of faces that belong to a patch P, and then create the patch Q + L, the faces of L have to be copied, otherwise changing the color of Q will also change some colors of P. I have solved all instances of this potential problem.

>
>OK. Fine. But now, I think we are doing too much. How many copies of copies do we need to be safe? I think one is enough. For instance, here :
>
> ```diff
> - return Patch(self._faces.difference(other))
> + P = Patch(self)
> + Q = Patch(other)
> + return Patch(P._faces.difference(Q))
> ```
>
> The line `return Patch(self._faces.difference(other))` is OK if the copy is always done by the `__init__` method. Note that this is done at least 3 times in the code.

There were indeed too many copies, I changed that.

I uploaded a new version of the last patch.

Cheers,
Timo



---

archive/issue_comments_112740.json:
```json
{
    "body": "Attachment: **[trac_11255_modifs2-tj.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac_11255_modifs2-tj.patch.gz)**",
    "created_at": "2011-05-22T09:37:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112740",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

Attachment: **[trac_11255_modifs2-tj.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac_11255_modifs2-tj.patch.gz)**



---

archive/issue_comments_112741.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\n> The only thing that bugs me is that we have to create a whole iterable to pick a single element of a Patch: the best way I can think of is `list(P)[0]`. Using `random.choice` is of course overkill, and there is no `frozenst.pick_arbitrary` method (which would be nice...).\n\nTo get the first element, you can do:\n\n```\nsage: S = set(range(10))             \nsage: next(iter(S))     # or equivalently: iter(S).next()       \n0  \n```\n\nTo get the i-th element:\n\n```\nsage: from itertools import islice   \nsage: next(islice(iter(S), 7, None)) \n7                                    \n```\n\nI look at your patch and review it soon. Je crois bien qu'on y est maintenant!\n\nS\u00e9bastien",
    "created_at": "2011-05-22T20:18:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112741",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:17" align="right">comment:17</div>

> The only thing that bugs me is that we have to create a whole iterable to pick a single element of a Patch: the best way I can think of is `list(P)[0]`. Using `random.choice` is of course overkill, and there is no `frozenst.pick_arbitrary` method (which would be nice...).

To get the first element, you can do:

```
sage: S = set(range(10))             
sage: next(iter(S))     # or equivalently: iter(S).next()       
0  
```

To get the i-th element:

```
sage: from itertools import islice   
sage: next(islice(iter(S), 7, None)) 
7                                    
```

I look at your patch and review it soon. Je crois bien qu'on y est maintenant!

Sébastien



---

archive/issue_comments_112742.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nI just upload a patch which applies over all the precedent ones. The positive\nreview is near.  Again, I have one question about the methods\n`faces_of_vector`, `faces_of_type`:\n\n```diff\n-    return [face for face in self if face.vector() == vector(v)] \n+    return [Face(f.vector(), f.type(), f.color()) for f in self if f.vector() == vector(v)] \n```\n\n\n```diff\n-    return [face for face in self if face.type() == t] \n+    return [Face(f.vector(), f.type(), f.color()) for f in self if f.type() == t] \n```\n\nWhy do we need copies in those cases?\n\nS\u00e9bastien",
    "created_at": "2011-05-24T20:05:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112742",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:18" align="right">comment:18</div>

I just upload a patch which applies over all the precedent ones. The positive
review is near.  Again, I have one question about the methods
`faces_of_vector`, `faces_of_type`:

```diff
-    return [face for face in self if face.vector() == vector(v)] 
+    return [Face(f.vector(), f.type(), f.color()) for f in self if f.vector() == vector(v)] 
```


```diff
-    return [face for face in self if face.type() == t] 
+    return [Face(f.vector(), f.type(), f.color()) for f in self if f.type() == t] 
```

Why do we need copies in those cases?

Sébastien



---

archive/issue_comments_112743.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -6,4 +6,4 @@\n \n For the patchbot (this info must be put here instead of below):\n \n-Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch trac_11255_modifs2-tj.patch\n+Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch trac_11255_modifs2-tj.patch trac_11255_reviewer-2nd-sl.patch\n``````\n",
    "created_at": "2011-05-24T20:12:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112743",
    "user": "https://github.com/seblabbe"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -6,4 +6,4 @@
 
 For the patchbot (this info must be put here instead of below):
 
-Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch trac_11255_modifs2-tj.patch
+Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch trac_11255_modifs2-tj.patch trac_11255_reviewer-2nd-sl.patch
``````




---

archive/issue_comments_112744.json:
```json
{
    "body": "Reviewer: **S\u00e9bastien Labb\u00e9**",
    "created_at": "2011-05-24T20:12:23Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112744",
    "user": "https://github.com/seblabbe"
}
```

Reviewer: **Sébastien Labbé**



---

archive/issue_comments_112745.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nReplying to [@seblabbe](#comment:18):\n> Why do we need copies in those cases?\n\nHi, if for some reason the user repaints the returned faces, we don't want it to change the color of the faces in the original Patch.\n\nOtherwise, are you sure about the `next(iter(P))` trick? The other seems faster:\n\n```\nsage: a = frozenset(range(10000))\nsage: timeit('list(a)[0]')\n625 loops, best of 3: 107 \u00b5s per loop\nsage: timeit('next(iter(a))')\n625 loops, best of 3: 607 ns per loop\n```",
    "created_at": "2011-05-24T20:16:34Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112745",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:20" align="right">comment:20</div>

Replying to [@seblabbe](#comment:18):
> Why do we need copies in those cases?

Hi, if for some reason the user repaints the returned faces, we don't want it to change the color of the faces in the original Patch.

Otherwise, are you sure about the `next(iter(P))` trick? The other seems faster:

```
sage: a = frozenset(range(10000))
sage: timeit('list(a)[0]')
625 loops, best of 3: 107 µs per loop
sage: timeit('next(iter(a))')
625 loops, best of 3: 607 ns per loop
```



---

archive/issue_comments_112746.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\n`next(iter(a))` is faster.  One of those timings is microseconds and the other is nanoseconds.",
    "created_at": "2011-05-24T20:21:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112746",
    "user": "https://github.com/mwhansen"
}
```

<div id="comment:21" align="right">comment:21</div>

`next(iter(a))` is faster.  One of those timings is microseconds and the other is nanoseconds.



---

archive/issue_comments_112747.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nI feel I should and could be cited as an author of the file `e_one_star.py` especially for the big modifications we made together on the file last year. I added my name in the last patch. Do you agree Timo?\n\nS\u00e9bastien",
    "created_at": "2011-05-24T20:22:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112747",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:22" align="right">comment:22</div>

I feel I should and could be cited as an author of the file `e_one_star.py` especially for the big modifications we made together on the file last year. I added my name in the last patch. Do you agree Timo?

Sébastien



---

archive/issue_comments_112748.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nReplying to [@seblabbe](#comment:22):\n> I feel I should and could be cited as an author of the file `e_one_star.py` especially for the big modifications we made together on the file last year. I added my name in the last patch. Do you agree Timo?\n\nOf course! I thought so since the work we had done in Porquerolles but you wanted to be a reviewer instead. It's good that you added yourself.\n\nOtherwise, I agree with the other changes of your last patch.",
    "created_at": "2011-05-24T20:25:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112748",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:23" align="right">comment:23</div>

Replying to [@seblabbe](#comment:22):
> I feel I should and could be cited as an author of the file `e_one_star.py` especially for the big modifications we made together on the file last year. I added my name in the last patch. Do you agree Timo?

Of course! I thought so since the work we had done in Porquerolles but you wanted to be a reviewer instead. It's good that you added yourself.

Otherwise, I agree with the other changes of your last patch.



---

archive/issue_comments_112749.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nReplying to [@sagetrac-tjolivet](#comment:20):\n> Replying to [@seblabbe](#comment:18):\n> > Why do we need copies in those cases?\n\n> \n> Hi, if for some reason the user repaints the returned faces, we don't want it to change the color of the faces in the original Patch.\n\nWhat if the user wants to get the faces of a certain type and does not want to repaint them? We do useless copies in that case. I feel like those methods should return the faces as they are. I think the user may make the copies himself.\n\nIt is like if the patch was a Python set. Iterating through it iterates through its elements (not copies of them).\n\n```\nsage: f = Face((0,0,0), 1, color='red')      \nsage: g = copy(f)                            \nsage: g.color()                              \nRGB color (1.0, 0.0, 0.0)                    \nsage: f.color('black')                       \nsage: g.color()                              \nRGB color (1.0, 0.0, 0.0)                    \nsage: f.color()                              \nRGB color (0.0, 0.0, 0.0)                    \n```\n\nS\u00e9bastien",
    "created_at": "2011-05-24T20:35:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112749",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:24" align="right">comment:24</div>

Replying to [@sagetrac-tjolivet](#comment:20):
> Replying to [@seblabbe](#comment:18):
> > Why do we need copies in those cases?

> 
> Hi, if for some reason the user repaints the returned faces, we don't want it to change the color of the faces in the original Patch.

What if the user wants to get the faces of a certain type and does not want to repaint them? We do useless copies in that case. I feel like those methods should return the faces as they are. I think the user may make the copies himself.

It is like if the patch was a Python set. Iterating through it iterates through its elements (not copies of them).

```
sage: f = Face((0,0,0), 1, color='red')      
sage: g = copy(f)                            
sage: g.color()                              
RGB color (1.0, 0.0, 0.0)                    
sage: f.color('black')                       
sage: g.color()                              
RGB color (1.0, 0.0, 0.0)                    
sage: f.color()                              
RGB color (0.0, 0.0, 0.0)                    
```

Sébastien



---

archive/issue_events_149191.json:
```json
{
    "actor": "https://github.com/sagetrac-sage-combinat",
    "created_at": "2011-05-24T20:49:22Z",
    "event": "unassigned",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "subject": "https://github.com/sagetrac-tjolivet",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149191"
}
```



---

archive/issue_comments_112750.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nReplying to [@seblabbe](#comment:24):\n> What if the user wants to get the faces of a certain type and does not want to repaint them? We do useless copies in that case. I feel like those methods should return the faces as they are. I think the user may make the copies himself.\n> \n> It is like if the patch was a Python set. Iterating through it iterates through its elements (not copies of them).\n\nOK, I agree. If `Patch.__iter__` doesn't return new copies then `Patch.faces_of_truc` should behave the same. (And some user might also want to change the colors of the faces of given vector or type.)\n\nOh, I think we should also add a method `Patch.faces_of_color`. We just have to be careful about the input: we must convert it in the same way as we convert face colors, and we must take into account that color comparison is python is a bit strange:\n\n```\nsage: a = Color('red')\nsage: b = Color('red')\nsage: a == b\nFalse\nsage : tuple(a) == tuple(b)\nTrue\n```",
    "created_at": "2011-05-24T20:49:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112750",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:25" align="right">comment:25</div>

Replying to [@seblabbe](#comment:24):
> What if the user wants to get the faces of a certain type and does not want to repaint them? We do useless copies in that case. I feel like those methods should return the faces as they are. I think the user may make the copies himself.
> 
> It is like if the patch was a Python set. Iterating through it iterates through its elements (not copies of them).

OK, I agree. If `Patch.__iter__` doesn't return new copies then `Patch.faces_of_truc` should behave the same. (And some user might also want to change the colors of the faces of given vector or type.)

Oh, I think we should also add a method `Patch.faces_of_color`. We just have to be careful about the input: we must convert it in the same way as we convert face colors, and we must take into account that color comparison is python is a bit strange:

```
sage: a = Color('red')
sage: b = Color('red')
sage: a == b
False
sage : tuple(a) == tuple(b)
True
```



---

archive/issue_comments_112751.json:
```json
{
    "body": "Attachment: **[trac_11255_reviewer-2nd-sl.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-2nd-sl.patch.gz)**\n\nApplies over the precedent patches",
    "created_at": "2011-05-25T18:40:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112751",
    "user": "https://github.com/seblabbe"
}
```

Attachment: **[trac_11255_reviewer-2nd-sl.patch.gz](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-2nd-sl.patch.gz)**

Applies over the precedent patches



---

archive/issue_comments_112752.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nI am ready to give a positive review to this ticket. But before, Timo, you must check my last patch.\n\nS\u00e9bastien",
    "created_at": "2011-05-25T18:45:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112752",
    "user": "https://github.com/seblabbe"
}
```

<div id="comment:26" align="right">comment:26</div>

I am ready to give a positive review to this ticket. But before, Timo, you must check my last patch.

Sébastien



---

archive/issue_comments_112753.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">comment:27</div>\n\nReplying to [@seblabbe](#comment:26):\n> I am ready to give a positive review to this ticket. But before, Timo, you must check my last patch.\n\nVery good, I agree! Thanks a lot.",
    "created_at": "2011-05-25T19:40:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112753",
    "user": "https://github.com/sagetrac-tjolivet"
}
```

<div id="comment:27" align="right">comment:27</div>

Replying to [@seblabbe](#comment:26):
> I am ready to give a positive review to this ticket. But before, Timo, you must check my last patch.

Very good, I agree! Thanks a lot.



---

archive/issue_events_149192.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2011-05-26T02:17:43Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149192"
}
```



---

archive/issue_events_149193.json:
```json
{
    "actor": "https://github.com/seblabbe",
    "created_at": "2011-05-26T02:17:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149193"
}
```



---

archive/issue_comments_112754.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -6,4 +6,9 @@\n \n For the patchbot (this info must be put here instead of below):\n \n-Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch trac_11255_modifs2-tj.patch trac_11255_reviewer-2nd-sl.patch\n+Apply:\n+* [attachment: trac-11255-tj.patch](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj.patch.gz)\n+* [attachment: trac-11255-tj-modifs.patch](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj-modifs.patch.gz)\n+* [attachment: trac_11255_reviewer-sl.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-sl.patch.gz)\n+* [attachment: trac_11255_modifs2-tj.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_modifs2-tj.patch.gz)\n+* [attachment: trac_11255_reviewer-2nd-sl.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-2nd-sl.patch.gz)\n``````\n",
    "created_at": "2011-06-07T19:25:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112754",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -6,4 +6,9 @@
 
 For the patchbot (this info must be put here instead of below):
 
-Apply trac-11255-tj.patch trac-11255-tj-modifs.patch trac_11255_reviewer-sl.patch trac_11255_modifs2-tj.patch trac_11255_reviewer-2nd-sl.patch
+Apply:
+* [attachment: trac-11255-tj.patch](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj.patch.gz)
+* [attachment: trac-11255-tj-modifs.patch](https://github.com/sagemath/sage/files/ticket11255/trac-11255-tj-modifs.patch.gz)
+* [attachment: trac_11255_reviewer-sl.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-sl.patch.gz)
+* [attachment: trac_11255_modifs2-tj.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_modifs2-tj.patch.gz)
+* [attachment: trac_11255_reviewer-2nd-sl.patch](https://github.com/sagemath/sage/files/ticket11255/trac_11255_reviewer-2nd-sl.patch.gz)
``````




---

archive/issue_events_149194.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-06-08T07:13:36Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149194"
}
```



---

archive/issue_events_149195.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-06-08T07:13:36Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11255#event-149195"
}
```



---

archive/issue_comments_112755.json:
```json
{
    "body": "Merged: **sage-4.7.1.alpha3**",
    "created_at": "2011-06-08T07:13:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/11255",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11255#issuecomment-112755",
    "user": "https://github.com/jdemeyer"
}
```

Merged: **sage-4.7.1.alpha3**
