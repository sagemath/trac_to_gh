# Issue 11576: make it possible to generate sequences of variables easily

archive/issues_011404.json:
```json
{
    "body": "People are *always* asking how to get sequences of variables, like `a1,a2,a3,a4` or the like.  See [this ask.sagemath.org](http://ask.sagemath.org/question/611/implicitly-defining-a-sequence-of-variables) question, for example.\n\nJason Grout has an interesting possible solution that should find a home somewhere in Sage\n(see [sage-support discussion](https://groups.google.com/d/topic/sage-support/GFJdjFvKCvo/discussion)).\n\n> ```\n> class VariableGenerator(object):\n>      def __init__(self, prefix):\n>          self.__prefix = prefix\n>      @cached_method\n>      def __getitem__(self, key):\n>          return SR.var(\"%s%s\"%(self.__prefix,key))\n> ```\n> Now just specify a prefix, and then you can index to your heart's \n> content to generate variables.\n> \n> ```\n> a = VariableGenerator('a') # some people may like 'a_' as the prefix\n> a[0], a[1], a[2] # all variables\n> ```\n> Of course, this can easily be extended to using function call syntax:\n> a(0), or to using multiple indices: a[1,3].  Indeed, you can let your\n> imagination run wild and even do things like return full symbolic\n> matrices or vectors with slices: a[0:5, 0:5].\n\nApply [attachment:trac_11576-indexed_expression.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.patch)\n\n**Assignee:** @burcin\n\n**CC:**  @jasongrout @gvol @orlitzky @eviatarbach @slel\n\n**Keywords:** Cernay2012\n\nIssue created by migration from https://trac.sagemath.org/ticket/11576\n\n",
    "created_at": "2011-07-05T14:20:39Z",
    "labels": [
        "component: symbolics",
        "enhancement",
        "needs work"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-6.4",
    "title": "make it possible to generate sequences of variables easily",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/11576",
    "user": "https://github.com/kcrisman"
}
```
People are *always* asking how to get sequences of variables, like `a1,a2,a3,a4` or the like.  See [this ask.sagemath.org](http://ask.sagemath.org/question/611/implicitly-defining-a-sequence-of-variables) question, for example.

Jason Grout has an interesting possible solution that should find a home somewhere in Sage
(see [sage-support discussion](https://groups.google.com/d/topic/sage-support/GFJdjFvKCvo/discussion)).

> ```
> class VariableGenerator(object):
>      def __init__(self, prefix):
>          self.__prefix = prefix
>      @cached_method
>      def __getitem__(self, key):
>          return SR.var("%s%s"%(self.__prefix,key))
> ```
> Now just specify a prefix, and then you can index to your heart's 
> content to generate variables.
> 
> ```
> a = VariableGenerator('a') # some people may like 'a_' as the prefix
> a[0], a[1], a[2] # all variables
> ```
> Of course, this can easily be extended to using function call syntax:
> a(0), or to using multiple indices: a[1,3].  Indeed, you can let your
> imagination run wild and even do things like return full symbolic
> matrices or vectors with slices: a[0:5, 0:5].

Apply [attachment:trac_11576-indexed_expression.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.patch)

**Assignee:** @burcin

**CC:**  @jasongrout @gvol @orlitzky @eviatarbach @slel

**Keywords:** Cernay2012

Issue created by migration from https://trac.sagemath.org/ticket/11576





---

archive/issue_comments_120740.json:
```json
{
    "body": "<a id='comment:1'></a>\nGiNaC already has indexed expressions. We should try to use what is there instead of coming up with a pure python solution ourselves. This was discussed on sage-devel a while ago, I even put up an experimental patch for it:\n\nhttp://groups.google.com/group/sage-devel/browse_thread/thread/69ab50fe11672111",
    "created_at": "2011-07-05T14:34:27Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120740",
    "user": "https://github.com/burcin"
}
```

<a id='comment:1'></a>
GiNaC already has indexed expressions. We should try to use what is there instead of coming up with a pure python solution ourselves. This was discussed on sage-devel a while ago, I even put up an experimental patch for it:

http://groups.google.com/group/sage-devel/browse_thread/thread/69ab50fe11672111



---

archive/issue_comments_120741.json:
```json
{
    "body": "<a id='comment:2'></a>\nThanks, Burcin!  I must have missed this somehow.  \n\n[Here](http://sage.math.washington.edu/home/burcin/indexed_expression.patch) is a link to the patch.\n\nFrom that thread:\n\n```\nNote that GiNaC cannot take derivatives of indexed expressions. \n```\nSo that means one couldn't say that `diff(a[1],a[1])==1`?  That would seem to be unfortunate.\n\nBy the way, note that Jason was just trying to find a way to make lots of GiNaC variables.  I don't think that these approaches are necessarily that different - for instance, a class like Jason's for non-indexed, but still many, variables of similar names, would, be, useful. , , ,",
    "created_at": "2011-07-05T14:43:17Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120741",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:2'></a>
Thanks, Burcin!  I must have missed this somehow.  

[Here](http://sage.math.washington.edu/home/burcin/indexed_expression.patch) is a link to the patch.

From that thread:

```
Note that GiNaC cannot take derivatives of indexed expressions. 
```
So that means one couldn't say that `diff(a[1],a[1])==1`?  That would seem to be unfortunate.

By the way, note that Jason was just trying to find a way to make lots of GiNaC variables.  I don't think that these approaches are necessarily that different - for instance, a class like Jason's for non-indexed, but still many, variables of similar names, would, be, useful. , , ,



---

archive/issue_comments_120742.json:
```json
{
    "body": "<a id='comment:3'></a>\nReplying to [kcrisman](#comment%3A2):\n \n> From that thread:\n\n\n ```\n Note that GiNaC cannot take derivatives of indexed expressions. \n ```\n> So that means one couldn't say that `diff(a[1],a[1])==1`?  That would seem to be unfortunate.\n\nI don't have time to test this right now, but if it really doesn't work, we could fix it or ask the GiNaC developers why they chose to omit this.\n\n> By the way, note that Jason was just trying to find a way to make lots of GiNaC variables.  I don't think that these approaches are necessarily that different - for instance, a class like Jason's for non-indexed, but still many, variables of similar names, would, be, useful. , , , \n\nIt would be useful to extend the `var()` syntax to support creating variables like 'a1, a2, ..., a10'. We should keep in mind the signature of other constructors like `PolynomialRing()` if we attempt this.\n\nIf we go further and try to support vectors and matrices with symbolic entries, it would be better to use the underlying GiNaC functionality. There is an example at the end of this page:\n\nhttp://www.ginac.de/tutorial/Indexed-objects.html\n\n\nIf you can propose a basic user interface, I'd be happy to help with at least the first steps of interfacing C++.",
    "created_at": "2011-07-05T16:20:55Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120742",
    "user": "https://github.com/burcin"
}
```

<a id='comment:3'></a>
Replying to [kcrisman](#comment%3A2):
 
> From that thread:


 ```
 Note that GiNaC cannot take derivatives of indexed expressions. 
 ```
> So that means one couldn't say that `diff(a[1],a[1])==1`?  That would seem to be unfortunate.

I don't have time to test this right now, but if it really doesn't work, we could fix it or ask the GiNaC developers why they chose to omit this.

> By the way, note that Jason was just trying to find a way to make lots of GiNaC variables.  I don't think that these approaches are necessarily that different - for instance, a class like Jason's for non-indexed, but still many, variables of similar names, would, be, useful. , , , 

It would be useful to extend the `var()` syntax to support creating variables like 'a1, a2, ..., a10'. We should keep in mind the signature of other constructors like `PolynomialRing()` if we attempt this.

If we go further and try to support vectors and matrices with symbolic entries, it would be better to use the underlying GiNaC functionality. There is an example at the end of this page:

http://www.ginac.de/tutorial/Indexed-objects.html


If you can propose a basic user interface, I'd be happy to help with at least the first steps of interfacing C++.



---

archive/issue_comments_120743.json:
```json
{
    "body": "<a id='comment:4'></a>\nPerhaps another motivation for using GiNaC functionality for this is that the alternative approach leaks. Watch the memory usage of\n\n```\nsage: for i in range(10^8):\n....:    l=1+SR.symbol(\"a%s\"%str(i))\n```\nPerhaps GiNaCs indexed variables are less prone to leaking?",
    "created_at": "2011-07-05T19:20:36Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120743",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:4'></a>
Perhaps another motivation for using GiNaC functionality for this is that the alternative approach leaks. Watch the memory usage of

```
sage: for i in range(10^8):
....:    l=1+SR.symbol("a%s"%str(i))
```
Perhaps GiNaCs indexed variables are less prone to leaking?



---

archive/attachments_015828.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "indexed_expression-experimental-fh.patch",
    "asset_url": "tarball://root/attachments/ticket11576/indexed_expression-experimental-fh.patch",
    "created_at": "2011-11-24T21:20:50Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket11576/indexed_expression-experimental-fh.patch",
    "user": "https://github.com/hivert"
}
```



---

archive/issue_comments_120744.json:
```json
{
    "body": "<a id='comment:6'></a>\n**Attachment:** [indexed_expression-experimental-fh.patch](https://github.com/sagemath/sage/files/ticket11576/indexed_expression-experimental-fh.patch)\n\nHi there,\n\nAs as said on sage-devel, I started to work on Burcin patch. My goal was to be\nable to index a variable by **any** Sage object (eg: integers, group\nelement, matrices...). So I extended a little Burcin patch. Now I'm faced with\nthe problem that GiNaC indexed variable seems to have a not trivial semantic\nthat I don't understand at all. Moreover I don't know how to debug Cython /\nC++ code so I'm quite stuck. Here is the problem I have.\n\nTo get it you should apply [attachment:indexed_expression-experimental-fh.patch](https://github.com/sagemath/sage/files/ticket11576/indexed_expression-experimental-fh.patch)\non a fresh Sage-4.7.2 install. Then I can\n\n```\nsage: m1 = matrix([1,2]); m1.set_immutable()\nsage: m2 = matrix([2,1]); m2.set_immutable()\nsage: a = x.ind[m1]; b = 2*x.ind[m2]\nsage: a + a\n2*x.[1 2]\nsage: a + b\nx.[1 2] + 2*x.[2 1]\n```\nwhich is, in my view very cool !\n\nHowever strange thing has occurred under the hood, in particular for a strange\nreason I don't understand Sage added the two matrices ! This is apparent in\n\n```\nsage: a = x.ind[Permutation([3,2,1])]; b = 2*x.ind[1]\nsage: a+b\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n\n/home/data/Sage-Install/sage-4.7.2/devel/sage-review/sage/symbolic/<ipython console> in <module>()\n\n/home/florent/src/Sage/sage/local/lib/python2.6/site-packages/sage/structure/element.so in sage.structure.element.RingElement.__add__ (sage/structure/element.c:11488)()\n\n/home/florent/src/Sage/sage/local/lib/python2.6/site-packages/sage/symbolic/expression.so in sage.symbolic.expression.Expression._add_ (sage/symbolic/expression.cpp:11082)()\n   2186                            relational_operator(_right._gobj))\n   2187         else:\n-> 2188             x = gadd(left._gobj, _right._gobj)\n   2189         return new_Expression_from_GEx(left._parent, x)\n   2190 \n\n/home/florent/src/Sage/sage/local/lib/python2.6/site-packages/sage/structure/element.so in sage.structure.element.RingElement.__sub__ (sage/structure/element.c:11816)()\n\n/home/florent/src/Sage/sage/local/lib/python2.6/site-packages/sage/structure/coerce.so in sage.structure.coerce.CoercionModel_cache_maps.bin_op (sage/structure/coerce.c:7489)()\n\nTypeError: unsupported operand parent(s) for '-': '<class 'sage.combinat.permutation.Permutation_class'>' and 'Integer Ring'\n```\nTo make thing crystal clear (I hope):\n\n```\nsage: class bla(SageObject):\n...       def __add__(self, other):\n...           print \"Addition called\"\nsage: a, b = x.ind[m1],2*x.ind[m2]\nsage: m1 = bla()\nsage: m2 = bla()\nsage: m1 + m2\nAddition called\nsage: m1*m2\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n\n/home/data/Sage-Install/sage-4.7.2/devel/sage-review/sage/symbolic/<ipython console> in <module>()\n\nTypeError: unsupported operand type(s) for *: 'bla' and 'bla'\n```\n\nWTF ! Why is it adding or multiplying my indices for nothing ! It is a problem\nof Ginac ? of the wrapper ? or behind the chair and the screen ?\n\nAny help greatly appreciated !\n\nCheers,\n\nFlorent\n\nPS: crosspost on sage-devel.",
    "created_at": "2011-11-24T21:20:50Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120744",
    "user": "https://github.com/hivert"
}
```

<a id='comment:6'></a>
**Attachment:** [indexed_expression-experimental-fh.patch](https://github.com/sagemath/sage/files/ticket11576/indexed_expression-experimental-fh.patch)

Hi there,

As as said on sage-devel, I started to work on Burcin patch. My goal was to be
able to index a variable by **any** Sage object (eg: integers, group
element, matrices...). So I extended a little Burcin patch. Now I'm faced with
the problem that GiNaC indexed variable seems to have a not trivial semantic
that I don't understand at all. Moreover I don't know how to debug Cython /
C++ code so I'm quite stuck. Here is the problem I have.

To get it you should apply [attachment:indexed_expression-experimental-fh.patch](https://github.com/sagemath/sage/files/ticket11576/indexed_expression-experimental-fh.patch)
on a fresh Sage-4.7.2 install. Then I can

```
sage: m1 = matrix([1,2]); m1.set_immutable()
sage: m2 = matrix([2,1]); m2.set_immutable()
sage: a = x.ind[m1]; b = 2*x.ind[m2]
sage: a + a
2*x.[1 2]
sage: a + b
x.[1 2] + 2*x.[2 1]
```
which is, in my view very cool !

However strange thing has occurred under the hood, in particular for a strange
reason I don't understand Sage added the two matrices ! This is apparent in

```
sage: a = x.ind[Permutation([3,2,1])]; b = 2*x.ind[1]
sage: a+b
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/data/Sage-Install/sage-4.7.2/devel/sage-review/sage/symbolic/<ipython console> in <module>()

/home/florent/src/Sage/sage/local/lib/python2.6/site-packages/sage/structure/element.so in sage.structure.element.RingElement.__add__ (sage/structure/element.c:11488)()

/home/florent/src/Sage/sage/local/lib/python2.6/site-packages/sage/symbolic/expression.so in sage.symbolic.expression.Expression._add_ (sage/symbolic/expression.cpp:11082)()
   2186                            relational_operator(_right._gobj))
   2187         else:
-> 2188             x = gadd(left._gobj, _right._gobj)
   2189         return new_Expression_from_GEx(left._parent, x)
   2190 

/home/florent/src/Sage/sage/local/lib/python2.6/site-packages/sage/structure/element.so in sage.structure.element.RingElement.__sub__ (sage/structure/element.c:11816)()

/home/florent/src/Sage/sage/local/lib/python2.6/site-packages/sage/structure/coerce.so in sage.structure.coerce.CoercionModel_cache_maps.bin_op (sage/structure/coerce.c:7489)()

TypeError: unsupported operand parent(s) for '-': '<class 'sage.combinat.permutation.Permutation_class'>' and 'Integer Ring'
```
To make thing crystal clear (I hope):

```
sage: class bla(SageObject):
...       def __add__(self, other):
...           print "Addition called"
sage: a, b = x.ind[m1],2*x.ind[m2]
sage: m1 = bla()
sage: m2 = bla()
sage: m1 + m2
Addition called
sage: m1*m2
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/home/data/Sage-Install/sage-4.7.2/devel/sage-review/sage/symbolic/<ipython console> in <module>()

TypeError: unsupported operand type(s) for *: 'bla' and 'bla'
```

WTF ! Why is it adding or multiplying my indices for nothing ! It is a problem
of Ginac ? of the wrapper ? or behind the chair and the screen ?

Any help greatly appreciated !

Cheers,

Florent

PS: crosspost on sage-devel.



---

archive/issue_comments_120745.json:
```json
{
    "body": "**Changing keywords** from \"\" to \"Cernay2012\".",
    "created_at": "2012-02-06T12:42:31Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120745",
    "user": "https://github.com/burcin"
}
```

**Changing keywords** from "" to "Cernay2012".



---

archive/issue_comments_120746.json:
```json
{
    "body": "<a id='comment:9'></a>\nAllow me to throw my entry into the ring.\n\nIt's not nearly as ambitious as Burcin & Florent's patches, but it does scratch the itch that most people have, and it's working and tested already.",
    "created_at": "2012-12-01T04:19:04Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120746",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:9'></a>
Allow me to throw my entry into the ring.

It's not nearly as ambitious as Burcin & Florent's patches, but it does scratch the itch that most people have, and it's working and tested already.



---

archive/issue_comments_120747.json:
```json
{
    "body": "<a id='comment:10'></a>\nI like a lot of it.  Obviously needs tests in the new class.  A few questions, which may betray ignorance:  \n* Is it okay that we don't overwrite the global variables?  I like that in principle, but there is similar confusion at times with PolynomialRings that have an x which isn't in SR while `sage: x` still returns the symbolic `x`.  Just asking.\n* One thing I don't like, or need explanation for, is the confusion in multi-index situations between the string (not LaTeX) reps of `x_{1}_{1}` and `x_{11}`, which are apparently both `x11`.  It's almost *too* flexible, because you don't have to say how many indices there will be ahead of time - which is useful, of course, but there might have to be something with the reps.\n* Should `SymbolSequence` inherit from something?",
    "created_at": "2012-12-01T14:47:06Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120747",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:10'></a>
I like a lot of it.  Obviously needs tests in the new class.  A few questions, which may betray ignorance:  
* Is it okay that we don't overwrite the global variables?  I like that in principle, but there is similar confusion at times with PolynomialRings that have an x which isn't in SR while `sage: x` still returns the symbolic `x`.  Just asking.
* One thing I don't like, or need explanation for, is the confusion in multi-index situations between the string (not LaTeX) reps of `x_{1}_{1}` and `x_{11}`, which are apparently both `x11`.  It's almost *too* flexible, because you don't have to say how many indices there will be ahead of time - which is useful, of course, but there might have to be something with the reps.
* Should `SymbolSequence` inherit from something?



---

archive/attachments_015829.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "sage-trac_11576.patch",
    "asset_url": "tarball://root/attachments/ticket11576/sage-trac_11576.patch",
    "created_at": "2012-12-01T17:02:31Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket11576/sage-trac_11576.patch",
    "user": "https://github.com/orlitzky"
}
```



---

archive/issue_comments_120748.json:
```json
{
    "body": "**Attachment:** [sage-trac_11576.patch](https://github.com/sagemath/sage/files/ticket11576/sage-trac_11576.patch)\n\nAdd tests for the individual class methods",
    "created_at": "2012-12-01T17:02:31Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120748",
    "user": "https://github.com/orlitzky"
}
```

**Attachment:** [sage-trac_11576.patch](https://github.com/sagemath/sage/files/ticket11576/sage-trac_11576.patch)

Add tests for the individual class methods



---

archive/issue_comments_120749.json:
```json
{
    "body": "<a id='comment:11'></a>\nReplying to [kcrisman](#comment%3A10):\n> I like a lot of it.  Obviously needs tests in the new class.\n\n\n\nI just updated the patch, each of the individual class methods now have their own examples.\n\n\n\n\n> A few questions, which may betray ignorance:  \n> * Is it okay that we don't overwrite the global variables?  I like that in principle, but there is similar confusion at times with PolynomialRings that have an x which isn't in SR while `sage: x` still returns the symbolic `x`.  Just asking.\n\n\n\nHaving two different `x`-things floating around -- one a python variable and one a symbol name -- is a little bad, but clobbering them is in my opinion worse. Essentially what I'm trying to do is make this act like `SR.symbol()` instead of `SR.var()`.\n\nThe `symbol()` function leaves the variables alone:\n\n```\nsage: y = 7    \nsage: SR.symbol('y')\ny\nsage: y\n7\n```\n\nNow there's a symbol floating around somewhere called `y`, but it isn't the python variable. The alternative is, in my opinion, much worse:\n\n```\nsage: y = 7         \nsage: var('y')\ny\nsage: y\ny\n```\n\nYou could argue that people expect that from `var()` these days, but they certainly wouldn't expect it from indexing some object. So this is what I **don't** want:\n\n```\nsage: y1 = 7             \nsage: ys = SR.symbols('y')\nsage: foo = ys[1]\nsage: y1\ny1\n```\n\nThe user never even wrote 'y1' anywhere, so I think it's dangerous to overwrite it.\n\n\n\n\n> * One thing I don't like, or need explanation for, is the confusion in multi-index situations between the string (not LaTeX) reps of `x_{1}_{1}` and `x_{11}`, which are apparently both `x11`.  It's almost *too* flexible, because you don't have to say how many indices there will be ahead of time - which is useful, of course, but there might have to be something with the reps.\n\n\n\nYou're right... my motivation was simply, \"make it easy to create a bunch of symbols,\" but I don't like this:\n\n```\nsage: a = SR.symbols('a')\nsage: bool(a[11] == a[1,1])\nTrue\n```\n\nThe next-best thing I can think of is to use underscores, like the latex representation. This makes everything a little uglier, but avoids the ambiguity. Thoughts?\n\n\n\n\n> * Should `SymbolSequence` inherit from something?\n\n\n\nI dunno. I think this is the first standalone class I've written for the sage library. Anyone know?",
    "created_at": "2012-12-01T17:21:17Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120749",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:11'></a>
Replying to [kcrisman](#comment%3A10):
> I like a lot of it.  Obviously needs tests in the new class.



I just updated the patch, each of the individual class methods now have their own examples.




> A few questions, which may betray ignorance:  
> * Is it okay that we don't overwrite the global variables?  I like that in principle, but there is similar confusion at times with PolynomialRings that have an x which isn't in SR while `sage: x` still returns the symbolic `x`.  Just asking.



Having two different `x`-things floating around -- one a python variable and one a symbol name -- is a little bad, but clobbering them is in my opinion worse. Essentially what I'm trying to do is make this act like `SR.symbol()` instead of `SR.var()`.

The `symbol()` function leaves the variables alone:

```
sage: y = 7    
sage: SR.symbol('y')
y
sage: y
7
```

Now there's a symbol floating around somewhere called `y`, but it isn't the python variable. The alternative is, in my opinion, much worse:

```
sage: y = 7         
sage: var('y')
y
sage: y
y
```

You could argue that people expect that from `var()` these days, but they certainly wouldn't expect it from indexing some object. So this is what I **don't** want:

```
sage: y1 = 7             
sage: ys = SR.symbols('y')
sage: foo = ys[1]
sage: y1
y1
```

The user never even wrote 'y1' anywhere, so I think it's dangerous to overwrite it.




> * One thing I don't like, or need explanation for, is the confusion in multi-index situations between the string (not LaTeX) reps of `x_{1}_{1}` and `x_{11}`, which are apparently both `x11`.  It's almost *too* flexible, because you don't have to say how many indices there will be ahead of time - which is useful, of course, but there might have to be something with the reps.



You're right... my motivation was simply, "make it easy to create a bunch of symbols," but I don't like this:

```
sage: a = SR.symbols('a')
sage: bool(a[11] == a[1,1])
True
```

The next-best thing I can think of is to use underscores, like the latex representation. This makes everything a little uglier, but avoids the ambiguity. Thoughts?




> * Should `SymbolSequence` inherit from something?



I dunno. I think this is the first standalone class I've written for the sage library. Anyone know?



---

archive/attachments_015830.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "underscores.patch",
    "asset_url": "tarball://root/attachments/ticket11576/underscores.patch",
    "created_at": "2012-12-01T17:34:11Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket11576/underscores.patch",
    "user": "https://github.com/orlitzky"
}
```



---

archive/issue_comments_120750.json:
```json
{
    "body": "**Attachment:** [underscores.patch](https://github.com/sagemath/sage/files/ticket11576/underscores.patch)\n\nUse underscores to separate indices (applies on top of previous patch)",
    "created_at": "2012-12-01T17:34:11Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120750",
    "user": "https://github.com/orlitzky"
}
```

**Attachment:** [underscores.patch](https://github.com/sagemath/sage/files/ticket11576/underscores.patch)

Use underscores to separate indices (applies on top of previous patch)



---

archive/issue_comments_120751.json:
```json
{
    "body": "<a id='comment:12'></a>\nIf you want to see what it would look like with underscores, the patch I just posted adds them and has a test for subscript collision.",
    "created_at": "2012-12-01T17:35:40Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120751",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:12'></a>
If you want to see what it would look like with underscores, the patch I just posted adds them and has a test for subscript collision.



---

archive/issue_comments_120752.json:
```json
{
    "body": "<a id='comment:13'></a>\nThanks for your comments - I think I agree with most of that.\n> You're right... my motivation was simply, \"make it easy to create a bunch of symbols,\" but I don't like this:\n> \n> ```\n> sage: a = SR.symbols('a')\n> sage: bool(a[11] == a[1,1])\n> True\n> ```\n> \n> The next-best thing I can think of is to use underscores, like the latex representation. This makes everything a little uglier, but avoids the ambiguity. Thoughts?\n\nYeah, I'm not sure either.  I'd appreciate input from people who actually *use* this stuff! I don't make such variable sequences in my own work.  I see your new patch, but it still looks like \n\n```\na_1_2_3_4_5_6 \n```\ncould represent a whole Catalan stew of different indices with the nested thing going on.   I don't feel like making this decision, but it would be a shame for something to languish.  Maybe Burcin or Florent have ideas - it *is* true that it's silly to reinvent the wheel if Ginac has this already, but we do now have a patch...\n\nAlso, what do you know about the memory leak issue in [comment:4](#comment%3A4)?\n\n> > * Should `SymbolSequence` inherit from something?\n\n> I dunno. I think this is the first standalone class I've written for the sage library. Anyone know?\n\nUsually at least from `SageObject`, I guess.  Would `Symbol` be appropriate, or maybe not?  What generic methods would you want available to this class via inheritance that `Symbol` already has?  I guess each individual symbol has everything that `Symbol` has.",
    "created_at": "2012-12-01T17:41:54Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120752",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:13'></a>
Thanks for your comments - I think I agree with most of that.
> You're right... my motivation was simply, "make it easy to create a bunch of symbols," but I don't like this:
> 
> ```
> sage: a = SR.symbols('a')
> sage: bool(a[11] == a[1,1])
> True
> ```
> 
> The next-best thing I can think of is to use underscores, like the latex representation. This makes everything a little uglier, but avoids the ambiguity. Thoughts?

Yeah, I'm not sure either.  I'd appreciate input from people who actually *use* this stuff! I don't make such variable sequences in my own work.  I see your new patch, but it still looks like 

```
a_1_2_3_4_5_6 
```
could represent a whole Catalan stew of different indices with the nested thing going on.   I don't feel like making this decision, but it would be a shame for something to languish.  Maybe Burcin or Florent have ideas - it *is* true that it's silly to reinvent the wheel if Ginac has this already, but we do now have a patch...

Also, what do you know about the memory leak issue in [comment:4](#comment%3A4)?

> > * Should `SymbolSequence` inherit from something?

> I dunno. I think this is the first standalone class I've written for the sage library. Anyone know?

Usually at least from `SageObject`, I guess.  Would `Symbol` be appropriate, or maybe not?  What generic methods would you want available to this class via inheritance that `Symbol` already has?  I guess each individual symbol has everything that `Symbol` has.



---

archive/issue_comments_120753.json:
```json
{
    "body": "<a id='comment:14'></a>\nI'm not thinking very good right now -- can you give an example of e.g. `a_1_2_3` being ambiguous?",
    "created_at": "2013-01-06T21:12:05Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120753",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:14'></a>
I'm not thinking very good right now -- can you give an example of e.g. `a_1_2_3` being ambiguous?



---

archive/issue_comments_120754.json:
```json
{
    "body": "<a id='comment:15'></a>\nIs it `a_1_{2_3}` or `a_{123}`?   I guess I was thinking of subscripts of subscripts.  Maybe that's not at issue here; I can't quite reconstruct my thinking then either.  Wasn't there some nesting somewhere in your patch?",
    "created_at": "2013-01-07T14:06:09Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120754",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:15'></a>
Is it `a_1_{2_3}` or `a_{123}`?   I guess I was thinking of subscripts of subscripts.  Maybe that's not at issue here; I can't quite reconstruct my thinking then either.  Wasn't there some nesting somewhere in your patch?



---

archive/issue_comments_120755.json:
```json
{
    "body": "<a id='comment:16'></a>\nReplying to [kcrisman](#comment%3A15):\n> Is it `a_1_{2_3}` or `a_{123}`?   I guess I was thinking of subscripts of subscripts.  Maybe that's not at issue here; I can't quite reconstruct my thinking then either.  Wasn't there some nesting somewhere in your patch?\n\nIt's `a_{1)_{2}_{3}`. To create `a_{123}`, you'd call `a[123]`. There is nesting going on, but each \"level\" should be separated by an underscore now. In fact now that we're only accepting the square brackets, I think commas should map directly to underscores. For example,\n\n```\nsage: xs[3, 8:10, 2:4]\n[xs_3_8_2, xs_3_8_3, xs_3_9_2, xs_3_9_3]\n```\n\nYou're allowed to think of `a[2,3]` as `a_{2_3}`, but I don't think there's any way to create it distinct from `a_{2}_{3}`. The implementation creates an `a_{2}` first, and then subscripts that with 3.\n\nI still think the underscores are a little ugly, but I've gotten used to them and it's preferable to having `a[1,1] - a[11] == 0`.",
    "created_at": "2013-01-07T14:39:02Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120755",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:16'></a>
Replying to [kcrisman](#comment%3A15):
> Is it `a_1_{2_3}` or `a_{123}`?   I guess I was thinking of subscripts of subscripts.  Maybe that's not at issue here; I can't quite reconstruct my thinking then either.  Wasn't there some nesting somewhere in your patch?

It's `a_{1)_{2}_{3}`. To create `a_{123}`, you'd call `a[123]`. There is nesting going on, but each "level" should be separated by an underscore now. In fact now that we're only accepting the square brackets, I think commas should map directly to underscores. For example,

```
sage: xs[3, 8:10, 2:4]
[xs_3_8_2, xs_3_8_3, xs_3_9_2, xs_3_9_3]
```

You're allowed to think of `a[2,3]` as `a_{2_3}`, but I don't think there's any way to create it distinct from `a_{2}_{3}`. The implementation creates an `a_{2}` first, and then subscripts that with 3.

I still think the underscores are a little ugly, but I've gotten used to them and it's preferable to having `a[1,1] - a[11] == 0`.



---

archive/issue_comments_120756.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [mjo](#comment%3A16):\n> Replying to [kcrisman](#comment%3A15):\n> > Is it `a_1_{2_3}` or `a_{123}`?   I guess I was thinking of subscripts of subscripts.  Maybe that's not at issue here; I can't quite reconstruct my thinking then either.  Wasn't there some nesting somewhere in your patch?\n\n> \n> It's `a_{1)_{2}_{3}`. To create `a_{123}`, you'd call `a[123]`. There is nesting going on, but each \"level\" should be separated by an underscore now. In fact now that we're only accepting the square brackets, I think commas should map directly to underscores. For example,\n> \n\nSo how would you distinguish `a_(1,2_3)` from `a_(1_2,3)` - or is that not at issue?  That's what I was getting at, I think.",
    "created_at": "2013-01-07T14:42:21Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120756",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:17'></a>
Replying to [mjo](#comment%3A16):
> Replying to [kcrisman](#comment%3A15):
> > Is it `a_1_{2_3}` or `a_{123}`?   I guess I was thinking of subscripts of subscripts.  Maybe that's not at issue here; I can't quite reconstruct my thinking then either.  Wasn't there some nesting somewhere in your patch?

> 
> It's `a_{1)_{2}_{3}`. To create `a_{123}`, you'd call `a[123]`. There is nesting going on, but each "level" should be separated by an underscore now. In fact now that we're only accepting the square brackets, I think commas should map directly to underscores. For example,
> 

So how would you distinguish `a_(1,2_3)` from `a_(1_2,3)` - or is that not at issue?  That's what I was getting at, I think.



---

archive/issue_comments_120757.json:
```json
{
    "body": "<a id='comment:18'></a>\nReplying to [kcrisman](#comment%3A17):\n> So how would you distinguish `a_(1,2_3)` from `a_(1_2,3)` - or is that not at issue?  That's what I was getting at, I think.\n\n\n\nNeither of those are directly constructible. It might be useful to make the bijection in your head, but `a_{1}_{2}_{3}` is all that my patch allows you to create. The user assigns alternate semantics at his own risk =)",
    "created_at": "2013-01-07T14:50:19Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120757",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:18'></a>
Replying to [kcrisman](#comment%3A17):
> So how would you distinguish `a_(1,2_3)` from `a_(1_2,3)` - or is that not at issue?  That's what I was getting at, I think.



Neither of those are directly constructible. It might be useful to make the bijection in your head, but `a_{1}_{2}_{3}` is all that my patch allows you to create. The user assigns alternate semantics at his own risk =)



---

archive/issue_comments_120758.json:
```json
{
    "body": "<a id='comment:19'></a>\n> Neither of those are directly constructible. It might be useful to make the bijection in your head, but `a_{1}_{2}_{3}` is all that my patch allows you to create. The user assigns alternate semantics at his own risk =)\n\nOkay, so there is only `a_(1,2,3)` and `a_(12,3)` and `a_(123)` and friends, everything at one level.\n\nI'd probably be okay with this then, but I'd really like some input from Burcin and/or Florent as to how compatible this might be with *eventually* using Ginac's capabilities.  I would view doing this natively as a temporary measure.  For instance, have you checked how this performs with respect to Nils' comment about memory usage?",
    "created_at": "2013-01-07T15:15:49Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120758",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:19'></a>
> Neither of those are directly constructible. It might be useful to make the bijection in your head, but `a_{1}_{2}_{3}` is all that my patch allows you to create. The user assigns alternate semantics at his own risk =)

Okay, so there is only `a_(1,2,3)` and `a_(12,3)` and `a_(123)` and friends, everything at one level.

I'd probably be okay with this then, but I'd really like some input from Burcin and/or Florent as to how compatible this might be with *eventually* using Ginac's capabilities.  I would view doing this natively as a temporary measure.  For instance, have you checked how this performs with respect to Nils' comment about memory usage?



---

archive/issue_comments_120759.json:
```json
{
    "body": "<a id='comment:20'></a>\nReplying to [kcrisman](#comment%3A19):\n> I'd probably be okay with this then, but I'd really like some input from Burcin and/or Florent as to how compatible this might be with *eventually* using Ginac's capabilities.  I would view doing this natively as a temporary measure.  For instance, have you checked how this performs with respect to Nils' comment about memory usage?\n\nHopefully we could just deprecate `SR.Symbols()` and tell people to use the indexed symbols instead. Which memory usage comment do you mean?",
    "created_at": "2013-01-07T15:31:49Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120759",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:20'></a>
Replying to [kcrisman](#comment%3A19):
> I'd probably be okay with this then, but I'd really like some input from Burcin and/or Florent as to how compatible this might be with *eventually* using Ginac's capabilities.  I would view doing this natively as a temporary measure.  For instance, have you checked how this performs with respect to Nils' comment about memory usage?

Hopefully we could just deprecate `SR.Symbols()` and tell people to use the indexed symbols instead. Which memory usage comment do you mean?



---

archive/issue_comments_120760.json:
```json
{
    "body": "<a id='comment:21'></a>\n> *eventually* using Ginac's capabilities.  I would view doing this natively as a temporary measure.  For instance, have you checked how this performs with respect to Nils' comment about memory usage?\n> \n> Hopefully we could just deprecate `SR.Symbols()`\n\n? isn't this the new thing you just added? (well, `symbols`, but I don't see `Symbols` or `Symbol` - or did you mean `symbol`?)\n>  and tell people to use the indexed symbols instead. Which memory usage comment do you mean?\n\ncomment:4",
    "created_at": "2013-01-07T15:39:48Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120760",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:21'></a>
> *eventually* using Ginac's capabilities.  I would view doing this natively as a temporary measure.  For instance, have you checked how this performs with respect to Nils' comment about memory usage?
> 
> Hopefully we could just deprecate `SR.Symbols()`

? isn't this the new thing you just added? (well, `symbols`, but I don't see `Symbols` or `Symbol` - or did you mean `symbol`?)
>  and tell people to use the indexed symbols instead. Which memory usage comment do you mean?

comment:4



---

archive/attachments_015831.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "trac_11576-indexed_expression.20130107.patch",
    "asset_url": "tarball://root/attachments/ticket11576/trac_11576-indexed_expression.20130107.patch",
    "created_at": "2013-01-07T16:01:09Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.20130107.patch",
    "user": "https://github.com/burcin"
}
```



---

archive/issue_comments_120761.json:
```json
{
    "body": "<a id='comment:22'></a>\n**Attachment:** [trac_11576-indexed_expression.20130107.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.20130107.patch)\n\nReplying to [nbruin](#comment%3A4):\n> Perhaps another motivation for using GiNaC functionality for this is that the alternative approach leaks. Watch the memory usage of\n> \n> ```\n> sage: for i in range(10^8):\n> ....:    l=1+SR.symbol(\"a%s\"%str(i))\n> ```\n> Perhaps GiNaCs indexed variables are less prone to leaking?\n\nI'm not sure if anything is `_leaking_` here. Pynac stores a symbol lookup table, in order to give you the same variable if you ask for SR.symbol('x') twice. As you pass new strings to this function, the lookup table grows. Note that if you repeat the same loop, memory usage does not grow.\n\nI agree that this is a good argument for using indexed variables from Pynac/GiNaC instead of trying to invent our own. Here are some numbers:\n\n```\nsage: get_memory_usage()\n866.94921875\nsage: x.ind[5]\nx.5\nsage: for i in range(10000):\n....:     t = x.ind[i]\n....:     \nsage: get_memory_usage()\n867.2265625\nsage: for i in range(10000):                  \n....:     t = SR.symbol('a_'+str(i))\n....:     \nsage: get_memory_usage()                                    \n870.4140625\n```\n\nThis is with [attachment:trac_11576-indexed_expression.20130107.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.20130107.patch). I just rebased the patch I was working on at the Sage days in Cernay.\n\nApart from lack of documentation and tests, this patch provides the functionality discussed in this ticket. The main problem holding it up was the fact that it allows you to use arbitrary Python objects as indices, and these are not handled properly when the expression is being converted to Maxima.",
    "created_at": "2013-01-07T16:01:09Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120761",
    "user": "https://github.com/burcin"
}
```

<a id='comment:22'></a>
**Attachment:** [trac_11576-indexed_expression.20130107.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.20130107.patch)

Replying to [nbruin](#comment%3A4):
> Perhaps another motivation for using GiNaC functionality for this is that the alternative approach leaks. Watch the memory usage of
> 
> ```
> sage: for i in range(10^8):
> ....:    l=1+SR.symbol("a%s"%str(i))
> ```
> Perhaps GiNaCs indexed variables are less prone to leaking?

I'm not sure if anything is `_leaking_` here. Pynac stores a symbol lookup table, in order to give you the same variable if you ask for SR.symbol('x') twice. As you pass new strings to this function, the lookup table grows. Note that if you repeat the same loop, memory usage does not grow.

I agree that this is a good argument for using indexed variables from Pynac/GiNaC instead of trying to invent our own. Here are some numbers:

```
sage: get_memory_usage()
866.94921875
sage: x.ind[5]
x.5
sage: for i in range(10000):
....:     t = x.ind[i]
....:     
sage: get_memory_usage()
867.2265625
sage: for i in range(10000):                  
....:     t = SR.symbol('a_'+str(i))
....:     
sage: get_memory_usage()                                    
870.4140625
```

This is with [attachment:trac_11576-indexed_expression.20130107.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.20130107.patch). I just rebased the patch I was working on at the Sage days in Cernay.

Apart from lack of documentation and tests, this patch provides the functionality discussed in this ticket. The main problem holding it up was the fact that it allows you to use arbitrary Python objects as indices, and these are not handled properly when the expression is being converted to Maxima.



---

archive/issue_comments_120762.json:
```json
{
    "body": "<a id='comment:23'></a>\n> I just rebased the patch I was working on at the Sage days in Cernay.\n\nWith Sage 5.6.beta2:\n\n```\npatching file sage/libs/ginac.pxd\nHunk #2 FAILED at 101\n```\nThe two lines with `dbgprint` are gone in beta2.\n\n> Apart from lack of documentation and tests, this patch provides the functionality discussed in this ticket. The main problem holding it up was the fact that it allows you to use arbitrary Python objects as indices, and these are not handled properly when the expression is being converted to Maxima.\n\nWe could just disallow anything that didn't fit a number or regular expression with commas or something.\n\nThis patch is somewhat different also in that\n\n```\nraise NotImplementedError(\"don't know what to do with multiple indices yet!\") \n```\nand I have to say I do like being able to use slice notation directly on the variable.\n\nAlso,\n\n```\nsage: x.ind[2:6]\nx.2\n```\nseems counterintuitive for a couple reasons - the dot suggests an attribute to me in Python, and where are the other indices?  I'm also not sure I like allowing indexing of non-variables, but that might be ignorance and fear speaking.  I just don't know what \n\n```\nsage: ex.ind[p]\n(x + 1).[2, 1, 3]\n```\nreally means.",
    "created_at": "2013-01-07T16:17:28Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120762",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:23'></a>
> I just rebased the patch I was working on at the Sage days in Cernay.

With Sage 5.6.beta2:

```
patching file sage/libs/ginac.pxd
Hunk #2 FAILED at 101
```
The two lines with `dbgprint` are gone in beta2.

> Apart from lack of documentation and tests, this patch provides the functionality discussed in this ticket. The main problem holding it up was the fact that it allows you to use arbitrary Python objects as indices, and these are not handled properly when the expression is being converted to Maxima.

We could just disallow anything that didn't fit a number or regular expression with commas or something.

This patch is somewhat different also in that

```
raise NotImplementedError("don't know what to do with multiple indices yet!") 
```
and I have to say I do like being able to use slice notation directly on the variable.

Also,

```
sage: x.ind[2:6]
x.2
```
seems counterintuitive for a couple reasons - the dot suggests an attribute to me in Python, and where are the other indices?  I'm also not sure I like allowing indexing of non-variables, but that might be ignorance and fear speaking.  I just don't know what 

```
sage: ex.ind[p]
(x + 1).[2, 1, 3]
```
really means.



---

archive/issue_comments_120763.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [kcrisman](#comment%3A21):\n> > *eventually* using Ginac's capabilities.  I would view doing this natively as a temporary measure.  For instance, have you checked how this performs with respect to Nils' comment about memory usage?\n> > \n> > Hopefully we could just deprecate `SR.Symbols()`\n\n> ? isn't this the new thing you just added? (well, `symbols`, but I don't see `Symbols` or `Symbol` - or did you mean `symbol`?)\n\n\n\nTypo, I meant lowercase `SR.symbols()`. Yeah, it's the thing I just added. But if there's ever a simpler solution with the same functionality, we could deprecate it. If I can just call `x[1, 2:3]` directly, then there's no need to do `x = SR.symbols(); x[1, 2:3]`.\n\n\n\n\n\n> >  and tell people to use the indexed symbols instead. Which memory usage comment do you mean?\n\n> comment:4\n\n\n\nOh, right. As Burcin pointed out, there's no leak, it's just creating symbols and they use up some memory. If you stick to the same symbols, memory usage won't grow.\n\nI can see the value in being able to use arbitrary subscripts, but I also like being able to do the common case quickly and easily. `x.ind[1]` is a little weird, especially if we can't use multiple indices. I also don't think it makes much sense to subscript `SR(1).ind[5]` and have it display `1.5`.",
    "created_at": "2013-01-07T19:54:47Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120763",
    "user": "https://github.com/orlitzky"
}
```

<a id='comment:24'></a>
Replying to [kcrisman](#comment%3A21):
> > *eventually* using Ginac's capabilities.  I would view doing this natively as a temporary measure.  For instance, have you checked how this performs with respect to Nils' comment about memory usage?
> > 
> > Hopefully we could just deprecate `SR.Symbols()`

> ? isn't this the new thing you just added? (well, `symbols`, but I don't see `Symbols` or `Symbol` - or did you mean `symbol`?)



Typo, I meant lowercase `SR.symbols()`. Yeah, it's the thing I just added. But if there's ever a simpler solution with the same functionality, we could deprecate it. If I can just call `x[1, 2:3]` directly, then there's no need to do `x = SR.symbols(); x[1, 2:3]`.





> >  and tell people to use the indexed symbols instead. Which memory usage comment do you mean?

> comment:4



Oh, right. As Burcin pointed out, there's no leak, it's just creating symbols and they use up some memory. If you stick to the same symbols, memory usage won't grow.

I can see the value in being able to use arbitrary subscripts, but I also like being able to do the common case quickly and easily. `x.ind[1]` is a little weird, especially if we can't use multiple indices. I also don't think it makes much sense to subscript `SR(1).ind[5]` and have it display `1.5`.



---

archive/issue_comments_120764.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [mjo](#comment%3A24):\n> Oh, right. As Burcin pointed out, there's no leak, it's just creating symbols and they use up some memory. If you stick to the same symbols, memory usage won't grow.\n\nIndeed. The issue is that once you can create sequences of symbols *easily*, people might start doing that more and hence memory footprint might become more of an issue.\n\nWhen creating arbitrary symbols, one cannot really avoid adding an entry in a table somewhere. In principle, weak caching strategies should allow reclaiming that at some point, but coordination across various interfaces and libraries (specifically maxima) will make it *very* hard to estimate the lifetime of a symbol properly. Hence, a permanent memory cost for the creation of a new symbol is so hard to avoid that we should probably consider it unavoidable.\n\nIt would be nice if the permanent cost of a symbol sequence is only for the sequence, not for every member generated in it. Note that\n\n```\nfor i in [1..10^8]:\n    print sin(i)\n```\ndoes *not* explode in memory, because the entry `sin` in the symbol table gets combined with an *argument* `i` that varies. No further permanent entries are made. I bet that `Ginac` does something similar for its sequences of symbols (i.e., it probably stores a base symbol together with an index. Essentially a function call, but labelled in such a way that it gets handles as an atomic, free, entity. Implementation is really easy in theory: any simplification/rewrite routine should simply *not* descend further into the tree)\n\nIdeally, one would have to find a way of encoding such symbols for `maxima` and `maxima_lib` as well, to avoid the (permanent) translation tables there to blow up as well. I don't know how easy it is to create structures capable of storing a serial number AND allowing differentiating etc. against it. Perhaps just encoding as an (uninterned) symbol might work. If you encode the string heavily enough you may be able to recognize them on the way out. For `maxima_lib` you could also store a flag as an attribute on the symbol and test for that in conversion back to sage (maxima uses something like this for \"dummy\"  variables somewhere).\n\nHowever, if you can't figure out how to do this for maxima, at least you may be able to avoid memory blow-up as long as these symbols don't touch various interfaces.\n\nI think that if you think this is worth doing, it's worth doing it well. I think sage has now matured to the point where putting in features via cheap hacks does more harm than good. (In fact the cheap hacks that were necessary to get the project up and running originally are now hurting further development.)",
    "created_at": "2013-01-07T20:58:16Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120764",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:25'></a>
Replying to [mjo](#comment%3A24):
> Oh, right. As Burcin pointed out, there's no leak, it's just creating symbols and they use up some memory. If you stick to the same symbols, memory usage won't grow.

Indeed. The issue is that once you can create sequences of symbols *easily*, people might start doing that more and hence memory footprint might become more of an issue.

When creating arbitrary symbols, one cannot really avoid adding an entry in a table somewhere. In principle, weak caching strategies should allow reclaiming that at some point, but coordination across various interfaces and libraries (specifically maxima) will make it *very* hard to estimate the lifetime of a symbol properly. Hence, a permanent memory cost for the creation of a new symbol is so hard to avoid that we should probably consider it unavoidable.

It would be nice if the permanent cost of a symbol sequence is only for the sequence, not for every member generated in it. Note that

```
for i in [1..10^8]:
    print sin(i)
```
does *not* explode in memory, because the entry `sin` in the symbol table gets combined with an *argument* `i` that varies. No further permanent entries are made. I bet that `Ginac` does something similar for its sequences of symbols (i.e., it probably stores a base symbol together with an index. Essentially a function call, but labelled in such a way that it gets handles as an atomic, free, entity. Implementation is really easy in theory: any simplification/rewrite routine should simply *not* descend further into the tree)

Ideally, one would have to find a way of encoding such symbols for `maxima` and `maxima_lib` as well, to avoid the (permanent) translation tables there to blow up as well. I don't know how easy it is to create structures capable of storing a serial number AND allowing differentiating etc. against it. Perhaps just encoding as an (uninterned) symbol might work. If you encode the string heavily enough you may be able to recognize them on the way out. For `maxima_lib` you could also store a flag as an attribute on the symbol and test for that in conversion back to sage (maxima uses something like this for "dummy"  variables somewhere).

However, if you can't figure out how to do this for maxima, at least you may be able to avoid memory blow-up as long as these symbols don't touch various interfaces.

I think that if you think this is worth doing, it's worth doing it well. I think sage has now matured to the point where putting in features via cheap hacks does more harm than good. (In fact the cheap hacks that were necessary to get the project up and running originally are now hurting further development.)



---

archive/issue_comments_120765.json:
```json
{
    "body": "Rebased patch",
    "created_at": "2013-06-18T17:56:38Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120765",
    "user": "https://github.com/vbraun"
}
```

Rebased patch



---

archive/attachments_015832.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "trac_11576-indexed_expression.patch",
    "asset_url": "tarball://root/attachments/ticket11576/trac_11576-indexed_expression.patch",
    "created_at": "2013-06-18T17:57:17Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "attachment",
    "url": "https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.patch",
    "user": "https://github.com/vbraun"
}
```



---

archive/issue_comments_120766.json:
```json
{
    "body": "<a id='comment:27'></a>\n**Attachment:** [trac_11576-indexed_expression.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.patch)\n\nRebased on top of Sage-5.10.rc2",
    "created_at": "2013-06-18T17:57:17Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120766",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:27'></a>
**Attachment:** [trac_11576-indexed_expression.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.patch)

Rebased on top of Sage-5.10.rc2



---

archive/issue_comments_120767.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -19,3 +19,5 @@\n imagination run wild and even do things like return full symbolic \n matrices or vectors with slices: a[0:5, 0:5]. \n ```\n+\n+Apply [attachment:trac_11576-indexed_expression.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.patch)\n``````\n",
    "created_at": "2013-06-18T17:57:17Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120767",
    "user": "https://github.com/vbraun"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -19,3 +19,5 @@
 imagination run wild and even do things like return full symbolic 
 matrices or vectors with slices: a[0:5, 0:5]. 
 ```
+
+Apply [attachment:trac_11576-indexed_expression.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.patch)
``````




---

archive/issue_events_091960.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-06-18T17:57:17Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91960"
}
```



---

archive/issue_comments_120768.json:
```json
{
    "body": "<a id='comment:28'></a>\nDoctest failures:\n\n```\nsage -t sage/symbolic/getitem.pyx  # 4 doctests failed\nsage -t sage/symbolic/expression.pyx  # 1 doctest failed\n```",
    "created_at": "2013-06-18T18:10:22Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120768",
    "user": "https://github.com/vbraun"
}
```

<a id='comment:28'></a>
Doctest failures:

```
sage -t sage/symbolic/getitem.pyx  # 4 doctests failed
sage -t sage/symbolic/expression.pyx  # 1 doctest failed
```



---

archive/issue_events_091961.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-06-18T18:10:22Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91961"
}
```



---

archive/issue_events_091962.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2013-06-18T18:10:22Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91962"
}
```



---

archive/issue_events_091963.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "milestone": "sage-5.11",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91963"
}
```



---

archive/issue_events_091964.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91964"
}
```



---

archive/issue_events_091965.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "milestone": "sage-6.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91965"
}
```



---

archive/issue_events_091966.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91966"
}
```



---

archive/issue_events_091967.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91967"
}
```



---

archive/issue_events_091968.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91968"
}
```



---

archive/issue_events_091969.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91969"
}
```



---

archive/issue_events_091970.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/11576#event-91970"
}
```



---

archive/issue_comments_120769.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,23 +1,26 @@\n People are *always* asking how to get sequences of variables, like `a1,a2,a3,a4` or the like.  See [this ask.sagemath.org](http://ask.sagemath.org/question/611/implicitly-defining-a-sequence-of-variables) question, for example.\n \n-Jason Grout has an interesting possible solution that should find a home somewhere in Sage. \n+Jason Grout has an interesting possible solution that should find a home somewhere in Sage\n+(see [sage-support discussion](https://groups.google.com/d/topic/sage-support/GFJdjFvKCvo/discussion)).\n \n-```\n-\n-class VariableGenerator(object): \n-     def __init__(self, prefix): \n-         self.__prefix = prefix \n-     @cached_method \n-     def __getitem__(self, key): \n-         return SR.var(\"%s%s\"%(self.__prefix,key)) \n-Now just specify a prefix, and then you can index to your heart's \n-content to generate variables. \n-a=VariableGenerator('a') # some people may like 'a_' as the prefix \n-a[0], a[1], a[2] # all variables \n-Of course, this can easily be extended to using function call syntax: \n-a(0), or to using multiple indices: a[1,3].  Indeed, you can let your \n-imagination run wild and even do things like return full symbolic \n-matrices or vectors with slices: a[0:5, 0:5]. \n-```\n+> ```\n+> class VariableGenerator(object):\n+>      def __init__(self, prefix):\n+>          self.__prefix = prefix\n+>      @cached_method\n+>      def __getitem__(self, key):\n+>          return SR.var(\"%s%s\"%(self.__prefix,key))\n+> ```\n+> Now just specify a prefix, and then you can index to your heart's \n+> content to generate variables.\n+> \n+> ```\n+> a = VariableGenerator('a') # some people may like 'a_' as the prefix\n+> a[0], a[1], a[2] # all variables\n+> ```\n+> Of course, this can easily be extended to using function call syntax:\n+> a(0), or to using multiple indices: a[1,3].  Indeed, you can let your\n+> imagination run wild and even do things like return full symbolic\n+> matrices or vectors with slices: a[0:5, 0:5].\n \n Apply [attachment:trac_11576-indexed_expression.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.patch)\n``````\n",
    "created_at": "2016-11-11T06:09:17Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120769",
    "user": "https://github.com/slel"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,23 +1,26 @@
 People are *always* asking how to get sequences of variables, like `a1,a2,a3,a4` or the like.  See [this ask.sagemath.org](http://ask.sagemath.org/question/611/implicitly-defining-a-sequence-of-variables) question, for example.
 
-Jason Grout has an interesting possible solution that should find a home somewhere in Sage. 
+Jason Grout has an interesting possible solution that should find a home somewhere in Sage
+(see [sage-support discussion](https://groups.google.com/d/topic/sage-support/GFJdjFvKCvo/discussion)).
 
-```
-
-class VariableGenerator(object): 
-     def __init__(self, prefix): 
-         self.__prefix = prefix 
-     @cached_method 
-     def __getitem__(self, key): 
-         return SR.var("%s%s"%(self.__prefix,key)) 
-Now just specify a prefix, and then you can index to your heart's 
-content to generate variables. 
-a=VariableGenerator('a') # some people may like 'a_' as the prefix 
-a[0], a[1], a[2] # all variables 
-Of course, this can easily be extended to using function call syntax: 
-a(0), or to using multiple indices: a[1,3].  Indeed, you can let your 
-imagination run wild and even do things like return full symbolic 
-matrices or vectors with slices: a[0:5, 0:5]. 
-```
+> ```
+> class VariableGenerator(object):
+>      def __init__(self, prefix):
+>          self.__prefix = prefix
+>      @cached_method
+>      def __getitem__(self, key):
+>          return SR.var("%s%s"%(self.__prefix,key))
+> ```
+> Now just specify a prefix, and then you can index to your heart's 
+> content to generate variables.
+> 
+> ```
+> a = VariableGenerator('a') # some people may like 'a_' as the prefix
+> a[0], a[1], a[2] # all variables
+> ```
+> Of course, this can easily be extended to using function call syntax:
+> a(0), or to using multiple indices: a[1,3].  Indeed, you can let your
+> imagination run wild and even do things like return full symbolic
+> matrices or vectors with slices: a[0:5, 0:5].
 
 Apply [attachment:trac_11576-indexed_expression.patch](https://github.com/sagemath/sage/files/ticket11576/trac_11576-indexed_expression.patch)
``````




---

archive/issue_comments_120770.json:
```json
{
    "body": "<a id='comment:34'></a>\nConceivably related: #22809",
    "created_at": "2017-04-14T14:36:51Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120770",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:34'></a>
Conceivably related: #22809



---

archive/issue_comments_120771.json:
```json
{
    "body": "<a id='comment:35'></a>\nplease see also the recent: #22813. the motivation is the 1st sentence of this ticket's description,\n\n> People are always asking how to get sequences of variables, like a1,a2,a3,a4 or the like.\n\nIt has been suggested to not overwrite global variables as `var('a0 a1 a2')` would normally do, but instead return the tuple `a` without injection.\n\ncertainly less comprehensive than this ticket, but related. if i can partner with any of you, i'm willing to (try to) implement the updates needed for this one / to fix doctests.",
    "created_at": "2017-04-21T11:48:50Z",
    "issue": "https://github.com/sagemath/sage/issues/11576",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/11576#issuecomment-120771",
    "user": "https://github.com/mforets"
}
```

<a id='comment:35'></a>
please see also the recent: #22813. the motivation is the 1st sentence of this ticket's description,

> People are always asking how to get sequences of variables, like a1,a2,a3,a4 or the like.

It has been suggested to not overwrite global variables as `var('a0 a1 a2')` would normally do, but instead return the tuple `a` without injection.

certainly less comprehensive than this ticket, but related. if i can partner with any of you, i'm willing to (try to) implement the updates needed for this one / to fix doctests.
