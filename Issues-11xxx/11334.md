# Issue 11334: Fix the infinity ring.

archive/issues_011334.json:
```json
{
    "body": "Assignee: @aghitza\n\nCC:  @burcin\n\nComparisons in the infinity ring are broken, mostly because it does not correctly coerce infinities from other rings into it. It also needs to be updated for the new coercion framework.\n\nAlso, `sage/rings/infinity.py` has no author or copyright notice.\n\nComparisons with SR or complex fields are still sometimes weird as \n* SR doesn't coerce to the infinity ring, since we want symbolic comparisons with infinity\n* Complex numbers have phases, but the infinity ring only supports +/- \n* CC/CDF have a weird model for their own infinity representation:\nThese shall be dealt with elsewhere as they can't be fixed on the side of the infinity ring.\n\nIssue created by migration from https://trac.sagemath.org/ticket/11506\n\n",
    "closed_at": "2014-05-25T10:09:16Z",
    "created_at": "2011-06-16T18:03:21Z",
    "labels": [
        "component: algebra",
        "blocker",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.3",
    "title": "Fix the infinity ring.",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/11334",
    "user": "https://github.com/vbraun"
}
```
Assignee: @aghitza

CC:  @burcin

Comparisons in the infinity ring are broken, mostly because it does not correctly coerce infinities from other rings into it. It also needs to be updated for the new coercion framework.

Also, `sage/rings/infinity.py` has no author or copyright notice.

Comparisons with SR or complex fields are still sometimes weird as 
* SR doesn't coerce to the infinity ring, since we want symbolic comparisons with infinity
* Complex numbers have phases, but the infinity ring only supports +/- 
* CC/CDF have a weird model for their own infinity representation:
These shall be dealt with elsewhere as they can't be fixed on the side of the infinity ring.

Issue created by migration from https://trac.sagemath.org/ticket/11506





---

archive/issue_comments_125055.json:
```json
{
    "body": "More oddities to fix:\n\n```\nsage: oo\n+Infinity\nsage: RR(oo) # Note the capitalization\n+infinity\nsage: oo * oo    \n+Infinity\nsage: RR(oo) * CC(oo)\n+infinity - NaN*I\nsage: CC(5) * CC(oo)\n+infinity - NaN*I\nsage: RR(5) * RR(oo)\n+infinity\nsage: oo * unsigned_infinity\nInfinity\nsage: RR(oo) * unsigned_infinity\nValueError: oo times number < oo not defined\n```\n\nFixing this will probably also fix #9547.",
    "created_at": "2012-05-11T13:32:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125055",
    "user": "https://github.com/tscrim"
}
```

More oddities to fix:

```
sage: oo
+Infinity
sage: RR(oo) # Note the capitalization
+infinity
sage: oo * oo    
+Infinity
sage: RR(oo) * CC(oo)
+infinity - NaN*I
sage: CC(5) * CC(oo)
+infinity - NaN*I
sage: RR(5) * RR(oo)
+infinity
sage: oo * unsigned_infinity
Infinity
sage: RR(oo) * unsigned_infinity
ValueError: oo times number < oo not defined
```

Fixing this will probably also fix #9547.



---

archive/issue_comments_125056.json:
```json
{
    "body": "This is related to #14045.",
    "created_at": "2013-02-02T15:31:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125056",
    "user": "https://github.com/tscrim"
}
```

This is related to #14045.



---

archive/issue_comments_125057.json:
```json
{
    "body": "Some progress as of `5.7.beta3`:\n\n```\nsage: InfinityRing(RR(oo))\n+Infinity\nsage: InfinityRing(CC(oo))\n+Infinity\nsage: oo == RR(oo)\nTrue\nsage: float('inf') * unsigned_infinity\nInfinity\nsage: oo == CC(oo) # This is okay because we want an unsigned infinity\nFalse\n```\n\nBut still more to go:\n\n```\nsage: CC(oo) == unsigned_infinity # This is not\nFalse\nsage: CC(oo) * CC(oo) # Worse case, I think it should be \"+infinty - 0*I\" (consistent with python), best would be \"+infinity\"\n+infinity - NaN*I\nsage: InfinityRing(SR(oo))\nTypeError: \n```\nAnd some even more fun:\n\n```\nsage: oo*i - unsigned_infinity\nInfinity\nsage: oo*i + unsigned_infinity\nInfinity\nsage: oo*i   \n(I)*Infinity\nsage: oo*i + oo\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\n<ipython-input-17-05765816106c> in <module>()\n----> 1 oo*i + oo\n...\nRuntimeError: indeterminate expression: infinity - infinity encountered.\n```\n\nSee also #14088.",
    "created_at": "2013-02-09T21:13:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125057",
    "user": "https://github.com/tscrim"
}
```

Some progress as of `5.7.beta3`:

```
sage: InfinityRing(RR(oo))
+Infinity
sage: InfinityRing(CC(oo))
+Infinity
sage: oo == RR(oo)
True
sage: float('inf') * unsigned_infinity
Infinity
sage: oo == CC(oo) # This is okay because we want an unsigned infinity
False
```

But still more to go:

```
sage: CC(oo) == unsigned_infinity # This is not
False
sage: CC(oo) * CC(oo) # Worse case, I think it should be "+infinty - 0*I" (consistent with python), best would be "+infinity"
+infinity - NaN*I
sage: InfinityRing(SR(oo))
TypeError: 
```
And some even more fun:

```
sage: oo*i - unsigned_infinity
Infinity
sage: oo*i + unsigned_infinity
Infinity
sage: oo*i   
(I)*Infinity
sage: oo*i + oo
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
<ipython-input-17-05765816106c> in <module>()
----> 1 oo*i + oo
...
RuntimeError: indeterminate expression: infinity - infinity encountered.
```

See also #14088.



---

archive/issue_events_029993.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11334#event-29993"
}
```



---

archive/issue_comments_125058.json:
```json
{
    "body": "See also #14857.\n\nAs well, things like this:\n\n```\nsage: bool(SR(oo) > 5)\nFalse\n```",
    "created_at": "2013-08-16T23:17:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125058",
    "user": "https://github.com/eviatarbach"
}
```

See also #14857.

As well, things like this:

```
sage: bool(SR(oo) > 5)
False
```



---

archive/issue_comments_125059.json:
```json
{
    "body": "see also my comment about `limit` in #14857: shouldn't `limit` return an element of InfinityRing for `Infinity, +Infinity, -Infinity`?\n\nPaul",
    "created_at": "2013-08-25T13:58:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125059",
    "user": "https://github.com/zimmermann6"
}
```

see also my comment about `limit` in #14857: shouldn't `limit` return an element of InfinityRing for `Infinity, +Infinity, -Infinity`?

Paul



---

archive/issue_comments_125060.json:
```json
{
    "body": "Changing priority from major to critical.",
    "created_at": "2013-10-03T20:16:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125060",
    "user": "https://github.com/pjbruin"
}
```

Changing priority from major to critical.



---

archive/issue_comments_125061.json:
```json
{
    "body": "The following is an extremely serious error:\n\n```\nsage: Infinity in RR\nTrue\n```\nThis is mathematical nonsense.\n\nLess polemically phrased, it has the potential to be dangerously confusing.  It reflects the *implementation choice* that multiprecision reals are also able to represent infinity.\n\nBesides, it contradicts the documentation of the infinity \"ring\", the parent of `Infinity`, which states that the infinity \"ring\" does not have a coercion map to any actual rings.\n\n`Infinity in CC` does correctly return `False`.\n\nSee also https://groups.google.com/forum/#!topic/sage-devel/sHyLWNcItl4 .",
    "created_at": "2013-10-03T20:16:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125061",
    "user": "https://github.com/pjbruin"
}
```

The following is an extremely serious error:

```
sage: Infinity in RR
True
```
This is mathematical nonsense.

Less polemically phrased, it has the potential to be dangerously confusing.  It reflects the *implementation choice* that multiprecision reals are also able to represent infinity.

Besides, it contradicts the documentation of the infinity "ring", the parent of `Infinity`, which states that the infinity "ring" does not have a coercion map to any actual rings.

`Infinity in CC` does correctly return `False`.

See also https://groups.google.com/forum/#!topic/sage-devel/sHyLWNcItl4 .



---

archive/issue_comments_125062.json:
```json
{
    "body": "> Besides, it contradicts the documentation of the infinity \"ring\", the parent of Infinity, which states that the infinity \"ring\" does not have a coercion map to any actual rings.\n\n\nLet me argue for the same thing as you, but more precisely and technically based on the internal design decisions in Sage.\n\nFirst note that there is no implicit coercion map from `InfinityRing` to RR, where coercion is as defined http://www.sagemath.org/doc/tutorial/tour_coercion.html. \n\n```\nsage: RR.has_coerce_map_from(InfinityRing)\nFalse\nsage: InfinityRing.has_coerce_map_from(RR)\nTrue\n```\n\nHowever, there is a *conversion* map:\n\n```\nsage: f = RR.convert_map_from(InfinityRing); f\nConversion map:\n  From: The Infinity Ring\n  To:   Real Field with 53 bits of precision\nsage: f(oo)\n+infinity\nsage: oo.parent()\nThe Infinity Ring\n```\n\nConversion (not coercion) paired with equality testing (see below) is what is used for \"in\" testing systematically throughout Sage.  For example, the following uses conversion:\n\n```\nsage: 2/1 in ZZ\nTrue\n```\nThe above would be false if it used only automatic coercion, since there is no automatic coercion from the rationals (parent of 2/1) to ZZ.    \"In\" works by applying the conversion map, then testing *equality* between the original object and the converted object, e.g., :\n\n```\nsage: ZZ(2/1) == 2/1\nTrue\n```\nHowever, this equality test does use implicit coercion. \n\n\nIn the case of \"+infinity\":\n\n```\nsage: RR(oo)     # fine\n+infinity\nsage: RR(oo) == oo  # that this is true is what is really wrong....\nTrue\n```\n\nThat `RR(oo) == oo` evaluates to True is the real bug, since == is supposed to mean *equal* under an implicit coercion map, e.g.:\n\n```\nsage: 2/1 == 2       # coerce both to QQ\nTrue\nsage: 2 == Mod(2,7)  # coerce both to Z/7Z\nTrue\nsage: 2/1 == Mod(2,7)      # FALSE!  As it should be -- no *implicit* coercion to a common parent, so they can't be equal\nFalse\n```\n\nWith CC things work right:  `CC(oo) != oo`:\n\n```\nsage: CC(oo)\n+infinity\nsage: f = CC.convert_map_from(InfinityRing); f\nConversion map:\n  From: The Infinity Ring\n  To:   Complex Field with 53 bits of precision\nsage: f(oo)\n+infinity\nsage: f(oo) == oo\nFalse\nsage: CC(oo) == oo  # good\nFalse\n```\n\n\n> This is mathematical nonsense.\n\n\nFor the record, I'm a little uncomfortable with this way of arguing, since we're talking about numerical analysis and numerical computation here, in actual software, which is something that numerical analysts, IEEE committees, etc., have thought about these issues for a while.  They have very good reasons to represent various infinities as special cases, and have well defined rules about their behavior. \n\nNonetheless, I have to agree with your conclusion.  I think the fix is to make it so `RR(oo) == oo` returns False.  When that is sorted out, then `oo in RR` should return False as well, as explained above.  One can *explicitly* construct `a = RR(oo)` if needed, and for this infinity, `a in RR` will be true.",
    "created_at": "2013-10-05T00:08:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125062",
    "user": "https://github.com/williamstein"
}
```

> Besides, it contradicts the documentation of the infinity "ring", the parent of Infinity, which states that the infinity "ring" does not have a coercion map to any actual rings.


Let me argue for the same thing as you, but more precisely and technically based on the internal design decisions in Sage.

First note that there is no implicit coercion map from `InfinityRing` to RR, where coercion is as defined http://www.sagemath.org/doc/tutorial/tour_coercion.html. 

```
sage: RR.has_coerce_map_from(InfinityRing)
False
sage: InfinityRing.has_coerce_map_from(RR)
True
```

However, there is a *conversion* map:

```
sage: f = RR.convert_map_from(InfinityRing); f
Conversion map:
  From: The Infinity Ring
  To:   Real Field with 53 bits of precision
sage: f(oo)
+infinity
sage: oo.parent()
The Infinity Ring
```

Conversion (not coercion) paired with equality testing (see below) is what is used for "in" testing systematically throughout Sage.  For example, the following uses conversion:

```
sage: 2/1 in ZZ
True
```
The above would be false if it used only automatic coercion, since there is no automatic coercion from the rationals (parent of 2/1) to ZZ.    "In" works by applying the conversion map, then testing *equality* between the original object and the converted object, e.g., :

```
sage: ZZ(2/1) == 2/1
True
```
However, this equality test does use implicit coercion. 


In the case of "+infinity":

```
sage: RR(oo)     # fine
+infinity
sage: RR(oo) == oo  # that this is true is what is really wrong....
True
```

That `RR(oo) == oo` evaluates to True is the real bug, since == is supposed to mean *equal* under an implicit coercion map, e.g.:

```
sage: 2/1 == 2       # coerce both to QQ
True
sage: 2 == Mod(2,7)  # coerce both to Z/7Z
True
sage: 2/1 == Mod(2,7)      # FALSE!  As it should be -- no *implicit* coercion to a common parent, so they can't be equal
False
```

With CC things work right:  `CC(oo) != oo`:

```
sage: CC(oo)
+infinity
sage: f = CC.convert_map_from(InfinityRing); f
Conversion map:
  From: The Infinity Ring
  To:   Complex Field with 53 bits of precision
sage: f(oo)
+infinity
sage: f(oo) == oo
False
sage: CC(oo) == oo  # good
False
```


> This is mathematical nonsense.


For the record, I'm a little uncomfortable with this way of arguing, since we're talking about numerical analysis and numerical computation here, in actual software, which is something that numerical analysts, IEEE committees, etc., have thought about these issues for a while.  They have very good reasons to represent various infinities as special cases, and have well defined rules about their behavior. 

Nonetheless, I have to agree with your conclusion.  I think the fix is to make it so `RR(oo) == oo` returns False.  When that is sorted out, then `oo in RR` should return False as well, as explained above.  One can *explicitly* construct `a = RR(oo)` if needed, and for this infinity, `a in RR` will be true.



---

archive/issue_comments_125063.json:
```json
{
    "body": "Here is a more systematic list with things that work correctly and things that don't (compiled from earlier comments, with various additions).  We should probably have several tickets instead of trying to solve all problems at once.\n\nMost basic operations in the signed and unsigned infinity rings work as expected:\n\n```\nsage: infinity.parent()\nThe Infinity Ring\nsage: unsigned_infinity.parent()\nThe Unsigned Infinity Ring\nsage: oo is infinity\nTrue\nsage: oo is Infinity\nTrue\nsage: infinity == unsigned_infinity\nTrue\nsage: -infinity == unsigned infinity\nTrue\nsage: infinity == -infinity\nFalse\nsage: oo * oo    \n+Infinity\nsage: oo * unsigned_infinity\nInfinity\n```\nThe coercion maps also work as expected:\n\n```\nsage: UnsignedInfinityRing.has_coerce_map_from(InfinityRing)\nTrue\nsage: InfinityRing.has_coerce_map_from(UnsignedInfinityRing)\nFalse\nsage: UnsignedInfinityRing.has_coerce_map_from(RR)\nTrue\nsage: UnsignedInfinityRing.has_coerce_map_from(CC)\nTrue\nsage: InfinityRing.has_coerce_map_from(RR)\nTrue\nsage: InfinityRing.has_coerce_map_from(CC)\nFalse\nsage: RR.has_coerce_map_from(UnsignedInfinityRing)\nFalse\nsage: CC.has_coerce_map_from(UnsignedInfinityRing)\nFalse\nsage: RR.has_coerce_map_from(InfinityRing)\nFalse\nsage: CC.has_coerce_map_from(InfinityRing)\nFalse\n```\nThe following is debatable, since it makes the arbitrary choice that unsigned infinity is \"more positive than negative\":\n\n```\nsage: InfinityRing(unsigned_infinity)\n+Infinity  # this should probably raise an error\n```\nThe following wrongly suggests that `UnsignedInfinityRing` is ordered:\n\n```\nsage: UnsignedInfinityRing(0)\nA number less than infinity  # should be \"A finite number\"\n```\nA seemingly arbitrary typographical inconsistency (upper-case I vs. lower-case i):\n\n```\nsage: oo\n+Infinity\nsage: RR(oo)\n+infinity\n```\nConversion to `InfinityRing` and `UnsignedInfinityRing`:\n\n```\nsage: InfinityRing(RR(oo))\n+Infinity  # OK\nsage: InfinityRing(CC(oo))\n+Infinity  # should raise an error (complex infinity is unsigned)\nUnsignedInfinityRing(CC(oo))\nA number less than infinity  # should be Infinity\nUnsignedInfinityRing(CC(oo))\nA number less than infinity  # should be Infinity\n```\nArithmetic in `RR`:\n\n```\nsage: RR(5) * RR(oo)\n+infinity  # OK\nsage: RR(oo) * unsigned_infinity\n...\nValueError: oo times number < oo not defined  # should be Infinity\n```\n`CC` currently contains many infinity elements, whereas it should contain at most one (the point at infinity in the Riemann sphere):\n\n```\nsage: RR(oo) * CC(oo)\n+infinity - NaN*I  # should be \"complex infinity\"\nsage: CC(5) * CC(oo)\n+infinity - NaN*I  # should be \"complex infinity\"\n```\nConversion from `InfinityRing` and `UnsignedInfinityRing`:\n\n```\nsage: RR(oo)\n+infinity  # OK\nsage: RR(unsigned_infinity)\n+infinity  # should raise an error\nsage: CC(oo)\n+infinity  # should be \"complex infinity\"\nsage: CC(unsigned_infinity)\n+infinity  # should be \"complex infinity\n\nsage: f = RR.convert_map_from(InfinityRing); f\nConversion map:\n  From: The Infinity Ring\n  To:   Real Field with 53 bits of precision\nsage: f(oo)\n+infinity  # OK\nsage: f(InfinityRing(0))\n...\nTypeError: Unable to convert x (='Zero') to real number.  # should be 0.000000000000000\nsage: f(InfinityRing(1))\nTypeError: Unable to convert x (='Apositivefinitenumber') to real number.  # OK\nsage: f(InfinityRing(-1))\nTypeError: Unable to convert x (='Anegativefinitenumber') to real number.  # OK\n\nsage: f = CC.convert_map_from(InfinityRing); f\nConversion map:\n  From: The Infinity Ring\n  To:   Complex Field with 53 bits of precision\nsage: f(oo)\n+infinity  # should be \"complex infinity\"\nsage: f(InfinityRing(0))\nTypeError: unable to coerce to a ComplexNumber: <class 'sage.rings.infinity.FiniteNumber'>  # should be 0.000000000000000\nsage: f(InfinityRing(1))\nTypeError: unable to coerce to a ComplexNumber: <class 'sage.rings.infinity.FiniteNumber'>  # OK\nsage: f(InfinityRing(-1))\nTypeError: unable to coerce to a ComplexNumber: <class 'sage.rings.infinity.FiniteNumber'>  # OK\n```\nComparison:\n\n```\nsage: RR(oo) == oo\nTrue   # might be OK; William Stein (comment:8) disagrees\nsage: RR(oo) == unsigned_infinity\nFalse  # True might be acceptable\nsage: CC(oo) == oo\nFalse  # OK\nsage: CC(oo) == unsigned_infinity\nFalse  # True might be acceptable\nsage: CC(oo) == RR(oo)\nTrue   # OK\n```\nMembership testing:\n\n```\nsage: Infinity in RR\nTrue  # should be False\nsage: Infinity in CC\nFalse  # OK\nsage: unsigned_infinity in RR\nFalse  # OK\nsage: unsigned_infinity in CC\nFalse  # OK\n```\nProblems with the symbolic ring:\n\n```\nsage: InfinityRing(SR(oo))\n...\nTypeError:  # should be +Infinity\nsage: oo*i   \n(I)*Infinity  # should probably be Infinity\nsage: oo*i + oo\n...\nRuntimeError: indeterminate expression: infinity - infinity encountered.  # OK\nsage: bool(SR(oo) > 5)\nFalse  # should be True\nsage: oo*i - unsigned_infinity\nInfinity  # OK\nsage: oo*i + unsigned_infinity\nInfinity  # OK\n```",
    "created_at": "2013-11-24T16:05:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125063",
    "user": "https://github.com/pjbruin"
}
```

Here is a more systematic list with things that work correctly and things that don't (compiled from earlier comments, with various additions).  We should probably have several tickets instead of trying to solve all problems at once.

Most basic operations in the signed and unsigned infinity rings work as expected:

```
sage: infinity.parent()
The Infinity Ring
sage: unsigned_infinity.parent()
The Unsigned Infinity Ring
sage: oo is infinity
True
sage: oo is Infinity
True
sage: infinity == unsigned_infinity
True
sage: -infinity == unsigned infinity
True
sage: infinity == -infinity
False
sage: oo * oo    
+Infinity
sage: oo * unsigned_infinity
Infinity
```
The coercion maps also work as expected:

```
sage: UnsignedInfinityRing.has_coerce_map_from(InfinityRing)
True
sage: InfinityRing.has_coerce_map_from(UnsignedInfinityRing)
False
sage: UnsignedInfinityRing.has_coerce_map_from(RR)
True
sage: UnsignedInfinityRing.has_coerce_map_from(CC)
True
sage: InfinityRing.has_coerce_map_from(RR)
True
sage: InfinityRing.has_coerce_map_from(CC)
False
sage: RR.has_coerce_map_from(UnsignedInfinityRing)
False
sage: CC.has_coerce_map_from(UnsignedInfinityRing)
False
sage: RR.has_coerce_map_from(InfinityRing)
False
sage: CC.has_coerce_map_from(InfinityRing)
False
```
The following is debatable, since it makes the arbitrary choice that unsigned infinity is "more positive than negative":

```
sage: InfinityRing(unsigned_infinity)
+Infinity  # this should probably raise an error
```
The following wrongly suggests that `UnsignedInfinityRing` is ordered:

```
sage: UnsignedInfinityRing(0)
A number less than infinity  # should be "A finite number"
```
A seemingly arbitrary typographical inconsistency (upper-case I vs. lower-case i):

```
sage: oo
+Infinity
sage: RR(oo)
+infinity
```
Conversion to `InfinityRing` and `UnsignedInfinityRing`:

```
sage: InfinityRing(RR(oo))
+Infinity  # OK
sage: InfinityRing(CC(oo))
+Infinity  # should raise an error (complex infinity is unsigned)
UnsignedInfinityRing(CC(oo))
A number less than infinity  # should be Infinity
UnsignedInfinityRing(CC(oo))
A number less than infinity  # should be Infinity
```
Arithmetic in `RR`:

```
sage: RR(5) * RR(oo)
+infinity  # OK
sage: RR(oo) * unsigned_infinity
...
ValueError: oo times number < oo not defined  # should be Infinity
```
`CC` currently contains many infinity elements, whereas it should contain at most one (the point at infinity in the Riemann sphere):

```
sage: RR(oo) * CC(oo)
+infinity - NaN*I  # should be "complex infinity"
sage: CC(5) * CC(oo)
+infinity - NaN*I  # should be "complex infinity"
```
Conversion from `InfinityRing` and `UnsignedInfinityRing`:

```
sage: RR(oo)
+infinity  # OK
sage: RR(unsigned_infinity)
+infinity  # should raise an error
sage: CC(oo)
+infinity  # should be "complex infinity"
sage: CC(unsigned_infinity)
+infinity  # should be "complex infinity

sage: f = RR.convert_map_from(InfinityRing); f
Conversion map:
  From: The Infinity Ring
  To:   Real Field with 53 bits of precision
sage: f(oo)
+infinity  # OK
sage: f(InfinityRing(0))
...
TypeError: Unable to convert x (='Zero') to real number.  # should be 0.000000000000000
sage: f(InfinityRing(1))
TypeError: Unable to convert x (='Apositivefinitenumber') to real number.  # OK
sage: f(InfinityRing(-1))
TypeError: Unable to convert x (='Anegativefinitenumber') to real number.  # OK

sage: f = CC.convert_map_from(InfinityRing); f
Conversion map:
  From: The Infinity Ring
  To:   Complex Field with 53 bits of precision
sage: f(oo)
+infinity  # should be "complex infinity"
sage: f(InfinityRing(0))
TypeError: unable to coerce to a ComplexNumber: <class 'sage.rings.infinity.FiniteNumber'>  # should be 0.000000000000000
sage: f(InfinityRing(1))
TypeError: unable to coerce to a ComplexNumber: <class 'sage.rings.infinity.FiniteNumber'>  # OK
sage: f(InfinityRing(-1))
TypeError: unable to coerce to a ComplexNumber: <class 'sage.rings.infinity.FiniteNumber'>  # OK
```
Comparison:

```
sage: RR(oo) == oo
True   # might be OK; William Stein (comment:8) disagrees
sage: RR(oo) == unsigned_infinity
False  # True might be acceptable
sage: CC(oo) == oo
False  # OK
sage: CC(oo) == unsigned_infinity
False  # True might be acceptable
sage: CC(oo) == RR(oo)
True   # OK
```
Membership testing:

```
sage: Infinity in RR
True  # should be False
sage: Infinity in CC
False  # OK
sage: unsigned_infinity in RR
False  # OK
sage: unsigned_infinity in CC
False  # OK
```
Problems with the symbolic ring:

```
sage: InfinityRing(SR(oo))
...
TypeError:  # should be +Infinity
sage: oo*i   
(I)*Infinity  # should probably be Infinity
sage: oo*i + oo
...
RuntimeError: indeterminate expression: infinity - infinity encountered.  # OK
sage: bool(SR(oo) > 5)
False  # should be True
sage: oo*i - unsigned_infinity
Infinity  # OK
sage: oo*i + unsigned_infinity
Infinity  # OK
```



---

archive/issue_events_029994.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11334#event-29994"
}
```



---

archive/issue_events_029995.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11334#event-29995"
}
```



---

archive/issue_events_029996.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:19:32Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11334#event-29996"
}
```



---

archive/issue_events_029997.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:19:32Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11334#event-29997"
}
```



---

archive/issue_comments_125064.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-05-20T15:56:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125064",
    "user": "https://github.com/vbraun"
}
```

New commits:



---

archive/issue_comments_125065.json:
```json
{
    "body": "IMHO things like `i*oo` make sense, we should just support arbitrary phases instead of only `+/-`. I did implement that in pynac so it works in the symbolic ring. But extending the infinity ring is a different ticket. In the absence of an infinity ring with phases, comparisons with complex numbers will always be somewhat wonky. But then that is not __too__ bad since they can't really be compared.\n\nI disagree with the \"`Infinity in RR` should be false\" discussion above. In Sage, `RR` can represent plus/minus infinity because `RDF` can represent infinity by IEEE. The fact that `RR(oo) == oo` is the whole point of the infinity ring, namely to have consistent comparisons across various rings that can represent infinity.",
    "created_at": "2014-05-20T17:51:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125065",
    "user": "https://github.com/vbraun"
}
```

IMHO things like `i*oo` make sense, we should just support arbitrary phases instead of only `+/-`. I did implement that in pynac so it works in the symbolic ring. But extending the infinity ring is a different ticket. In the absence of an infinity ring with phases, comparisons with complex numbers will always be somewhat wonky. But then that is not __too__ bad since they can't really be compared.

I disagree with the "`Infinity in RR` should be false" discussion above. In Sage, `RR` can represent plus/minus infinity because `RDF` can represent infinity by IEEE. The fact that `RR(oo) == oo` is the whole point of the infinity ring, namely to have consistent comparisons across various rings that can represent infinity.



---

archive/issue_comments_125066.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-20T17:53:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125066",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_125067.json:
```json
{
    "body": "Also, the following two are equally incorrect:\n\n```\nsage: infinity == unsigned_infinity\nTrue\nsage: 2+7 == Mod(2,7)\nTrue\n```\nBoth violate Python rules for equality and hashes. But as long as we want the latter we also have to accept the former.",
    "created_at": "2014-05-20T18:07:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125067",
    "user": "https://github.com/vbraun"
}
```

Also, the following two are equally incorrect:

```
sage: infinity == unsigned_infinity
True
sage: 2+7 == Mod(2,7)
True
```
Both violate Python rules for equality and hashes. But as long as we want the latter we also have to accept the former.



---

archive/issue_comments_125068.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-05-20T18:10:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125068",
    "user": "https://github.com/vbraun"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_125069.json:
```json
{
    "body": "Changing priority from critical to blocker.",
    "created_at": "2014-05-20T18:15:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125069",
    "user": "https://github.com/vbraun"
}
```

Changing priority from critical to blocker.



---

archive/issue_comments_125070.json:
```json
{
    "body": "I mostly agree with the changes made; they fix some bugs and don't seem to introduce new weirdness.\n\nI still don't believe that `Infinity in RR` is a good thing; I don't think the arguments for it are strong enough to justify what to me feels like a huge pain in the eye.  But it's not too directly related to the other points addressed in this ticket, so let's leave it at that for now.\n\nAlso, in my opinion, having one complex infinity for each argument is really just as arbitrary as the current situation of having complex infinities where the real and imaginary parts can each be a real number, or positive or negative infinity.  But this too is something for another time.\n\nNow here is something that to me looks like a bug even if you believe that `RR` should contain `+Infinity` and `-Infinity`:\n\n```\nsage: unsigned_infinity in RR\nTrue\n```\nThis is because of the following two circumstances: `RR(unsigned_infinity)` is defined (as `RR(infinity)`, to be precise), and `RR(infinity) == unsigned_infinity` returns True.  I would prefer making `RR(unsigned_infinity)` raise an error, if this can be done without breaking too much.\n\nAnd here is a strange inconsistency:\n\n```\nsage: unsigned_infinity - oo*i\n...\nValueError: oo - oo not defined\nsage: unsigned_infinity + oo*i\nInfinity\n```\nI think this is best resolved by making the second example raise a `ValueError` like the first one; it seems to me that neither addition nor subtraction makes sense in the unsigned infinity \"ring\".",
    "created_at": "2014-05-20T18:56:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125070",
    "user": "https://github.com/pjbruin"
}
```

I mostly agree with the changes made; they fix some bugs and don't seem to introduce new weirdness.

I still don't believe that `Infinity in RR` is a good thing; I don't think the arguments for it are strong enough to justify what to me feels like a huge pain in the eye.  But it's not too directly related to the other points addressed in this ticket, so let's leave it at that for now.

Also, in my opinion, having one complex infinity for each argument is really just as arbitrary as the current situation of having complex infinities where the real and imaginary parts can each be a real number, or positive or negative infinity.  But this too is something for another time.

Now here is something that to me looks like a bug even if you believe that `RR` should contain `+Infinity` and `-Infinity`:

```
sage: unsigned_infinity in RR
True
```
This is because of the following two circumstances: `RR(unsigned_infinity)` is defined (as `RR(infinity)`, to be precise), and `RR(infinity) == unsigned_infinity` returns True.  I would prefer making `RR(unsigned_infinity)` raise an error, if this can be done without breaking too much.

And here is a strange inconsistency:

```
sage: unsigned_infinity - oo*i
...
ValueError: oo - oo not defined
sage: unsigned_infinity + oo*i
Infinity
```
I think this is best resolved by making the second example raise a `ValueError` like the first one; it seems to me that neither addition nor subtraction makes sense in the unsigned infinity "ring".



---

archive/issue_comments_125071.json:
```json
{
    "body": "`unsigned_infinity in RR` returns true because there are coercions RR -> signed infinity ring -> unsigned infinity ring:\n\n```\nsage: get_coercion_model().explain(unsigned_infinity, RR(oo), operator.eq)\nCoercion on right operand via\n    Conversion map:\n      From: Real Field with 53 bits of precision\n      To:   The Unsigned Infinity Ring\nArithmetic performed after coercions.\nResult lives in The Unsigned Infinity Ring\nThe Unsigned Infinity Ring\n```\nWe could disallow the conversion RR(unsigned_infinity) but it would not change anything.\n\nI agree with you that the infinity representation in CDF and CC sucks, but thats another ticket...",
    "created_at": "2014-05-20T19:06:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125071",
    "user": "https://github.com/vbraun"
}
```

`unsigned_infinity in RR` returns true because there are coercions RR -> signed infinity ring -> unsigned infinity ring:

```
sage: get_coercion_model().explain(unsigned_infinity, RR(oo), operator.eq)
Coercion on right operand via
    Conversion map:
      From: Real Field with 53 bits of precision
      To:   The Unsigned Infinity Ring
Arithmetic performed after coercions.
Result lives in The Unsigned Infinity Ring
The Unsigned Infinity Ring
```
We could disallow the conversion RR(unsigned_infinity) but it would not change anything.

I agree with you that the infinity representation in CDF and CC sucks, but thats another ticket...



---

archive/issue_comments_125072.json:
```json
{
    "body": "Replying to [comment:20 vbraun]:\n> `unsigned_infinity in RR` returns true because there are coercions RR -> signed infinity ring -> unsigned infinity ring:\n\nYes, and I think that isn't a problem.\n> We could disallow the conversion RR(unsigned_infinity) but it would not change anything.\n\nWell, if I'm not mistaken, at least it would make `unsigned_infinity in RR` return False (because the conversion needs to succeed for this to return True), which was my point.\n\nIt seems my last point wasn't very clear, so here an equivalent example without complex infinities:\n\n```\nsage: unsigned_infinity + unsigned_infinity\nInfinity\nsage: unsigned_infinity - unsigned_infinity\n...\nValueError: oo - oo not defined\n```\nI think we should raise an error for addition, i.e. make the code of `_add_()` work in an analogous way to that of `_sub_()`.  (Not that this was caused by your patch; the thing with the `+i` and `-i` just led me to this inconsistency.)",
    "created_at": "2014-05-20T19:29:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125072",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:20 vbraun]:
> `unsigned_infinity in RR` returns true because there are coercions RR -> signed infinity ring -> unsigned infinity ring:

Yes, and I think that isn't a problem.
> We could disallow the conversion RR(unsigned_infinity) but it would not change anything.

Well, if I'm not mistaken, at least it would make `unsigned_infinity in RR` return False (because the conversion needs to succeed for this to return True), which was my point.

It seems my last point wasn't very clear, so here an equivalent example without complex infinities:

```
sage: unsigned_infinity + unsigned_infinity
Infinity
sage: unsigned_infinity - unsigned_infinity
...
ValueError: oo - oo not defined
```
I think we should raise an error for addition, i.e. make the code of `_add_()` work in an analogous way to that of `_sub_()`.  (Not that this was caused by your patch; the thing with the `+i` and `-i` just led me to this inconsistency.)



---

archive/issue_comments_125073.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-20T19:47:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125073",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_125074.json:
```json
{
    "body": "OK, I think this is enough improvement for now.",
    "created_at": "2014-05-20T20:23:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125074",
    "user": "https://github.com/pjbruin"
}
```

OK, I think this is enough improvement for now.



---

archive/issue_comments_125075.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-05-20T20:23:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125075",
    "user": "https://github.com/pjbruin"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_125076.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2014-05-20T22:20:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125076",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_125077.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:",
    "created_at": "2014-05-20T22:20:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125077",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:



---

archive/issue_comments_125078.json:
```json
{
    "body": "Not so fast, I was implementing your suggestion ;-)",
    "created_at": "2014-05-20T22:20:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125078",
    "user": "https://github.com/vbraun"
}
```

Not so fast, I was implementing your suggestion ;-)



---

archive/issue_comments_125079.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-05-20T22:57:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125079",
    "user": "https://github.com/pjbruin"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_125080.json:
```json
{
    "body": "Even better!",
    "created_at": "2014-05-20T22:57:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125080",
    "user": "https://github.com/pjbruin"
}
```

Even better!



---

archive/issue_comments_125081.json:
```json
{
    "body": "As per #13125, I still disagree this:\n\n```\nsage: RIF(0, oo)\n[0.00000000000000000 .. +infinity]\nsage: RIF(0, oo) == oo\nTrue\n```\nIf a discussion on sage-devel thinks this okay, then this can be merged, but I think this could very easily lead to wrong results.",
    "created_at": "2014-05-21T04:51:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125081",
    "user": "https://github.com/tscrim"
}
```

As per #13125, I still disagree this:

```
sage: RIF(0, oo)
[0.00000000000000000 .. +infinity]
sage: RIF(0, oo) == oo
True
```
If a discussion on sage-devel thinks this okay, then this can be merged, but I think this could very easily lead to wrong results.



---

archive/issue_comments_125082.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2014-05-21T04:51:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125082",
    "user": "https://github.com/tscrim"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_125083.json:
```json
{
    "body": "I forgot about the discussion about this on #13125.  I think that `RIF` shouldn't coerce into the infinity ring, and that conversion should succeed if and only if the interval is finite or equal to either `[-infinity .. -infinity]` or `[+infinity .. +infinity]`.  To motivate why there shouldn't be a coercion, I would say that `RIF` and `InfinityRing` are two models for underdetermined (and possibly infinite) real numbers, but that they happen to be incompatible models with regard to the data they record.  In other words, neither of them is a \"finer\" approximation of the extended real numbers than the other.",
    "created_at": "2014-05-21T09:39:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125083",
    "user": "https://github.com/pjbruin"
}
```

I forgot about the discussion about this on #13125.  I think that `RIF` shouldn't coerce into the infinity ring, and that conversion should succeed if and only if the interval is finite or equal to either `[-infinity .. -infinity]` or `[+infinity .. +infinity]`.  To motivate why there shouldn't be a coercion, I would say that `RIF` and `InfinityRing` are two models for underdetermined (and possibly infinite) real numbers, but that they happen to be incompatible models with regard to the data they record.  In other words, neither of them is a "finer" approximation of the extended real numbers than the other.



---

archive/issue_comments_125084.json:
```json
{
    "body": "If anything it is about more coarse approximation, this is why there is a coercion RR -> signed infinity -> unsigned infinity.\n\nThere is also a coercion RR -> RIF. IMHO there ought to be a pushout, and right now its the infinity ring. Arguably it should be a better structure that also knows about semi-infinite intervals. But until you write one we only have the infinity ring.\n\nReally, the only question right now is whether unbounded intervals ought to coerce into a finite number or infinity. The convention that I chose is where\n\n```\nsage: RIF(0,oo) == oo == RIF(0,oo).center()\nTrue\n```\nDo you really want `RIF(0,oo) < oo == RIF(0,oo).center()`? Because that is the only alternative.",
    "created_at": "2014-05-21T10:32:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125084",
    "user": "https://github.com/vbraun"
}
```

If anything it is about more coarse approximation, this is why there is a coercion RR -> signed infinity -> unsigned infinity.

There is also a coercion RR -> RIF. IMHO there ought to be a pushout, and right now its the infinity ring. Arguably it should be a better structure that also knows about semi-infinite intervals. But until you write one we only have the infinity ring.

Really, the only question right now is whether unbounded intervals ought to coerce into a finite number or infinity. The convention that I chose is where

```
sage: RIF(0,oo) == oo == RIF(0,oo).center()
True
```
Do you really want `RIF(0,oo) < oo == RIF(0,oo).center()`? Because that is the only alternative.



---

archive/issue_comments_125085.json:
```json
{
    "body": "Replying to [comment:29 vbraun]:\n> If anything it is about more coarse approximation, this is why there is a coercion RR -> signed infinity -> unsigned infinity.\n\n\nIt is more coarse to certain extent; on the other hand `RIF` does not in general specify whether an element is positive, negative, zero, plus or minus infinity.\n\n> There is also a coercion RR -> RIF. IMHO there ought to be a pushout, and right now its the infinity ring. Arguably it should be a better structure that also knows about semi-infinite intervals.\n\n\nIndeed, something like a `InfinityIntervalRing` (although we may want a less silly name); its elements should be intervals in the ordered set\n\n```\n-infinity < -finite < 0 < +finite < +infinity\n```\n[Edit: we don't necessarily have to create a new structure, maybe we can just let the existing infinity ring have such intervals as elements and regard the existing elements as one-element intervals.]\n\n> Really, the only question right now is whether unbounded intervals ought to coerce into a finite number or infinity. The convention that I chose is where\n> \n> ```\n> sage: RIF(0,oo) == oo == RIF(0,oo).center()\n> True\n> ```\n> Do you really want `RIF(0,oo) < oo == RIF(0,oo).center()`? Because that is the only alternative.\n\nWould there be anything against not trying to implement conversion `RIF` -> `InfinityRing` in this ticket at all (i.e. letting it raise an error like it does now), and fix comparison in a better way (and on a different ticket) by implementing this \"infinity interval ring\"?\n\nConversion from `RIF` to the current `InfinityRing` is already broken anyway, even when there are no infinities involved; do you convert the interval [-1, 1] into \"a negative finite number\", \"zero\", or \"a positive finite number\"?",
    "created_at": "2014-05-21T10:46:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125085",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:29 vbraun]:
> If anything it is about more coarse approximation, this is why there is a coercion RR -> signed infinity -> unsigned infinity.


It is more coarse to certain extent; on the other hand `RIF` does not in general specify whether an element is positive, negative, zero, plus or minus infinity.

> There is also a coercion RR -> RIF. IMHO there ought to be a pushout, and right now its the infinity ring. Arguably it should be a better structure that also knows about semi-infinite intervals.


Indeed, something like a `InfinityIntervalRing` (although we may want a less silly name); its elements should be intervals in the ordered set

```
-infinity < -finite < 0 < +finite < +infinity
```
[Edit: we don't necessarily have to create a new structure, maybe we can just let the existing infinity ring have such intervals as elements and regard the existing elements as one-element intervals.]

> Really, the only question right now is whether unbounded intervals ought to coerce into a finite number or infinity. The convention that I chose is where
> 
> ```
> sage: RIF(0,oo) == oo == RIF(0,oo).center()
> True
> ```
> Do you really want `RIF(0,oo) < oo == RIF(0,oo).center()`? Because that is the only alternative.

Would there be anything against not trying to implement conversion `RIF` -> `InfinityRing` in this ticket at all (i.e. letting it raise an error like it does now), and fix comparison in a better way (and on a different ticket) by implementing this "infinity interval ring"?

Conversion from `RIF` to the current `InfinityRing` is already broken anyway, even when there are no infinities involved; do you convert the interval [-1, 1] into "a negative finite number", "zero", or "a positive finite number"?



---

archive/issue_comments_125086.json:
```json
{
    "body": "Again, no coercion to the infinity ring means: comparison by memory address. Which will a) not be the one you like and b) inconsistent across different runs / platforms. Maybe we can't fix a) right away, but we must fix b).",
    "created_at": "2014-05-21T12:01:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125086",
    "user": "https://github.com/vbraun"
}
```

Again, no coercion to the infinity ring means: comparison by memory address. Which will a) not be the one you like and b) inconsistent across different runs / platforms. Maybe we can't fix a) right away, but we must fix b).



---

archive/issue_comments_125087.json:
```json
{
    "body": "Given that comparison of `RIF` elements with infinity is broken, and there is no good way to fix it with the current `InfinityRing`, users have to work around it by comparing upper and lower endpoings separately, until someone implements these \"intervals in the infinity ring\".  If that is the case, then why is it so urgent to make comparison of `RIF` elements with infinity sort of work right now?",
    "created_at": "2014-05-21T13:28:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125087",
    "user": "https://github.com/pjbruin"
}
```

Given that comparison of `RIF` elements with infinity is broken, and there is no good way to fix it with the current `InfinityRing`, users have to work around it by comparing upper and lower endpoings separately, until someone implements these "intervals in the infinity ring".  If that is the case, then why is it so urgent to make comparison of `RIF` elements with infinity sort of work right now?



---

archive/issue_comments_125088.json:
```json
{
    "body": "All I'm saying is that the current state is a clear improvement over what we currently have. Do you want me to revert to the old behaviour of comparison by memory address, causing hard-to-debug errors where the sort order depends on the machine and time of the day?",
    "created_at": "2014-05-21T15:43:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125088",
    "user": "https://github.com/vbraun"
}
```

All I'm saying is that the current state is a clear improvement over what we currently have. Do you want me to revert to the old behaviour of comparison by memory address, causing hard-to-debug errors where the sort order depends on the machine and time of the day?



---

archive/issue_comments_125089.json:
```json
{
    "body": "To be honest I personally don't care too much about this specific problem, and I would be happy to set the ticket back to positive review if Travis can live with that.",
    "created_at": "2014-05-21T16:36:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125089",
    "user": "https://github.com/pjbruin"
}
```

To be honest I personally don't care too much about this specific problem, and I would be happy to set the ticket back to positive review if Travis can live with that.



---

archive/issue_comments_125090.json:
```json
{
    "body": "IMO this makes things worse: a potential subtle bug is better than a (generally) mathematically wrong answer. Irregardless, this is not a coercion as it is not a ring morphism:\n\n```\nsage: RIF(0, oo) - RIF(0, oo)\n[-infinity .. +infinity]\nsage: InfinityRing(RIF(0, oo) - RIF(0, oo))\n+Infinity\nsage: InfinityRing(RIF(0, oo)) - InfinityRing(RIF(0, oo))\n---------------------------------------------------------------------------\nSignError                                 Traceback (most recent call last)\n...\nSignError: cannot add infinity to minus infinity\n```",
    "created_at": "2014-05-22T06:06:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125090",
    "user": "https://github.com/tscrim"
}
```

IMO this makes things worse: a potential subtle bug is better than a (generally) mathematically wrong answer. Irregardless, this is not a coercion as it is not a ring morphism:

```
sage: RIF(0, oo) - RIF(0, oo)
[-infinity .. +infinity]
sage: InfinityRing(RIF(0, oo) - RIF(0, oo))
+Infinity
sage: InfinityRing(RIF(0, oo)) - InfinityRing(RIF(0, oo))
---------------------------------------------------------------------------
SignError                                 Traceback (most recent call last)
...
SignError: cannot add infinity to minus infinity
```



---

archive/issue_comments_125091.json:
```json
{
    "body": "Of course its not a ring homomorphism. Neither RIF nor the infinity ring are even additive Abelian groups.\n\n```\nsage: x = RIF(0,1);  x - x == 0\nFalse\n```",
    "created_at": "2014-05-22T09:20:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125091",
    "user": "https://github.com/vbraun"
}
```

Of course its not a ring homomorphism. Neither RIF nor the infinity ring are even additive Abelian groups.

```
sage: x = RIF(0,1);  x - x == 0
False
```



---

archive/issue_comments_125092.json:
```json
{
    "body": "There should be a bit better check of equality in RIF as `x - x` will be 0 because we know we are subtracting the same number (even if we don't know the exact number). However `RIF(0,1) - RIF(0,1)` may or may not be 0, we don't know because the left and right terms may or may not be the same value. So IMO it still is a field (it also is in the category of `Fields`), but doing exact comparisons can be difficult.\n\nNow the infinity ring is a actually a semiring, but nevertheless it still has less structure. Even if we don't want to consider which category, the basic promise of coercion is that if you can do operation `#` on (2 elements of) `A`, then you can do the same (equivalent?) operation on `B`.",
    "created_at": "2014-05-22T15:00:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125092",
    "user": "https://github.com/tscrim"
}
```

There should be a bit better check of equality in RIF as `x - x` will be 0 because we know we are subtracting the same number (even if we don't know the exact number). However `RIF(0,1) - RIF(0,1)` may or may not be 0, we don't know because the left and right terms may or may not be the same value. So IMO it still is a field (it also is in the category of `Fields`), but doing exact comparisons can be difficult.

Now the infinity ring is a actually a semiring, but nevertheless it still has less structure. Even if we don't want to consider which category, the basic promise of coercion is that if you can do operation `#` on (2 elements of) `A`, then you can do the same (equivalent?) operation on `B`.



---

archive/issue_comments_125093.json:
```json
{
    "body": "Replying to [comment:37 tscrim]:\n> So IMO it still is a field (it also is in the category of `Fields`)\n\n`RIF` is definitely not a field (and neither are `RR` and `RDF`).  They are Sage objects that approximate the field **R** of real numbers in different ways, but none of these Sage objects satisfies the axioms of a field.\n> Now the infinity ring is a actually a semiring, but nevertheless it still has less structure.\n\nI don't understand this.  Addition of `+Infinity` and `-Infinity` is undefined in the infinity ring, or is this what you mean by \"less structure\"?\n> Even if we don't want to consider which category, the basic promise of coercion is that if you can do operation `#` on (2 elements of) `A`, then you can do the same (equivalent?) operation on `B`.\n\nNo, the operation `4 // 2` is defined in `ZZ`, but not after coercion to `Zmod(8)`, for example.",
    "created_at": "2014-05-22T15:15:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125093",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:37 tscrim]:
> So IMO it still is a field (it also is in the category of `Fields`)

`RIF` is definitely not a field (and neither are `RR` and `RDF`).  They are Sage objects that approximate the field **R** of real numbers in different ways, but none of these Sage objects satisfies the axioms of a field.
> Now the infinity ring is a actually a semiring, but nevertheless it still has less structure.

I don't understand this.  Addition of `+Infinity` and `-Infinity` is undefined in the infinity ring, or is this what you mean by "less structure"?
> Even if we don't want to consider which category, the basic promise of coercion is that if you can do operation `#` on (2 elements of) `A`, then you can do the same (equivalent?) operation on `B`.

No, the operation `4 // 2` is defined in `ZZ`, but not after coercion to `Zmod(8)`, for example.



---

archive/issue_comments_125094.json:
```json
{
    "body": "Replying to [comment:38 pbruin]:\n> `RIF` is definitely not a field (and neither are `RR` and `RDF`).  They are Sage objects that approximate the field **R** of real numbers in different ways, but none of these Sage objects satisfies the axioms of a field.\n\n\nSince there is `oo` in `RIF`, I agree with you, it's actually not a field. Although I would say that if we remove `oo`, I would say it is a field. But this is a separate point, because the break is in the addition, not the multiplication. So would you say `RIF` is an additive abelian group?\n\nI also found some strange behavior with `RIF`:\n\n```\nsage: oo in RIF\nTrue\nsage: RIF(oo)\n[+infinity .. +infinity]\nsage: RIF(oo) / RIF(oo)\n[.. NaN ..]\nsage: RIF(oo) / RIF(0)\n[-infinity .. +infinity]\nsage: RIF(oo) * RIF(0)\n0\n```\n\n> I don't understand this.  Addition of `+Infinity` and `-Infinity` is undefined in the infinity ring, or is this what you mean by \"less structure\"?\n\n\nYes (another example would be the tropical semiring).\n\n> No, the operation `4 // 2` is defined in `ZZ`, but not after coercion to `Zmod(8)`, for example.\n\n\nIn this case, division is not a part of the structure of `ZZ`, so perhaps I should amend my statement above to when you can *always* do operation `#` (i.e. it is guaranteed by the category). For `RIF`, subtraction is guaranteed to work.",
    "created_at": "2014-05-22T16:16:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125094",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:38 pbruin]:
> `RIF` is definitely not a field (and neither are `RR` and `RDF`).  They are Sage objects that approximate the field **R** of real numbers in different ways, but none of these Sage objects satisfies the axioms of a field.


Since there is `oo` in `RIF`, I agree with you, it's actually not a field. Although I would say that if we remove `oo`, I would say it is a field. But this is a separate point, because the break is in the addition, not the multiplication. So would you say `RIF` is an additive abelian group?

I also found some strange behavior with `RIF`:

```
sage: oo in RIF
True
sage: RIF(oo)
[+infinity .. +infinity]
sage: RIF(oo) / RIF(oo)
[.. NaN ..]
sage: RIF(oo) / RIF(0)
[-infinity .. +infinity]
sage: RIF(oo) * RIF(0)
0
```

> I don't understand this.  Addition of `+Infinity` and `-Infinity` is undefined in the infinity ring, or is this what you mean by "less structure"?


Yes (another example would be the tropical semiring).

> No, the operation `4 // 2` is defined in `ZZ`, but not after coercion to `Zmod(8)`, for example.


In this case, division is not a part of the structure of `ZZ`, so perhaps I should amend my statement above to when you can *always* do operation `#` (i.e. it is guaranteed by the category). For `RIF`, subtraction is guaranteed to work.



---

archive/issue_comments_125095.json:
```json
{
    "body": "Replying to [comment:39 tscrim]:\n> Since there is `oo` in `RIF`, I agree with you, it's actually not a field. Although I would say that if we remove `oo`, I would say it is a field.\n\nNo, see below.\n> But this is a separate point, because the break is in the addition, not the multiplication. So would you say `RIF` is an additive abelian group?\n\nAs Volker pointed out, it isn't, even if we remove infinity.  And since it isn't an additive Abelian group, it certainly isn't a field either.  Moreover, the set of non-zero, non-infinite elements is not a group under multiplication.  For example, the interval [-1, 1] has neither an additive nor a multiplicative inverse.\n> I also found some strange behavior with `RIF`:\n> \n> ```\n> sage: oo in RIF\n> True\n> sage: RIF(oo)\n> [+infinity .. +infinity]\n> sage: RIF(oo) / RIF(oo)\n> [.. NaN ..]\n> sage: RIF(oo) / RIF(0)\n> [-infinity .. +infinity]\n> sage: RIF(oo) * RIF(0)\n> 0\n> ```\n\nThat does look slightly inconsistent, especially the last one, but I don't have enough experience with `RIF` to say if this is intended.\n> > I don't understand this.  Addition of `+Infinity` and `-Infinity` is undefined in the infinity ring, or is this what you mean by \"less structure\"?\n\n> \n> Yes (another example would be the tropical semiring).\n\nI still don't get your point.  The tropical semiring is a semiring, while `InfinityRing` is not a semiring.\n> > No, the operation `4 // 2` is defined in `ZZ`, but not after coercion to `Zmod(8)`, for example.\n\n> \n> In this case, division is not a part of the structure of `ZZ`, so perhaps I should amend my statement above to when you can *always* do operation `#` (i.e. it is guaranteed by the category). For `RIF`, subtraction is guaranteed to work.\n\nThat depends on what you mean by \"work\":\n\n```\nsage: RIF(oo) - RIF(oo)\n[.. NaN ..]\n```\nMaybe this should return `[-infinity .. +infinity]`, then it would cooperate nicely with the future support for \"intervals in the infinity ring\" (comments 29 and 30 above).",
    "created_at": "2014-05-22T17:10:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125095",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:39 tscrim]:
> Since there is `oo` in `RIF`, I agree with you, it's actually not a field. Although I would say that if we remove `oo`, I would say it is a field.

No, see below.
> But this is a separate point, because the break is in the addition, not the multiplication. So would you say `RIF` is an additive abelian group?

As Volker pointed out, it isn't, even if we remove infinity.  And since it isn't an additive Abelian group, it certainly isn't a field either.  Moreover, the set of non-zero, non-infinite elements is not a group under multiplication.  For example, the interval [-1, 1] has neither an additive nor a multiplicative inverse.
> I also found some strange behavior with `RIF`:
> 
> ```
> sage: oo in RIF
> True
> sage: RIF(oo)
> [+infinity .. +infinity]
> sage: RIF(oo) / RIF(oo)
> [.. NaN ..]
> sage: RIF(oo) / RIF(0)
> [-infinity .. +infinity]
> sage: RIF(oo) * RIF(0)
> 0
> ```

That does look slightly inconsistent, especially the last one, but I don't have enough experience with `RIF` to say if this is intended.
> > I don't understand this.  Addition of `+Infinity` and `-Infinity` is undefined in the infinity ring, or is this what you mean by "less structure"?

> 
> Yes (another example would be the tropical semiring).

I still don't get your point.  The tropical semiring is a semiring, while `InfinityRing` is not a semiring.
> > No, the operation `4 // 2` is defined in `ZZ`, but not after coercion to `Zmod(8)`, for example.

> 
> In this case, division is not a part of the structure of `ZZ`, so perhaps I should amend my statement above to when you can *always* do operation `#` (i.e. it is guaranteed by the category). For `RIF`, subtraction is guaranteed to work.

That depends on what you mean by "work":

```
sage: RIF(oo) - RIF(oo)
[.. NaN ..]
```
Maybe this should return `[-infinity .. +infinity]`, then it would cooperate nicely with the future support for "intervals in the infinity ring" (comments 29 and 30 above).



---

archive/issue_comments_125096.json:
```json
{
    "body": "Replying to [comment:40 pbruin]:\n> As Volker pointed out, it isn't, even if we remove infinity.  And since it isn't an additive Abelian group, it certainly isn't a field either.  Moreover, the set of non-zero, non-infinite elements is not a group under multiplication.  For example, the interval [-1, 1] has neither an additive nor a multiplicative inverse.\n> ...\n> That depends on what you mean by \"work\":\n> \n> ```\n> sage: RIF(oo) - RIF(oo)\n> [.. NaN ..]\n> ```\n> Maybe this should return `[-infinity .. +infinity]`, then it would cooperate nicely with the future support for \"intervals in the infinity ring\" (comments 29 and 30 above).\n\n\nFrom my understanding, elements in RIF aren't intervals as sets, they are a single point that's guaranteed to be within in the interval. Thus if we fix a real element `x` in an interval, say `[-1, 1]`, then `x - x == 0` should be true (which I would say that it does not is currently a bug). However doing something like `RIF(-1,1) - RIF(-1, 1)` gets two (essentially) random numbers in the interval `[-1, 1]` and subtracts them and `RIF` tells us the result is guaranteed to lie in `[-2, 2]`.\n\nWell...at least if we throw out the exact values of `+/-oo` and the `NaN`...(and it's essentially a field to the average user)\n\nWe also have this behavior with the current branch:\n\n```\nsage: InfinityRing(RIF(oo) - RIF(oo))\nA positive finite number\nsage: InfinityRing(float(\"NaN\"))\nA negative finite number\n```\nAt least it maps this over. So to add to the question list, how do we handle this too? Keep it as is?\n\n> I still don't get your point. The tropical semiring is a semiring, while InfinityRing is not a semiring.\n\n\nOkay, I'm going to take a deep breath and try to make I'm not missing any cases or over simplifying things.\n\nIn `RIF` (with `[.. NaN ..]`), we have an additive abelian semigroup as we have an associative binary operation.\n\nFor `InfinityRing`, we have 5 elements: `[-oo, n, 0, p, oo]` where `n` and `p` are finite negative and positive numbers respectively. The following additions are defined (up to commutation):\n\n```\n-oo + [n, 0, p] -> -oo\nn + [n, 0] -> n\np + [0, p] -> p\noo + [n, 0, p] -> oo\n```\nbut none of the others (and multiplication is worse). So it doesn't have any fully defined binary operations on the entire set.\n\nI didn't miss any cases, right? If so, then this is when I say \"less structure\".",
    "created_at": "2014-05-22T19:36:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125096",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:40 pbruin]:
> As Volker pointed out, it isn't, even if we remove infinity.  And since it isn't an additive Abelian group, it certainly isn't a field either.  Moreover, the set of non-zero, non-infinite elements is not a group under multiplication.  For example, the interval [-1, 1] has neither an additive nor a multiplicative inverse.
> ...
> That depends on what you mean by "work":
> 
> ```
> sage: RIF(oo) - RIF(oo)
> [.. NaN ..]
> ```
> Maybe this should return `[-infinity .. +infinity]`, then it would cooperate nicely with the future support for "intervals in the infinity ring" (comments 29 and 30 above).


From my understanding, elements in RIF aren't intervals as sets, they are a single point that's guaranteed to be within in the interval. Thus if we fix a real element `x` in an interval, say `[-1, 1]`, then `x - x == 0` should be true (which I would say that it does not is currently a bug). However doing something like `RIF(-1,1) - RIF(-1, 1)` gets two (essentially) random numbers in the interval `[-1, 1]` and subtracts them and `RIF` tells us the result is guaranteed to lie in `[-2, 2]`.

Well...at least if we throw out the exact values of `+/-oo` and the `NaN`...(and it's essentially a field to the average user)

We also have this behavior with the current branch:

```
sage: InfinityRing(RIF(oo) - RIF(oo))
A positive finite number
sage: InfinityRing(float("NaN"))
A negative finite number
```
At least it maps this over. So to add to the question list, how do we handle this too? Keep it as is?

> I still don't get your point. The tropical semiring is a semiring, while InfinityRing is not a semiring.


Okay, I'm going to take a deep breath and try to make I'm not missing any cases or over simplifying things.

In `RIF` (with `[.. NaN ..]`), we have an additive abelian semigroup as we have an associative binary operation.

For `InfinityRing`, we have 5 elements: `[-oo, n, 0, p, oo]` where `n` and `p` are finite negative and positive numbers respectively. The following additions are defined (up to commutation):

```
-oo + [n, 0, p] -> -oo
n + [n, 0] -> n
p + [0, p] -> p
oo + [n, 0, p] -> oo
```
but none of the others (and multiplication is worse). So it doesn't have any fully defined binary operations on the entire set.

I didn't miss any cases, right? If so, then this is when I say "less structure".



---

archive/issue_comments_125097.json:
```json
{
    "body": "Replying to [comment:41 tscrim]:\n> From my understanding, elements in RIF aren't intervals as sets\n\n\nNo, they are intervals as sets. This is how RIF is implemented, and this is how it behaves.",
    "created_at": "2014-05-22T20:06:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125097",
    "user": "https://github.com/vbraun"
}
```

Replying to [comment:41 tscrim]:
> From my understanding, elements in RIF aren't intervals as sets


No, they are intervals as sets. This is how RIF is implemented, and this is how it behaves.



---

archive/issue_comments_125098.json:
```json
{
    "body": "Then this should be true:\n\n```\nsage: RIF(1, 2) == RIF(1, 2)\nFalse\n```\nsince they are clearly equal as sets.",
    "created_at": "2014-05-22T20:38:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125098",
    "user": "https://github.com/tscrim"
}
```

Then this should be true:

```
sage: RIF(1, 2) == RIF(1, 2)
False
```
since they are clearly equal as sets.



---

archive/issue_comments_125099.json:
```json
{
    "body": "```\nsage: cmp(RIF(1,0), RIF(1,0))\n0\n```",
    "created_at": "2014-05-22T21:15:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125099",
    "user": "https://github.com/vbraun"
}
```

```
sage: cmp(RIF(1,0), RIF(1,0))
0
```



---

archive/issue_comments_125100.json:
```json
{
    "body": "I am now convinced of Volker's position to immediately fix this (to the extent possible with the current `InfinityRing`).  This example (without the patch applied) is decisive for me:\n\n```\nsage: RIF(0,1) > infinity\nTrue\n```",
    "created_at": "2014-05-22T22:12:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125100",
    "user": "https://github.com/pjbruin"
}
```

I am now convinced of Volker's position to immediately fix this (to the extent possible with the current `InfinityRing`).  This example (without the patch applied) is decisive for me:

```
sage: RIF(0,1) > infinity
True
```



---

archive/issue_comments_125101.json:
```json
{
    "body": "Replying to [comment:45 pbruin]:\n> I am now convinced of Volker's position to immediately fix this (to the extent possible with the current `InfinityRing`).  This example (without the patch applied) is decisive for me:\n> \n> ```\n> sage: RIF(0,1) > infinity\n> True\n> ```\n\n\nDependent on memory locations, YMMV",
    "created_at": "2014-05-22T22:31:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125101",
    "user": "https://github.com/vbraun"
}
```

Replying to [comment:45 pbruin]:
> I am now convinced of Volker's position to immediately fix this (to the extent possible with the current `InfinityRing`).  This example (without the patch applied) is decisive for me:
> 
> ```
> sage: RIF(0,1) > infinity
> True
> ```


Dependent on memory locations, YMMV



---

archive/issue_comments_125102.json:
```json
{
    "body": "Replying to [comment:46 vbraun]:\n> > {{{\n> > sage: RIF(0,1) > infinity\n> > True\n> > }}}\n\n> \n> Dependent on memory locations, YMMV \n\nI know, it's just that this example made me realise how annoying that can be.",
    "created_at": "2014-05-22T22:42:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125102",
    "user": "https://github.com/pjbruin"
}
```

Replying to [comment:46 vbraun]:
> > {{{
> > sage: RIF(0,1) > infinity
> > True
> > }}}

> 
> Dependent on memory locations, YMMV 

I know, it's just that this example made me realise how annoying that can be.



---

archive/issue_comments_125103.json:
```json
{
    "body": "I think we should just document the behaviour of the `RIF` -> `InfinityRing` conversion implemented by this ticket and add a warning that this may change in the future.  If everyone finds that acceptable as a (partial/temporary if you like) solution, we can close this ticket as far as I'm concerned.",
    "created_at": "2014-05-23T19:03:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125103",
    "user": "https://github.com/pjbruin"
}
```

I think we should just document the behaviour of the `RIF` -> `InfinityRing` conversion implemented by this ticket and add a warning that this may change in the future.  If everyone finds that acceptable as a (partial/temporary if you like) solution, we can close this ticket as far as I'm concerned.



---

archive/issue_comments_125104.json:
```json
{
    "body": "However `cmp` is for totally ordered sets and `RIF` is not, so I don't trust it here (plus it's deprecated in python3):\n\n```\nsage: P = Poset([['a', 'b'], []], facade=False)\nsage: a = P('a')\nsage: b = P('b')\nsage: a < b\nFalse\nsage: b < a\nFalse\nsage: a > b\nFalse\nsage: b > a\nFalse\nsage: cmp(a, b)\n0\nsage: a == b\nFalse\n```\nSo what's happening is in `cmp(a, b)`, because neither `a` is less/greater than `b` nor vice versa, it's saying they must be equal (because it is supposed to be a totally ordered set).\n\nI'd be okay with a big warning in the doc and a printed warning when coercing (semi)infinity intervals into the infinity ring.",
    "created_at": "2014-05-23T20:36:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125104",
    "user": "https://github.com/tscrim"
}
```

However `cmp` is for totally ordered sets and `RIF` is not, so I don't trust it here (plus it's deprecated in python3):

```
sage: P = Poset([['a', 'b'], []], facade=False)
sage: a = P('a')
sage: b = P('b')
sage: a < b
False
sage: b < a
False
sage: a > b
False
sage: b > a
False
sage: cmp(a, b)
0
sage: a == b
False
```
So what's happening is in `cmp(a, b)`, because neither `a` is less/greater than `b` nor vice versa, it's saying they must be equal (because it is supposed to be a totally ordered set).

I'd be okay with a big warning in the doc and a printed warning when coercing (semi)infinity intervals into the infinity ring.



---

archive/issue_comments_125105.json:
```json
{
    "body": "I'm against printing BS warnings, the various comparison in RIF are already complicated and and more motivated by what one can do vs what is mathematically desirable.",
    "created_at": "2014-05-23T20:49:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125105",
    "user": "https://github.com/vbraun"
}
```

I'm against printing BS warnings, the various comparison in RIF are already complicated and and more motivated by what one can do vs what is mathematically desirable.



---

archive/issue_comments_125106.json:
```json
{
    "body": "I'm also against a printed warning, but a line or two in the docstring of the relevant `_element_constructor_` and/or `_coerce_map_from_` methods would be appropriate in my opinion.",
    "created_at": "2014-05-23T21:06:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125106",
    "user": "https://github.com/pjbruin"
}
```

I'm also against a printed warning, but a line or two in the docstring of the relevant `_element_constructor_` and/or `_coerce_map_from_` methods would be appropriate in my opinion.



---

archive/issue_comments_125107.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-23T21:41:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125107",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_125108.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2014-05-23T21:42:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125108",
    "user": "https://github.com/vbraun"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_125109.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-05-23T21:51:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125109",
    "user": "https://github.com/pjbruin"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_125110.json:
```json
{
    "body": "trivial reviewer patch (fix typo)",
    "created_at": "2014-05-23T21:51:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125110",
    "user": "https://github.com/pjbruin"
}
```

trivial reviewer patch (fix typo)



---

archive/issue_comments_125111.json:
```json
{
    "body": "well the semicolon was intentional, but I'm also fine with a period.",
    "created_at": "2014-05-23T22:15:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125111",
    "user": "https://github.com/vbraun"
}
```

well the semicolon was intentional, but I'm also fine with a period.



---

archive/issue_comments_125112.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-05-25T10:09:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125112",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_029998.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2014-05-25T10:09:16Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/11334#event-29998"
}
```



---

archive/issue_comments_125113.json:
```json
{
    "body": "I am a bit late to comment on this, but let me add my 2\u00a0cents about what `infinity in RR` should return and related questions.\nThe way I understand it:\n* `RR` essentially is an interface to MPFR. It is not, has never been and cannot be the right model for the field of real numbers in sage.\n* `RIF` being based on MPFI, its elements are sets. As a general \n  rule, operations on these elements are required to return \n  over-approximations of the image of their operands, period. Note that this \n  could apply to boolean predicates: in an ideal world, `[1,3] = [2,4]` would \n  return something like `{True, False}`. But some compromises are necessary, in \n  part because sage keeps abusing Python's equality and comparison operators \n  instead of defining its own \"mathematical\" equality.\nSo I think the problems raised by Peter and Travis are mostly due to \nunfortunate name choices and cannot be solved without \nbreaking lots of existing code. The best plan I can come up with would be \nsomething like this:\n* Deprecate `RR`, `Reals()`, and `RealField()` (`Reals(p)`, `RealField(p)` can probably stay). Replace `RR` by `RFP`.\n* Make it clear in the documentation that these parents represent sets of floating-point numbers\u2014particular subsets of the dyadic rationals, augmented with special values such as \u00b1\u221e and equipped with well-defined, if peculiar, operations\u2014, not the field of real numbers.\n* While we're at it, deprecate `RIF` and `RealIntervalField`. Rename them to something like `IR` (a common notation in interval analysis) and `RealFloatingPointIntervals`.\n* Stop pretending any of these are fields (or even semigroups). Perhaps introduce a category of \"approximate fields\" (for lack of a better name).\n* After the deprecation period, consider making `RR` and `Reals` refer to/return `RLF` (or perhaps some new implementation that better models the \"true\" reals).\n* Idem for `CC`, `CIF` etc.",
    "created_at": "2014-06-06T15:32:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/11334",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/11334#issuecomment-125113",
    "user": "https://github.com/mezzarobba"
}
```

I am a bit late to comment on this, but let me add my 2 cents about what `infinity in RR` should return and related questions.
The way I understand it:
* `RR` essentially is an interface to MPFR. It is not, has never been and cannot be the right model for the field of real numbers in sage.
* `RIF` being based on MPFI, its elements are sets. As a general 
  rule, operations on these elements are required to return 
  over-approximations of the image of their operands, period. Note that this 
  could apply to boolean predicates: in an ideal world, `[1,3] = [2,4]` would 
  return something like `{True, False}`. But some compromises are necessary, in 
  part because sage keeps abusing Python's equality and comparison operators 
  instead of defining its own "mathematical" equality.
So I think the problems raised by Peter and Travis are mostly due to 
unfortunate name choices and cannot be solved without 
breaking lots of existing code. The best plan I can come up with would be 
something like this:
* Deprecate `RR`, `Reals()`, and `RealField()` (`Reals(p)`, `RealField(p)` can probably stay). Replace `RR` by `RFP`.
* Make it clear in the documentation that these parents represent sets of floating-point numbers—particular subsets of the dyadic rationals, augmented with special values such as ±∞ and equipped with well-defined, if peculiar, operations—, not the field of real numbers.
* While we're at it, deprecate `RIF` and `RealIntervalField`. Rename them to something like `IR` (a common notation in interval analysis) and `RealFloatingPointIntervals`.
* Stop pretending any of these are fields (or even semigroups). Perhaps introduce a category of "approximate fields" (for lack of a better name).
* After the deprecation period, consider making `RR` and `Reals` refer to/return `RLF` (or perhaps some new implementation that better models the "true" reals).
* Idem for `CC`, `CIF` etc.
