# Issue 32054: Turn reduce of generic ideals into abstract method

archive/issues_032054.json:
```json
{
    "body": "CC:  @trevorkarn @tscrim @mkoeppe @jhpalmieri\n\nCurrently, generic ideals in `sage.rings.ideal.Ideal_generic` have the following `reduce` method:\n\n\n```python\n    def reduce(self, f):\n        r\"\"\"\n        Return the reduction of the element of `f` modulo ``self``.\n\n        This is an element of `R` that is equivalent modulo `I` to `f` where\n        `I` is ``self``.\n\n        EXAMPLES::\n\n            sage: ZZ.ideal(5).reduce(17)\n            2\n            sage: parent(ZZ.ideal(5).reduce(17))\n            Integer Ring\n        \"\"\"\n        return f       # default\n```\n\n\nThis behavior is typically unwanted. We replace the method with an abstract method instead, raising a NotImplementedError by default.\n\nIssue created by migration from https://trac.sagemath.org/ticket/32291\n\n",
    "created_at": "2021-07-28T15:43:36Z",
    "labels": [
        "algebra",
        "major",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Turn reduce of generic ideals into abstract method",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/32054",
    "user": "@mjungmath"
}
```
CC:  @trevorkarn @tscrim @mkoeppe @jhpalmieri

Currently, generic ideals in `sage.rings.ideal.Ideal_generic` have the following `reduce` method:


```python
    def reduce(self, f):
        r"""
        Return the reduction of the element of `f` modulo ``self``.

        This is an element of `R` that is equivalent modulo `I` to `f` where
        `I` is ``self``.

        EXAMPLES::

            sage: ZZ.ideal(5).reduce(17)
            2
            sage: parent(ZZ.ideal(5).reduce(17))
            Integer Ring
        """
        return f       # default
```


This behavior is typically unwanted. We replace the method with an abstract method instead, raising a NotImplementedError by default.

Issue created by migration from https://trac.sagemath.org/ticket/32291





---

archive/issue_comments_457646.json:
```json
{
    "body": "There is still something not quite right about what I pushed, but it is a start.\n----\nNew commits:",
    "created_at": "2021-07-28T22:05:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457646",
    "user": "@trevorkarn"
}
```

There is still something not quite right about what I pushed, but it is a start.
----
New commits:



---

archive/issue_comments_457647.json:
```json
{
    "body": "1. I would propose to modify the method in `Ideal_generic` instead of adding a new one to `noncommutative_ideals`.\n\n2. Sage provides a [decorator for abstract methods](https://doc.sagemath.org/html/en/reference/misc/sage/misc/abstract_method.html).\n\n3. The error message is imo slightly misleading in the sense that reduction can be supported in general, but must be individually implemented when subclassed.",
    "created_at": "2021-07-28T22:24:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457647",
    "user": "@mjungmath"
}
```

1. I would propose to modify the method in `Ideal_generic` instead of adding a new one to `noncommutative_ideals`.

2. Sage provides a [decorator for abstract methods](https://doc.sagemath.org/html/en/reference/misc/sage/misc/abstract_method.html).

3. The error message is imo slightly misleading in the sense that reduction can be supported in general, but must be individually implemented when subclassed.



---

archive/issue_comments_457648.json:
```json
{
    "body": "I am a firm -1 on this because the `reduce()` method is just saying, \"Give me a representative of `p` in the ideal `I`.\" So there is nothing mathematically wrong with this. Yes, it is less than ideal because we want it to be \"minimal\" but that is not strictly required.",
    "created_at": "2021-07-28T22:54:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457648",
    "user": "@tscrim"
}
```

I am a firm -1 on this because the `reduce()` method is just saying, "Give me a representative of `p` in the ideal `I`." So there is nothing mathematically wrong with this. Yes, it is less than ideal because we want it to be "minimal" but that is not strictly required.



---

archive/issue_comments_457649.json:
```json
{
    "body": "That makes sense. However, we should at least document that the usage of generic ideals leads to unexpected results in quotient rings (see e.g. https://ask.sagemath.org/question/56243/quotients-of-exterior-algebras/).",
    "created_at": "2021-07-29T08:36:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457649",
    "user": "@mjungmath"
}
```

That makes sense. However, we should at least document that the usage of generic ideals leads to unexpected results in quotient rings (see e.g. https://ask.sagemath.org/question/56243/quotients-of-exterior-algebras/).



---

archive/issue_comments_457650.json:
```json
{
    "body": "It looks like the perturbator is rather `_richcmp_` in `rings.quotient_ring_element.QuotientRingElement` comparing two elements on the level of the ring, and not of the quotient.\n\nLong story short, the implementation of `_richcmp_` in fact assumes that `reduce` returns the \"minimal\" reduction.",
    "created_at": "2021-07-29T10:44:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457650",
    "user": "@mjungmath"
}
```

It looks like the perturbator is rather `_richcmp_` in `rings.quotient_ring_element.QuotientRingElement` comparing two elements on the level of the ring, and not of the quotient.

Long story short, the implementation of `_richcmp_` in fact assumes that `reduce` returns the "minimal" reduction.



---

archive/issue_comments_457651.json:
```json
{
    "body": "I would propose to boil the comparison in case of equality down to the check `bool(self-other)` instead. What do you think?",
    "created_at": "2021-07-29T11:06:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457651",
    "user": "@mjungmath"
}
```

I would propose to boil the comparison in case of equality down to the check `bool(self-other)` instead. What do you think?



---

archive/issue_comments_457652.json:
```json
{
    "body": "Changing type from enhancement to defect.",
    "created_at": "2021-07-29T11:24:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457652",
    "user": "@mjungmath"
}
```

Changing type from enhancement to defect.



---

archive/issue_comments_457653.json:
```json
{
    "body": "Should we also remove `_richcmp_` completely? I have the feeling this code returns nonsense most times.",
    "created_at": "2021-07-29T11:24:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457653",
    "user": "@mjungmath"
}
```

Should we also remove `_richcmp_` completely? I have the feeling this code returns nonsense most times.



---

archive/issue_comments_457654.json:
```json
{
    "body": "> ASSUMPTION:\n>\n> I has a method I.reduce(x) returning the normal form of elements x\u2208R. In other words, it is required that I.reduce(x)==I.reduce(y) \u27fax\u2212y\u2208I, and x-I.reduce(x) in I, for all x,y\u2208R.\n\nThis is an extract of https://doc.sagemath.org/html/en/reference/rings/sage/rings/quotient_ring.html#sage.rings.quotient_ring.QuotientRing. That means, the reduce function of an ideal is usually expected to return the normal form. This is currently not given.",
    "created_at": "2021-07-29T12:59:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457654",
    "user": "@mjungmath"
}
```

> ASSUMPTION:
>
> I has a method I.reduce(x) returning the normal form of elements x∈R. In other words, it is required that I.reduce(x)==I.reduce(y) ⟺x−y∈I, and x-I.reduce(x) in I, for all x,y∈R.

This is an extract of https://doc.sagemath.org/html/en/reference/rings/sage/rings/quotient_ring.html#sage.rings.quotient_ring.QuotientRing. That means, the reduce function of an ideal is usually expected to return the normal form. This is currently not given.



---

archive/issue_comments_457655.json:
```json
{
    "body": "I'm now slightly confused. The example given in your sage-devel post is now working for me in the GCA case.\n\n\n```\nsage: A.<x,y,z> = GradedCommutativeAlgebra(QQ,degrees=(1,2,3))                                                                                                                                              \nsage: I = A.ideal(x*y-z)                                                                                                                                                                                    \nsage: J = A.ideal(x^2)                                                                                                                                                                                      \nsage: Q1 = A.quotient(I)                                                                                                                                                                                    \nsage: Q2 = A.quotient(J)                                                                                                                                                                                    \nsage: Q1.gens()[0]*Q1.gens()[1] # x*y                                                                                                                                                                       \nz\nsage: Q2.gens()[0]^2 # x^2                                                                                                                                                                               \n0\nsage: Q2.gens()[0]^2 == 0  \nTrue\n```\n\n\nI am running sage 9.4.beta5 so I'm not sure if it is fixed there or what is going on. On the other hand, the exterior algebra still has the same behavior as in the description.",
    "created_at": "2021-07-29T19:59:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457655",
    "user": "@trevorkarn"
}
```

I'm now slightly confused. The example given in your sage-devel post is now working for me in the GCA case.


```
sage: A.<x,y,z> = GradedCommutativeAlgebra(QQ,degrees=(1,2,3))                                                                                                                                              
sage: I = A.ideal(x*y-z)                                                                                                                                                                                    
sage: J = A.ideal(x^2)                                                                                                                                                                                      
sage: Q1 = A.quotient(I)                                                                                                                                                                                    
sage: Q2 = A.quotient(J)                                                                                                                                                                                    
sage: Q1.gens()[0]*Q1.gens()[1] # x*y                                                                                                                                                                       
z
sage: Q2.gens()[0]^2 # x^2                                                                                                                                                                               
0
sage: Q2.gens()[0]^2 == 0  
True
```


I am running sage 9.4.beta5 so I'm not sure if it is fixed there or what is going on. On the other hand, the exterior algebra still has the same behavior as in the description.



---

archive/issue_comments_457656.json:
```json
{
    "body": "Replying to [comment:10 tkarn]:\n> I'm now slightly confused. The example given in your sage-devel post is now working for me in the GCA case.\n> \n> {{{\n> sage: A.<x,y,z> = GradedCommutativeAlgebra(QQ,degrees=(1,2,3))                                                                                                                                              \n> sage: I = A.ideal(x*y-z)                                                                                                                                                                                    \n> sage: J = A.ideal(x^2)                                                                                                                                                                                      \n> sage: Q1 = A.quotient(I)                                                                                                                                                                                    \n> sage: Q2 = A.quotient(J)                                                                                                                                                                                    \n> sage: Q1.gens()[0]*Q1.gens()[1] # x*y                                                                                                                                                                       \n> z\n> sage: Q2.gens()[0]^2 # x^2                                                                                                                                                                               \n> 0\n> sage: Q2.gens()[0]^2 == 0  \n> True\n> }}}\n> \n> I am running sage 9.4.beta5 so I'm not sure if it is fixed there or what is going on. On the other hand, the exterior algebra still has the same behavior as in the description.\n\nI was using my implementation in #32272. The class `GCAlgebra` uses a non-generic quotient.",
    "created_at": "2021-07-29T22:04:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457656",
    "user": "@mjungmath"
}
```

Replying to [comment:10 tkarn]:
> I'm now slightly confused. The example given in your sage-devel post is now working for me in the GCA case.
> 
> {{{
> sage: A.<x,y,z> = GradedCommutativeAlgebra(QQ,degrees=(1,2,3))                                                                                                                                              
> sage: I = A.ideal(x*y-z)                                                                                                                                                                                    
> sage: J = A.ideal(x^2)                                                                                                                                                                                      
> sage: Q1 = A.quotient(I)                                                                                                                                                                                    
> sage: Q2 = A.quotient(J)                                                                                                                                                                                    
> sage: Q1.gens()[0]*Q1.gens()[1] # x*y                                                                                                                                                                       
> z
> sage: Q2.gens()[0]^2 # x^2                                                                                                                                                                               
> 0
> sage: Q2.gens()[0]^2 == 0  
> True
> }}}
> 
> I am running sage 9.4.beta5 so I'm not sure if it is fixed there or what is going on. On the other hand, the exterior algebra still has the same behavior as in the description.

I was using my implementation in #32272. The class `GCAlgebra` uses a non-generic quotient.



---

archive/issue_comments_457657.json:
```json
{
    "body": "We should not remove `_richcmp_` either. Equality check is generally not mathematical equality. Unfortunately Python does not allow `==` (and similar) to return a `Unknown`, which would technically be the way out (yet knowing when to it is unknown or not is a hard problem too). Note that is an assumption that is not generically satisfied, so you should not expect the quotient ring to fully behave correctly. Rather than spending time trying to block users in cases when we haven't implemented (or don't have general answers) that will potentially break code in the wild, we should spend time implementing the cases we do know.\n\nFor example, the exterior algebra can use:\n\n- https://www.math.auckland.ac.nz/~slinko/Supervision/DominicSearlesMastersThesis.pdf\n- https://link.springer.com/article/10.1007/BF00244487\n\nIn some sense, all you need to do is linear algebra since the exterior algebra is finite dimensional. Compute a basis for the ideal as a subspace (again, finite dimensional), and then take the quotient as vector spaces. Of course, this is not likely to be fast, but it works with very minimal code needed to be added/changed.\n\nNote that in the second paper, the exterior polynomial algebra is the ungraded version of a graded commutative algebra. So that gives a Gr\u00f6bner basis algorithm in that case if we also rewrite the GCA code with a more basic implementation.",
    "created_at": "2021-07-30T05:32:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/32054",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/32054#issuecomment-457657",
    "user": "@tscrim"
}
```

We should not remove `_richcmp_` either. Equality check is generally not mathematical equality. Unfortunately Python does not allow `==` (and similar) to return a `Unknown`, which would technically be the way out (yet knowing when to it is unknown or not is a hard problem too). Note that is an assumption that is not generically satisfied, so you should not expect the quotient ring to fully behave correctly. Rather than spending time trying to block users in cases when we haven't implemented (or don't have general answers) that will potentially break code in the wild, we should spend time implementing the cases we do know.

For example, the exterior algebra can use:

- https://www.math.auckland.ac.nz/~slinko/Supervision/DominicSearlesMastersThesis.pdf
- https://link.springer.com/article/10.1007/BF00244487

In some sense, all you need to do is linear algebra since the exterior algebra is finite dimensional. Compute a basis for the ideal as a subspace (again, finite dimensional), and then take the quotient as vector spaces. Of course, this is not likely to be fast, but it works with very minimal code needed to be added/changed.

Note that in the second paper, the exterior polynomial algebra is the ungraded version of a graded commutative algebra. So that gives a Gröbner basis algorithm in that case if we also rewrite the GCA code with a more basic implementation.
