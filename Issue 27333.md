# Issue 27333: Minimal weight cycle basis Implementation

archive/issues_027333.json:
```json
{
    "body": "Assignee: @rajat1433\n\nCC:  @dcoudert\n\nKeywords: cycle_basis, shortest_paths\n\nMinimal weight cycle basis is a cycle basis for which the total weight of all the cycles is minimum.\n\nIts applications are as follows:\n- The minimum weight cycle basis of a nearest neighbor graph of points sampled from a three-dimensional surface can be used to obtain a reconstruction of the surface.\n\n- In cheminformatics, the minimal cycle basis of a molecular graph is referred to as the Smallest Set of Smallest Rings (SSSR).\n\nThis ticket will aim at implementing this algorithm.\n\nIssue created by migration from https://trac.sagemath.org/ticket/27570\n\n",
    "closed_at": "2019-04-27T17:44:19Z",
    "created_at": "2019-03-30T13:03:17Z",
    "labels": [
        "component: graph theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.8",
    "title": "Minimal weight cycle basis Implementation",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27333",
    "user": "https://github.com/rajat1433"
}
```
Assignee: @rajat1433

CC:  @dcoudert

Keywords: cycle_basis, shortest_paths

Minimal weight cycle basis is a cycle basis for which the total weight of all the cycles is minimum.

Its applications are as follows:
- The minimum weight cycle basis of a nearest neighbor graph of points sampled from a three-dimensional surface can be used to obtain a reconstruction of the surface.

- In cheminformatics, the minimal cycle basis of a molecular graph is referred to as the Smallest Set of Smallest Rings (SSSR).

This ticket will aim at implementing this algorithm.

Issue created by migration from https://trac.sagemath.org/ticket/27570





---

archive/issue_comments_384881.json:
```json
{
    "body": "minimum weight cycle basis in a graph with m edges and n vertices can be found in polynomial time using https://link.springer.com/article/10.1007/s00453-007-9064-z. \n\nhttps://arxiv.org/pdf/0912.1208.pdf\n\nI am going through these algorithms before implementing it.\n\nThese work for undirected(weighted/non-weighted) graphs without multiedges.",
    "created_at": "2019-03-30T13:05:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384881",
    "user": "https://github.com/rajat1433"
}
```

minimum weight cycle basis in a graph with m edges and n vertices can be found in polynomial time using https://link.springer.com/article/10.1007/s00453-007-9064-z. 

https://arxiv.org/pdf/0912.1208.pdf

I am going through these algorithms before implementing it.

These work for undirected(weighted/non-weighted) graphs without multiedges.



---

archive/issue_comments_384882.json:
```json
{
    "body": "Set assignee to @rajat1433.",
    "created_at": "2019-04-05T03:32:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384882",
    "user": "https://github.com/rajat1433"
}
```

Set assignee to @rajat1433.



---

archive/issue_comments_384883.json:
```json
{
    "body": "I had a doubt regarding what should we add in examples when getting deprecation warning from external package. like below:\n\n```\nsage: g.minimum_cycle_basis(by_weight=True, algorithm=\"NetworkX\")\n\nDeprecationWarning: connected_component_subgraphs is deprecated and will be removedin 2.2. Use (G.subgraph(c).copy() for c in connected_components(G))\n            [[1, 2, 3, 4], [1, 2, 3], [5, 6, 7]]\n```\n should we skip these examples in examples section?",
    "created_at": "2019-04-07T15:15:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384883",
    "user": "https://github.com/rajat1433"
}
```

I had a doubt regarding what should we add in examples when getting deprecation warning from external package. like below:

```
sage: g.minimum_cycle_basis(by_weight=True, algorithm="NetworkX")

DeprecationWarning: connected_component_subgraphs is deprecated and will be removedin 2.2. Use (G.subgraph(c).copy() for c in connected_components(G))
            [[1, 2, 3, 4], [1, 2, 3], [5, 6, 7]]
```
 should we skip these examples in examples section?



---

archive/issue_comments_384884.json:
```json
{
    "body": "Skip this example. This is an upstream issue as we use networkx 2.2.",
    "created_at": "2019-04-07T16:56:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384884",
    "user": "https://github.com/dcoudert"
}
```

Skip this example. This is an upstream issue as we use networkx 2.2.



---

archive/issue_comments_384885.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2019-04-09T14:26:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384885",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_384886.json:
```json
{
    "body": "I have added minimum cycle basis cython implementation and for python implementation used networkx's min_cycle_basis method. The algorithm's complexity is O(m<sup>2</sup>)n and cython implementation is quite faster than NetwrokX's python as I have tested.",
    "created_at": "2019-04-09T14:31:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384886",
    "user": "https://github.com/rajat1433"
}
```

I have added minimum cycle basis cython implementation and for python implementation used networkx's min_cycle_basis method. The algorithm's complexity is O(m<sup>2</sup>)n and cython implementation is quite faster than NetwrokX's python as I have tested.



---

archive/issue_comments_384887.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-09T14:38:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384887",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384888.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-04-09T18:46:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384888",
    "user": "https://github.com/rajat1433"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_384889.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-10T03:56:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384889",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384890.json:
```json
{
    "body": "A first round of comments. \n\n`min_cycle_basis`:\n- remove input parameter \"algorithm\"\n\n- in many methods, we are using a mapping from integers to vertices. This is simply `cdef list int_to_vertex = list(G)`. The reverse mapping is then `cdef dict vertex_to_int = {u: i for i, u in enumerate(int_to_vertex)}`.\n\n- To simplify and speed up your code, you should either make a copy of `self` in which vertices are relabeled in `0..n-1`, or at least relabel the edges in `edgelist` using integers. The only step were you need the real vertex ids is before returning the result.\n\n- You could work with edges as frozenset directly\n\n- don't import `from sage.graphs.base.boost_graph import johnson_shortest_paths` inside a loop\n\n\n\n`minimum_cycle_basis`:\n- I don't see the need for creating a new method here. You could add parameters to `cycle_basis` to make it return a minimum cycle basis when the user asked for it ?",
    "created_at": "2019-04-10T09:43:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384890",
    "user": "https://github.com/dcoudert"
}
```

A first round of comments. 

`min_cycle_basis`:
- remove input parameter "algorithm"

- in many methods, we are using a mapping from integers to vertices. This is simply `cdef list int_to_vertex = list(G)`. The reverse mapping is then `cdef dict vertex_to_int = {u: i for i, u in enumerate(int_to_vertex)}`.

- To simplify and speed up your code, you should either make a copy of `self` in which vertices are relabeled in `0..n-1`, or at least relabel the edges in `edgelist` using integers. The only step were you need the real vertex ids is before returning the result.

- You could work with edges as frozenset directly

- don't import `from sage.graphs.base.boost_graph import johnson_shortest_paths` inside a loop



`minimum_cycle_basis`:
- I don't see the need for creating a new method here. You could add parameters to `cycle_basis` to make it return a minimum cycle basis when the user asked for it ?



---

archive/issue_comments_384891.json:
```json
{
    "body": "Replying to [comment:10 dcoudert]:\n\n> - in many methods, we are using a mapping from integers to vertices. This is simply `cdef list int_to_vertex = list(G)`. The reverse mapping is then `cdef dict vertex_to_int = {u: i for i, u in enumerate(int_to_vertex)}`.\n\n\nIt seems SparseGraphBackend object is not iterable so we cant do list(self)\n\n[UPDATE]\nSo I did this\n\n```\n        cdef list int_to_vertex = list(self.iterator_verts(None))\n        cdef dict vertex_to_int = {u: i for i, u in enumerate(int_to_vertex)}\n```\n\n```\n/home/rajat/new_version/sage-8.7.beta6/local/lib/python2.7/site-packages/sage/graphs/base/c_graph.pyx in sage.graphs.base.c_graph.CGraphBackend.min_cycle_basis (build/cythonized/sage/graphs/base/c_graph.cpp:21478)()\n   2457         l = len(edges_complement)\n   2458         cdef list orth_set = [set([e]) for e in edges_complement]\n-> 2459         cdef list int_to_vertex = list(self)\n   2460         cdef dict vertex_to_int = {u: i for i, u in enumerate(int_to_vertex)}\n   2461         if not by_weight:\n\nTypeError: 'sage.graphs.base.sparse_graph.SparseGraphBackend' object is not iterable\n\n```\n\n\n\n\n> - You could work with edges as frozenset directly\n> \n\n\nCan you elaborate on it? I didn't understand.",
    "created_at": "2019-04-11T04:43:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384891",
    "user": "https://github.com/rajat1433"
}
```

Replying to [comment:10 dcoudert]:

> - in many methods, we are using a mapping from integers to vertices. This is simply `cdef list int_to_vertex = list(G)`. The reverse mapping is then `cdef dict vertex_to_int = {u: i for i, u in enumerate(int_to_vertex)}`.


It seems SparseGraphBackend object is not iterable so we cant do list(self)

[UPDATE]
So I did this

```
        cdef list int_to_vertex = list(self.iterator_verts(None))
        cdef dict vertex_to_int = {u: i for i, u in enumerate(int_to_vertex)}
```

```
/home/rajat/new_version/sage-8.7.beta6/local/lib/python2.7/site-packages/sage/graphs/base/c_graph.pyx in sage.graphs.base.c_graph.CGraphBackend.min_cycle_basis (build/cythonized/sage/graphs/base/c_graph.cpp:21478)()
   2457         l = len(edges_complement)
   2458         cdef list orth_set = [set([e]) for e in edges_complement]
-> 2459         cdef list int_to_vertex = list(self)
   2460         cdef dict vertex_to_int = {u: i for i, u in enumerate(int_to_vertex)}
   2461         if not by_weight:

TypeError: 'sage.graphs.base.sparse_graph.SparseGraphBackend' object is not iterable

```




> - You could work with edges as frozenset directly
> 


Can you elaborate on it? I didn't understand.



---

archive/issue_comments_384892.json:
```json
{
    "body": "Replying to [comment:10 dcoudert]:\n\n> \n> - To simplify and speed up your code, you should either make a copy of `self` in which vertices are relabeled in `0..n-1`, or at least relabel the edges in `edgelist` using integers. The only step were you need the real vertex ids is before returning the result.\n\n\nI think this can be done and will improve dictionary look up time.",
    "created_at": "2019-04-11T05:06:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384892",
    "user": "https://github.com/rajat1433"
}
```

Replying to [comment:10 dcoudert]:

> 
> - To simplify and speed up your code, you should either make a copy of `self` in which vertices are relabeled in `0..n-1`, or at least relabel the edges in `edgelist` using integers. The only step were you need the real vertex ids is before returning the result.


I think this can be done and will improve dictionary look up time.



---

archive/issue_comments_384893.json:
```json
{
    "body": "The parameters of cycle_basis and minimum_cycle_basis are quite different as in cyclebasis we just specify the output as vertices or edges but in min_cycle_basis we have algorithm parameter and weight parameters too. If they are merged it will mess a bit.(just my opinion). But if it seems better than I can do it.",
    "created_at": "2019-04-12T04:40:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384893",
    "user": "https://github.com/rajat1433"
}
```

The parameters of cycle_basis and minimum_cycle_basis are quite different as in cyclebasis we just specify the output as vertices or edges but in min_cycle_basis we have algorithm parameter and weight parameters too. If they are merged it will mess a bit.(just my opinion). But if it seems better than I can do it.



---

archive/issue_comments_384894.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-12T04:44:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384894",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384895.json:
```json
{
    "body": "I agree with your arguments.\n\nIn your code, you code document a bit the type of graph you build, and so why you use `n+j` or `n + vidx`.\n\nI'm a bit worried about the following lines because I don't know what you expect\n\n```\n+            new_cycle = {frozenset((int_to_vertex[u], int_to_vertex[v])) for u, v in edges}\n+            cycle_basis.append(list(set().union(*new_cycle)))\n```\nWith such operation, you loose the order of the vertices, so I don't see how you get a cycle.\n\nI think the following is better, but it is only because I'm not sure how list manipulation is really done for sure instructions.\n\n```diff\n-            orth_set[i + 1:] = [o ^ base if len(o & new_cycle) % 2 else o for o in orth_set[i + 1:]]\n+            for j in range(i + 1, len(orth_set)):\n+                orth_set[j] = o ^ base if len(o & new_cycle) % 2 else o\n```\n\nalso\n\n```diff\n+                edges_c = [frozenset(e) for e in comp.edges(labels=False) if e not in edges_s]\n+                edges_c = [frozenset(e) for e in comp.edge_iterator(labels=False) if e not in edges_s]\n```\n\nWhat if the input graph has loops ? If not accepted, then use `self._scream_if_not_simple()`.",
    "created_at": "2019-04-12T11:06:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384895",
    "user": "https://github.com/dcoudert"
}
```

I agree with your arguments.

In your code, you code document a bit the type of graph you build, and so why you use `n+j` or `n + vidx`.

I'm a bit worried about the following lines because I don't know what you expect

```
+            new_cycle = {frozenset((int_to_vertex[u], int_to_vertex[v])) for u, v in edges}
+            cycle_basis.append(list(set().union(*new_cycle)))
```
With such operation, you loose the order of the vertices, so I don't see how you get a cycle.

I think the following is better, but it is only because I'm not sure how list manipulation is really done for sure instructions.

```diff
-            orth_set[i + 1:] = [o ^ base if len(o & new_cycle) % 2 else o for o in orth_set[i + 1:]]
+            for j in range(i + 1, len(orth_set)):
+                orth_set[j] = o ^ base if len(o & new_cycle) % 2 else o
```

also

```diff
+                edges_c = [frozenset(e) for e in comp.edges(labels=False) if e not in edges_s]
+                edges_c = [frozenset(e) for e in comp.edge_iterator(labels=False) if e not in edges_s]
```

What if the input graph has loops ? If not accepted, then use `self._scream_if_not_simple()`.



---

archive/issue_comments_384896.json:
```json
{
    "body": "I forgot to tell/add that our algorithm returns only vertices in the cycle not necessarily in the order of cycle. This is a kind of limitation of the algorithm as given in https://link.springer.com/article/10.1007/s00453-007-9064-z. But the time complexity we get is good. I have added the following text now:\n\n```\nA list of cycle lists is returned. Each cycle list is a list of vertices\nwhich forms a cycle in G. Note that the vertices are not necessarily\nreturned in the order by which they appear in the cycle\n```\n\nSo now \n\n```\n+            new_cycle = {frozenset((int_to_vertex[u], int_to_vertex[v])) for u, v in edges}\n+            cycle_basis.append(list(set().union(*new_cycle)))\n```\nthis should not be our worry :) as the vertices are returned here in sorted order.",
    "created_at": "2019-04-12T14:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384896",
    "user": "https://github.com/rajat1433"
}
```

I forgot to tell/add that our algorithm returns only vertices in the cycle not necessarily in the order of cycle. This is a kind of limitation of the algorithm as given in https://link.springer.com/article/10.1007/s00453-007-9064-z. But the time complexity we get is good. I have added the following text now:

```
A list of cycle lists is returned. Each cycle list is a list of vertices
which forms a cycle in G. Note that the vertices are not necessarily
returned in the order by which they appear in the cycle
```

So now 

```
+            new_cycle = {frozenset((int_to_vertex[u], int_to_vertex[v])) for u, v in edges}
+            cycle_basis.append(list(set().union(*new_cycle)))
```
this should not be our worry :) as the vertices are returned here in sorted order.



---

archive/issue_comments_384897.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-12T14:32:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384897",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384898.json:
```json
{
    "body": "**min_cycle_basis**\n\n```diff\n-        A list of cycle lists is returned. Each cycle list is a list of vertices\n-        which forms a cycle in G. Note that the vertices are not necessarily\n-        returned in the order by which they appear in the cycle\n+        A cycle basis is a list of cycles (list of vertices forming a cycle) of\n+        `G`. Note that the vertices are not necessarily returned in the order\n+        in which they appear in the cycle.\n```\n\n```diff\n-        Minimum weight cycle basis is the cycle basis for which the total weight\n-        (length for unweighted graphs) of all the cycles is minimum.\n+        A minimum weight cycle basis is a cycle basis that minimizes the sum of\n+        the weights (length for unweighted graphs) of its cycles.\n```\n\n```diff\n-        - ``edges_complement`` -- list (default: ``None``); a list of edges\n-          present in the ``self`` but not in present in a particular spanning\n-          tree.\n+        - ``edges_complement`` -- list (default: ``None``); list of edges of\n+          ``self`` without the edges of a particular spanning tree.\n```\n\n```diff\n-            # Add 2 copies of each edge in self to T. Cross edge is added if\n-            # edge is in orth otherwise in-plane edge is added\n+            # For each edge in self, add 2 edges to G: \"cross\" edges if\n+            # edge is in orth otherwise \"in-plane\" edges\n```\n\n\nNo need for `list(..)`\n\n```diff\n-            for edge in list(zip(min_path_nodes[:-1], min_path_nodes[1:])):\n+            for edge in zip(min_path_nodes[:-1], min_path_nodes[1:]):\n```\n\nHere an alternative is to use `chain`. You need to add before the loop `from itertools import chain`. I don't know if it's faster...\n\n```diff\n             new_cycle = {frozenset((int_to_vertex[u], int_to_vertex[v])) for u, v in edges}\n-            cycle_basis.append(list(set().union(*new_cycle)))\n+            cycle_basis.append(list(set(chain(*new_cycle))))\n```\n\n\n**minimum_cycle_basis**\n- same comments than above for improving the text\n- don't use this as plain text `minimum_cycle_basis` in documentation.\n\n```diff\n-          * If ``algorithm = \"NetworkX\"``, a networkx implementation of the\n-            minimum_cycle_basis algorithm is used\n-\n-          * If ``algorithm = None``, then cython implementation of the\n-            minimum_cycle_basis algorithm is used\n+          * If ``algorithm = \"NetworkX\"``, use networkx implementation\n+\n+          * If ``algorithm = None``, use Sage Cython implementation\n```\n- make `edge_s` a set to speed up construction of `edges_c`\n\n```diff\n+                edges_s = [(a, b) for a, b, c in sp_edges]\n+                edges_s = set((a, b) for a, b, c in sp_edges)\n```\n- `compliment` -> `complement`\n- In fact, this is better\n\n```diff\n-                # compliment of the edges of the spanning tree with respect\n-                # to self\n+                # Edges of self that are not in the spanning tree\n```",
    "created_at": "2019-04-14T16:38:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384898",
    "user": "https://github.com/dcoudert"
}
```

**min_cycle_basis**

```diff
-        A list of cycle lists is returned. Each cycle list is a list of vertices
-        which forms a cycle in G. Note that the vertices are not necessarily
-        returned in the order by which they appear in the cycle
+        A cycle basis is a list of cycles (list of vertices forming a cycle) of
+        `G`. Note that the vertices are not necessarily returned in the order
+        in which they appear in the cycle.
```

```diff
-        Minimum weight cycle basis is the cycle basis for which the total weight
-        (length for unweighted graphs) of all the cycles is minimum.
+        A minimum weight cycle basis is a cycle basis that minimizes the sum of
+        the weights (length for unweighted graphs) of its cycles.
```

```diff
-        - ``edges_complement`` -- list (default: ``None``); a list of edges
-          present in the ``self`` but not in present in a particular spanning
-          tree.
+        - ``edges_complement`` -- list (default: ``None``); list of edges of
+          ``self`` without the edges of a particular spanning tree.
```

```diff
-            # Add 2 copies of each edge in self to T. Cross edge is added if
-            # edge is in orth otherwise in-plane edge is added
+            # For each edge in self, add 2 edges to G: "cross" edges if
+            # edge is in orth otherwise "in-plane" edges
```


No need for `list(..)`

```diff
-            for edge in list(zip(min_path_nodes[:-1], min_path_nodes[1:])):
+            for edge in zip(min_path_nodes[:-1], min_path_nodes[1:]):
```

Here an alternative is to use `chain`. You need to add before the loop `from itertools import chain`. I don't know if it's faster...

```diff
             new_cycle = {frozenset((int_to_vertex[u], int_to_vertex[v])) for u, v in edges}
-            cycle_basis.append(list(set().union(*new_cycle)))
+            cycle_basis.append(list(set(chain(*new_cycle))))
```


**minimum_cycle_basis**
- same comments than above for improving the text
- don't use this as plain text `minimum_cycle_basis` in documentation.

```diff
-          * If ``algorithm = "NetworkX"``, a networkx implementation of the
-            minimum_cycle_basis algorithm is used
-
-          * If ``algorithm = None``, then cython implementation of the
-            minimum_cycle_basis algorithm is used
+          * If ``algorithm = "NetworkX"``, use networkx implementation
+
+          * If ``algorithm = None``, use Sage Cython implementation
```
- make `edge_s` a set to speed up construction of `edges_c`

```diff
+                edges_s = [(a, b) for a, b, c in sp_edges]
+                edges_s = set((a, b) for a, b, c in sp_edges)
```
- `compliment` -> `complement`
- In fact, this is better

```diff
-                # compliment of the edges of the spanning tree with respect
-                # to self
+                # Edges of self that are not in the spanning tree
```



---

archive/issue_comments_384899.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-15T08:43:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384899",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384900.json:
```json
{
    "body": "I think union and chain works differently and in the present case union seems correct as it collects all the vertices of different edges. chain might result in repetition of vertices.",
    "created_at": "2019-04-15T08:55:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384900",
    "user": "https://github.com/rajat1433"
}
```

I think union and chain works differently and in the present case union seems correct as it collects all the vertices of different edges. chain might result in repetition of vertices.



---

archive/issue_comments_384901.json:
```json
{
    "body": "Replying to [comment:20 gh-rajat1433]:\n> I think union and chain works differently and in the present case union seems correct as it collects all the vertices of different edges. chain might result in repetition of vertices.\n\nno, the behavior is the same here, but as I wrote, I'm not sure it's better here, so let it as is.",
    "created_at": "2019-04-15T09:01:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384901",
    "user": "https://github.com/dcoudert"
}
```

Replying to [comment:20 gh-rajat1433]:
> I think union and chain works differently and in the present case union seems correct as it collects all the vertices of different edges. chain might result in repetition of vertices.

no, the behavior is the same here, but as I wrote, I'm not sure it's better here, so let it as is.



---

archive/issue_comments_384902.json:
```json
{
    "body": "Yes you are right I was misunderstanding the definition of chain.\n\n\n```\nsage: n = {(1,2),(3,4),(1,4),(5,6),(6,8),(6,4)}\nsage: %timeit list(set().union(*n))\nThe slowest run took 11.81 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000000 loops, best of 3: 1.53 \u00b5s per loop\nsage: %timeit list(set(chain(*n)))\nThe slowest run took 6.35 times longer than the fastest. This could mean that an intermediate result is being cached.\n1000000 loops, best of 3: 1.58 \u00b5s per loop\n\n```\n\nAlthough not much difference but union is slightly more better than chain here.",
    "created_at": "2019-04-15T09:13:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384902",
    "user": "https://github.com/rajat1433"
}
```

Yes you are right I was misunderstanding the definition of chain.


```
sage: n = {(1,2),(3,4),(1,4),(5,6),(6,8),(6,4)}
sage: %timeit list(set().union(*n))
The slowest run took 11.81 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.53 µs per loop
sage: %timeit list(set(chain(*n)))
The slowest run took 6.35 times longer than the fastest. This could mean that an intermediate result is being cached.
1000000 loops, best of 3: 1.58 µs per loop

```

Although not much difference but union is slightly more better than chain here.



---

archive/issue_comments_384903.json:
```json
{
    "body": "- ``self`` -> ```self```  (twice)\n\n- what happen when `edges_complement` is None ?\n\n- you should document the fact that in `edges_complement`, edges are pairs without labels, and in fact frozensets. In fact, it might be better to compute `edges_complement` inside `min_cycle_basis` to avoid errors in the input.\n\n- a possible improvement could be to do\n\n```\ncdef list edgelist = list(self.iterator_unsorted_edges(list(self.iterator_verts(None)), True))\ncdef list edgelist_int = [(vertex_to_int[e[0]], vertex_to_int[e[1], weight_function(e)) for e in edgelist]\ncdef list orth_set = [set([(vertex_to_int[e[0]], vertex_to_int[e[1])]) for e in edges_complement]\n```\n  this way, inside the main loops you work only with integers and precomputed weights. Finally, you reconstruct the correct cycle basis before returning it.\n\n  You can then do `for e in edgelist:` -> `for uidx, vidx, edge_w in edgelist_int:`\n\n  Think about it.",
    "created_at": "2019-04-15T09:23:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384903",
    "user": "https://github.com/dcoudert"
}
```

- ``self`` -> ```self```  (twice)

- what happen when `edges_complement` is None ?

- you should document the fact that in `edges_complement`, edges are pairs without labels, and in fact frozensets. In fact, it might be better to compute `edges_complement` inside `min_cycle_basis` to avoid errors in the input.

- a possible improvement could be to do

```
cdef list edgelist = list(self.iterator_unsorted_edges(list(self.iterator_verts(None)), True))
cdef list edgelist_int = [(vertex_to_int[e[0]], vertex_to_int[e[1], weight_function(e)) for e in edgelist]
cdef list orth_set = [set([(vertex_to_int[e[0]], vertex_to_int[e[1])]) for e in edges_complement]
```
  this way, inside the main loops you work only with integers and precomputed weights. Finally, you reconstruct the correct cycle basis before returning it.

  You can then do `for e in edgelist:` -> `for uidx, vidx, edge_w in edgelist_int:`

  Think about it.



---

archive/issue_comments_384904.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-15T12:10:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384904",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384905.json:
```json
{
    "body": "```\ncdef list orth_set = [set([(vertex_to_int[e[0]], vertex_to_int[e[1])]) for e in edges_complement]\n```\nthis will throw an error as edges_complement being a frozenset can't be indexed.\n\n**\nwhat happen when edges_complement is None ?** \n\nIt should return an empty list. I added it in this commit to avoid process further.\n\nI tried doing \n\n```\ncdef list orth_set = [set([(vertex_to_int[e[0]], vertex_to_int[e[1])]) for e in edges_complement]\n```\n\nbefore converting to frozenset but got some unexpected errors. Will see if it can be added.",
    "created_at": "2019-04-15T12:13:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384905",
    "user": "https://github.com/rajat1433"
}
```

```
cdef list orth_set = [set([(vertex_to_int[e[0]], vertex_to_int[e[1])]) for e in edges_complement]
```
this will throw an error as edges_complement being a frozenset can't be indexed.

**
what happen when edges_complement is None ?** 

It should return an empty list. I added it in this commit to avoid process further.

I tried doing 

```
cdef list orth_set = [set([(vertex_to_int[e[0]], vertex_to_int[e[1])]) for e in edges_complement]
```

before converting to frozenset but got some unexpected errors. Will see if it can be added.



---

archive/issue_comments_384906.json:
```json
{
    "body": "Replying to [comment:25 gh-rajat1433]:\n> \n> \n> ```\n> cdef list orth_set = [set([(vertex_to_int[e[0]], vertex_to_int[e[1])]) for e in edges_complement]\n> ```\n> this will throw an error as edges_complement being a frozenset can't be indexed.\n\n\nThen \n\n```\ncdef list orth_set = [set([(vertex_to_int[u], vertex_to_int[v])]) for u, v in edges_complement]\n```",
    "created_at": "2019-04-15T13:58:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384906",
    "user": "https://github.com/dcoudert"
}
```

Replying to [comment:25 gh-rajat1433]:
> 
> 
> ```
> cdef list orth_set = [set([(vertex_to_int[e[0]], vertex_to_int[e[1])]) for e in edges_complement]
> ```
> this will throw an error as edges_complement being a frozenset can't be indexed.


Then 

```
cdef list orth_set = [set([(vertex_to_int[u], vertex_to_int[v])]) for u, v in edges_complement]
```



---

archive/issue_comments_384907.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-17T19:17:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384907",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384908.json:
```json
{
    "body": "Replying to [comment:26 dcoudert]:\n\n> Then \n> \n> ```\n> cdef list orth_set = [set([(vertex_to_int[u], vertex_to_int[v])]) for u, v in edges_complement]\n> ```\n> \n\n\nWe have \n\n```\n            new_cycle = {frozenset((int_to_vertex[u], int_to_vertex[v])) for u, v in edges}\n            cycle_basis.append(list(set().union(*new_cycle)))\n            # updating orth_set so that i+1, i+2, ...th elements are orthogonal\n            # to the newly found cycle\n            base = orth_set[i]\n            for j in range(i + 1, len(orth_set)):\n                if len(**orth_set[j] & new_cycle**) % 2:\n                    orth_set[j] = orth_set[j] ^ base\n```\n\nIn new_cycle we have original vertices so we can't convert vertex to int in orth_set before as they have to be bitwise and with new_cycle as indicated above.",
    "created_at": "2019-04-18T05:02:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384908",
    "user": "https://github.com/rajat1433"
}
```

Replying to [comment:26 dcoudert]:

> Then 
> 
> ```
> cdef list orth_set = [set([(vertex_to_int[u], vertex_to_int[v])]) for u, v in edges_complement]
> ```
> 


We have 

```
            new_cycle = {frozenset((int_to_vertex[u], int_to_vertex[v])) for u, v in edges}
            cycle_basis.append(list(set().union(*new_cycle)))
            # updating orth_set so that i+1, i+2, ...th elements are orthogonal
            # to the newly found cycle
            base = orth_set[i]
            for j in range(i + 1, len(orth_set)):
                if len(**orth_set[j] & new_cycle**) % 2:
                    orth_set[j] = orth_set[j] ^ base
```

In new_cycle we have original vertices so we can't convert vertex to int in orth_set before as they have to be bitwise and with new_cycle as indicated above.



---

archive/issue_comments_384909.json:
```json
{
    "body": "consider this code\n\n```\n        if not edges_complement:\n            return []\n        if not by_weight:\n            def weight_function(e):\n                return 1\n        from sage.graphs.base.boost_graph import johnson_shortest_paths\n        from sage.graphs.graph import Graph\n\n        cdef int u_int, v_int, i, j\n        cdef object u, v\n        cdef list int_to_vertex = list(self.iterator_verts(None))\n        cdef dict vertex_to_int = {u: u_int for u_int, u in enumerate(int_to_vertex)}\n        cdef list edgelist = [(vertex_to_int[e[0]], vertex_to_int[e[1]], weight_function(e))\n                                  for e in self.iterator_unsorted_edges(int_to_vertex, True)]\n        edges_complement = [frozenset((vertex_to_int[u], vertex_to_int[v])) for u, v in edges_complement]\n        cdef int l = len(edges_complement)\n        cdef list orth_set = [set([e]) for e in edges_complement]\n        cdef int n = self.num_verts()\n        cdef list min_path_nodes\n        cdef list min_path\n        cdef dict all_pair_shortest_pathlens\n        cdef dict cross_paths_lens\n        cdef list cycle_basis = []\n        cdef set base\n\n        for i in range(l):\n            base = orth_set[i]\n            G = Graph(weighted=True)\n            # For each edge in self, add 2 edges to G: \"cross\" edges if edge is\n            # in base, otherwise \"in-plane\" edges\n            for u_int, v_int, edge_w in edgelist:\n                # mapping the nodes in self from 0 to n-1\n                if frozenset((u_int, v_int)) in base:\n                    G.add_edge(u_int, n + v_int, edge_w)\n                    G.add_edge(n + u_int, v_int, edge_w)\n                else:\n                    G.add_edge(u_int, v_int, edge_w)\n                    G.add_edge(n + u_int, n + v_int, edge_w)\n\n            all_pair_shortest_pathlens = johnson_shortest_paths(G)\n            cross_paths_lens = {j: all_pair_shortest_pathlens[j][n + j] for j in range(n)}\n            u_int = min(cross_paths_lens, key=cross_paths_lens.get)\n            v_int = n + u_int\n            min_path = G._backend.bidirectional_dijkstra(u_int, v_int, distance_flag=False)\n\n            # Mapping the nodes in G to nodes in self\n            min_path_nodes = [u_int if u_int < n else u_int - n for u_int in min_path]\n\n            # removal of edges occuring even number of times\n            edges = set()\n            for edge in zip(min_path_nodes[:-1], min_path_nodes[1:]):\n                edges ^= {edge}\n            new_cycle = {frozenset(e) for e in edges}\n            cycle_basis.append([int_to_vertex[u_int] for u_int in set().union(*new_cycle)])\n            # updating orth_set so that i+1, i+2, ...th elements are orthogonal\n            # to the newly found cycle\n            for j in range(i + 1, l):\n                if len(orth_set[j] & new_cycle) % 2:\n                    orth_set[j] = orth_set[j] ^ base\n        return cycle_basis\n```\n\nNow, is `c_graph.pyx` the best place for this code ? Somehow, instead of building a `Graph`, you could directly build a boost graph and call corresponding methods on it. Plus, with #27518, we will be able to get the predecessor matrix, thus avoiding an extra call to Dijkstra.",
    "created_at": "2019-04-20T08:58:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384909",
    "user": "https://github.com/dcoudert"
}
```

consider this code

```
        if not edges_complement:
            return []
        if not by_weight:
            def weight_function(e):
                return 1
        from sage.graphs.base.boost_graph import johnson_shortest_paths
        from sage.graphs.graph import Graph

        cdef int u_int, v_int, i, j
        cdef object u, v
        cdef list int_to_vertex = list(self.iterator_verts(None))
        cdef dict vertex_to_int = {u: u_int for u_int, u in enumerate(int_to_vertex)}
        cdef list edgelist = [(vertex_to_int[e[0]], vertex_to_int[e[1]], weight_function(e))
                                  for e in self.iterator_unsorted_edges(int_to_vertex, True)]
        edges_complement = [frozenset((vertex_to_int[u], vertex_to_int[v])) for u, v in edges_complement]
        cdef int l = len(edges_complement)
        cdef list orth_set = [set([e]) for e in edges_complement]
        cdef int n = self.num_verts()
        cdef list min_path_nodes
        cdef list min_path
        cdef dict all_pair_shortest_pathlens
        cdef dict cross_paths_lens
        cdef list cycle_basis = []
        cdef set base

        for i in range(l):
            base = orth_set[i]
            G = Graph(weighted=True)
            # For each edge in self, add 2 edges to G: "cross" edges if edge is
            # in base, otherwise "in-plane" edges
            for u_int, v_int, edge_w in edgelist:
                # mapping the nodes in self from 0 to n-1
                if frozenset((u_int, v_int)) in base:
                    G.add_edge(u_int, n + v_int, edge_w)
                    G.add_edge(n + u_int, v_int, edge_w)
                else:
                    G.add_edge(u_int, v_int, edge_w)
                    G.add_edge(n + u_int, n + v_int, edge_w)

            all_pair_shortest_pathlens = johnson_shortest_paths(G)
            cross_paths_lens = {j: all_pair_shortest_pathlens[j][n + j] for j in range(n)}
            u_int = min(cross_paths_lens, key=cross_paths_lens.get)
            v_int = n + u_int
            min_path = G._backend.bidirectional_dijkstra(u_int, v_int, distance_flag=False)

            # Mapping the nodes in G to nodes in self
            min_path_nodes = [u_int if u_int < n else u_int - n for u_int in min_path]

            # removal of edges occuring even number of times
            edges = set()
            for edge in zip(min_path_nodes[:-1], min_path_nodes[1:]):
                edges ^= {edge}
            new_cycle = {frozenset(e) for e in edges}
            cycle_basis.append([int_to_vertex[u_int] for u_int in set().union(*new_cycle)])
            # updating orth_set so that i+1, i+2, ...th elements are orthogonal
            # to the newly found cycle
            for j in range(i + 1, l):
                if len(orth_set[j] & new_cycle) % 2:
                    orth_set[j] = orth_set[j] ^ base
        return cycle_basis
```

Now, is `c_graph.pyx` the best place for this code ? Somehow, instead of building a `Graph`, you could directly build a boost graph and call corresponding methods on it. Plus, with #27518, we will be able to get the predecessor matrix, thus avoiding an extra call to Dijkstra.



---

archive/issue_comments_384910.json:
```json
{
    "body": "- Now, is c_graph.pyx the best place for this code ? Somehow, instead of building a Graph, you could directly build a boost graph and call corresponding methods on it. Plus, with #27518, we will be able to get the predecessor matrix, thus avoiding an extra call to Dijkstra. \n\nBut when we call any method in boost graph it takes in sage graph and converts it into a boost graph like in Johnson's algorithm for all_paths. So if we want to use directly boost graph we may have to write a new function/ modify the existing function in boost_graph.pyx for using the algorithm of boost graph on boost graph directly without expecting a sage graph. \nIf you have any other idea let me know.",
    "created_at": "2019-04-20T15:00:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384910",
    "user": "https://github.com/rajat1433"
}
```

- Now, is c_graph.pyx the best place for this code ? Somehow, instead of building a Graph, you could directly build a boost graph and call corresponding methods on it. Plus, with #27518, we will be able to get the predecessor matrix, thus avoiding an extra call to Dijkstra. 

But when we call any method in boost graph it takes in sage graph and converts it into a boost graph like in Johnson's algorithm for all_paths. So if we want to use directly boost graph we may have to write a new function/ modify the existing function in boost_graph.pyx for using the algorithm of boost graph on boost graph directly without expecting a sage graph. 
If you have any other idea let me know.



---

archive/issue_comments_384911.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-20T15:01:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384911",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384912.json:
```json
{
    "body": "New branch with an implementation using boost. The main advantage is to avoid conversion between sage graph and boost graph as we create directly the boost graph.\n\nPlease try it, test it, etc. to check if it's working correctly and also if it is better than previous version.\n\n---\nNew commits:",
    "created_at": "2019-04-20T18:11:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384912",
    "user": "https://github.com/dcoudert"
}
```

New branch with an implementation using boost. The main advantage is to avoid conversion between sage graph and boost graph as we create directly the boost graph.

Please try it, test it, etc. to check if it's working correctly and also if it is better than previous version.

---
New commits:



---

archive/issue_comments_384913.json:
```json
{
    "body": "Since the branch is in `public/`, you can modify it.",
    "created_at": "2019-04-20T18:11:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384913",
    "user": "https://github.com/dcoudert"
}
```

Since the branch is in `public/`, you can modify it.



---

archive/issue_comments_384914.json:
```json
{
    "body": "Thank You `@`dcoudert for helping me with the boost graph code. I have tested it on my system and its timing is improved as well as it is passing all the tests. So its certainly better and appropriate then the previous version.\n\nFor me it is good to go.",
    "created_at": "2019-04-21T10:20:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384914",
    "user": "https://github.com/rajat1433"
}
```

Thank You `@`dcoudert for helping me with the boost graph code. I have tested it on my system and its timing is improved as well as it is passing all the tests. So its certainly better and appropriate then the previous version.

For me it is good to go.



---

archive/issue_comments_384915.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-21T10:22:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384915",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384916.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-21T13:46:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384916",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384917.json:
```json
{
    "body": "I added some examples with networkx plus a few corrections.\n\nIn `min_cycle_basis`, can we avoid input parameter `edges_complement` and so compute a spanning tree inside the method. Is it important to have this input parameter ?",
    "created_at": "2019-04-21T13:49:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384917",
    "user": "https://github.com/dcoudert"
}
```

I added some examples with networkx plus a few corrections.

In `min_cycle_basis`, can we avoid input parameter `edges_complement` and so compute a spanning tree inside the method. Is it important to have this input parameter ?



---

archive/issue_comments_384918.json:
```json
{
    "body": "Replying to [comment:37 dcoudert]:\n> I added some examples with networkx plus a few corrections.\n> \n> In `min_cycle_basis`, can we avoid input parameter `edges_complement` and so compute a spanning tree inside the method. Is it important to have this input parameter ?\n\n\nSince we now have sage graph inside min_cycle_basis , edges_complement can now be computed inside our method , no need to pass it as a parameter.\nI will do the required change.",
    "created_at": "2019-04-21T13:58:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384918",
    "user": "https://github.com/rajat1433"
}
```

Replying to [comment:37 dcoudert]:
> I added some examples with networkx plus a few corrections.
> 
> In `min_cycle_basis`, can we avoid input parameter `edges_complement` and so compute a spanning tree inside the method. Is it important to have this input parameter ?


Since we now have sage graph inside min_cycle_basis , edges_complement can now be computed inside our method , no need to pass it as a parameter.
I will do the required change.



---

archive/issue_comments_384919.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-23T17:12:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384919",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384920.json:
```json
{
    "body": "I have removed the edges_complement parameter.\nNote that I have added\n> {{{#!diff\n\n>+cpdef w_f(e):\n>+    return 1\n\n}}}\nin boost_graph as required to get an unweighted spanning tree as cython doesn't allow lambda expressions.\nCouldn't find a better way to do it. \nIf you have any other way in mind let me know.",
    "created_at": "2019-04-23T17:16:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384920",
    "user": "https://github.com/rajat1433"
}
```

I have removed the edges_complement parameter.
Note that I have added
> {{{#!diff

>+cpdef w_f(e):
>+    return 1

}}}
in boost_graph as required to get an unweighted spanning tree as cython doesn't allow lambda expressions.
Couldn't find a better way to do it. 
If you have any other way in mind let me know.



---

archive/issue_comments_384921.json:
```json
{
    "body": "Since any spanning tree is valid, you can simply avoid adding the weight function. So we don't need to define `w_f`.",
    "created_at": "2019-04-23T18:43:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384921",
    "user": "https://github.com/dcoudert"
}
```

Since any spanning tree is valid, you can simply avoid adding the weight function. So we don't need to define `w_f`.



---

archive/issue_comments_384922.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-24T07:24:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384922",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384923.json:
```json
{
    "body": "I just tried the the patch with Python3 and we have some issues to fix. This is mostly ordering issues as for instance the order of the keys of a dictionary is not always the same in Python 2 and Python 3.\n\nFor instance, I get:\n\n```\nFile \"src/sage/graphs/generic_graph.py\", line 4679, in sage.graphs.generic_graph.GenericGraph.minimum_cycle_basis\nFailed example:\n    g.minimum_cycle_basis(by_weight=True)\nExpected:\n    [[1, 2, 3], [1, 2, 3, 4], [5, 6, 7]]\nGot:\n    [[1, 2, 3, 4], [1, 2, 3], [5, 6, 7]]\n**********************************************************************\nFile \"src/sage/graphs/generic_graph.py\", line 4681, in sage.graphs.generic_graph.GenericGraph.minimum_cycle_basis\nFailed example:\n    g.minimum_cycle_basis(by_weight=False)\nExpected:\n    [[1, 2, 3], [1, 3, 4], [5, 6, 7]]\nGot:\n    [[1, 3, 4], [1, 2, 3], [5, 6, 7]]\n```\n\n\nSo, I suggest to use `sorted(g.minimum_cycle_basis(...))` in all examples, and possibly\n`sorted(sorted(c) for c in g.minimum_cycle_basis(...))`. This last one might be too much, but...",
    "created_at": "2019-04-24T09:41:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384923",
    "user": "https://github.com/dcoudert"
}
```

I just tried the the patch with Python3 and we have some issues to fix. This is mostly ordering issues as for instance the order of the keys of a dictionary is not always the same in Python 2 and Python 3.

For instance, I get:

```
File "src/sage/graphs/generic_graph.py", line 4679, in sage.graphs.generic_graph.GenericGraph.minimum_cycle_basis
Failed example:
    g.minimum_cycle_basis(by_weight=True)
Expected:
    [[1, 2, 3], [1, 2, 3, 4], [5, 6, 7]]
Got:
    [[1, 2, 3, 4], [1, 2, 3], [5, 6, 7]]
**********************************************************************
File "src/sage/graphs/generic_graph.py", line 4681, in sage.graphs.generic_graph.GenericGraph.minimum_cycle_basis
Failed example:
    g.minimum_cycle_basis(by_weight=False)
Expected:
    [[1, 2, 3], [1, 3, 4], [5, 6, 7]]
Got:
    [[1, 3, 4], [1, 2, 3], [5, 6, 7]]
```


So, I suggest to use `sorted(g.minimum_cycle_basis(...))` in all examples, and possibly
`sorted(sorted(c) for c in g.minimum_cycle_basis(...))`. This last one might be too much, but...



---

archive/issue_comments_384924.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-04-24T11:14:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384924",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_384925.json:
```json
{
    "body": "In our examples we do not have disconnected components except in 1 in which sorted and unsorted are same, so sorted(g.minimum_cycle_basis(...)) will work",
    "created_at": "2019-04-24T11:17:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384925",
    "user": "https://github.com/rajat1433"
}
```

In our examples we do not have disconnected components except in 1 in which sorted and unsorted are same, so sorted(g.minimum_cycle_basis(...)) will work



---

archive/issue_comments_384926.json:
```json
{
    "body": "This has nothing to do with being connected or not. In all our example, we always get the vertices of a cycle sorted by label, although this is not a requirement in the code.\nInstead of `[[1, 2, 3], [1, 3, 4], [5, 6, 7]]`, we could get `[[1, 3, 2], [3, 4, 1], [5, 7, 6]]`. If we had that, then `sorted(sorted(c)...` would be necessary.\n\nWe could certainly improve further the code, but this is already quite good.",
    "created_at": "2019-04-24T11:40:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384926",
    "user": "https://github.com/dcoudert"
}
```

This has nothing to do with being connected or not. In all our example, we always get the vertices of a cycle sorted by label, although this is not a requirement in the code.
Instead of `[[1, 2, 3], [1, 3, 4], [5, 6, 7]]`, we could get `[[1, 3, 2], [3, 4, 1], [5, 7, 6]]`. If we had that, then `sorted(sorted(c)...` would be necessary.

We could certainly improve further the code, but this is already quite good.



---

archive/issue_comments_384927.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2019-04-24T11:40:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384927",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_384928.json:
```json
{
    "body": "LGTM.",
    "created_at": "2019-04-24T11:40:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384928",
    "user": "https://github.com/dcoudert"
}
```

LGTM.



---

archive/issue_events_068481.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2019-04-27T17:44:19Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27333#event-68481"
}
```



---

archive/issue_comments_384929.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2019-04-27T17:44:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27333",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27333#issuecomment-384929",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
