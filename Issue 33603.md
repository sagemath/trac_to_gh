# Issue 33603: bool(matrix) ignores exceptions raised while comparing entries

Issue created by migration from https://trac.sagemath.org/ticket/33840

Original creator: mmezzarobba

Original creation time: 2022-05-11 16:26:29

`Matrix0.get_is_zero_unsafe()`, and hence some other functions including `Matrix.__bool__()` do not propagate exceptions:

```
sage: class MyAlgebraicNumber(sage.rings.qqbar.AlgebraicNumber):
....:     def __bool__(self):
....:         raise ValueError
sage: mat = matrix(1,1,MyAlgebraicNumber(1))
sage: bool(mat)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-4-5a0f0e7947d0> in __bool__(self)
      1 class MyAlgebraicNumber(sage.rings.qqbar.AlgebraicNumber):
      2     def __bool__(self):
----> 3         raise ValueError

ValueError:
Exception ignored in: 'sage.matrix.matrix0.Matrix.get_is_zero_unsafe'
Traceback (most recent call last):
  File "<ipython-input-4-5a0f0e7947d0>", line 3, in __bool__
ValueError:
True
```



---

Comment by mmezzarobba created at 2022-05-11 16:38:26

Changing status from new to needs_review.


---

Comment by mmezzarobba created at 2022-05-11 16:38:26

New commits:


---

Comment by git created at 2022-05-16 05:19:50

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by vdelecroix created at 2022-06-16 20:16:45

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-06-17 02:37:26

I am not sure about this. It is unsafe for a reason. I think we should expect `__bool__` to not raise an exception. We do not propagate such errors for other `*_unsafe` matrix methods either. Can you provide a more explicit example or more justification rather than this artificial one (where I would say there is a bug in `MyAlgebraicNumber` instead)?


---

Comment by tscrim created at 2022-06-17 02:37:26

Changing status from positive_review to needs_info.


---

Comment by mmezzarobba created at 2022-06-17 06:37:36

Replying to [comment:4 tscrim]:
> I think we should expect `__bool__` to not raise an exception.

While I cannot think of any example in the Sage library, I don't see why `__bool__` shouldn't raise exceptions.
[This question](https://stackoverflow.com/questions/52862526/can-the-python-bool-function-raise-an-exception-for-an-invalid-argument) on stackoverflows gives a few examples where it does, including

```
sage: import numpy
sage: bool(numpy.array([[1],[2]]))
...
ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
```

and we discussed on several occasions doing something similar in Sage. My own use case was a bit similar too—a custom number class that worked with numerical approximations and could raise an exception to ask the caller to redo the whole computation with a higher working precision.

> We do not propagate such errors for other `*_unsafe` matrix methods either.

If I remember correctly, other `_unsafe` methods (or the ones I know about) are internal to the matrix implementation; they do not call methods from the base ring or its elements.


---

Comment by tscrim created at 2022-06-17 08:04:38

Replying to [comment:5 mmezzarobba]:
> Replying to [comment:4 tscrim]:
> > I think we should expect `__bool__` to not raise an exception.
> 
> While I cannot think of any example in the Sage library, I don't see why `__bool__` shouldn't raise exceptions.
> [This question](https://stackoverflow.com/questions/52862526/can-the-python-bool-function-raise-an-exception-for-an-invalid-argument) on stackoverflows gives a few examples where it does, including
> {{{
> sage: import numpy
> sage: bool(numpy.array([[1],[2]]))
> ...
> ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()
> }}}
> and we discussed on several occasions doing something similar in Sage. 

Numpy arrays are very different than a matrix, which has a (very different) mathematical meaning.

I think `__bool__` should be treated like `__eq__`, which should generally never raise an error. (I would like to see an `Unknown` type being able to return however.) My justification is `bool(x)` should be equivalent to `x == 0` for any object where `0` makes sense.

> My own use case was a bit similar too—a custom number class that worked with numerical approximations and could raise an exception to ask the caller to redo the whole computation with a higher working precision.

IMO, the correct thing do for this is to implement a subclass that handles such things as necessary. I don't think raising an exception is the correct way to deal with working around the lack of an `Unknown` return type. IMO, you should check something like `if not (x == 0) and not (x != 0):`.

Note also that `-1` is not (strictly speaking) a `bint`. So the error code is returning something of a different type or indistinguishable from `1`. Although IIRC, Cython treats `bint` as an `int` when building the C code, but I wouldn't want to rely on that.

> > We do not propagate such errors for other `*_unsafe` matrix methods either.
> 
> If I remember correctly, other `_unsafe` methods (or the ones I know about) are internal to the matrix implementation;

I would say this is internal as well, but I know you are using a different definition (see below).

> they do not call methods from the base ring or its elements.

That is not true. They can build elements from or convert data to internal data structures. For example, see `matrix_gf2e_dense.pyx`.


---

Comment by mmezzarobba created at 2022-06-17 12:45:59

Replying to [comment:6 tscrim]:
> Numpy arrays are very different than a matrix, which has a (very different) mathematical meaning.

Of course. My point was just that, in general, Python objects do have `__bool__()` methods that raise exceptions.

`get_is_zero_unsafe()` is used by _generic_ matrices, meaning it may call the `__bool__()` method of elements of arbitrary rings, including custom rings provided by the user. Why shouldn't it propagate the exceptions raised in these methods?

> I think `__bool__` should be treated like `__eq__`, which should generally never raise an error. (I would like to see an `Unknown` type being able to return however.) My justification is `bool(x)` should be equivalent to `x == 0` for any object where `0` makes sense.

I would say that is an argument _for_ propagating exceptions, since `__eq__()` methods on mathematical objects can be quite complicated. Sometimes the user will interrupt an `__eq__()` that takes too long, or it will fail to allocate memory, or...


---

Comment by mmezzarobba created at 2022-06-17 13:10:15

Replying to [comment:5 mmezzarobba]:
> While I cannot think of any example in the Sage library,

Actually I can (a very contrived one, but using only pure Sage objects):

```
sage: t = SR(matrix(2,2,range(4)))
sage: mat = matrix([[t]])
sage: bool(mat)
...
Exception ignored in: 'sage.matrix.matrix_symbolic_dense.Matrix_symbolic_dense.get_is_zero_unsafe'
...
```



---

Comment by tscrim created at 2022-06-19 02:09:03

Replying to [comment:7 mmezzarobba]:
> Replying to [comment:6 tscrim]:
> > Numpy arrays are very different than a matrix, which has a (very different) mathematical meaning.
> 
> Of course. My point was just that, in general, Python objects do have `__bool__()` methods that raise exceptions.

I can also make a Python object that can delete your entire system upon calling `__bool__()`. Saying it could happen is different than saying it should be allowed to happen.

> `get_is_zero_unsafe()` is used by _generic_ matrices, meaning it may call the `__bool__()` method of elements of arbitrary rings, including custom rings provided by the user. Why shouldn't it propagate the exceptions raised in these methods?

There is an implicit assumption that those rings are reasonable well-behaved. In particular, if you are wanting to see if something is zero, then it should be well-behaved in this regard and not raise an error on comparisons to `0`. So many things do not protect against this for good reason.

> > I think `__bool__` should be treated like `__eq__`, which should generally never raise an error. (I would like to see an `Unknown` type being able to return however.) My justification is `bool(x)` should be equivalent to `x == 0` for any object where `0` makes sense.
> 
> I would say that is an argument _for_ propagating exceptions, since `__eq__()` methods on mathematical objects can be quite complicated. Sometimes the user will interrupt an `__eq__()` that takes too long, or it will fail to allocate memory, or...

That is a fair point about the interruption. I also did a little bit more reading and the Cython docs do say `bint` is a C `int` (with a special mapping to `True/False` in Python). Thus I am now okay with this change. Although I still oppose code where `__bool__()` (and `__eq__()`) raise an error for any category where it makes sense to compare to `0`  as being anything other than a bug.For example, the comment:8 example is a bug IMO.

Raising an error on equality can cause lots of subtle problems. For example, when working with dictionaries in which you get a hash collision:

```sage
sage: M = matrix(2,2,range(4))
sage: M.set_immutable()
sage: t = SR(M)
sage: mat = matrix([[t]])
sage: mat.set_immutable()
sage: mat == 0. # boom
sage: hash(mat)
1677951251422179082
sage: d = {mat: 0}
sage: d[mat]  # fine since no hash collision
0
sage: d[hash(mat)] = 2 # boom from a hash collision that invokes an equality check
```



---

Comment by tscrim created at 2022-06-19 02:09:03

Changing status from needs_info to positive_review.


---

Comment by vbraun created at 2022-06-21 23:23:21

Resolution: fixed
