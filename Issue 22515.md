# Issue 22515: Lazy imports based on PEP 302

Issue created by migration from Trac.

Original creator: jdemeyer

Original creation time: 2017-04-04 13:23:08

Highly experimental...

try to implement lazy imports using [PEP 302](https://www.python.org/dev/peps/pep-0302/) somehow.


---

Comment by jdemeyer created at 2017-04-05 13:38:46

New commits:


---

Comment by git created at 2017-04-05 15:18:01

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by jdemeyer created at 2017-04-05 15:35:24

Changing status from new to needs_review.


---

Comment by nbruin created at 2017-04-05 19:57:19

I don't think using the context manager is thread safe, and python as a whole doesn't forbid using threads. I'm afraid we're stuck with other, less attractive syntax.

I haven't looked into this in detail, but python does have an impressive hooks etc. in the import system (hooks that have changed quite a bit in later versions of 3.* as well ...). If we want to co-opt the `import` statement syntax, perhaps we can do something using
[meta_path](https://docs.python.org/3/reference/import.html#the-meta-path) so that we can do something like

```
import lazy.sage.calculus.calculus
```



---

Comment by nbruin created at 2017-04-05 20:19:00

Different note on lazy imports: Currently we have hundreds of "lazy-import" objects hanging around coming from
in module `A`:

```
lazy_import('C',XXX}
```

and then in module `B`:

```
from A import XXX
```

The problem is that the lazy import object that gets bound to B.XXX still has a pointer to the namespace of A, so every time B.XXX gets called, it will looking at A.XXX. See #16522. 

If we're going to put hooks into the import system, perhaps we can filter out these issues as well.


---

Comment by klee created at 2017-04-05 22:15:28

I don't like two similar-looking names `lazy_import` and `lazyimport` used together. This would be nicer

```
from sage.misc.lazy_import import lazy_import

with lazy_import():
   from ...
```


Looking at your code, it seems that you chose `lazyimport` because of the existing function of the same name. To solve this unfortunate situation, it could be possible to hack the `__call__` method so that your `lazyimport`(or `lazy_import`) also support the old function of the same name. Like if the first argument starts with a string, then roll back to the old function...


---

Comment by nbruin created at 2017-04-06 00:15:55

Hm. Replacing `__import__` within a context manager isn't thread safe. But we COULD replace `__import__` wholesale to do what it normally does, and in extended form allow things like

```
import lazy.sage.calculus.calculus
from lazy.sage.interfaces.maxima_lib import maxima
```

what's more, we could also wrap

```
from A import XXX
```

to check if XXX is a `LazyImport` object and if so, rewrap it referencing the appropriate namespace.

The only offence is that we'd be incompatible with a top-level module "lazy" existing.


---

Comment by jdemeyer created at 2017-04-06 07:48:59

Replying to [comment:9 nbruin]:
> I don't think using the context manager is thread safe, and python as a whole doesn't forbid using threads. I'm afraid we're stuck with other, less attractive syntax.

On the other hard, I would argue that lazy imports are mostly useful during startup, where multi-threading is not likely.

> I haven't looked into this in detail, but python does have an impressive hooks etc. in the import system (hooks that have changed quite a bit in later versions of 3.* as well ...). If we want to co-opt the `import` statement syntax, perhaps we can do something using
> [meta_path](https://docs.python.org/3/reference/import.html#the-meta-path)

I guess you refer to [PEP 302](https://www.python.org/dev/peps/pep-0302/)? I did look into that, but it doesn't quite work. It's the wrong level of abstraction. These PEP 302 hooks assume that you actually want to import something (i.e. add a new entry to `sys.modules`). For lazy imports, we don't import anything, so I think that `__import__` is the right hook. Besides, `sys.meta_path` is also a global variable, so it wouldn't solve the "multi-threading" problem.

> {{{
> import lazy.sage.calculus.calculus
> }}}

Interesting syntax. I guess that would work (not for relative imports, but that is a minor thing). The only problem is that `lazy` would become a reserved name, so we really should pick something that no package will ever use. Say


```
import __lazy__.sage.calculus.calculus
```



---

Comment by jdemeyer created at 2017-04-06 07:52:03

Replying to [comment:12 nbruin]:
> Hm. Replacing `__import__` within a context manager isn't thread safe. But we COULD replace `__import__` wholesale to do what it normally does, and in extended form allow things like
> {{{
> import lazy.sage.calculus.calculus
> from lazy.sage.interfaces.maxima_lib import maxima
> }}}
> what's more, we could also wrap
> {{{
> from A import XXX
> }}}
> to check if XXX is a `LazyImport` object and if so, rewrap it referencing the appropriate namespace.

Funny. I was thinking exactly the same thing after reading your comment [comment:10]


---

Comment by jdemeyer created at 2017-04-06 08:33:36

Thinking more about it, I prefer

```
from sage.calculus.calculus.__lazy__ import something
```


Only the latter would support relative imports like `from .calculus.__lazy__ import something`.


---

Comment by jdemeyer created at 2017-04-06 08:36:29

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-04-06 08:41:15

Nils, you idea doesn't allow passing extra options to `LazyImport`. You cannot do

```
from sage.calculus.calculus.__lazy__(deprecation=12345) import something
```



---

Comment by jdemeyer created at 2017-04-06 08:41:45

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-04-06 08:44:56

Replying to [comment:9 nbruin]:
> I don't think using the context manager is thread safe, and python as a whole doesn't forbid using threads.

Maybe I can keep the current solution but try to make it thread-safe.


---

Comment by jdemeyer created at 2017-04-06 08:44:56

Changing status from needs_review to needs_work.


---

Comment by jdemeyer created at 2017-04-06 09:36:12

Replying to [comment:11 klee]:
> I don't like two similar-looking names `lazy_import` and `lazyimport` used together.

Fine, just stop using `lazy_import` then.

> Looking at your code, it seems that you chose `lazyimport` because of the existing function of the same name.

Exactly, I avoided `lazy_import` because it already exists.

> To solve this unfortunate situation, it could be possible to hack the `__call__` method so that your `lazyimport`(or `lazy_import`) also support the old function of the same name. Like if the first argument starts with a string, then roll back to the old function...

It would be possible, but I don't see the point. It would be just a hack which IMHO serves no purpose.


---

Comment by jdemeyer created at 2017-04-06 09:38:29

Regarding thread-safety, the only thing that we cannot protect against is another thread also changing `__builtin__.__import__`. If you are willing to live with that, I think it's possible to fix other thread issues.


---

Comment by klee created at 2017-04-06 10:19:08

Replying to [comment:20 jdemeyer]:
> Replying to [comment:11 klee]:
> > To solve this unfortunate situation, it could be possible to hack the `__call__` method so that your `lazyimport`(or `lazy_import`) also support the old function of the same name. Like if the first argument starts with a string, then roll back to the old function...
> 
> It would be possible, but I don't see the point. It would be just a hack which IMHO serves no purpose.

The purpose is to use the better name `lazy_import` for your new "lazy import". I guess that you expect the old "lazy import" will gradually be replaced with yours. By that time we would have lost the name `lazy_import` for nothing and be stuck with the not-so-satisfying name `lazyimport`.

Of course, this is a minor issue now...


---

Comment by git created at 2017-04-06 10:26:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-04-06 10:28:29

Changing status from needs_work to needs_review.


---

Comment by jdemeyer created at 2017-04-06 10:35:36

Replying to [comment:12 nbruin]:
> We could also wrap
> {{{
> from A import XXX
> }}}
> to check if XXX is a `LazyImport` object and if so, rewrap it referencing the appropriate namespace.

I suggest to do this _not_ on this ticket, but on #16522.


---

Comment by git created at 2017-04-06 12:35:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2017-04-06 12:35:42

Continuing the name discussion, I realized that lazy imports are often used in `all.py` files which are then imported by an `from ... import *` statement. It's better that this latter statement does not import the name `lazyimport` (imagine seeing `lazyimport` in a catalogue). For that reason, it is better to start the name with an underscore. So I changed the name to `_lazyimport_`.


---

Comment by embray created at 2017-04-06 14:42:26

I don't know how lazy imports worked before in Sage, nor have I fully tried to understand this yet, but is there some reason you _must_ replace `__import__`?  This is generally considered extremely fraught with difficulties and fragile.  Is there something you can't do with PEP 302-style import hooks?  See also https://docs.python.org/3/reference/import.html for some information on how this relates to Python 3.


---

Comment by embray created at 2017-04-06 14:53:28

Yeah, if the main purpose of replacing `__import__` is to return a `LazyModule` object, this could be done with import hooks, and none of the stuff with threads, and replacing `__import__` should be necessary.  The context manager might not be necessary either, though I could see a use for it if you wanted explicitly import some modules lazily and others not depending on the context.

Unless I'm missing something, for example, as this relates to Cython.


---

Comment by jdemeyer created at 2017-04-06 15:17:44

Replying to [comment:28 embray]:
> This is generally considered extremely fraught with difficulties and fragile.

[citation needed]

> Is there something you can't do with PEP 302-style import hooks?

My impression with PEP 302 is that it is really meant if you actually want to import something in the end and add it to `sys.modules`. This is _not_ the case here.

I tried to implement this with PEP 302 at first and it didn't work. Maybe there is some possibility to get it to work somehow, but I'm convinced that replacing `__import__` is the simplest solution.


---

Comment by jdemeyer created at 2017-04-06 15:21:03

Replying to [comment:29 embray]:
> The context manager might not be necessary either

Which syntax would you propose, keeping in mind that we want to allow optional arguments like

```
with _lazyimport_(deprecation=12345):
    from ... import ...
```


I'm honestly open for suggestions here.


---

Comment by embray created at 2017-04-06 15:31:23

Replying to [comment:30 jdemeyer]:
> Replying to [comment:28 embray]:
> > This is generally considered extremely fraught with difficulties and fragile.
> 
> [citation needed]

PEP 302 itself for one.  Plus my own experience with more complex import scenarios (ever try to import an [IRAF](http://iraf.noao.edu/) module for Python?)

> > Is there something you can't do with PEP 302-style import hooks?
> 
> My impression with PEP 302 is that it is really meant if you actually want to import something in the end and add it to `sys.modules`. This is _not_ the case here.
> 
> I tried to implement this with PEP 302 at first and it didn't work. Maybe there is some possibility to get it to work somehow, but I'm convinced that replacing `__import__` is the simplest solution.

I'm definitely not convinced but I'd have to see what you tried and why it didn't work?


---

Comment by embray created at 2017-04-06 15:34:28

Replying to [comment:31 jdemeyer]:
> Replying to [comment:29 embray]:
> > The context manager might not be necessary either
> 
> Which syntax would you propose, keeping in mind that we want to allow optional arguments like
> {{{
> with _lazyimport_(deprecation=12345):
>     from ... import ...
> }}}
> 
> I'm honestly open for suggestions here.

Right, this is another point in favor of the context manager construct.  The more I look at this I think it's very useful.  There are other ways one might do this globally for a module, but if you want to tweak options on a contextual basis this makes some sense.

I think my only concern is it's not very transparent.  It might be nice to have a way to mark a particular module to just always be lazy-imported because it is known to be involved in import cycles (e.g. `sage.rings.integer_ring`).  That way someone using the module doesn't have to carefully specify that it should be lazy-imported.


---

Comment by jdemeyer created at 2017-04-06 18:03:24

Replying to [comment:32 embray]:
> PEP 302 itself for one.  Plus my own experience with more complex import scenarios (ever try to import an [IRAF](http://iraf.noao.edu/) module for Python?)

I simply think that PEP 302 and overriding `__import__` solve different problems. PEP 302 solves the problem that you have an actual module somewhere which needs to be imported, but that you need to do something special to find the module (I think of `pyximport` which automatically compiles Cython code or `setuptools` unpacking eggs).

Overriding `__import__` essentially allows you to syntactically replace the `import` statement with custom code, which is very much what we want to do with lazy imports.

I would also argue that the current code dealing with overriding `__import__` is pretty simple, so I don't see what PEP 302 could add.


---

Comment by jdemeyer created at 2017-04-06 18:10:51

Replying to [comment:29 embray]:
> this could be done with import hooks, and none of the stuff with threads should be necessary.

"the stuff with threads" is needed to support the context manager because it changes a global variable `__builtin__.__import__`. PEP 302 wouldn't make a difference for this because it also uses global variables like `sys.meta_path`.


---

Comment by jdemeyer created at 2017-04-06 18:14:19

Replying to [comment:33 embray]:
> It might be nice to have a way to mark a particular module to just always be lazy-imported

That would be a completely different way to deal with lazy imports. I can't say at this point whether that would be a good or bad idea or how it should be implemented.


---

Comment by nbruin created at 2017-04-06 19:28:33

Replying to [comment:21 jdemeyer]:
> Regarding thread-safety, the only thing that we cannot protect against is another thread also changing `__builtin__.__import__`. If you are willing to live with that, I think it's possible to fix other thread issues.

As usual, lack of thread-safety is a canary for general unintended side-effects that in a highly dynamic environment such as python can also screw things up in the same thread:

Whatever code is wrapped inside the "with lazyimport" now needs to ensure it doesn't trigger other code to execute that happens to rely on "import" meaning what it usually means in python. That's a very hard, non-local restriction to enforce. So I think changing a global binding in this way (which is non-transparent wrt the normal usage) is a no-go. You basically end up with a context in which the only legal command is `import` or `from .. import` (and even there, with the hooks available in the python import system, do you have full control over what code gets executed?


---

Comment by nbruin created at 2017-04-06 19:33:21

Replying to [comment:34 jdemeyer]:
> Overriding `__import__` essentially allows you to syntactically replace the `import` statement with custom code, which is very much what we want to do with lazy imports.

Indeed. A lazy "import module" can  be done through loader hooks, and python3 even has an example class for doing that.

It's the lazy "from module import object" that is tricky to do, and for which it seems `__import__` is the right hook (there is a "from" list there. The other import hooks don't seem to have that info).
Incidentally, that is also the more problematic thing to do and should probably be generally avoided. It leads to proxy objects that easily end up in places where they cannot remove themselves.


---

Comment by jdemeyer created at 2017-04-06 20:14:34

Replying to [comment:37 nbruin]:
> Whatever code is wrapped inside the "with lazyimport" now needs to ensure it doesn't trigger other code to execute that happens to rely on "import" meaning what it usually means in python.

If that code just executes an `import` statement and nothing else (which is how this is intented), there should be no problem. I intent this to be used as

```
...some code...
with _lazyimport_:
    from sage.rings.integer import ZZ
...some code...
```

not

```
with _lazyimport_:
    ...some code...
    from sage.rings.integer import ZZ
    ...some code...
```


> and even there, with the hooks available in the python import system, do you have full control over what code gets executed?

Yes because those other hooks won't be called.


---

Comment by jdemeyer created at 2017-04-06 20:15:15

Resolution: wontfix


---

Comment by jdemeyer created at 2017-04-06 20:15:15

Anyway, with 2 people clearly against my idea, I will stop fighting...


---

Comment by jdemeyer created at 2017-04-06 20:22:02

Once you implement lazy imports with your hypothetical fix using PEP 302, remember to fix #15648 and #20626 too.


---

Comment by jdemeyer created at 2017-04-06 20:24:08

And maybe #21636 too, while you're at it.


---

Comment by jdemeyer created at 2017-04-06 20:25:42

...which should eventually lead to a fix for #22747 which I need for https://github.com/OpenDreamKit/OpenDreamKit/issues/87


---

Comment by jdemeyer created at 2017-04-07 07:55:42

Just to know where we stand, let me try to summarize the pros and cons of my approach. I'll try to do this objectively. It will at least allow to compare different approaches.

New features compared to the old `lazy_import`:

1. Support Python and Cython (imports in Cython work the same way as plain Python, so this is true for anything which hooks the import system).

2. Simple syntax: an ordinary `import` statement inside a `with _lazyimport_` block.

3. Relative and absolute imports are supported.


Existing features from `lazy_import` which are kept:

4. Support for PEP 302 (a module which needs a PEP 302 loader can be lazy imported).

5. Support for optional arguments like `deprecation`.

6. Support for `from ... import *`.

7. Automatic replacement of `LazyImport` in a global namespace by the actual imported object.

8. Existing `lazy_import`s can be easily converted to the new `with _lazyimport_`, preserving all features.


Cons:

9. Only `from ... import ...` is supported, not `import ...`

10. One should be careful not to run arbitrary code inside a `with _lazyimport_` block.

11. It's not implemented using PEP 302 (personally, I don't think that's an issue, but you guys seem to think so).

Finally, let me mention that #21636 is the main reason to work on this, for which in particular proper Cython support for lazy imports is needed.


---

Comment by jdemeyer created at 2017-04-07 08:33:37

I also remind you about #22755, which makes some fixes to the existing lazy imports. If you do work on lazy imports, please do so on top of #22755.


---

Comment by embray created at 2017-04-07 09:42:01

> PEP 302 wouldn't make a difference for this because it also uses global variables like sys.meta_path

You wouldn't be manipulating `sys.meta_path` in general, except very early on in `sage.__init__` for example.


---

Comment by embray created at 2017-04-07 11:17:11

I think I understand better now how this is really _only_ trying to override the `from a import b` syntax, which is why you are targeting `__import__` itself.  Though really, the problem with circular imports is the same whether one is using the `import foo` syntax or the `from foo import ...` syntax.  

So that takes me back to thinking that some modules should always use some kind of lazy-import mechanism.  It's better overall to design things to avoid circular imports in the first place, but it's admittedly tricky for some fundamental modules (like rationals are defined in terms of integers, but operations on integers can return rationals, or need to be able to work with rationals, etc.).  That's just one example it it seems to be one of the most pervasive.

Now, supporting `from foo import ...` is still tricky since it needs to be supported via a proxy object, but already exists and can be reused / improved on.  The issues you mentioned like #20626 seem like issues with the implementation of the proxy itself. (I also wonder if, rather than using our own proxy implementation, it would be useful to use something from the community like https://github.com/ionelmc/python-lazy-object-proxy; not sure how well that works with Sage's builtin types though).


----


On a slightly different topic, I don't quite understand why the "deprecation" feature of the existing `lazy_import` needs to be implemented directly through the import syntax or via a wrapper around it.  Similarly for the "startup guard" functionality.  Instead, these features could be implemented if _all_ modules in _sage_ were wrapped in a custom `Module` subclass/wrapper.  Although I haven't tested as such, I think there'd be little noticeable overhead to doing so.  Then we can add simple syntax at the module level for specifying this behavior.  For example, `sage.combinat.crystals.all` contains a fair number of deprecations.  Instead of:


```
lazy_import('sage.combinat.crystals.letters',
            'CrystalOfLetters',
            deprecation=(15882, "this is being removed from the global namespace. Use crystals.Letters instead"))

lazy_import('sage.combinat.crystals.fast_crystals',
            'FastCrystal',
            deprecation=(15882, "this is being removed from the global namespace. Use crystals.FastRankTwo instead"))

lazy_import('sage.combinat.crystals.highest_weight_crystals',
            'HighestWeightCrystal',
            deprecation=(15882, "this is being removed from the global namespace. Use crystals.HighestWeight instead"))
```


this could look something like:


```
__sage_deprecations__ = [
    ('sage.combinat.crystals.' + mod_name, cls_name, 15822, "this is being removed from the global namespace. Use crystals. %s instead" % cls_name) for mod_name, cls_name in [
        ('letters', 'CrystalOfLetters'),
        ('fast_crystals', 'FastCrystal'),
        ('highest_weight_crystals', 'HeighestWeightCrystals'),
        ...
    ]
]
```


A custom module wrapper would be able handle imports of objects listed in `__sage_deprecations__` (as I'm calling it) through `__getattribute__` and return proxies for those objects, whereas the `sage.combinat.crystals.catalog` module would not have `__sage_deprecations__` and thus would supply the normal, non-proxied objects.

I feel like this is a clearer and more explicit declarative approach to how some attributes of some modules should be handled, rather than mucking with the import system every single time this feature is needed.


---

Comment by embray created at 2017-04-07 12:12:31

Just out of curiosity, I'm going to take a stab at replacing our proxy with `lazy_object_proxy` (without any other changes to lazy_import) and see how far I can get, or if it can resolve any of the known bugs.


---

Comment by nbruin created at 2017-04-07 18:53:10

Replying to [comment:47 embray]:
> I think I understand better now how this is really _only_ trying to override the `from a import b` syntax, which is why you are targeting `__import__` itself.  Though really, the problem with circular imports is the same whether one is using the `import foo` syntax or the `from foo import ...` syntax.  

No, it's not. Python is completely fine with circular imports. The problem arises when there is a circular access of module attributes *during load time*. The problem with "from foo import ..." is that it automatically leads to a module attribute access during load time.

Without "from foo import ..." you'd have to write something like

```
import A

c=A.b+1
```

which is very unlikely to happen, since usually at load time only declarations are executed.

For that kind of symbols we would basically just need

```
#instead of from A import b
import A
forward_binding(target="b",namespace=globals(),from=A,from_name="b")
```

where forward_binding could be resolved as soon as A is initialized. The proxy doesn't have to hang around until first used, as with lazy-import. I'm not sure we have the right hooks to do this, but if there are I think we could change __import__ to allow one more level of circularity (namely, circularity for "from A import b" provided that A.b doesn't get accessed during load time).


---

Comment by jdemeyer created at 2017-04-07 20:07:03

Replying to [comment:47 embray]:
> The issues you mentioned like #20626 seem like issues with the implementation of the proxy itself.

Yes and I *had* a fix for #15648 and for #20626 (based on this ticket, so those fixes are no longer valid).


---

Comment by nbruin created at 2017-04-07 20:11:55

Replying to [comment:39 jdemeyer]:
> > and even there, with the hooks available in the python import system, do you have full control over what code gets executed?
> 
> Yes because those other hooks won't be called.

I think there might be a more reliable way: When `__import__` gets called, it does get a "globals" parameter with it as the scope on which to work. We can park our state whether inputs are to be lazy there:

```
builtin.__import__=new_import
lazy_import=True
from A import a
lazy_import=False
import B
```

i.e., the new import uses a binding in the relevant scope to see if it needs to intercept imports and make them lazy or whether they should be processed as normal.

That way, the new import routine would be transparent for scopes where lazy_import isn't being used.

Based on that infrastructure, a context would be just fine. It would be about toggling a flag in the relevant scope rather than changing a global variable.

It does mean we'd need to have our "__import__" wrapper in place all the time, because swapping it *out* would still be sensitive to scoping and threading issues.


---

Comment by embray created at 2017-04-07 20:52:47

I still think that messing so much with imports for what you want to accomplish is overkill.  My point in my last comment was that whether you use the `import foo` or `from import foo ...` syntax the first thing that happens is `foo` is imported, possibly through import hooks, and those hooks can always wrap the `Module` object for `foo` in a proxy that can handle lazy imports.

You could even make the module wrapper itself a context manager for handling lazy imports.  I don't know that this is the clearest syntax but it's an idea:


```
import foo
with foo.__lazy_import__:
    from foo import a
    from foo import b
```


In this case `a` and `b` are `LazyImport` proxies.

I think the 'deprecation warning' aspect of `lazy_import` can be handled through a separate mechanism as explained above.

My experiment in rewriting `LazyImport` worked too--there's just one minor detail with regard to how `__class__` is handled that I need to fix but it's 11:00 p.m. on Friday night here so I'm gonna call it quits until Monday :)


---

Comment by embray created at 2017-04-11 09:31:11

Can we maybe discuss exactly what the use cases are for lazy-import?

To me the _primary_ use case--the one that really matters--is just breaking circular imports at startup time.  I've never needed something like lazy imports to get around that before, but I admit some of the circular definitions in Sage are vexing and hard to avoid, especially in Cygwin modules where we have less control over the order in which module-level statements are executed with respect to each other.  So that's one case.

The other two, as far as I can tell, are:

1) Issuing deprecation warnings for imports of some names from modules they shouldn't be directly imported from.

2) Issuing a warning (or error as in #22755) if some proxied lazy import gets resolved during initial startup.

I don't really much see the case for the latter of the two.  If the main use case for lazy imports (and note: I'm not necessarily claiming that's the case, that's just my understanding) then who cares if gets resolved at startup time?  If it does, any nothing breaks, then it doesn't need to be a lazy import in the first place (having this feature optionally for debugging purposes is nice though).


---

Comment by embray created at 2017-04-11 09:34:37

Or are there also cases where lazy import is used for performance reasons, and if so what are some examples of that?


---

Comment by jdemeyer created at 2017-04-11 09:40:46

I would say there are two important use cases:

1. as you mentioned, breaking circular imports.

2. importing less stuff at startup to decrease startup time. For example, if you don't care about differential geometry, then it would be a waste of time to import all differential-geometry-related modules when Sage starts up. However, we do want the relevant classes to appear in the global namespace, so we use a lazy import. The `at_startup` argument is very relevant here, since a lazy import resolved at startup wouldn't help with this.


---

Comment by embray created at 2017-04-11 09:43:02

Got it--thanks for clarifying.


---

Comment by jdemeyer created at 2017-04-20 09:39:32

TODO: discuss lazy imports next week too with `@`embray.


---

Comment by jdemeyer created at 2017-04-21 15:27:16

Good news for myself: I think I can get #22747 to work without requiring this.


---

Comment by embray created at 2017-04-21 17:23:57

Is that the issue you refer to when you mean "works with Cython"?
