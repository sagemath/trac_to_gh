# Issue 22515: Lazy imports based on PEP 302

archive/issues_022515.json:
```json
{
    "body": "Highly experimental...\n\ntry to implement lazy imports using [PEP 302](https://www.python.org/dev/peps/pep-0302/) somehow.\n\nIssue created by migration from https://trac.sagemath.org/ticket/22752\n\n",
    "created_at": "2017-04-04T13:23:08Z",
    "labels": [
        "component: misc"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "Lazy imports based on PEP 302",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/22515",
    "user": "https://github.com/jdemeyer"
}
```
Highly experimental...

try to implement lazy imports using [PEP 302](https://www.python.org/dev/peps/pep-0302/) somehow.

Issue created by migration from https://trac.sagemath.org/ticket/22752





---

archive/issue_comments_313336.json:
```json
{
    "body": "New commits:",
    "created_at": "2017-04-05T13:38:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313336",
    "user": "https://github.com/jdemeyer"
}
```

New commits:



---

archive/issue_comments_313337.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2017-04-05T15:18:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313337",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_313338.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2017-04-05T15:35:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313338",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_313339.json:
```json
{
    "body": "I don't think using the context manager is thread safe, and python as a whole doesn't forbid using threads. I'm afraid we're stuck with other, less attractive syntax.\n\nI haven't looked into this in detail, but python does have an impressive hooks etc. in the import system (hooks that have changed quite a bit in later versions of 3.* as well ...). If we want to co-opt the `import` statement syntax, perhaps we can do something using\n[meta_path](https://docs.python.org/3/reference/import.html#the-meta-path) so that we can do something like\n\n```\nimport lazy.sage.calculus.calculus\n```\n",
    "created_at": "2017-04-05T19:57:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313339",
    "user": "https://github.com/nbruin"
}
```

I don't think using the context manager is thread safe, and python as a whole doesn't forbid using threads. I'm afraid we're stuck with other, less attractive syntax.

I haven't looked into this in detail, but python does have an impressive hooks etc. in the import system (hooks that have changed quite a bit in later versions of 3.* as well ...). If we want to co-opt the `import` statement syntax, perhaps we can do something using
[meta_path](https://docs.python.org/3/reference/import.html#the-meta-path) so that we can do something like

```
import lazy.sage.calculus.calculus
```




---

archive/issue_comments_313340.json:
```json
{
    "body": "Different note on lazy imports: Currently we have hundreds of \"lazy-import\" objects hanging around coming from\nin module `A`:\n\n```\nlazy_import('C',XXX}\n```\n\nand then in module `B`:\n\n```\nfrom A import XXX\n```\n\nThe problem is that the lazy import object that gets bound to B.XXX still has a pointer to the namespace of A, so every time B.XXX gets called, it will looking at A.XXX. See #16522. \n\nIf we're going to put hooks into the import system, perhaps we can filter out these issues as well.",
    "created_at": "2017-04-05T20:19:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313340",
    "user": "https://github.com/nbruin"
}
```

Different note on lazy imports: Currently we have hundreds of "lazy-import" objects hanging around coming from
in module `A`:

```
lazy_import('C',XXX}
```

and then in module `B`:

```
from A import XXX
```

The problem is that the lazy import object that gets bound to B.XXX still has a pointer to the namespace of A, so every time B.XXX gets called, it will looking at A.XXX. See #16522. 

If we're going to put hooks into the import system, perhaps we can filter out these issues as well.



---

archive/issue_comments_313341.json:
```json
{
    "body": "I don't like two similar-looking names `lazy_import` and `lazyimport` used together. This would be nicer\n\n```\nfrom sage.misc.lazy_import import lazy_import\n\nwith lazy_import():\n   from ...\n```\n\n\nLooking at your code, it seems that you chose `lazyimport` because of the existing function of the same name. To solve this unfortunate situation, it could be possible to hack the `__call__` method so that your `lazyimport`(or `lazy_import`) also support the old function of the same name. Like if the first argument starts with a string, then roll back to the old function...",
    "created_at": "2017-04-05T22:15:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313341",
    "user": "https://github.com/kwankyu"
}
```

I don't like two similar-looking names `lazy_import` and `lazyimport` used together. This would be nicer

```
from sage.misc.lazy_import import lazy_import

with lazy_import():
   from ...
```


Looking at your code, it seems that you chose `lazyimport` because of the existing function of the same name. To solve this unfortunate situation, it could be possible to hack the `__call__` method so that your `lazyimport`(or `lazy_import`) also support the old function of the same name. Like if the first argument starts with a string, then roll back to the old function...



---

archive/issue_comments_313342.json:
```json
{
    "body": "Hm. Replacing `__import__` within a context manager isn't thread safe. But we COULD replace `__import__` wholesale to do what it normally does, and in extended form allow things like\n\n```\nimport lazy.sage.calculus.calculus\nfrom lazy.sage.interfaces.maxima_lib import maxima\n```\n\nwhat's more, we could also wrap\n\n```\nfrom A import XXX\n```\n\nto check if XXX is a `LazyImport` object and if so, rewrap it referencing the appropriate namespace.\n\nThe only offence is that we'd be incompatible with a top-level module \"lazy\" existing.",
    "created_at": "2017-04-06T00:15:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313342",
    "user": "https://github.com/nbruin"
}
```

Hm. Replacing `__import__` within a context manager isn't thread safe. But we COULD replace `__import__` wholesale to do what it normally does, and in extended form allow things like

```
import lazy.sage.calculus.calculus
from lazy.sage.interfaces.maxima_lib import maxima
```

what's more, we could also wrap

```
from A import XXX
```

to check if XXX is a `LazyImport` object and if so, rewrap it referencing the appropriate namespace.

The only offence is that we'd be incompatible with a top-level module "lazy" existing.



---

archive/issue_comments_313343.json:
```json
{
    "body": "Replying to [comment:9 nbruin]:\n> I don't think using the context manager is thread safe, and python as a whole doesn't forbid using threads. I'm afraid we're stuck with other, less attractive syntax.\n\nOn the other hard, I would argue that lazy imports are mostly useful during startup, where multi-threading is not likely.\n\n> I haven't looked into this in detail, but python does have an impressive hooks etc. in the import system (hooks that have changed quite a bit in later versions of 3.* as well ...). If we want to co-opt the `import` statement syntax, perhaps we can do something using\n> [meta_path](https://docs.python.org/3/reference/import.html#the-meta-path)\n\nI guess you refer to [PEP 302](https://www.python.org/dev/peps/pep-0302/)? I did look into that, but it doesn't quite work. It's the wrong level of abstraction. These PEP 302 hooks assume that you actually want to import something (i.e. add a new entry to `sys.modules`). For lazy imports, we don't import anything, so I think that `__import__` is the right hook. Besides, `sys.meta_path` is also a global variable, so it wouldn't solve the \"multi-threading\" problem.\n\n> {{{\n> import lazy.sage.calculus.calculus\n> }}}\n\nInteresting syntax. I guess that would work (not for relative imports, but that is a minor thing). The only problem is that `lazy` would become a reserved name, so we really should pick something that no package will ever use. Say\n\n\n```\nimport __lazy__.sage.calculus.calculus\n```\n",
    "created_at": "2017-04-06T07:48:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313343",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:9 nbruin]:
> I don't think using the context manager is thread safe, and python as a whole doesn't forbid using threads. I'm afraid we're stuck with other, less attractive syntax.

On the other hard, I would argue that lazy imports are mostly useful during startup, where multi-threading is not likely.

> I haven't looked into this in detail, but python does have an impressive hooks etc. in the import system (hooks that have changed quite a bit in later versions of 3.* as well ...). If we want to co-opt the `import` statement syntax, perhaps we can do something using
> [meta_path](https://docs.python.org/3/reference/import.html#the-meta-path)

I guess you refer to [PEP 302](https://www.python.org/dev/peps/pep-0302/)? I did look into that, but it doesn't quite work. It's the wrong level of abstraction. These PEP 302 hooks assume that you actually want to import something (i.e. add a new entry to `sys.modules`). For lazy imports, we don't import anything, so I think that `__import__` is the right hook. Besides, `sys.meta_path` is also a global variable, so it wouldn't solve the "multi-threading" problem.

> {{{
> import lazy.sage.calculus.calculus
> }}}

Interesting syntax. I guess that would work (not for relative imports, but that is a minor thing). The only problem is that `lazy` would become a reserved name, so we really should pick something that no package will ever use. Say


```
import __lazy__.sage.calculus.calculus
```




---

archive/issue_comments_313344.json:
```json
{
    "body": "Replying to [comment:12 nbruin]:\n> Hm. Replacing `__import__` within a context manager isn't thread safe. But we COULD replace `__import__` wholesale to do what it normally does, and in extended form allow things like\n> {{{\n> import lazy.sage.calculus.calculus\n> from lazy.sage.interfaces.maxima_lib import maxima\n> }}}\n> what's more, we could also wrap\n> {{{\n> from A import XXX\n> }}}\n> to check if XXX is a `LazyImport` object and if so, rewrap it referencing the appropriate namespace.\n\nFunny. I was thinking exactly the same thing after reading your comment [comment:10]",
    "created_at": "2017-04-06T07:52:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313344",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:12 nbruin]:
> Hm. Replacing `__import__` within a context manager isn't thread safe. But we COULD replace `__import__` wholesale to do what it normally does, and in extended form allow things like
> {{{
> import lazy.sage.calculus.calculus
> from lazy.sage.interfaces.maxima_lib import maxima
> }}}
> what's more, we could also wrap
> {{{
> from A import XXX
> }}}
> to check if XXX is a `LazyImport` object and if so, rewrap it referencing the appropriate namespace.

Funny. I was thinking exactly the same thing after reading your comment [comment:10]



---

archive/issue_comments_313345.json:
```json
{
    "body": "Thinking more about it, I prefer\n\n```\nfrom sage.calculus.calculus.__lazy__ import something\n```\n\n\nOnly the latter would support relative imports like `from .calculus.__lazy__ import something`.",
    "created_at": "2017-04-06T08:33:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313345",
    "user": "https://github.com/jdemeyer"
}
```

Thinking more about it, I prefer

```
from sage.calculus.calculus.__lazy__ import something
```


Only the latter would support relative imports like `from .calculus.__lazy__ import something`.



---

archive/issue_comments_313346.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-04-06T08:36:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313346",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_313347.json:
```json
{
    "body": "Nils, you idea doesn't allow passing extra options to `LazyImport`. You cannot do\n\n```\nfrom sage.calculus.calculus.__lazy__(deprecation=12345) import something\n```\n",
    "created_at": "2017-04-06T08:41:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313347",
    "user": "https://github.com/jdemeyer"
}
```

Nils, you idea doesn't allow passing extra options to `LazyImport`. You cannot do

```
from sage.calculus.calculus.__lazy__(deprecation=12345) import something
```




---

archive/issue_comments_313348.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-04-06T08:41:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313348",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_313349.json:
```json
{
    "body": "Replying to [comment:9 nbruin]:\n> I don't think using the context manager is thread safe, and python as a whole doesn't forbid using threads.\n\nMaybe I can keep the current solution but try to make it thread-safe.",
    "created_at": "2017-04-06T08:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313349",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:9 nbruin]:
> I don't think using the context manager is thread safe, and python as a whole doesn't forbid using threads.

Maybe I can keep the current solution but try to make it thread-safe.



---

archive/issue_comments_313350.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-04-06T08:44:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313350",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_313351.json:
```json
{
    "body": "Replying to [comment:11 klee]:\n> I don't like two similar-looking names `lazy_import` and `lazyimport` used together.\n\nFine, just stop using `lazy_import` then.\n\n> Looking at your code, it seems that you chose `lazyimport` because of the existing function of the same name.\n\nExactly, I avoided `lazy_import` because it already exists.\n\n> To solve this unfortunate situation, it could be possible to hack the `__call__` method so that your `lazyimport`(or `lazy_import`) also support the old function of the same name. Like if the first argument starts with a string, then roll back to the old function...\n\nIt would be possible, but I don't see the point. It would be just a hack which IMHO serves no purpose.",
    "created_at": "2017-04-06T09:36:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313351",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:11 klee]:
> I don't like two similar-looking names `lazy_import` and `lazyimport` used together.

Fine, just stop using `lazy_import` then.

> Looking at your code, it seems that you chose `lazyimport` because of the existing function of the same name.

Exactly, I avoided `lazy_import` because it already exists.

> To solve this unfortunate situation, it could be possible to hack the `__call__` method so that your `lazyimport`(or `lazy_import`) also support the old function of the same name. Like if the first argument starts with a string, then roll back to the old function...

It would be possible, but I don't see the point. It would be just a hack which IMHO serves no purpose.



---

archive/issue_comments_313352.json:
```json
{
    "body": "Regarding thread-safety, the only thing that we cannot protect against is another thread also changing `__builtin__.__import__`. If you are willing to live with that, I think it's possible to fix other thread issues.",
    "created_at": "2017-04-06T09:38:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313352",
    "user": "https://github.com/jdemeyer"
}
```

Regarding thread-safety, the only thing that we cannot protect against is another thread also changing `__builtin__.__import__`. If you are willing to live with that, I think it's possible to fix other thread issues.



---

archive/issue_comments_313353.json:
```json
{
    "body": "Replying to [comment:20 jdemeyer]:\n> Replying to [comment:11 klee]:\n> > To solve this unfortunate situation, it could be possible to hack the `__call__` method so that your `lazyimport`(or `lazy_import`) also support the old function of the same name. Like if the first argument starts with a string, then roll back to the old function...\n> \n> It would be possible, but I don't see the point. It would be just a hack which IMHO serves no purpose.\n\nThe purpose is to use the better name `lazy_import` for your new \"lazy import\". I guess that you expect the old \"lazy import\" will gradually be replaced with yours. By that time we would have lost the name `lazy_import` for nothing and be stuck with the not-so-satisfying name `lazyimport`.\n\nOf course, this is a minor issue now...",
    "created_at": "2017-04-06T10:19:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313353",
    "user": "https://github.com/kwankyu"
}
```

Replying to [comment:20 jdemeyer]:
> Replying to [comment:11 klee]:
> > To solve this unfortunate situation, it could be possible to hack the `__call__` method so that your `lazyimport`(or `lazy_import`) also support the old function of the same name. Like if the first argument starts with a string, then roll back to the old function...
> 
> It would be possible, but I don't see the point. It would be just a hack which IMHO serves no purpose.

The purpose is to use the better name `lazy_import` for your new "lazy import". I guess that you expect the old "lazy import" will gradually be replaced with yours. By that time we would have lost the name `lazy_import` for nothing and be stuck with the not-so-satisfying name `lazyimport`.

Of course, this is a minor issue now...



---

archive/issue_comments_313354.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-04-06T10:26:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313354",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_313355.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-04-06T10:28:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313355",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_313356.json:
```json
{
    "body": "Replying to [comment:12 nbruin]:\n> We could also wrap\n> {{{\n> from A import XXX\n> }}}\n> to check if XXX is a `LazyImport` object and if so, rewrap it referencing the appropriate namespace.\n\nI suggest to do this *not* on this ticket, but on #16522.",
    "created_at": "2017-04-06T10:35:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313356",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:12 nbruin]:
> We could also wrap
> {{{
> from A import XXX
> }}}
> to check if XXX is a `LazyImport` object and if so, rewrap it referencing the appropriate namespace.

I suggest to do this *not* on this ticket, but on #16522.



---

archive/issue_comments_313357.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-04-06T12:35:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313357",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_313358.json:
```json
{
    "body": "Continuing the name discussion, I realized that lazy imports are often used in `all.py` files which are then imported by an `from ... import *` statement. It's better that this latter statement does not import the name `lazyimport` (imagine seeing `lazyimport` in a catalogue). For that reason, it is better to start the name with an underscore. So I changed the name to `_lazyimport_`.",
    "created_at": "2017-04-06T12:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313358",
    "user": "https://github.com/jdemeyer"
}
```

Continuing the name discussion, I realized that lazy imports are often used in `all.py` files which are then imported by an `from ... import *` statement. It's better that this latter statement does not import the name `lazyimport` (imagine seeing `lazyimport` in a catalogue). For that reason, it is better to start the name with an underscore. So I changed the name to `_lazyimport_`.



---

archive/issue_comments_313359.json:
```json
{
    "body": "I don't know how lazy imports worked before in Sage, nor have I fully tried to understand this yet, but is there some reason you *must* replace `__import__`?  This is generally considered extremely fraught with difficulties and fragile.  Is there something you can't do with PEP 302-style import hooks?  See also https://docs.python.org/3/reference/import.html for some information on how this relates to Python 3.",
    "created_at": "2017-04-06T14:42:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313359",
    "user": "https://github.com/embray"
}
```

I don't know how lazy imports worked before in Sage, nor have I fully tried to understand this yet, but is there some reason you *must* replace `__import__`?  This is generally considered extremely fraught with difficulties and fragile.  Is there something you can't do with PEP 302-style import hooks?  See also https://docs.python.org/3/reference/import.html for some information on how this relates to Python 3.



---

archive/issue_comments_313360.json:
```json
{
    "body": "Yeah, if the main purpose of replacing `__import__` is to return a `LazyModule` object, this could be done with import hooks, and none of the stuff with threads, and replacing `__import__` should be necessary.  The context manager might not be necessary either, though I could see a use for it if you wanted explicitly import some modules lazily and others not depending on the context.\n\nUnless I'm missing something, for example, as this relates to Cython.",
    "created_at": "2017-04-06T14:53:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313360",
    "user": "https://github.com/embray"
}
```

Yeah, if the main purpose of replacing `__import__` is to return a `LazyModule` object, this could be done with import hooks, and none of the stuff with threads, and replacing `__import__` should be necessary.  The context manager might not be necessary either, though I could see a use for it if you wanted explicitly import some modules lazily and others not depending on the context.

Unless I'm missing something, for example, as this relates to Cython.



---

archive/issue_comments_313361.json:
```json
{
    "body": "Replying to [comment:28 embray]:\n> This is generally considered extremely fraught with difficulties and fragile.\n\n[citation needed]\n\n> Is there something you can't do with PEP 302-style import hooks?\n\nMy impression with PEP 302 is that it is really meant if you actually want to import something in the end and add it to `sys.modules`. This is *not* the case here.\n\nI tried to implement this with PEP 302 at first and it didn't work. Maybe there is some possibility to get it to work somehow, but I'm convinced that replacing `__import__` is the simplest solution.",
    "created_at": "2017-04-06T15:17:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313361",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:28 embray]:
> This is generally considered extremely fraught with difficulties and fragile.

[citation needed]

> Is there something you can't do with PEP 302-style import hooks?

My impression with PEP 302 is that it is really meant if you actually want to import something in the end and add it to `sys.modules`. This is *not* the case here.

I tried to implement this with PEP 302 at first and it didn't work. Maybe there is some possibility to get it to work somehow, but I'm convinced that replacing `__import__` is the simplest solution.



---

archive/issue_comments_313362.json:
```json
{
    "body": "Replying to [comment:29 embray]:\n> The context manager might not be necessary either\n\nWhich syntax would you propose, keeping in mind that we want to allow optional arguments like\n\n```\nwith _lazyimport_(deprecation=12345):\n    from ... import ...\n```\n\n\nI'm honestly open for suggestions here.",
    "created_at": "2017-04-06T15:21:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313362",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:29 embray]:
> The context manager might not be necessary either

Which syntax would you propose, keeping in mind that we want to allow optional arguments like

```
with _lazyimport_(deprecation=12345):
    from ... import ...
```


I'm honestly open for suggestions here.



---

archive/issue_comments_313363.json:
```json
{
    "body": "Replying to [comment:30 jdemeyer]:\n> Replying to [comment:28 embray]:\n> > This is generally considered extremely fraught with difficulties and fragile.\n> \n> [citation needed]\n\nPEP 302 itself for one.  Plus my own experience with more complex import scenarios (ever try to import an [IRAF](http://iraf.noao.edu/) module for Python?)\n\n> > Is there something you can't do with PEP 302-style import hooks?\n> \n> My impression with PEP 302 is that it is really meant if you actually want to import something in the end and add it to `sys.modules`. This is *not* the case here.\n> \n> I tried to implement this with PEP 302 at first and it didn't work. Maybe there is some possibility to get it to work somehow, but I'm convinced that replacing `__import__` is the simplest solution.\n\nI'm definitely not convinced but I'd have to see what you tried and why it didn't work?",
    "created_at": "2017-04-06T15:31:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313363",
    "user": "https://github.com/embray"
}
```

Replying to [comment:30 jdemeyer]:
> Replying to [comment:28 embray]:
> > This is generally considered extremely fraught with difficulties and fragile.
> 
> [citation needed]

PEP 302 itself for one.  Plus my own experience with more complex import scenarios (ever try to import an [IRAF](http://iraf.noao.edu/) module for Python?)

> > Is there something you can't do with PEP 302-style import hooks?
> 
> My impression with PEP 302 is that it is really meant if you actually want to import something in the end and add it to `sys.modules`. This is *not* the case here.
> 
> I tried to implement this with PEP 302 at first and it didn't work. Maybe there is some possibility to get it to work somehow, but I'm convinced that replacing `__import__` is the simplest solution.

I'm definitely not convinced but I'd have to see what you tried and why it didn't work?



---

archive/issue_comments_313364.json:
```json
{
    "body": "Replying to [comment:31 jdemeyer]:\n> Replying to [comment:29 embray]:\n> > The context manager might not be necessary either\n> \n> Which syntax would you propose, keeping in mind that we want to allow optional arguments like\n> {{{\n> with _lazyimport_(deprecation=12345):\n>     from ... import ...\n> }}}\n> \n> I'm honestly open for suggestions here.\n\nRight, this is another point in favor of the context manager construct.  The more I look at this I think it's very useful.  There are other ways one might do this globally for a module, but if you want to tweak options on a contextual basis this makes some sense.\n\nI think my only concern is it's not very transparent.  It might be nice to have a way to mark a particular module to just always be lazy-imported because it is known to be involved in import cycles (e.g. `sage.rings.integer_ring`).  That way someone using the module doesn't have to carefully specify that it should be lazy-imported.",
    "created_at": "2017-04-06T15:34:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313364",
    "user": "https://github.com/embray"
}
```

Replying to [comment:31 jdemeyer]:
> Replying to [comment:29 embray]:
> > The context manager might not be necessary either
> 
> Which syntax would you propose, keeping in mind that we want to allow optional arguments like
> {{{
> with _lazyimport_(deprecation=12345):
>     from ... import ...
> }}}
> 
> I'm honestly open for suggestions here.

Right, this is another point in favor of the context manager construct.  The more I look at this I think it's very useful.  There are other ways one might do this globally for a module, but if you want to tweak options on a contextual basis this makes some sense.

I think my only concern is it's not very transparent.  It might be nice to have a way to mark a particular module to just always be lazy-imported because it is known to be involved in import cycles (e.g. `sage.rings.integer_ring`).  That way someone using the module doesn't have to carefully specify that it should be lazy-imported.



---

archive/issue_comments_313365.json:
```json
{
    "body": "Replying to [comment:32 embray]:\n> PEP 302 itself for one.  Plus my own experience with more complex import scenarios (ever try to import an [IRAF](http://iraf.noao.edu/) module for Python?)\n\nI simply think that PEP 302 and overriding `__import__` solve different problems. PEP 302 solves the problem that you have an actual module somewhere which needs to be imported, but that you need to do something special to find the module (I think of `pyximport` which automatically compiles Cython code or `setuptools` unpacking eggs).\n\nOverriding `__import__` essentially allows you to syntactically replace the `import` statement with custom code, which is very much what we want to do with lazy imports.\n\nI would also argue that the current code dealing with overriding `__import__` is pretty simple, so I don't see what PEP 302 could add.",
    "created_at": "2017-04-06T18:03:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313365",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:32 embray]:
> PEP 302 itself for one.  Plus my own experience with more complex import scenarios (ever try to import an [IRAF](http://iraf.noao.edu/) module for Python?)

I simply think that PEP 302 and overriding `__import__` solve different problems. PEP 302 solves the problem that you have an actual module somewhere which needs to be imported, but that you need to do something special to find the module (I think of `pyximport` which automatically compiles Cython code or `setuptools` unpacking eggs).

Overriding `__import__` essentially allows you to syntactically replace the `import` statement with custom code, which is very much what we want to do with lazy imports.

I would also argue that the current code dealing with overriding `__import__` is pretty simple, so I don't see what PEP 302 could add.



---

archive/issue_comments_313366.json:
```json
{
    "body": "Replying to [comment:29 embray]:\n> this could be done with import hooks, and none of the stuff with threads should be necessary.\n\n\"the stuff with threads\" is needed to support the context manager because it changes a global variable `__builtin__.__import__`. PEP 302 wouldn't make a difference for this because it also uses global variables like `sys.meta_path`.",
    "created_at": "2017-04-06T18:10:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313366",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:29 embray]:
> this could be done with import hooks, and none of the stuff with threads should be necessary.

"the stuff with threads" is needed to support the context manager because it changes a global variable `__builtin__.__import__`. PEP 302 wouldn't make a difference for this because it also uses global variables like `sys.meta_path`.



---

archive/issue_comments_313367.json:
```json
{
    "body": "Replying to [comment:33 embray]:\n> It might be nice to have a way to mark a particular module to just always be lazy-imported\n\nThat would be a completely different way to deal with lazy imports. I can't say at this point whether that would be a good or bad idea or how it should be implemented.",
    "created_at": "2017-04-06T18:14:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313367",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:33 embray]:
> It might be nice to have a way to mark a particular module to just always be lazy-imported

That would be a completely different way to deal with lazy imports. I can't say at this point whether that would be a good or bad idea or how it should be implemented.



---

archive/issue_comments_313368.json:
```json
{
    "body": "Replying to [comment:21 jdemeyer]:\n> Regarding thread-safety, the only thing that we cannot protect against is another thread also changing `__builtin__.__import__`. If you are willing to live with that, I think it's possible to fix other thread issues.\n\nAs usual, lack of thread-safety is a canary for general unintended side-effects that in a highly dynamic environment such as python can also screw things up in the same thread:\n\nWhatever code is wrapped inside the \"with lazyimport\" now needs to ensure it doesn't trigger other code to execute that happens to rely on \"import\" meaning what it usually means in python. That's a very hard, non-local restriction to enforce. So I think changing a global binding in this way (which is non-transparent wrt the normal usage) is a no-go. You basically end up with a context in which the only legal command is `import` or `from .. import` (and even there, with the hooks available in the python import system, do you have full control over what code gets executed?",
    "created_at": "2017-04-06T19:28:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313368",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:21 jdemeyer]:
> Regarding thread-safety, the only thing that we cannot protect against is another thread also changing `__builtin__.__import__`. If you are willing to live with that, I think it's possible to fix other thread issues.

As usual, lack of thread-safety is a canary for general unintended side-effects that in a highly dynamic environment such as python can also screw things up in the same thread:

Whatever code is wrapped inside the "with lazyimport" now needs to ensure it doesn't trigger other code to execute that happens to rely on "import" meaning what it usually means in python. That's a very hard, non-local restriction to enforce. So I think changing a global binding in this way (which is non-transparent wrt the normal usage) is a no-go. You basically end up with a context in which the only legal command is `import` or `from .. import` (and even there, with the hooks available in the python import system, do you have full control over what code gets executed?



---

archive/issue_comments_313369.json:
```json
{
    "body": "Replying to [comment:34 jdemeyer]:\n> Overriding `__import__` essentially allows you to syntactically replace the `import` statement with custom code, which is very much what we want to do with lazy imports.\n\nIndeed. A lazy \"import module\" can  be done through loader hooks, and python3 even has an example class for doing that.\n\nIt's the lazy \"from module import object\" that is tricky to do, and for which it seems `__import__` is the right hook (there is a \"from\" list there. The other import hooks don't seem to have that info).\nIncidentally, that is also the more problematic thing to do and should probably be generally avoided. It leads to proxy objects that easily end up in places where they cannot remove themselves.",
    "created_at": "2017-04-06T19:33:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313369",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:34 jdemeyer]:
> Overriding `__import__` essentially allows you to syntactically replace the `import` statement with custom code, which is very much what we want to do with lazy imports.

Indeed. A lazy "import module" can  be done through loader hooks, and python3 even has an example class for doing that.

It's the lazy "from module import object" that is tricky to do, and for which it seems `__import__` is the right hook (there is a "from" list there. The other import hooks don't seem to have that info).
Incidentally, that is also the more problematic thing to do and should probably be generally avoided. It leads to proxy objects that easily end up in places where they cannot remove themselves.



---

archive/issue_comments_313370.json:
```json
{
    "body": "Replying to [comment:37 nbruin]:\n> Whatever code is wrapped inside the \"with lazyimport\" now needs to ensure it doesn't trigger other code to execute that happens to rely on \"import\" meaning what it usually means in python.\n\nIf that code just executes an `import` statement and nothing else (which is how this is intented), there should be no problem. I intent this to be used as\n\n```\n...some code...\nwith _lazyimport_:\n    from sage.rings.integer import ZZ\n...some code...\n```\n\nnot\n\n```\nwith _lazyimport_:\n    ...some code...\n    from sage.rings.integer import ZZ\n    ...some code...\n```\n\n\n> and even there, with the hooks available in the python import system, do you have full control over what code gets executed?\n\nYes because those other hooks won't be called.",
    "created_at": "2017-04-06T20:14:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313370",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:37 nbruin]:
> Whatever code is wrapped inside the "with lazyimport" now needs to ensure it doesn't trigger other code to execute that happens to rely on "import" meaning what it usually means in python.

If that code just executes an `import` statement and nothing else (which is how this is intented), there should be no problem. I intent this to be used as

```
...some code...
with _lazyimport_:
    from sage.rings.integer import ZZ
...some code...
```

not

```
with _lazyimport_:
    ...some code...
    from sage.rings.integer import ZZ
    ...some code...
```


> and even there, with the hooks available in the python import system, do you have full control over what code gets executed?

Yes because those other hooks won't be called.



---

archive/issue_comments_313371.json:
```json
{
    "body": "Resolution: wontfix",
    "created_at": "2017-04-06T20:15:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313371",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: wontfix



---

archive/issue_comments_313372.json:
```json
{
    "body": "Anyway, with 2 people clearly against my idea, I will stop fighting...",
    "created_at": "2017-04-06T20:15:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313372",
    "user": "https://github.com/jdemeyer"
}
```

Anyway, with 2 people clearly against my idea, I will stop fighting...



---

archive/issue_comments_313373.json:
```json
{
    "body": "Once you implement lazy imports with your hypothetical fix using PEP 302, remember to fix #15648 and #20626 too.",
    "created_at": "2017-04-06T20:22:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313373",
    "user": "https://github.com/jdemeyer"
}
```

Once you implement lazy imports with your hypothetical fix using PEP 302, remember to fix #15648 and #20626 too.



---

archive/issue_comments_313374.json:
```json
{
    "body": "And maybe #21636 too, while you're at it.",
    "created_at": "2017-04-06T20:24:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313374",
    "user": "https://github.com/jdemeyer"
}
```

And maybe #21636 too, while you're at it.



---

archive/issue_comments_313375.json:
```json
{
    "body": "...which should eventually lead to a fix for #22747 which I need for https://github.com/OpenDreamKit/OpenDreamKit/issues/87",
    "created_at": "2017-04-06T20:25:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313375",
    "user": "https://github.com/jdemeyer"
}
```

...which should eventually lead to a fix for #22747 which I need for https://github.com/OpenDreamKit/OpenDreamKit/issues/87



---

archive/issue_comments_313376.json:
```json
{
    "body": "Just to know where we stand, let me try to summarize the pros and cons of my approach. I'll try to do this objectively. It will at least allow to compare different approaches.\n\nNew features compared to the old `lazy_import`:\n\n1. Support Python and Cython (imports in Cython work the same way as plain Python, so this is true for anything which hooks the import system).\n\n2. Simple syntax: an ordinary `import` statement inside a `with _lazyimport_` block.\n\n3. Relative and absolute imports are supported.\n\n\nExisting features from `lazy_import` which are kept:\n\n4. Support for PEP 302 (a module which needs a PEP 302 loader can be lazy imported).\n\n5. Support for optional arguments like `deprecation`.\n\n6. Support for `from ... import *`.\n\n7. Automatic replacement of `LazyImport` in a global namespace by the actual imported object.\n\n8. Existing `lazy_import`s can be easily converted to the new `with _lazyimport_`, preserving all features.\n\n\nCons:\n\n9. Only `from ... import ...` is supported, not `import ...`\n\n10. One should be careful not to run arbitrary code inside a `with _lazyimport_` block.\n\n21. It's not implemented using PEP 302 (personally, I don't think that's an issue, but you guys seem to think so).\n\nFinally, let me mention that #21636 is the main reason to work on this, for which in particular proper Cython support for lazy imports is needed.",
    "created_at": "2017-04-07T07:55:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313376",
    "user": "https://github.com/jdemeyer"
}
```

Just to know where we stand, let me try to summarize the pros and cons of my approach. I'll try to do this objectively. It will at least allow to compare different approaches.

New features compared to the old `lazy_import`:

1. Support Python and Cython (imports in Cython work the same way as plain Python, so this is true for anything which hooks the import system).

2. Simple syntax: an ordinary `import` statement inside a `with _lazyimport_` block.

3. Relative and absolute imports are supported.


Existing features from `lazy_import` which are kept:

4. Support for PEP 302 (a module which needs a PEP 302 loader can be lazy imported).

5. Support for optional arguments like `deprecation`.

6. Support for `from ... import *`.

7. Automatic replacement of `LazyImport` in a global namespace by the actual imported object.

8. Existing `lazy_import`s can be easily converted to the new `with _lazyimport_`, preserving all features.


Cons:

9. Only `from ... import ...` is supported, not `import ...`

10. One should be careful not to run arbitrary code inside a `with _lazyimport_` block.

21. It's not implemented using PEP 302 (personally, I don't think that's an issue, but you guys seem to think so).

Finally, let me mention that #21636 is the main reason to work on this, for which in particular proper Cython support for lazy imports is needed.



---

archive/issue_comments_313377.json:
```json
{
    "body": "I also remind you about #22755, which makes some fixes to the existing lazy imports. If you do work on lazy imports, please do so on top of #22755.",
    "created_at": "2017-04-07T08:33:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313377",
    "user": "https://github.com/jdemeyer"
}
```

I also remind you about #22755, which makes some fixes to the existing lazy imports. If you do work on lazy imports, please do so on top of #22755.



---

archive/issue_comments_313378.json:
```json
{
    "body": "> PEP 302 wouldn't make a difference for this because it also uses global variables like sys.meta_path\n\nYou wouldn't be manipulating `sys.meta_path` in general, except very early on in `sage.__init__` for example.",
    "created_at": "2017-04-07T09:42:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313378",
    "user": "https://github.com/embray"
}
```

> PEP 302 wouldn't make a difference for this because it also uses global variables like sys.meta_path

You wouldn't be manipulating `sys.meta_path` in general, except very early on in `sage.__init__` for example.



---

archive/issue_comments_313379.json:
```json
{
    "body": "I think I understand better now how this is really *only* trying to override the `from a import b` syntax, which is why you are targeting `__import__` itself.  Though really, the problem with circular imports is the same whether one is using the `import foo` syntax or the `from foo import ...` syntax.  \n\nSo that takes me back to thinking that some modules should always use some kind of lazy-import mechanism.  It's better overall to design things to avoid circular imports in the first place, but it's admittedly tricky for some fundamental modules (like rationals are defined in terms of integers, but operations on integers can return rationals, or need to be able to work with rationals, etc.).  That's just one example it it seems to be one of the most pervasive.\n\nNow, supporting `from foo import ...` is still tricky since it needs to be supported via a proxy object, but already exists and can be reused / improved on.  The issues you mentioned like #20626 seem like issues with the implementation of the proxy itself. (I also wonder if, rather than using our own proxy implementation, it would be useful to use something from the community like https://github.com/ionelmc/python-lazy-object-proxy; not sure how well that works with Sage's builtin types though).\n\n\n----\n\n\nOn a slightly different topic, I don't quite understand why the \"deprecation\" feature of the existing `lazy_import` needs to be implemented directly through the import syntax or via a wrapper around it.  Similarly for the \"startup guard\" functionality.  Instead, these features could be implemented if *all* modules in *sage* were wrapped in a custom `Module` subclass/wrapper.  Although I haven't tested as such, I think there'd be little noticeable overhead to doing so.  Then we can add simple syntax at the module level for specifying this behavior.  For example, `sage.combinat.crystals.all` contains a fair number of deprecations.  Instead of:\n\n\n```\nlazy_import('sage.combinat.crystals.letters',\n            'CrystalOfLetters',\n            deprecation=(15882, \"this is being removed from the global namespace. Use crystals.Letters instead\"))\n\nlazy_import('sage.combinat.crystals.fast_crystals',\n            'FastCrystal',\n            deprecation=(15882, \"this is being removed from the global namespace. Use crystals.FastRankTwo instead\"))\n\nlazy_import('sage.combinat.crystals.highest_weight_crystals',\n            'HighestWeightCrystal',\n            deprecation=(15882, \"this is being removed from the global namespace. Use crystals.HighestWeight instead\"))\n```\n\n\nthis could look something like:\n\n\n```\n__sage_deprecations__ = [\n    ('sage.combinat.crystals.' + mod_name, cls_name, 15822, \"this is being removed from the global namespace. Use crystals. %s instead\" % cls_name) for mod_name, cls_name in [\n        ('letters', 'CrystalOfLetters'),\n        ('fast_crystals', 'FastCrystal'),\n        ('highest_weight_crystals', 'HeighestWeightCrystals'),\n        ...\n    ]\n]\n```\n\n\nA custom module wrapper would be able handle imports of objects listed in `__sage_deprecations__` (as I'm calling it) through `__getattribute__` and return proxies for those objects, whereas the `sage.combinat.crystals.catalog` module would not have `__sage_deprecations__` and thus would supply the normal, non-proxied objects.\n\nI feel like this is a clearer and more explicit declarative approach to how some attributes of some modules should be handled, rather than mucking with the import system every single time this feature is needed.",
    "created_at": "2017-04-07T11:17:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313379",
    "user": "https://github.com/embray"
}
```

I think I understand better now how this is really *only* trying to override the `from a import b` syntax, which is why you are targeting `__import__` itself.  Though really, the problem with circular imports is the same whether one is using the `import foo` syntax or the `from foo import ...` syntax.  

So that takes me back to thinking that some modules should always use some kind of lazy-import mechanism.  It's better overall to design things to avoid circular imports in the first place, but it's admittedly tricky for some fundamental modules (like rationals are defined in terms of integers, but operations on integers can return rationals, or need to be able to work with rationals, etc.).  That's just one example it it seems to be one of the most pervasive.

Now, supporting `from foo import ...` is still tricky since it needs to be supported via a proxy object, but already exists and can be reused / improved on.  The issues you mentioned like #20626 seem like issues with the implementation of the proxy itself. (I also wonder if, rather than using our own proxy implementation, it would be useful to use something from the community like https://github.com/ionelmc/python-lazy-object-proxy; not sure how well that works with Sage's builtin types though).


----


On a slightly different topic, I don't quite understand why the "deprecation" feature of the existing `lazy_import` needs to be implemented directly through the import syntax or via a wrapper around it.  Similarly for the "startup guard" functionality.  Instead, these features could be implemented if *all* modules in *sage* were wrapped in a custom `Module` subclass/wrapper.  Although I haven't tested as such, I think there'd be little noticeable overhead to doing so.  Then we can add simple syntax at the module level for specifying this behavior.  For example, `sage.combinat.crystals.all` contains a fair number of deprecations.  Instead of:


```
lazy_import('sage.combinat.crystals.letters',
            'CrystalOfLetters',
            deprecation=(15882, "this is being removed from the global namespace. Use crystals.Letters instead"))

lazy_import('sage.combinat.crystals.fast_crystals',
            'FastCrystal',
            deprecation=(15882, "this is being removed from the global namespace. Use crystals.FastRankTwo instead"))

lazy_import('sage.combinat.crystals.highest_weight_crystals',
            'HighestWeightCrystal',
            deprecation=(15882, "this is being removed from the global namespace. Use crystals.HighestWeight instead"))
```


this could look something like:


```
__sage_deprecations__ = [
    ('sage.combinat.crystals.' + mod_name, cls_name, 15822, "this is being removed from the global namespace. Use crystals. %s instead" % cls_name) for mod_name, cls_name in [
        ('letters', 'CrystalOfLetters'),
        ('fast_crystals', 'FastCrystal'),
        ('highest_weight_crystals', 'HeighestWeightCrystals'),
        ...
    ]
]
```


A custom module wrapper would be able handle imports of objects listed in `__sage_deprecations__` (as I'm calling it) through `__getattribute__` and return proxies for those objects, whereas the `sage.combinat.crystals.catalog` module would not have `__sage_deprecations__` and thus would supply the normal, non-proxied objects.

I feel like this is a clearer and more explicit declarative approach to how some attributes of some modules should be handled, rather than mucking with the import system every single time this feature is needed.



---

archive/issue_comments_313380.json:
```json
{
    "body": "Just out of curiosity, I'm going to take a stab at replacing our proxy with `lazy_object_proxy` (without any other changes to lazy_import) and see how far I can get, or if it can resolve any of the known bugs.",
    "created_at": "2017-04-07T12:12:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313380",
    "user": "https://github.com/embray"
}
```

Just out of curiosity, I'm going to take a stab at replacing our proxy with `lazy_object_proxy` (without any other changes to lazy_import) and see how far I can get, or if it can resolve any of the known bugs.



---

archive/issue_comments_313381.json:
```json
{
    "body": "Replying to [comment:47 embray]:\n> I think I understand better now how this is really *only* trying to override the `from a import b` syntax, which is why you are targeting `__import__` itself.  Though really, the problem with circular imports is the same whether one is using the `import foo` syntax or the `from foo import ...` syntax.  \n\nNo, it's not. Python is completely fine with circular imports. The problem arises when there is a circular access of module attributes *during load time*. The problem with \"from foo import ...\" is that it automatically leads to a module attribute access during load time.\n\nWithout \"from foo import ...\" you'd have to write something like\n\n```\nimport A\n\nc=A.b+1\n```\n\nwhich is very unlikely to happen, since usually at load time only declarations are executed.\n\nFor that kind of symbols we would basically just need\n\n```\n#instead of from A import b\nimport A\nforward_binding(target=\"b\",namespace=globals(),from=A,from_name=\"b\")\n```\n\nwhere forward_binding could be resolved as soon as A is initialized. The proxy doesn't have to hang around until first used, as with lazy-import. I'm not sure we have the right hooks to do this, but if there are I think we could change __import__ to allow one more level of circularity (namely, circularity for \"from A import b\" provided that A.b doesn't get accessed during load time).",
    "created_at": "2017-04-07T18:53:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313381",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:47 embray]:
> I think I understand better now how this is really *only* trying to override the `from a import b` syntax, which is why you are targeting `__import__` itself.  Though really, the problem with circular imports is the same whether one is using the `import foo` syntax or the `from foo import ...` syntax.  

No, it's not. Python is completely fine with circular imports. The problem arises when there is a circular access of module attributes *during load time*. The problem with "from foo import ..." is that it automatically leads to a module attribute access during load time.

Without "from foo import ..." you'd have to write something like

```
import A

c=A.b+1
```

which is very unlikely to happen, since usually at load time only declarations are executed.

For that kind of symbols we would basically just need

```
#instead of from A import b
import A
forward_binding(target="b",namespace=globals(),from=A,from_name="b")
```

where forward_binding could be resolved as soon as A is initialized. The proxy doesn't have to hang around until first used, as with lazy-import. I'm not sure we have the right hooks to do this, but if there are I think we could change __import__ to allow one more level of circularity (namely, circularity for "from A import b" provided that A.b doesn't get accessed during load time).



---

archive/issue_comments_313382.json:
```json
{
    "body": "Replying to [comment:47 embray]:\n> The issues you mentioned like #20626 seem like issues with the implementation of the proxy itself.\n\nYes and I **had** a fix for #15648 and for #20626 (based on this ticket, so those fixes are no longer valid).",
    "created_at": "2017-04-07T20:07:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313382",
    "user": "https://github.com/jdemeyer"
}
```

Replying to [comment:47 embray]:
> The issues you mentioned like #20626 seem like issues with the implementation of the proxy itself.

Yes and I **had** a fix for #15648 and for #20626 (based on this ticket, so those fixes are no longer valid).



---

archive/issue_comments_313383.json:
```json
{
    "body": "Replying to [comment:39 jdemeyer]:\n> > and even there, with the hooks available in the python import system, do you have full control over what code gets executed?\n> \n> Yes because those other hooks won't be called.\n\nI think there might be a more reliable way: When `__import__` gets called, it does get a \"globals\" parameter with it as the scope on which to work. We can park our state whether inputs are to be lazy there:\n\n```\nbuiltin.__import__=new_import\nlazy_import=True\nfrom A import a\nlazy_import=False\nimport B\n```\n\ni.e., the new import uses a binding in the relevant scope to see if it needs to intercept imports and make them lazy or whether they should be processed as normal.\n\nThat way, the new import routine would be transparent for scopes where lazy_import isn't being used.\n\nBased on that infrastructure, a context would be just fine. It would be about toggling a flag in the relevant scope rather than changing a global variable.\n\nIt does mean we'd need to have our \"__import__\" wrapper in place all the time, because swapping it *out* would still be sensitive to scoping and threading issues.",
    "created_at": "2017-04-07T20:11:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313383",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:39 jdemeyer]:
> > and even there, with the hooks available in the python import system, do you have full control over what code gets executed?
> 
> Yes because those other hooks won't be called.

I think there might be a more reliable way: When `__import__` gets called, it does get a "globals" parameter with it as the scope on which to work. We can park our state whether inputs are to be lazy there:

```
builtin.__import__=new_import
lazy_import=True
from A import a
lazy_import=False
import B
```

i.e., the new import uses a binding in the relevant scope to see if it needs to intercept imports and make them lazy or whether they should be processed as normal.

That way, the new import routine would be transparent for scopes where lazy_import isn't being used.

Based on that infrastructure, a context would be just fine. It would be about toggling a flag in the relevant scope rather than changing a global variable.

It does mean we'd need to have our "__import__" wrapper in place all the time, because swapping it *out* would still be sensitive to scoping and threading issues.



---

archive/issue_comments_313384.json:
```json
{
    "body": "I still think that messing so much with imports for what you want to accomplish is overkill.  My point in my last comment was that whether you use the `import foo` or `from import foo ...` syntax the first thing that happens is `foo` is imported, possibly through import hooks, and those hooks can always wrap the `Module` object for `foo` in a proxy that can handle lazy imports.\n\nYou could even make the module wrapper itself a context manager for handling lazy imports.  I don't know that this is the clearest syntax but it's an idea:\n\n\n```\nimport foo\nwith foo.__lazy_import__:\n    from foo import a\n    from foo import b\n```\n\n\nIn this case `a` and `b` are `LazyImport` proxies.\n\nI think the 'deprecation warning' aspect of `lazy_import` can be handled through a separate mechanism as explained above.\n\nMy experiment in rewriting `LazyImport` worked too--there's just one minor detail with regard to how `__class__` is handled that I need to fix but it's 11:00 p.m. on Friday night here so I'm gonna call it quits until Monday :)",
    "created_at": "2017-04-07T20:52:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313384",
    "user": "https://github.com/embray"
}
```

I still think that messing so much with imports for what you want to accomplish is overkill.  My point in my last comment was that whether you use the `import foo` or `from import foo ...` syntax the first thing that happens is `foo` is imported, possibly through import hooks, and those hooks can always wrap the `Module` object for `foo` in a proxy that can handle lazy imports.

You could even make the module wrapper itself a context manager for handling lazy imports.  I don't know that this is the clearest syntax but it's an idea:


```
import foo
with foo.__lazy_import__:
    from foo import a
    from foo import b
```


In this case `a` and `b` are `LazyImport` proxies.

I think the 'deprecation warning' aspect of `lazy_import` can be handled through a separate mechanism as explained above.

My experiment in rewriting `LazyImport` worked too--there's just one minor detail with regard to how `__class__` is handled that I need to fix but it's 11:00 p.m. on Friday night here so I'm gonna call it quits until Monday :)



---

archive/issue_comments_313385.json:
```json
{
    "body": "Can we maybe discuss exactly what the use cases are for lazy-import?\n\nTo me the *primary* use case--the one that really matters--is just breaking circular imports at startup time.  I've never needed something like lazy imports to get around that before, but I admit some of the circular definitions in Sage are vexing and hard to avoid, especially in Cygwin modules where we have less control over the order in which module-level statements are executed with respect to each other.  So that's one case.\n\nThe other two, as far as I can tell, are:\n\n1) Issuing deprecation warnings for imports of some names from modules they shouldn't be directly imported from.\n\n2) Issuing a warning (or error as in #22755) if some proxied lazy import gets resolved during initial startup.\n\nI don't really much see the case for the latter of the two.  If the main use case for lazy imports (and note: I'm not necessarily claiming that's the case, that's just my understanding) then who cares if gets resolved at startup time?  If it does, any nothing breaks, then it doesn't need to be a lazy import in the first place (having this feature optionally for debugging purposes is nice though).",
    "created_at": "2017-04-11T09:31:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313385",
    "user": "https://github.com/embray"
}
```

Can we maybe discuss exactly what the use cases are for lazy-import?

To me the *primary* use case--the one that really matters--is just breaking circular imports at startup time.  I've never needed something like lazy imports to get around that before, but I admit some of the circular definitions in Sage are vexing and hard to avoid, especially in Cygwin modules where we have less control over the order in which module-level statements are executed with respect to each other.  So that's one case.

The other two, as far as I can tell, are:

1) Issuing deprecation warnings for imports of some names from modules they shouldn't be directly imported from.

2) Issuing a warning (or error as in #22755) if some proxied lazy import gets resolved during initial startup.

I don't really much see the case for the latter of the two.  If the main use case for lazy imports (and note: I'm not necessarily claiming that's the case, that's just my understanding) then who cares if gets resolved at startup time?  If it does, any nothing breaks, then it doesn't need to be a lazy import in the first place (having this feature optionally for debugging purposes is nice though).



---

archive/issue_comments_313386.json:
```json
{
    "body": "Or are there also cases where lazy import is used for performance reasons, and if so what are some examples of that?",
    "created_at": "2017-04-11T09:34:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313386",
    "user": "https://github.com/embray"
}
```

Or are there also cases where lazy import is used for performance reasons, and if so what are some examples of that?



---

archive/issue_comments_313387.json:
```json
{
    "body": "I would say there are two important use cases:\n\n1. as you mentioned, breaking circular imports.\n\n2. importing less stuff at startup to decrease startup time. For example, if you don't care about differential geometry, then it would be a waste of time to import all differential-geometry-related modules when Sage starts up. However, we do want the relevant classes to appear in the global namespace, so we use a lazy import. The `at_startup` argument is very relevant here, since a lazy import resolved at startup wouldn't help with this.",
    "created_at": "2017-04-11T09:40:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313387",
    "user": "https://github.com/jdemeyer"
}
```

I would say there are two important use cases:

1. as you mentioned, breaking circular imports.

2. importing less stuff at startup to decrease startup time. For example, if you don't care about differential geometry, then it would be a waste of time to import all differential-geometry-related modules when Sage starts up. However, we do want the relevant classes to appear in the global namespace, so we use a lazy import. The `at_startup` argument is very relevant here, since a lazy import resolved at startup wouldn't help with this.



---

archive/issue_comments_313388.json:
```json
{
    "body": "Got it--thanks for clarifying.",
    "created_at": "2017-04-11T09:43:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313388",
    "user": "https://github.com/embray"
}
```

Got it--thanks for clarifying.



---

archive/issue_comments_313389.json:
```json
{
    "body": "TODO: discuss lazy imports next week too with `@`embray.",
    "created_at": "2017-04-20T09:39:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313389",
    "user": "https://github.com/jdemeyer"
}
```

TODO: discuss lazy imports next week too with `@`embray.



---

archive/issue_comments_313390.json:
```json
{
    "body": "Good news for myself: I think I can get #22747 to work without requiring this.",
    "created_at": "2017-04-21T15:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313390",
    "user": "https://github.com/jdemeyer"
}
```

Good news for myself: I think I can get #22747 to work without requiring this.



---

archive/issue_comments_313391.json:
```json
{
    "body": "Is that the issue you refer to when you mean \"works with Cython\"?",
    "created_at": "2017-04-21T17:23:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/22515",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/22515#issuecomment-313391",
    "user": "https://github.com/embray"
}
```

Is that the issue you refer to when you mean "works with Cython"?
