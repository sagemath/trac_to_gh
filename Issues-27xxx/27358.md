# Issue 27358: Memory leak in sage.categories.action.Action

archive/issues_027121.json:
```json
{
    "assignees": [],
    "body": "\n```\nsage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap\n....: G = AbelianGroupGap([2,3,4,5])\n....: \nsage: aut = G.automorphism_group()\nsage: for k in range(100):\n....:     s = aut.subgroup([aut.random_element() for k in range(3)])\n....:     \nsage: st = type(s)\nsage: del s,aut,G\nsage: import gc\nsage: gc.collect()\n56\nsage: len([v for v in gc.get_objects() if type(v) == st])\n100\n```\n\nCC:  @tscrim @nbruin @jdemeyer\n\nBranch/Commit: **[u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries) @ [a2b3bc2](https://github.com/sagemath/sagetrac-mirror/commit/a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5)**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/27358_\n\n",
    "created_at": "2019-02-26T10:46:45Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/component%3A%20memleak",
        "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/needs%20work"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.8",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Memory leak in sage.categories.action.Action",
    "type": "issue",
    "updated_at": "2022-09-19T18:58:47Z",
    "url": "https://github.com/sagemath/sage/issues/27358",
    "user": "https://github.com/simonbrandhorst"
}
```

```
sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
....: G = AbelianGroupGap([2,3,4,5])
....: 
sage: aut = G.automorphism_group()
sage: for k in range(100):
....:     s = aut.subgroup([aut.random_element() for k in range(3)])
....:     
sage: st = type(s)
sage: del s,aut,G
sage: import gc
sage: gc.collect()
56
sage: len([v for v in gc.get_objects() if type(v) == st])
100
```

CC:  @tscrim @nbruin @jdemeyer

Branch/Commit: **[u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries) @ [a2b3bc2](https://github.com/sagemath/sagetrac-mirror/commit/a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5)**

_Issue created by migration from https://trac.sagemath.org/ticket/27358_





---

archive/issue_events_357627.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2019-02-26T10:46:45Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-8.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357627"
}
```



---

archive/issue_events_357628.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2019-02-26T10:46:45Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "label": "https://github.com/sagemath/sage/labels/component%3A%20memleak",
    "label_color": "000080",
    "label_name": "component: memleak",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357628"
}
```



---

archive/issue_events_357629.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2019-02-26T10:46:45Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "label": "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357629"
}
```



---

archive/issue_events_357630.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2019-02-26T10:46:45Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357630"
}
```



---

archive/issue_comments_425908.json:
```json
{
    "body": "Branch: **[u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups)**",
    "created_at": "2019-02-26T10:51:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425908",
    "user": "https://github.com/simonbrandhorst"
}
```

Branch: **[u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups)**



---

archive/issue_comments_425909.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">Comment 2</div>\n\nAfter removing `UniqueRepresentation` the memory leak is fixed.\n\n```\nsage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGr\n....: oupGap\n....: G = AbelianGroupGap([2,3,4,5])\n....: \nsage: aut = G.automorphism_group()\nsage: for k in range(100):\n....:     s = aut.subgroup([aut.random_element() for k in range(3)])\n....:     \nsage: st = type(s)\nsage: del s,aut,G\nsage: import gc\nsage: gc.collect()\n167\nsage: [v for v in gc.get_objects() if type(v) == st]\n[]\n```\n\nI think that automorphism groups and especially their subgroups\nare too complex objects for unique representations. For Abelian groups that may be okay\nbut certainly in the non-commutative world unique representation does not work and has too little benefit.",
    "created_at": "2019-02-26T10:54:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425909",
    "user": "https://github.com/simonbrandhorst"
}
```

<div id="comment:2" align="right">Comment 2</div>

After removing `UniqueRepresentation` the memory leak is fixed.

```
sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGr
....: oupGap
....: G = AbelianGroupGap([2,3,4,5])
....: 
sage: aut = G.automorphism_group()
sage: for k in range(100):
....:     s = aut.subgroup([aut.random_element() for k in range(3)])
....:     
sage: st = type(s)
sage: del s,aut,G
sage: import gc
sage: gc.collect()
167
sage: [v for v in gc.get_objects() if type(v) == st]
[]
```

I think that automorphism groups and especially their subgroups
are too complex objects for unique representations. For Abelian groups that may be okay
but certainly in the non-commutative world unique representation does not work and has too little benefit.



---

archive/issue_comments_425910.json:
```json
{
    "body": "Commit: **[73a9207](https://github.com/sagemath/sagetrac-mirror/commit/73a9207bd005aeff843958bb03f03054b0b1dedd)**",
    "created_at": "2019-02-26T10:54:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425910",
    "user": "https://github.com/simonbrandhorst"
}
```

Commit: **[73a9207](https://github.com/sagemath/sagetrac-mirror/commit/73a9207bd005aeff843958bb03f03054b0b1dedd)**



---

archive/issue_events_357631.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2019-02-26T10:54:52Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357631"
}
```



---

archive/issue_comments_425911.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">Comment 4</div>\n\nThis comes at the price of pickling. It does not work anymore.\nRespectively, unpickling would just create isomorphic objects.\nFrom my point of view we can sacrifice pickling.\nWith the memory leak the class is unusable for any serious computation.",
    "created_at": "2019-02-26T11:29:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425911",
    "user": "https://github.com/simonbrandhorst"
}
```

<div id="comment:4" align="right">Comment 4</div>

This comes at the price of pickling. It does not work anymore.
Respectively, unpickling would just create isomorphic objects.
From my point of view we can sacrifice pickling.
With the memory leak the class is unusable for any serious computation.



---

archive/issue_comments_425912.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">Comment 5</div>\n\nSo there is not a memory leak as there is a small cache (I think it is an LRU cache) that goes on that stores 128 objects. If you run it with 200 elements, you will get\n\n```\nsage: len([v for v in gc.get_objects() if type(v) == st])\n128\n```\n\nWe can see that there is no memory leak in the code because there is no `@cached_method` being used and the data being passed is all 1 directional (i.e., no strong reference cycles). At least, this is my understanding of how things are working.",
    "created_at": "2019-02-27T05:16:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425912",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:5" align="right">Comment 5</div>

So there is not a memory leak as there is a small cache (I think it is an LRU cache) that goes on that stores 128 objects. If you run it with 200 elements, you will get

```
sage: len([v for v in gc.get_objects() if type(v) == st])
128
```

We can see that there is no memory leak in the code because there is no `@cached_method` being used and the data being passed is all 1 directional (i.e., no strong reference cycles). At least, this is my understanding of how things are working.



---

archive/issue_comments_425913.json:
```json
{
    "body": "Changed author from **Simon Brandhorst** to none",
    "created_at": "2019-02-27T05:16:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425913",
    "user": "https://github.com/tscrim"
}
```

Changed author from **Simon Brandhorst** to none



---

archive/issue_comments_425914.json:
```json
{
    "body": "Changed branch from **[u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups)** to none",
    "created_at": "2019-02-27T05:16:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425914",
    "user": "https://github.com/tscrim"
}
```

Changed branch from **[u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups)** to none



---

archive/issue_comments_425915.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">Comment 6</div>\n\nSo I am proposing closing this.",
    "created_at": "2019-02-27T05:16:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425915",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:6" align="right">Comment 6</div>

So I am proposing closing this.



---

archive/issue_events_357632.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2019-02-27T05:16:38Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-8.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357632"
}
```



---

archive/issue_events_357633.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2019-02-27T05:16:38Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "label": "https://github.com/sagemath/sage/labels/p3%20%E2%80%93%20major",
    "label_color": "ffbb00",
    "label_name": "p3 \u2013 major",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357633"
}
```



---

archive/issue_events_357634.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2019-02-27T05:16:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "label": "https://github.com/sagemath/sage/labels/invalid",
    "label_color": "a6a6a6",
    "label_name": "invalid",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357634"
}
```



---

archive/issue_comments_425916.json:
```json
{
    "body": "Changed commit from **[73a9207](https://github.com/sagemath/sagetrac-mirror/commit/73a9207bd005aeff843958bb03f03054b0b1dedd)** to none",
    "created_at": "2019-02-27T05:16:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425916",
    "user": "https://github.com/tscrim"
}
```

Changed commit from **[73a9207](https://github.com/sagemath/sagetrac-mirror/commit/73a9207bd005aeff843958bb03f03054b0b1dedd)** to none



---

archive/issue_comments_425917.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">Comment 7</div>\n\nSo an `@`cached_method together with a unique representation would cause memory leaks?",
    "created_at": "2019-02-27T08:59:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425917",
    "user": "https://github.com/simonbrandhorst"
}
```

<div id="comment:7" align="right">Comment 7</div>

So an `@`cached_method together with a unique representation would cause memory leaks?



---

archive/issue_comments_425918.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">Comment 8</div>\n\nNot a `@cached_method` in a subclass of `UniqueRepresentation`. But I am pretty sure a `@cached_method` that creates a `UniqueRepresentation` `UR` whose input includes `self` ends up being a memory leak (because then `self` is a strong global reference as a key to `UR`, but `UR` has a strong reference being the output of `@cached_method`). (This also has a code smell because of the double-caching anyways.)\n\nIn some sense a `UniqueRepresentation` and `@cached_method` are the same as they use the same mechanism as `@cached_function` to store data.",
    "created_at": "2019-02-27T09:56:55Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425918",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:8" align="right">Comment 8</div>

Not a `@cached_method` in a subclass of `UniqueRepresentation`. But I am pretty sure a `@cached_method` that creates a `UniqueRepresentation` `UR` whose input includes `self` ends up being a memory leak (because then `self` is a strong global reference as a key to `UR`, but `UR` has a strong reference being the output of `@cached_method`). (This also has a code smell because of the double-caching anyways.)

In some sense a `UniqueRepresentation` and `@cached_method` are the same as they use the same mechanism as `@cached_function` to store data.



---

archive/issue_comments_425919.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">Comment 9</div>\n\nthank you for your time. I think I have located my memory leak now:\n\n```\nsage: import gc\nsage: for k in range(2,400):\n....:     m = matrix.diagonal([1,k])\n....:     L = IntegralLattice(m)\n....:     D = L.discriminant_group()\n....:     g = L.orthogonal_group().gen(0)\n....:     tmp = D.gen(0)*g;\n....:     \nsage: gc.collect()\n2182\nsage: len([v for v in gc.get_objects() if type(v) == type(D)])\n514\n```\nIt could be related to the cached method discriminant_group. But the memleak only happens with the action. Maybe I programmed things a bit smelly :-/ .",
    "created_at": "2019-02-27T10:38:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425919",
    "user": "https://github.com/simonbrandhorst"
}
```

<div id="comment:9" align="right">Comment 9</div>

thank you for your time. I think I have located my memory leak now:

```
sage: import gc
sage: for k in range(2,400):
....:     m = matrix.diagonal([1,k])
....:     L = IntegralLattice(m)
....:     D = L.discriminant_group()
....:     g = L.orthogonal_group().gen(0)
....:     tmp = D.gen(0)*g;
....:     
sage: gc.collect()
2182
sage: len([v for v in gc.get_objects() if type(v) == type(D)])
514
```
It could be related to the cached method discriminant_group. But the memleak only happens with the action. Maybe I programmed things a bit smelly :-/ .



---

archive/issue_comments_425920.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">Comment 10</div>\n\nOkay the root cause seems to be somewhere in the coercion system.\nAnd I found a way to release the memory however it seems to me like a bug.\n\n```\nsage: for k in range(2,10000):\n....:     m = matrix.diagonal([1,k])\n....:     L = IntegralLattice(m)\n....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)\n....:     tmp = L.an_element()*g\nsage: import gc\nsage: len([v for v in gc.get_objects() if type(v) == type(L)])\n9893\nsage: gc.collect()\n35563\nsage: len([v for v in gc.get_objects() if type(v) == type(L)])\n9892\nsage: cm = sage.structure.element.get_coercion_model()\nsage: cm.reset_cache()\nsage: gc.collect()\n2630471\nsage: len([v for v in gc.get_objects() if type(v) == type(L)])\n130\n```",
    "created_at": "2019-02-27T10:54:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425920",
    "user": "https://github.com/simonbrandhorst"
}
```

<div id="comment:10" align="right">Comment 10</div>

Okay the root cause seems to be somewhere in the coercion system.
And I found a way to release the memory however it seems to me like a bug.

```
sage: for k in range(2,10000):
....:     m = matrix.diagonal([1,k])
....:     L = IntegralLattice(m)
....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)
....:     tmp = L.an_element()*g
sage: import gc
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
9893
sage: gc.collect()
35563
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
9892
sage: cm = sage.structure.element.get_coercion_model()
sage: cm.reset_cache()
sage: gc.collect()
2630471
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
130
```



---

archive/issue_events_357635.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2019-02-27T11:07:24Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357635"
}
```



---

archive/issue_events_357636.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2019-02-27T11:07:24Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "label": "https://github.com/sagemath/sage/labels/needs%20work",
    "label_color": "ffff00",
    "label_name": "needs work",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357636"
}
```



---

archive/issue_comments_425921.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">Comment 11</div>\n\nOkay, we need to recycle this ticket.\n\nNils, I am cc-ing you on this ticket because of the memory leak. Jeroen because it might involve the coercion framework.\n\nI wonder if it has something to do with having an action, non-unique parents, but discriminant group being a `@cached_method`. It is too late here (Australia) for me to figure out a more minimal example and nothing obvious jumps out at me.",
    "created_at": "2019-02-27T11:07:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425921",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:11" align="right">Comment 11</div>

Okay, we need to recycle this ticket.

Nils, I am cc-ing you on this ticket because of the memory leak. Jeroen because it might involve the coercion framework.

I wonder if it has something to do with having an action, non-unique parents, but discriminant group being a `@cached_method`. It is too late here (Australia) for me to figure out a more minimal example and nothing obvious jumps out at me.



---

archive/issue_events_357637.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2019-02-27T16:03:50Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "title_is": "Memory leak in sage.groups.matrix_gps.isometries",
    "title_was": "Memory leak in automorphism groups of abelian groups",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357637"
}
```



---

archive/issue_comments_425922.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">Comment 12</div>\n\nIt has to do with the action.",
    "created_at": "2019-02-27T16:03:50Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425922",
    "user": "https://github.com/simonbrandhorst"
}
```

<div id="comment:12" align="right">Comment 12</div>

It has to do with the action.



---

archive/issue_comments_425923.json:
```json
{
    "body": "Branch: **[u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries)**",
    "created_at": "2019-02-27T17:00:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425923",
    "user": "https://github.com/simonbrandhorst"
}
```

Branch: **[u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries)**



---

archive/issue_comments_425924.json:
```json
{
    "body": "Commit: **[a2b3bc2](https://github.com/sagemath/sagetrac-mirror/commit/a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5)**",
    "created_at": "2019-02-27T17:03:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425924",
    "user": "https://github.com/simonbrandhorst"
}
```

Commit: **[a2b3bc2](https://github.com/sagemath/sagetrac-mirror/commit/a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5)**



---

archive/issue_comments_425925.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">Comment 14</div>\n\nHere is a fix. \nHowever, it involves calling the internal method\n`sage.structure.parent.Parent._unset_coercions_used`\nto be able to register an action. I am unsure of the consequences here.\nIs there a better way to tell the coercion model about the action?\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5\">a2b3bc2</a></td><td><code>deprecate arguments invariant_submodule and invariant_quotient_module</code></td></tr></table>\n",
    "created_at": "2019-02-27T17:03:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425925",
    "user": "https://github.com/simonbrandhorst"
}
```

<div id="comment:14" align="right">Comment 14</div>

Here is a fix. 
However, it involves calling the internal method
`sage.structure.parent.Parent._unset_coercions_used`
to be able to register an action. I am unsure of the consequences here.
Is there a better way to tell the coercion model about the action?

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5">a2b3bc2</a></td><td><code>deprecate arguments invariant_submodule and invariant_quotient_module</code></td></tr></table>




---

archive/issue_comments_425926.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">Comment 15</div>\n\nYou can get a graphical representation of the backref graph:\n\n```\nfor k in range(2,200):\n    m = matrix.diagonal([1,k])\n    L = IntegralLattice(m)\n    G = L.orthogonal_group([matrix.identity(2)])\n    g = G.0\n    if k == 2:\n        ID=id(G)\n    tmp = L.an_element()*g\nimport gc\ngc.collect()\nimport objgraph #that's a useful package for hunting memory leaks\nobjgraph.show_backrefs([g for  g in gc.get_objects() if id(g) == ID],max_depth=7).save(\"graph.dot\")\n```\n\nIt seems that the objects of type `FreeQuadraticModule_integer_symmetric` and `TorsionQuadraticModule` have strong references between each other. Furthermore, the parent of `g` of type`GroupOfIsometries` refers to them via strong links. It also seems that GroupOfIsometries is a construction parameter of some `UniqueRepresentation` object.\n\nThere do seem to be reference cycles:\n`GroupOfIsometries`->`TripleDict`->`GroupActionOnSubmodule`->`Groupoid_with_category`->`dict`->(back)\n\nThe groupoid object is a `UniqueRepresentation` object, so that explains that ref. Since `GroupOfIsometries` ends up having a strong reference to the groupoid, this would nail things in memory: The `GroupOfIsometries` object is kept alive for as long as the groupoid exists because it's a construction parameter for it. The groupoid object is kept alive by the `GroupOfIsometries`. Hence a memory leak. There could be other, but this is definitely one.",
    "created_at": "2019-02-27T20:47:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425926",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:15" align="right">Comment 15</div>

You can get a graphical representation of the backref graph:

```
for k in range(2,200):
    m = matrix.diagonal([1,k])
    L = IntegralLattice(m)
    G = L.orthogonal_group([matrix.identity(2)])
    g = G.0
    if k == 2:
        ID=id(G)
    tmp = L.an_element()*g
import gc
gc.collect()
import objgraph #that's a useful package for hunting memory leaks
objgraph.show_backrefs([g for  g in gc.get_objects() if id(g) == ID],max_depth=7).save("graph.dot")
```

It seems that the objects of type `FreeQuadraticModule_integer_symmetric` and `TorsionQuadraticModule` have strong references between each other. Furthermore, the parent of `g` of type`GroupOfIsometries` refers to them via strong links. It also seems that GroupOfIsometries is a construction parameter of some `UniqueRepresentation` object.

There do seem to be reference cycles:
`GroupOfIsometries`->`TripleDict`->`GroupActionOnSubmodule`->`Groupoid_with_category`->`dict`->(back)

The groupoid object is a `UniqueRepresentation` object, so that explains that ref. Since `GroupOfIsometries` ends up having a strong reference to the groupoid, this would nail things in memory: The `GroupOfIsometries` object is kept alive for as long as the groupoid exists because it's a construction parameter for it. The groupoid object is kept alive by the `GroupOfIsometries`. Hence a memory leak. There could be other, but this is definitely one.



---

archive/issue_comments_425927.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">Comment 16</div>\n\nThank you for the analysis Nils and the `objgraph` example (I didn't know about that...or I forgot `>_<`).\n\nMost of that reference cycle feels completely natural. We want the groupoid to be the category for the action and it makes sense for that to be a unique representation. The groupoid has to refer back to the set it acts on. The `GroupOfIsometries` `G` creates the `GroupActionOnSubmodule`, which has to refer to `G`, but that is an arrow going in the opposite direction. I believe that `TripleDict` ref inserted in there is coming from the coercion model via a call to `_get_action_`, which seems to be the cause of the problem. At least, I do not see where in `groups/matrix_gps/isometries.py` that would come from otherwise.",
    "created_at": "2019-02-27T22:44:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425927",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:16" align="right">Comment 16</div>

Thank you for the analysis Nils and the `objgraph` example (I didn't know about that...or I forgot `>_<`).

Most of that reference cycle feels completely natural. We want the groupoid to be the category for the action and it makes sense for that to be a unique representation. The groupoid has to refer back to the set it acts on. The `GroupOfIsometries` `G` creates the `GroupActionOnSubmodule`, which has to refer to `G`, but that is an arrow going in the opposite direction. I believe that `TripleDict` ref inserted in there is coming from the coercion model via a call to `_get_action_`, which seems to be the cause of the problem. At least, I do not see where in `groups/matrix_gps/isometries.py` that would come from otherwise.



---

archive/issue_comments_425928.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">Comment 17</div>\n\nI really do not see where the strong reference `GroupOfIsometries`->`TripleDict` comes from. I understand the `TripleDict` is the `_action_maps` in the coercion model, which has `GroupOfIsometries` as a key, so the ref should go the other direction and break the cycle. Althou ingh even if it did go the other way, there would still be a strong ref to `GroupOfIsometries` that would not be able to be removed, which would keep it as a key in the `TripleDict`.\n\nActually, I do not see how this is not a problem for *any* `Action`.",
    "created_at": "2019-02-27T22:57:28Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425928",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:17" align="right">Comment 17</div>

I really do not see where the strong reference `GroupOfIsometries`->`TripleDict` comes from. I understand the `TripleDict` is the `_action_maps` in the coercion model, which has `GroupOfIsometries` as a key, so the ref should go the other direction and break the cycle. Althou ingh even if it did go the other way, there would still be a strong ref to `GroupOfIsometries` that would not be able to be removed, which would keep it as a key in the `TripleDict`.

Actually, I do not see how this is not a problem for *any* `Action`.



---

archive/issue_comments_425929.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">Comment 18</div>\n\nThere's another `TripleDict()`: an attribute `_action_hash` on `Parent` objects. That's the only candidate for the link `GroupOfIsometries -> TripleDict`.\n\nIt is indeed the case that actions tend to tie together lifetimes of objects involved. That's indeed not unnatural. Normally, if both group and acted-up-set lose all references, the cyclic garbage collector would be able to discard the cycle. The problem I see is that the `UniqueRepresentation` cache maintains an outside reference to the cycle: to the `GroupOfIsometries` object to be precise. This cache is guarded by a weakref to the groupoid object. However, the groupoid object is kept alive because the `_action_hash` on `GroupOfIsometries` linking to it.\n\nIf the `UniqueRepresentation` cache were not keyed by the `GroupOfIsometries` object, this cycle would not cause a memory leak.\n\nAnother way would be to not cache the groupoid on `GroupOfIsometries`. This groupoid can be recovered from the `GroupOfIsometries` via the `UniqueRepresentation` cache, after all. I expect that would be very detrimental to performance, though. Plus, while we have identified this one cycle here, there could easily be another one.\n\nIt is a little strange that `search_src(\"_action_hash\")` doesn't find any lines where the attribute actually gets used. Do we not use this anymore for action discovery?",
    "created_at": "2019-02-28T00:26:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425929",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:18" align="right">Comment 18</div>

There's another `TripleDict()`: an attribute `_action_hash` on `Parent` objects. That's the only candidate for the link `GroupOfIsometries -> TripleDict`.

It is indeed the case that actions tend to tie together lifetimes of objects involved. That's indeed not unnatural. Normally, if both group and acted-up-set lose all references, the cyclic garbage collector would be able to discard the cycle. The problem I see is that the `UniqueRepresentation` cache maintains an outside reference to the cycle: to the `GroupOfIsometries` object to be precise. This cache is guarded by a weakref to the groupoid object. However, the groupoid object is kept alive because the `_action_hash` on `GroupOfIsometries` linking to it.

If the `UniqueRepresentation` cache were not keyed by the `GroupOfIsometries` object, this cycle would not cause a memory leak.

Another way would be to not cache the groupoid on `GroupOfIsometries`. This groupoid can be recovered from the `GroupOfIsometries` via the `UniqueRepresentation` cache, after all. I expect that would be very detrimental to performance, though. Plus, while we have identified this one cycle here, there could easily be another one.

It is a little strange that `search_src("_action_hash")` doesn't find any lines where the attribute actually gets used. Do we not use this anymore for action discovery?



---

archive/issue_comments_425930.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">Comment 19</div>\n\nAh, I missed that on `Parent`, good catch. I agree with you about the `_action_hash` being strange outright, but on a second thought and this comment in `parent.pxd`, I think it serves a purpose:\n\n```\n    # Write-only hashtable of all actions discovered using this parent.\n    # This is only needed to keep a strong reference to actions, to\n    # prevent them being garbage collected prematurely.\n    cdef TripleDict _action_hash\n```\nMainly without it, the action object (e.g., `GroupActionOnSubmodule`) would have no strong reference to it, so the action would be garbage collected, which means the corresponding key in `_action_maps` would then go too.\n\nInterestingly, merely asking for the action is not causing a memory leak:\n\n```\nsage: for k in range(2,1000):\n....:     m = matrix.diagonal([1,k])\n....:     L = IntegralLattice(m)\n....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)\n....:     A = coercion_model.discover_action(L, g.parent(), operator.mul)\n....:     \nsage: import gc\nsage: gc.collect()\n29408\nsage: gc.collect()\n7\nsage: len([v for v in gc.get_objects() if type(v) == type(A)])\n2\nsage: len([v for v in gc.get_objects() if type(v) == type(L)])\n122\n```",
    "created_at": "2019-02-28T01:39:29Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425930",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:19" align="right">Comment 19</div>

Ah, I missed that on `Parent`, good catch. I agree with you about the `_action_hash` being strange outright, but on a second thought and this comment in `parent.pxd`, I think it serves a purpose:

```
    # Write-only hashtable of all actions discovered using this parent.
    # This is only needed to keep a strong reference to actions, to
    # prevent them being garbage collected prematurely.
    cdef TripleDict _action_hash
```
Mainly without it, the action object (e.g., `GroupActionOnSubmodule`) would have no strong reference to it, so the action would be garbage collected, which means the corresponding key in `_action_maps` would then go too.

Interestingly, merely asking for the action is not causing a memory leak:

```
sage: for k in range(2,1000):
....:     m = matrix.diagonal([1,k])
....:     L = IntegralLattice(m)
....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)
....:     A = coercion_model.discover_action(L, g.parent(), operator.mul)
....:     
sage: import gc
sage: gc.collect()
29408
sage: gc.collect()
7
sage: len([v for v in gc.get_objects() if type(v) == type(A)])
2
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
122
```



---

archive/issue_comments_425931.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">Comment 20</div>\n\nMy understanding is that by creating the action, we are creating that cycle. So it is still apparently able to be collected. It is only when we actually multiply the elements that something changes. Maybe something also with checking for coercions?",
    "created_at": "2019-02-28T01:48:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425931",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:20" align="right">Comment 20</div>

My understanding is that by creating the action, we are creating that cycle. So it is still apparently able to be collected. It is only when we actually multiply the elements that something changes. Maybe something also with checking for coercions?



---

archive/issue_comments_425932.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">Comment 21</div>\n\nAlso, explicitly invoking `A.act(g, L.an_element())` does not nail things in memory.",
    "created_at": "2019-02-28T01:49:36Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425932",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:21" align="right">Comment 21</div>

Also, explicitly invoking `A.act(g, L.an_element())` does not nail things in memory.



---

archive/issue_comments_425933.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">Comment 22</div>\n\nThe test I wrote in [comment:19](#comment%3A19) does is slightly different as `coercion_model.get_action` runs `Parent.get_action`, which does not put the action into the `_action_maps` `TripleDict`. Although I do believe the cycle mentioned in [comment:15](#comment%3A15) is getting created, and it is that `coercion_model._action_maps` that nails it in memory.",
    "created_at": "2019-02-28T02:01:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425933",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:22" align="right">Comment 22</div>

The test I wrote in [comment:19](#comment%3A19) does is slightly different as `coercion_model.get_action` runs `Parent.get_action`, which does not put the action into the `_action_maps` `TripleDict`. Although I do believe the cycle mentioned in [comment:15](#comment%3A15) is getting created, and it is that `coercion_model._action_maps` that nails it in memory.



---

archive/issue_comments_425934.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">Comment 23</div>\n\nHere is another example of the same memory leak with `Action`:\n\n```sage\nfor p in primes(10000):\n   F = GF(p)\n   M = MatrixSpace(F, 2)\n   V = F^2\n    _ = M.one() * V.zero()\n```\n\n```\nsage: import gc\nsage: gc.collect()\n14\nsage: gc.collect()\n7\nsage: len([v for v in gc.get_objects() if type(v) == type(V)])\n1229\nsage: len(list(primes(10000)))\n1229\n```\nSo it is a much more pervasive problem than in this particular example (really any nontrivial `Action`).",
    "created_at": "2019-02-28T02:08:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425934",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:23" align="right">Comment 23</div>

Here is another example of the same memory leak with `Action`:

```sage
for p in primes(10000):
   F = GF(p)
   M = MatrixSpace(F, 2)
   V = F^2
    _ = M.one() * V.zero()
```

```
sage: import gc
sage: gc.collect()
14
sage: gc.collect()
7
sage: len([v for v in gc.get_objects() if type(v) == type(V)])
1229
sage: len(list(primes(10000)))
1229
```
So it is a much more pervasive problem than in this particular example (really any nontrivial `Action`).



---

archive/issue_comments_425935.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">Comment 24</div>\n\nHmm...the leak in [comment:23](#comment%3A23) might be a different issue as when I run\n\n```\nsage: for p in primes(10000):\n....:     F = GF(p)\n....:     M = MatrixSpace(F, 2)\n....:     V = F^2\n....:     A = coercion_model.discover_action(V, M, operator.mul)\nsage: import gc\nsage: gc.collect()\n116\nsage: gc.collect()\n7\nsage: len([v for v in gc.get_objects() if type(v) == type(F)])\n1229\nsage: coercion_model._action_maps[M, V, operator.mul]\n...\nKey Error: ...\n```\n\nThen again, this might be an (the?) underlying problem as the for the matrix group goes through this...",
    "created_at": "2019-02-28T02:20:05Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425935",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:24" align="right">Comment 24</div>

Hmm...the leak in [comment:23](#comment%3A23) might be a different issue as when I run

```
sage: for p in primes(10000):
....:     F = GF(p)
....:     M = MatrixSpace(F, 2)
....:     V = F^2
....:     A = coercion_model.discover_action(V, M, operator.mul)
sage: import gc
sage: gc.collect()
116
sage: gc.collect()
7
sage: len([v for v in gc.get_objects() if type(v) == type(F)])
1229
sage: coercion_model._action_maps[M, V, operator.mul]
...
Key Error: ...
```

Then again, this might be an (the?) underlying problem as the for the matrix group goes through this...



---

archive/issue_comments_425936.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">Comment 25</div>\n\ncommenting out  \n\n```\n#self._action_hash.set(S, op, self_on_left, action)\n```\nand using\n\n```\nsage: cm = sage.structure.element.get_coercion_model()\nsage: cm.reset_cache()\n```\nallows things to be collected.",
    "created_at": "2019-03-05T23:50:51Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425936",
    "user": "https://github.com/simonbrandhorst"
}
```

<div id="comment:25" align="right">Comment 25</div>

commenting out  

```
#self._action_hash.set(S, op, self_on_left, action)
```
and using

```
sage: cm = sage.structure.element.get_coercion_model()
sage: cm.reset_cache()
```
allows things to be collected.



---

archive/issue_comments_425937.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">Comment 26</div>\n\nThinking more about this, there are two separate issues.\n\n1 - Mathematical: An action of a  does not have to form a groupoid (i.e., they are not invertible in general). So technically actions should be endofunctors on a small category. However, this is not a technical challenge, just an (slight) abuse of terminology.\n\n2 - Reference cycles: I looked at [comment:24](#comment%3A24) with `objgraph`, and it is fundamentally the same cycle, just a bit tighter: `MatrixSpace` -> `VectorMatrixAction` -> `Groupoid` -> `dict` -> back. Now even if we fix 1 (which could be as simple as changing the name of the `Groupoid` class), that still leaves us with this extremely natural reference cycle. So perhaps the most natural way out is to make the category not a `UniqueRepresentation`. Another thought would be for a `Groupoid` to only hold a weak references to its defining group (both as `self.__G` and in its construction key). Even doing that, there still is a problem of `VectorMatrixAction` -> `MatrixSpace` -> `TripleDict` -> back.\n\nI do not get why actions are treated differently than coercions. Coercions only keep their codomains as strong references (the reasoning as I understand it is that if you are acting by something in the domain, you likely have that domain as an explicit reference). So why are we having a strong reference to the actor (analogous to the domain) and not the set (the codomain)? Perhaps for actions in general, the proper thing to do is have weak references to both the actor and the set.\n\nI suspect we need to take this discussion to sage-devel as this might involve a major change in how we handle references with actions, as well as caching parameters for categories.",
    "created_at": "2019-03-07T02:36:32Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425937",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:26" align="right">Comment 26</div>

Thinking more about this, there are two separate issues.

1 - Mathematical: An action of a  does not have to form a groupoid (i.e., they are not invertible in general). So technically actions should be endofunctors on a small category. However, this is not a technical challenge, just an (slight) abuse of terminology.

2 - Reference cycles: I looked at [comment:24](#comment%3A24) with `objgraph`, and it is fundamentally the same cycle, just a bit tighter: `MatrixSpace` -> `VectorMatrixAction` -> `Groupoid` -> `dict` -> back. Now even if we fix 1 (which could be as simple as changing the name of the `Groupoid` class), that still leaves us with this extremely natural reference cycle. So perhaps the most natural way out is to make the category not a `UniqueRepresentation`. Another thought would be for a `Groupoid` to only hold a weak references to its defining group (both as `self.__G` and in its construction key). Even doing that, there still is a problem of `VectorMatrixAction` -> `MatrixSpace` -> `TripleDict` -> back.

I do not get why actions are treated differently than coercions. Coercions only keep their codomains as strong references (the reasoning as I understand it is that if you are acting by something in the domain, you likely have that domain as an explicit reference). So why are we having a strong reference to the actor (analogous to the domain) and not the set (the codomain)? Perhaps for actions in general, the proper thing to do is have weak references to both the actor and the set.

I suspect we need to take this discussion to sage-devel as this might involve a major change in how we handle references with actions, as well as caching parameters for categories.



---

archive/issue_comments_425938.json:
```json
{
    "body": "<div id=\"comment:27\" align=\"right\">Comment 27</div>\n\nGo ahead.",
    "created_at": "2019-03-08T09:16:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425938",
    "user": "https://github.com/simonbrandhorst"
}
```

<div id="comment:27" align="right">Comment 27</div>

Go ahead.



---

archive/issue_events_357638.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2020-03-04T10:12:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357638"
}
```



---

archive/issue_events_357639.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2020-03-04T10:12:47Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "title_is": "Memory leak in sage.categories.action.Action",
    "title_was": "Memory leak in sage.groups.matrix_gps.isometries",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357639"
}
```



---

archive/issue_comments_425939.json:
```json
{
    "body": "<div id=\"comment:29\" align=\"right\">Comment 29</div>\n\nMoving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.",
    "created_at": "2020-05-01T04:28:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425939",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:29" align="right">Comment 29</div>

Moving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.



---

archive/issue_events_357640.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-05-01T04:28:42Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357640"
}
```



---

archive/issue_events_357641.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-05-01T04:28:42Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357641"
}
```



---

archive/issue_events_357642.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-10-24T20:15:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357642"
}
```



---

archive/issue_events_357643.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-10-24T20:15:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357643"
}
```



---

archive/issue_comments_425940.json:
```json
{
    "body": "<div id=\"comment:31\" align=\"right\">Comment 31</div>\n\nSetting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27358#issuecomment-425940",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:31" align="right">Comment 31</div>

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_357644.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357644"
}
```



---

archive/issue_events_357645.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357645"
}
```



---

archive/issue_events_357646.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-08-09T21:26:23Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357646"
}
```



---

archive/issue_events_357647.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-08-09T21:26:23Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357647"
}
```



---

archive/issue_events_357648.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357648"
}
```



---

archive/issue_events_357649.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357649"
}
```



---

archive/issue_events_357650.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:19:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357650"
}
```



---

archive/issue_events_357651.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:19:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357651"
}
```



---

archive/issue_events_357652.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357652"
}
```



---

archive/issue_events_357653.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27358",
    "milestone_number": null,
    "milestone_title": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27358#event-357653"
}
```
