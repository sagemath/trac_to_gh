# Issue 27358: Memory leak in sage.categories.action.Action

archive/issues_027121.json:
```json
{
    "body": "\n```\nsage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap\n....: G = AbelianGroupGap([2,3,4,5])\n....: \nsage: aut = G.automorphism_group()\nsage: for k in range(100):\n....:     s = aut.subgroup([aut.random_element() for k in range(3)])\n....:     \nsage: st = type(s)\nsage: del s,aut,G\nsage: import gc\nsage: gc.collect()\n56\nsage: len([v for v in gc.get_objects() if type(v) == st])\n100\n```\n\nCC:  @tscrim @nbruin @jdemeyer\n\nBranch: [u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries)\n\nStatus: needs_work\n\nCommit: a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5\n\nIssue created by migration from https://trac.sagemath.org/ticket/27358\n\n",
    "created_at": "2019-02-26T10:46:45Z",
    "labels": [
        "component: memleak",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Memory leak in sage.categories.action.Action",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27358",
    "user": "https://github.com/simonbrandhorst"
}
```

```
sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGroupGap
....: G = AbelianGroupGap([2,3,4,5])
....: 
sage: aut = G.automorphism_group()
sage: for k in range(100):
....:     s = aut.subgroup([aut.random_element() for k in range(3)])
....:     
sage: st = type(s)
sage: del s,aut,G
sage: import gc
sage: gc.collect()
56
sage: len([v for v in gc.get_objects() if type(v) == st])
100
```

CC:  @tscrim @nbruin @jdemeyer

Branch: [u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries](https://github.com/sagemath/sagetrac-mirror/tree/u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries)

Status: needs_work

Commit: a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5

Issue created by migration from https://trac.sagemath.org/ticket/27358





---

archive/issue_comments_528819.json:
```json
{
    "body": "Changing branch from \"\" to \"u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups\"",
    "created_at": "2019-02-26T10:51:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528819",
    "user": "https://github.com/simonbrandhorst"
}
```

Changing branch from "" to "u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups"



---

archive/issue_comments_528820.json:
```json
{
    "body": "<a id='comment:2'></a>\nAfter removing `UniqueRepresentation` the memory leak is fixed.\n\n```\nsage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGr\n....: oupGap\n....: G = AbelianGroupGap([2,3,4,5])\n....: \nsage: aut = G.automorphism_group()\nsage: for k in range(100):\n....:     s = aut.subgroup([aut.random_element() for k in range(3)])\n....:     \nsage: st = type(s)\nsage: del s,aut,G\nsage: import gc\nsage: gc.collect()\n167\nsage: [v for v in gc.get_objects() if type(v) == st]\n[]\n```\n\nI think that automorphism groups and especially their subgroups\nare too complex objects for unique representations. For Abelian groups that may be okay\nbut certainly in the non-commutative world unique representation does not work and has too little benefit.",
    "created_at": "2019-02-26T10:54:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528820",
    "user": "https://github.com/simonbrandhorst"
}
```

<a id='comment:2'></a>
After removing `UniqueRepresentation` the memory leak is fixed.

```
sage: from sage.groups.abelian_gps.abelian_group_gap import AbelianGr
....: oupGap
....: G = AbelianGroupGap([2,3,4,5])
....: 
sage: aut = G.automorphism_group()
sage: for k in range(100):
....:     s = aut.subgroup([aut.random_element() for k in range(3)])
....:     
sage: st = type(s)
sage: del s,aut,G
sage: import gc
sage: gc.collect()
167
sage: [v for v in gc.get_objects() if type(v) == st]
[]
```

I think that automorphism groups and especially their subgroups
are too complex objects for unique representations. For Abelian groups that may be okay
but certainly in the non-commutative world unique representation does not work and has too little benefit.



---

archive/issue_comments_528821.json:
```json
{
    "body": "Changing commit from \"\" to \"73a9207bd005aeff843958bb03f03054b0b1dedd\"",
    "created_at": "2019-02-26T10:54:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528821",
    "user": "https://github.com/simonbrandhorst"
}
```

Changing commit from "" to "73a9207bd005aeff843958bb03f03054b0b1dedd"



---

archive/issue_comments_528822.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-02-26T10:54:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528822",
    "user": "https://github.com/simonbrandhorst"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_528823.json:
```json
{
    "body": "<a id='comment:4'></a>\nThis comes at the price of pickling. It does not work anymore.\nRespectively, unpickling would just create isomorphic objects.\nFrom my point of view we can sacrifice pickling.\nWith the memory leak the class is unusable for any serious computation.",
    "created_at": "2019-02-26T11:29:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528823",
    "user": "https://github.com/simonbrandhorst"
}
```

<a id='comment:4'></a>
This comes at the price of pickling. It does not work anymore.
Respectively, unpickling would just create isomorphic objects.
From my point of view we can sacrifice pickling.
With the memory leak the class is unusable for any serious computation.



---

archive/issue_comments_528824.json:
```json
{
    "body": "<a id='comment:5'></a>\nSo there is not a memory leak as there is a small cache (I think it is an LRU cache) that goes on that stores 128 objects. If you run it with 200 elements, you will get\n\n```\nsage: len([v for v in gc.get_objects() if type(v) == st])\n128\n```\n\nWe can see that there is no memory leak in the code because there is no ``@`cached_method` being used and the data being passed is all 1 directional (i.e., no strong reference cycles). At least, this is my understanding of how things are working.",
    "created_at": "2019-02-27T05:16:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528824",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:5'></a>
So there is not a memory leak as there is a small cache (I think it is an LRU cache) that goes on that stores 128 objects. If you run it with 200 elements, you will get

```
sage: len([v for v in gc.get_objects() if type(v) == st])
128
```

We can see that there is no memory leak in the code because there is no ``@`cached_method` being used and the data being passed is all 1 directional (i.e., no strong reference cycles). At least, this is my understanding of how things are working.



---

archive/issue_comments_528825.json:
```json
{
    "body": "Changing author from \"Simon Brandhorst\" to \"\"",
    "created_at": "2019-02-27T05:16:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528825",
    "user": "https://github.com/tscrim"
}
```

Changing author from "Simon Brandhorst" to ""



---

archive/issue_comments_528826.json:
```json
{
    "body": "Changing branch from \"u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups\" to \"\"",
    "created_at": "2019-02-27T05:16:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528826",
    "user": "https://github.com/tscrim"
}
```

Changing branch from "u/sbrandhorst/memory_leak_in_automorphism_groups_of_abelian_groups" to ""



---

archive/issue_comments_528827.json:
```json
{
    "body": "<a id='comment:6'></a>\nSo I am proposing closing this.",
    "created_at": "2019-02-27T05:16:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528827",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:6'></a>
So I am proposing closing this.



---

archive/issue_events_077039.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2019-02-27T05:16:38Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77039"
}
```



---

archive/issue_comments_528828.json:
```json
{
    "body": "Changing commit from \"73a9207bd005aeff843958bb03f03054b0b1dedd\" to \"\"",
    "created_at": "2019-02-27T05:16:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528828",
    "user": "https://github.com/tscrim"
}
```

Changing commit from "73a9207bd005aeff843958bb03f03054b0b1dedd" to ""



---

archive/issue_comments_528829.json:
```json
{
    "body": "<a id='comment:7'></a>\nSo an `@`cached_method together with a unique representation would cause memory leaks?",
    "created_at": "2019-02-27T08:59:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528829",
    "user": "https://github.com/simonbrandhorst"
}
```

<a id='comment:7'></a>
So an `@`cached_method together with a unique representation would cause memory leaks?



---

archive/issue_comments_528830.json:
```json
{
    "body": "<a id='comment:8'></a>\nNot a ``@`cached_method` in a subclass of `UniqueRepresentation`. But I am pretty sure a ``@`cached_method` that creates a `UniqueRepresentation` `UR` whose input includes `self` ends up being a memory leak (because then `self` is a strong global reference as a key to `UR`, but `UR` has a strong reference being the output of ``@`cached_method`). (This also has a code smell because of the double-caching anyways.)\n\nIn some sense a `UniqueRepresentation` and ``@`cached_method` are the same as they use the same mechanism as ``@`cached_function` to store data.",
    "created_at": "2019-02-27T09:56:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528830",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:8'></a>
Not a ``@`cached_method` in a subclass of `UniqueRepresentation`. But I am pretty sure a ``@`cached_method` that creates a `UniqueRepresentation` `UR` whose input includes `self` ends up being a memory leak (because then `self` is a strong global reference as a key to `UR`, but `UR` has a strong reference being the output of ``@`cached_method`). (This also has a code smell because of the double-caching anyways.)

In some sense a `UniqueRepresentation` and ``@`cached_method` are the same as they use the same mechanism as ``@`cached_function` to store data.



---

archive/issue_comments_528831.json:
```json
{
    "body": "<a id='comment:9'></a>\nthank you for your time. I think I have located my memory leak now:\n\n```\nsage: import gc\nsage: for k in range(2,400):\n....:     m = matrix.diagonal([1,k])\n....:     L = IntegralLattice(m)\n....:     D = L.discriminant_group()\n....:     g = L.orthogonal_group().gen(0)\n....:     tmp = D.gen(0)*g;\n....:     \nsage: gc.collect()\n2182\nsage: len([v for v in gc.get_objects() if type(v) == type(D)])\n514\n```\nIt could be related to the cached method discriminant_group. But the memleak only happens with the action. Maybe I programmed things a bit smelly :-/ .",
    "created_at": "2019-02-27T10:38:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528831",
    "user": "https://github.com/simonbrandhorst"
}
```

<a id='comment:9'></a>
thank you for your time. I think I have located my memory leak now:

```
sage: import gc
sage: for k in range(2,400):
....:     m = matrix.diagonal([1,k])
....:     L = IntegralLattice(m)
....:     D = L.discriminant_group()
....:     g = L.orthogonal_group().gen(0)
....:     tmp = D.gen(0)*g;
....:     
sage: gc.collect()
2182
sage: len([v for v in gc.get_objects() if type(v) == type(D)])
514
```
It could be related to the cached method discriminant_group. But the memleak only happens with the action. Maybe I programmed things a bit smelly :-/ .



---

archive/issue_comments_528832.json:
```json
{
    "body": "<a id='comment:10'></a>\nOkay the root cause seems to be somewhere in the coercion system.\nAnd I found a way to release the memory however it seems to me like a bug.\n\n```\nsage: for k in range(2,10000):\n....:     m = matrix.diagonal([1,k])\n....:     L = IntegralLattice(m)\n....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)\n....:     tmp = L.an_element()*g\nsage: import gc\nsage: len([v for v in gc.get_objects() if type(v) == type(L)])\n9893\nsage: gc.collect()\n35563\nsage: len([v for v in gc.get_objects() if type(v) == type(L)])\n9892\nsage: cm = sage.structure.element.get_coercion_model()\nsage: cm.reset_cache()\nsage: gc.collect()\n2630471\nsage: len([v for v in gc.get_objects() if type(v) == type(L)])\n130\n```",
    "created_at": "2019-02-27T10:54:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528832",
    "user": "https://github.com/simonbrandhorst"
}
```

<a id='comment:10'></a>
Okay the root cause seems to be somewhere in the coercion system.
And I found a way to release the memory however it seems to me like a bug.

```
sage: for k in range(2,10000):
....:     m = matrix.diagonal([1,k])
....:     L = IntegralLattice(m)
....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)
....:     tmp = L.an_element()*g
sage: import gc
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
9893
sage: gc.collect()
35563
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
9892
sage: cm = sage.structure.element.get_coercion_model()
sage: cm.reset_cache()
sage: gc.collect()
2630471
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
130
```



---

archive/issue_comments_528833.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2019-02-27T11:07:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528833",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_528834.json:
```json
{
    "body": "<a id='comment:11'></a>\nOkay, we need to recycle this ticket.\n\nNils, I am cc-ing you on this ticket because of the memory leak. Jeroen because it might involve the coercion framework.\n\nI wonder if it has something to do with having an action, non-unique parents, but discriminant group being a ``@`cached_method`. It is too late here (Australia) for me to figure out a more minimal example and nothing obvious jumps out at me.",
    "created_at": "2019-02-27T11:07:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528834",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:11'></a>
Okay, we need to recycle this ticket.

Nils, I am cc-ing you on this ticket because of the memory leak. Jeroen because it might involve the coercion framework.

I wonder if it has something to do with having an action, non-unique parents, but discriminant group being a ``@`cached_method`. It is too late here (Australia) for me to figure out a more minimal example and nothing obvious jumps out at me.



---

archive/issue_events_077040.json:
```json
{
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "rename": {
        "from": "Memory leak in automorphism groups of abelian groups",
        "to": "Memory leak in sage.groups.matrix_gps.isometries"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77040"
}
```



---

archive/issue_comments_528835.json:
```json
{
    "body": "<a id='comment:12'></a>\nIt has to do with the action.",
    "created_at": "2019-02-27T16:03:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528835",
    "user": "https://github.com/simonbrandhorst"
}
```

<a id='comment:12'></a>
It has to do with the action.



---

archive/issue_comments_528836.json:
```json
{
    "body": "Changing branch from \"\" to \"u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries\"",
    "created_at": "2019-02-27T17:00:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528836",
    "user": "https://github.com/simonbrandhorst"
}
```

Changing branch from "" to "u/sbrandhorst/memory_leak_in_sage_groups_matrix_gps_isometries"



---

archive/issue_comments_528837.json:
```json
{
    "body": "Changing commit from \"\" to \"a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5\"",
    "created_at": "2019-02-27T17:03:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528837",
    "user": "https://github.com/simonbrandhorst"
}
```

Changing commit from "" to "a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5"



---

archive/issue_comments_528838.json:
```json
{
    "body": "<a id='comment:14'></a>\nHere is a fix. \nHowever, it involves calling the internal method\n`sage.structure.parent.Parent._unset_coercions_used`\nto be able to register an action. I am unsure of the consequences here.\nIs there a better way to tell the coercion model about the action?\n\n---\nNew commits:\n|                                                                                                                                          |                                                                       |\n|------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------|\n|[a2b3bc2](https://github.com/sagemath/sagetrac-mirror/commit/a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5)|`deprecate arguments invariant_submodule and invariant_quotient_module`|",
    "created_at": "2019-02-27T17:03:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528838",
    "user": "https://github.com/simonbrandhorst"
}
```

<a id='comment:14'></a>
Here is a fix. 
However, it involves calling the internal method
`sage.structure.parent.Parent._unset_coercions_used`
to be able to register an action. I am unsure of the consequences here.
Is there a better way to tell the coercion model about the action?

---
New commits:
|                                                                                                                                          |                                                                       |
|------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------|
|[a2b3bc2](https://github.com/sagemath/sagetrac-mirror/commit/a2b3bc2de2e5a5d15256b0f77b21188c83d50fc5)|`deprecate arguments invariant_submodule and invariant_quotient_module`|



---

archive/issue_comments_528839.json:
```json
{
    "body": "<a id='comment:15'></a>\nYou can get a graphical representation of the backref graph:\n\n```\nfor k in range(2,200):\n    m = matrix.diagonal([1,k])\n    L = IntegralLattice(m)\n    G = L.orthogonal_group([matrix.identity(2)])\n    g = G.0\n    if k == 2:\n        ID=id(G)\n    tmp = L.an_element()*g\nimport gc\ngc.collect()\nimport objgraph #that's a useful package for hunting memory leaks\nobjgraph.show_backrefs([g for  g in gc.get_objects() if id(g) == ID],max_depth=7).save(\"graph.dot\")\n```\n\nIt seems that the objects of type `FreeQuadraticModule_integer_symmetric` and `TorsionQuadraticModule` have strong references between each other. Furthermore, the parent of `g` of type`GroupOfIsometries` refers to them via strong links. It also seems that GroupOfIsometries is a construction parameter of some `UniqueRepresentation` object.\n\nThere do seem to be reference cycles:\n`GroupOfIsometries`->`TripleDict`->`GroupActionOnSubmodule`->`Groupoid_with_category`->`dict`->(back)\n\nThe groupoid object is a `UniqueRepresentation` object, so that explains that ref. Since `GroupOfIsometries` ends up having a strong reference to the groupoid, this would nail things in memory: The `GroupOfIsometries` object is kept alive for as long as the groupoid exists because it's a construction parameter for it. The groupoid object is kept alive by the `GroupOfIsometries`. Hence a memory leak. There could be other, but this is definitely one.",
    "created_at": "2019-02-27T20:47:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528839",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:15'></a>
You can get a graphical representation of the backref graph:

```
for k in range(2,200):
    m = matrix.diagonal([1,k])
    L = IntegralLattice(m)
    G = L.orthogonal_group([matrix.identity(2)])
    g = G.0
    if k == 2:
        ID=id(G)
    tmp = L.an_element()*g
import gc
gc.collect()
import objgraph #that's a useful package for hunting memory leaks
objgraph.show_backrefs([g for  g in gc.get_objects() if id(g) == ID],max_depth=7).save("graph.dot")
```

It seems that the objects of type `FreeQuadraticModule_integer_symmetric` and `TorsionQuadraticModule` have strong references between each other. Furthermore, the parent of `g` of type`GroupOfIsometries` refers to them via strong links. It also seems that GroupOfIsometries is a construction parameter of some `UniqueRepresentation` object.

There do seem to be reference cycles:
`GroupOfIsometries`->`TripleDict`->`GroupActionOnSubmodule`->`Groupoid_with_category`->`dict`->(back)

The groupoid object is a `UniqueRepresentation` object, so that explains that ref. Since `GroupOfIsometries` ends up having a strong reference to the groupoid, this would nail things in memory: The `GroupOfIsometries` object is kept alive for as long as the groupoid exists because it's a construction parameter for it. The groupoid object is kept alive by the `GroupOfIsometries`. Hence a memory leak. There could be other, but this is definitely one.



---

archive/issue_comments_528840.json:
```json
{
    "body": "<a id='comment:16'></a>\nThank you for the analysis Nils and the `objgraph` example (I didn't know about that...or I forgot `>_<`).\n\nMost of that reference cycle feels completely natural. We want the groupoid to be the category for the action and it makes sense for that to be a unique representation. The groupoid has to refer back to the set it acts on. The `GroupOfIsometries` `G` creates the `GroupActionOnSubmodule`, which has to refer to `G`, but that is an arrow going in the opposite direction. I believe that `TripleDict` ref inserted in there is coming from the coercion model via a call to `_get_action_`, which seems to be the cause of the problem. At least, I do not see where in `groups/matrix_gps/isometries.py` that would come from otherwise.",
    "created_at": "2019-02-27T22:44:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528840",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:16'></a>
Thank you for the analysis Nils and the `objgraph` example (I didn't know about that...or I forgot `>_<`).

Most of that reference cycle feels completely natural. We want the groupoid to be the category for the action and it makes sense for that to be a unique representation. The groupoid has to refer back to the set it acts on. The `GroupOfIsometries` `G` creates the `GroupActionOnSubmodule`, which has to refer to `G`, but that is an arrow going in the opposite direction. I believe that `TripleDict` ref inserted in there is coming from the coercion model via a call to `_get_action_`, which seems to be the cause of the problem. At least, I do not see where in `groups/matrix_gps/isometries.py` that would come from otherwise.



---

archive/issue_comments_528841.json:
```json
{
    "body": "<a id='comment:17'></a>\nI really do not see where the strong reference `GroupOfIsometries`->`TripleDict` comes from. I understand the `TripleDict` is the `_action_maps` in the coercion model, which has `GroupOfIsometries` as a key, so the ref should go the other direction and break the cycle. Althou ingh even if it did go the other way, there would still be a strong ref to `GroupOfIsometries` that would not be able to be removed, which would keep it as a key in the `TripleDict`.\n\nActually, I do not see how this is not a problem for *any* `Action`.",
    "created_at": "2019-02-27T22:57:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528841",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:17'></a>
I really do not see where the strong reference `GroupOfIsometries`->`TripleDict` comes from. I understand the `TripleDict` is the `_action_maps` in the coercion model, which has `GroupOfIsometries` as a key, so the ref should go the other direction and break the cycle. Althou ingh even if it did go the other way, there would still be a strong ref to `GroupOfIsometries` that would not be able to be removed, which would keep it as a key in the `TripleDict`.

Actually, I do not see how this is not a problem for *any* `Action`.



---

archive/issue_comments_528842.json:
```json
{
    "body": "<a id='comment:18'></a>\nThere's another `TripleDict()`: an attribute `_action_hash` on `Parent` objects. That's the only candidate for the link `GroupOfIsometries -> TripleDict`.\n\nIt is indeed the case that actions tend to tie together lifetimes of objects involved. That's indeed not unnatural. Normally, if both group and acted-up-set lose all references, the cyclic garbage collector would be able to discard the cycle. The problem I see is that the `UniqueRepresentation` cache maintains an outside reference to the cycle: to the `GroupOfIsometries` object to be precise. This cache is guarded by a weakref to the groupoid object. However, the groupoid object is kept alive because the `_action_hash` on `GroupOfIsometries` linking to it.\n\nIf the `UniqueRepresentation` cache were not keyed by the `GroupOfIsometries` object, this cycle would not cause a memory leak.\n\nAnother way would be to not cache the groupoid on `GroupOfIsometries`. This groupoid can be recovered from the `GroupOfIsometries` via the `UniqueRepresentation` cache, after all. I expect that would be very detrimental to performance, though. Plus, while we have identified this one cycle here, there could easily be another one.\n\nIt is a little strange that `search_src(\"_action_hash\")` doesn't find any lines where the attribute actually gets used. Do we not use this anymore for action discovery?",
    "created_at": "2019-02-28T00:26:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528842",
    "user": "https://github.com/nbruin"
}
```

<a id='comment:18'></a>
There's another `TripleDict()`: an attribute `_action_hash` on `Parent` objects. That's the only candidate for the link `GroupOfIsometries -> TripleDict`.

It is indeed the case that actions tend to tie together lifetimes of objects involved. That's indeed not unnatural. Normally, if both group and acted-up-set lose all references, the cyclic garbage collector would be able to discard the cycle. The problem I see is that the `UniqueRepresentation` cache maintains an outside reference to the cycle: to the `GroupOfIsometries` object to be precise. This cache is guarded by a weakref to the groupoid object. However, the groupoid object is kept alive because the `_action_hash` on `GroupOfIsometries` linking to it.

If the `UniqueRepresentation` cache were not keyed by the `GroupOfIsometries` object, this cycle would not cause a memory leak.

Another way would be to not cache the groupoid on `GroupOfIsometries`. This groupoid can be recovered from the `GroupOfIsometries` via the `UniqueRepresentation` cache, after all. I expect that would be very detrimental to performance, though. Plus, while we have identified this one cycle here, there could easily be another one.

It is a little strange that `search_src("_action_hash")` doesn't find any lines where the attribute actually gets used. Do we not use this anymore for action discovery?



---

archive/issue_comments_528843.json:
```json
{
    "body": "<a id='comment:19'></a>\nAh, I missed that on `Parent`, good catch. I agree with you about the `_action_hash` being strange outright, but on a second thought and this comment in `parent.pxd`, I think it serves a purpose:\n\n```\n    # Write-only hashtable of all actions discovered using this parent.\n    # This is only needed to keep a strong reference to actions, to\n    # prevent them being garbage collected prematurely.\n    cdef TripleDict _action_hash\n```\nMainly without it, the action object (e.g., `GroupActionOnSubmodule`) would have no strong reference to it, so the action would be garbage collected, which means the corresponding key in `_action_maps` would then go too.\n\nInterestingly, merely asking for the action is not causing a memory leak:\n\n```\nsage: for k in range(2,1000):\n....:     m = matrix.diagonal([1,k])\n....:     L = IntegralLattice(m)\n....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)\n....:     A = coercion_model.discover_action(L, g.parent(), operator.mul)\n....:     \nsage: import gc\nsage: gc.collect()\n29408\nsage: gc.collect()\n7\nsage: len([v for v in gc.get_objects() if type(v) == type(A)])\n2\nsage: len([v for v in gc.get_objects() if type(v) == type(L)])\n122\n```",
    "created_at": "2019-02-28T01:39:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528843",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:19'></a>
Ah, I missed that on `Parent`, good catch. I agree with you about the `_action_hash` being strange outright, but on a second thought and this comment in `parent.pxd`, I think it serves a purpose:

```
    # Write-only hashtable of all actions discovered using this parent.
    # This is only needed to keep a strong reference to actions, to
    # prevent them being garbage collected prematurely.
    cdef TripleDict _action_hash
```
Mainly without it, the action object (e.g., `GroupActionOnSubmodule`) would have no strong reference to it, so the action would be garbage collected, which means the corresponding key in `_action_maps` would then go too.

Interestingly, merely asking for the action is not causing a memory leak:

```
sage: for k in range(2,1000):
....:     m = matrix.diagonal([1,k])
....:     L = IntegralLattice(m)
....:     g = L.orthogonal_group([matrix.identity(2)]).gen(0)
....:     A = coercion_model.discover_action(L, g.parent(), operator.mul)
....:     
sage: import gc
sage: gc.collect()
29408
sage: gc.collect()
7
sage: len([v for v in gc.get_objects() if type(v) == type(A)])
2
sage: len([v for v in gc.get_objects() if type(v) == type(L)])
122
```



---

archive/issue_comments_528844.json:
```json
{
    "body": "<a id='comment:20'></a>\nMy understanding is that by creating the action, we are creating that cycle. So it is still apparently able to be collected. It is only when we actually multiply the elements that something changes. Maybe something also with checking for coercions?",
    "created_at": "2019-02-28T01:48:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528844",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:20'></a>
My understanding is that by creating the action, we are creating that cycle. So it is still apparently able to be collected. It is only when we actually multiply the elements that something changes. Maybe something also with checking for coercions?



---

archive/issue_comments_528845.json:
```json
{
    "body": "<a id='comment:21'></a>\nAlso, explicitly invoking `A.act(g, L.an_element())` does not nail things in memory.",
    "created_at": "2019-02-28T01:49:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528845",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:21'></a>
Also, explicitly invoking `A.act(g, L.an_element())` does not nail things in memory.



---

archive/issue_comments_528846.json:
```json
{
    "body": "<a id='comment:22'></a>\nThe test I wrote in[comment:19](#comment%3A19) does is slightly different as `coercion_model.get_action` runs `Parent.get_action`, which does not put the action into the `_action_maps` `TripleDict`. Although I do believe the cycle mentioned in[comment:15](#comment%3A15) is getting created, and it is that `coercion_model._action_maps` that nails it in memory.",
    "created_at": "2019-02-28T02:01:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528846",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:22'></a>
The test I wrote in[comment:19](#comment%3A19) does is slightly different as `coercion_model.get_action` runs `Parent.get_action`, which does not put the action into the `_action_maps` `TripleDict`. Although I do believe the cycle mentioned in[comment:15](#comment%3A15) is getting created, and it is that `coercion_model._action_maps` that nails it in memory.



---

archive/issue_comments_528847.json:
```json
{
    "body": "<a id='comment:23'></a>\nHere is another example of the same memory leak with `Action`:\n\n```sage\nfor p in primes(10000):\n   F = GF(p)\n   M = MatrixSpace(F, 2)\n   V = F^2\n    _ = M.one() * V.zero()\n```\n\n```\nsage: import gc\nsage: gc.collect()\n14\nsage: gc.collect()\n7\nsage: len([v for v in gc.get_objects() if type(v) == type(V)])\n1229\nsage: len(list(primes(10000)))\n1229\n```\nSo it is a much more pervasive problem than in this particular example (really any nontrivial `Action`).",
    "created_at": "2019-02-28T02:08:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528847",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:23'></a>
Here is another example of the same memory leak with `Action`:

```sage
for p in primes(10000):
   F = GF(p)
   M = MatrixSpace(F, 2)
   V = F^2
    _ = M.one() * V.zero()
```

```
sage: import gc
sage: gc.collect()
14
sage: gc.collect()
7
sage: len([v for v in gc.get_objects() if type(v) == type(V)])
1229
sage: len(list(primes(10000)))
1229
```
So it is a much more pervasive problem than in this particular example (really any nontrivial `Action`).



---

archive/issue_comments_528848.json:
```json
{
    "body": "<a id='comment:24'></a>\nHmm...the leak in[comment:23](#comment%3A23) might be a different issue as when I run\n\n```\nsage: for p in primes(10000):\n....:     F = GF(p)\n....:     M = MatrixSpace(F, 2)\n....:     V = F^2\n....:     A = coercion_model.discover_action(V, M, operator.mul)\nsage: import gc\nsage: gc.collect()\n116\nsage: gc.collect()\n7\nsage: len([v for v in gc.get_objects() if type(v) == type(F)])\n1229\nsage: coercion_model._action_maps[M, V, operator.mul]\n...\nKey Error: ...\n```\n\nThen again, this might be an (the?) underlying problem as the for the matrix group goes through this...",
    "created_at": "2019-02-28T02:20:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528848",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:24'></a>
Hmm...the leak in[comment:23](#comment%3A23) might be a different issue as when I run

```
sage: for p in primes(10000):
....:     F = GF(p)
....:     M = MatrixSpace(F, 2)
....:     V = F^2
....:     A = coercion_model.discover_action(V, M, operator.mul)
sage: import gc
sage: gc.collect()
116
sage: gc.collect()
7
sage: len([v for v in gc.get_objects() if type(v) == type(F)])
1229
sage: coercion_model._action_maps[M, V, operator.mul]
...
Key Error: ...
```

Then again, this might be an (the?) underlying problem as the for the matrix group goes through this...



---

archive/issue_comments_528849.json:
```json
{
    "body": "<a id='comment:25'></a>\ncommenting out  \n\n```\n#self._action_hash.set(S, op, self_on_left, action)\n```\nand using\n\n```\nsage: cm = sage.structure.element.get_coercion_model()\nsage: cm.reset_cache()\n```\nallows things to be collected.",
    "created_at": "2019-03-05T23:50:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528849",
    "user": "https://github.com/simonbrandhorst"
}
```

<a id='comment:25'></a>
commenting out  

```
#self._action_hash.set(S, op, self_on_left, action)
```
and using

```
sage: cm = sage.structure.element.get_coercion_model()
sage: cm.reset_cache()
```
allows things to be collected.



---

archive/issue_comments_528850.json:
```json
{
    "body": "<a id='comment:26'></a>\nThinking more about this, there are two separate issues.\n\n1 - Mathematical: An action of a  does not have to form a groupoid (i.e., they are not invertible in general). So technically actions should be endofunctors on a small category. However, this is not a technical challenge, just an (slight) abuse of terminology.\n\n2 - Reference cycles: I looked at[comment:24](#comment%3A24) with `objgraph`, and it is fundamentally the same cycle, just a bit tighter: `MatrixSpace` -> `VectorMatrixAction` -> `Groupoid` -> `dict` -> back. Now even if we fix 1 (which could be as simple as changing the name of the `Groupoid` class), that still leaves us with this extremely natural reference cycle. So perhaps the most natural way out is to make the category not a `UniqueRepresentation`. Another thought would be for a `Groupoid` to only hold a weak references to its defining group (both as `self.__G` and in its construction key). Even doing that, there still is a problem of `VectorMatrixAction` -> `MatrixSpace` -> `TripleDict` -> back.\n\nI do not get why actions are treated differently than coercions. Coercions only keep their codomains as strong references (the reasoning as I understand it is that if you are acting by something in the domain, you likely have that domain as an explicit reference). So why are we having a strong reference to the actor (analogous to the domain) and not the set (the codomain)? Perhaps for actions in general, the proper thing to do is have weak references to both the actor and the set.\n\nI suspect we need to take this discussion to sage-devel as this might involve a major change in how we handle references with actions, as well as caching parameters for categories.",
    "created_at": "2019-03-07T02:36:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528850",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:26'></a>
Thinking more about this, there are two separate issues.

1 - Mathematical: An action of a  does not have to form a groupoid (i.e., they are not invertible in general). So technically actions should be endofunctors on a small category. However, this is not a technical challenge, just an (slight) abuse of terminology.

2 - Reference cycles: I looked at[comment:24](#comment%3A24) with `objgraph`, and it is fundamentally the same cycle, just a bit tighter: `MatrixSpace` -> `VectorMatrixAction` -> `Groupoid` -> `dict` -> back. Now even if we fix 1 (which could be as simple as changing the name of the `Groupoid` class), that still leaves us with this extremely natural reference cycle. So perhaps the most natural way out is to make the category not a `UniqueRepresentation`. Another thought would be for a `Groupoid` to only hold a weak references to its defining group (both as `self.__G` and in its construction key). Even doing that, there still is a problem of `VectorMatrixAction` -> `MatrixSpace` -> `TripleDict` -> back.

I do not get why actions are treated differently than coercions. Coercions only keep their codomains as strong references (the reasoning as I understand it is that if you are acting by something in the domain, you likely have that domain as an explicit reference). So why are we having a strong reference to the actor (analogous to the domain) and not the set (the codomain)? Perhaps for actions in general, the proper thing to do is have weak references to both the actor and the set.

I suspect we need to take this discussion to sage-devel as this might involve a major change in how we handle references with actions, as well as caching parameters for categories.



---

archive/issue_comments_528851.json:
```json
{
    "body": "<a id='comment:27'></a>\nGo ahead.",
    "created_at": "2019-03-08T09:16:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528851",
    "user": "https://github.com/simonbrandhorst"
}
```

<a id='comment:27'></a>
Go ahead.



---

archive/issue_events_077041.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2020-03-04T10:12:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-duplicate/invalid/wontfix",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77041"
}
```



---

archive/issue_events_077042.json:
```json
{
    "actor": "https://github.com/simonbrandhorst",
    "created_at": "2020-03-04T10:12:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77042"
}
```



---

archive/issue_events_077043.json:
```json
{
    "event": "renamed",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "rename": {
        "from": "Memory leak in sage.groups.matrix_gps.isometries",
        "to": "Memory leak in sage.categories.action.Action"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77043"
}
```



---

archive/issue_comments_528852.json:
```json
{
    "body": "<a id='comment:29'></a>\nMoving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.",
    "created_at": "2020-05-01T04:28:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528852",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:29'></a>
Moving tickets to milestone sage-9.2 based on a review of last modification date, branch status, and severity.



---

archive/issue_events_077044.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-05-01T04:28:42Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77044"
}
```



---

archive/issue_events_077045.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-05-01T04:28:42Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77045"
}
```



---

archive/issue_events_077046.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-10-24T20:15:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77046"
}
```



---

archive/issue_events_077047.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-10-24T20:15:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77047"
}
```



---

archive/issue_comments_528853.json:
```json
{
    "body": "<a id='comment:31'></a>\nSetting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27358#issuecomment-528853",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:31'></a>
Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_077048.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77048"
}
```



---

archive/issue_events_077049.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77049"
}
```



---

archive/issue_events_077050.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-08-09T21:26:23Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77050"
}
```



---

archive/issue_events_077051.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-08-09T21:26:23Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77051"
}
```



---

archive/issue_events_077052.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77052"
}
```



---

archive/issue_events_077053.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:24:17Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77053"
}
```



---

archive/issue_events_077054.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:19:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77054"
}
```



---

archive/issue_events_077055.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-05-03T15:19:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77055"
}
```



---

archive/issue_events_077056.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77056"
}
```



---

archive/issue_events_077057.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-09-19T18:58:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27358",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27358#event-77057"
}
```
