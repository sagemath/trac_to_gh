# Issue 27103: Enable SIMD-instructions for Bitsets

archive/issues_026866.json:
```json
{
    "assignees": [],
    "body": "#27122 enabled `-march=native` by default. This allows using intrinsics for Intel and AMD processors (unless the user specified different `CFLAGS` or `CXXFLAGS` differently).\n\nBitsets allocated using `MemoryAllocator` are overaligned allocated. This is not the case otherwise and there are several reasons not to do so for now:\n- More memory usage especially for small bitsets (`bitset_t` itself is rather small).\n- It makes `realloc` a lot harder.\n- There seems to be only about 10 percent loss when data is not overaligned.\n- There seems to be only about 1 percent performance loss, when the data is overaligned but the code is not customized for it (`_mm256_loadu_si256` instead of `_mm256_load_si256` etc).\n\nSee https://software.intel.com/sites/landingpage/IntrinsicsGuide for details about the instructions.\n\nThe emptyness check as it is seems be really fast and it appears pointless to beat it using intrinsics.\n\nA few minor improvements in the bitset frontend of bitsets were also made.\n\nTimings without intrinsics (should be exactly the same as without this ticket as the code almost did not change):\n\n```\nsage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \nsage: %timeit B == B                                                                                                                                                                \n7.93 \u00b5s \u00b1 5.71 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: Bop = ~B                                                                                                                                                                      \nsage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n8.11 \u00b5s \u00b1 4.43 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.issubset(B)                                                                                                                                                         \n7.98 \u00b5s \u00b1 7.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: B2 = ~Bop                                    \nsage: %timeit B2.intersection_update(B)                                                                                                                                             \n7.22 \u00b5s \u00b1 20 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B2.union(B)                                                                                                                                                           \n14.6 \u00b5s \u00b1 5.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n14 \u00b5s \u00b1 9.34 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.difference_update(Bop)                                                                                                                                              \n7.2 \u00b5s \u00b1 19.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: P = polytopes.hypercube(14)                                                                                                                                                   \nsage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \nsage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 12.8 s, sys: 7.98 ms, total: 12.8 s\nWall time: 12.8 s\n(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n\nsage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 581 ms, sys: 0 ns, total: 581 ms\nWall time: 580 ms\n(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n\nsage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 38 s, sys: 20.2 ms, total: 38 s\nWall time: 38 s\n(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n```\n\nWith SSE4.1 (some of them would also run just with SSE2, but already SSE4.1 is 2008):\n\n```\nsage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \nsage: %timeit B == B                                                                                                                                                                \n7.91 \u00b5s \u00b1 3.03 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: Bop = ~B                                                                                                                                                                      \nsage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n5.1 \u00b5s \u00b1 6.09 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.issubset(B)                                                                                                                                                         \n4.71 \u00b5s \u00b1 5.07 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: B2 = ~Bop                                                                                                                                                                     \nsage: %timeit B2.intersection_update(B)                                                                                                                                             \n5.57 \u00b5s \u00b1 9.94 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B2.union(B)                                                                                                                                                           \n11.9 \u00b5s \u00b1 5.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n12.4 \u00b5s \u00b1 7.06 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.difference_update(Bop)                                                                                                                                              \n4.66 \u00b5s \u00b1 38.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: P = polytopes.hypercube(14)                                                                                                                                                   \nsage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \nsage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 7.98 s, sys: 4 ms, total: 7.99 s\nWall time: 7.98 s\n(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n\nsage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 466 ms, sys: 0 ns, total: 466 ms\nWall time: 466 ms\n(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n                                                                                                                                                                              \nsage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 26.8 s, sys: 8.09 ms, total: 26.8 s\nWall time: 26.8 s\n(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n```\n\nWith AVX:\n\n```\nsage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \nsage: %timeit B == B                                                                                                                                                                \n3.99 \u00b5s \u00b1 2.46 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: Bop = ~B                                                                                                                                                                      \nsage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n3.38 \u00b5s \u00b1 12.7 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.issubset(B)                                                                                                                                                         \n3.05 \u00b5s \u00b1 2.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: P = polytopes.hypercube(14)                                                                                                                                                   \nsage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \nsage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 5.27 s, sys: 7.97 ms, total: 5.28 s\nWall time: 5.28 s\n(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n\nsage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 449 ms, sys: 6 \u00b5s, total: 449 ms\nWall time: 449 ms\n(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n\n# It does not use subset checks as it is a simple polytope.\nsage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 30.4 s, sys: 23.6 ms, total: 30.4 s\nWall time: 30.4 s\n(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n```\n\nWith AVX2:\n\n```\nsage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \nsage: Bop = ~B                                                                                                                                                                      \nsage: B2 = ~Bop                                                                                                                                                                     \nsage: %timeit B2.intersection_update(B)                                                                                                                                             \n4.2 \u00b5s \u00b1 3.28 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B2.union(B)                                                                                                                                                           \n12 \u00b5s \u00b1 5.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n12 \u00b5s \u00b1 5.98 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.difference_update(Bop)                                                                                                                                              \n4.03 \u00b5s \u00b1 3.46 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: P = polytopes.hypercube(14)                                                                                                                                                   \nsage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \nsage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 5.18 s, sys: 7 \u00b5s, total: 5.18 s\nWall time: 5.18 s\n(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n\nsage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 436 ms, sys: 3 \u00b5s, total: 436 ms\nWall time: 435 ms\n(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n\nsage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 24.3 s, sys: 19.7 ms, total: 24.3 s\nWall time: 24.3 s\n(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n```\n\nDepends on #31208\n\nCC:  @sophiasage @stumpc5 @hivert @slel @tscrim\n\nComponent: **geometry**\n\nKeywords: **bitsets, CombinatorialPolyhedron, SIMD, intrinsics**\n\nAuthor: **Jonathan Kliem**\n\nBranch/Commit: **[`8bd0b1f`](https://github.com/sagemath/sagetrac-mirror/commit/8bd0b1fe087a802603b426bd22d51458b951d776)**\n\nReviewer: **Travis Scrimshaw**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/27103_\n\n",
    "closed_at": "2021-01-31T20:53:48Z",
    "created_at": "2019-01-23T20:11:47Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20geometry",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/enhancement"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.3",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "Enable SIMD-instructions for Bitsets",
    "type": "issue",
    "updated_at": "2021-01-31T20:53:48Z",
    "url": "https://github.com/sagemath/sage/issues/27103",
    "user": "https://github.com/kliem"
}
```
#27122 enabled `-march=native` by default. This allows using intrinsics for Intel and AMD processors (unless the user specified different `CFLAGS` or `CXXFLAGS` differently).

Bitsets allocated using `MemoryAllocator` are overaligned allocated. This is not the case otherwise and there are several reasons not to do so for now:
- More memory usage especially for small bitsets (`bitset_t` itself is rather small).
- It makes `realloc` a lot harder.
- There seems to be only about 10 percent loss when data is not overaligned.
- There seems to be only about 1 percent performance loss, when the data is overaligned but the code is not customized for it (`_mm256_loadu_si256` instead of `_mm256_load_si256` etc).

See https://software.intel.com/sites/landingpage/IntrinsicsGuide for details about the instructions.

The emptyness check as it is seems be really fast and it appears pointless to beat it using intrinsics.

A few minor improvements in the bitset frontend of bitsets were also made.

Timings without intrinsics (should be exactly the same as without this ticket as the code almost did not change):

```
sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
sage: %timeit B == B                                                                                                                                                                
7.93 µs ± 5.71 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: Bop = ~B                                                                                                                                                                      
sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
8.11 µs ± 4.43 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.issubset(B)                                                                                                                                                         
7.98 µs ± 7.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: B2 = ~Bop                                    
sage: %timeit B2.intersection_update(B)                                                                                                                                             
7.22 µs ± 20 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B2.union(B)                                                                                                                                                           
14.6 µs ± 5.3 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
14 µs ± 9.34 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.difference_update(Bop)                                                                                                                                              
7.2 µs ± 19.2 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: P = polytopes.hypercube(14)                                                                                                                                                   
sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 12.8 s, sys: 7.98 ms, total: 12.8 s
Wall time: 12.8 s
(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)

sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 581 ms, sys: 0 ns, total: 581 ms
Wall time: 580 ms
(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)

sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 38 s, sys: 20.2 ms, total: 38 s
Wall time: 38 s
(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
```

With SSE4.1 (some of them would also run just with SSE2, but already SSE4.1 is 2008):

```
sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
sage: %timeit B == B                                                                                                                                                                
7.91 µs ± 3.03 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: Bop = ~B                                                                                                                                                                      
sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
5.1 µs ± 6.09 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.issubset(B)                                                                                                                                                         
4.71 µs ± 5.07 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: B2 = ~Bop                                                                                                                                                                     
sage: %timeit B2.intersection_update(B)                                                                                                                                             
5.57 µs ± 9.94 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B2.union(B)                                                                                                                                                           
11.9 µs ± 5.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
12.4 µs ± 7.06 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.difference_update(Bop)                                                                                                                                              
4.66 µs ± 38.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: P = polytopes.hypercube(14)                                                                                                                                                   
sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 7.98 s, sys: 4 ms, total: 7.99 s
Wall time: 7.98 s
(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)

sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 466 ms, sys: 0 ns, total: 466 ms
Wall time: 466 ms
(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
                                                                                                                                                                              
sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 26.8 s, sys: 8.09 ms, total: 26.8 s
Wall time: 26.8 s
(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
```

With AVX:

```
sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
sage: %timeit B == B                                                                                                                                                                
3.99 µs ± 2.46 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: Bop = ~B                                                                                                                                                                      
sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
3.38 µs ± 12.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.issubset(B)                                                                                                                                                         
3.05 µs ± 2.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: P = polytopes.hypercube(14)                                                                                                                                                   
sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 5.27 s, sys: 7.97 ms, total: 5.28 s
Wall time: 5.28 s
(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)

sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 449 ms, sys: 6 µs, total: 449 ms
Wall time: 449 ms
(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)

# It does not use subset checks as it is a simple polytope.
sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 30.4 s, sys: 23.6 ms, total: 30.4 s
Wall time: 30.4 s
(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
```

With AVX2:

```
sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
sage: Bop = ~B                                                                                                                                                                      
sage: B2 = ~Bop                                                                                                                                                                     
sage: %timeit B2.intersection_update(B)                                                                                                                                             
4.2 µs ± 3.28 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B2.union(B)                                                                                                                                                           
12 µs ± 5.9 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
12 µs ± 5.98 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.difference_update(Bop)                                                                                                                                              
4.03 µs ± 3.46 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: P = polytopes.hypercube(14)                                                                                                                                                   
sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 5.18 s, sys: 7 µs, total: 5.18 s
Wall time: 5.18 s
(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)

sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 436 ms, sys: 3 µs, total: 436 ms
Wall time: 435 ms
(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)

sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 24.3 s, sys: 19.7 ms, total: 24.3 s
Wall time: 24.3 s
(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
```

Depends on #31208

CC:  @sophiasage @stumpc5 @hivert @slel @tscrim

Component: **geometry**

Keywords: **bitsets, CombinatorialPolyhedron, SIMD, intrinsics**

Author: **Jonathan Kliem**

Branch/Commit: **[`8bd0b1f`](https://github.com/sagemath/sagetrac-mirror/commit/8bd0b1fe087a802603b426bd22d51458b951d776)**

Reviewer: **Travis Scrimshaw**

_Issue created by migration from https://trac.sagemath.org/ticket/27103_





---

archive/issue_events_369516.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-01-23T20:11:47Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "milestone_number": null,
    "milestone_title": "sage-8.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369516"
}
```



---

archive/issue_events_369517.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-01-23T20:11:47Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20geometry",
    "label_color": "0000ff",
    "label_name": "c: geometry",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369517"
}
```



---

archive/issue_events_369518.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-01-23T20:11:47Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20minor%20/%204",
    "label_color": "ffe799",
    "label_name": "p: minor / 4",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369518"
}
```



---

archive/issue_events_369519.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-01-23T20:11:47Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/enhancement",
    "label_color": "696969",
    "label_name": "enhancement",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369519"
}
```



---

archive/issue_events_369520.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-01-25T22:57:09Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20minor%20/%204",
    "label_color": "ffe799",
    "label_name": "p: minor / 4",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369520"
}
```



---

archive/issue_events_369521.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-01-25T22:57:09Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369521"
}
```



---

archive/issue_comments_418014.json:
```json
{
    "body": "Changed keywords from **CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector** to **CombinatorialPolyhedron, SIMD, intrinsics**",
    "created_at": "2019-01-25T22:57:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418014",
    "user": "https://github.com/kliem"
}
```

Changed keywords from **CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector** to **CombinatorialPolyhedron, SIMD, intrinsics**



---

archive/issue_comments_418015.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,11 +1,5 @@\n-The crucial calculation for pretty much everything in CombinatorialPolyhedron (#26887) is to check whether a face A is a (sub-)face of a different face B.\n+#26887 prepares SIMD-instructions to speed up calculations.\n \n-Once converted to Bits representing each vertex the question is A & ~B == 0.\n+The subject of this ticket is to carefully enable them.\n \n-This is fastly computed with processor intrinsics (_mm256_testc_si256 or _mm_testc_si128). AVX can do this with 256 bit chunks.\n-\n-To compute e.g. the f-vector, one also needs the intersection of two faces or bitwise AND. AVX cannot do this with 256 bit chunks, but AVX2 can.\n-\n-Currently the choice for AVX but not AVX2 is to compute with 128 bit chunks.\n-\n-As the subset check is very much the bottle neck of the computations, we should split 256 bits again in two for intersection, when AVX is available but AVX2 is not. This should give a speedup of almost two on large Polyhedra.\n+Also on machines with AVX and not AVX2, one should consider using `__m256i` instead of 128-bit data, as the crucial calculation is a subset check (A & ~B == 0), which can be done with 256-bit data on AVX with `_mm256_testc_si256`.\n``````\n",
    "created_at": "2019-01-25T22:57:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418015",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,11 +1,5 @@
-The crucial calculation for pretty much everything in CombinatorialPolyhedron (#26887) is to check whether a face A is a (sub-)face of a different face B.
+#26887 prepares SIMD-instructions to speed up calculations.
 
-Once converted to Bits representing each vertex the question is A & ~B == 0.
+The subject of this ticket is to carefully enable them.
 
-This is fastly computed with processor intrinsics (_mm256_testc_si256 or _mm_testc_si128). AVX can do this with 256 bit chunks.
-
-To compute e.g. the f-vector, one also needs the intersection of two faces or bitwise AND. AVX cannot do this with 256 bit chunks, but AVX2 can.
-
-Currently the choice for AVX but not AVX2 is to compute with 128 bit chunks.
-
-As the subset check is very much the bottle neck of the computations, we should split 256 bits again in two for intersection, when AVX is available but AVX2 is not. This should give a speedup of almost two on large Polyhedra.
+Also on machines with AVX and not AVX2, one should consider using `__m256i` instead of 128-bit data, as the crucial calculation is a subset check (A & ~B == 0), which can be done with 256-bit data on AVX with `_mm256_testc_si256`.
``````




---

archive/issue_comments_418016.json:
```json
{
    "body": "Changed dependencies from **#26887** to **#26887, #27122**",
    "created_at": "2019-01-25T22:57:09Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418016",
    "user": "https://github.com/kliem"
}
```

Changed dependencies from **#26887** to **#26887, #27122**



---

archive/issue_events_369522.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-01-25T22:57:09Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "title_is": "Farther improve CombinatorialPolyhedron: Enable SIMD-instructions.",
    "title_was": "Farther improve Combinatorial Polyhedron for AVX but not AVX 2.",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369522"
}
```



---

archive/issue_events_369523.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-01-25T22:57:29Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "title_is": "Farther improve CombinatorialPolyhedron: Enable SIMD-instructions",
    "title_was": "Farther improve CombinatorialPolyhedron: Enable SIMD-instructions.",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369523"
}
```



---

archive/issue_comments_418017.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nThis is a way, one could boost CombinatorialPolyhedron with intrinsics. Replace `is_subset`, `intersection` and `CountFaceBits` by those functions:\n\n```\n#if __AVX__\n    #include <immintrin.h>\n#elif __SSE4_1__\n    #include <emmintrin.h>\n    #include <smmintrin.h>\n#endif\n\n#if __POPCNT__\n    #include <immintrin.h>\n#endif\n\n\n// as of now, 512bit does not have something like _mm256_testc_si256,\n// which is the bottle neck of this function,\n// so it does not make sense to implement it\n\n// inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length)\n// the bottlen-neck is checking for subsets, which requires something as\n// _mm256_testc_si256, trying to determine, what is the best way of doing it:\n#if __AVX__\n    // 256-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrics defined in immintrin.h\n    const size_t chunksize = 256;\n    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){\n        // A & ~B == 0\n        // returns 1 if A is a subset of B, otherwise returns 0\n        // this is done by checking if there is an element in A,\n        // which is not in B\n        // `face_length` is the length of A and B in terms of uint64_t\n        // note that A,B need to be 32-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 4){\n            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);\n            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);\n            if (!_mm256_testc_si256(b, a)){ //need to be opposite order !!\n                return 0;\n            }\n        }\n        return 1;\n    }\n\n#elif __SSE4_1__\n    // 128-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrics defined in smmintrin.h and emmintrin.h\n    const size_t chunksize = 128;\n    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){\n        // A & ~B == 0\n        // returns 1 if A is a subset of B, otherwise returns 0\n        // this is done by checking if there is an element in A,\n        // which is not in B\n        // `face_length` is the length of A and B in terms of uint64_t\n        // note that A,B need to be 16-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 2){\n            __m128i a = _mm_load_si128((const __m128i*)&A[i]);\n            __m128i b = _mm_load_si128((const __m128i*)&B[i]);\n            if (!_mm_testc_si128(b, a)){ //need to be opposite order !!\n                return 0;\n            }\n        }\n        return 1;\n    }\n\n#else\n    // no intrinsics\n    const size_t chunksize = 64;\n    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){\n        // A & ~B == 0\n        // returns 1 if A is a subset of B, otherwise returns 0\n        // this is done by checking if there is an element in A,\n        // which is not in B\n        // `face_length` is the length of A and B in terms of uint64_t\n        size_t i;\n        for (i = 0; i < face_length; i++){\n            if (A[i] & ~B[i]){\n                return 0;\n            }\n        }\n        return 1;\n    }\n\n#endif\n\n// inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C,\n//                          size_t face_length)\n// now determining, how to do insersection\n#if __AVX2__\n    // 256-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrics defined in immintrin.h\n    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \\\n                             size_t face_length){\n        // C = A & B\n        // will set C to be the intersection of A and B\n        // `face_length` is the length of A, B and C in terms of uint64_t\n        // note that A,B,C need to be 32-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 4){\n            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);\n            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);\n            __m256i c = _mm256_and_si256(a, b);\n            _mm256_store_si256((__m256i*)&C[i],c);\n        }\n    }\n\n#elif __SSE4_1__\n    // actually SSE2 would be fine, but we don't want to force greater chunks,\n    // because of intersection, which is not the bottleneck\n    // 128-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrinsics defined in emmintrin.h\n    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \\\n                             size_t face_length){\n        // C = A & B\n        // will set C to be the intersection of A and B\n        // `face_length` is the length of A, B and C in terms of uint64_t\n        // note that A,B,C need to be 16-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 2){\n            __m128i a = _mm_load_si128((const __m128i*)&A[i]);\n            __m128i b = _mm_load_si128((const __m128i*)&B[i]);\n            __m128i c = _mm_and_si128(a, b);\n            _mm_store_si128((__m128i*)&C[i],c);\n        }\n    }\n\n#else\n    // commands, without intrinsics\n    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \\\n                             size_t face_length){\n        // C = A & B\n        // will set C to be the intersection of A and B\n        // `face_length` is the length of A, B and C in terms of uint64_t\n        size_t i;\n        for (i = 0; i < face_length; i++){\n            C[i] = A[i] & B[i];\n        }\n    }\n\n#endif\n\n// inline size_t CountFaceBits(uint64_t* A, size_t face_length)\n// determine the best way to count the set bits in uint64_t *\n#if (__POPCNT__) && (INTPTR_MAX == INT64_MAX) // 64-bit and popcnt\n    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {\n        // counts the number of vertices in a face by counting bits set to one\n        // `face_length` is the length of A in terms of uint64_t\n        size_t i;\n        unsigned int count = 0;\n        for (i=0; i<face_length; i++){\n            count += (size_t) _mm_popcnt_u64(A[i]);\n        }\n        return count;\n    }\n\n#else // popcount without intrinsics\n    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {\n        // counts the number of vertices in a face by counting bits set to one\n        // `face_length` is the length of A in terms of uint64_t\n        size_t i;\n        unsigned int count = 0;\n        for (i=0; i<face_length; i++){\n            uint64_t a = A[i];\n            while (a){\n                count += a & 1;\n                a >>= 1;\n            }\n        }\n        return count;\n    }\n\n#endif\n```",
    "created_at": "2019-02-20T15:45:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418017",
    "user": "https://github.com/kliem"
}
```

<div id="comment:3" align="right">comment:3</div>

This is a way, one could boost CombinatorialPolyhedron with intrinsics. Replace `is_subset`, `intersection` and `CountFaceBits` by those functions:

```
#if __AVX__
    #include <immintrin.h>
#elif __SSE4_1__
    #include <emmintrin.h>
    #include <smmintrin.h>
#endif

#if __POPCNT__
    #include <immintrin.h>
#endif


// as of now, 512bit does not have something like _mm256_testc_si256,
// which is the bottle neck of this function,
// so it does not make sense to implement it

// inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length)
// the bottlen-neck is checking for subsets, which requires something as
// _mm256_testc_si256, trying to determine, what is the best way of doing it:
#if __AVX__
    // 256-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrics defined in immintrin.h
    const size_t chunksize = 256;
    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){
        // A & ~B == 0
        // returns 1 if A is a subset of B, otherwise returns 0
        // this is done by checking if there is an element in A,
        // which is not in B
        // `face_length` is the length of A and B in terms of uint64_t
        // note that A,B need to be 32-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 4){
            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);
            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);
            if (!_mm256_testc_si256(b, a)){ //need to be opposite order !!
                return 0;
            }
        }
        return 1;
    }

#elif __SSE4_1__
    // 128-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrics defined in smmintrin.h and emmintrin.h
    const size_t chunksize = 128;
    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){
        // A & ~B == 0
        // returns 1 if A is a subset of B, otherwise returns 0
        // this is done by checking if there is an element in A,
        // which is not in B
        // `face_length` is the length of A and B in terms of uint64_t
        // note that A,B need to be 16-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 2){
            __m128i a = _mm_load_si128((const __m128i*)&A[i]);
            __m128i b = _mm_load_si128((const __m128i*)&B[i]);
            if (!_mm_testc_si128(b, a)){ //need to be opposite order !!
                return 0;
            }
        }
        return 1;
    }

#else
    // no intrinsics
    const size_t chunksize = 64;
    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){
        // A & ~B == 0
        // returns 1 if A is a subset of B, otherwise returns 0
        // this is done by checking if there is an element in A,
        // which is not in B
        // `face_length` is the length of A and B in terms of uint64_t
        size_t i;
        for (i = 0; i < face_length; i++){
            if (A[i] & ~B[i]){
                return 0;
            }
        }
        return 1;
    }

#endif

// inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C,
//                          size_t face_length)
// now determining, how to do insersection
#if __AVX2__
    // 256-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrics defined in immintrin.h
    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \
                             size_t face_length){
        // C = A & B
        // will set C to be the intersection of A and B
        // `face_length` is the length of A, B and C in terms of uint64_t
        // note that A,B,C need to be 32-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 4){
            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);
            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);
            __m256i c = _mm256_and_si256(a, b);
            _mm256_store_si256((__m256i*)&C[i],c);
        }
    }

#elif __SSE4_1__
    // actually SSE2 would be fine, but we don't want to force greater chunks,
    // because of intersection, which is not the bottleneck
    // 128-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrinsics defined in emmintrin.h
    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \
                             size_t face_length){
        // C = A & B
        // will set C to be the intersection of A and B
        // `face_length` is the length of A, B and C in terms of uint64_t
        // note that A,B,C need to be 16-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 2){
            __m128i a = _mm_load_si128((const __m128i*)&A[i]);
            __m128i b = _mm_load_si128((const __m128i*)&B[i]);
            __m128i c = _mm_and_si128(a, b);
            _mm_store_si128((__m128i*)&C[i],c);
        }
    }

#else
    // commands, without intrinsics
    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \
                             size_t face_length){
        // C = A & B
        // will set C to be the intersection of A and B
        // `face_length` is the length of A, B and C in terms of uint64_t
        size_t i;
        for (i = 0; i < face_length; i++){
            C[i] = A[i] & B[i];
        }
    }

#endif

// inline size_t CountFaceBits(uint64_t* A, size_t face_length)
// determine the best way to count the set bits in uint64_t *
#if (__POPCNT__) && (INTPTR_MAX == INT64_MAX) // 64-bit and popcnt
    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {
        // counts the number of vertices in a face by counting bits set to one
        // `face_length` is the length of A in terms of uint64_t
        size_t i;
        unsigned int count = 0;
        for (i=0; i<face_length; i++){
            count += (size_t) _mm_popcnt_u64(A[i]);
        }
        return count;
    }

#else // popcount without intrinsics
    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {
        // counts the number of vertices in a face by counting bits set to one
        // `face_length` is the length of A in terms of uint64_t
        size_t i;
        unsigned int count = 0;
        for (i=0; i<face_length; i++){
            uint64_t a = A[i];
            while (a){
                count += a & 1;
                a >>= 1;
            }
        }
        return count;
    }

#endif
```



---

archive/issue_comments_418018.json:
```json
{
    "body": "Commit: **[`52cb026`](https://github.com/sagemath/sagetrac-mirror/commit/52cb026a0fbddc1984701f7054bd71e97e157ea1)**",
    "created_at": "2019-03-11T14:29:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418018",
    "user": "https://github.com/kliem"
}
```

Commit: **[`52cb026`](https://github.com/sagemath/sagetrac-mirror/commit/52cb026a0fbddc1984701f7054bd71e97e157ea1)**



---

archive/issue_comments_418019.json:
```json
{
    "body": "<div id=\"comment:4\"></div>\n\nLast 10 new commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6052b6138d488608c5ba11ea05525648aea1b4ee\"><code>6052b61</code></a></td><td><code>FaceIterator is an actual iterator now</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/e8309e4c706335d981a70ed67bdaa7ea96a3ca13\"><code>e8309e4</code></a></td><td><code>fixed allocation of array</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/6a55fa5dadad4d97182d55334a985bdab6e34f37\"><code>6a55fa5</code></a></td><td><code>it.next() -> next(it), also fixed face_lattice_facet_repr for trivial cases</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9f421825ae6eaa4bc800b978ba7e9d529434a0fc\"><code>9f42182</code></a></td><td><code>improved documentation mostly</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/687d0032794306c563430f03391fac3ba7bf9419\"><code>687d003</code></a></td><td><code>replaced calloc by new[]</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f8a201e41ffc28d9903499988aed2f86db2dee17\"><code>f8a201e</code></a></td><td><code>Improved comments all through base.pyx</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/df43a2d5391a8c78db78e66a6ab3556a1e1b8689\"><code>df43a2d</code></a></td><td><code>improved pseudo-code Algorithm in ``FaceIterator``</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b73e53c9b172eb0b53b0895f49f79b5c6eaac65e\"><code>b73e53c</code></a></td><td><code>Corrected a mathematical error in explonation.</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f791ccee9f403eafc3f62b223729f84397fd3433\"><code>f791cce</code></a></td><td><code>removed notes and old files again</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/52cb026a0fbddc1984701f7054bd71e97e157ea1\"><code>52cb026</code></a></td><td><code>replaced methods by intrinsic alternatives</code></td></tr></table>\n",
    "created_at": "2019-03-11T14:29:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418019",
    "user": "https://github.com/kliem"
}
```

<div id="comment:4"></div>

Last 10 new commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6052b6138d488608c5ba11ea05525648aea1b4ee"><code>6052b61</code></a></td><td><code>FaceIterator is an actual iterator now</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/e8309e4c706335d981a70ed67bdaa7ea96a3ca13"><code>e8309e4</code></a></td><td><code>fixed allocation of array</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/6a55fa5dadad4d97182d55334a985bdab6e34f37"><code>6a55fa5</code></a></td><td><code>it.next() -> next(it), also fixed face_lattice_facet_repr for trivial cases</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9f421825ae6eaa4bc800b978ba7e9d529434a0fc"><code>9f42182</code></a></td><td><code>improved documentation mostly</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/687d0032794306c563430f03391fac3ba7bf9419"><code>687d003</code></a></td><td><code>replaced calloc by new[]</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f8a201e41ffc28d9903499988aed2f86db2dee17"><code>f8a201e</code></a></td><td><code>Improved comments all through base.pyx</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/df43a2d5391a8c78db78e66a6ab3556a1e1b8689"><code>df43a2d</code></a></td><td><code>improved pseudo-code Algorithm in ``FaceIterator``</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b73e53c9b172eb0b53b0895f49f79b5c6eaac65e"><code>b73e53c</code></a></td><td><code>Corrected a mathematical error in explonation.</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f791ccee9f403eafc3f62b223729f84397fd3433"><code>f791cce</code></a></td><td><code>removed notes and old files again</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/52cb026a0fbddc1984701f7054bd71e97e157ea1"><code>52cb026</code></a></td><td><code>replaced methods by intrinsic alternatives</code></td></tr></table>




---

archive/issue_comments_418020.json:
```json
{
    "body": "Branch: **[public/27103](https://github.com/sagemath/sagetrac-mirror/tree/public/27103)**",
    "created_at": "2019-03-11T14:29:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418020",
    "user": "https://github.com/kliem"
}
```

Branch: **[public/27103](https://github.com/sagemath/sagetrac-mirror/tree/public/27103)**



---

archive/issue_events_369524.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-03-25T10:56:15Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "milestone_number": null,
    "milestone_title": "sage-8.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369524"
}
```



---

archive/issue_events_369525.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-03-25T10:56:15Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "milestone_number": null,
    "milestone_title": "sage-8.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369525"
}
```



---

archive/issue_comments_418021.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nTicket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)",
    "created_at": "2019-03-25T10:56:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418021",
    "user": "https://github.com/embray"
}
```

<div id="comment:5" align="right">comment:5</div>

Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)



---

archive/issue_comments_418022.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nAs the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).",
    "created_at": "2019-06-14T14:54:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418022",
    "user": "https://github.com/embray"
}
```

<div id="comment:6" align="right">comment:6</div>

As the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).



---

archive/issue_events_369526.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-06-14T14:54:19Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "milestone_number": null,
    "milestone_title": "sage-8.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369526"
}
```



---

archive/issue_events_369527.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-08-29T19:02:46Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/pending",
    "label_color": "008080",
    "label_name": "pending",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369527"
}
```



---

archive/issue_events_369528.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-09-18T13:18:42Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "title_is": "Further improve CombinatorialPolyhedron: Enable SIMD-instructions",
    "title_was": "Farther improve CombinatorialPolyhedron: Enable SIMD-instructions",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369528"
}
```



---

archive/issue_comments_418023.json:
```json
{
    "body": "Changed commit from **[`52cb026`](https://github.com/sagemath/sagetrac-mirror/commit/52cb026a0fbddc1984701f7054bd71e97e157ea1)** to **[`10a6196`](https://github.com/sagemath/sagetrac-mirror/commit/10a61963ba0bb2547e44934bfa197933d1395d96)**",
    "created_at": "2019-10-23T07:47:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418023",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`52cb026`](https://github.com/sagemath/sagetrac-mirror/commit/52cb026a0fbddc1984701f7054bd71e97e157ea1)** to **[`10a6196`](https://github.com/sagemath/sagetrac-mirror/commit/10a61963ba0bb2547e44934bfa197933d1395d96)**



---

archive/issue_comments_418024.json:
```json
{
    "body": "<div id=\"comment:9\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/10a61963ba0bb2547e44934bfa197933d1395d96\"><code>10a6196</code></a></td><td><code>enabled intrinsics in bit_vector_operation.cc</code></td></tr></table>\n",
    "created_at": "2019-10-23T07:47:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418024",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:9"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/10a61963ba0bb2547e44934bfa197933d1395d96"><code>10a6196</code></a></td><td><code>enabled intrinsics in bit_vector_operation.cc</code></td></tr></table>




---

archive/issue_comments_418025.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\nfor popcount, you can use something like this when builtin popcount is not available:\n\n```\ncdef inline int popcount64(uint64_t i):\n   \"\"\"\n   Return the number of '1' bits in a 64-bits integer.\n   \"\"\"\n   i = i - ((i >> 1) & 0x5555555555555555ULL)\n   i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)\n   return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56\n```\n\nEDIT: removed inappropriate comment (bad copy/paste)",
    "created_at": "2019-10-23T10:57:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418025",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:10" align="right">comment:10</div>

for popcount, you can use something like this when builtin popcount is not available:

```
cdef inline int popcount64(uint64_t i):
   """
   Return the number of '1' bits in a 64-bits integer.
   """
   i = i - ((i >> 1) & 0x5555555555555555ULL)
   i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)
   return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56
```

EDIT: removed inappropriate comment (bad copy/paste)



---

archive/issue_comments_418026.json:
```json
{
    "body": "Changed commit from **[`10a6196`](https://github.com/sagemath/sagetrac-mirror/commit/10a61963ba0bb2547e44934bfa197933d1395d96)** to **[`d069567`](https://github.com/sagemath/sagetrac-mirror/commit/d069567e351f0dcecd5f790171cf30a5a8089fb3)**",
    "created_at": "2019-10-23T11:44:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418026",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`10a6196`](https://github.com/sagemath/sagetrac-mirror/commit/10a61963ba0bb2547e44934bfa197933d1395d96)** to **[`d069567`](https://github.com/sagemath/sagetrac-mirror/commit/d069567e351f0dcecd5f790171cf30a5a8089fb3)**



---

archive/issue_comments_418027.json:
```json
{
    "body": "<div id=\"comment:11\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d069567e351f0dcecd5f790171cf30a5a8089fb3\"><code>d069567</code></a></td><td><code>improved popcount without intrinsics</code></td></tr></table>\n",
    "created_at": "2019-10-23T11:44:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418027",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:11"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d069567e351f0dcecd5f790171cf30a5a8089fb3"><code>d069567</code></a></td><td><code>improved popcount without intrinsics</code></td></tr></table>




---

archive/issue_comments_418028.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nThanks. Was a nice exercise to go through it.\n\nReplying to [@dcoudert](#comment%3A10):\n> for popcount, you can use something like this when builtin popcount is not available:\n> \n> ```\n> cdef inline int popcount64(uint64_t i):\n>    \"\"\"\n>    Return the number of '1' bits in a 64-bits integer.\n>    \"\"\"\n>    i = i - ((i >> 1) & 0x5555555555555555ULL)\n>    i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)\n>    return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56\n> ```\n> \n> EDIT: removed inappropriate comment (bad copy/paste)",
    "created_at": "2019-10-23T11:45:39Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418028",
    "user": "https://github.com/kliem"
}
```

<div id="comment:12" align="right">comment:12</div>

Thanks. Was a nice exercise to go through it.

Replying to [@dcoudert](#comment%3A10):
> for popcount, you can use something like this when builtin popcount is not available:
> 
> ```
> cdef inline int popcount64(uint64_t i):
>    """
>    Return the number of '1' bits in a 64-bits integer.
>    """
>    i = i - ((i >> 1) & 0x5555555555555555ULL)
>    i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)
>    return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56
> ```
> 
> EDIT: removed inappropriate comment (bad copy/paste)



---

archive/issue_events_369529.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-10-23T17:50:00Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369529"
}
```



---

archive/issue_comments_418029.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -2,4 +2,4 @@\n \n The subject of this ticket is to carefully enable them.\n \n-Also on machines with AVX and not AVX2, one should consider using `__m256i` instead of 128-bit data, as the crucial calculation is a subset check (A & ~B == 0), which can be done with 256-bit data on AVX with `_mm256_testc_si256`.\n+We implement a faster version of subset check, intersection and popcount (atom count) according to the available intrisics.\n``````\n",
    "created_at": "2019-10-23T17:50:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418029",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -2,4 +2,4 @@
 
 The subject of this ticket is to carefully enable them.
 
-Also on machines with AVX and not AVX2, one should consider using `__m256i` instead of 128-bit data, as the crucial calculation is a subset check (A & ~B == 0), which can be done with 256-bit data on AVX with `_mm256_testc_si256`.
+We implement a faster version of subset check, intersection and popcount (atom count) according to the available intrisics.
``````




---

archive/issue_events_369530.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-10-24T05:25:42Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "title_is": "Enable SIMD-instructions for Combinatorial Polyhedron",
    "title_was": "Further improve CombinatorialPolyhedron: Enable SIMD-instructions",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369530"
}
```



---

archive/issue_comments_418030.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,5 +1,7 @@\n-#26887 prepares SIMD-instructions to speed up calculations.\n+#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).\n \n The subject of this ticket is to carefully enable them.\n \n-We implement a faster version of subset check, intersection and popcount (atom count) according to the available intrisics.\n+We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.\n+\n+We also improve the default popcount (atom count).\n``````\n",
    "created_at": "2019-10-24T05:25:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418030",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,5 +1,7 @@
-#26887 prepares SIMD-instructions to speed up calculations.
+#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).
 
 The subject of this ticket is to carefully enable them.
 
-We implement a faster version of subset check, intersection and popcount (atom count) according to the available intrisics.
+We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.
+
+We also improve the default popcount (atom count).
``````




---

archive/issue_comments_418031.json:
```json
{
    "body": "Author: **David Coudert, Jonathan Kliem**",
    "created_at": "2019-10-24T05:25:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418031",
    "user": "https://github.com/kliem"
}
```

Author: **David Coudert, Jonathan Kliem**



---

archive/issue_comments_418032.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nYou could add an how to help reviewing this ticket. I can test it on OSX, but I assume it's far from enough.\n\nPS: no need to add me as an author. I just gave a small trick from hakmem 169. See e.g. [http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html](http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html)",
    "created_at": "2019-10-24T12:42:22Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418032",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:15" align="right">comment:15</div>

You could add an how to help reviewing this ticket. I can test it on OSX, but I assume it's far from enough.

PS: no need to add me as an author. I just gave a small trick from hakmem 169. See e.g. [http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html](http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html)



---

archive/issue_comments_418033.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -5,3 +5,103 @@\n We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.\n \n We also improve the default popcount (atom count).\n+\n+Timing before this ticket:\n+\n+```\n+sage: P = polytopes.permutahedron(7)\n+sage: import time\n+sage: x = 1000\n+sage: for _ in range(5): \n+....:     C = CombinatorialPolyhedron(P)\n+....:     a = time.time()\n+....:     _ = C.f_vector()\n+....:     b = time.time()\n+....:     x = min(b-a,x)\n+....:     \n+sage: x\n+0.04108405113220215\n+```\n+\n+Timing with this ticket and `SSE4.1`:\n+\n+```\n+...\n+sage: x\n+0.026965856552124023\n+```\n+\n+Timing with this ticket and `AVX`:\n+\n+```\n+...\n+sage: x\n+0.016251087188720703\n+```\n+\n+Timing with this ticket and `AVX2`:\n+\n+```\n+...\n+sage: x\n+0.015423059463500977\n+```\n+\n+** Please help testing this ticket:**\n+\n+It makes sense to test this ticket on top of #27122 or independently.\n+\n+- Test it after having tested #27122:\n+  - I assume you are still on the branch `test_march_native`.\n+  - Run the above test in sage to see what your current timing is.\n+  - pull this ticket: `git pull trac public/27103`\n+  - make sage and run the test again, note the timing\n+  - run related doctests, to see whether everything still works:\n+\n+```\n+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx\n+```\n+- Test it without testing #27122:\n+  - See what your timing for the above example currently is.\n+  - checkout a new branch and pull `public/27103`.\n+  - set the environment variable `CFLAGS` to `-march=native` (if you don't use gcc or clang for compiling sage, you might have to set an equivalent or the specific flags to enable you specific intrinsics):\n+\n+```\n+export $CFLAGS='-march=native'\n+```\n+- remove the cythonized files for combinatorial polyhedron:\n+\n+```\n+rm src/build/cythonized/sage/geometry/polyhedron/combinatorial_polyhedron/*\n+```\n+- Make sage.\n+- Run sage and see what the new timing on the above example is.\n+- run related doctests, to see whether everything still works:\n+\n+```\n+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx\n+```\n+\n+The ticket works if:\n+- sage builds\n+- the related doctests work\n+- you get improved timings according to your available intrinsics\n+\n+Please report success or any failure (with log of the failure) as a comment to this ticket along with\n+- operating system,\n+- kernel,\n+- architecture,\n+- cpu model,\n+- which of the following flags are set `sse4_1 avx avx2 popcnt`.\n+One way to obtain those information is to run the following commands:\n+- Linux:\n+  - `hostnamectl` (for the first three items)\n+  - `lscpu | grep -i \"Model name\"` \n+  - `lscpu | grep -o sse4_1; lscpu | grep -o \"avx \"; lscpu | grep -o avx2; lscpu | grep -o popcnt`\n+- OS X:\n+  - `sysctl -n machdep.cpu.brand_string`\n+  - `sw_vers`\n+  - `uname -a`\n+  - `sysctl -a | grep -o SSE4.1; sysctl -a | grep -o \"AVX \"; sysctl -a | grep -o AVX2; sysctl -a | grep -o POPCNT`\n+\n+Thank you.\n``````\n",
    "created_at": "2019-10-25T09:14:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418033",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -5,3 +5,103 @@
 We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.
 
 We also improve the default popcount (atom count).
+
+Timing before this ticket:
+
+```
+sage: P = polytopes.permutahedron(7)
+sage: import time
+sage: x = 1000
+sage: for _ in range(5): 
+....:     C = CombinatorialPolyhedron(P)
+....:     a = time.time()
+....:     _ = C.f_vector()
+....:     b = time.time()
+....:     x = min(b-a,x)
+....:     
+sage: x
+0.04108405113220215
+```
+
+Timing with this ticket and `SSE4.1`:
+
+```
+...
+sage: x
+0.026965856552124023
+```
+
+Timing with this ticket and `AVX`:
+
+```
+...
+sage: x
+0.016251087188720703
+```
+
+Timing with this ticket and `AVX2`:
+
+```
+...
+sage: x
+0.015423059463500977
+```
+
+** Please help testing this ticket:**
+
+It makes sense to test this ticket on top of #27122 or independently.
+
+- Test it after having tested #27122:
+  - I assume you are still on the branch `test_march_native`.
+  - Run the above test in sage to see what your current timing is.
+  - pull this ticket: `git pull trac public/27103`
+  - make sage and run the test again, note the timing
+  - run related doctests, to see whether everything still works:
+
+```
+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx
+```
+- Test it without testing #27122:
+  - See what your timing for the above example currently is.
+  - checkout a new branch and pull `public/27103`.
+  - set the environment variable `CFLAGS` to `-march=native` (if you don't use gcc or clang for compiling sage, you might have to set an equivalent or the specific flags to enable you specific intrinsics):
+
+```
+export $CFLAGS='-march=native'
+```
+- remove the cythonized files for combinatorial polyhedron:
+
+```
+rm src/build/cythonized/sage/geometry/polyhedron/combinatorial_polyhedron/*
+```
+- Make sage.
+- Run sage and see what the new timing on the above example is.
+- run related doctests, to see whether everything still works:
+
+```
+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx
+```
+
+The ticket works if:
+- sage builds
+- the related doctests work
+- you get improved timings according to your available intrinsics
+
+Please report success or any failure (with log of the failure) as a comment to this ticket along with
+- operating system,
+- kernel,
+- architecture,
+- cpu model,
+- which of the following flags are set `sse4_1 avx avx2 popcnt`.
+One way to obtain those information is to run the following commands:
+- Linux:
+  - `hostnamectl` (for the first three items)
+  - `lscpu | grep -i "Model name"` 
+  - `lscpu | grep -o sse4_1; lscpu | grep -o "avx "; lscpu | grep -o avx2; lscpu | grep -o popcnt`
+- OS X:
+  - `sysctl -n machdep.cpu.brand_string`
+  - `sw_vers`
+  - `uname -a`
+  - `sysctl -a | grep -o SSE4.1; sysctl -a | grep -o "AVX "; sysctl -a | grep -o AVX2; sysctl -a | grep -o POPCNT`
+
+Thank you.
``````




---

archive/issue_comments_418034.json:
```json
{
    "body": "<div id=\"comment:16\" align=\"right\">comment:16</div>\n\nIt works for me.\n\n- Operating System: Debian GNU/Linux 10 (buster)\n- Kernel: Linux 4.19.0-6-amd64\n- Architecture: x86-64\n- CPU Model name: Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz\n- sse4.1, avx, avx2, popcnt",
    "created_at": "2019-10-25T09:14:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418034",
    "user": "https://github.com/kliem"
}
```

<div id="comment:16" align="right">comment:16</div>

It works for me.

- Operating System: Debian GNU/Linux 10 (buster)
- Kernel: Linux 4.19.0-6-amd64
- Architecture: x86-64
- CPU Model name: Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz
- sse4.1, avx, avx2, popcnt



---

archive/issue_comments_418035.json:
```json
{
    "body": "Changed author from **David Coudert, Jonathan Kliem** to **Jonathan Kliem**",
    "created_at": "2019-10-25T09:16:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418035",
    "user": "https://github.com/kliem"
}
```

Changed author from **David Coudert, Jonathan Kliem** to **Jonathan Kliem**



---

archive/issue_comments_418036.json:
```json
{
    "body": "<div id=\"comment:18\" align=\"right\">comment:18</div>\n\nSystem:\n- Operating System: OS X 10.14.6\n- Kernel: Darwin Kernel Version 18.7.0\n- Architecture: x86-64\n- CPU Model name: Intel(R) Core(TM) i7-4650U CPU @ 1.70GHz\n- sse4.1, avx2, popcnt\n\n\nTiming using py3:\n- 0.08155608177185059\nWith this ticket (`git trac checkout 27103`) and CFLAGS set:\n- 0.024885177612304688\n\n\nand all tests pass.",
    "created_at": "2019-10-25T16:30:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418036",
    "user": "https://github.com/dcoudert"
}
```

<div id="comment:18" align="right">comment:18</div>

System:
- Operating System: OS X 10.14.6
- Kernel: Darwin Kernel Version 18.7.0
- Architecture: x86-64
- CPU Model name: Intel(R) Core(TM) i7-4650U CPU @ 1.70GHz
- sse4.1, avx2, popcnt


Timing using py3:
- 0.08155608177185059
With this ticket (`git trac checkout 27103`) and CFLAGS set:
- 0.024885177612304688


and all tests pass.



---

archive/issue_comments_418037.json:
```json
{
    "body": "<div id=\"comment:19\" align=\"right\">comment:19</div>\n\nIf you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.",
    "created_at": "2019-10-26T03:27:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418037",
    "user": "https://github.com/videlec"
}
```

<div id="comment:19" align="right">comment:19</div>

If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.



---

archive/issue_comments_418038.json:
```json
{
    "body": "<div id=\"comment:20\" align=\"right\">comment:20</div>\n\nWorks on\n\n- Operating System: Ubuntu 18.04.3 LTS\n- Kernel: Linux 4.15.0-65-generic\n- Architecture: x86-64\n- Model name:          Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz\n- sse4_1 avx avx2 popcnt\n\nBefore:\n- 0.05162477493286133\nAfter\n- 0.02220010757446289",
    "created_at": "2019-10-26T11:11:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418038",
    "user": "https://github.com/kliem"
}
```

<div id="comment:20" align="right">comment:20</div>

Works on

- Operating System: Ubuntu 18.04.3 LTS
- Kernel: Linux 4.15.0-65-generic
- Architecture: x86-64
- Model name:          Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz
- sse4_1 avx avx2 popcnt

Before:
- 0.05162477493286133
After
- 0.02220010757446289



---

archive/issue_comments_418039.json:
```json
{
    "body": "<div id=\"comment:21\" align=\"right\">comment:21</div>\n\nReplying to [@videlec](#comment%3A19):\n> If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.\n\nYes...\n\nThat is going to be some project, but it definitely makes sense.\n\nOne problem with bitset (to my understanding) so far is, that it is not overaligned. If it is overaligned, loads and stores are supposedly much faster (when using intrinsics).\n\nProbably the best way to find out, is to see how the performance of my code actually changes, when I use bitsets instead of my own implementation.\n\nBtw, if you have a specific example in mind, where calculations with bitsets are the bottle neck, I would be interested.",
    "created_at": "2019-10-26T11:52:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418039",
    "user": "https://github.com/kliem"
}
```

<div id="comment:21" align="right">comment:21</div>

Replying to [@videlec](#comment%3A19):
> If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.

Yes...

That is going to be some project, but it definitely makes sense.

One problem with bitset (to my understanding) so far is, that it is not overaligned. If it is overaligned, loads and stores are supposedly much faster (when using intrinsics).

Probably the best way to find out, is to see how the performance of my code actually changes, when I use bitsets instead of my own implementation.

Btw, if you have a specific example in mind, where calculations with bitsets are the bottle neck, I would be interested.



---

archive/issue_comments_418040.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nFor examples, have a look in the graph code `sage/graphs/` (e.g. iteration over vertex covers, etc). Apparently there are stuff in `sage/combinat/` as well. More generally\n\n```\n$ git grep -l bitset\n```",
    "created_at": "2019-10-26T14:54:15Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418040",
    "user": "https://github.com/videlec"
}
```

<div id="comment:22" align="right">comment:22</div>

For examples, have a look in the graph code `sage/graphs/` (e.g. iteration over vertex covers, etc). Apparently there are stuff in `sage/combinat/` as well. More generally

```
$ git grep -l bitset
```



---

archive/issue_comments_418041.json:
```json
{
    "body": "<div id=\"comment:23\" align=\"right\">comment:23</div>\n\nWorks on top of #27122, itrself on top of Python 3-based 9.0.beta2 on :\n\n- Operating System: Debian GNU/Linux bullseye/sid\n- Kernel: Linux 5.2.0-3-amd64\n- Architecture: x86-64\n- Nom de mod\u00e8le : Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz\n\nBefore: `0.046399831771850586`\n\nAfter: `0.016237735748291016`\n\nAll polyhedra-related tests pass.\n\nHTH,",
    "created_at": "2019-10-26T15:56:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418041",
    "user": "https://github.com/EmmanuelCharpentier"
}
```

<div id="comment:23" align="right">comment:23</div>

Works on top of #27122, itrself on top of Python 3-based 9.0.beta2 on :

- Operating System: Debian GNU/Linux bullseye/sid
- Kernel: Linux 5.2.0-3-amd64
- Architecture: x86-64
- Nom de modèle : Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz

Before: `0.046399831771850586`

After: `0.016237735748291016`

All polyhedra-related tests pass.

HTH,



---

archive/issue_comments_418042.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nI'm almost certain that this is applicable to `sage/data_structures/bitset.pxi`. I ran the following test:\n\n```\nsage: def fill_bitset():\n....:     for _ in range(1000000):\n....:         yield randint(0,10000000000)\n....:     yield 10000000000\n....:     \nsage: a = FrozenBitset(fill_bitset())\nsage: cython('''\n....: from sage.data_structures.bitset cimport bitset_t, FrozenBitset\n....: def intersect(FrozenBitset a, FrozenBitset b):\n....:     a.intersection(b)\n....: ''')\nsage: %timeit intersect(a,a)\n```\n\nWith the current implementation via GMP this takes about 781 ms (best of 3).\n\n```\nmpn_and_n(r.bits, a.bits, b.bits, b.limbs)\n```\nI replaced this by:\n\n```\ncdef mp_size_t i\ncdef mp_limb_t *rb = r.bits, *ab = a.bits, *bb = b.bits\nfor i from 0 <= i < a.limbs:\n    rb[i] = ab[i] & bb[i]\n```\nand it seems to be about the same.\n\nOf course this is a very brief naive test, but there seems to be no reason to use GMP for this specific function. Notice, that this doesn't even use intrinsics.",
    "created_at": "2019-10-26T20:31:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418042",
    "user": "https://github.com/kliem"
}
```

<div id="comment:24" align="right">comment:24</div>

I'm almost certain that this is applicable to `sage/data_structures/bitset.pxi`. I ran the following test:

```
sage: def fill_bitset():
....:     for _ in range(1000000):
....:         yield randint(0,10000000000)
....:     yield 10000000000
....:     
sage: a = FrozenBitset(fill_bitset())
sage: cython('''
....: from sage.data_structures.bitset cimport bitset_t, FrozenBitset
....: def intersect(FrozenBitset a, FrozenBitset b):
....:     a.intersection(b)
....: ''')
sage: %timeit intersect(a,a)
```

With the current implementation via GMP this takes about 781 ms (best of 3).

```
mpn_and_n(r.bits, a.bits, b.bits, b.limbs)
```
I replaced this by:

```
cdef mp_size_t i
cdef mp_limb_t *rb = r.bits, *ab = a.bits, *bb = b.bits
for i from 0 <= i < a.limbs:
    rb[i] = ab[i] & bb[i]
```
and it seems to be about the same.

Of course this is a very brief naive test, but there seems to be no reason to use GMP for this specific function. Notice, that this doesn't even use intrinsics.



---

archive/issue_comments_418043.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nIf you can make `data_structures/bitset.pxi` better this is wonderful. What I want to avoid is two different piece of code that achieve the same thing. Please put your code in `data_structures/` rather than in `polyhedron` and make it as generic as possible. That way it will benefit to others.\n\nAlso, note that not all functions in `bitset.pxi` use GMP/MPIR. Where it does it should be fast. That is comparison (`mpn_cmp`), intersection (`mpn_and_n`), union (`mpn_ior_n`), etc. You might want to have a look at how these are implemented [GMP](https://gmplib.org/)/[MPIR](http://mpir.org/).",
    "created_at": "2019-10-26T21:19:24Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418043",
    "user": "https://github.com/videlec"
}
```

<div id="comment:25" align="right">comment:25</div>

If you can make `data_structures/bitset.pxi` better this is wonderful. What I want to avoid is two different piece of code that achieve the same thing. Please put your code in `data_structures/` rather than in `polyhedron` and make it as generic as possible. That way it will benefit to others.

Also, note that not all functions in `bitset.pxi` use GMP/MPIR. Where it does it should be fast. That is comparison (`mpn_cmp`), intersection (`mpn_and_n`), union (`mpn_ior_n`), etc. You might want to have a look at how these are implemented [GMP](https://gmplib.org/)/[MPIR](http://mpir.org/).



---

archive/issue_comments_418044.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nThings are complicated and a lot more complicated than I thought.\n\n- To my knowledge, I cannot do something as `#if __AVX__` in cython, can I? This would mean, we would have to rewrite bitset in C or C++ to use intrinsics.\n- So far I'm only reimplementing very basic functions.\n- I cannot write simple tests, where intrinsics are much faster. For intersection I don't see an improvement, for subset checks I'm maybe 10% faster. Here is, why I think this might be the case:\n\n  Loading registers takes a lot of time. In many cases this might be the bottle neck. Sure intrinsics need only one processor step instead of four to do bitwise `AND` of two registers. However, when I'm mostly waiting on read/write this does not help. Without intrinsics the processor can still process registers as fast as they can be loaded and stored again (don't forget that the result blocks another register while it is being stored).\n\n  Now in my scenario with subset checks things are a bit different. Nothings needs to be stored after the computation (this would explain why subset check with intrinsics is 10% faster than without). But more importantly seems to be the exact scenario I'm in:\n\n  I'm checking whether `A` is a subset of any of `B_1,...,B_n`. In most cases only the first 256 vertices are needed to discover that `A` is not a subset of `B_i`. So the first register of `A` can be reused a lot of times.\n\n  So, intrinsics might be useful in other scenarios for bitsets in sage, but it's definitly not a no-brainer. One won't lose. That I'm pretty sure of.",
    "created_at": "2019-10-28T10:17:01Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418044",
    "user": "https://github.com/kliem"
}
```

<div id="comment:26" align="right">comment:26</div>

Things are complicated and a lot more complicated than I thought.

- To my knowledge, I cannot do something as `#if __AVX__` in cython, can I? This would mean, we would have to rewrite bitset in C or C++ to use intrinsics.
- So far I'm only reimplementing very basic functions.
- I cannot write simple tests, where intrinsics are much faster. For intersection I don't see an improvement, for subset checks I'm maybe 10% faster. Here is, why I think this might be the case:

  Loading registers takes a lot of time. In many cases this might be the bottle neck. Sure intrinsics need only one processor step instead of four to do bitwise `AND` of two registers. However, when I'm mostly waiting on read/write this does not help. Without intrinsics the processor can still process registers as fast as they can be loaded and stored again (don't forget that the result blocks another register while it is being stored).

  Now in my scenario with subset checks things are a bit different. Nothings needs to be stored after the computation (this would explain why subset check with intrinsics is 10% faster than without). But more importantly seems to be the exact scenario I'm in:

  I'm checking whether `A` is a subset of any of `B_1,...,B_n`. In most cases only the first 256 vertices are needed to discover that `A` is not a subset of `B_i`. So the first register of `A` can be reused a lot of times.

  So, intrinsics might be useful in other scenarios for bitsets in sage, but it's definitly not a no-brainer. One won't lose. That I'm pretty sure of.



---

archive/issue_comments_418045.json:
```json
{
    "body": "<div id=\"comment:27\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/5dc41db60cc3754b7022f153ba52f6140f85bf32\"><code>5dc41db</code></a></td><td><code>fixed copy/paste typo</code></td></tr></table>\n",
    "created_at": "2019-11-04T15:09:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418045",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:27"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/5dc41db60cc3754b7022f153ba52f6140f85bf32"><code>5dc41db</code></a></td><td><code>fixed copy/paste typo</code></td></tr></table>




---

archive/issue_comments_418046.json:
```json
{
    "body": "Changed commit from **[`d069567`](https://github.com/sagemath/sagetrac-mirror/commit/d069567e351f0dcecd5f790171cf30a5a8089fb3)** to **[`5dc41db`](https://github.com/sagemath/sagetrac-mirror/commit/5dc41db60cc3754b7022f153ba52f6140f85bf32)**",
    "created_at": "2019-11-04T15:09:43Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418046",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`d069567`](https://github.com/sagemath/sagetrac-mirror/commit/d069567e351f0dcecd5f790171cf30a5a8089fb3)** to **[`5dc41db`](https://github.com/sagemath/sagetrac-mirror/commit/5dc41db60cc3754b7022f153ba52f6140f85bf32)**



---

archive/issue_comments_418047.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -2,7 +2,7 @@\n \n The subject of this ticket is to carefully enable them.\n \n-We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.\n+We implement faster versions of subset check, intersection and popcount (atom count) according to the available intrinsics.\n \n We also improve the default popcount (atom count).\n \n@@ -93,7 +93,7 @@\n - architecture,\n - cpu model,\n - which of the following flags are set `sse4_1 avx avx2 popcnt`.\n-One way to obtain those information is to run the following commands:\n+One way to obtain this information is to run the following commands:\n - Linux:\n   - `hostnamectl` (for the first three items)\n   - `lscpu | grep -i \"Model name\"` \n``````\n",
    "created_at": "2020-04-26T00:46:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418047",
    "user": "https://github.com/slel"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -2,7 +2,7 @@
 
 The subject of this ticket is to carefully enable them.
 
-We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.
+We implement faster versions of subset check, intersection and popcount (atom count) according to the available intrinsics.
 
 We also improve the default popcount (atom count).
 
@@ -93,7 +93,7 @@
 - architecture,
 - cpu model,
 - which of the following flags are set `sse4_1 avx avx2 popcnt`.
-One way to obtain those information is to run the following commands:
+One way to obtain this information is to run the following commands:
 - Linux:
   - `hostnamectl` (for the first three items)
   - `lscpu | grep -i "Model name"` 
``````




---

archive/issue_comments_418048.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nI will probably move those improvements to `data_structures/bitset.pxi`, once #27122 is done.\n\nIn the mean time, one can of course still pull the attached branch, if one wants to improve the f-vector computation.",
    "created_at": "2020-04-27T07:14:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418048",
    "user": "https://github.com/kliem"
}
```

<div id="comment:30" align="right">comment:30</div>

I will probably move those improvements to `data_structures/bitset.pxi`, once #27122 is done.

In the mean time, one can of course still pull the attached branch, if one wants to improve the f-vector computation.



---

archive/issue_events_369531.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2020-04-27T07:14:04Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369531"
}
```



---

archive/issue_events_369532.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2020-04-27T07:14:04Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369532"
}
```



---

archive/issue_comments_418049.json:
```json
{
    "body": "Changed dependencies from **#26887, #27122** to **#27122**",
    "created_at": "2020-04-27T07:14:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418049",
    "user": "https://github.com/kliem"
}
```

Changed dependencies from **#26887, #27122** to **#27122**



---

archive/issue_comments_418050.json:
```json
{
    "body": "<div id=\"comment:31\"></div>\n\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/39f3a389993dae51d40154a000e4bd79d150910b\"><code>39f3a38</code></a></td><td><code>directly check is_simple/is_simplicial</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bf91483e0aea5b5ad8904162124223f29450e687\"><code>bf91483</code></a></td><td><code>improved count atoms</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fe880a4d5422617f4b15d0b0c36838db3c7fe9b4\"><code>fe880a4</code></a></td><td><code>input of `intersection` in standard order</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1826202d498717d6732e55494f055d78a8428e91\"><code>1826202</code></a></td><td><code>Merge branch 'public/30429' of git://trac.sagemath.org/sage into u/gh-kliem/improved_count_atoms</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/44631b84decef7ad88f33925e4d10d78d4ba2d2e\"><code>44631b8</code></a></td><td><code>enabled intrinsics in bit_vector_operation.cc</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/be5c59038e7914610f4a734971deca6cc47c9646\"><code>be5c590</code></a></td><td><code>consistent namings in comments</code></td></tr></table>\n",
    "created_at": "2020-08-25T08:27:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418050",
    "user": "https://github.com/kliem"
}
```

<div id="comment:31"></div>

New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/39f3a389993dae51d40154a000e4bd79d150910b"><code>39f3a38</code></a></td><td><code>directly check is_simple/is_simplicial</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bf91483e0aea5b5ad8904162124223f29450e687"><code>bf91483</code></a></td><td><code>improved count atoms</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fe880a4d5422617f4b15d0b0c36838db3c7fe9b4"><code>fe880a4</code></a></td><td><code>input of `intersection` in standard order</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1826202d498717d6732e55494f055d78a8428e91"><code>1826202</code></a></td><td><code>Merge branch 'public/30429' of git://trac.sagemath.org/sage into u/gh-kliem/improved_count_atoms</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/44631b84decef7ad88f33925e4d10d78d4ba2d2e"><code>44631b8</code></a></td><td><code>enabled intrinsics in bit_vector_operation.cc</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/be5c59038e7914610f4a734971deca6cc47c9646"><code>be5c590</code></a></td><td><code>consistent namings in comments</code></td></tr></table>




---

archive/issue_comments_418051.json:
```json
{
    "body": "Changed dependencies from **#27122** to **#27122, #30429, #30435**",
    "created_at": "2020-08-25T08:27:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418051",
    "user": "https://github.com/kliem"
}
```

Changed dependencies from **#27122** to **#27122, #30429, #30435**



---

archive/issue_comments_418052.json:
```json
{
    "body": "Changed branch from **[public/27103](https://github.com/sagemath/sagetrac-mirror/tree/public/27103)** to **[public/27103-reb](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb)**",
    "created_at": "2020-08-25T08:27:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418052",
    "user": "https://github.com/kliem"
}
```

Changed branch from **[public/27103](https://github.com/sagemath/sagetrac-mirror/tree/public/27103)** to **[public/27103-reb](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb)**



---

archive/issue_comments_418053.json:
```json
{
    "body": "Changed commit from **[`5dc41db`](https://github.com/sagemath/sagetrac-mirror/commit/5dc41db60cc3754b7022f153ba52f6140f85bf32)** to **[`be5c590`](https://github.com/sagemath/sagetrac-mirror/commit/be5c59038e7914610f4a734971deca6cc47c9646)**",
    "created_at": "2020-08-25T08:27:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418053",
    "user": "https://github.com/kliem"
}
```

Changed commit from **[`5dc41db`](https://github.com/sagemath/sagetrac-mirror/commit/5dc41db60cc3754b7022f153ba52f6140f85bf32)** to **[`be5c590`](https://github.com/sagemath/sagetrac-mirror/commit/be5c59038e7914610f4a734971deca6cc47c9646)**



---

archive/issue_comments_418054.json:
```json
{
    "body": "Changed dependencies from **#27122, #30429, #30435** to **#27122, #30040, #30429, #30435**",
    "created_at": "2020-08-25T12:42:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418054",
    "user": "https://github.com/kliem"
}
```

Changed dependencies from **#27122, #30429, #30435** to **#27122, #30040, #30429, #30435**



---

archive/issue_comments_418055.json:
```json
{
    "body": "Changed commit from **[`be5c590`](https://github.com/sagemath/sagetrac-mirror/commit/be5c59038e7914610f4a734971deca6cc47c9646)** to **[`cd0198e`](https://github.com/sagemath/sagetrac-mirror/commit/cd0198e09e3baeb8ae6e135a1e7e9c504958312a)**",
    "created_at": "2020-08-25T12:42:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418055",
    "user": "https://github.com/kliem"
}
```

Changed commit from **[`be5c590`](https://github.com/sagemath/sagetrac-mirror/commit/be5c59038e7914610f4a734971deca6cc47c9646)** to **[`cd0198e`](https://github.com/sagemath/sagetrac-mirror/commit/cd0198e09e3baeb8ae6e135a1e7e9c504958312a)**



---

archive/issue_comments_418056.json:
```json
{
    "body": "Changed branch from **[public/27103-reb](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb)** to **[public/27103-reb2](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb2)**",
    "created_at": "2020-08-25T12:42:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418056",
    "user": "https://github.com/kliem"
}
```

Changed branch from **[public/27103-reb](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb)** to **[public/27103-reb2](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb2)**



---

archive/issue_comments_418057.json:
```json
{
    "body": "<div id=\"comment:32\"></div>\n\nLast 10 new commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/131c065cf4fa7c9ac76b8a5a5e04c2847c47e6ab\"><code>131c065</code></a></td><td><code>add a specialized `get_next_level_simple`</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bc00d42b653450d1dab1e6ee454288a7626e45b5\"><code>bc00d42</code></a></td><td><code>prepare slightly modified algorithm for simple/simplicial polytopes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4fdc787ca1849002610bdc64bfb2faed27ad5f95\"><code>4fdc787</code></a></td><td><code>faster algorithm for simple/simplicial polytopes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4724d3c3e45bd821b250b5a4bce56147569602f8\"><code>4724d3c</code></a></td><td><code>small fixes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/0297853a04eb342308b7fa0a1259197f6884dfbe\"><code>0297853</code></a></td><td><code>improvements in documentation</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7ffac00417d0143aafefec4c21e3ad59a45cac06\"><code>7ffac00</code></a></td><td><code>changes in 30429</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/01b4154149fcc31347e8591874aa1668907aa315\"><code>01b4154</code></a></td><td><code>typo</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/24350b9fff7e04658030120f53d4e96e342565b9\"><code>24350b9</code></a></td><td><code>Revert \"unite and is_zero for bit_vectors\"</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/49eacaf0925baf03fb4cf684473fa04f2cb9956e\"><code>49eacaf</code></a></td><td><code>Merge branch 'public/27103-reb' of git://trac.sagemath.org/sage into public/27103-reb2</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cd0198e09e3baeb8ae6e135a1e7e9c504958312a\"><code>cd0198e</code></a></td><td><code>unite and is_zero for bit_vectors with intrinsics</code></td></tr></table>\n",
    "created_at": "2020-08-25T12:42:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418057",
    "user": "https://github.com/kliem"
}
```

<div id="comment:32"></div>

Last 10 new commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/131c065cf4fa7c9ac76b8a5a5e04c2847c47e6ab"><code>131c065</code></a></td><td><code>add a specialized `get_next_level_simple`</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bc00d42b653450d1dab1e6ee454288a7626e45b5"><code>bc00d42</code></a></td><td><code>prepare slightly modified algorithm for simple/simplicial polytopes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4fdc787ca1849002610bdc64bfb2faed27ad5f95"><code>4fdc787</code></a></td><td><code>faster algorithm for simple/simplicial polytopes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4724d3c3e45bd821b250b5a4bce56147569602f8"><code>4724d3c</code></a></td><td><code>small fixes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/0297853a04eb342308b7fa0a1259197f6884dfbe"><code>0297853</code></a></td><td><code>improvements in documentation</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7ffac00417d0143aafefec4c21e3ad59a45cac06"><code>7ffac00</code></a></td><td><code>changes in 30429</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/01b4154149fcc31347e8591874aa1668907aa315"><code>01b4154</code></a></td><td><code>typo</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/24350b9fff7e04658030120f53d4e96e342565b9"><code>24350b9</code></a></td><td><code>Revert "unite and is_zero for bit_vectors"</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/49eacaf0925baf03fb4cf684473fa04f2cb9956e"><code>49eacaf</code></a></td><td><code>Merge branch 'public/27103-reb' of git://trac.sagemath.org/sage into public/27103-reb2</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cd0198e09e3baeb8ae6e135a1e7e9c504958312a"><code>cd0198e</code></a></td><td><code>unite and is_zero for bit_vectors with intrinsics</code></td></tr></table>




---

archive/issue_comments_418058.json:
```json
{
    "body": "<div id=\"comment:33\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/20a39b679f660e6b59ba7db4f7c302ab454fe28b\"><code>20a39b6</code></a></td><td><code>outsource inclusion maximal</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b672fcaf65e2219644166a6ed5d8e29c13b4d67d\"><code>b672fca</code></a></td><td><code>removed redundant function</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f62e7706c109174e0a41259578102ad2a626c01a\"><code>f62e770</code></a></td><td><code>merge in #30458</code></td></tr><tr><td><code>[accea52](https://github.com/sagemath/sagetrac-mirror/commit/accea52802a9bcf8f3aea69bd4489ecdcaad94e8)</code></td><td><code>`missing `}</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d3d1385996810fa322133e0f8490b46feee02196\"><code>d3d1385</code></a></td><td><code>Merge branch 'public/30040-reb' of git://trac.sagemath.org/sage into public/27103-reb2</code></td></tr></table>\n",
    "created_at": "2020-08-28T14:35:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418058",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:33"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/20a39b679f660e6b59ba7db4f7c302ab454fe28b"><code>20a39b6</code></a></td><td><code>outsource inclusion maximal</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b672fcaf65e2219644166a6ed5d8e29c13b4d67d"><code>b672fca</code></a></td><td><code>removed redundant function</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f62e7706c109174e0a41259578102ad2a626c01a"><code>f62e770</code></a></td><td><code>merge in #30458</code></td></tr><tr><td><code>[accea52](https://github.com/sagemath/sagetrac-mirror/commit/accea52802a9bcf8f3aea69bd4489ecdcaad94e8)</code></td><td><code>`missing `}</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d3d1385996810fa322133e0f8490b46feee02196"><code>d3d1385</code></a></td><td><code>Merge branch 'public/30040-reb' of git://trac.sagemath.org/sage into public/27103-reb2</code></td></tr></table>




---

archive/issue_comments_418059.json:
```json
{
    "body": "Changed commit from **[`cd0198e`](https://github.com/sagemath/sagetrac-mirror/commit/cd0198e09e3baeb8ae6e135a1e7e9c504958312a)** to **[`d3d1385`](https://github.com/sagemath/sagetrac-mirror/commit/d3d1385996810fa322133e0f8490b46feee02196)**",
    "created_at": "2020-08-28T14:35:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418059",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`cd0198e`](https://github.com/sagemath/sagetrac-mirror/commit/cd0198e09e3baeb8ae6e135a1e7e9c504958312a)** to **[`d3d1385`](https://github.com/sagemath/sagetrac-mirror/commit/d3d1385996810fa322133e0f8490b46feee02196)**



---

archive/issue_comments_418060.json:
```json
{
    "body": "Changed commit from **[`d3d1385`](https://github.com/sagemath/sagetrac-mirror/commit/d3d1385996810fa322133e0f8490b46feee02196)** to **[`67c88cf`](https://github.com/sagemath/sagetrac-mirror/commit/67c88cfb1f22e4f886834e3b6c53487e62ae7f6d)**",
    "created_at": "2020-08-30T06:25:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418060",
    "user": "https://github.com/kliem"
}
```

Changed commit from **[`d3d1385`](https://github.com/sagemath/sagetrac-mirror/commit/d3d1385996810fa322133e0f8490b46feee02196)** to **[`67c88cf`](https://github.com/sagemath/sagetrac-mirror/commit/67c88cfb1f22e4f886834e3b6c53487e62ae7f6d)**



---

archive/issue_comments_418061.json:
```json
{
    "body": "Changed branch from **[public/27103-reb2](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb2)** to **[public/27103-reb3](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb3)**",
    "created_at": "2020-08-30T06:25:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418061",
    "user": "https://github.com/kliem"
}
```

Changed branch from **[public/27103-reb2](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb2)** to **[public/27103-reb3](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb3)**



---

archive/issue_comments_418062.json:
```json
{
    "body": "<div id=\"comment:34\" align=\"right\">comment:34</div>\n\nChanges in #30040.\n\n---\nLast 10 new commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/7f5b19f5a55e7548bafde5d4604bfaed43662b14\"><code>7f5b19f</code></a></td><td><code>unite and is_zero for bit_vectors</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/1496bfdc13ec3a43622469f8c2b6e0b5a302cd29\"><code>1496bfd</code></a></td><td><code>add a specialized `get_next_level_simple`</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fc4784acf1e9fb18e8a159fd7356dbb3b7363041\"><code>fc4784a</code></a></td><td><code>changes in 30429</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/81ba2e0516a5d2fb04dd7ed7b5047342fe82b21f\"><code>81ba2e0</code></a></td><td><code>simplify `get_next_level_simple by 30458</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9cece7476a87a77e3c5f714457c69269b95047ff\"><code>9cece74</code></a></td><td><code>prepare slightly modified algorithm for simple/simplicial polytopes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/fe5852ad6dd7e069862d6c4a4e28a2c985c772d7\"><code>fe5852a</code></a></td><td><code>typo</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/151038630149c150eb4dd9551ceedc05a03fb5a1\"><code>1510386</code></a></td><td><code>faster algorithm for simple/simplicial polytopes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/86c564a86c2fdbba045e9a36974d03ea268a3e2d\"><code>86c564a</code></a></td><td><code>small fixes</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/ed6e966209266875d61895cf8112672675b17960\"><code>ed6e966</code></a></td><td><code>improvements in documentation</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/67c88cfb1f22e4f886834e3b6c53487e62ae7f6d\"><code>67c88cf</code></a></td><td><code>merged in 30040</code></td></tr></table>\n",
    "created_at": "2020-08-30T06:25:19Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418062",
    "user": "https://github.com/kliem"
}
```

<div id="comment:34" align="right">comment:34</div>

Changes in #30040.

---
Last 10 new commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/7f5b19f5a55e7548bafde5d4604bfaed43662b14"><code>7f5b19f</code></a></td><td><code>unite and is_zero for bit_vectors</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/1496bfdc13ec3a43622469f8c2b6e0b5a302cd29"><code>1496bfd</code></a></td><td><code>add a specialized `get_next_level_simple`</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fc4784acf1e9fb18e8a159fd7356dbb3b7363041"><code>fc4784a</code></a></td><td><code>changes in 30429</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/81ba2e0516a5d2fb04dd7ed7b5047342fe82b21f"><code>81ba2e0</code></a></td><td><code>simplify `get_next_level_simple by 30458</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9cece7476a87a77e3c5f714457c69269b95047ff"><code>9cece74</code></a></td><td><code>prepare slightly modified algorithm for simple/simplicial polytopes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/fe5852ad6dd7e069862d6c4a4e28a2c985c772d7"><code>fe5852a</code></a></td><td><code>typo</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/151038630149c150eb4dd9551ceedc05a03fb5a1"><code>1510386</code></a></td><td><code>faster algorithm for simple/simplicial polytopes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/86c564a86c2fdbba045e9a36974d03ea268a3e2d"><code>86c564a</code></a></td><td><code>small fixes</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/ed6e966209266875d61895cf8112672675b17960"><code>ed6e966</code></a></td><td><code>improvements in documentation</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/67c88cfb1f22e4f886834e3b6c53487e62ae7f6d"><code>67c88cf</code></a></td><td><code>merged in 30040</code></td></tr></table>




---

archive/issue_comments_418063.json:
```json
{
    "body": "<div id=\"comment:35\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/cfcdeb677073fc32f8dd57263056b640a7f6a518\"><code>cfcdeb6</code></a></td><td><code>Merge branch 'develop' of git://trac.sagemath.org/sage into public/27103-reb3</code></td></tr></table>\n",
    "created_at": "2020-09-02T06:39:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418063",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:35"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/cfcdeb677073fc32f8dd57263056b640a7f6a518"><code>cfcdeb6</code></a></td><td><code>Merge branch 'develop' of git://trac.sagemath.org/sage into public/27103-reb3</code></td></tr></table>




---

archive/issue_comments_418064.json:
```json
{
    "body": "Changed commit from **[`67c88cf`](https://github.com/sagemath/sagetrac-mirror/commit/67c88cfb1f22e4f886834e3b6c53487e62ae7f6d)** to **[`cfcdeb6`](https://github.com/sagemath/sagetrac-mirror/commit/cfcdeb677073fc32f8dd57263056b640a7f6a518)**",
    "created_at": "2020-09-02T06:39:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418064",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`67c88cf`](https://github.com/sagemath/sagetrac-mirror/commit/67c88cfb1f22e4f886834e3b6c53487e62ae7f6d)** to **[`cfcdeb6`](https://github.com/sagemath/sagetrac-mirror/commit/cfcdeb677073fc32f8dd57263056b640a7f6a518)**



---

archive/issue_comments_418065.json:
```json
{
    "body": "Changed dependencies from **#27122, #30040, #30429, #30435** to **#31208**",
    "created_at": "2021-01-08T10:37:49Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418065",
    "user": "https://github.com/kliem"
}
```

Changed dependencies from **#27122, #30040, #30429, #30435** to **#31208**



---

archive/issue_comments_418066.json:
```json
{
    "body": "Changed keywords from **CombinatorialPolyhedron, SIMD, intrinsics** to **bitsets, CombinatorialPolyhedron, SIMD, intrinsics**",
    "created_at": "2021-01-15T18:06:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418066",
    "user": "https://github.com/kliem"
}
```

Changed keywords from **CombinatorialPolyhedron, SIMD, intrinsics** to **bitsets, CombinatorialPolyhedron, SIMD, intrinsics**



---

archive/issue_comments_418067.json:
```json
{
    "body": "<div id=\"comment:37\" align=\"right\">comment:37</div>\n\nI will update the description yet, but this is basically ready for review.\n\nI got three failing doctests, but I don't think they are related:\n\n```\nsage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/sources.py  # 1 doctest failed                                                                              \nsage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/forker.py  # 1 doctest failed                                                                               \nsage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/interfaces/singular.py  # Killed due to segmentation fault  \n```\n\nOtherwise on my machine everything passes (with AVX2).\n\n(in the above two each time `FDS.in_lib` fails, so that doesn't seem to be related, also the singular timout doesn't seem to be related).\n\n---\nNew commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/348ed67dcc84049a7af369a288c335c5df8d4a87\"><code>348ed67</code></a></td><td><code>use popcnt and tzcnt</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/2713d8922125b80e8c9ab50662d345bf9d102355\"><code>2713d89</code></a></td><td><code>easier instructions</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/9c6edc1300aef994b0f125757c2c4040036b9a7a\"><code>9c6edc1</code></a></td><td><code>better documentation</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/bd78875e2aad36e4631d3c329df411c5afbac39a\"><code>bd78875</code></a></td><td><code>improvements to the frontend</code></td></tr></table>\n",
    "created_at": "2021-01-15T18:06:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418067",
    "user": "https://github.com/kliem"
}
```

<div id="comment:37" align="right">comment:37</div>

I will update the description yet, but this is basically ready for review.

I got three failing doctests, but I don't think they are related:

```
sage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/sources.py  # 1 doctest failed                                                                              
sage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/forker.py  # 1 doctest failed                                                                               
sage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/interfaces/singular.py  # Killed due to segmentation fault  
```

Otherwise on my machine everything passes (with AVX2).

(in the above two each time `FDS.in_lib` fails, so that doesn't seem to be related, also the singular timout doesn't seem to be related).

---
New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/348ed67dcc84049a7af369a288c335c5df8d4a87"><code>348ed67</code></a></td><td><code>use popcnt and tzcnt</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/2713d8922125b80e8c9ab50662d345bf9d102355"><code>2713d89</code></a></td><td><code>easier instructions</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/9c6edc1300aef994b0f125757c2c4040036b9a7a"><code>9c6edc1</code></a></td><td><code>better documentation</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/bd78875e2aad36e4631d3c329df411c5afbac39a"><code>bd78875</code></a></td><td><code>improvements to the frontend</code></td></tr></table>




---

archive/issue_events_369533.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2021-01-15T18:06:52Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/needs%20info",
    "label_color": "ffff00",
    "label_name": "needs info",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369533"
}
```



---

archive/issue_events_369534.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2021-01-15T18:06:52Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369534"
}
```



---

archive/issue_comments_418068.json:
```json
{
    "body": "Changed branch from **[public/27103-reb3](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb3)** to **[public/27103-in-bitsets](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-in-bitsets)**",
    "created_at": "2021-01-15T18:06:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418068",
    "user": "https://github.com/kliem"
}
```

Changed branch from **[public/27103-reb3](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-reb3)** to **[public/27103-in-bitsets](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-in-bitsets)**



---

archive/issue_comments_418069.json:
```json
{
    "body": "Changed commit from **[`cfcdeb6`](https://github.com/sagemath/sagetrac-mirror/commit/cfcdeb677073fc32f8dd57263056b640a7f6a518)** to **[`bd78875`](https://github.com/sagemath/sagetrac-mirror/commit/bd78875e2aad36e4631d3c329df411c5afbac39a)**",
    "created_at": "2021-01-15T18:06:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418069",
    "user": "https://github.com/kliem"
}
```

Changed commit from **[`cfcdeb6`](https://github.com/sagemath/sagetrac-mirror/commit/cfcdeb677073fc32f8dd57263056b640a7f6a518)** to **[`bd78875`](https://github.com/sagemath/sagetrac-mirror/commit/bd78875e2aad36e4631d3c329df411c5afbac39a)**



---

archive/issue_events_369535.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2021-01-15T18:47:51Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369535"
}
```



---

archive/issue_events_369536.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2021-01-15T18:47:51Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/pending",
    "label_color": "008080",
    "label_name": "pending",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369536"
}
```



---

archive/issue_comments_418070.json:
```json
{
    "body": "<div id=\"comment:39\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a\"><code>db11a45</code></a></td><td><code>enable intrinsics for bitsets</code></td></tr></table>\n",
    "created_at": "2021-01-15T18:49:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418070",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:39"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a"><code>db11a45</code></a></td><td><code>enable intrinsics for bitsets</code></td></tr></table>




---

archive/issue_comments_418071.json:
```json
{
    "body": "Changed commit from **[`bd78875`](https://github.com/sagemath/sagetrac-mirror/commit/bd78875e2aad36e4631d3c329df411c5afbac39a)** to **[`db11a45`](https://github.com/sagemath/sagetrac-mirror/commit/db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a)**",
    "created_at": "2021-01-15T18:49:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418071",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`bd78875`](https://github.com/sagemath/sagetrac-mirror/commit/bd78875e2aad36e4631d3c329df411c5afbac39a)** to **[`db11a45`](https://github.com/sagemath/sagetrac-mirror/commit/db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a)**



---

archive/issue_comments_418072.json:
```json
{
    "body": "<div id=\"comment:40\" align=\"right\">comment:40</div>\n\nReplying to [@sagetrac-git](#comment%3A39):\n> Branch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a\"><code>db11a45</code></a></td><td><code>enable intrinsics for bitsets</code></td></tr></table>\n\nForgot to commit.",
    "created_at": "2021-01-15T18:49:18Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418072",
    "user": "https://github.com/kliem"
}
```

<div id="comment:40" align="right">comment:40</div>

Replying to [@sagetrac-git](#comment%3A39):
> Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a"><code>db11a45</code></a></td><td><code>enable intrinsics for bitsets</code></td></tr></table>

Forgot to commit.



---

archive/issue_comments_418073.json:
```json
{
    "body": "Changed commit from **[`db11a45`](https://github.com/sagemath/sagetrac-mirror/commit/db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a)** to **[`65dba93`](https://github.com/sagemath/sagetrac-mirror/commit/65dba93023b83874be5b18d0e3f58ba5484b7db9)**",
    "created_at": "2021-01-15T18:55:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418073",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`db11a45`](https://github.com/sagemath/sagetrac-mirror/commit/db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a)** to **[`65dba93`](https://github.com/sagemath/sagetrac-mirror/commit/65dba93023b83874be5b18d0e3f58ba5484b7db9)**



---

archive/issue_comments_418074.json:
```json
{
    "body": "<div id=\"comment:41\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/65dba93023b83874be5b18d0e3f58ba5484b7db9\"><code>65dba93</code></a></td><td><code>mistakes in the sse4.1 code</code></td></tr></table>\n",
    "created_at": "2021-01-15T18:55:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418074",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:41"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/65dba93023b83874be5b18d0e3f58ba5484b7db9"><code>65dba93</code></a></td><td><code>mistakes in the sse4.1 code</code></td></tr></table>




---

archive/issue_events_369537.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2021-01-15T21:05:14Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "title_is": "Enable SIMD-instructions for Bitsets",
    "title_was": "Enable SIMD-instructions for Combinatorial Polyhedron",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369537"
}
```



---

archive/issue_comments_418075.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,107 +1,177 @@\n-#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).\n+#27122 enabled `-march=native` by default. This allows using intrinsics for Intel and AMD processors (unless the user specified different `CFLAGS` or `CXXFLAGS` differently).\n \n-The subject of this ticket is to carefully enable them.\n+Bitsets allocated using `MemoryAllocator` are overaligned allocated. This is not the case otherwise and there are several reasons not to do so for now:\n+- More memory usage especially for small bitsets (`bitset_t` itself is rather small).\n+- It makes `realloc` a lot harder.\n+- There seems to be only about 10 percent loss when data is not overaligned.\n+- There seems to be only about 1 percent performance loss, when the data is overaligned but the code is not customized for it (`_mm256_loadu_si256` instead of `_mm256_load_si256` etc).\n \n-We implement faster versions of subset check, intersection and popcount (atom count) according to the available intrinsics.\n+See https://software.intel.com/sites/landingpage/IntrinsicsGuide for details about the instructions.\n \n-We also improve the default popcount (atom count).\n+The emptyness check as it is seems be really fast and it appears pointless to beat it using intrinsics.\n \n-Timing before this ticket:\n+A few minor improvements in the bitset frontend of bitsets were also made.\n+\n+Timings without intrinsics (should be exactly the same as without this ticket as the code almost did not change):\n \n ```\n-sage: P = polytopes.permutahedron(7)\n-sage: import time\n-sage: x = 1000\n-sage: for _ in range(5): \n-....:     C = CombinatorialPolyhedron(P)\n-....:     a = time.time()\n-....:     _ = C.f_vector()\n-....:     b = time.time()\n-....:     x = min(b-a,x)\n-....:     \n-sage: x\n-0.04108405113220215\n+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \n+sage: %timeit B == B                                                                                                                                                                \n+7.93 \u00b5s \u00b1 5.71 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: Bop = ~B                                                                                                                                                                      \n+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n+8.11 \u00b5s \u00b1 4.43 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.issubset(B)                                                                                                                                                         \n+7.98 \u00b5s \u00b1 7.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: B2 = ~Bop                                    \n+sage: %timeit B2.intersection_update(B)                                                                                                                                             \n+7.22 \u00b5s \u00b1 20 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B2.union(B)                                                                                                                                                           \n+14.6 \u00b5s \u00b1 5.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n+14 \u00b5s \u00b1 9.34 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.difference_update(Bop)                                                                                                                                              \n+7.2 \u00b5s \u00b1 19.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: P = polytopes.hypercube(14)                                                                                                                                                   \n+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \n+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 12.8 s, sys: 7.98 ms, total: 12.8 s\n+Wall time: 12.8 s\n+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n+\n+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 581 ms, sys: 0 ns, total: 581 ms\n+Wall time: 580 ms\n+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n+\n+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 38 s, sys: 20.2 ms, total: 38 s\n+Wall time: 38 s\n+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n ```\n \n-Timing with this ticket and `SSE4.1`:\n+With SSE4.1 (some of them would also run just with SSE2, but already SSE4.1 is 2008):\n \n ```\n-...\n-sage: x\n-0.026965856552124023\n+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \n+sage: %timeit B == B                                                                                                                                                                \n+7.91 \u00b5s \u00b1 3.03 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: Bop = ~B                                                                                                                                                                      \n+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n+5.1 \u00b5s \u00b1 6.09 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.issubset(B)                                                                                                                                                         \n+4.71 \u00b5s \u00b1 5.07 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: B2 = ~Bop                                                                                                                                                                     \n+sage: %timeit B2.intersection_update(B)                                                                                                                                             \n+5.57 \u00b5s \u00b1 9.94 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B2.union(B)                                                                                                                                                           \n+11.9 \u00b5s \u00b1 5.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n+12.4 \u00b5s \u00b1 7.06 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.difference_update(Bop)                                                                                                                                              \n+4.66 \u00b5s \u00b1 38.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: P = polytopes.hypercube(14)                                                                                                                                                   \n+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \n+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 7.98 s, sys: 4 ms, total: 7.99 s\n+Wall time: 7.98 s\n+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n+\n+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 466 ms, sys: 0 ns, total: 466 ms\n+Wall time: 466 ms\n+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n+                                                                                                                                                                              \n+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 26.8 s, sys: 8.09 ms, total: 26.8 s\n+Wall time: 26.8 s\n+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n ```\n \n-Timing with this ticket and `AVX`:\n+With AVX:\n \n ```\n-...\n-sage: x\n-0.016251087188720703\n+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \n+sage: %timeit B == B                                                                                                                                                                \n+3.99 \u00b5s \u00b1 2.46 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: Bop = ~B                                                                                                                                                                      \n+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n+3.38 \u00b5s \u00b1 12.7 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.issubset(B)                                                                                                                                                         \n+3.05 \u00b5s \u00b1 2.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: P = polytopes.hypercube(14)                                                                                                                                                   \n+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \n+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 5.27 s, sys: 7.97 ms, total: 5.28 s\n+Wall time: 5.28 s\n+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n+\n+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 449 ms, sys: 6 \u00b5s, total: 449 ms\n+Wall time: 449 ms\n+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n+\n+# It does not use subset checks as it is a simple polytope.\n+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 30.4 s, sys: 23.6 ms, total: 30.4 s\n+Wall time: 30.4 s\n+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n ```\n \n-Timing with this ticket and `AVX2`:\n+With AVX2:\n \n ```\n-...\n-sage: x\n-0.015423059463500977\n+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \n+sage: Bop = ~B                                                                                                                                                                      \n+sage: B2 = ~Bop                                                                                                                                                                     \n+sage: %timeit B2.intersection_update(B)                                                                                                                                             \n+4.2 \u00b5s \u00b1 3.28 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B2.union(B)                                                                                                                                                           \n+12 \u00b5s \u00b1 5.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n+12 \u00b5s \u00b1 5.98 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.difference_update(Bop)                                                                                                                                              \n+4.03 \u00b5s \u00b1 3.46 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: P = polytopes.hypercube(14)                                                                                                                                                   \n+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \n+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 5.18 s, sys: 7 \u00b5s, total: 5.18 s\n+Wall time: 5.18 s\n+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n+\n+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 436 ms, sys: 3 \u00b5s, total: 436 ms\n+Wall time: 435 ms\n+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n+\n+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 24.3 s, sys: 19.7 ms, total: 24.3 s\n+Wall time: 24.3 s\n+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n ```\n-\n-** Please help testing this ticket:**\n-\n-It makes sense to test this ticket on top of #27122 or independently.\n-\n-- Test it after having tested #27122:\n-  - I assume you are still on the branch `test_march_native`.\n-  - Run the above test in sage to see what your current timing is.\n-  - pull this ticket: `git pull trac public/27103`\n-  - make sage and run the test again, note the timing\n-  - run related doctests, to see whether everything still works:\n-\n-```\n-sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx\n-```\n-- Test it without testing #27122:\n-  - See what your timing for the above example currently is.\n-  - checkout a new branch and pull `public/27103`.\n-  - set the environment variable `CFLAGS` to `-march=native` (if you don't use gcc or clang for compiling sage, you might have to set an equivalent or the specific flags to enable you specific intrinsics):\n-\n-```\n-export $CFLAGS='-march=native'\n-```\n-- remove the cythonized files for combinatorial polyhedron:\n-\n-```\n-rm src/build/cythonized/sage/geometry/polyhedron/combinatorial_polyhedron/*\n-```\n-- Make sage.\n-- Run sage and see what the new timing on the above example is.\n-- run related doctests, to see whether everything still works:\n-\n-```\n-sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx\n-```\n-\n-The ticket works if:\n-- sage builds\n-- the related doctests work\n-- you get improved timings according to your available intrinsics\n-\n-Please report success or any failure (with log of the failure) as a comment to this ticket along with\n-- operating system,\n-- kernel,\n-- architecture,\n-- cpu model,\n-- which of the following flags are set `sse4_1 avx avx2 popcnt`.\n-One way to obtain this information is to run the following commands:\n-- Linux:\n-  - `hostnamectl` (for the first three items)\n-  - `lscpu | grep -i \"Model name\"` \n-  - `lscpu | grep -o sse4_1; lscpu | grep -o \"avx \"; lscpu | grep -o avx2; lscpu | grep -o popcnt`\n-- OS X:\n-  - `sysctl -n machdep.cpu.brand_string`\n-  - `sw_vers`\n-  - `uname -a`\n-  - `sysctl -a | grep -o SSE4.1; sysctl -a | grep -o \"AVX \"; sysctl -a | grep -o AVX2; sysctl -a | grep -o POPCNT`\n-\n-Thank you.\n``````\n",
    "created_at": "2021-01-15T21:05:14Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418075",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,107 +1,177 @@
-#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).
+#27122 enabled `-march=native` by default. This allows using intrinsics for Intel and AMD processors (unless the user specified different `CFLAGS` or `CXXFLAGS` differently).
 
-The subject of this ticket is to carefully enable them.
+Bitsets allocated using `MemoryAllocator` are overaligned allocated. This is not the case otherwise and there are several reasons not to do so for now:
+- More memory usage especially for small bitsets (`bitset_t` itself is rather small).
+- It makes `realloc` a lot harder.
+- There seems to be only about 10 percent loss when data is not overaligned.
+- There seems to be only about 1 percent performance loss, when the data is overaligned but the code is not customized for it (`_mm256_loadu_si256` instead of `_mm256_load_si256` etc).
 
-We implement faster versions of subset check, intersection and popcount (atom count) according to the available intrinsics.
+See https://software.intel.com/sites/landingpage/IntrinsicsGuide for details about the instructions.
 
-We also improve the default popcount (atom count).
+The emptyness check as it is seems be really fast and it appears pointless to beat it using intrinsics.
 
-Timing before this ticket:
+A few minor improvements in the bitset frontend of bitsets were also made.
+
+Timings without intrinsics (should be exactly the same as without this ticket as the code almost did not change):
 
 ```
-sage: P = polytopes.permutahedron(7)
-sage: import time
-sage: x = 1000
-sage: for _ in range(5): 
-....:     C = CombinatorialPolyhedron(P)
-....:     a = time.time()
-....:     _ = C.f_vector()
-....:     b = time.time()
-....:     x = min(b-a,x)
-....:     
-sage: x
-0.04108405113220215
+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
+sage: %timeit B == B                                                                                                                                                                
+7.93 µs ± 5.71 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: Bop = ~B                                                                                                                                                                      
+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
+8.11 µs ± 4.43 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.issubset(B)                                                                                                                                                         
+7.98 µs ± 7.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: B2 = ~Bop                                    
+sage: %timeit B2.intersection_update(B)                                                                                                                                             
+7.22 µs ± 20 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B2.union(B)                                                                                                                                                           
+14.6 µs ± 5.3 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
+14 µs ± 9.34 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.difference_update(Bop)                                                                                                                                              
+7.2 µs ± 19.2 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: P = polytopes.hypercube(14)                                                                                                                                                   
+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 12.8 s, sys: 7.98 ms, total: 12.8 s
+Wall time: 12.8 s
+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)
+
+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 581 ms, sys: 0 ns, total: 581 ms
+Wall time: 580 ms
+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
+
+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 38 s, sys: 20.2 ms, total: 38 s
+Wall time: 38 s
+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
 ```
 
-Timing with this ticket and `SSE4.1`:
+With SSE4.1 (some of them would also run just with SSE2, but already SSE4.1 is 2008):
 
 ```
-...
-sage: x
-0.026965856552124023
+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
+sage: %timeit B == B                                                                                                                                                                
+7.91 µs ± 3.03 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: Bop = ~B                                                                                                                                                                      
+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
+5.1 µs ± 6.09 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.issubset(B)                                                                                                                                                         
+4.71 µs ± 5.07 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: B2 = ~Bop                                                                                                                                                                     
+sage: %timeit B2.intersection_update(B)                                                                                                                                             
+5.57 µs ± 9.94 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B2.union(B)                                                                                                                                                           
+11.9 µs ± 5.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
+12.4 µs ± 7.06 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.difference_update(Bop)                                                                                                                                              
+4.66 µs ± 38.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: P = polytopes.hypercube(14)                                                                                                                                                   
+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 7.98 s, sys: 4 ms, total: 7.99 s
+Wall time: 7.98 s
+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)
+
+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 466 ms, sys: 0 ns, total: 466 ms
+Wall time: 466 ms
+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
+                                                                                                                                                                              
+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 26.8 s, sys: 8.09 ms, total: 26.8 s
+Wall time: 26.8 s
+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
 ```
 
-Timing with this ticket and `AVX`:
+With AVX:
 
 ```
-...
-sage: x
-0.016251087188720703
+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
+sage: %timeit B == B                                                                                                                                                                
+3.99 µs ± 2.46 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: Bop = ~B                                                                                                                                                                      
+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
+3.38 µs ± 12.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.issubset(B)                                                                                                                                                         
+3.05 µs ± 2.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: P = polytopes.hypercube(14)                                                                                                                                                   
+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 5.27 s, sys: 7.97 ms, total: 5.28 s
+Wall time: 5.28 s
+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)
+
+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 449 ms, sys: 6 µs, total: 449 ms
+Wall time: 449 ms
+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
+
+# It does not use subset checks as it is a simple polytope.
+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 30.4 s, sys: 23.6 ms, total: 30.4 s
+Wall time: 30.4 s
+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
 ```
 
-Timing with this ticket and `AVX2`:
+With AVX2:
 
 ```
-...
-sage: x
-0.015423059463500977
+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
+sage: Bop = ~B                                                                                                                                                                      
+sage: B2 = ~Bop                                                                                                                                                                     
+sage: %timeit B2.intersection_update(B)                                                                                                                                             
+4.2 µs ± 3.28 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B2.union(B)                                                                                                                                                           
+12 µs ± 5.9 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
+12 µs ± 5.98 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.difference_update(Bop)                                                                                                                                              
+4.03 µs ± 3.46 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: P = polytopes.hypercube(14)                                                                                                                                                   
+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 5.18 s, sys: 7 µs, total: 5.18 s
+Wall time: 5.18 s
+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)
+
+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 436 ms, sys: 3 µs, total: 436 ms
+Wall time: 435 ms
+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
+
+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 24.3 s, sys: 19.7 ms, total: 24.3 s
+Wall time: 24.3 s
+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
 ```
-
-** Please help testing this ticket:**
-
-It makes sense to test this ticket on top of #27122 or independently.
-
-- Test it after having tested #27122:
-  - I assume you are still on the branch `test_march_native`.
-  - Run the above test in sage to see what your current timing is.
-  - pull this ticket: `git pull trac public/27103`
-  - make sage and run the test again, note the timing
-  - run related doctests, to see whether everything still works:
-
-```
-sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx
-```
-- Test it without testing #27122:
-  - See what your timing for the above example currently is.
-  - checkout a new branch and pull `public/27103`.
-  - set the environment variable `CFLAGS` to `-march=native` (if you don't use gcc or clang for compiling sage, you might have to set an equivalent or the specific flags to enable you specific intrinsics):
-
-```
-export $CFLAGS='-march=native'
-```
-- remove the cythonized files for combinatorial polyhedron:
-
-```
-rm src/build/cythonized/sage/geometry/polyhedron/combinatorial_polyhedron/*
-```
-- Make sage.
-- Run sage and see what the new timing on the above example is.
-- run related doctests, to see whether everything still works:
-
-```
-sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx
-```
-
-The ticket works if:
-- sage builds
-- the related doctests work
-- you get improved timings according to your available intrinsics
-
-Please report success or any failure (with log of the failure) as a comment to this ticket along with
-- operating system,
-- kernel,
-- architecture,
-- cpu model,
-- which of the following flags are set `sse4_1 avx avx2 popcnt`.
-One way to obtain this information is to run the following commands:
-- Linux:
-  - `hostnamectl` (for the first three items)
-  - `lscpu | grep -i "Model name"` 
-  - `lscpu | grep -o sse4_1; lscpu | grep -o "avx "; lscpu | grep -o avx2; lscpu | grep -o popcnt`
-- OS X:
-  - `sysctl -n machdep.cpu.brand_string`
-  - `sw_vers`
-  - `uname -a`
-  - `sysctl -a | grep -o SSE4.1; sysctl -a | grep -o "AVX "; sysctl -a | grep -o AVX2; sysctl -a | grep -o POPCNT`
-
-Thank you.
``````




---

archive/issue_comments_418076.json:
```json
{
    "body": "Changed commit from **[`65dba93`](https://github.com/sagemath/sagetrac-mirror/commit/65dba93023b83874be5b18d0e3f58ba5484b7db9)** to **[`8bd0b1f`](https://github.com/sagemath/sagetrac-mirror/commit/8bd0b1fe087a802603b426bd22d51458b951d776)**",
    "created_at": "2021-01-15T21:19:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418076",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`65dba93`](https://github.com/sagemath/sagetrac-mirror/commit/65dba93023b83874be5b18d0e3f58ba5484b7db9)** to **[`8bd0b1f`](https://github.com/sagemath/sagetrac-mirror/commit/8bd0b1fe087a802603b426bd22d51458b951d776)**



---

archive/issue_comments_418077.json:
```json
{
    "body": "<div id=\"comment:43\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/a4f2e44008d4de38f40d6505e0cb3b364ee36edc\"><code>a4f2e44</code></a></td><td><code>remove sse4.1 for equality check, as it does not help</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/8bd0b1fe087a802603b426bd22d51458b951d776\"><code>8bd0b1f</code></a></td><td><code>remove assumption that LIMBS contain 64 bits</code></td></tr></table>\n",
    "created_at": "2021-01-15T21:19:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418077",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:43"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/a4f2e44008d4de38f40d6505e0cb3b364ee36edc"><code>a4f2e44</code></a></td><td><code>remove sse4.1 for equality check, as it does not help</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/8bd0b1fe087a802603b426bd22d51458b951d776"><code>8bd0b1f</code></a></td><td><code>remove assumption that LIMBS contain 64 bits</code></td></tr></table>




---

archive/issue_comments_418078.json:
```json
{
    "body": "<div id=\"comment:44\" align=\"right\">comment:44</div>\n\nAlso works for me with\n\n- Operating System: Ubuntu 18.04.5 LTS\n- Kernel: Linux 4.15.0-112-generic\n- Architecture: x86-64\n- Model: Intel(R) Core(TM) i7-8700 CPU @ 3.20GHz\n- sse4_1, sse4_2, avx, avx2 in cpu flags\n\nBased on this, the patchbots, and the previous comments, I am setting this to a positive review.",
    "created_at": "2021-01-17T02:13:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418078",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:44" align="right">comment:44</div>

Also works for me with

- Operating System: Ubuntu 18.04.5 LTS
- Kernel: Linux 4.15.0-112-generic
- Architecture: x86-64
- Model: Intel(R) Core(TM) i7-8700 CPU @ 3.20GHz
- sse4_1, sse4_2, avx, avx2 in cpu flags

Based on this, the patchbots, and the previous comments, I am setting this to a positive review.



---

archive/issue_comments_418079.json:
```json
{
    "body": "Reviewer: **Travis Scrimshaw**",
    "created_at": "2021-01-17T02:13:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418079",
    "user": "https://github.com/tscrim"
}
```

Reviewer: **Travis Scrimshaw**



---

archive/issue_events_369538.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2021-01-17T02:13:38Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369538"
}
```



---

archive/issue_events_369539.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2021-01-17T02:13:38Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369539"
}
```



---

archive/issue_comments_418080.json:
```json
{
    "body": "<div id=\"comment:45\" align=\"right\">comment:45</div>\n\nThank you.",
    "created_at": "2021-01-17T08:36:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418080",
    "user": "https://github.com/kliem"
}
```

<div id="comment:45" align="right">comment:45</div>

Thank you.



---

archive/issue_events_369540.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-01-31T20:53:48Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369540"
}
```



---

archive/issue_events_369541.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "2c32dab63a54a0197197ed8b1d2a7c60d5e0515a",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2021-01-31T20:53:48Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/27103#event-369541"
}
```



---

archive/issue_comments_418081.json:
```json
{
    "body": "Changed branch from **[public/27103-in-bitsets](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-in-bitsets)** to **[`8bd0b1f`](https://github.com/sagemath/sagetrac-mirror/commit/8bd0b1fe087a802603b426bd22d51458b951d776)**",
    "created_at": "2021-01-31T20:53:48Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/27103#issuecomment-418081",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[public/27103-in-bitsets](https://github.com/sagemath/sagetrac-mirror/tree/public/27103-in-bitsets)** to **[`8bd0b1f`](https://github.com/sagemath/sagetrac-mirror/commit/8bd0b1fe087a802603b426bd22d51458b951d776)**
