# Issue 27103: Enable SIMD-instructions for Bitsets

archive/issues_026866.json:
```json
{
    "body": "#27122 enabled `-march=native` by default. This allows using intrinsics for Intel and AMD processors (unless the user specified different `CFLAGS` or `CXXFLAGS` differently).\n\nBitsets allocated using `MemoryAllocator` are overaligned allocated. This is not the case otherwise and there are several reasons not to do so for now:\n- More memory usage especially for small bitsets (`bitset_t` itself is rather small).\n- It makes `realloc` a lot harder.\n- There seems to be only about 10 percent loss when data is not overaligned.\n- There seems to be only about 1 percent performance loss, when the data is overaligned but the code is not customized for it (`_mm256_loadu_si256` instead of `_mm256_load_si256` etc).\n\nSee https://software.intel.com/sites/landingpage/IntrinsicsGuide for details about the instructions.\n\nThe emptyness check as it is seems be really fast and it appears pointless to beat it using intrinsics.\n\nA few minor improvements in the bitset frontend of bitsets were also made.\n\nTimings without intrinsics (should be exactly the same as without this ticket as the code almost did not change):\n\n```\nsage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \nsage: %timeit B == B                                                                                                                                                                \n7.93 \u00b5s \u00b1 5.71 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: Bop = ~B                                                                                                                                                                      \nsage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n8.11 \u00b5s \u00b1 4.43 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.issubset(B)                                                                                                                                                         \n7.98 \u00b5s \u00b1 7.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: B2 = ~Bop                                    \nsage: %timeit B2.intersection_update(B)                                                                                                                                             \n7.22 \u00b5s \u00b1 20 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B2.union(B)                                                                                                                                                           \n14.6 \u00b5s \u00b1 5.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n14 \u00b5s \u00b1 9.34 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.difference_update(Bop)                                                                                                                                              \n7.2 \u00b5s \u00b1 19.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: P = polytopes.hypercube(14)                                                                                                                                                   \nsage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \nsage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 12.8 s, sys: 7.98 ms, total: 12.8 s\nWall time: 12.8 s\n(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n\nsage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 581 ms, sys: 0 ns, total: 581 ms\nWall time: 580 ms\n(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n\nsage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 38 s, sys: 20.2 ms, total: 38 s\nWall time: 38 s\n(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n```\n\nWith SSE4.1 (some of them would also run just with SSE2, but already SSE4.1 is 2008):\n\n```\nsage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \nsage: %timeit B == B                                                                                                                                                                \n7.91 \u00b5s \u00b1 3.03 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: Bop = ~B                                                                                                                                                                      \nsage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n5.1 \u00b5s \u00b1 6.09 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.issubset(B)                                                                                                                                                         \n4.71 \u00b5s \u00b1 5.07 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: B2 = ~Bop                                                                                                                                                                     \nsage: %timeit B2.intersection_update(B)                                                                                                                                             \n5.57 \u00b5s \u00b1 9.94 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B2.union(B)                                                                                                                                                           \n11.9 \u00b5s \u00b1 5.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n12.4 \u00b5s \u00b1 7.06 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.difference_update(Bop)                                                                                                                                              \n4.66 \u00b5s \u00b1 38.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: P = polytopes.hypercube(14)                                                                                                                                                   \nsage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \nsage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 7.98 s, sys: 4 ms, total: 7.99 s\nWall time: 7.98 s\n(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n\nsage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 466 ms, sys: 0 ns, total: 466 ms\nWall time: 466 ms\n(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n                                                                                                                                                                              \nsage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 26.8 s, sys: 8.09 ms, total: 26.8 s\nWall time: 26.8 s\n(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n```\n\nWith AVX:\n\n```\nsage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \nsage: %timeit B == B                                                                                                                                                                \n3.99 \u00b5s \u00b1 2.46 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: Bop = ~B                                                                                                                                                                      \nsage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n3.38 \u00b5s \u00b1 12.7 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.issubset(B)                                                                                                                                                         \n3.05 \u00b5s \u00b1 2.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: P = polytopes.hypercube(14)                                                                                                                                                   \nsage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \nsage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 5.27 s, sys: 7.97 ms, total: 5.28 s\nWall time: 5.28 s\n(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n\nsage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 449 ms, sys: 6 \u00b5s, total: 449 ms\nWall time: 449 ms\n(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n\n# It does not use subset checks as it is a simple polytope.\nsage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 30.4 s, sys: 23.6 ms, total: 30.4 s\nWall time: 30.4 s\n(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n```\n\nWith AVX2:\n\n```\nsage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \nsage: Bop = ~B                                                                                                                                                                      \nsage: B2 = ~Bop                                                                                                                                                                     \nsage: %timeit B2.intersection_update(B)                                                                                                                                             \n4.2 \u00b5s \u00b1 3.28 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B2.union(B)                                                                                                                                                           \n12 \u00b5s \u00b1 5.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n12 \u00b5s \u00b1 5.98 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage: %timeit B.difference_update(Bop)                                                                                                                                              \n4.03 \u00b5s \u00b1 3.46 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n\nsage: P = polytopes.hypercube(14)                                                                                                                                                   \nsage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \nsage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 5.18 s, sys: 7 \u00b5s, total: 5.18 s\nWall time: 5.18 s\n(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n\nsage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 436 ms, sys: 3 \u00b5s, total: 436 ms\nWall time: 435 ms\n(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n\nsage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \nsage: C = CombinatorialPolyhedron(P)                                                                                                                                                \nsage: %time C.f_vector()                                                                                                                                                            \nCPU times: user 24.3 s, sys: 19.7 ms, total: 24.3 s\nWall time: 24.3 s\n(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n```\n\nCC:  @sophiasage stumpc5 @hivert @slel @tscrim\n\nKeywords: bitsets, CombinatorialPolyhedron, SIMD, intrinsics\n\nBranch/Commit: 8bd0b1fe087a802603b426bd22d51458b951d776\n\nReviewer: Travis Scrimshaw\n\nAuthor: Jonathan Kliem\n\nDependencies: #31208\n\nResolution: fixed\n\nIssue created by migration from https://trac.sagemath.org/ticket/27103\n\n",
    "closed_at": "2021-01-31T20:53:48Z",
    "created_at": "2019-01-23T20:11:47Z",
    "labels": [
        "component: geometry"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.3",
    "title": "Enable SIMD-instructions for Bitsets",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27103",
    "user": "https://github.com/kliem"
}
```
#27122 enabled `-march=native` by default. This allows using intrinsics for Intel and AMD processors (unless the user specified different `CFLAGS` or `CXXFLAGS` differently).

Bitsets allocated using `MemoryAllocator` are overaligned allocated. This is not the case otherwise and there are several reasons not to do so for now:
- More memory usage especially for small bitsets (`bitset_t` itself is rather small).
- It makes `realloc` a lot harder.
- There seems to be only about 10 percent loss when data is not overaligned.
- There seems to be only about 1 percent performance loss, when the data is overaligned but the code is not customized for it (`_mm256_loadu_si256` instead of `_mm256_load_si256` etc).

See https://software.intel.com/sites/landingpage/IntrinsicsGuide for details about the instructions.

The emptyness check as it is seems be really fast and it appears pointless to beat it using intrinsics.

A few minor improvements in the bitset frontend of bitsets were also made.

Timings without intrinsics (should be exactly the same as without this ticket as the code almost did not change):

```
sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
sage: %timeit B == B                                                                                                                                                                
7.93 µs ± 5.71 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: Bop = ~B                                                                                                                                                                      
sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
8.11 µs ± 4.43 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.issubset(B)                                                                                                                                                         
7.98 µs ± 7.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: B2 = ~Bop                                    
sage: %timeit B2.intersection_update(B)                                                                                                                                             
7.22 µs ± 20 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B2.union(B)                                                                                                                                                           
14.6 µs ± 5.3 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
14 µs ± 9.34 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.difference_update(Bop)                                                                                                                                              
7.2 µs ± 19.2 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: P = polytopes.hypercube(14)                                                                                                                                                   
sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 12.8 s, sys: 7.98 ms, total: 12.8 s
Wall time: 12.8 s
(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)

sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 581 ms, sys: 0 ns, total: 581 ms
Wall time: 580 ms
(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)

sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 38 s, sys: 20.2 ms, total: 38 s
Wall time: 38 s
(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
```

With SSE4.1 (some of them would also run just with SSE2, but already SSE4.1 is 2008):

```
sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
sage: %timeit B == B                                                                                                                                                                
7.91 µs ± 3.03 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: Bop = ~B                                                                                                                                                                      
sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
5.1 µs ± 6.09 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.issubset(B)                                                                                                                                                         
4.71 µs ± 5.07 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: B2 = ~Bop                                                                                                                                                                     
sage: %timeit B2.intersection_update(B)                                                                                                                                             
5.57 µs ± 9.94 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B2.union(B)                                                                                                                                                           
11.9 µs ± 5.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
12.4 µs ± 7.06 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.difference_update(Bop)                                                                                                                                              
4.66 µs ± 38.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: P = polytopes.hypercube(14)                                                                                                                                                   
sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 7.98 s, sys: 4 ms, total: 7.99 s
Wall time: 7.98 s
(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)

sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 466 ms, sys: 0 ns, total: 466 ms
Wall time: 466 ms
(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
                                                                                                                                                                              
sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 26.8 s, sys: 8.09 ms, total: 26.8 s
Wall time: 26.8 s
(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
```

With AVX:

```
sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
sage: %timeit B == B                                                                                                                                                                
3.99 µs ± 2.46 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: Bop = ~B                                                                                                                                                                      
sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
3.38 µs ± 12.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.issubset(B)                                                                                                                                                         
3.05 µs ± 2.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: P = polytopes.hypercube(14)                                                                                                                                                   
sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 5.27 s, sys: 7.97 ms, total: 5.28 s
Wall time: 5.28 s
(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)

sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 449 ms, sys: 6 µs, total: 449 ms
Wall time: 449 ms
(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)

# It does not use subset checks as it is a simple polytope.
sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 30.4 s, sys: 23.6 ms, total: 30.4 s
Wall time: 30.4 s
(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
```

With AVX2:

```
sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
sage: Bop = ~B                                                                                                                                                                      
sage: B2 = ~Bop                                                                                                                                                                     
sage: %timeit B2.intersection_update(B)                                                                                                                                             
4.2 µs ± 3.28 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B2.union(B)                                                                                                                                                           
12 µs ± 5.9 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
12 µs ± 5.98 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage: %timeit B.difference_update(Bop)                                                                                                                                              
4.03 µs ± 3.46 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)

sage: P = polytopes.hypercube(14)                                                                                                                                                   
sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 5.18 s, sys: 7 µs, total: 5.18 s
Wall time: 5.18 s
(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)

sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 436 ms, sys: 3 µs, total: 436 ms
Wall time: 435 ms
(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)

sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
sage: %time C.f_vector()                                                                                                                                                            
CPU times: user 24.3 s, sys: 19.7 ms, total: 24.3 s
Wall time: 24.3 s
(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
```

CC:  @sophiasage stumpc5 @hivert @slel @tscrim

Keywords: bitsets, CombinatorialPolyhedron, SIMD, intrinsics

Branch/Commit: 8bd0b1fe087a802603b426bd22d51458b951d776

Reviewer: Travis Scrimshaw

Author: Jonathan Kliem

Dependencies: #31208

Resolution: fixed

Issue created by migration from https://trac.sagemath.org/ticket/27103





---

archive/issue_comments_521223.json:
```json
{
    "body": "Changing keywords from \"CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector\" to \"CombinatorialPolyhedron, SIMD, intrinsics\".",
    "created_at": "2019-01-25T22:57:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521223",
    "user": "https://github.com/kliem"
}
```

Changing keywords from "CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector" to "CombinatorialPolyhedron, SIMD, intrinsics".



---

archive/issue_comments_521224.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,16 +1,8 @@\n-The crucial calculation for pretty much everything in CombinatorialPolyhedron (#26887) is to check whether a face A is a (sub-)face of a different face B.\n+#26887 prepares SIMD-instructions to speed up calculations.\n \n-Once converted to Bits representing each vertex the question is A & ~B == 0.\n+The subject of this ticket is to carefully enable them.\n \n-This is fastly computed with processor intrinsics (_mm256_testc_si256 or _mm_testc_si128). AVX can do this with 256 bit chunks.\n-\n-To compute e.g. the f-vector, one also needs the intersection of two faces or bitwise AND. AVX cannot do this with 256 bit chunks, but AVX2 can.\n-\n-Currently the choice for AVX but not AVX2 is to compute with 128 bit chunks.\n-\n-As the subset check is very much the bottle neck of the computations, we should split 256 bits again in two for intersection, when AVX is available but AVX2 is not. This should give a speedup of almost two on large Polyhedra.\n-\n-Keywords: CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector\n+Also on machines with AVX and not AVX2, one should consider using `__m256i` instead of 128-bit data, as the crucial calculation is a subset check (A & ~B == 0), which can be done with 256-bit data on AVX with `_mm256_testc_si256`.\n \n Dependencies: #26887\n \n``````\n",
    "created_at": "2019-01-25T22:57:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521224",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,16 +1,8 @@
-The crucial calculation for pretty much everything in CombinatorialPolyhedron (#26887) is to check whether a face A is a (sub-)face of a different face B.
+#26887 prepares SIMD-instructions to speed up calculations.
 
-Once converted to Bits representing each vertex the question is A & ~B == 0.
+The subject of this ticket is to carefully enable them.
 
-This is fastly computed with processor intrinsics (_mm256_testc_si256 or _mm_testc_si128). AVX can do this with 256 bit chunks.
-
-To compute e.g. the f-vector, one also needs the intersection of two faces or bitwise AND. AVX cannot do this with 256 bit chunks, but AVX2 can.
-
-Currently the choice for AVX but not AVX2 is to compute with 128 bit chunks.
-
-As the subset check is very much the bottle neck of the computations, we should split 256 bits again in two for intersection, when AVX is available but AVX2 is not. This should give a speedup of almost two on large Polyhedra.
-
-Keywords: CombinatorialPolyhedron, polytopes, f-vector, edge graph, flag vector
+Also on machines with AVX and not AVX2, one should consider using `__m256i` instead of 128-bit data, as the crucial calculation is a subset check (A & ~B == 0), which can be done with 256-bit data on AVX with `_mm256_testc_si256`.
 
 Dependencies: #26887
 
``````




---

archive/issue_comments_521225.json:
```json
{
    "body": "Changing dependencies from \"#26887\" to \"#26887, #27122\"",
    "created_at": "2019-01-25T22:57:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521225",
    "user": "https://github.com/kliem"
}
```

Changing dependencies from "#26887" to "#26887, #27122"



---

archive/issue_comments_521226.json:
```json
{
    "body": "<a id='comment:3'></a>This is a way, one could boost CombinatorialPolyhedron with intrinsics. Replace `is_subset`, `intersection` and `CountFaceBits` by those functions:\n\n```\n#if __AVX__\n    #include <immintrin.h>\n#elif __SSE4_1__\n    #include <emmintrin.h>\n    #include <smmintrin.h>\n#endif\n\n#if __POPCNT__\n    #include <immintrin.h>\n#endif\n\n\n// as of now, 512bit does not have something like _mm256_testc_si256,\n// which is the bottle neck of this function,\n// so it does not make sense to implement it\n\n// inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length)\n// the bottlen-neck is checking for subsets, which requires something as\n// _mm256_testc_si256, trying to determine, what is the best way of doing it:\n#if __AVX__\n    // 256-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrics defined in immintrin.h\n    const size_t chunksize = 256;\n    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){\n        // A & ~B == 0\n        // returns 1 if A is a subset of B, otherwise returns 0\n        // this is done by checking if there is an element in A,\n        // which is not in B\n        // `face_length` is the length of A and B in terms of uint64_t\n        // note that A,B need to be 32-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 4){\n            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);\n            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);\n            if (!_mm256_testc_si256(b, a)){ //need to be opposite order !!\n                return 0;\n            }\n        }\n        return 1;\n    }\n\n#elif __SSE4_1__\n    // 128-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrics defined in smmintrin.h and emmintrin.h\n    const size_t chunksize = 128;\n    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){\n        // A & ~B == 0\n        // returns 1 if A is a subset of B, otherwise returns 0\n        // this is done by checking if there is an element in A,\n        // which is not in B\n        // `face_length` is the length of A and B in terms of uint64_t\n        // note that A,B need to be 16-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 2){\n            __m128i a = _mm_load_si128((const __m128i*)&A[i]);\n            __m128i b = _mm_load_si128((const __m128i*)&B[i]);\n            if (!_mm_testc_si128(b, a)){ //need to be opposite order !!\n                return 0;\n            }\n        }\n        return 1;\n    }\n\n#else\n    // no intrinsics\n    const size_t chunksize = 64;\n    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){\n        // A & ~B == 0\n        // returns 1 if A is a subset of B, otherwise returns 0\n        // this is done by checking if there is an element in A,\n        // which is not in B\n        // `face_length` is the length of A and B in terms of uint64_t\n        size_t i;\n        for (i = 0; i < face_length; i++){\n            if (A[i] & ~B[i]){\n                return 0;\n            }\n        }\n        return 1;\n    }\n\n#endif\n\n// inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C,\n//                          size_t face_length)\n// now determining, how to do insersection\n#if __AVX2__\n    // 256-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrics defined in immintrin.h\n    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \\\n                             size_t face_length){\n        // C = A & B\n        // will set C to be the intersection of A and B\n        // `face_length` is the length of A, B and C in terms of uint64_t\n        // note that A,B,C need to be 32-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 4){\n            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);\n            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);\n            __m256i c = _mm256_and_si256(a, b);\n            _mm256_store_si256((__m256i*)&C[i],c);\n        }\n    }\n\n#elif __SSE4_1__\n    // actually SSE2 would be fine, but we don't want to force greater chunks,\n    // because of intersection, which is not the bottleneck\n    // 128-bit commands, those operations are equivalent to the operations\n    // defined in `#else`\n    // intrinsics defined in emmintrin.h\n    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \\\n                             size_t face_length){\n        // C = A & B\n        // will set C to be the intersection of A and B\n        // `face_length` is the length of A, B and C in terms of uint64_t\n        // note that A,B,C need to be 16-byte-aligned\n        size_t i;\n        for (i = 0; i < face_length; i += 2){\n            __m128i a = _mm_load_si128((const __m128i*)&A[i]);\n            __m128i b = _mm_load_si128((const __m128i*)&B[i]);\n            __m128i c = _mm_and_si128(a, b);\n            _mm_store_si128((__m128i*)&C[i],c);\n        }\n    }\n\n#else\n    // commands, without intrinsics\n    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \\\n                             size_t face_length){\n        // C = A & B\n        // will set C to be the intersection of A and B\n        // `face_length` is the length of A, B and C in terms of uint64_t\n        size_t i;\n        for (i = 0; i < face_length; i++){\n            C[i] = A[i] & B[i];\n        }\n    }\n\n#endif\n\n// inline size_t CountFaceBits(uint64_t* A, size_t face_length)\n// determine the best way to count the set bits in uint64_t *\n#if (__POPCNT__) && (INTPTR_MAX == INT64_MAX) // 64-bit and popcnt\n    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {\n        // counts the number of vertices in a face by counting bits set to one\n        // `face_length` is the length of A in terms of uint64_t\n        size_t i;\n        unsigned int count = 0;\n        for (i=0; i<face_length; i++){\n            count += (size_t) _mm_popcnt_u64(A[i]);\n        }\n        return count;\n    }\n\n#else // popcount without intrinsics\n    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {\n        // counts the number of vertices in a face by counting bits set to one\n        // `face_length` is the length of A in terms of uint64_t\n        size_t i;\n        unsigned int count = 0;\n        for (i=0; i<face_length; i++){\n            uint64_t a = A[i];\n            while (a){\n                count += a & 1;\n                a >>= 1;\n            }\n        }\n        return count;\n    }\n\n#endif\n```",
    "created_at": "2019-02-20T15:45:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521226",
    "user": "https://github.com/kliem"
}
```

<a id='comment:3'></a>This is a way, one could boost CombinatorialPolyhedron with intrinsics. Replace `is_subset`, `intersection` and `CountFaceBits` by those functions:

```
#if __AVX__
    #include <immintrin.h>
#elif __SSE4_1__
    #include <emmintrin.h>
    #include <smmintrin.h>
#endif

#if __POPCNT__
    #include <immintrin.h>
#endif


// as of now, 512bit does not have something like _mm256_testc_si256,
// which is the bottle neck of this function,
// so it does not make sense to implement it

// inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length)
// the bottlen-neck is checking for subsets, which requires something as
// _mm256_testc_si256, trying to determine, what is the best way of doing it:
#if __AVX__
    // 256-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrics defined in immintrin.h
    const size_t chunksize = 256;
    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){
        // A & ~B == 0
        // returns 1 if A is a subset of B, otherwise returns 0
        // this is done by checking if there is an element in A,
        // which is not in B
        // `face_length` is the length of A and B in terms of uint64_t
        // note that A,B need to be 32-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 4){
            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);
            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);
            if (!_mm256_testc_si256(b, a)){ //need to be opposite order !!
                return 0;
            }
        }
        return 1;
    }

#elif __SSE4_1__
    // 128-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrics defined in smmintrin.h and emmintrin.h
    const size_t chunksize = 128;
    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){
        // A & ~B == 0
        // returns 1 if A is a subset of B, otherwise returns 0
        // this is done by checking if there is an element in A,
        // which is not in B
        // `face_length` is the length of A and B in terms of uint64_t
        // note that A,B need to be 16-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 2){
            __m128i a = _mm_load_si128((const __m128i*)&A[i]);
            __m128i b = _mm_load_si128((const __m128i*)&B[i]);
            if (!_mm_testc_si128(b, a)){ //need to be opposite order !!
                return 0;
            }
        }
        return 1;
    }

#else
    // no intrinsics
    const size_t chunksize = 64;
    inline int is_subset(uint64_t *A, uint64_t *B, size_t face_length){
        // A & ~B == 0
        // returns 1 if A is a subset of B, otherwise returns 0
        // this is done by checking if there is an element in A,
        // which is not in B
        // `face_length` is the length of A and B in terms of uint64_t
        size_t i;
        for (i = 0; i < face_length; i++){
            if (A[i] & ~B[i]){
                return 0;
            }
        }
        return 1;
    }

#endif

// inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C,
//                          size_t face_length)
// now determining, how to do insersection
#if __AVX2__
    // 256-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrics defined in immintrin.h
    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \
                             size_t face_length){
        // C = A & B
        // will set C to be the intersection of A and B
        // `face_length` is the length of A, B and C in terms of uint64_t
        // note that A,B,C need to be 32-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 4){
            __m256i a = _mm256_load_si256((const __m256i*)&A[i]);
            __m256i b = _mm256_load_si256((const __m256i*)&B[i]);
            __m256i c = _mm256_and_si256(a, b);
            _mm256_store_si256((__m256i*)&C[i],c);
        }
    }

#elif __SSE4_1__
    // actually SSE2 would be fine, but we don't want to force greater chunks,
    // because of intersection, which is not the bottleneck
    // 128-bit commands, those operations are equivalent to the operations
    // defined in `#else`
    // intrinsics defined in emmintrin.h
    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \
                             size_t face_length){
        // C = A & B
        // will set C to be the intersection of A and B
        // `face_length` is the length of A, B and C in terms of uint64_t
        // note that A,B,C need to be 16-byte-aligned
        size_t i;
        for (i = 0; i < face_length; i += 2){
            __m128i a = _mm_load_si128((const __m128i*)&A[i]);
            __m128i b = _mm_load_si128((const __m128i*)&B[i]);
            __m128i c = _mm_and_si128(a, b);
            _mm_store_si128((__m128i*)&C[i],c);
        }
    }

#else
    // commands, without intrinsics
    inline void intersection(uint64_t *A, uint64_t *B, uint64_t *C, \
                             size_t face_length){
        // C = A & B
        // will set C to be the intersection of A and B
        // `face_length` is the length of A, B and C in terms of uint64_t
        size_t i;
        for (i = 0; i < face_length; i++){
            C[i] = A[i] & B[i];
        }
    }

#endif

// inline size_t CountFaceBits(uint64_t* A, size_t face_length)
// determine the best way to count the set bits in uint64_t *
#if (__POPCNT__) && (INTPTR_MAX == INT64_MAX) // 64-bit and popcnt
    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {
        // counts the number of vertices in a face by counting bits set to one
        // `face_length` is the length of A in terms of uint64_t
        size_t i;
        unsigned int count = 0;
        for (i=0; i<face_length; i++){
            count += (size_t) _mm_popcnt_u64(A[i]);
        }
        return count;
    }

#else // popcount without intrinsics
    inline size_t CountFaceBits(uint64_t* A, size_t face_length) {
        // counts the number of vertices in a face by counting bits set to one
        // `face_length` is the length of A in terms of uint64_t
        size_t i;
        unsigned int count = 0;
        for (i=0; i<face_length; i++){
            uint64_t a = A[i];
            while (a){
                count += a & 1;
                a >>= 1;
            }
        }
        return count;
    }

#endif
```



---

archive/issue_comments_521227.json:
```json
{
    "body": "Changing commit from \"\" to \"52cb026a0fbddc1984701f7054bd71e97e157ea1\"",
    "created_at": "2019-03-11T14:29:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521227",
    "user": "https://github.com/kliem"
}
```

Changing commit from "" to "52cb026a0fbddc1984701f7054bd71e97e157ea1"



---

archive/issue_comments_521228.json:
```json
{
    "body": "<a id='comment:4'></a>Last 10 new commits:",
    "created_at": "2019-03-11T14:29:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521228",
    "user": "https://github.com/kliem"
}
```

<a id='comment:4'></a>Last 10 new commits:



---

archive/issue_comments_521229.json:
```json
{
    "body": "Changing branch from \"\" to \"public/27103\"",
    "created_at": "2019-03-11T14:29:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521229",
    "user": "https://github.com/kliem"
}
```

Changing branch from "" to "public/27103"



---

archive/issue_events_067334.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-03-25T10:56:15Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "milestone": "sage-8.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27103#event-67334"
}
```



---

archive/issue_comments_521230.json:
```json
{
    "body": "<a id='comment:5'></a>Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)",
    "created_at": "2019-03-25T10:56:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521230",
    "user": "https://github.com/embray"
}
```

<a id='comment:5'></a>Ticket retargeted after milestone closed (if you don't believe this ticket is appropriate for the Sage 8.8 release please retarget manually)



---

archive/issue_comments_521231.json:
```json
{
    "body": "<a id='comment:6'></a>As the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).",
    "created_at": "2019-06-14T14:54:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521231",
    "user": "https://github.com/embray"
}
```

<a id='comment:6'></a>As the Sage-8.8 release milestone is pending, we should delete the sage-8.8 milestone for tickets that are not actively being worked on or that still require significant work to move forward.  If you feel that this ticket should be included in the next Sage release at the soonest please set its milestone to the next release milestone (sage-8.9).



---

archive/issue_events_067335.json:
```json
{
    "actor": "https://github.com/embray",
    "created_at": "2019-06-14T14:54:19Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "milestone": "sage-8.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27103#event-67335"
}
```



---

archive/issue_events_067336.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2019-08-29T19:02:46Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "milestone": "sage-pending",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27103#event-67336"
}
```



---

archive/issue_comments_521232.json:
```json
{
    "body": "Changing commit from \"52cb026a0fbddc1984701f7054bd71e97e157ea1\" to \"10a61963ba0bb2547e44934bfa197933d1395d96\"",
    "created_at": "2019-10-23T07:47:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521232",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "52cb026a0fbddc1984701f7054bd71e97e157ea1" to "10a61963ba0bb2547e44934bfa197933d1395d96"



---

archive/issue_comments_521233.json:
```json
{
    "body": "<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2019-10-23T07:47:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521233",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:9'></a>Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_521234.json:
```json
{
    "body": "<a id='comment:10'></a>for popcount, you can use something like this when builtin popcount is not available:\n\n```\ncdef inline int popcount64(uint64_t i):\n   \"\"\"\n   Return the number of '1' bits in a 64-bits integer.\n   \"\"\"\n   i = i - ((i >> 1) & 0x5555555555555555ULL)\n   i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)\n   return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56\n```\n\nEDIT: removed inappropriate comment (bad copy/paste)",
    "created_at": "2019-10-23T10:57:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521234",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:10'></a>for popcount, you can use something like this when builtin popcount is not available:

```
cdef inline int popcount64(uint64_t i):
   """
   Return the number of '1' bits in a 64-bits integer.
   """
   i = i - ((i >> 1) & 0x5555555555555555ULL)
   i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)
   return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56
```

EDIT: removed inappropriate comment (bad copy/paste)



---

archive/issue_comments_521235.json:
```json
{
    "body": "Changing commit from \"10a61963ba0bb2547e44934bfa197933d1395d96\" to \"d069567e351f0dcecd5f790171cf30a5a8089fb3\"",
    "created_at": "2019-10-23T11:44:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521235",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "10a61963ba0bb2547e44934bfa197933d1395d96" to "d069567e351f0dcecd5f790171cf30a5a8089fb3"



---

archive/issue_comments_521236.json:
```json
{
    "body": "<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-10-23T11:44:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521236",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:11'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_521237.json:
```json
{
    "body": "<a id='comment:12'></a>Thanks. Was a nice exercise to go through it.\n\nReplying to [comment:10 dcoudert]:\n> for popcount, you can use something like this when builtin popcount is not available:\n> \n> ```\n> cdef inline int popcount64(uint64_t i):\n>    \"\"\"\n>    Return the number of '1' bits in a 64-bits integer.\n>    \"\"\"\n>    i = i - ((i >> 1) & 0x5555555555555555ULL)\n>    i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)\n>    return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56\n> ```\n> \n> EDIT: removed inappropriate comment (bad copy/paste)",
    "created_at": "2019-10-23T11:45:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521237",
    "user": "https://github.com/kliem"
}
```

<a id='comment:12'></a>Thanks. Was a nice exercise to go through it.

Replying to [comment:10 dcoudert]:
> for popcount, you can use something like this when builtin popcount is not available:
> 
> ```
> cdef inline int popcount64(uint64_t i):
>    """
>    Return the number of '1' bits in a 64-bits integer.
>    """
>    i = i - ((i >> 1) & 0x5555555555555555ULL)
>    i = (i & 0x3333333333333333ULL) + ((i >> 2) & 0x3333333333333333ULL)
>    return ( ((i + (i >> 4)) & 0x0f0f0f0f0f0f0f0fULL) * 0x0101010101010101ULL ) >> 56
> ```
> 
> EDIT: removed inappropriate comment (bad copy/paste)



---

archive/issue_comments_521238.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-10-23T17:50:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521238",
    "user": "https://github.com/kliem"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_521239.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,8 @@\n+#26887 prepares SIMD-instructions to speed up calculations.\n \n+The subject of this ticket is to carefully enable them.\n+\n+We implement a faster version of subset check, intersection and popcount (atom count) according to the available intrisics.\n \n Dependencies: #26887\n \n``````\n",
    "created_at": "2019-10-23T17:50:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521239",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,8 @@
+#26887 prepares SIMD-instructions to speed up calculations.
 
+The subject of this ticket is to carefully enable them.
+
+We implement a faster version of subset check, intersection and popcount (atom count) according to the available intrisics.
 
 Dependencies: #26887
 
``````




---

archive/issue_comments_521240.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,10 @@\n+#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).\n \n+The subject of this ticket is to carefully enable them.\n+\n+We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.\n+\n+We also improve the default popcount (atom count).\n \n Dependencies: #26887\n \n``````\n",
    "created_at": "2019-10-24T05:25:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521240",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,10 @@
+#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).
 
+The subject of this ticket is to carefully enable them.
+
+We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.
+
+We also improve the default popcount (atom count).
 
 Dependencies: #26887
 
``````




---

archive/issue_comments_521241.json:
```json
{
    "body": "Changing author from \"\" to \"David Coudert, Jonathan Kliem\"",
    "created_at": "2019-10-24T05:25:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521241",
    "user": "https://github.com/kliem"
}
```

Changing author from "" to "David Coudert, Jonathan Kliem"



---

archive/issue_comments_521242.json:
```json
{
    "body": "<a id='comment:15'></a>You could add an how to help reviewing this ticket. I can test it on OSX, but I assume it's far from enough.\n\nPS: no need to add me as an author. I just gave a small trick from hakmem 169. See e.g. [http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html](http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html)",
    "created_at": "2019-10-24T12:42:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521242",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:15'></a>You could add an how to help reviewing this ticket. I can test it on OSX, but I assume it's far from enough.

PS: no need to add me as an author. I just gave a small trick from hakmem 169. See e.g. [http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html](http://www.dalkescientific.com/writings/diary/archive/2008/07/03/hakmem_and_other_popcounts.html)



---

archive/issue_comments_521243.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,110 @@\n+#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).\n \n+The subject of this ticket is to carefully enable them.\n+\n+We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.\n+\n+We also improve the default popcount (atom count).\n+\n+Timing before this ticket:\n+\n+```\n+sage: P = polytopes.permutahedron(7)\n+sage: import time\n+sage: x = 1000\n+sage: for _ in range(5): \n+....:     C = CombinatorialPolyhedron(P)\n+....:     a = time.time()\n+....:     _ = C.f_vector()\n+....:     b = time.time()\n+....:     x = min(b-a,x)\n+....:     \n+sage: x\n+0.04108405113220215\n+```\n+\n+Timing with this ticket and `SSE4.1`:\n+\n+```\n+...\n+sage: x\n+0.026965856552124023\n+```\n+\n+Timing with this ticket and `AVX`:\n+\n+```\n+...\n+sage: x\n+0.016251087188720703\n+```\n+\n+Timing with this ticket and `AVX2`:\n+\n+```\n+...\n+sage: x\n+0.015423059463500977\n+```\n+\n+** Please help testing this ticket:**\n+\n+It makes sense to test this ticket on top of #27122 or independently.\n+\n+- Test it after having tested #27122:\n+  - I assume you are still on the branch `test_march_native`.\n+  - Run the above test in sage to see what your current timing is.\n+  - pull this ticket: `git pull trac public/27103`\n+  - make sage and run the test again, note the timing\n+  - run related doctests, to see whether everything still works:\n+\n+```\n+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx\n+```\n+- Test it without testing #27122:\n+  - See what your timing for the above example currently is.\n+  - checkout a new branch and pull `public/27103`.\n+  - set the environment variable `CFLAGS` to `-march=native` (if you don't use gcc or clang for compiling sage, you might have to set an equivalent or the specific flags to enable you specific intrinsics):\n+\n+```\n+export $CFLAGS='-march=native'\n+```\n+- remove the cythonized files for combinatorial polyhedron:\n+\n+```\n+rm src/build/cythonized/sage/geometry/polyhedron/combinatorial_polyhedron/*\n+```\n+- Make sage.\n+- Run sage and see what the new timing on the above example is.\n+- run related doctests, to see whether everything still works:\n+\n+```\n+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx\n+```\n+\n+The ticket works if:\n+- sage builds\n+- the related doctests work\n+- you get improved timings according to your available intrinsics\n+\n+Please report success or any failure (with log of the failure) as a comment to this ticket along with\n+- operating system,\n+- kernel,\n+- architecture,\n+- cpu model,\n+- which of the following flags are set `sse4_1 avx avx2 popcnt`.\n+One way to obtain those information is to run the following commands:\n+- Linux:\n+  - `hostnamectl` (for the first three items)\n+  - `lscpu | grep -i \"Model name\"` \n+  - `lscpu | grep -o sse4_1; lscpu | grep -o \"avx \"; lscpu | grep -o avx2; lscpu | grep -o popcnt`\n+- OS X:\n+  - `sysctl -n machdep.cpu.brand_string`\n+  - `sw_vers`\n+  - `uname -a`\n+  - `sysctl -a | grep -o SSE4.1; sysctl -a | grep -o \"AVX \"; sysctl -a | grep -o AVX2; sysctl -a | grep -o POPCNT`\n+\n+Thank you.\n \n Dependencies: #26887\n \n``````\n",
    "created_at": "2019-10-25T09:14:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521243",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,110 @@
+#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).
 
+The subject of this ticket is to carefully enable them.
+
+We implement fasters versions of subset check, intersection and popcount (atom count) according to the available intrisics.
+
+We also improve the default popcount (atom count).
+
+Timing before this ticket:
+
+```
+sage: P = polytopes.permutahedron(7)
+sage: import time
+sage: x = 1000
+sage: for _ in range(5): 
+....:     C = CombinatorialPolyhedron(P)
+....:     a = time.time()
+....:     _ = C.f_vector()
+....:     b = time.time()
+....:     x = min(b-a,x)
+....:     
+sage: x
+0.04108405113220215
+```
+
+Timing with this ticket and `SSE4.1`:
+
+```
+...
+sage: x
+0.026965856552124023
+```
+
+Timing with this ticket and `AVX`:
+
+```
+...
+sage: x
+0.016251087188720703
+```
+
+Timing with this ticket and `AVX2`:
+
+```
+...
+sage: x
+0.015423059463500977
+```
+
+** Please help testing this ticket:**
+
+It makes sense to test this ticket on top of #27122 or independently.
+
+- Test it after having tested #27122:
+  - I assume you are still on the branch `test_march_native`.
+  - Run the above test in sage to see what your current timing is.
+  - pull this ticket: `git pull trac public/27103`
+  - make sage and run the test again, note the timing
+  - run related doctests, to see whether everything still works:
+
+```
+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx
+```
+- Test it without testing #27122:
+  - See what your timing for the above example currently is.
+  - checkout a new branch and pull `public/27103`.
+  - set the environment variable `CFLAGS` to `-march=native` (if you don't use gcc or clang for compiling sage, you might have to set an equivalent or the specific flags to enable you specific intrinsics):
+
+```
+export $CFLAGS='-march=native'
+```
+- remove the cythonized files for combinatorial polyhedron:
+
+```
+rm src/build/cythonized/sage/geometry/polyhedron/combinatorial_polyhedron/*
+```
+- Make sage.
+- Run sage and see what the new timing on the above example is.
+- run related doctests, to see whether everything still works:
+
+```
+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx
+```
+
+The ticket works if:
+- sage builds
+- the related doctests work
+- you get improved timings according to your available intrinsics
+
+Please report success or any failure (with log of the failure) as a comment to this ticket along with
+- operating system,
+- kernel,
+- architecture,
+- cpu model,
+- which of the following flags are set `sse4_1 avx avx2 popcnt`.
+One way to obtain those information is to run the following commands:
+- Linux:
+  - `hostnamectl` (for the first three items)
+  - `lscpu | grep -i "Model name"` 
+  - `lscpu | grep -o sse4_1; lscpu | grep -o "avx "; lscpu | grep -o avx2; lscpu | grep -o popcnt`
+- OS X:
+  - `sysctl -n machdep.cpu.brand_string`
+  - `sw_vers`
+  - `uname -a`
+  - `sysctl -a | grep -o SSE4.1; sysctl -a | grep -o "AVX "; sysctl -a | grep -o AVX2; sysctl -a | grep -o POPCNT`
+
+Thank you.
 
 Dependencies: #26887
 
``````




---

archive/issue_comments_521244.json:
```json
{
    "body": "<a id='comment:16'></a>It works for me.\n\n- Operating System: Debian GNU/Linux 10 (buster)\n- Kernel: Linux 4.19.0-6-amd64\n- Architecture: x86-64\n- CPU Model name: Intel(R) Core(TM) i7-7700 CPU `@` 3.60GHz\n- sse4.1, avx, avx2, popcnt",
    "created_at": "2019-10-25T09:14:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521244",
    "user": "https://github.com/kliem"
}
```

<a id='comment:16'></a>It works for me.

- Operating System: Debian GNU/Linux 10 (buster)
- Kernel: Linux 4.19.0-6-amd64
- Architecture: x86-64
- CPU Model name: Intel(R) Core(TM) i7-7700 CPU `@` 3.60GHz
- sse4.1, avx, avx2, popcnt



---

archive/issue_comments_521245.json:
```json
{
    "body": "Changing author from \"David Coudert, Jonathan Kliem\" to \"Jonathan Kliem\"",
    "created_at": "2019-10-25T09:16:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521245",
    "user": "https://github.com/kliem"
}
```

Changing author from "David Coudert, Jonathan Kliem" to "Jonathan Kliem"



---

archive/issue_comments_521246.json:
```json
{
    "body": "<a id='comment:18'></a>System:\n- Operating System: OS X 10.14.6\n- Kernel: Darwin Kernel Version 18.7.0\n- Architecture: x86-64\n- CPU Model name: Intel(R) Core(TM) i7-4650U CPU `@` 1.70GHz\n- sse4.1, avx2, popcnt\n\n\nTiming using py3:\n- 0.08155608177185059\nWith this ticket (`git trac checkout 27103`) and CFLAGS set:\n- 0.024885177612304688\n\n\nand all tests pass.",
    "created_at": "2019-10-25T16:30:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521246",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:18'></a>System:
- Operating System: OS X 10.14.6
- Kernel: Darwin Kernel Version 18.7.0
- Architecture: x86-64
- CPU Model name: Intel(R) Core(TM) i7-4650U CPU `@` 1.70GHz
- sse4.1, avx2, popcnt


Timing using py3:
- 0.08155608177185059
With this ticket (`git trac checkout 27103`) and CFLAGS set:
- 0.024885177612304688


and all tests pass.



---

archive/issue_comments_521247.json:
```json
{
    "body": "<a id='comment:19'></a>If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.",
    "created_at": "2019-10-26T03:27:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521247",
    "user": "https://github.com/videlec"
}
```

<a id='comment:19'></a>If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.



---

archive/issue_comments_521248.json:
```json
{
    "body": "<a id='comment:20'></a>Works on\n\n- Operating System: Ubuntu 18.04.3 LTS\n- Kernel: Linux 4.15.0-65-generic\n- Architecture: x86-64\n- Model name:          Intel(R) Core(TM) i5-7200U CPU `@` 2.50GHz\n- sse4_1 avx avx2 popcnt\n\nBefore:\n- 0.05162477493286133\nAfter\n- 0.02220010757446289",
    "created_at": "2019-10-26T11:11:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521248",
    "user": "https://github.com/kliem"
}
```

<a id='comment:20'></a>Works on

- Operating System: Ubuntu 18.04.3 LTS
- Kernel: Linux 4.15.0-65-generic
- Architecture: x86-64
- Model name:          Intel(R) Core(TM) i5-7200U CPU `@` 2.50GHz
- sse4_1 avx avx2 popcnt

Before:
- 0.05162477493286133
After
- 0.02220010757446289



---

archive/issue_comments_521249.json:
```json
{
    "body": "<a id='comment:21'></a>Replying to [comment:19 vdelecroix]:\n> If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.\n\n\nYes...\n\nThat is going to be some project, but it definitely makes sense.\n\nOne problem with bitset (to my understanding) so far is, that it is not overaligned. If it is overaligned, loads and stores are supposedly much faster (when using intrinsics).\n\nProbably the best way to find out, is to see how the performance of my code actually changes, when I use bitsets instead of my own implementation.\n\nBtw, if you have a specific example in mind, where calculations with bitsets are the bottle neck, I would be interested.",
    "created_at": "2019-10-26T11:52:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521249",
    "user": "https://github.com/kliem"
}
```

<a id='comment:21'></a>Replying to [comment:19 vdelecroix]:
> If you want reasonably fast implementation of bitsets, you should consider using `sage/data_structures/bitset.pxi`. That uses GMP which has a lot of asembly optimization. If it is not good enough, then you should rather make `bitset.pxi` faster than rewriting code for a very specialized application.


Yes...

That is going to be some project, but it definitely makes sense.

One problem with bitset (to my understanding) so far is, that it is not overaligned. If it is overaligned, loads and stores are supposedly much faster (when using intrinsics).

Probably the best way to find out, is to see how the performance of my code actually changes, when I use bitsets instead of my own implementation.

Btw, if you have a specific example in mind, where calculations with bitsets are the bottle neck, I would be interested.



---

archive/issue_comments_521250.json:
```json
{
    "body": "<a id='comment:22'></a>For examples, have a look in the graph code `sage/graphs/` (e.g. iteration over vertex covers, etc). Apparently there are stuff in `sage/combinat/` as well. More generally\n\n```\n$ git grep -l bitset\n```",
    "created_at": "2019-10-26T14:54:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521250",
    "user": "https://github.com/videlec"
}
```

<a id='comment:22'></a>For examples, have a look in the graph code `sage/graphs/` (e.g. iteration over vertex covers, etc). Apparently there are stuff in `sage/combinat/` as well. More generally

```
$ git grep -l bitset
```



---

archive/issue_comments_521251.json:
```json
{
    "body": "<a id='comment:23'></a>Works on top of #27122, itrself on top of Python 3-based 9.0.beta2 on :\n\n- Operating System: Debian GNU/Linux bullseye/sid\n- Kernel: Linux 5.2.0-3-amd64\n- Architecture: x86-64\n- Nom de mod\u00e8le : Intel(R) Core(TM) i7-8550U CPU `@` 1.80GHz\n\nBefore: `0.046399831771850586`\n\nAfter: `0.016237735748291016`\n\nAll polyhedra-related tests pass.\n\nHTH,",
    "created_at": "2019-10-26T15:56:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521251",
    "user": "https://github.com/EmmanuelCharpentier"
}
```

<a id='comment:23'></a>Works on top of #27122, itrself on top of Python 3-based 9.0.beta2 on :

- Operating System: Debian GNU/Linux bullseye/sid
- Kernel: Linux 5.2.0-3-amd64
- Architecture: x86-64
- Nom de modèle : Intel(R) Core(TM) i7-8550U CPU `@` 1.80GHz

Before: `0.046399831771850586`

After: `0.016237735748291016`

All polyhedra-related tests pass.

HTH,



---

archive/issue_comments_521252.json:
```json
{
    "body": "<a id='comment:24'></a>I'm almost certain that this is applicable to `sage/data_structures/bitset.pxi`. I ran the following test:\n\n```\nsage: def fill_bitset():\n....:     for _ in range(1000000):\n....:         yield randint(0,10000000000)\n....:     yield 10000000000\n....:     \nsage: a = FrozenBitset(fill_bitset())\nsage: cython('''\n....: from sage.data_structures.bitset cimport bitset_t, FrozenBitset\n....: def intersect(FrozenBitset a, FrozenBitset b):\n....:     a.intersection(b)\n....: ''')\nsage: %timeit intersect(a,a)\n```\n\nWith the current implementation via GMP this takes about 781 ms (best of 3).\n\n```\nmpn_and_n(r.bits, a.bits, b.bits, b.limbs)\n```\nI replaced this by:\n\n```\ncdef mp_size_t i\ncdef mp_limb_t *rb = r.bits, *ab = a.bits, *bb = b.bits\nfor i from 0 <= i < a.limbs:\n    rb[i] = ab[i] & bb[i]\n```\nand it seems to be about the same.\n\nOf course this is a very brief naive test, but there seems to be no reason to use GMP for this specific function. Notice, that this doesn't even use intrinsics.",
    "created_at": "2019-10-26T20:31:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521252",
    "user": "https://github.com/kliem"
}
```

<a id='comment:24'></a>I'm almost certain that this is applicable to `sage/data_structures/bitset.pxi`. I ran the following test:

```
sage: def fill_bitset():
....:     for _ in range(1000000):
....:         yield randint(0,10000000000)
....:     yield 10000000000
....:     
sage: a = FrozenBitset(fill_bitset())
sage: cython('''
....: from sage.data_structures.bitset cimport bitset_t, FrozenBitset
....: def intersect(FrozenBitset a, FrozenBitset b):
....:     a.intersection(b)
....: ''')
sage: %timeit intersect(a,a)
```

With the current implementation via GMP this takes about 781 ms (best of 3).

```
mpn_and_n(r.bits, a.bits, b.bits, b.limbs)
```
I replaced this by:

```
cdef mp_size_t i
cdef mp_limb_t *rb = r.bits, *ab = a.bits, *bb = b.bits
for i from 0 <= i < a.limbs:
    rb[i] = ab[i] & bb[i]
```
and it seems to be about the same.

Of course this is a very brief naive test, but there seems to be no reason to use GMP for this specific function. Notice, that this doesn't even use intrinsics.



---

archive/issue_comments_521253.json:
```json
{
    "body": "<a id='comment:25'></a>If you can make `data_structures/bitset.pxi` better this is wonderful. What I want to avoid is two different piece of code that achieve the same thing. Please put your code in `data_structures/` rather than in `polyhedron` and make it as generic as possible. That way it will benefit to others.\n\nAlso, note that not all functions in `bitset.pxi` use GMP/MPIR. Where it does it should be fast. That is comparison (`mpn_cmp`), intersection (`mpn_and_n`), union (`mpn_ior_n`), etc. You might want to have a look at how these are implemented [GMP](https://gmplib.org/)/[MPIR](http://mpir.org/).",
    "created_at": "2019-10-26T21:19:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521253",
    "user": "https://github.com/videlec"
}
```

<a id='comment:25'></a>If you can make `data_structures/bitset.pxi` better this is wonderful. What I want to avoid is two different piece of code that achieve the same thing. Please put your code in `data_structures/` rather than in `polyhedron` and make it as generic as possible. That way it will benefit to others.

Also, note that not all functions in `bitset.pxi` use GMP/MPIR. Where it does it should be fast. That is comparison (`mpn_cmp`), intersection (`mpn_and_n`), union (`mpn_ior_n`), etc. You might want to have a look at how these are implemented [GMP](https://gmplib.org/)/[MPIR](http://mpir.org/).



---

archive/issue_comments_521254.json:
```json
{
    "body": "<a id='comment:26'></a>Things are complicated and a lot more complicated than I thought.\n\n- To my knowledge, I cannot do something as `#if __AVX__` in cython, can I? This would mean, we would have to rewrite bitset in C or C++ to use intrinsics.\n- So far I'm only reimplementing very basic functions.\n- I cannot write simple tests, where intrinsics are much faster. For intersection I don't see an improvement, for subset checks I'm maybe 10% faster. Here is, why I think this might be the case:\n\n  Loading registers takes a lot of time. In many cases this might be the bottle neck. Sure intrinsics need only one processor step instead of four to do bitwise `AND` of two registers. However, when I'm mostly waiting on read/write this does not help. Without intrinsics the processor can still process registers as fast as they can be loaded and stored again (don't forget that the result blocks another register while it is being stored).\n\n  Now in my scenario with subset checks things are a bit different. Nothings needs to be stored after the computation (this would explain why subset check with intrinsics is 10% faster than without). But more importantly seems to be the exact scenario I'm in:\n\n  I'm checking whether `A` is a subset of any of `B_1,...,B_n`. In most cases only the first 256 vertices are needed to discover that `A` is not a subset of `B_i`. So the first register of `A` can be reused a lot of times.\n\n  So, intrinsics might be useful in other scenarios for bitsets in sage, but it's definitly not a no-brainer. One won't lose. That I'm pretty sure of.",
    "created_at": "2019-10-28T10:17:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521254",
    "user": "https://github.com/kliem"
}
```

<a id='comment:26'></a>Things are complicated and a lot more complicated than I thought.

- To my knowledge, I cannot do something as `#if __AVX__` in cython, can I? This would mean, we would have to rewrite bitset in C or C++ to use intrinsics.
- So far I'm only reimplementing very basic functions.
- I cannot write simple tests, where intrinsics are much faster. For intersection I don't see an improvement, for subset checks I'm maybe 10% faster. Here is, why I think this might be the case:

  Loading registers takes a lot of time. In many cases this might be the bottle neck. Sure intrinsics need only one processor step instead of four to do bitwise `AND` of two registers. However, when I'm mostly waiting on read/write this does not help. Without intrinsics the processor can still process registers as fast as they can be loaded and stored again (don't forget that the result blocks another register while it is being stored).

  Now in my scenario with subset checks things are a bit different. Nothings needs to be stored after the computation (this would explain why subset check with intrinsics is 10% faster than without). But more importantly seems to be the exact scenario I'm in:

  I'm checking whether `A` is a subset of any of `B_1,...,B_n`. In most cases only the first 256 vertices are needed to discover that `A` is not a subset of `B_i`. So the first register of `A` can be reused a lot of times.

  So, intrinsics might be useful in other scenarios for bitsets in sage, but it's definitly not a no-brainer. One won't lose. That I'm pretty sure of.



---

archive/issue_comments_521255.json:
```json
{
    "body": "<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-11-04T15:09:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521255",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:27'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_521256.json:
```json
{
    "body": "Changing commit from \"d069567e351f0dcecd5f790171cf30a5a8089fb3\" to \"5dc41db60cc3754b7022f153ba52f6140f85bf32\"",
    "created_at": "2019-11-04T15:09:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521256",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "d069567e351f0dcecd5f790171cf30a5a8089fb3" to "5dc41db60cc3754b7022f153ba52f6140f85bf32"



---

archive/issue_comments_521257.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,110 @@\n+#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).\n \n+The subject of this ticket is to carefully enable them.\n+\n+We implement faster versions of subset check, intersection and popcount (atom count) according to the available intrinsics.\n+\n+We also improve the default popcount (atom count).\n+\n+Timing before this ticket:\n+\n+```\n+sage: P = polytopes.permutahedron(7)\n+sage: import time\n+sage: x = 1000\n+sage: for _ in range(5): \n+....:     C = CombinatorialPolyhedron(P)\n+....:     a = time.time()\n+....:     _ = C.f_vector()\n+....:     b = time.time()\n+....:     x = min(b-a,x)\n+....:     \n+sage: x\n+0.04108405113220215\n+```\n+\n+Timing with this ticket and `SSE4.1`:\n+\n+```\n+...\n+sage: x\n+0.026965856552124023\n+```\n+\n+Timing with this ticket and `AVX`:\n+\n+```\n+...\n+sage: x\n+0.016251087188720703\n+```\n+\n+Timing with this ticket and `AVX2`:\n+\n+```\n+...\n+sage: x\n+0.015423059463500977\n+```\n+\n+** Please help testing this ticket:**\n+\n+It makes sense to test this ticket on top of #27122 or independently.\n+\n+- Test it after having tested #27122:\n+  - I assume you are still on the branch `test_march_native`.\n+  - Run the above test in sage to see what your current timing is.\n+  - pull this ticket: `git pull trac public/27103`\n+  - make sage and run the test again, note the timing\n+  - run related doctests, to see whether everything still works:\n+\n+```\n+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx\n+```\n+- Test it without testing #27122:\n+  - See what your timing for the above example currently is.\n+  - checkout a new branch and pull `public/27103`.\n+  - set the environment variable `CFLAGS` to `-march=native` (if you don't use gcc or clang for compiling sage, you might have to set an equivalent or the specific flags to enable you specific intrinsics):\n+\n+```\n+export $CFLAGS='-march=native'\n+```\n+- remove the cythonized files for combinatorial polyhedron:\n+\n+```\n+rm src/build/cythonized/sage/geometry/polyhedron/combinatorial_polyhedron/*\n+```\n+- Make sage.\n+- Run sage and see what the new timing on the above example is.\n+- run related doctests, to see whether everything still works:\n+\n+```\n+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx\n+```\n+\n+The ticket works if:\n+- sage builds\n+- the related doctests work\n+- you get improved timings according to your available intrinsics\n+\n+Please report success or any failure (with log of the failure) as a comment to this ticket along with\n+- operating system,\n+- kernel,\n+- architecture,\n+- cpu model,\n+- which of the following flags are set `sse4_1 avx avx2 popcnt`.\n+One way to obtain this information is to run the following commands:\n+- Linux:\n+  - `hostnamectl` (for the first three items)\n+  - `lscpu | grep -i \"Model name\"` \n+  - `lscpu | grep -o sse4_1; lscpu | grep -o \"avx \"; lscpu | grep -o avx2; lscpu | grep -o popcnt`\n+- OS X:\n+  - `sysctl -n machdep.cpu.brand_string`\n+  - `sw_vers`\n+  - `uname -a`\n+  - `sysctl -a | grep -o SSE4.1; sysctl -a | grep -o \"AVX \"; sysctl -a | grep -o AVX2; sysctl -a | grep -o POPCNT`\n+\n+Thank you.\n \n Dependencies: #26887\n \n``````\n",
    "created_at": "2020-04-26T00:46:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521257",
    "user": "https://github.com/slel"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,110 @@
+#26887 prepares SIMD-instructions to speed up calculations (e.g. by having data overaligned, if requested).
 
+The subject of this ticket is to carefully enable them.
+
+We implement faster versions of subset check, intersection and popcount (atom count) according to the available intrinsics.
+
+We also improve the default popcount (atom count).
+
+Timing before this ticket:
+
+```
+sage: P = polytopes.permutahedron(7)
+sage: import time
+sage: x = 1000
+sage: for _ in range(5): 
+....:     C = CombinatorialPolyhedron(P)
+....:     a = time.time()
+....:     _ = C.f_vector()
+....:     b = time.time()
+....:     x = min(b-a,x)
+....:     
+sage: x
+0.04108405113220215
+```
+
+Timing with this ticket and `SSE4.1`:
+
+```
+...
+sage: x
+0.026965856552124023
+```
+
+Timing with this ticket and `AVX`:
+
+```
+...
+sage: x
+0.016251087188720703
+```
+
+Timing with this ticket and `AVX2`:
+
+```
+...
+sage: x
+0.015423059463500977
+```
+
+** Please help testing this ticket:**
+
+It makes sense to test this ticket on top of #27122 or independently.
+
+- Test it after having tested #27122:
+  - I assume you are still on the branch `test_march_native`.
+  - Run the above test in sage to see what your current timing is.
+  - pull this ticket: `git pull trac public/27103`
+  - make sage and run the test again, note the timing
+  - run related doctests, to see whether everything still works:
+
+```
+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx
+```
+- Test it without testing #27122:
+  - See what your timing for the above example currently is.
+  - checkout a new branch and pull `public/27103`.
+  - set the environment variable `CFLAGS` to `-march=native` (if you don't use gcc or clang for compiling sage, you might have to set an equivalent or the specific flags to enable you specific intrinsics):
+
+```
+export $CFLAGS='-march=native'
+```
+- remove the cythonized files for combinatorial polyhedron:
+
+```
+rm src/build/cythonized/sage/geometry/polyhedron/combinatorial_polyhedron/*
+```
+- Make sage.
+- Run sage and see what the new timing on the above example is.
+- run related doctests, to see whether everything still works:
+
+```
+sage -t --long src/sage/geometry/polyhedron/combinatorial_polyhedron/*.pyx
+```
+
+The ticket works if:
+- sage builds
+- the related doctests work
+- you get improved timings according to your available intrinsics
+
+Please report success or any failure (with log of the failure) as a comment to this ticket along with
+- operating system,
+- kernel,
+- architecture,
+- cpu model,
+- which of the following flags are set `sse4_1 avx avx2 popcnt`.
+One way to obtain this information is to run the following commands:
+- Linux:
+  - `hostnamectl` (for the first three items)
+  - `lscpu | grep -i "Model name"` 
+  - `lscpu | grep -o sse4_1; lscpu | grep -o "avx "; lscpu | grep -o avx2; lscpu | grep -o popcnt`
+- OS X:
+  - `sysctl -n machdep.cpu.brand_string`
+  - `sw_vers`
+  - `uname -a`
+  - `sysctl -a | grep -o SSE4.1; sysctl -a | grep -o "AVX "; sysctl -a | grep -o AVX2; sysctl -a | grep -o POPCNT`
+
+Thank you.
 
 Dependencies: #26887
 
``````




---

archive/issue_comments_521258.json:
```json
{
    "body": "<a id='comment:30'></a>I will probably move those improvements to `data_structures/bitset.pxi`, once #27122 is done.\n\nIn the mean time, one can of course still pull the attached branch, if one wants to improve the f-vector computation.",
    "created_at": "2020-04-27T07:14:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521258",
    "user": "https://github.com/kliem"
}
```

<a id='comment:30'></a>I will probably move those improvements to `data_structures/bitset.pxi`, once #27122 is done.

In the mean time, one can of course still pull the attached branch, if one wants to improve the f-vector computation.



---

archive/issue_comments_521259.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2020-04-27T07:14:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521259",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_521260.json:
```json
{
    "body": "Changing dependencies from \"#26887, #27122\" to \"#27122\"",
    "created_at": "2020-04-27T07:14:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521260",
    "user": "https://github.com/kliem"
}
```

Changing dependencies from "#26887, #27122" to "#27122"



---

archive/issue_comments_521261.json:
```json
{
    "body": "<a id='comment:31'></a>New commits:",
    "created_at": "2020-08-25T08:27:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521261",
    "user": "https://github.com/kliem"
}
```

<a id='comment:31'></a>New commits:



---

archive/issue_comments_521262.json:
```json
{
    "body": "Changing dependencies from \"#27122\" to \"#27122, #30429, #30435\"",
    "created_at": "2020-08-25T08:27:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521262",
    "user": "https://github.com/kliem"
}
```

Changing dependencies from "#27122" to "#27122, #30429, #30435"



---

archive/issue_comments_521263.json:
```json
{
    "body": "Changing branch from \"public/27103\" to \"public/27103-reb\"",
    "created_at": "2020-08-25T08:27:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521263",
    "user": "https://github.com/kliem"
}
```

Changing branch from "public/27103" to "public/27103-reb"



---

archive/issue_comments_521264.json:
```json
{
    "body": "Changing commit from \"5dc41db60cc3754b7022f153ba52f6140f85bf32\" to \"be5c59038e7914610f4a734971deca6cc47c9646\"",
    "created_at": "2020-08-25T08:27:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521264",
    "user": "https://github.com/kliem"
}
```

Changing commit from "5dc41db60cc3754b7022f153ba52f6140f85bf32" to "be5c59038e7914610f4a734971deca6cc47c9646"



---

archive/issue_comments_521265.json:
```json
{
    "body": "Changing dependencies from \"#27122, #30429, #30435\" to \"#27122, #30040, #30429, #30435\"",
    "created_at": "2020-08-25T12:42:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521265",
    "user": "https://github.com/kliem"
}
```

Changing dependencies from "#27122, #30429, #30435" to "#27122, #30040, #30429, #30435"



---

archive/issue_comments_521266.json:
```json
{
    "body": "Changing commit from \"be5c59038e7914610f4a734971deca6cc47c9646\" to \"cd0198e09e3baeb8ae6e135a1e7e9c504958312a\"",
    "created_at": "2020-08-25T12:42:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521266",
    "user": "https://github.com/kliem"
}
```

Changing commit from "be5c59038e7914610f4a734971deca6cc47c9646" to "cd0198e09e3baeb8ae6e135a1e7e9c504958312a"



---

archive/issue_comments_521267.json:
```json
{
    "body": "Changing branch from \"public/27103-reb\" to \"public/27103-reb2\"",
    "created_at": "2020-08-25T12:42:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521267",
    "user": "https://github.com/kliem"
}
```

Changing branch from "public/27103-reb" to "public/27103-reb2"



---

archive/issue_comments_521268.json:
```json
{
    "body": "<a id='comment:32'></a>Last 10 new commits:",
    "created_at": "2020-08-25T12:42:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521268",
    "user": "https://github.com/kliem"
}
```

<a id='comment:32'></a>Last 10 new commits:



---

archive/issue_comments_521269.json:
```json
{
    "body": "<a id='comment:33'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-08-28T14:35:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521269",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:33'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_521270.json:
```json
{
    "body": "Changing commit from \"cd0198e09e3baeb8ae6e135a1e7e9c504958312a\" to \"d3d1385996810fa322133e0f8490b46feee02196\"",
    "created_at": "2020-08-28T14:35:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521270",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "cd0198e09e3baeb8ae6e135a1e7e9c504958312a" to "d3d1385996810fa322133e0f8490b46feee02196"



---

archive/issue_comments_521271.json:
```json
{
    "body": "Changing commit from \"d3d1385996810fa322133e0f8490b46feee02196\" to \"67c88cfb1f22e4f886834e3b6c53487e62ae7f6d\"",
    "created_at": "2020-08-30T06:25:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521271",
    "user": "https://github.com/kliem"
}
```

Changing commit from "d3d1385996810fa322133e0f8490b46feee02196" to "67c88cfb1f22e4f886834e3b6c53487e62ae7f6d"



---

archive/issue_comments_521272.json:
```json
{
    "body": "Changing branch from \"public/27103-reb2\" to \"public/27103-reb3\"",
    "created_at": "2020-08-30T06:25:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521272",
    "user": "https://github.com/kliem"
}
```

Changing branch from "public/27103-reb2" to "public/27103-reb3"



---

archive/issue_comments_521273.json:
```json
{
    "body": "<a id='comment:34'></a>Changes in #30040.\n\n---\nLast 10 new commits:",
    "created_at": "2020-08-30T06:25:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521273",
    "user": "https://github.com/kliem"
}
```

<a id='comment:34'></a>Changes in #30040.

---
Last 10 new commits:



---

archive/issue_comments_521274.json:
```json
{
    "body": "<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-09-02T06:39:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521274",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:35'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_521275.json:
```json
{
    "body": "Changing commit from \"67c88cfb1f22e4f886834e3b6c53487e62ae7f6d\" to \"cfcdeb677073fc32f8dd57263056b640a7f6a518\"",
    "created_at": "2020-09-02T06:39:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521275",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "67c88cfb1f22e4f886834e3b6c53487e62ae7f6d" to "cfcdeb677073fc32f8dd57263056b640a7f6a518"



---

archive/issue_comments_521276.json:
```json
{
    "body": "Changing dependencies from \"#27122, #30040, #30429, #30435\" to \"#31208\"",
    "created_at": "2021-01-08T10:37:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521276",
    "user": "https://github.com/kliem"
}
```

Changing dependencies from "#27122, #30040, #30429, #30435" to "#31208"



---

archive/issue_comments_521277.json:
```json
{
    "body": "Changing keywords from \"CombinatorialPolyhedron, SIMD, intrinsics\" to \"bitsets, CombinatorialPolyhedron, SIMD, intrinsics\".",
    "created_at": "2021-01-15T18:06:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521277",
    "user": "https://github.com/kliem"
}
```

Changing keywords from "CombinatorialPolyhedron, SIMD, intrinsics" to "bitsets, CombinatorialPolyhedron, SIMD, intrinsics".



---

archive/issue_comments_521278.json:
```json
{
    "body": "<a id='comment:37'></a>I will update the description yet, but this is basically ready for review.\n\nI got three failing doctests, but I don't think they are related:\n\n```\nsage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/sources.py  # 1 doctest failed                                                                              \nsage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/forker.py  # 1 doctest failed                                                                               \nsage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/interfaces/singular.py  # Killed due to segmentation fault  \n```\n\nOtherwise on my machine everything passes (with AVX2).\n\n(in the above two each time `FDS.in_lib` fails, so that doesn't seem to be related, also the singular timout doesn't seem to be related).\n\n---\nNew commits:",
    "created_at": "2021-01-15T18:06:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521278",
    "user": "https://github.com/kliem"
}
```

<a id='comment:37'></a>I will update the description yet, but this is basically ready for review.

I got three failing doctests, but I don't think they are related:

```
sage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/sources.py  # 1 doctest failed                                                                              
sage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/doctest/forker.py  # 1 doctest failed                                                                               
sage -t --long --random-seed=0 /srv/public/kliem/sage/src/sage/interfaces/singular.py  # Killed due to segmentation fault  
```

Otherwise on my machine everything passes (with AVX2).

(in the above two each time `FDS.in_lib` fails, so that doesn't seem to be related, also the singular timout doesn't seem to be related).

---
New commits:



---

archive/issue_comments_521279.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2021-01-15T18:06:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521279",
    "user": "https://github.com/kliem"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_521280.json:
```json
{
    "body": "Changing branch from \"public/27103-reb3\" to \"public/27103-in-bitsets\"",
    "created_at": "2021-01-15T18:06:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521280",
    "user": "https://github.com/kliem"
}
```

Changing branch from "public/27103-reb3" to "public/27103-in-bitsets"



---

archive/issue_comments_521281.json:
```json
{
    "body": "Changing commit from \"cfcdeb677073fc32f8dd57263056b640a7f6a518\" to \"bd78875e2aad36e4631d3c329df411c5afbac39a\"",
    "created_at": "2021-01-15T18:06:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521281",
    "user": "https://github.com/kliem"
}
```

Changing commit from "cfcdeb677073fc32f8dd57263056b640a7f6a518" to "bd78875e2aad36e4631d3c329df411c5afbac39a"



---

archive/issue_events_067337.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2021-01-15T18:47:51Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "milestone": "sage-pending",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27103#event-67337"
}
```



---

archive/issue_events_067338.json:
```json
{
    "actor": "https://github.com/kliem",
    "created_at": "2021-01-15T18:47:51Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27103#event-67338"
}
```



---

archive/issue_comments_521282.json:
```json
{
    "body": "<a id='comment:39'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-15T18:49:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521282",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:39'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_521283.json:
```json
{
    "body": "Changing commit from \"bd78875e2aad36e4631d3c329df411c5afbac39a\" to \"db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a\"",
    "created_at": "2021-01-15T18:49:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521283",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "bd78875e2aad36e4631d3c329df411c5afbac39a" to "db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a"



---

archive/issue_comments_521284.json:
```json
{
    "body": "<a id='comment:40'></a>Replying to [comment:39 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> |                                                                                                                                           |                               |\n> |-------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|\n> |[db11a45](https://git.sagemath.org/sage.git/commit/?id=db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a)|`enable intrinsics for bitsets`|\n\n\nForgot to commit.",
    "created_at": "2021-01-15T18:49:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521284",
    "user": "https://github.com/kliem"
}
```

<a id='comment:40'></a>Replying to [comment:39 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> |                                                                                                                                           |                               |
> |-------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------|
> |[db11a45](https://git.sagemath.org/sage.git/commit/?id=db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a)|`enable intrinsics for bitsets`|


Forgot to commit.



---

archive/issue_comments_521285.json:
```json
{
    "body": "Changing commit from \"db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a\" to \"65dba93023b83874be5b18d0e3f58ba5484b7db9\"",
    "created_at": "2021-01-15T18:55:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521285",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "db11a450cfb5d88d7c6e8c8e0837bfb0e506f09a" to "65dba93023b83874be5b18d0e3f58ba5484b7db9"



---

archive/issue_comments_521286.json:
```json
{
    "body": "<a id='comment:41'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-15T18:55:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521286",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:41'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_521287.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,4 +1,180 @@\n+#27122 enabled `-march=native` by default. This allows using intrinsics for Intel and AMD processors (unless the user specified different `CFLAGS` or `CXXFLAGS` differently).\n \n+Bitsets allocated using `MemoryAllocator` are overaligned allocated. This is not the case otherwise and there are several reasons not to do so for now:\n+- More memory usage especially for small bitsets (`bitset_t` itself is rather small).\n+- It makes `realloc` a lot harder.\n+- There seems to be only about 10 percent loss when data is not overaligned.\n+- There seems to be only about 1 percent performance loss, when the data is overaligned but the code is not customized for it (`_mm256_loadu_si256` instead of `_mm256_load_si256` etc).\n+\n+See https://software.intel.com/sites/landingpage/IntrinsicsGuide for details about the instructions.\n+\n+The emptyness check as it is seems be really fast and it appears pointless to beat it using intrinsics.\n+\n+A few minor improvements in the bitset frontend of bitsets were also made.\n+\n+Timings without intrinsics (should be exactly the same as without this ticket as the code almost did not change):\n+\n+```\n+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \n+sage: %timeit B == B                                                                                                                                                                \n+7.93 \u00b5s \u00b1 5.71 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: Bop = ~B                                                                                                                                                                      \n+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n+8.11 \u00b5s \u00b1 4.43 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.issubset(B)                                                                                                                                                         \n+7.98 \u00b5s \u00b1 7.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: B2 = ~Bop                                    \n+sage: %timeit B2.intersection_update(B)                                                                                                                                             \n+7.22 \u00b5s \u00b1 20 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B2.union(B)                                                                                                                                                           \n+14.6 \u00b5s \u00b1 5.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n+14 \u00b5s \u00b1 9.34 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.difference_update(Bop)                                                                                                                                              \n+7.2 \u00b5s \u00b1 19.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: P = polytopes.hypercube(14)                                                                                                                                                   \n+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \n+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 12.8 s, sys: 7.98 ms, total: 12.8 s\n+Wall time: 12.8 s\n+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n+\n+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 581 ms, sys: 0 ns, total: 581 ms\n+Wall time: 580 ms\n+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n+\n+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 38 s, sys: 20.2 ms, total: 38 s\n+Wall time: 38 s\n+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n+```\n+\n+With SSE4.1 (some of them would also run just with SSE2, but already SSE4.1 is 2008):\n+\n+```\n+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \n+sage: %timeit B == B                                                                                                                                                                \n+7.91 \u00b5s \u00b1 3.03 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: Bop = ~B                                                                                                                                                                      \n+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n+5.1 \u00b5s \u00b1 6.09 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.issubset(B)                                                                                                                                                         \n+4.71 \u00b5s \u00b1 5.07 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: B2 = ~Bop                                                                                                                                                                     \n+sage: %timeit B2.intersection_update(B)                                                                                                                                             \n+5.57 \u00b5s \u00b1 9.94 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B2.union(B)                                                                                                                                                           \n+11.9 \u00b5s \u00b1 5.64 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n+12.4 \u00b5s \u00b1 7.06 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.difference_update(Bop)                                                                                                                                              \n+4.66 \u00b5s \u00b1 38.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: P = polytopes.hypercube(14)                                                                                                                                                   \n+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \n+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 7.98 s, sys: 4 ms, total: 7.99 s\n+Wall time: 7.98 s\n+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n+\n+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 466 ms, sys: 0 ns, total: 466 ms\n+Wall time: 466 ms\n+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n+                                                                                                                                                                              \n+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 26.8 s, sys: 8.09 ms, total: 26.8 s\n+Wall time: 26.8 s\n+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n+```\n+\n+With AVX:\n+\n+```\n+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \n+sage: %timeit B == B                                                                                                                                                                \n+3.99 \u00b5s \u00b1 2.46 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: Bop = ~B                                                                                                                                                                      \n+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     \n+3.38 \u00b5s \u00b1 12.7 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.issubset(B)                                                                                                                                                         \n+3.05 \u00b5s \u00b1 2.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: P = polytopes.hypercube(14)                                                                                                                                                   \n+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \n+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 5.27 s, sys: 7.97 ms, total: 5.28 s\n+Wall time: 5.28 s\n+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n+\n+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 449 ms, sys: 6 \u00b5s, total: 449 ms\n+Wall time: 449 ms\n+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n+\n+# It does not use subset checks as it is a simple polytope.\n+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 30.4 s, sys: 23.6 ms, total: 30.4 s\n+Wall time: 30.4 s\n+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n+```\n+\n+With AVX2:\n+\n+```\n+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          \n+sage: Bop = ~B                                                                                                                                                                      \n+sage: B2 = ~Bop                                                                                                                                                                     \n+sage: %timeit B2.intersection_update(B)                                                                                                                                             \n+4.2 \u00b5s \u00b1 3.28 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B2.union(B)                                                                                                                                                           \n+12 \u00b5s \u00b1 5.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           \n+12 \u00b5s \u00b1 5.98 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+sage: %timeit B.difference_update(Bop)                                                                                                                                              \n+4.03 \u00b5s \u00b1 3.46 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n+\n+sage: P = polytopes.hypercube(14)                                                                                                                                                   \n+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       \n+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 5.18 s, sys: 7 \u00b5s, total: 5.18 s\n+Wall time: 5.18 s\n+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)\n+\n+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 436 ms, sys: 3 \u00b5s, total: 436 ms\n+Wall time: 435 ms\n+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)\n+\n+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    \n+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                \n+sage: %time C.f_vector()                                                                                                                                                            \n+CPU times: user 24.3 s, sys: 19.7 ms, total: 24.3 s\n+Wall time: 24.3 s\n+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)\n+```\n \n Dependencies: #26887\n \n``````\n",
    "created_at": "2021-01-15T21:05:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521287",
    "user": "https://github.com/kliem"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,4 +1,180 @@
+#27122 enabled `-march=native` by default. This allows using intrinsics for Intel and AMD processors (unless the user specified different `CFLAGS` or `CXXFLAGS` differently).
 
+Bitsets allocated using `MemoryAllocator` are overaligned allocated. This is not the case otherwise and there are several reasons not to do so for now:
+- More memory usage especially for small bitsets (`bitset_t` itself is rather small).
+- It makes `realloc` a lot harder.
+- There seems to be only about 10 percent loss when data is not overaligned.
+- There seems to be only about 1 percent performance loss, when the data is overaligned but the code is not customized for it (`_mm256_loadu_si256` instead of `_mm256_load_si256` etc).
+
+See https://software.intel.com/sites/landingpage/IntrinsicsGuide for details about the instructions.
+
+The emptyness check as it is seems be really fast and it appears pointless to beat it using intrinsics.
+
+A few minor improvements in the bitset frontend of bitsets were also made.
+
+Timings without intrinsics (should be exactly the same as without this ticket as the code almost did not change):
+
+```
+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
+sage: %timeit B == B                                                                                                                                                                
+7.93 µs ± 5.71 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: Bop = ~B                                                                                                                                                                      
+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
+8.11 µs ± 4.43 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.issubset(B)                                                                                                                                                         
+7.98 µs ± 7.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: B2 = ~Bop                                    
+sage: %timeit B2.intersection_update(B)                                                                                                                                             
+7.22 µs ± 20 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B2.union(B)                                                                                                                                                           
+14.6 µs ± 5.3 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
+14 µs ± 9.34 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.difference_update(Bop)                                                                                                                                              
+7.2 µs ± 19.2 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: P = polytopes.hypercube(14)                                                                                                                                                   
+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 12.8 s, sys: 7.98 ms, total: 12.8 s
+Wall time: 12.8 s
+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)
+
+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 581 ms, sys: 0 ns, total: 581 ms
+Wall time: 580 ms
+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
+
+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 38 s, sys: 20.2 ms, total: 38 s
+Wall time: 38 s
+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
+```
+
+With SSE4.1 (some of them would also run just with SSE2, but already SSE4.1 is 2008):
+
+```
+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
+sage: %timeit B == B                                                                                                                                                                
+7.91 µs ± 3.03 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: Bop = ~B                                                                                                                                                                      
+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
+5.1 µs ± 6.09 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.issubset(B)                                                                                                                                                         
+4.71 µs ± 5.07 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: B2 = ~Bop                                                                                                                                                                     
+sage: %timeit B2.intersection_update(B)                                                                                                                                             
+5.57 µs ± 9.94 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B2.union(B)                                                                                                                                                           
+11.9 µs ± 5.64 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
+12.4 µs ± 7.06 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.difference_update(Bop)                                                                                                                                              
+4.66 µs ± 38.1 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: P = polytopes.hypercube(14)                                                                                                                                                   
+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 7.98 s, sys: 4 ms, total: 7.99 s
+Wall time: 7.98 s
+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)
+
+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 466 ms, sys: 0 ns, total: 466 ms
+Wall time: 466 ms
+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
+                                                                                                                                                                              
+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 26.8 s, sys: 8.09 ms, total: 26.8 s
+Wall time: 26.8 s
+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
+```
+
+With AVX:
+
+```
+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
+sage: %timeit B == B                                                                                                                                                                
+3.99 µs ± 2.46 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: Bop = ~B                                                                                                                                                                      
+sage: %timeit B.isdisjoint(Bop)                                                                                                                                                     
+3.38 µs ± 12.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.issubset(B)                                                                                                                                                         
+3.05 µs ± 2.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: P = polytopes.hypercube(14)                                                                                                                                                   
+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 5.27 s, sys: 7.97 ms, total: 5.28 s
+Wall time: 5.28 s
+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)
+
+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 449 ms, sys: 6 µs, total: 449 ms
+Wall time: 449 ms
+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
+
+# It does not use subset checks as it is a simple polytope.
+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 30.4 s, sys: 23.6 ms, total: 30.4 s
+Wall time: 30.4 s
+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
+```
+
+With AVX2:
+
+```
+sage: B = Bitset((randint(0,2**20) for _ in range(2**19)))                                                                                                                          
+sage: Bop = ~B                                                                                                                                                                      
+sage: B2 = ~Bop                                                                                                                                                                     
+sage: %timeit B2.intersection_update(B)                                                                                                                                             
+4.2 µs ± 3.28 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B2.union(B)                                                                                                                                                           
+12 µs ± 5.9 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.symmetric_difference(Bop)                                                                                                                                           
+12 µs ± 5.98 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+sage: %timeit B.difference_update(Bop)                                                                                                                                              
+4.03 µs ± 3.46 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
+
+sage: P = polytopes.hypercube(14)                                                                                                                                                   
+sage: P1 = P.stack(next(P.face_generator(1)))                                                                                                                                       
+sage: C = CombinatorialPolyhedron(P1)                                                                                                                                               
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 5.18 s, sys: 7 µs, total: 5.18 s
+Wall time: 5.18 s
+(1, 16385, 131069, 487383, 1117948, 1769482, 2047331, 1788501, 1200342, 622908, 248963, 75361, 16640, 2470, 197, 1)
+
+sage: P = polytopes.Birkhoff_polytope(5)                                                                                                                                            
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 436 ms, sys: 3 µs, total: 436 ms
+Wall time: 435 ms
+(1, 120, 5040, 50250, 233400, 631700, 1113700, 1367040, 1220550, 817150, 419225, 167200, 52120, 12600, 2300, 300, 25, 1)
+
+sage: P = polytopes.associahedron(['A', 11], backend='normaliz')                                                                                                                    
+sage: C = CombinatorialPolyhedron(P)                                                                                                                                                
+sage: %time C.f_vector()                                                                                                                                                            
+CPU times: user 24.3 s, sys: 19.7 ms, total: 24.3 s
+Wall time: 24.3 s
+(1, 208012, 1144066, 2735810, 3730650, 3197700, 1790712, 659736, 157080, 23100, 1925, 77, 1)
+```
 
 Dependencies: #26887
 
``````




---

archive/issue_comments_521288.json:
```json
{
    "body": "Changing commit from \"65dba93023b83874be5b18d0e3f58ba5484b7db9\" to \"8bd0b1fe087a802603b426bd22d51458b951d776\"",
    "created_at": "2021-01-15T21:19:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521288",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing commit from "65dba93023b83874be5b18d0e3f58ba5484b7db9" to "8bd0b1fe087a802603b426bd22d51458b951d776"



---

archive/issue_comments_521289.json:
```json
{
    "body": "<a id='comment:43'></a>Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2021-01-15T21:19:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521289",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

<a id='comment:43'></a>Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_521290.json:
```json
{
    "body": "<a id='comment:44'></a>Also works for me with\n\n- Operating System: Ubuntu 18.04.5 LTS\n- Kernel: Linux 4.15.0-112-generic\n- Architecture: x86-64\n- Model: Intel(R) Core(TM) i7-8700 CPU `@` 3.20GHz\n- sse4_1, sse4_2, avx, avx2 in cpu flags\n\nBased on this, the patchbots, and the previous comments, I am setting this to a positive review.",
    "created_at": "2021-01-17T02:13:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521290",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:44'></a>Also works for me with

- Operating System: Ubuntu 18.04.5 LTS
- Kernel: Linux 4.15.0-112-generic
- Architecture: x86-64
- Model: Intel(R) Core(TM) i7-8700 CPU `@` 3.20GHz
- sse4_1, sse4_2, avx, avx2 in cpu flags

Based on this, the patchbots, and the previous comments, I am setting this to a positive review.



---

archive/issue_comments_521291.json:
```json
{
    "body": "Changing reviewer from \"\" to \"Travis Scrimshaw\"",
    "created_at": "2021-01-17T02:13:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521291",
    "user": "https://github.com/tscrim"
}
```

Changing reviewer from "" to "Travis Scrimshaw"



---

archive/issue_comments_521292.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-01-17T02:13:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521292",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_521293.json:
```json
{
    "body": "<a id='comment:45'></a>Thank you.",
    "created_at": "2021-01-17T08:36:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521293",
    "user": "https://github.com/kliem"
}
```

<a id='comment:45'></a>Thank you.



---

archive/issue_events_067339.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2021-01-31T20:53:48Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/27103#event-67339"
}
```



---

archive/issue_comments_521294.json:
```json
{
    "body": "Changing branch from \"public/27103-in-bitsets\" to \"8bd0b1fe087a802603b426bd22d51458b951d776\"",
    "created_at": "2021-01-31T20:53:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521294",
    "user": "https://github.com/vbraun"
}
```

Changing branch from "public/27103-in-bitsets" to "8bd0b1fe087a802603b426bd22d51458b951d776"



---

archive/issue_comments_521295.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2021-01-31T20:53:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27103",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27103#issuecomment-521295",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
