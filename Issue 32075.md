# Issue 32075: faster abelian_group() method for elliptic curves over finite fields

Issue created by migration from https://trac.sagemath.org/ticket/32312

Original creator: lorenz

Original creation time: 2021-07-30 11:11:24

CC:  cremona klee defeo

Keywords: elliptic curves, group structure, finite field

This patch improves the computation of a basis of the group of rational points for elliptic curves over finite fields.

The algorithm works as follows:
* Call `gens()` to obtain a generating set; this in turn calls into PARI which factors the group order and uses pairings to determine the group structure.
* Let `P` denote the point of larger order `n₁`; we will extend `P` to a basis `(P,Q')` where `Q'` has order `n₂ = #E/n₁`.
* Remove all unneeded prime factors from the order of `Q`, i.e., multiply by the part of `n₁` that's coprime to `n₂`.
* Find an appropriate multiple `[x]P` such that `Q' := Q-[x]P` has order `n₂`; this involves a (typically easy) discrete-logarithm computation.
* As desired, `(P,Q')` is then a basis of the group of rational points of E.

Benchmarks: I ran `.abelian_group()` on thousands of random elliptic curves over prime and extension fields with sizes between 8 and 160 bits using both Sage 9.3 and the new implementation, and the new algorithm was between 30% and 50% faster on average (for all sizes).

In addition, there are cases for which the new algorithm is _dramatically_ faster. For example:

*Sage 9.3:*

```
sage: for e in [7,17,31,61,127]:
....:     E = EllipticCurve(GF((2**e-1)**2), [1,0])
....:     %time E.abelian_group()
....:
CPU times: user 20.7 ms, sys: 66 µs, total: 20.7 ms
Wall time: 20.8 ms
Additive abelian group isomorphic to Z/128 + Z/128 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + x over Finite Field in z2 of size 127^2
CPU times: user 342 ms, sys: 45 µs, total: 342 ms
Wall time: 342 ms
Additive abelian group isomorphic to Z/131072 + Z/131072 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + x over Finite Field in z2 of size 131071^2
CPU times: user 1min 23s, sys: 103 ms, total: 1min 23s
Wall time: 1min 23s
Additive abelian group isomorphic to Z/2147483648 + Z/2147483648 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + x over Finite Field in z2 of size 2147483647^2
#### (continues to run for a long time, then dies from lack of memory)
```


*New code:*

```
sage: for e in [7,17,31,61,127]:
....:     E = EllipticCurve(GF((2**e-1)**2), [1,0])
....:     %time E.abelian_group()
....:
CPU times: user 3.78 ms, sys: 0 ns, total: 3.78 ms
Wall time: 3.78 ms
Additive abelian group isomorphic to Z/128 + Z/128 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + x over Finite Field in z2 of size 127^2
CPU times: user 7.75 ms, sys: 0 ns, total: 7.75 ms
Wall time: 7.77 ms
Additive abelian group isomorphic to Z/131072 + Z/131072 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + x over Finite Field in z2 of size 131071^2
CPU times: user 12 ms, sys: 0 ns, total: 12 ms
Wall time: 12 ms
Additive abelian group isomorphic to Z/2147483648 + Z/2147483648 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + x over Finite Field in z2 of size 2147483647^2
CPU times: user 29.7 ms, sys: 0 ns, total: 29.7 ms
Wall time: 29.8 ms
Additive abelian group isomorphic to Z/2305843009213693952 + Z/2305843009213693952 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + x over Finite Field in z2 of size 2305843009213693951^2
CPU times: user 280 ms, sys: 0 ns, total: 280 ms
Wall time: 280 ms
Additive abelian group isomorphic to Z/170141183460469231731687303715884105728 + Z/170141183460469231731687303715884105728 embedded in Abelian group of points on Elliptic Curve defined by y^2 = x^3 + x over Finite Field in z2 of size 170141183460469231731687303715884105727^2
```


The only curves for which the new algorithm is _not_ polynomial-time (after factoring the order) are curves whose group of rational points has `ℓ^∞`-torsion isomorphic to `ℤ/ℓ^r × ℤ/ℓ^s` where `r > s > 0` for some prime `ℓ`. In that case, the cost includes a factor `Θ(√ℓ)`. I don't think I know how to construct such curves for large `ℓ`.



---

Comment by lorenz created at 2021-07-30 11:12:20

Changing status from new to needs_review.


---

Comment by lorenz created at 2021-08-12 00:45:50

Changing priority from minor to major.


---

Comment by tscrim created at 2021-08-15 00:20:45

I cannot attest to the validity of the algorithm, but it is implemented as defined as far as I can tell and it passes doctests.

Is this something that is guaranteed to happen or is it for controlling user input?

```
assert len(gens) <= 2
```


Also, it would be better to write this on two lines:

```diff
-S, T = n//nQ * P, n2 * Q
+S = n//nQ * P
+T = n2 * Q
```


In the doc, you should use `\ZZ` instead of `\mathbb Z` for uniformity.

Do you have a reference for this algorithm you could add to the doc?


---

Comment by git created at 2021-08-15 07:35:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2021-08-15 07:37:34

Replying to [comment:7 tscrim]:
> Is this something that is guaranteed to happen or is it for controlling user input?
> {{{
> assert len(gens) <= 2
> }}}

This is guaranteed by the documentation and current implementation of `self.gens()`. Unless someone changes the meaning of `gens()` in a mathematically nonsensical way in the future, it will always hold. I suppose the `assert` is realistically useless, but it does make explicit an assumption of the following code.

> Do you have a reference for this algorithm you could add to the doc?

I pretty much made this one up while writing the code. Does anyone know a reference? This is a generic-group algorithm, so it's probably a special case of something in Sutherland's thesis (or elsewhere), but the specifics here are tailored to the output of `gens()`.


---

Comment by git created at 2021-08-15 07:40:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-08-16 00:27:17

Replying to [comment:9 lorenz]:
> Replying to [comment:7 tscrim]:
> > Is this something that is guaranteed to happen or is it for controlling user input?
> > {{{
> > assert len(gens) <= 2
> > }}}
> 
> This is guaranteed by the documentation and current implementation of `self.gens()`. Unless someone changes the meaning of `gens()` in a mathematically nonsensical way in the future, it will always hold. I suppose the `assert` is realistically useless, but it does make explicit an assumption of the following code.

That was my understanding from looking at the previous code, but I figured I should double-check.

> > Do you have a reference for this algorithm you could add to the doc?
> 
> I pretty much made this one up while writing the code. Does anyone know a reference? This is a generic-group algorithm, so it's probably a special case of something in Sutherland's thesis (or elsewhere), but the specifics here are tailored to the output of `gens()`.

This is outside of my area of expertise. Could you add a bit about the algorithm in to the documentation? Also, is this random still? It looks quite deterministic.


---

Comment by git created at 2021-08-16 06:55:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by lorenz created at 2021-08-16 06:57:34

Replying to [comment:11 tscrim]:
> Could you add a bit about the algorithm in to the documentation? Also, is this random still? It looks quite deterministic.

Done, and yes: It calls into `.gens()`, which is randomized. I've tried making this a little bit clearer in the newest commit.


---

Comment by tscrim created at 2021-08-16 12:18:28

Thank you. LGTM.


---

Comment by tscrim created at 2021-08-16 12:18:28

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-09-05 21:38:45

Resolution: fixed
