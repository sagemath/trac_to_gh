# Issue 20683: Changes to Unknown class

Issue created by migration from Trac.

Original creator: eviatarbach

Original creation time: 2016-07-02 00:08:44

CC:  slelievre tmonteil vdelecroix

Keywords: days78

The `Unknown` class currently evaluates to `False` when converted to a boolean. This also leads to wrong results when using the logical operators, as explained in `unknown.py`.

This ticket makes evaluating the truth value of `Unknown` with `__nonzero__` an error, meaning that logical operations must be done only with the bitwise operators. It also adapts the `UnknownClass` to add support for an `Undecidable` object, which is similar to `Unknown` but intended specifically for cases when an answer is known to be formally undecidable. This is useful for #17700.


---

Comment by eviatarbach created at 2016-07-02 00:12:41

New commits:


---

Comment by eviatarbach created at 2016-07-02 00:17:26

Adding a preliminary patch. Some tests fail in `orthogonal_arrays.py` and `difference_family.py` due to #20919.

I changed many instances of code like:


```
if orthogonal_array(k, n, existence=True):
...
```


to


```
if orthogonal_array(k, n, existence=True) == True:
...
```


since the former fails with the new `Unknown` implementation.


---

Comment by eviatarbach created at 2016-07-02 00:17:26

Changing type from PLEASE CHANGE to enhancement.


---

Comment by vdelecroix created at 2016-07-02 09:09:14

What is the point of an `Undecidable` class? To my mind this is completely useless.

- either you have an algorithm that works sometimes (because the problem is undecidable). If an instance of this algorithm fails, then you should raise an error or possibly returns `Unknown`.
- or you have no algorithm for a given problem and it makes no sense to write an empty Python function for that.


---

Comment by tscrim created at 2016-07-02 15:30:41

`Undeciable` indicates that there is a stronger statement being made, e.g., trying to determine if two finitely presented groups are isomorphic, whereas `Unknown` simply says the algorithm (currently) cannot determine a solution.

Suggestion for the implementation, did you consider using `misc.fast_methods.Singleton`, and having two classes (with a common base class). (More of a technical note, you cannot inherit `Singleton` in the base class, just the "final" class.)


---

Comment by vdelecroix created at 2016-07-02 17:06:58

Hi Travis,

Replying to [comment:5 tscrim]:
> `Undeciable` indicates that there is a stronger statement being made, e.g., trying to determine if two finitely presented groups are isomorphic, whereas `Unknown` simply says the algorithm (currently) cannot determine a solution.

Let me try to make clearer my point. When you ask the question `are_isomorphic(G1, G2)` this has an answer: either `True` or `False`. As you said, despite the 1001 heuristics implemented, it might be that the algorithm you have does not have anything relevant to say. However, returning `Undecidable` is a complete nonsense. The problem `are_isomorphic` (*without parameters*) is undecidable but the instance `are_isomorphic(G1, G2)` is always decidable.


---

Comment by tscrim created at 2016-07-02 19:55:30

Replying to [comment:6 vdelecroix]:
> Replying to [comment:5 tscrim]:
> > `Undeciable` indicates that there is a stronger statement being made, e.g., trying to determine if two finitely presented groups are isomorphic, whereas `Unknown` simply says the algorithm (currently) cannot determine a solution.
> 
> Let me try to make clearer my point. When you ask the question `are_isomorphic(G1, G2)` this has an answer: either `True` or `False`. As you said, despite the 1001 heuristics implemented, it might be that the algorithm you have does not have anything relevant to say. However, returning `Undecidable` is a complete nonsense. The problem `are_isomorphic` (*without parameters*) is undecidable but the instance `are_isomorphic(G1, G2)` is always decidable.

My understanding is that the isomorphism problem (determining if `G1` and `G2` are isomorphic) for finitely-presented groups is undecidable. At least for the word problem (if two reduced expressions represent the same element) in a finitely-presented group, it is undecidable: https://en.wikipedia.org/wiki/Word_problem_for_groups. Heuristics in this case are usually checks to show things are not equal, e.g., checking if some of invariant is different.

However, this is different than the case when we don't know if something is undeciable, in that there might exist some algorithm which we don't yet know of. These are often more closely tied with constructions of objects, like constructing strongly regular graphs (I believe). So I feel that having an `Undeciable` allows us to carry more information to the user that they are trying to do something that is impossible.


---

Comment by eviatarbach created at 2016-07-02 21:58:28

Ah yes, I see vdelecroix's point.

It does seem that it would not be too useful to let the user know that the general problem is undecidable given an instance of it that the algorithm is not able to solve. If we made use of [Richardson's theorem](https://en.wikipedia.org/wiki/Richardson%27s_theorem), for example, to return `Undecidable` for testing equality for a certain class of symbolic expressions, we could confuse the user into believing a certain problem was "impossible" even when a trivial heuristic solution exists.

Perhaps information on undecidability of a problem should be left to documentation?


---

Comment by eviatarbach created at 2016-07-02 22:03:47

Oh, and good idea on using the `Singleton` class, I didn't know about it.


---

Comment by vdelecroix created at 2016-07-03 11:03:31

Replying to [comment:8 eviatarbach]:
> Ah yes, I see vdelecroix's point.
> 
> It does seem that it would not be too useful to let the user know that the general problem is undecidable given an instance of it that the algorithm is not able to solve. If we made use of [Richardson's theorem](https://en.wikipedia.org/wiki/Richardson%27s_theorem), for example, to return `Undecidable` for testing equality for a certain class of symbolic expressions, we could confuse the user into believing a certain problem was "impossible" even when a trivial heuristic solution exists.
> 
> Perhaps information on undecidability of a problem should be left to documentation?

Having this in the documentation looks like a good idea to me!


---

Comment by tscrim created at 2016-07-03 15:20:00

Works for me too.
