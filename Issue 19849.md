# Issue 19849: Asymptotic ring: fix exponentiation

archive/issues_019849.json:
```json
{
    "body": "CC:  behackl dkrenn\n\n\n```\nsage: P.<R> = QQ[]\nsage: A.<Z> = AsymptoticRing('T^QQ', P)\nsage: sqrt(Z)\nTraceback (most recent call last):\n...\nArithmeticError: Cannot take T to the exponent 1/2 in Exact Term Monoid T^QQ\nwith coefficients in Univariate Polynomial Ring in R over Rational Field\nsince its coefficient 1 cannot be taken to this exponent.\n> *previous* TypeError: rational is not an integer\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/20086\n\n",
    "created_at": "2016-02-19T12:52:04Z",
    "labels": [
        "asymptotic expansions",
        "major",
        "bug"
    ],
    "title": "Asymptotic ring: fix exponentiation",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/19849",
    "user": "cheuberg"
}
```
CC:  behackl dkrenn


```
sage: P.<R> = QQ[]
sage: A.<Z> = AsymptoticRing('T^QQ', P)
sage: sqrt(Z)
Traceback (most recent call last):
...
ArithmeticError: Cannot take T to the exponent 1/2 in Exact Term Monoid T^QQ
with coefficients in Univariate Polynomial Ring in R over Rational Field
since its coefficient 1 cannot be taken to this exponent.
> *previous* TypeError: rational is not an integer
```


Issue created by migration from https://trac.sagemath.org/ticket/20086





---

archive/issue_comments_272740.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-19T13:19:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272740",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272741.json:
```json
{
    "body": "Changing component from asymptotic expansions to basic arithmetic.",
    "created_at": "2016-02-19T13:22:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272741",
    "user": "cheuberg"
}
```

Changing component from asymptotic expansions to basic arithmetic.



---

archive/issue_comments_272742.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-02-19T13:22:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272742",
    "user": "cheuberg"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_272743.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-19T15:37:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272743",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272744.json:
```json
{
    "body": "The fact that for a in QQ, the value of `a^(1/2)` has its parent depending on the actual value of a is a compromise for novice use (in calculus etc.) Normally, one would raise an error if `a^(1/2)` does not lie in QQ. Certainly, promoting to SR is a very bad choice for anything else than novice use.\n\nI see you take the effort of trying to put the result back in the original parent. Don't you think it's better to force that? i.e., raise an error if it doesn't work, rather than give a result back in SR?\n\nThe problem is that if someone is computing with polynomials, it's almost certainly not desired to end up in SR (where things like `QQ['x']['x']` get squashed), and if an error isn't raised, it's very hard to detect that it happened.\n\nAlso, if you're implementing the (partial) map `a:->a^(n/m)` , why not extend it properly? When\n`(QQ['x'](4))^(1/2)` works, why should `QQ['x'](x<sup>2)</sup>(1/2)` fail?",
    "created_at": "2016-02-20T01:56:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272744",
    "user": "nbruin"
}
```

The fact that for a in QQ, the value of `a^(1/2)` has its parent depending on the actual value of a is a compromise for novice use (in calculus etc.) Normally, one would raise an error if `a^(1/2)` does not lie in QQ. Certainly, promoting to SR is a very bad choice for anything else than novice use.

I see you take the effort of trying to put the result back in the original parent. Don't you think it's better to force that? i.e., raise an error if it doesn't work, rather than give a result back in SR?

The problem is that if someone is computing with polynomials, it's almost certainly not desired to end up in SR (where things like `QQ['x']['x']` get squashed), and if an error isn't raised, it's very hard to detect that it happened.

Also, if you're implementing the (partial) map `a:->a^(n/m)` , why not extend it properly? When
`(QQ['x'](4))^(1/2)` works, why should `QQ['x'](x<sup>2)</sup>(1/2)` fail?



---

archive/issue_comments_272745.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-02-22T17:19:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272745",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272746.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2016-02-22T17:28:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272746",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_272747.json:
```json
{
    "body": "Replying to [comment:6 nbruin]:\n> The fact that for a in QQ, the value of `a^(1/2)` has its parent depending on the actual value of a is a compromise for novice use (in calculus etc.) Normally, one would raise an error if `a^(1/2)` does not lie in QQ. Certainly, promoting to SR is a very bad choice for anything else than novice use.\n> \n> I see you take the effort of trying to put the result back in the original parent. Don't you think it's better to force that? i.e., raise an error if it doesn't work, rather than give a result back in SR?\n> \n> The problem is that if someone is computing with polynomials, it's almost certainly not desired to end up in SR (where things like `QQ['x']['x']` get squashed), and if an error isn't raised, it's very hard to detect that it happened.\n\nvery valid points, thank you. I now raise an exception.\n\n> \n> Also, if you're implementing the (partial) map `a:->a^(n/m)` , why not extend it properly? When\n> `(QQ['x'](4))^(1/2)` works, why should `QQ['x'](x<sup>2)</sup>(1/2)` fail?\n\nI needed a fix a bug which did bite me somewhere else, see initial description. Of course, it would be nice to have that, too; but I'd prefer to leave that to a follow-up ticket and to have this functionality here soon.",
    "created_at": "2016-02-22T17:33:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272747",
    "user": "cheuberg"
}
```

Replying to [comment:6 nbruin]:
> The fact that for a in QQ, the value of `a^(1/2)` has its parent depending on the actual value of a is a compromise for novice use (in calculus etc.) Normally, one would raise an error if `a^(1/2)` does not lie in QQ. Certainly, promoting to SR is a very bad choice for anything else than novice use.
> 
> I see you take the effort of trying to put the result back in the original parent. Don't you think it's better to force that? i.e., raise an error if it doesn't work, rather than give a result back in SR?
> 
> The problem is that if someone is computing with polynomials, it's almost certainly not desired to end up in SR (where things like `QQ['x']['x']` get squashed), and if an error isn't raised, it's very hard to detect that it happened.

very valid points, thank you. I now raise an exception.

> 
> Also, if you're implementing the (partial) map `a:->a^(n/m)` , why not extend it properly? When
> `(QQ['x'](4))^(1/2)` works, why should `QQ['x'](x<sup>2)</sup>(1/2)` fail?

I needed a fix a bug which did bite me somewhere else, see initial description. Of course, it would be nice to have that, too; but I'd prefer to leave that to a follow-up ticket and to have this functionality here soon.



---

archive/issue_comments_272748.json:
```json
{
    "body": "I've fixed the segmentation fault from `rings/integer.pyx` and implemented the case of `constant^constant`.\n\nAlso, +1 for extending this functionality on a follow-up ticket; I'd also like to have this in as soon as possible.\n\nI've reviewed your changes, please cross-review. If you are satisfied and if there are no other objections, I'd set this to `positive_review`.\n----\nNew commits:",
    "created_at": "2016-03-08T13:26:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272748",
    "user": "behackl"
}
```

I've fixed the segmentation fault from `rings/integer.pyx` and implemented the case of `constant^constant`.

Also, +1 for extending this functionality on a follow-up ticket; I'd also like to have this in as soon as possible.

I've reviewed your changes, please cross-review. If you are satisfied and if there are no other objections, I'd set this to `positive_review`.
----
New commits:



---

archive/issue_comments_272749.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-09T08:29:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272749",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272750.json:
```json
{
    "body": "Replying to [comment:11 behackl]:\n> I've fixed the segmentation fault from `rings/integer.pyx` and implemented the case of `constant^constant`.\n\nThat's weird, but as integer tries to convert the base to the base of the exponent and expects the polynomial ring to handle it, we have to cope with it.\n> \n> I've reviewed your changes, please cross-review. If you are satisfied and if there are no other objections, I'd set this to `positive_review`.\n\nI refactored the code: that way it seems to be more suitable for future extension and handles polynomial exponents gracefully.\n\nIn a first commit, I removed handling of the segmentation fault because I thought it should be handeled by the base ring; later on, I understood that it has to be handeled here, so re-instated fix (in some other way).\n----\nNew commits:",
    "created_at": "2016-03-09T17:03:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272750",
    "user": "cheuberg"
}
```

Replying to [comment:11 behackl]:
> I've fixed the segmentation fault from `rings/integer.pyx` and implemented the case of `constant^constant`.

That's weird, but as integer tries to convert the base to the base of the exponent and expects the polynomial ring to handle it, we have to cope with it.
> 
> I've reviewed your changes, please cross-review. If you are satisfied and if there are no other objections, I'd set this to `positive_review`.

I refactored the code: that way it seems to be more suitable for future extension and handles polynomial exponents gracefully.

In a first commit, I removed handling of the segmentation fault because I thought it should be handeled by the base ring; later on, I understood that it has to be handeled here, so re-instated fix (in some other way).
----
New commits:



---

archive/issue_comments_272751.json:
```json
{
    "body": "Why doing something that complicated for dealing with strange exponents? Why not simply\n\n```\nif input is not an integer:\n  convert to an integer\ndo the exponentiation\n```\n\n\nWhy are you special casing degree 0 polynomial? If I understand correctly these examples won't behave similarly\n\n```\nsage: R.<x> = QQ[]\nsage: ((x+1)^2)^(1/2)\n-> TypeError\nsage: ((R(2))^2)^(1/2)\n-> 2\n```\n\nWhich is weird.",
    "created_at": "2016-03-09T17:36:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272751",
    "user": "vdelecroix"
}
```

Why doing something that complicated for dealing with strange exponents? Why not simply

```
if input is not an integer:
  convert to an integer
do the exponentiation
```


Why are you special casing degree 0 polynomial? If I understand correctly these examples won't behave similarly

```
sage: R.<x> = QQ[]
sage: ((x+1)^2)^(1/2)
-> TypeError
sage: ((R(2))^2)^(1/2)
-> 2
```

Which is weird.



---

archive/issue_comments_272752.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2016-03-09T17:36:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272752",
    "user": "vdelecroix"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_272753.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2016-03-09T17:57:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272753",
    "user": "cheuberg"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_272754.json:
```json
{
    "body": "Replying to [comment:16 vdelecroix]:\n> Why doing something that complicated for dealing with strange exponents? Why not simply\n> {{{\n> if input is not an integer:\n>   convert to an integer\n> do the exponentiation\n> }}}\n\nI do not understand this comment. Which input? Base or Exponent? Where should this code be?\n\n\n> \n> Why are you special casing degree 0 polynomial? If I understand correctly these examples won't behave similarly\n> {{{\n> sage: R.<x> = QQ[]\n> sage: ((x+1)<sup>2)</sup>(1/2)\n> -> TypeError\n> sage: ((R(2))<sup>2)</sup>(1/2)\n> -> 2\n> }}}\n> Which is weird.\n\nI need a quick fix for `R(1)^(1/2)`. If somebody has time to implement `((x+1)<sup>2)</sup>(1/2)` very soon, I'd be happy. I do not have time soon. However, I want to have the code associated with a recently submitted paper in 7.1.\n\nBasically, this fix here simply branches to existing code. Computing `((x+1)<sup>2)</sup>(1/2)` needs new mathematical code (involving square free decomposition).\n\nTherefore, I propose to include this now on the basis that while this is not a perfect and definitive solution, it is better than the previous behaviour.",
    "created_at": "2016-03-09T17:57:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272754",
    "user": "cheuberg"
}
```

Replying to [comment:16 vdelecroix]:
> Why doing something that complicated for dealing with strange exponents? Why not simply
> {{{
> if input is not an integer:
>   convert to an integer
> do the exponentiation
> }}}

I do not understand this comment. Which input? Base or Exponent? Where should this code be?


> 
> Why are you special casing degree 0 polynomial? If I understand correctly these examples won't behave similarly
> {{{
> sage: R.<x> = QQ[]
> sage: ((x+1)<sup>2)</sup>(1/2)
> -> TypeError
> sage: ((R(2))<sup>2)</sup>(1/2)
> -> 2
> }}}
> Which is weird.

I need a quick fix for `R(1)^(1/2)`. If somebody has time to implement `((x+1)<sup>2)</sup>(1/2)` very soon, I'd be happy. I do not have time soon. However, I want to have the code associated with a recently submitted paper in 7.1.

Basically, this fix here simply branches to existing code. Computing `((x+1)<sup>2)</sup>(1/2)` needs new mathematical code (involving square free decomposition).

Therefore, I propose to include this now on the basis that while this is not a perfect and definitive solution, it is better than the previous behaviour.



---

archive/issue_comments_272755.json:
```json
{
    "body": "Replying to [comment:17 cheuberg]:\n> Replying to [comment:16 vdelecroix]:\n> > Why doing something that complicated for dealing with strange exponents? Why not simply\n> > {{{\n> > if input is not an integer:\n> >   convert to an integer\n> > do the exponentiation\n> > }}}\n> \n> I do not understand this comment. Which input? Base or Exponent? Where should this code be?\n \nLet me be more precise then\n\n```\ndef __pow__(self, exp):\n    cdef long n\n    try:\n        n = exp\n        # old code for integer exponent\n    except TypeError:\n        n = QQ.coerce(exp)\n        # new code for rational exponent\n```\n\nWhat I do not understand is why are you testing if the exponent is a polynomial...\n\nThe following is currently a `TypeError`\n\n```\nsage: 1^(ZZ['x'].one())\nTraceback (most recent call last):\n...\nTypeError: 'sage.rings.polynomial.polynomial_integer_dense_flint.Polynomial_integer_dense_flint' object cannot be interpreted as an index\n```\n\nThe same should happen when the integer `1` is replaced by the polynomial `1`.\n\n> > Why are you special casing degree 0 polynomial? If I understand correctly these examples won't behave similarly\n> > {{{\n> > sage: R.<x> = QQ[]\n> > sage: ((x+1)<sup>2)</sup>(1/2)\n> > -> TypeError\n> > sage: ((R(2))<sup>2)</sup>(1/2)\n> > -> 2\n> > }}}\n> > Which is weird.\n> \n> I need a quick fix for `R(1)^(1/2)`. If somebody has time to implement `((x+1)<sup>2)</sup>(1/2)` very soon, I'd be happy. I do not have time soon. However, I want to have the code associated with a recently submitted paper in 7.1.\n\nAre you sure there was a bug? In Sage the integer 1 is *not* the 1 from ZZ[x] (though they are equal through coercion). Some softwares behave differently to that respect (e.g. GAP) where there is only one 1 which is an integer and not anything else. In Sage (but not in GAP) it is already the case that operations change with respect to the parents even if the objects are equal\n\n```\nsage: Zmod(10)(3) == 3\nsage: Zmod(10)(5) == 5\nsage: log(Zmod(10)(3))\n3\nsage: log(Zmod(10)(5))\nTraceback (most recent call last):\n...\nZeroDivisionError: Inverse does not exist.\n```\n\n\n> Basically, this fix here simply branches to existing code.\n> Computing `((x+1)<sup>2)</sup>(1/2)` needs new mathematical code (involving square free decomposition).\n\nIndeed. Your modifications obfuscate the code for only a very trivial case and a discutable behavior of powering with polynomials.\n\n> Therefore, I propose to include this now on the basis that while this is not a perfect and definitive solution, it is better than the previous behaviour.\n\nNot sure it is better. Sage used to consider operations based on parents. Powers are of course a special type of operation and with some respect might be treated appart. But \"(polynomial)^(polynomial)\" is not well defined. And \"(polynomial)^(rational)\" is well defined in some situations (and to that respect, your code improves the current situation a little).\n\nMoreover, the current \"power promotion\" for ZZ is very bad\n\n```\nsage: 3^(1/2)\nsqrt(3)\nsage: parent(_)\nSymbolic Ring\nsage: 4^(1/2)\n2\nsage: parent(_)\nRational Field\n```\n\nMaking it available for constant polynomial is not that much of an improvement.",
    "created_at": "2016-03-09T18:31:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272755",
    "user": "vdelecroix"
}
```

Replying to [comment:17 cheuberg]:
> Replying to [comment:16 vdelecroix]:
> > Why doing something that complicated for dealing with strange exponents? Why not simply
> > {{{
> > if input is not an integer:
> >   convert to an integer
> > do the exponentiation
> > }}}
> 
> I do not understand this comment. Which input? Base or Exponent? Where should this code be?
 
Let me be more precise then

```
def __pow__(self, exp):
    cdef long n
    try:
        n = exp
        # old code for integer exponent
    except TypeError:
        n = QQ.coerce(exp)
        # new code for rational exponent
```

What I do not understand is why are you testing if the exponent is a polynomial...

The following is currently a `TypeError`

```
sage: 1^(ZZ['x'].one())
Traceback (most recent call last):
...
TypeError: 'sage.rings.polynomial.polynomial_integer_dense_flint.Polynomial_integer_dense_flint' object cannot be interpreted as an index
```

The same should happen when the integer `1` is replaced by the polynomial `1`.

> > Why are you special casing degree 0 polynomial? If I understand correctly these examples won't behave similarly
> > {{{
> > sage: R.<x> = QQ[]
> > sage: ((x+1)<sup>2)</sup>(1/2)
> > -> TypeError
> > sage: ((R(2))<sup>2)</sup>(1/2)
> > -> 2
> > }}}
> > Which is weird.
> 
> I need a quick fix for `R(1)^(1/2)`. If somebody has time to implement `((x+1)<sup>2)</sup>(1/2)` very soon, I'd be happy. I do not have time soon. However, I want to have the code associated with a recently submitted paper in 7.1.

Are you sure there was a bug? In Sage the integer 1 is *not* the 1 from ZZ[x] (though they are equal through coercion). Some softwares behave differently to that respect (e.g. GAP) where there is only one 1 which is an integer and not anything else. In Sage (but not in GAP) it is already the case that operations change with respect to the parents even if the objects are equal

```
sage: Zmod(10)(3) == 3
sage: Zmod(10)(5) == 5
sage: log(Zmod(10)(3))
3
sage: log(Zmod(10)(5))
Traceback (most recent call last):
...
ZeroDivisionError: Inverse does not exist.
```


> Basically, this fix here simply branches to existing code.
> Computing `((x+1)<sup>2)</sup>(1/2)` needs new mathematical code (involving square free decomposition).

Indeed. Your modifications obfuscate the code for only a very trivial case and a discutable behavior of powering with polynomials.

> Therefore, I propose to include this now on the basis that while this is not a perfect and definitive solution, it is better than the previous behaviour.

Not sure it is better. Sage used to consider operations based on parents. Powers are of course a special type of operation and with some respect might be treated appart. But "(polynomial)^(polynomial)" is not well defined. And "(polynomial)^(rational)" is well defined in some situations (and to that respect, your code improves the current situation a little).

Moreover, the current "power promotion" for ZZ is very bad

```
sage: 3^(1/2)
sqrt(3)
sage: parent(_)
Symbolic Ring
sage: 4^(1/2)
2
sage: parent(_)
Rational Field
```

Making it available for constant polynomial is not that much of an improvement.



---

archive/issue_comments_272756.json:
```json
{
    "body": "It seems that I mis-edited the description of the problem at some stage. Is now fixed.\n\nApart from that, the current code apparently leads to problems.",
    "created_at": "2016-03-09T20:01:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272756",
    "user": "cheuberg"
}
```

It seems that I mis-edited the description of the problem at some stage. Is now fixed.

Apart from that, the current code apparently leads to problems.



---

archive/issue_comments_272757.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-03-09T20:01:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272757",
    "user": "cheuberg"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_272758.json:
```json
{
    "body": "Replying to [comment:18 vdelecroix]:\n> Moreover, the current \"power promotion\" for ZZ is very bad\n> {{{\n> sage: 3^(1/2)\n> sqrt(3)\n> sage: parent(_)\n> Symbolic Ring\n> sage: 4^(1/2)\n> 2\n> sage: parent(_)\n> Rational Field\n> }}}\nsee [comment:6 nbruin]'s comment 6.",
    "created_at": "2016-03-09T20:03:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272758",
    "user": "cheuberg"
}
```

Replying to [comment:18 vdelecroix]:
> Moreover, the current "power promotion" for ZZ is very bad
> {{{
> sage: 3^(1/2)
> sqrt(3)
> sage: parent(_)
> Symbolic Ring
> sage: 4^(1/2)
> 2
> sage: parent(_)
> Rational Field
> }}}
see [comment:6 nbruin]'s comment 6.



---

archive/issue_comments_272759.json:
```json
{
    "body": "Hi Vincent!\n\nJust to clarify the previous need for checking whether the exponent is a polynomial: in our previous approach, we were hoping for the coefficient ring to carry out the exponentiation, i.e. if we had\n\n```\nsage: P.<z> = QQ[]\nsage: P(1/4)^(1/2)\n1/2\n```\n\nthen we would compute this by letting `QQ` do the exponentiation. However, in the doctest over at `rings/integer.pyx` we have something like\n\n```\nsage: P.<t> = QQ[]\nsage: 2^t\n```\n\nWith the old implementation, this lead to an infinite loop (because coercion would put the base always back to P again...), and thus I added the check for the polynomial in the exponent.\n\nIn any case, I'm all for improving the code and first trying to deal with integers, and then with rationals afterwards. Nevertheless, I'd still just handle constant polynomials in the base on this ticket---but then, this could be extended easily.\n\nBenjamin",
    "created_at": "2016-03-09T20:08:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272759",
    "user": "behackl"
}
```

Hi Vincent!

Just to clarify the previous need for checking whether the exponent is a polynomial: in our previous approach, we were hoping for the coefficient ring to carry out the exponentiation, i.e. if we had

```
sage: P.<z> = QQ[]
sage: P(1/4)^(1/2)
1/2
```

then we would compute this by letting `QQ` do the exponentiation. However, in the doctest over at `rings/integer.pyx` we have something like

```
sage: P.<t> = QQ[]
sage: 2^t
```

With the old implementation, this lead to an infinite loop (because coercion would put the base always back to P again...), and thus I added the check for the polynomial in the exponent.

In any case, I'm all for improving the code and first trying to deal with integers, and then with rationals afterwards. Nevertheless, I'd still just handle constant polynomials in the base on this ticket---but then, this could be extended easily.

Benjamin



---

archive/issue_comments_272760.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-09T20:10:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272760",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272761.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-03-09T20:12:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272761",
    "user": "cheuberg"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_272762.json:
```json
{
    "body": "Problem found by patchbot was a stupid mistake, hopefully fixed now.",
    "created_at": "2016-03-09T20:12:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272762",
    "user": "cheuberg"
}
```

Problem found by patchbot was a stupid mistake, hopefully fixed now.



---

archive/issue_comments_272763.json:
```json
{
    "body": "Replying to [comment:18 vdelecroix]:\n> Let me be more precise then\n> {{{\n> def __pow__(self, exp):\n>     cdef long n\n>     try:\n>         n = exp\n>         # old code for integer exponent\n>     except TypeError:\n>         n = QQ.coerce(exp)\n>         # new code for rational exponent\n> }}}\n\nok, if you prefer it like that, we can probably do that.\n\n> > I need a quick fix for `R(1)^(1/2)`. If somebody has time to implement `((x+1)<sup>2)</sup>(1/2)` very soon, I'd be happy. I do not have time soon. However, I want to have the code associated with a recently submitted paper in 7.1.\n> \n> Are you sure there was a bug?\n\nDo you think that disallowing `R(1)^(1/2)` is the desired behaviour?\n\n> In Sage the integer 1 is *not* the 1 from ZZ[x] (though they are equal through coercion). Some softwares behave differently to that respect (e.g. GAP) where there is only one 1 which is an integer and not anything else. In Sage (but not in GAP) it is already the case that operations change with respect to the parents even if the objects are equal\n> {{{\n> sage: Zmod(10)(3) == 3\n> sage: Zmod(10)(5) == 5\n> sage: log(Zmod(10)(3))\n> 3\n> sage: log(Zmod(10)(5))\n> Traceback (most recent call last):\n> ...\n> ZeroDivisionError: Inverse does not exist.\n> }}}\n\nI have no idea how this is related to this problem, sorry.\n\n> \n> > Basically, this fix here simply branches to existing code.\n> > Computing `((x+1)<sup>2)</sup>(1/2)` needs new mathematical code (involving square free decomposition).\n> \n> Indeed. Your modifications obfuscate the code for only a very trivial case and a discutable behavior of powering with polynomials.\n\nIt might seem trivial to you, but it did cost me an hour while writing a paper because basically, asymptotic rings using polynomial rings as coefficient rings could not compute square roots, and, sorry, I need that.\n\n> \n> > Therefore, I propose to include this now on the basis that while this is not a perfect and definitive solution, it is better than the previous behaviour.\n> \n> Not sure it is better. Sage used to consider operations based on parents. Powers are of course a special type of operation and with some respect might be treated appart. But \"(polynomial)^(polynomial)\" is not well defined. And \"(polynomial)^(rational)\" is well defined in some situations (and to that respect, your code improves the current situation a little).\n\nThere was a discussion on sage-devel a few weeks ago. Every parent seems to have its own home-made logic about how to do coercion. Please do not try to fix that in this ticket.",
    "created_at": "2016-03-09T20:23:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272763",
    "user": "cheuberg"
}
```

Replying to [comment:18 vdelecroix]:
> Let me be more precise then
> {{{
> def __pow__(self, exp):
>     cdef long n
>     try:
>         n = exp
>         # old code for integer exponent
>     except TypeError:
>         n = QQ.coerce(exp)
>         # new code for rational exponent
> }}}

ok, if you prefer it like that, we can probably do that.

> > I need a quick fix for `R(1)^(1/2)`. If somebody has time to implement `((x+1)<sup>2)</sup>(1/2)` very soon, I'd be happy. I do not have time soon. However, I want to have the code associated with a recently submitted paper in 7.1.
> 
> Are you sure there was a bug?

Do you think that disallowing `R(1)^(1/2)` is the desired behaviour?

> In Sage the integer 1 is *not* the 1 from ZZ[x] (though they are equal through coercion). Some softwares behave differently to that respect (e.g. GAP) where there is only one 1 which is an integer and not anything else. In Sage (but not in GAP) it is already the case that operations change with respect to the parents even if the objects are equal
> {{{
> sage: Zmod(10)(3) == 3
> sage: Zmod(10)(5) == 5
> sage: log(Zmod(10)(3))
> 3
> sage: log(Zmod(10)(5))
> Traceback (most recent call last):
> ...
> ZeroDivisionError: Inverse does not exist.
> }}}

I have no idea how this is related to this problem, sorry.

> 
> > Basically, this fix here simply branches to existing code.
> > Computing `((x+1)<sup>2)</sup>(1/2)` needs new mathematical code (involving square free decomposition).
> 
> Indeed. Your modifications obfuscate the code for only a very trivial case and a discutable behavior of powering with polynomials.

It might seem trivial to you, but it did cost me an hour while writing a paper because basically, asymptotic rings using polynomial rings as coefficient rings could not compute square roots, and, sorry, I need that.

> 
> > Therefore, I propose to include this now on the basis that while this is not a perfect and definitive solution, it is better than the previous behaviour.
> 
> Not sure it is better. Sage used to consider operations based on parents. Powers are of course a special type of operation and with some respect might be treated appart. But "(polynomial)^(polynomial)" is not well defined. And "(polynomial)^(rational)" is well defined in some situations (and to that respect, your code improves the current situation a little).

There was a discussion on sage-devel a few weeks ago. Every parent seems to have its own home-made logic about how to do coercion. Please do not try to fix that in this ticket.



---

archive/issue_comments_272764.json:
```json
{
    "body": "Replying to [comment:24 cheuberg]:\n> >\n> > [... snip ...]\n> >\n\n> There was a discussion on sage-devel a few weeks ago. Every parent seems to have its own home-made logic about how to do coercion. Please do not try to fix that in this ticket.\n\nPlease do not try to complicate it in this ticket either. A possible solution could be:\n- allow `polynomial^rational` as much as we can (i.e. for some constant polynomials for the sake of this ticket). For more general polynomial we can for now raise a `NotImplementedError`.\n- disallow `polynomial^polynomial` even if the power is a constant polynomial. In that case, the error should be a `TypeError`. This is the current behavior for some polynomial rings but not all\n\n```\nsage: ZZ['x'].gen() ** ZZ['x'].one()\n -> TypeError\nsage: QQ['x'].gen() ** ZZ['x'].one()\n -> TypeError\nsage: RR['x'].gen() ** ZZ['x'].one()\nx\n```\n\n\nWhat do you think? Would that solution fit your needs?\n\nVincent",
    "created_at": "2016-03-10T02:23:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272764",
    "user": "vdelecroix"
}
```

Replying to [comment:24 cheuberg]:
> >
> > [... snip ...]
> >

> There was a discussion on sage-devel a few weeks ago. Every parent seems to have its own home-made logic about how to do coercion. Please do not try to fix that in this ticket.

Please do not try to complicate it in this ticket either. A possible solution could be:
- allow `polynomial^rational` as much as we can (i.e. for some constant polynomials for the sake of this ticket). For more general polynomial we can for now raise a `NotImplementedError`.
- disallow `polynomial^polynomial` even if the power is a constant polynomial. In that case, the error should be a `TypeError`. This is the current behavior for some polynomial rings but not all

```
sage: ZZ['x'].gen() ** ZZ['x'].one()
 -> TypeError
sage: QQ['x'].gen() ** ZZ['x'].one()
 -> TypeError
sage: RR['x'].gen() ** ZZ['x'].one()
x
```


What do you think? Would that solution fit your needs?

Vincent



---

archive/issue_comments_272765.json:
```json
{
    "body": "Replying to [comment:25 vdelecroix]:\n> A possible solution could be:\n>  - allow `polynomial^rational` as much as we can (i.e. for some constant polynomials for the sake of this ticket). For more general polynomial we can for now raise a `NotImplementedError`.\n>  - disallow `polynomial^polynomial` even if the power is a constant polynomial. In that case, the error should be a `TypeError`. This is the current behavior for some polynomial rings but not all\n> {{{\n> sage: ZZ['x'].gen() ** ZZ['x'].one()\n>  -> TypeError\n> sage: QQ['x'].gen() ** ZZ['x'].one()\n>  -> TypeError\n> sage: RR['x'].gen() ** ZZ['x'].one()\n> x\n> }}}\n> \n> What do you think? Would that solution fit your needs?\n\nAs far as I can see without implementing it and `make ptestlong`, this fits perfectly.",
    "created_at": "2016-03-10T05:31:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272765",
    "user": "cheuberg"
}
```

Replying to [comment:25 vdelecroix]:
> A possible solution could be:
>  - allow `polynomial^rational` as much as we can (i.e. for some constant polynomials for the sake of this ticket). For more general polynomial we can for now raise a `NotImplementedError`.
>  - disallow `polynomial^polynomial` even if the power is a constant polynomial. In that case, the error should be a `TypeError`. This is the current behavior for some polynomial rings but not all
> {{{
> sage: ZZ['x'].gen() ** ZZ['x'].one()
>  -> TypeError
> sage: QQ['x'].gen() ** ZZ['x'].one()
>  -> TypeError
> sage: RR['x'].gen() ** ZZ['x'].one()
> x
> }}}
> 
> What do you think? Would that solution fit your needs?

As far as I can see without implementing it and `make ptestlong`, this fits perfectly.



---

archive/issue_comments_272766.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-10T06:19:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272766",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272767.json:
```json
{
    "body": "This is now refactored as a try/expect block; polynomial exponents are now disallowed.\n\nI am not completely comfortable with the long block wrapped within `try`/`expect` because I am not sure that we catch the correct `TypeError`. What do you think about that?",
    "created_at": "2016-03-10T06:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272767",
    "user": "cheuberg"
}
```

This is now refactored as a try/expect block; polynomial exponents are now disallowed.

I am not completely comfortable with the long block wrapped within `try`/`expect` because I am not sure that we catch the correct `TypeError`. What do you think about that?



---

archive/issue_comments_272768.json:
```json
{
    "body": "Replying to [comment:28 cheuberg]:\n> This is now refactored as a try/expect block; polynomial exponents are now disallowed.\n\nThanks.\n\n> I am not completely comfortable with the long block wrapped within `try`/`expect` because I am not sure that we catch the correct `TypeError`. What do you think about that?\n\nRight. It is better to avoid long `try/except`. One possibility is\n\n```\ntry:\n    nn = pyobject_to_long(exp)\nexcept TypeError:\n    # rational code\nelse:\n    # integer code\n```\n",
    "created_at": "2016-03-10T13:26:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272768",
    "user": "vdelecroix"
}
```

Replying to [comment:28 cheuberg]:
> This is now refactored as a try/expect block; polynomial exponents are now disallowed.

Thanks.

> I am not completely comfortable with the long block wrapped within `try`/`expect` because I am not sure that we catch the correct `TypeError`. What do you think about that?

Right. It is better to avoid long `try/except`. One possibility is

```
try:
    nn = pyobject_to_long(exp)
except TypeError:
    # rational code
else:
    # integer code
```




---

archive/issue_comments_272769.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-10T13:45:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272769",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272770.json:
```json
{
    "body": "Replying to [comment:29 vdelecroix]:\n> Right. It is better to avoid long `try/except`. One possibility is\n> {{{\n> try:\n>     nn = pyobject_to_long(exp)\n> except TypeError:\n>     # rational code\n> else:\n>     # integer code\n> }}}\ndone.",
    "created_at": "2016-03-10T13:46:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272770",
    "user": "cheuberg"
}
```

Replying to [comment:29 vdelecroix]:
> Right. It is better to avoid long `try/except`. One possibility is
> {{{
> try:
>     nn = pyobject_to_long(exp)
> except TypeError:
>     # rational code
> else:
>     # integer code
> }}}
done.



---

archive/issue_comments_272771.json:
```json
{
    "body": "I implemented a generic `nth_root` method and used it...\n----\nNew commits:",
    "created_at": "2016-03-11T15:45:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272771",
    "user": "vdelecroix"
}
```

I implemented a generic `nth_root` method and used it...
----
New commits:



---

archive/issue_comments_272772.json:
```json
{
    "body": "Though, since `num` and `den` are relatively prime it should be cheaper to do `self.nth_root(den) ** num` instead of `(self ** num).nth_root(den)`... I will think about it.\n\nAnyway, it would be good to see whether it works for other polynomial rings. For example `QQbar['x']` or when the base ring is a number field or a finite field...",
    "created_at": "2016-03-11T15:49:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272772",
    "user": "vdelecroix"
}
```

Though, since `num` and `den` are relatively prime it should be cheaper to do `self.nth_root(den) ** num` instead of `(self ** num).nth_root(den)`... I will think about it.

Anyway, it would be good to see whether it works for other polynomial rings. For example `QQbar['x']` or when the base ring is a number field or a finite field...



---

archive/issue_comments_272773.json:
```json
{
    "body": "When the polynomial is of degree 0 it would also be faster to actually also relies on `nth_root`:\n\n```\nsage: %timeit 27.nth_root(3)\n1000000 loops, best of 3: 388 ns per loop\nsage: %timeit 27 ** (1/3)\n100000 loops, best of 3: 7.51 \u00b5s per loop\n```\n\nAs `nth_root` should be guaranteed to return an element of the same ring there will also be much less coercion involved.",
    "created_at": "2016-03-11T15:53:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272773",
    "user": "vdelecroix"
}
```

When the polynomial is of degree 0 it would also be faster to actually also relies on `nth_root`:

```
sage: %timeit 27.nth_root(3)
1000000 loops, best of 3: 388 ns per loop
sage: %timeit 27 ** (1/3)
100000 loops, best of 3: 7.51 µs per loop
```

As `nth_root` should be guaranteed to return an element of the same ring there will also be much less coercion involved.



---

archive/issue_comments_272774.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-11T15:59:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272774",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272775.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-11T17:21:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272775",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272776.json:
```json
{
    "body": "Hi! I've reviewed this refactored implementation (thanks for implementing it!), and everything looks good to me.\n\nI've added a small reviewer commit; please cross-review and set to `positive_review` if you are satisfied.\n----\nNew commits:",
    "created_at": "2016-03-29T02:20:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272776",
    "user": "behackl"
}
```

Hi! I've reviewed this refactored implementation (thanks for implementing it!), and everything looks good to me.

I've added a small reviewer commit; please cross-review and set to `positive_review` if you are satisfied.
----
New commits:



---

archive/issue_comments_272777.json:
```json
{
    "body": "Nope. This is actually working because of a bug see #20214  ;-(. What I wrote in the generic `nth_root` should always be an infinite loop (because of `u.nth_root(n)`).\n\nOne possibility:\n\n- make it work when `u.is_one()` is `True` (or more generally when `u.multiplicative_order()` is finite)\n- raise an error if `u` is not in the above case and there are some non trivial factors\n\nThe aim of the second item is that in children classes (like polynomials) you might want to do\n\n```\ndef nth_root(self, n):\n    if self.degree() <= 0:\n        # factorize unit using base ring method\n        XXX\n    else:\n        return super(XXX).nth_root(self, n)\n```\n",
    "created_at": "2016-03-29T02:44:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272777",
    "user": "vdelecroix"
}
```

Nope. This is actually working because of a bug see #20214  ;-(. What I wrote in the generic `nth_root` should always be an infinite loop (because of `u.nth_root(n)`).

One possibility:

- make it work when `u.is_one()` is `True` (or more generally when `u.multiplicative_order()` is finite)
- raise an error if `u` is not in the above case and there are some non trivial factors

The aim of the second item is that in children classes (like polynomials) you might want to do

```
def nth_root(self, n):
    if self.degree() <= 0:
        # factorize unit using base ring method
        XXX
    else:
        return super(XXX).nth_root(self, n)
```




---

archive/issue_comments_272778.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-03-29T02:44:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272778",
    "user": "vdelecroix"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_272779.json:
```json
{
    "body": "Well, wouldn't it be more natural to let the unit be an element of the base ring? (As far as I see the parent of the unit of polynomials over QQ always is from QQ, for example.)\n\nOf course, we can also add checks like if `u` is one etc., but with this ticket only polynomial rings over the rationals and the integers use this method---and both of them have implemented a `nth_root` method; this is why I still think that this would be good to go and why special treatment isn't needed. And the inconsistency mentioned in #20214 only introduces a recursion of depth 2, which would be resolved if the `unit` method would behave for integers like for rationals.\n\nIt isn't even necessary to separately implement `nth_root` for polynomials such that the case of constant polynomials is handled by the base ring: over `ZZ`, the overall coefficient is decomposed w.r.t. PFD and handled like a non-constant polynomial (which is what I would have implemented in the base ring as well). For QQ, the overall factor is in the unit and handled separately in the `nth_root` method.\n\nLetting other polynomial rings profit from this procedure should be realized in a follow-up ticket, IMHO.\n\nHowever, what should be added before this ships is a special treatment of the zero polynomial. I'll push this in a minute.",
    "created_at": "2016-03-29T07:55:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272779",
    "user": "behackl"
}
```

Well, wouldn't it be more natural to let the unit be an element of the base ring? (As far as I see the parent of the unit of polynomials over QQ always is from QQ, for example.)

Of course, we can also add checks like if `u` is one etc., but with this ticket only polynomial rings over the rationals and the integers use this method---and both of them have implemented a `nth_root` method; this is why I still think that this would be good to go and why special treatment isn't needed. And the inconsistency mentioned in #20214 only introduces a recursion of depth 2, which would be resolved if the `unit` method would behave for integers like for rationals.

It isn't even necessary to separately implement `nth_root` for polynomials such that the case of constant polynomials is handled by the base ring: over `ZZ`, the overall coefficient is decomposed w.r.t. PFD and handled like a non-constant polynomial (which is what I would have implemented in the base ring as well). For QQ, the overall factor is in the unit and handled separately in the `nth_root` method.

Letting other polynomial rings profit from this procedure should be realized in a follow-up ticket, IMHO.

However, what should be added before this ships is a special treatment of the zero polynomial. I'll push this in a minute.



---

archive/issue_comments_272780.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-03-29T08:11:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272780",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272781.json:
```json
{
    "body": "... any new thoughts on this?",
    "created_at": "2016-04-18T14:57:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272781",
    "user": "behackl"
}
```

... any new thoughts on this?



---

archive/issue_comments_272782.json:
```json
{
    "body": "Replying to [comment:42 behackl]:\n> ... any new thoughts on this?\n\nI would very much like to have this in `7.2`, because I/we need it for a paper we have written. Thus I'd like to discuss this once again:\n\nIIRC the possibly infinite recursion could be avoided altogether if we would convert the unit `f.unit()` to the corresponding base ring. This wouldn't require any additional fix for the units, and the code affects only `ZZ[]` and `QQ[]` anyway, so I'm rather sure that it works.\n\nAny objections to this approach?",
    "created_at": "2016-04-30T16:17:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272782",
    "user": "behackl"
}
```

Replying to [comment:42 behackl]:
> ... any new thoughts on this?

I would very much like to have this in `7.2`, because I/we need it for a paper we have written. Thus I'd like to discuss this once again:

IIRC the possibly infinite recursion could be avoided altogether if we would convert the unit `f.unit()` to the corresponding base ring. This wouldn't require any additional fix for the units, and the code affects only `ZZ[]` and `QQ[]` anyway, so I'm rather sure that it works.

Any objections to this approach?



---

archive/issue_comments_272783.json:
```json
{
    "body": "Changing status from needs_work to needs_info.",
    "created_at": "2016-04-30T16:17:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272783",
    "user": "behackl"
}
```

Changing status from needs_work to needs_info.



---

archive/issue_comments_272784.json:
```json
{
    "body": "It is fine for me if you modify the generic `nth_root` to\n\n```\nu = f.unit()\nif u.is_one():\n    # do nothing\nelif self.parent() != self.base_ring():\n    # try to factorize the unit in the base ring\nelse:\n    # raise a NotImplementedError\n```\n\n\nEDIT: small modif in the code `self != self.base_ring()` -> `self.parent() != self.base_ring()`",
    "created_at": "2016-04-30T18:33:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272784",
    "user": "vdelecroix"
}
```

It is fine for me if you modify the generic `nth_root` to

```
u = f.unit()
if u.is_one():
    # do nothing
elif self.parent() != self.base_ring():
    # try to factorize the unit in the base ring
else:
    # raise a NotImplementedError
```


EDIT: small modif in the code `self != self.base_ring()` -> `self.parent() != self.base_ring()`



---

archive/issue_comments_272785.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-04-30T23:47:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272785",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272786.json:
```json
{
    "body": "Replying to [comment:44 vdelecroix]:\n> It is fine for me if you modify the generic `nth_root` to\n> {{{\n> u = f.unit()\n> if u.is_one():\n>     # do nothing\n> elif self.parent() != self.base_ring():\n>     # try to factorize the unit in the base ring\n> else:\n>     # raise a NotImplementedError\n> }}}\n> \n> EDIT: small modif in the code `self != self.base_ring()` -> `self.parent() != self.base_ring()`\n\nThanks for the suggestion! I've pushed some changes such that the unit is handled with more care. Apart from that, I've reviewed the documentation changes and doctests already in the past, this is still fine for me. Please cross-review. :-)",
    "created_at": "2016-04-30T23:53:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272786",
    "user": "behackl"
}
```

Replying to [comment:44 vdelecroix]:
> It is fine for me if you modify the generic `nth_root` to
> {{{
> u = f.unit()
> if u.is_one():
>     # do nothing
> elif self.parent() != self.base_ring():
>     # try to factorize the unit in the base ring
> else:
>     # raise a NotImplementedError
> }}}
> 
> EDIT: small modif in the code `self != self.base_ring()` -> `self.parent() != self.base_ring()`

Thanks for the suggestion! I've pushed some changes such that the unit is handled with more care. Apart from that, I've reviewed the documentation changes and doctests already in the past, this is still fine for me. Please cross-review. :-)



---

archive/issue_comments_272787.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2016-04-30T23:53:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272787",
    "user": "behackl"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_272788.json:
```json
{
    "body": "With\n\n```\nif u.parent() != u.base_ring():\n    u = u.base_ring(u)\n\ntry:\n    ans = u.nth_root(n)\nexcept AttributeError:\n    raise NotImplementedError(...)\n```\n\nYou have a risk of infinite recursion. You should use `nth_root` of `u` only if `u.parent()` is not `self.parent()` anymore.",
    "created_at": "2016-05-01T03:54:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272788",
    "user": "vdelecroix"
}
```

With

```
if u.parent() != u.base_ring():
    u = u.base_ring(u)

try:
    ans = u.nth_root(n)
except AttributeError:
    raise NotImplementedError(...)
```

You have a risk of infinite recursion. You should use `nth_root` of `u` only if `u.parent()` is not `self.parent()` anymore.



---

archive/issue_comments_272789.json:
```json
{
    "body": "Moreover, it is not always possible to do `u = u.base_ring(u)` (even for units).",
    "created_at": "2016-05-01T03:55:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272789",
    "user": "vdelecroix"
}
```

Moreover, it is not always possible to do `u = u.base_ring(u)` (even for units).



---

archive/issue_comments_272790.json:
```json
{
    "body": "I added a commit to fix the issues I mentioned. As a reviewer, I think that the code lacks example. It currently only tests `ZZ[x]` but is intended to work for any unique factorization domain...\n----\nLast 10 new commits:",
    "created_at": "2016-05-01T04:28:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272790",
    "user": "vdelecroix"
}
```

I added a commit to fix the issues I mentioned. As a reviewer, I think that the code lacks example. It currently only tests `ZZ[x]` but is intended to work for any unique factorization domain...
----
Last 10 new commits:



---

archive/issue_comments_272791.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-01T10:17:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272791",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272792.json:
```json
{
    "body": "Replying to [comment:50 vdelecroix]:\n> I added a commit to fix the issues I mentioned. As a reviewer, I think that the code lacks example. It currently only tests `ZZ[x]` but is intended to work for any unique factorization domain...\n\nI wasn't too happy with the repeated `if` and `raise` statements, so I tried to clean that up a bit. Also, I've added doctests for `QQ[x]`, multivariate polynomial rings, and the number field in `x^2 - 2`. Does anything more exotic come to your mind that you would like to have tested as well?",
    "created_at": "2016-05-01T10:22:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272792",
    "user": "behackl"
}
```

Replying to [comment:50 vdelecroix]:
> I added a commit to fix the issues I mentioned. As a reviewer, I think that the code lacks example. It currently only tests `ZZ[x]` but is intended to work for any unique factorization domain...

I wasn't too happy with the repeated `if` and `raise` statements, so I tried to clean that up a bit. Also, I've added doctests for `QQ[x]`, multivariate polynomial rings, and the number field in `x^2 - 2`. Does anything more exotic come to your mind that you would like to have tested as well?



---

archive/issue_comments_272793.json:
```json
{
    "body": "Would be nice to have a non polynomial examples. But currently, order in number fields does not know whether they are principal ideal domain or unique factorization domain\n\n```\nsage: R = ZZ[I]\nsage: R in PrincipalIdealDomains()\nFalse\nsage: R in UniqueFactorizationDomains()\nFalse\n```\n\n\nIn `__pow__` for integer polynomials, in the case the exponent is an integer you should only use `nn` and not `exp` (i.e. you should replace `if exp == 0` and `if exp < 0` by `if nn == 0` and `nn < 0`).",
    "created_at": "2016-05-01T13:09:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272793",
    "user": "vdelecroix"
}
```

Would be nice to have a non polynomial examples. But currently, order in number fields does not know whether they are principal ideal domain or unique factorization domain

```
sage: R = ZZ[I]
sage: R in PrincipalIdealDomains()
False
sage: R in UniqueFactorizationDomains()
False
```


In `__pow__` for integer polynomials, in the case the exponent is an integer you should only use `nn` and not `exp` (i.e. you should replace `if exp == 0` and `if exp < 0` by `if nn == 0` and `nn < 0`).



---

archive/issue_comments_272794.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-01T13:29:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272794",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272795.json:
```json
{
    "body": "Replying to [comment:53 vdelecroix]:\n> Would be nice to have a non polynomial examples. But currently, order in number fields does not know whether they are principal ideal domain or unique factorization domain\n> {{{\n> sage: R = ZZ[I]\n> sage: R in PrincipalIdealDomains()\n> False\n> sage: R in UniqueFactorizationDomains()\n> False\n> }}}\n> \n\nYes, the gaussian integers were also my first idea for such an example, but getting this to work should rather be a follow-up ticket.\n\n> In `__pow__` for integer polynomials, in the case the exponent is an integer you should only use `nn` and not `exp` (i.e. you should replace `if exp == 0` and `if exp < 0` by `if nn == 0` and `nn < 0`).\n\nMakes sense. Done.",
    "created_at": "2016-05-01T13:37:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272795",
    "user": "behackl"
}
```

Replying to [comment:53 vdelecroix]:
> Would be nice to have a non polynomial examples. But currently, order in number fields does not know whether they are principal ideal domain or unique factorization domain
> {{{
> sage: R = ZZ[I]
> sage: R in PrincipalIdealDomains()
> False
> sage: R in UniqueFactorizationDomains()
> False
> }}}
> 

Yes, the gaussian integers were also my first idea for such an example, but getting this to work should rather be a follow-up ticket.

> In `__pow__` for integer polynomials, in the case the exponent is an integer you should only use `nn` and not `exp` (i.e. you should replace `if exp == 0` and `if exp < 0` by `if nn == 0` and `nn < 0`).

Makes sense. Done.



---

archive/issue_comments_272796.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-05-01T15:55:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272796",
    "user": "vdelecroix"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_272797.json:
```json
{
    "body": "Enough to go!",
    "created_at": "2016-05-01T15:55:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272797",
    "user": "vdelecroix"
}
```

Enough to go!



---

archive/issue_comments_272798.json:
```json
{
    "body": "Replying to [comment:56 vdelecroix]:\n> Enough to go!\n\nThanks for this final sprint! Now I can sleep a bit better... ;-)",
    "created_at": "2016-05-01T16:02:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272798",
    "user": "behackl"
}
```

Replying to [comment:56 vdelecroix]:
> Enough to go!

Thanks for this final sprint! Now I can sleep a bit better... ;-)



---

archive/issue_comments_272799.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2016-05-01T16:18:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272799",
    "user": "nbruin"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_272800.json:
```json
{
    "body": "Taking an n-th root of an element in a ring R by computing a factorization is an insane way to go about it. A much better generic strategy is to hope that the univariate polynomial ring over R has a root finding algorithm and see if the polynomial `x^n-a` has a root. You will see that:\n- it actually has a decent performance over QQ (although there the algorithm should really be special-cased)\n- it will work over most fields, including the ones that are not constructed as fraction fields of rings with a factorization algorithm.\n- you don't have to mess around with the unit part that a factorization algorithm probably won't recognize.\n\nIllustration:\n\n```\nsage: a=next_prime(10^10)*next_prime(10^11)\nsage: b=a^2\nsage: %timeit (R.0^2-b).roots()\n1000 loops, best of 3: 428 \u00b5s per loop\nsage: %timeit b.factor()\n100 loops, best of 3: 3.68 ms per loop\n```\n\n\n```\nsage: k.<r>=NumberField(x^2+5)\nsage: b=k(7^2)\nsage: (k['x'].0^2-b).roots()\n[(7, 1), (-7, 1)]\nsage: factor(b) #doesn't work of course\n```\n",
    "created_at": "2016-05-01T16:18:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272800",
    "user": "nbruin"
}
```

Taking an n-th root of an element in a ring R by computing a factorization is an insane way to go about it. A much better generic strategy is to hope that the univariate polynomial ring over R has a root finding algorithm and see if the polynomial `x^n-a` has a root. You will see that:
- it actually has a decent performance over QQ (although there the algorithm should really be special-cased)
- it will work over most fields, including the ones that are not constructed as fraction fields of rings with a factorization algorithm.
- you don't have to mess around with the unit part that a factorization algorithm probably won't recognize.

Illustration:

```
sage: a=next_prime(10^10)*next_prime(10^11)
sage: b=a^2
sage: %timeit (R.0^2-b).roots()
1000 loops, best of 3: 428 µs per loop
sage: %timeit b.factor()
100 loops, best of 3: 3.68 ms per loop
```


```
sage: k.<r>=NumberField(x^2+5)
sage: b=k(7^2)
sage: (k['x'].0^2-b).roots()
[(7, 1), (-7, 1)]
sage: factor(b) #doesn't work of course
```




---

archive/issue_comments_272801.json:
```json
{
    "body": "Replying to [comment:58 nbruin]:\n> Taking an n-th root of an element in a ring R by computing a factorization is an insane way to go about it. A much better generic strategy is to hope that the univariate polynomial ring over R has a root finding algorithm and see if the polynomial `x^n-a` has a root. You will see that:\n> - it actually has a decent performance over QQ (although there the algorithm should really be special-cases)\n> - it will work over most fields, including the ones that are not constructed as fraction fields of rings with a factorization algorithm.\n> - you don't have to mess around with the unit part that a factorization algorithm probably won't recognize.\n\nWhile I like the general idea of this approach, I'm for discussing it on a follow-up ticket; see it as a \"performance enhancement\" of this implementation. Also, I'm not sure how exactly the root-finding algorithm for these univariate polynomial rings can be properly motivated, for me neither `roots()` nor `any_root()` did the job:\n\n\n```\nsage: R.<x> = QQ[]\nsage: P.<X> = R[]\nsage: a = X^2 - (x^2 + 2*x + 1)\nsage: a.any_root(R)\nTraceback (most recent call last):\n...\nTypeError: Unable to coerce Principal ideal (1) of Univariate Polynomial Ring in x over Rational Field (<class 'sage.rings.polynomial.ideal.Ideal_1poly_field'>) to Rational\n```\n\n\nDo you strongly object against setting this back to `positive_review`?",
    "created_at": "2016-05-01T16:55:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272801",
    "user": "behackl"
}
```

Replying to [comment:58 nbruin]:
> Taking an n-th root of an element in a ring R by computing a factorization is an insane way to go about it. A much better generic strategy is to hope that the univariate polynomial ring over R has a root finding algorithm and see if the polynomial `x^n-a` has a root. You will see that:
> - it actually has a decent performance over QQ (although there the algorithm should really be special-cases)
> - it will work over most fields, including the ones that are not constructed as fraction fields of rings with a factorization algorithm.
> - you don't have to mess around with the unit part that a factorization algorithm probably won't recognize.

While I like the general idea of this approach, I'm for discussing it on a follow-up ticket; see it as a "performance enhancement" of this implementation. Also, I'm not sure how exactly the root-finding algorithm for these univariate polynomial rings can be properly motivated, for me neither `roots()` nor `any_root()` did the job:


```
sage: R.<x> = QQ[]
sage: P.<X> = R[]
sage: a = X^2 - (x^2 + 2*x + 1)
sage: a.any_root(R)
Traceback (most recent call last):
...
TypeError: Unable to coerce Principal ideal (1) of Univariate Polynomial Ring in x over Rational Field (<class 'sage.rings.polynomial.ideal.Ideal_1poly_field'>) to Rational
```


Do you strongly object against setting this back to `positive_review`?



---

archive/issue_comments_272802.json:
```json
{
    "body": "Replying to [comment:59 behackl]:\n> Do you strongly object against setting this back to `positive_review`?\nYes, because it is parking code in the wrong spot.\n\nPerhaps park your code on `sage.rings.polynomial.polynomial_element.Polynomial`? Taking an n-th root of a polynomial via factorization isn't quite as bad as in general.\n\nSince `NumberFieldElement` etc. already provides an `nth_root` method, it may be sufficient to just provide the method on Polynomial.",
    "created_at": "2016-05-02T04:42:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272802",
    "user": "nbruin"
}
```

Replying to [comment:59 behackl]:
> Do you strongly object against setting this back to `positive_review`?
Yes, because it is parking code in the wrong spot.

Perhaps park your code on `sage.rings.polynomial.polynomial_element.Polynomial`? Taking an n-th root of a polynomial via factorization isn't quite as bad as in general.

Since `NumberFieldElement` etc. already provides an `nth_root` method, it may be sufficient to just provide the method on Polynomial.



---

archive/issue_comments_272803.json:
```json
{
    "body": "Replying to [comment:60 nbruin]:\n> Replying to [comment:59 behackl]:\n> > Do you strongly object against setting this back to `positive_review`?\n> Yes, because it is parking code in the wrong spot.\n> \n\nI was hoping for a comment from Vincent, as he started with the generic solution on this branch.\n\nIn any case: I do not quite understand why this would be in the wrong place. Unique factorization domains should provide a `factor`-method, and providing a generic `nth_root` method for them doesn't strike me as bad.\n\nIt might be true that this ticket only changes the behavior of polynomial rings, but I don't see a downside of providing a generic solution. But maybe I'm missing something? :-)\n\n> Perhaps park your code on `sage.rings.polynomial.polynomial_element.Polynomial`? Taking an n-th root of a polynomial via factorization isn't quite as bad as in general.\n> \n> Since `NumberFieldElement` etc. already provides an `nth_root` method, it may be sufficient to just provide the method on Polynomial.\n\nYes, that is true---however, I think that the code provided on this ticket is generic enough to work for all unique factorization domains. Or doesn't it? Even if it might be not performant, I think that a generic approach is certainly allowed to be slow---this problem can be handled by special case implementations.\n\nI just don't see a benefit from moving the code back to polynomials only. Could you elaborate more why this generic solution should be degraded to a special case?",
    "created_at": "2016-05-02T18:51:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272803",
    "user": "behackl"
}
```

Replying to [comment:60 nbruin]:
> Replying to [comment:59 behackl]:
> > Do you strongly object against setting this back to `positive_review`?
> Yes, because it is parking code in the wrong spot.
> 

I was hoping for a comment from Vincent, as he started with the generic solution on this branch.

In any case: I do not quite understand why this would be in the wrong place. Unique factorization domains should provide a `factor`-method, and providing a generic `nth_root` method for them doesn't strike me as bad.

It might be true that this ticket only changes the behavior of polynomial rings, but I don't see a downside of providing a generic solution. But maybe I'm missing something? :-)

> Perhaps park your code on `sage.rings.polynomial.polynomial_element.Polynomial`? Taking an n-th root of a polynomial via factorization isn't quite as bad as in general.
> 
> Since `NumberFieldElement` etc. already provides an `nth_root` method, it may be sufficient to just provide the method on Polynomial.

Yes, that is true---however, I think that the code provided on this ticket is generic enough to work for all unique factorization domains. Or doesn't it? Even if it might be not performant, I think that a generic approach is certainly allowed to be slow---this problem can be handled by special case implementations.

I just don't see a benefit from moving the code back to polynomials only. Could you elaborate more why this generic solution should be degraded to a special case?



---

archive/issue_comments_272804.json:
```json
{
    "body": "The code provided is far to be working on any UFD as you have to factor the unit! But we know for sure that it will work for polynomial rings whose base ring provides a `nth_root` method. It would make sense to move the code to generic polynomial. As there is not a lot of examples of UFD in Sage it is hard to say that this code is useful for general UFD.",
    "created_at": "2016-05-02T19:00:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272804",
    "user": "vdelecroix"
}
```

The code provided is far to be working on any UFD as you have to factor the unit! But we know for sure that it will work for polynomial rings whose base ring provides a `nth_root` method. It would make sense to move the code to generic polynomial. As there is not a lot of examples of UFD in Sage it is hard to say that this code is useful for general UFD.



---

archive/issue_comments_272805.json:
```json
{
    "body": "Replying to [comment:62 vdelecroix]:\n> The code provided is far to be working on any UFD as you have to factor the unit! \n\nI might still be thinking too much of polynomial rings when thinking of UFDs. ;-)\n\n> But we know for sure that it will work for polynomial rings whose base ring provides a `nth_root` method. It would make sense to move the code to generic polynomial. \n\nThe argument regarding the unit and the fact that there are not that much (exotic) UFDs implemented in Sage convice me; thanks for the clarification! :-) I'll move the code.",
    "created_at": "2016-05-02T19:08:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272805",
    "user": "behackl"
}
```

Replying to [comment:62 vdelecroix]:
> The code provided is far to be working on any UFD as you have to factor the unit! 

I might still be thinking too much of polynomial rings when thinking of UFDs. ;-)

> But we know for sure that it will work for polynomial rings whose base ring provides a `nth_root` method. It would make sense to move the code to generic polynomial. 

The argument regarding the unit and the fact that there are not that much (exotic) UFDs implemented in Sage convice me; thanks for the clarification! :-) I'll move the code.



---

archive/issue_comments_272806.json:
```json
{
    "body": "Changing status from needs_info to needs_work.",
    "created_at": "2016-05-02T19:08:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272806",
    "user": "behackl"
}
```

Changing status from needs_info to needs_work.



---

archive/issue_comments_272807.json:
```json
{
    "body": "Moving the code to `sage.rings.polynomial.polynomial_element.Polynomial` only provides `nth_root` for univariate polynomial rings, as it seems. The doctests for multivariate rings fail with\n\n\n```\nAttributeError: 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular' object has no attribute 'nth_root'\n```\n\n\nI'm not a particularly big fried of copying the code to `sage.rings.polynomial.multi_polynomial_element.MPolynomial_element` as well. The univariate and multivariate polynomial ring elements inherit from CommutativeAlgebraelement and CommutativeRingElement, respectively---so implementing it in a superclass is not possible.\n\nIdeas?",
    "created_at": "2016-05-02T19:33:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272807",
    "user": "behackl"
}
```

Moving the code to `sage.rings.polynomial.polynomial_element.Polynomial` only provides `nth_root` for univariate polynomial rings, as it seems. The doctests for multivariate rings fail with


```
AttributeError: 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular' object has no attribute 'nth_root'
```


I'm not a particularly big fried of copying the code to `sage.rings.polynomial.multi_polynomial_element.MPolynomial_element` as well. The univariate and multivariate polynomial ring elements inherit from CommutativeAlgebraelement and CommutativeRingElement, respectively---so implementing it in a superclass is not possible.

Ideas?



---

archive/issue_comments_272808.json:
```json
{
    "body": "Replying to [comment:64 behackl]:\n> Ideas?\n\n- Leave the code in `categories.unique_factorization_domain`, raise a `NotImplementedError` ...\n  - ... if something goes wrong (current behavior), or \n  - ... when the calling parent is not a polynomial ring (that seems relatively restrictive to me)\n- Move it to either univariate or multivariate polynomials, call the same method from the other one (I'm thinking of something like `nth_root = sage.rings.polynomial.polynomial_element.nth_root` or so...)\n- Move it to both univaraite and multivariate polynomial rings\n\nI'll try to do the second one and push the branch again, let me know if you feel that there is a better solution.",
    "created_at": "2016-05-03T07:42:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272808",
    "user": "behackl"
}
```

Replying to [comment:64 behackl]:
> Ideas?

- Leave the code in `categories.unique_factorization_domain`, raise a `NotImplementedError` ...
  - ... if something goes wrong (current behavior), or 
  - ... when the calling parent is not a polynomial ring (that seems relatively restrictive to me)
- Move it to either univariate or multivariate polynomials, call the same method from the other one (I'm thinking of something like `nth_root = sage.rings.polynomial.polynomial_element.nth_root` or so...)
- Move it to both univaraite and multivariate polynomial rings

I'll try to do the second one and push the branch again, let me know if you feel that there is a better solution.



---

archive/issue_comments_272809.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-03T08:16:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272809",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272810.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-05-03T08:20:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272810",
    "user": "behackl"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_272811.json:
```json
{
    "body": "My attempt to implement the second strategy failed spectacularly with\n\n\n```\nTypeError: descriptor 'nth_root' for 'sage.rings.polynomial.polynomial_element.Polynomial' objects doesn't apply to 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular' object\n```\n\n\nso I've duplicated the code and adapted the doctests a bit.\n\nI'm not particularly happy with this solution, but I don't see a better one*. Suggestions are very welcome. Back to `needs_review` again...\n\n*EDIT: that doesn't live in `categories.unique_factorization_domains`. There seems to be nothing sufficiently in common between the univariate and multivariate polynomial rings.",
    "created_at": "2016-05-03T08:20:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272811",
    "user": "behackl"
}
```

My attempt to implement the second strategy failed spectacularly with


```
TypeError: descriptor 'nth_root' for 'sage.rings.polynomial.polynomial_element.Polynomial' objects doesn't apply to 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular' object
```


so I've duplicated the code and adapted the doctests a bit.

I'm not particularly happy with this solution, but I don't see a better one*. Suggestions are very welcome. Back to `needs_review` again...

*EDIT: that doesn't live in `categories.unique_factorization_domains`. There seems to be nothing sufficiently in common between the univariate and multivariate polynomial rings.



---

archive/issue_comments_272812.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-05T18:09:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272812",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272813.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-05T18:13:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272813",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272814.json:
```json
{
    "body": "I've added comments that there is a duplicated version of the code. Also, I've fixed the failing doctest.\n\nEven though we are too late for `7.2`, I'd still greatly appreciate if someone could review my last few changes. The code itself is already reviewed.",
    "created_at": "2016-05-05T18:24:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272814",
    "user": "behackl"
}
```

I've added comments that there is a duplicated version of the code. Also, I've fixed the failing doctest.

Even though we are too late for `7.2`, I'd still greatly appreciate if someone could review my last few changes. The code itself is already reviewed.



---

archive/issue_comments_272815.json:
```json
{
    "body": "Since now the code is in the polynomial ring you can simplify it a lot. Just remove all of\n\n```\nu = f.unit()\nif u.is_one():\n    ...\nelse:\n    ....\n```\n\nand do\n\n```\nu = self.base_ring()(f.unit())\ntry:\n    u.nth_root(n)\nexcept AttributeError:\n    raise NotImplementedError\n```\n",
    "created_at": "2016-05-06T11:54:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272815",
    "user": "vdelecroix"
}
```

Since now the code is in the polynomial ring you can simplify it a lot. Just remove all of

```
u = f.unit()
if u.is_one():
    ...
else:
    ....
```

and do

```
u = self.base_ring()(f.unit())
try:
    u.nth_root(n)
except AttributeError:
    raise NotImplementedError
```




---

archive/issue_comments_272816.json:
```json
{
    "body": "And if the degree is not divisible by `n` you already know that there is no n-th root (in multivariate case, degree=\"sum of degrees of monomials\"). This is very cheap to test.",
    "created_at": "2016-05-06T12:10:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272816",
    "user": "vdelecroix"
}
```

And if the degree is not divisible by `n` you already know that there is no n-th root (in multivariate case, degree="sum of degrees of monomials"). This is very cheap to test.



---

archive/issue_comments_272817.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-06T13:25:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272817",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272818.json:
```json
{
    "body": "Replying to [comment:73 git]:\n> Branch pushed to git repo; I updated commit sha1. New commits:\n> ||[753462d](http://git.sagemath.org/sage.git/commit/?id=753462d07465a87797609856bec781797da9a6b1)||`more refactoring after moving code to rings.polynomial`||\n\nSimplified the code and added the additional check for `self.degree() % n`.",
    "created_at": "2016-05-06T13:26:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272818",
    "user": "behackl"
}
```

Replying to [comment:73 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[753462d](http://git.sagemath.org/sage.git/commit/?id=753462d07465a87797609856bec781797da9a6b1)||`more refactoring after moving code to rings.polynomial`||

Simplified the code and added the additional check for `self.degree() % n`.



---

archive/issue_comments_272819.json:
```json
{
    "body": "Perhaps don't bother getting a grammatically correct ordinal. Note that the current code doesn't get it correct anyway: It's 21st, 22nd, 23rd.\n\nBetter to formulate the error message in a way that doesn't depend on correct ordinal spelling, e.g.\n`ValueError(\"(%s)^(1/%s) does not lie in ring\"%(f,n))`\n\nConcerning further optimization: testing degree is of course a worthwhile cheap trick. A follow-up ticket should probably use square-free factorization; something along the lines:\n\n- if the characteristic p divides n then first check that the polynomial only has p-th powers of the variables in it. Take p-th root (i.e., replace variables and take p-th root of coefficients) and take (n/p)-th root of resulting polynomial\n\n- In characteristic 0 then take g=f/GCD(f,f.derivative()), check that `g^n` divides `f`, take n-th root of `f/(g^n)`, multiply by g and return that.  \n\nIn positive characteristic we may first need to take all p-th powers out.",
    "created_at": "2016-05-07T06:19:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272819",
    "user": "nbruin"
}
```

Perhaps don't bother getting a grammatically correct ordinal. Note that the current code doesn't get it correct anyway: It's 21st, 22nd, 23rd.

Better to formulate the error message in a way that doesn't depend on correct ordinal spelling, e.g.
`ValueError("(%s)^(1/%s) does not lie in ring"%(f,n))`

Concerning further optimization: testing degree is of course a worthwhile cheap trick. A follow-up ticket should probably use square-free factorization; something along the lines:

- if the characteristic p divides n then first check that the polynomial only has p-th powers of the variables in it. Take p-th root (i.e., replace variables and take p-th root of coefficients) and take (n/p)-th root of resulting polynomial

- In characteristic 0 then take g=f/GCD(f,f.derivative()), check that `g^n` divides `f`, take n-th root of `f/(g^n)`, multiply by g and return that.  

In positive characteristic we may first need to take all p-th powers out.



---

archive/issue_comments_272820.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-07T08:19:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272820",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272821.json:
```json
{
    "body": "Replying to [comment:75 nbruin]:\n> Perhaps don't bother getting a grammatically correct ordinal. Note that the current code doesn't get it correct anyway: It's 21st, 22nd, 23rd.\n> \n> Better to formulate the error message in a way that doesn't depend on correct ordinal spelling, e.g.\n> `ValueError(\"(%s)^(1/%s) does not lie in ring\"%(f,n))`\n> \n\nI do like the version with explicit ordinals in the errors more, so I fixed them. :-)\n\n\n\n> Concerning further optimization: testing degree is of course a worthwhile cheap trick. A follow-up ticket should probably use square-free factorization; something along the lines:\n> \n>  - if the characteristic p divides n then first check that the polynomial only has p-th powers of the variables in it. Take p-th root (i.e., replace variables and take p-th root of coefficients) and take (n/p)-th root of resulting polynomial\n> \n>  - In characteristic 0 then take g=f/GCD(f,f.derivative()), check that `g^n` divides `f`, take n-th root of `f/(g^n)`, multiply by g and return that.  \n> \n> In positive characteristic we may first need to take all p-th powers out.\n\nOf course, there is always potential to improve the performance. However, like you said, this should happen in a follow-up ticket.",
    "created_at": "2016-05-07T08:36:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272821",
    "user": "behackl"
}
```

Replying to [comment:75 nbruin]:
> Perhaps don't bother getting a grammatically correct ordinal. Note that the current code doesn't get it correct anyway: It's 21st, 22nd, 23rd.
> 
> Better to formulate the error message in a way that doesn't depend on correct ordinal spelling, e.g.
> `ValueError("(%s)^(1/%s) does not lie in ring"%(f,n))`
> 

I do like the version with explicit ordinals in the errors more, so I fixed them. :-)



> Concerning further optimization: testing degree is of course a worthwhile cheap trick. A follow-up ticket should probably use square-free factorization; something along the lines:
> 
>  - if the characteristic p divides n then first check that the polynomial only has p-th powers of the variables in it. Take p-th root (i.e., replace variables and take p-th root of coefficients) and take (n/p)-th root of resulting polynomial
> 
>  - In characteristic 0 then take g=f/GCD(f,f.derivative()), check that `g^n` divides `f`, take n-th root of `f/(g^n)`, multiply by g and return that.  
> 
> In positive characteristic we may first need to take all p-th powers out.

Of course, there is always potential to improve the performance. However, like you said, this should happen in a follow-up ticket.



---

archive/issue_comments_272822.json:
```json
{
    "body": "Replying to [comment:77 behackl]:\n> Replying to [comment:75 nbruin]:\n> > Perhaps don't bother getting a grammatically correct ordinal. Note that the current code doesn't get it correct anyway: It's 21st, 22nd, 23rd.\n> > \n> > Better to formulate the error message in a way that doesn't depend on correct ordinal spelling, e.g.\n> > `ValueError(\"(%s)^(1/%s) does not lie in ring\"%(f,n))`\n> > \n> \n> I do like the version with explicit ordinals in the errors more, so I fixed them. :-)\n\nHaving the following code executed each time the function run is useless\n\n```\n        if 10 <= n % 100 < 20:\n            postfix = 'th'\n        else:\n            postfix = {1:'st', 2:'nd', 3:'rd'}.get(n % 10, 'th')\n```\n\nMoreover, having these four lines potentially anywhere in Sage because you like is not the way to go. If you really think it is better this way, then implement a function `ordinal_str` that would *really* be doctested.\n\nIn the error message proposed by Nils there was the explicit mention of the parent which is a good thing.",
    "created_at": "2016-05-07T12:27:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272822",
    "user": "vdelecroix"
}
```

Replying to [comment:77 behackl]:
> Replying to [comment:75 nbruin]:
> > Perhaps don't bother getting a grammatically correct ordinal. Note that the current code doesn't get it correct anyway: It's 21st, 22nd, 23rd.
> > 
> > Better to formulate the error message in a way that doesn't depend on correct ordinal spelling, e.g.
> > `ValueError("(%s)^(1/%s) does not lie in ring"%(f,n))`
> > 
> 
> I do like the version with explicit ordinals in the errors more, so I fixed them. :-)

Having the following code executed each time the function run is useless

```
        if 10 <= n % 100 < 20:
            postfix = 'th'
        else:
            postfix = {1:'st', 2:'nd', 3:'rd'}.get(n % 10, 'th')
```

Moreover, having these four lines potentially anywhere in Sage because you like is not the way to go. If you really think it is better this way, then implement a function `ordinal_str` that would *really* be doctested.

In the error message proposed by Nils there was the explicit mention of the parent which is a good thing.



---

archive/issue_comments_272823.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-07T13:14:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272823",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272824.json:
```json
{
    "body": "\n```\nsage: R.<x> = ZZ[]\nsage: parent(R.one().nth_root(3))\nInteger Ring\n```\n",
    "created_at": "2016-05-07T13:22:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272824",
    "user": "vdelecroix"
}
```


```
sage: R.<x> = ZZ[]
sage: parent(R.one().nth_root(3))
Integer Ring
```




---

archive/issue_comments_272825.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-05-07T13:22:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272825",
    "user": "vdelecroix"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_272826.json:
```json
{
    "body": "Replying to [comment:80 vdelecroix]:\n> {{{\n> sage: R.<x> = ZZ[]\n> sage: parent(R.one().nth_root(3))\n> Integer Ring\n> }}}\n\nFixed, will push in a moment.",
    "created_at": "2016-05-07T13:25:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272826",
    "user": "behackl"
}
```

Replying to [comment:80 vdelecroix]:
> {{{
> sage: R.<x> = ZZ[]
> sage: parent(R.one().nth_root(3))
> Integer Ring
> }}}

Fixed, will push in a moment.



---

archive/issue_comments_272827.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-07T13:31:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272827",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272828.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-05-07T13:36:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272828",
    "user": "behackl"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_272829.json:
```json
{
    "body": "Patchbot reports doctest failure due to the change in the error message.",
    "created_at": "2016-05-07T15:36:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272829",
    "user": "vdelecroix"
}
```

Patchbot reports doctest failure due to the change in the error message.



---

archive/issue_comments_272830.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2016-05-08T01:52:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272830",
    "user": "vdelecroix"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_272831.json:
```json
{
    "body": "I have an implementation for a much faster implementation of n-th root at #20571.",
    "created_at": "2016-05-08T01:52:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272831",
    "user": "vdelecroix"
}
```

I have an implementation for a much faster implementation of n-th root at #20571.



---

archive/issue_comments_272832.json:
```json
{
    "body": "Replying to [comment:84 vdelecroix]:\n> Patchbot reports doctest failure due to the change in the error message.\n\nIndeed, and this can be fixed straightforward. However, there is (once again ...) a slight inconvenience: there are superfluous parentheses in, e.g.\n\n\n```\nsage: P.<x> = ZZ[]\nsage: P(4).nth_root(3)\nTraceback (most recent call last):\n...\nValueError: (4)^(1/3) does not lie in ...\n```\n\n\nor\n\n\n```\nsage: x.nth_root(3)\nTraceback (most recent call last):\n...\nValueError: (x)^(1/3) does not lie in ...\n```\n\n\nShould we live with that? Fixing it would require querying something like `self.is_constant()` and `self in self.parent().gens()` or so.\n\nEDIT: `self.is_constant()` would not work:\n\n\n```\nsage: P.<x> = ZZ[]\nsage: Q.<y> = P[]\nsage: Q(x+1).is_constant()\nTrue\n```\n",
    "created_at": "2016-05-08T07:05:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272832",
    "user": "behackl"
}
```

Replying to [comment:84 vdelecroix]:
> Patchbot reports doctest failure due to the change in the error message.

Indeed, and this can be fixed straightforward. However, there is (once again ...) a slight inconvenience: there are superfluous parentheses in, e.g.


```
sage: P.<x> = ZZ[]
sage: P(4).nth_root(3)
Traceback (most recent call last):
...
ValueError: (4)^(1/3) does not lie in ...
```


or


```
sage: x.nth_root(3)
Traceback (most recent call last):
...
ValueError: (x)^(1/3) does not lie in ...
```


Should we live with that? Fixing it would require querying something like `self.is_constant()` and `self in self.parent().gens()` or so.

EDIT: `self.is_constant()` would not work:


```
sage: P.<x> = ZZ[]
sage: Q.<y> = P[]
sage: Q(x+1).is_constant()
True
```




---

archive/issue_comments_272833.json:
```json
{
    "body": "I would think most people would prioritize #20571 over such typographical issues, so I wouldn't sweat too hard over parentheses at this point. Another issue: while it's nice to have informative error messages, error strings that cost a lot to be constructed only to be caught by an \"except\" statement can mean a performance penalty. This is more an issue in python than in many other languages because there's a culture in python (and perhaps even more so in some parts of sage) to use exceptions for regular program flow control, not just for error conditions.",
    "created_at": "2016-05-08T20:58:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272833",
    "user": "nbruin"
}
```

I would think most people would prioritize #20571 over such typographical issues, so I wouldn't sweat too hard over parentheses at this point. Another issue: while it's nice to have informative error messages, error strings that cost a lot to be constructed only to be caught by an "except" statement can mean a performance penalty. This is more an issue in python than in many other languages because there's a culture in python (and perhaps even more so in some parts of sage) to use exceptions for regular program flow control, not just for error conditions.



---

archive/issue_comments_272834.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-05-08T22:56:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272834",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_272835.json:
```json
{
    "body": "Replying to [comment:89 nbruin]:\n> I would think most people would prioritize #20571 over such typographical issues, so I wouldn't sweat too hard over parentheses at this point. Another issue: while it's nice to have informative error messages, error strings that cost a lot to be constructed only to be caught by an \"except\" statement can mean a performance penalty. This is more an issue in python than in many other languages because there's a culture in python (and perhaps even more so in some parts of sage) to use exceptions for regular program flow control, not just for error conditions.\n\nYes, that's my feeling too. While it is somehow unfortunate, I can very well live with it. \n\nI've fixed the doctests and tested the entire `src/sage/rings/polynomial`-directory; let's see what the patchbot thinks.",
    "created_at": "2016-05-08T23:00:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272835",
    "user": "behackl"
}
```

Replying to [comment:89 nbruin]:
> I would think most people would prioritize #20571 over such typographical issues, so I wouldn't sweat too hard over parentheses at this point. Another issue: while it's nice to have informative error messages, error strings that cost a lot to be constructed only to be caught by an "except" statement can mean a performance penalty. This is more an issue in python than in many other languages because there's a culture in python (and perhaps even more so in some parts of sage) to use exceptions for regular program flow control, not just for error conditions.

Yes, that's my feeling too. While it is somehow unfortunate, I can very well live with it. 

I've fixed the doctests and tested the entire `src/sage/rings/polynomial`-directory; let's see what the patchbot thinks.



---

archive/issue_comments_272836.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2016-05-09T15:24:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272836",
    "user": "behackl"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_272837.json:
```json
{
    "body": "Let's move to #20571.",
    "created_at": "2016-05-10T04:48:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272837",
    "user": "vdelecroix"
}
```

Let's move to #20571.



---

archive/issue_comments_272838.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2016-05-10T04:48:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272838",
    "user": "vdelecroix"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_272839.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2016-05-17T07:16:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/19849",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/19849#issuecomment-272839",
    "user": "vbraun"
}
```

Resolution: fixed
