# Issue 19849: Asymptotic ring: fix exponentiation

Issue created by migration from Trac.

Original creator: cheuberg

Original creation time: 2016-02-19 12:52:04

CC:  behackl dkrenn


```
sage: P.<R> = QQ[]
sage: A.<Z> = AsymptoticRing('T^QQ', P)
sage: sqrt(Z)
Traceback (most recent call last):
...
ArithmeticError: Cannot take T to the exponent 1/2 in Exact Term Monoid T^QQ
with coefficients in Univariate Polynomial Ring in R over Rational Field
since its coefficient 1 cannot be taken to this exponent.
> *previous* TypeError: rational is not an integer
```



---

Comment by git created at 2016-02-19 13:19:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2016-02-19 13:22:52

Changing component from asymptotic expansions to basic arithmetic.


---

Comment by cheuberg created at 2016-02-19 13:22:52

Changing status from new to needs_review.


---

Comment by git created at 2016-02-19 15:37:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by nbruin created at 2016-02-20 01:56:39

The fact that for a in QQ, the value of `a^(1/2)` has its parent depending on the actual value of a is a compromise for novice use (in calculus etc.) Normally, one would raise an error if `a^(1/2)` does not lie in QQ. Certainly, promoting to SR is a very bad choice for anything else than novice use.

I see you take the effort of trying to put the result back in the original parent. Don't you think it's better to force that? i.e., raise an error if it doesn't work, rather than give a result back in SR?

The problem is that if someone is computing with polynomials, it's almost certainly not desired to end up in SR (where things like `QQ['x']['x']` get squashed), and if an error isn't raised, it's very hard to detect that it happened.

Also, if you're implementing the (partial) map `a:->a^(n/m)` , why not extend it properly? When
`(QQ['x'](4))^(1/2)` works, why should `QQ['x'](x<sup>2)</sup>(1/2)` fail?


---

Comment by git created at 2016-02-22 17:19:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-02-22 17:28:49

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by cheuberg created at 2016-02-22 17:33:23

Replying to [comment:6 nbruin]:
> The fact that for a in QQ, the value of `a^(1/2)` has its parent depending on the actual value of a is a compromise for novice use (in calculus etc.) Normally, one would raise an error if `a^(1/2)` does not lie in QQ. Certainly, promoting to SR is a very bad choice for anything else than novice use.
> 
> I see you take the effort of trying to put the result back in the original parent. Don't you think it's better to force that? i.e., raise an error if it doesn't work, rather than give a result back in SR?
> 
> The problem is that if someone is computing with polynomials, it's almost certainly not desired to end up in SR (where things like `QQ['x']['x']` get squashed), and if an error isn't raised, it's very hard to detect that it happened.

very valid points, thank you. I now raise an exception.

> 
> Also, if you're implementing the (partial) map `a:->a^(n/m)` , why not extend it properly? When
> `(QQ['x'](4))^(1/2)` works, why should `QQ['x'](x<sup>2)</sup>(1/2)` fail?

I needed a fix a bug which did bite me somewhere else, see initial description. Of course, it would be nice to have that, too; but I'd prefer to leave that to a follow-up ticket and to have this functionality here soon.


---

Comment by behackl created at 2016-03-08 13:26:38

I've fixed the segmentation fault from `rings/integer.pyx` and implemented the case of `constant^constant`.

Also, +1 for extending this functionality on a follow-up ticket; I'd also like to have this in as soon as possible.

I've reviewed your changes, please cross-review. If you are satisfied and if there are no other objections, I'd set this to `positive_review`.
----
New commits:


---

Comment by git created at 2016-03-09 08:29:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2016-03-09 17:03:56

Replying to [comment:11 behackl]:
> I've fixed the segmentation fault from `rings/integer.pyx` and implemented the case of `constant^constant`.

That's weird, but as integer tries to convert the base to the base of the exponent and expects the polynomial ring to handle it, we have to cope with it.
> 
> I've reviewed your changes, please cross-review. If you are satisfied and if there are no other objections, I'd set this to `positive_review`.

I refactored the code: that way it seems to be more suitable for future extension and handles polynomial exponents gracefully.

In a first commit, I removed handling of the segmentation fault because I thought it should be handeled by the base ring; later on, I understood that it has to be handeled here, so re-instated fix (in some other way).
----
New commits:


---

Comment by vdelecroix created at 2016-03-09 17:36:55

Why doing something that complicated for dealing with strange exponents? Why not simply

```
if input is not an integer:
  convert to an integer
do the exponentiation
```


Why are you special casing degree 0 polynomial? If I understand correctly these examples won't behave similarly

```
sage: R.<x> = QQ[]
sage: ((x+1)^2)^(1/2)
-> TypeError
sage: ((R(2))^2)^(1/2)
-> 2
```

Which is weird.


---

Comment by vdelecroix created at 2016-03-09 17:36:55

Changing status from needs_review to needs_info.


---

Comment by cheuberg created at 2016-03-09 17:57:44

Changing status from needs_info to needs_review.


---

Comment by cheuberg created at 2016-03-09 17:57:44

Replying to [comment:16 vdelecroix]:
> Why doing something that complicated for dealing with strange exponents? Why not simply
> {{{
> if input is not an integer:
>   convert to an integer
> do the exponentiation
> }}}

I do not understand this comment. Which input? Base or Exponent? Where should this code be?


> 
> Why are you special casing degree 0 polynomial? If I understand correctly these examples won't behave similarly
> {{{
> sage: R.<x> = QQ[]
> sage: ((x+1)<sup>2)</sup>(1/2)
> -> TypeError
> sage: ((R(2))<sup>2)</sup>(1/2)
> -> 2
> }}}
> Which is weird.

I need a quick fix for `R(1)^(1/2)`. If somebody has time to implement `((x+1)<sup>2)</sup>(1/2)` very soon, I'd be happy. I do not have time soon. However, I want to have the code associated with a recently submitted paper in 7.1.

Basically, this fix here simply branches to existing code. Computing `((x+1)<sup>2)</sup>(1/2)` needs new mathematical code (involving square free decomposition).

Therefore, I propose to include this now on the basis that while this is not a perfect and definitive solution, it is better than the previous behaviour.


---

Comment by vdelecroix created at 2016-03-09 18:31:55

Replying to [comment:17 cheuberg]:
> Replying to [comment:16 vdelecroix]:
> > Why doing something that complicated for dealing with strange exponents? Why not simply
> > {{{
> > if input is not an integer:
> >   convert to an integer
> > do the exponentiation
> > }}}
> 
> I do not understand this comment. Which input? Base or Exponent? Where should this code be?
 
Let me be more precise then

```
def __pow__(self, exp):
    cdef long n
    try:
        n = exp
        # old code for integer exponent
    except TypeError:
        n = QQ.coerce(exp)
        # new code for rational exponent
```

What I do not understand is why are you testing if the exponent is a polynomial...

The following is currently a `TypeError`

```
sage: 1^(ZZ['x'].one())
Traceback (most recent call last):
...
TypeError: 'sage.rings.polynomial.polynomial_integer_dense_flint.Polynomial_integer_dense_flint' object cannot be interpreted as an index
```

The same should happen when the integer `1` is replaced by the polynomial `1`.

> > Why are you special casing degree 0 polynomial? If I understand correctly these examples won't behave similarly
> > {{{
> > sage: R.<x> = QQ[]
> > sage: ((x+1)<sup>2)</sup>(1/2)
> > -> TypeError
> > sage: ((R(2))<sup>2)</sup>(1/2)
> > -> 2
> > }}}
> > Which is weird.
> 
> I need a quick fix for `R(1)^(1/2)`. If somebody has time to implement `((x+1)<sup>2)</sup>(1/2)` very soon, I'd be happy. I do not have time soon. However, I want to have the code associated with a recently submitted paper in 7.1.

Are you sure there was a bug? In Sage the integer 1 is *not* the 1 from ZZ[x] (though they are equal through coercion). Some softwares behave differently to that respect (e.g. GAP) where there is only one 1 which is an integer and not anything else. In Sage (but not in GAP) it is already the case that operations change with respect to the parents even if the objects are equal

```
sage: Zmod(10)(3) == 3
sage: Zmod(10)(5) == 5
sage: log(Zmod(10)(3))
3
sage: log(Zmod(10)(5))
Traceback (most recent call last):
...
ZeroDivisionError: Inverse does not exist.
```


> Basically, this fix here simply branches to existing code.
> Computing `((x+1)<sup>2)</sup>(1/2)` needs new mathematical code (involving square free decomposition).

Indeed. Your modifications obfuscate the code for only a very trivial case and a discutable behavior of powering with polynomials.

> Therefore, I propose to include this now on the basis that while this is not a perfect and definitive solution, it is better than the previous behaviour.

Not sure it is better. Sage used to consider operations based on parents. Powers are of course a special type of operation and with some respect might be treated appart. But "(polynomial)^(polynomial)" is not well defined. And "(polynomial)^(rational)" is well defined in some situations (and to that respect, your code improves the current situation a little).

Moreover, the current "power promotion" for ZZ is very bad

```
sage: 3^(1/2)
sqrt(3)
sage: parent(_)
Symbolic Ring
sage: 4^(1/2)
2
sage: parent(_)
Rational Field
```

Making it available for constant polynomial is not that much of an improvement.


---

Comment by cheuberg created at 2016-03-09 20:01:08

It seems that I mis-edited the description of the problem at some stage. Is now fixed.

Apart from that, the current code apparently leads to problems.


---

Comment by cheuberg created at 2016-03-09 20:01:08

Changing status from needs_review to needs_work.


---

Comment by cheuberg created at 2016-03-09 20:03:16

Replying to [comment:18 vdelecroix]:
> Moreover, the current "power promotion" for ZZ is very bad
> {{{
> sage: 3^(1/2)
> sqrt(3)
> sage: parent(_)
> Symbolic Ring
> sage: 4^(1/2)
> 2
> sage: parent(_)
> Rational Field
> }}}
see [comment:6 nbruin]'s comment 6.


---

Comment by behackl created at 2016-03-09 20:08:28

Hi Vincent!

Just to clarify the previous need for checking whether the exponent is a polynomial: in our previous approach, we were hoping for the coefficient ring to carry out the exponentiation, i.e. if we had

```
sage: P.<z> = QQ[]
sage: P(1/4)^(1/2)
1/2
```

then we would compute this by letting `QQ` do the exponentiation. However, in the doctest over at `rings/integer.pyx` we have something like

```
sage: P.<t> = QQ[]
sage: 2^t
```

With the old implementation, this lead to an infinite loop (because coercion would put the base always back to P again...), and thus I added the check for the polynomial in the exponent.

In any case, I'm all for improving the code and first trying to deal with integers, and then with rationals afterwards. Nevertheless, I'd still just handle constant polynomials in the base on this ticket---but then, this could be extended easily.

Benjamin


---

Comment by git created at 2016-03-09 20:10:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2016-03-09 20:12:01

Changing status from needs_work to needs_review.


---

Comment by cheuberg created at 2016-03-09 20:12:01

Problem found by patchbot was a stupid mistake, hopefully fixed now.


---

Comment by cheuberg created at 2016-03-09 20:23:59

Replying to [comment:18 vdelecroix]:
> Let me be more precise then
> {{{
> def __pow__(self, exp):
>     cdef long n
>     try:
>         n = exp
>         # old code for integer exponent
>     except TypeError:
>         n = QQ.coerce(exp)
>         # new code for rational exponent
> }}}

ok, if you prefer it like that, we can probably do that.

> > I need a quick fix for `R(1)^(1/2)`. If somebody has time to implement `((x+1)<sup>2)</sup>(1/2)` very soon, I'd be happy. I do not have time soon. However, I want to have the code associated with a recently submitted paper in 7.1.
> 
> Are you sure there was a bug?

Do you think that disallowing `R(1)^(1/2)` is the desired behaviour?

> In Sage the integer 1 is *not* the 1 from ZZ[x] (though they are equal through coercion). Some softwares behave differently to that respect (e.g. GAP) where there is only one 1 which is an integer and not anything else. In Sage (but not in GAP) it is already the case that operations change with respect to the parents even if the objects are equal
> {{{
> sage: Zmod(10)(3) == 3
> sage: Zmod(10)(5) == 5
> sage: log(Zmod(10)(3))
> 3
> sage: log(Zmod(10)(5))
> Traceback (most recent call last):
> ...
> ZeroDivisionError: Inverse does not exist.
> }}}

I have no idea how this is related to this problem, sorry.

> 
> > Basically, this fix here simply branches to existing code.
> > Computing `((x+1)<sup>2)</sup>(1/2)` needs new mathematical code (involving square free decomposition).
> 
> Indeed. Your modifications obfuscate the code for only a very trivial case and a discutable behavior of powering with polynomials.

It might seem trivial to you, but it did cost me an hour while writing a paper because basically, asymptotic rings using polynomial rings as coefficient rings could not compute square roots, and, sorry, I need that.

> 
> > Therefore, I propose to include this now on the basis that while this is not a perfect and definitive solution, it is better than the previous behaviour.
> 
> Not sure it is better. Sage used to consider operations based on parents. Powers are of course a special type of operation and with some respect might be treated appart. But "(polynomial)^(polynomial)" is not well defined. And "(polynomial)^(rational)" is well defined in some situations (and to that respect, your code improves the current situation a little).

There was a discussion on sage-devel a few weeks ago. Every parent seems to have its own home-made logic about how to do coercion. Please do not try to fix that in this ticket.


---

Comment by vdelecroix created at 2016-03-10 02:23:55

Replying to [comment:24 cheuberg]:
> >
> > [... snip ...]
> >

> There was a discussion on sage-devel a few weeks ago. Every parent seems to have its own home-made logic about how to do coercion. Please do not try to fix that in this ticket.

Please do not try to complicate it in this ticket either. A possible solution could be:
 - allow `polynomial^rational` as much as we can (i.e. for some constant polynomials for the sake of this ticket). For more general polynomial we can for now raise a `NotImplementedError`.
 - disallow `polynomial^polynomial` even if the power is a constant polynomial. In that case, the error should be a `TypeError`. This is the current behavior for some polynomial rings but not all

```
sage: ZZ['x'].gen() ** ZZ['x'].one()
 -> TypeError
sage: QQ['x'].gen() ** ZZ['x'].one()
 -> TypeError
sage: RR['x'].gen() ** ZZ['x'].one()
x
```


What do you think? Would that solution fit your needs?

Vincent


---

Comment by cheuberg created at 2016-03-10 05:31:02

Replying to [comment:25 vdelecroix]:
> A possible solution could be:
>  - allow `polynomial^rational` as much as we can (i.e. for some constant polynomials for the sake of this ticket). For more general polynomial we can for now raise a `NotImplementedError`.
>  - disallow `polynomial^polynomial` even if the power is a constant polynomial. In that case, the error should be a `TypeError`. This is the current behavior for some polynomial rings but not all
> {{{
> sage: ZZ['x'].gen() ** ZZ['x'].one()
>  -> TypeError
> sage: QQ['x'].gen() ** ZZ['x'].one()
>  -> TypeError
> sage: RR['x'].gen() ** ZZ['x'].one()
> x
> }}}
> 
> What do you think? Would that solution fit your needs?

As far as I can see without implementing it and `make ptestlong`, this fits perfectly.


---

Comment by git created at 2016-03-10 06:19:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2016-03-10 06:21:43

This is now refactored as a try/expect block; polynomial exponents are now disallowed.

I am not completely comfortable with the long block wrapped within `try`/`expect` because I am not sure that we catch the correct `TypeError`. What do you think about that?


---

Comment by vdelecroix created at 2016-03-10 13:26:58

Replying to [comment:28 cheuberg]:
> This is now refactored as a try/expect block; polynomial exponents are now disallowed.

Thanks.

> I am not completely comfortable with the long block wrapped within `try`/`expect` because I am not sure that we catch the correct `TypeError`. What do you think about that?

Right. It is better to avoid long `try/except`. One possibility is

```
try:
    nn = pyobject_to_long(exp)
except TypeError:
    # rational code
else:
    # integer code
```



---

Comment by git created at 2016-03-10 13:45:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2016-03-10 13:46:34

Replying to [comment:29 vdelecroix]:
> Right. It is better to avoid long `try/except`. One possibility is
> {{{
> try:
>     nn = pyobject_to_long(exp)
> except TypeError:
>     # rational code
> else:
>     # integer code
> }}}
done.


---

Comment by vdelecroix created at 2016-03-11 15:45:16

I implemented a generic `nth_root` method and used it...
----
New commits:


---

Comment by vdelecroix created at 2016-03-11 15:49:43

Though, since `num` and `den` are relatively prime it should be cheaper to do `self.nth_root(den) ** num` instead of `(self ** num).nth_root(den)`... I will think about it.

Anyway, it would be good to see whether it works for other polynomial rings. For example `QQbar['x']` or when the base ring is a number field or a finite field...


---

Comment by vdelecroix created at 2016-03-11 15:53:22

When the polynomial is of degree 0 it would also be faster to actually also relies on `nth_root`:

```
sage: %timeit 27.nth_root(3)
1000000 loops, best of 3: 388 ns per loop
sage: %timeit 27 ** (1/3)
100000 loops, best of 3: 7.51 µs per loop
```

As `nth_root` should be guaranteed to return an element of the same ring there will also be much less coercion involved.


---

Comment by git created at 2016-03-11 15:59:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-03-11 17:21:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-03-29 02:20:26

Hi! I've reviewed this refactored implementation (thanks for implementing it!), and everything looks good to me.

I've added a small reviewer commit; please cross-review and set to `positive_review` if you are satisfied.
----
New commits:


---

Comment by vdelecroix created at 2016-03-29 02:44:05

Nope. This is actually working because of a bug see #20214  ;-(. What I wrote in the generic `nth_root` should always be an infinite loop (because of `u.nth_root(n)`).

One possibility:

- make it work when `u.is_one()` is `True` (or more generally when `u.multiplicative_order()` is finite)
- raise an error if `u` is not in the above case and there are some non trivial factors

The aim of the second item is that in children classes (like polynomials) you might want to do

```
def nth_root(self, n):
    if self.degree() <= 0:
        # factorize unit using base ring method
        XXX
    else:
        return super(XXX).nth_root(self, n)
```



---

Comment by vdelecroix created at 2016-03-29 02:44:16

Changing status from needs_review to needs_work.


---

Comment by behackl created at 2016-03-29 07:55:46

Well, wouldn't it be more natural to let the unit be an element of the base ring? (As far as I see the parent of the unit of polynomials over QQ always is from QQ, for example.)

Of course, we can also add checks like if `u` is one etc., but with this ticket only polynomial rings over the rationals and the integers use this method---and both of them have implemented a `nth_root` method; this is why I still think that this would be good to go and why special treatment isn't needed. And the inconsistency mentioned in #20214 only introduces a recursion of depth 2, which would be resolved if the `unit` method would behave for integers like for rationals.

It isn't even necessary to separately implement `nth_root` for polynomials such that the case of constant polynomials is handled by the base ring: over `ZZ`, the overall coefficient is decomposed w.r.t. PFD and handled like a non-constant polynomial (which is what I would have implemented in the base ring as well). For QQ, the overall factor is in the unit and handled separately in the `nth_root` method.

Letting other polynomial rings profit from this procedure should be realized in a follow-up ticket, IMHO.

However, what should be added before this ships is a special treatment of the zero polynomial. I'll push this in a minute.


---

Comment by git created at 2016-03-29 08:11:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-04-18 14:57:15

... any new thoughts on this?


---

Comment by behackl created at 2016-04-30 16:17:37

Replying to [comment:42 behackl]:
> ... any new thoughts on this?

I would very much like to have this in `7.2`, because I/we need it for a paper we have written. Thus I'd like to discuss this once again:

IIRC the possibly infinite recursion could be avoided altogether if we would convert the unit `f.unit()` to the corresponding base ring. This wouldn't require any additional fix for the units, and the code affects only `ZZ[]` and `QQ[]` anyway, so I'm rather sure that it works.

Any objections to this approach?


---

Comment by behackl created at 2016-04-30 16:17:37

Changing status from needs_work to needs_info.


---

Comment by vdelecroix created at 2016-04-30 18:33:40

It is fine for me if you modify the generic `nth_root` to

```
u = f.unit()
if u.is_one():
    # do nothing
elif self.parent() != self.base_ring():
    # try to factorize the unit in the base ring
else:
    # raise a NotImplementedError
```


EDIT: small modif in the code `self != self.base_ring()` -> `self.parent() != self.base_ring()`


---

Comment by git created at 2016-04-30 23:47:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-04-30 23:53:06

Replying to [comment:44 vdelecroix]:
> It is fine for me if you modify the generic `nth_root` to
> {{{
> u = f.unit()
> if u.is_one():
>     # do nothing
> elif self.parent() != self.base_ring():
>     # try to factorize the unit in the base ring
> else:
>     # raise a NotImplementedError
> }}}
> 
> EDIT: small modif in the code `self != self.base_ring()` -> `self.parent() != self.base_ring()`

Thanks for the suggestion! I've pushed some changes such that the unit is handled with more care. Apart from that, I've reviewed the documentation changes and doctests already in the past, this is still fine for me. Please cross-review. :-)


---

Comment by behackl created at 2016-04-30 23:53:06

Changing status from needs_info to needs_review.


---

Comment by vdelecroix created at 2016-05-01 03:54:11

With

```
if u.parent() != u.base_ring():
    u = u.base_ring(u)

try:
    ans = u.nth_root(n)
except AttributeError:
    raise NotImplementedError(...)
```

You have a risk of infinite recursion. You should use `nth_root` of `u` only if `u.parent()` is not `self.parent()` anymore.


---

Comment by vdelecroix created at 2016-05-01 03:55:04

Moreover, it is not always possible to do `u = u.base_ring(u)` (even for units).


---

Comment by vdelecroix created at 2016-05-01 04:28:53

I added a commit to fix the issues I mentioned. As a reviewer, I think that the code lacks example. It currently only tests `ZZ[x]` but is intended to work for any unique factorization domain...
----
Last 10 new commits:


---

Comment by git created at 2016-05-01 10:17:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-05-01 10:22:20

Replying to [comment:50 vdelecroix]:
> I added a commit to fix the issues I mentioned. As a reviewer, I think that the code lacks example. It currently only tests `ZZ[x]` but is intended to work for any unique factorization domain...

I wasn't too happy with the repeated `if` and `raise` statements, so I tried to clean that up a bit. Also, I've added doctests for `QQ[x]`, multivariate polynomial rings, and the number field in `x^2 - 2`. Does anything more exotic come to your mind that you would like to have tested as well?


---

Comment by vdelecroix created at 2016-05-01 13:09:26

Would be nice to have a non polynomial examples. But currently, order in number fields does not know whether they are principal ideal domain or unique factorization domain

```
sage: R = ZZ[I]
sage: R in PrincipalIdealDomains()
False
sage: R in UniqueFactorizationDomains()
False
```


In `__pow__` for integer polynomials, in the case the exponent is an integer you should only use `nn` and not `exp` (i.e. you should replace `if exp == 0` and `if exp < 0` by `if nn == 0` and `nn < 0`).


---

Comment by git created at 2016-05-01 13:29:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-05-01 13:37:53

Replying to [comment:53 vdelecroix]:
> Would be nice to have a non polynomial examples. But currently, order in number fields does not know whether they are principal ideal domain or unique factorization domain
> {{{
> sage: R = ZZ[I]
> sage: R in PrincipalIdealDomains()
> False
> sage: R in UniqueFactorizationDomains()
> False
> }}}
> 

Yes, the gaussian integers were also my first idea for such an example, but getting this to work should rather be a follow-up ticket.

> In `__pow__` for integer polynomials, in the case the exponent is an integer you should only use `nn` and not `exp` (i.e. you should replace `if exp == 0` and `if exp < 0` by `if nn == 0` and `nn < 0`).

Makes sense. Done.


---

Comment by vdelecroix created at 2016-05-01 15:55:53

Changing status from needs_review to positive_review.


---

Comment by vdelecroix created at 2016-05-01 15:55:53

Enough to go!


---

Comment by behackl created at 2016-05-01 16:02:54

Replying to [comment:56 vdelecroix]:
> Enough to go!

Thanks for this final sprint! Now I can sleep a bit better... ;-)


---

Comment by nbruin created at 2016-05-01 16:18:18

Changing status from positive_review to needs_info.


---

Comment by nbruin created at 2016-05-01 16:18:18

Taking an n-th root of an element in a ring R by computing a factorization is an insane way to go about it. A much better generic strategy is to hope that the univariate polynomial ring over R has a root finding algorithm and see if the polynomial `x^n-a` has a root. You will see that:
- it actually has a decent performance over QQ (although there the algorithm should really be special-cased)
- it will work over most fields, including the ones that are not constructed as fraction fields of rings with a factorization algorithm.
- you don't have to mess around with the unit part that a factorization algorithm probably won't recognize.

Illustration:

```
sage: a=next_prime(10^10)*next_prime(10^11)
sage: b=a^2
sage: %timeit (R.0^2-b).roots()
1000 loops, best of 3: 428 µs per loop
sage: %timeit b.factor()
100 loops, best of 3: 3.68 ms per loop
```


```
sage: k.<r>=NumberField(x^2+5)
sage: b=k(7^2)
sage: (k['x'].0^2-b).roots()
[(7, 1), (-7, 1)]
sage: factor(b) #doesn't work of course
```



---

Comment by behackl created at 2016-05-01 16:55:16

Replying to [comment:58 nbruin]:
> Taking an n-th root of an element in a ring R by computing a factorization is an insane way to go about it. A much better generic strategy is to hope that the univariate polynomial ring over R has a root finding algorithm and see if the polynomial `x^n-a` has a root. You will see that:
> - it actually has a decent performance over QQ (although there the algorithm should really be special-cases)
> - it will work over most fields, including the ones that are not constructed as fraction fields of rings with a factorization algorithm.
> - you don't have to mess around with the unit part that a factorization algorithm probably won't recognize.

While I like the general idea of this approach, I'm for discussing it on a follow-up ticket; see it as a "performance enhancement" of this implementation. Also, I'm not sure how exactly the root-finding algorithm for these univariate polynomial rings can be properly motivated, for me neither `roots()` nor `any_root()` did the job:


```
sage: R.<x> = QQ[]
sage: P.<X> = R[]
sage: a = X^2 - (x^2 + 2*x + 1)
sage: a.any_root(R)
Traceback (most recent call last):
...
TypeError: Unable to coerce Principal ideal (1) of Univariate Polynomial Ring in x over Rational Field (<class 'sage.rings.polynomial.ideal.Ideal_1poly_field'>) to Rational
```


Do you strongly object against setting this back to `positive_review`?


---

Comment by nbruin created at 2016-05-02 04:42:54

Replying to [comment:59 behackl]:
> Do you strongly object against setting this back to `positive_review`?
Yes, because it is parking code in the wrong spot.

Perhaps park your code on `sage.rings.polynomial.polynomial_element.Polynomial`? Taking an n-th root of a polynomial via factorization isn't quite as bad as in general.

Since `NumberFieldElement` etc. already provides an `nth_root` method, it may be sufficient to just provide the method on Polynomial.


---

Comment by behackl created at 2016-05-02 18:51:10

Replying to [comment:60 nbruin]:
> Replying to [comment:59 behackl]:
> > Do you strongly object against setting this back to `positive_review`?
> Yes, because it is parking code in the wrong spot.
> 

I was hoping for a comment from Vincent, as he started with the generic solution on this branch.

In any case: I do not quite understand why this would be in the wrong place. Unique factorization domains should provide a `factor`-method, and providing a generic `nth_root` method for them doesn't strike me as bad.

It might be true that this ticket only changes the behavior of polynomial rings, but I don't see a downside of providing a generic solution. But maybe I'm missing something? :-)

> Perhaps park your code on `sage.rings.polynomial.polynomial_element.Polynomial`? Taking an n-th root of a polynomial via factorization isn't quite as bad as in general.
> 
> Since `NumberFieldElement` etc. already provides an `nth_root` method, it may be sufficient to just provide the method on Polynomial.

Yes, that is true---however, I think that the code provided on this ticket is generic enough to work for all unique factorization domains. Or doesn't it? Even if it might be not performant, I think that a generic approach is certainly allowed to be slow---this problem can be handled by special case implementations.

I just don't see a benefit from moving the code back to polynomials only. Could you elaborate more why this generic solution should be degraded to a special case?


---

Comment by vdelecroix created at 2016-05-02 19:00:15

The code provided is far to be working on any UFD as you have to factor the unit! But we know for sure that it will work for polynomial rings whose base ring provides a `nth_root` method. It would make sense to move the code to generic polynomial. As there is not a lot of examples of UFD in Sage it is hard to say that this code is useful for general UFD.


---

Comment by behackl created at 2016-05-02 19:08:06

Replying to [comment:62 vdelecroix]:
> The code provided is far to be working on any UFD as you have to factor the unit! 

I might still be thinking too much of polynomial rings when thinking of UFDs. ;-)

> But we know for sure that it will work for polynomial rings whose base ring provides a `nth_root` method. It would make sense to move the code to generic polynomial. 

The argument regarding the unit and the fact that there are not that much (exotic) UFDs implemented in Sage convice me; thanks for the clarification! :-) I'll move the code.


---

Comment by behackl created at 2016-05-02 19:08:06

Changing status from needs_info to needs_work.


---

Comment by behackl created at 2016-05-02 19:33:08

Moving the code to `sage.rings.polynomial.polynomial_element.Polynomial` only provides `nth_root` for univariate polynomial rings, as it seems. The doctests for multivariate rings fail with


```
AttributeError: 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular' object has no attribute 'nth_root'
```


I'm not a particularly big fried of copying the code to `sage.rings.polynomial.multi_polynomial_element.MPolynomial_element` as well. The univariate and multivariate polynomial ring elements inherit from CommutativeAlgebraelement and CommutativeRingElement, respectively---so implementing it in a superclass is not possible.

Ideas?


---

Comment by behackl created at 2016-05-03 07:42:54

Replying to [comment:64 behackl]:
> Ideas?

- Leave the code in `categories.unique_factorization_domain`, raise a `NotImplementedError` ...
  - ... if something goes wrong (current behavior), or 
  - ... when the calling parent is not a polynomial ring (that seems relatively restrictive to me)
- Move it to either univariate or multivariate polynomials, call the same method from the other one (I'm thinking of something like `nth_root = sage.rings.polynomial.polynomial_element.nth_root` or so...)
- Move it to both univaraite and multivariate polynomial rings

I'll try to do the second one and push the branch again, let me know if you feel that there is a better solution.


---

Comment by git created at 2016-05-03 08:16:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-05-03 08:20:46

Changing status from needs_work to needs_review.


---

Comment by behackl created at 2016-05-03 08:20:46

My attempt to implement the second strategy failed spectacularly with


```
TypeError: descriptor 'nth_root' for 'sage.rings.polynomial.polynomial_element.Polynomial' objects doesn't apply to 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomial_libsingular' object
```


so I've duplicated the code and adapted the doctests a bit.

I'm not particularly happy with this solution, but I don't see a better one*. Suggestions are very welcome. Back to `needs_review` again...

*EDIT: that doesn't live in `categories.unique_factorization_domains`. There seems to be nothing sufficiently in common between the univariate and multivariate polynomial rings.


---

Comment by git created at 2016-05-05 18:09:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-05-05 18:13:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-05-05 18:24:38

I've added comments that there is a duplicated version of the code. Also, I've fixed the failing doctest.

Even though we are too late for `7.2`, I'd still greatly appreciate if someone could review my last few changes. The code itself is already reviewed.


---

Comment by vdelecroix created at 2016-05-06 11:54:52

Since now the code is in the polynomial ring you can simplify it a lot. Just remove all of

```
u = f.unit()
if u.is_one():
    ...
else:
    ....
```

and do

```
u = self.base_ring()(f.unit())
try:
    u.nth_root(n)
except AttributeError:
    raise NotImplementedError
```



---

Comment by vdelecroix created at 2016-05-06 12:10:12

And if the degree is not divisible by `n` you already know that there is no n-th root (in multivariate case, degree="sum of degrees of monomials"). This is very cheap to test.


---

Comment by git created at 2016-05-06 13:25:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-05-06 13:26:38

Replying to [comment:73 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[753462d](http://git.sagemath.org/sage.git/commit/?id=753462d07465a87797609856bec781797da9a6b1)||`more refactoring after moving code to rings.polynomial`||

Simplified the code and added the additional check for `self.degree() % n`.


---

Comment by nbruin created at 2016-05-07 06:19:05

Perhaps don't bother getting a grammatically correct ordinal. Note that the current code doesn't get it correct anyway: It's 21st, 22nd, 23rd.

Better to formulate the error message in a way that doesn't depend on correct ordinal spelling, e.g.
`ValueError("(%s)^(1/%s) does not lie in ring"%(f,n))`

Concerning further optimization: testing degree is of course a worthwhile cheap trick. A follow-up ticket should probably use square-free factorization; something along the lines:

 - if the characteristic p divides n then first check that the polynomial only has p-th powers of the variables in it. Take p-th root (i.e., replace variables and take p-th root of coefficients) and take (n/p)-th root of resulting polynomial

 - In characteristic 0 then take g=f/GCD(f,f.derivative()), check that `g^n` divides `f`, take n-th root of `f/(g^n)`, multiply by g and return that.  

In positive characteristic we may first need to take all p-th powers out.


---

Comment by git created at 2016-05-07 08:19:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-05-07 08:36:28

Replying to [comment:75 nbruin]:
> Perhaps don't bother getting a grammatically correct ordinal. Note that the current code doesn't get it correct anyway: It's 21st, 22nd, 23rd.
> 
> Better to formulate the error message in a way that doesn't depend on correct ordinal spelling, e.g.
> `ValueError("(%s)^(1/%s) does not lie in ring"%(f,n))`
> 

I do like the version with explicit ordinals in the errors more, so I fixed them. :-)



> Concerning further optimization: testing degree is of course a worthwhile cheap trick. A follow-up ticket should probably use square-free factorization; something along the lines:
> 
>  - if the characteristic p divides n then first check that the polynomial only has p-th powers of the variables in it. Take p-th root (i.e., replace variables and take p-th root of coefficients) and take (n/p)-th root of resulting polynomial
> 
>  - In characteristic 0 then take g=f/GCD(f,f.derivative()), check that `g^n` divides `f`, take n-th root of `f/(g^n)`, multiply by g and return that.  
> 
> In positive characteristic we may first need to take all p-th powers out.

Of course, there is always potential to improve the performance. However, like you said, this should happen in a follow-up ticket.


---

Comment by vdelecroix created at 2016-05-07 12:27:19

Replying to [comment:77 behackl]:
> Replying to [comment:75 nbruin]:
> > Perhaps don't bother getting a grammatically correct ordinal. Note that the current code doesn't get it correct anyway: It's 21st, 22nd, 23rd.
> > 
> > Better to formulate the error message in a way that doesn't depend on correct ordinal spelling, e.g.
> > `ValueError("(%s)^(1/%s) does not lie in ring"%(f,n))`
> > 
> 
> I do like the version with explicit ordinals in the errors more, so I fixed them. :-)

Having the following code executed each time the function run is useless

```
        if 10 <= n % 100 < 20:
            postfix = 'th'
        else:
            postfix = {1:'st', 2:'nd', 3:'rd'}.get(n % 10, 'th')
```

Moreover, having these four lines potentially anywhere in Sage because you like is not the way to go. If you really think it is better this way, then implement a function `ordinal_str` that would _really_ be doctested.

In the error message proposed by Nils there was the explicit mention of the parent which is a good thing.


---

Comment by git created at 2016-05-07 13:14:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by vdelecroix created at 2016-05-07 13:22:05


```
sage: R.<x> = ZZ[]
sage: parent(R.one().nth_root(3))
Integer Ring
```



---

Comment by vdelecroix created at 2016-05-07 13:22:05

Changing status from needs_review to needs_work.


---

Comment by behackl created at 2016-05-07 13:25:52

Replying to [comment:80 vdelecroix]:
> {{{
> sage: R.<x> = ZZ[]
> sage: parent(R.one().nth_root(3))
> Integer Ring
> }}}

Fixed, will push in a moment.


---

Comment by git created at 2016-05-07 13:31:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-05-07 13:36:10

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-05-07 15:36:27

Patchbot reports doctest failure due to the change in the error message.


---

Comment by vdelecroix created at 2016-05-08 01:52:24

Changing status from needs_review to needs_work.


---

Comment by vdelecroix created at 2016-05-08 01:52:24

I have an implementation for a much faster implementation of n-th root at #20571.


---

Comment by behackl created at 2016-05-08 07:05:37

Replying to [comment:84 vdelecroix]:
> Patchbot reports doctest failure due to the change in the error message.

Indeed, and this can be fixed straightforward. However, there is (once again ...) a slight inconvenience: there are superfluous parentheses in, e.g.


```
sage: P.<x> = ZZ[]
sage: P(4).nth_root(3)
Traceback (most recent call last):
...
ValueError: (4)^(1/3) does not lie in ...
```


or


```
sage: x.nth_root(3)
Traceback (most recent call last):
...
ValueError: (x)^(1/3) does not lie in ...
```


Should we live with that? Fixing it would require querying something like `self.is_constant()` and `self in self.parent().gens()` or so.

EDIT: `self.is_constant()` would not work:


```
sage: P.<x> = ZZ[]
sage: Q.<y> = P[]
sage: Q(x+1).is_constant()
True
```



---

Comment by nbruin created at 2016-05-08 20:58:59

I would think most people would prioritize #20571 over such typographical issues, so I wouldn't sweat too hard over parentheses at this point. Another issue: while it's nice to have informative error messages, error strings that cost a lot to be constructed only to be caught by an "except" statement can mean a performance penalty. This is more an issue in python than in many other languages because there's a culture in python (and perhaps even more so in some parts of sage) to use exceptions for regular program flow control, not just for error conditions.


---

Comment by git created at 2016-05-08 22:56:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by behackl created at 2016-05-08 23:00:41

Replying to [comment:89 nbruin]:
> I would think most people would prioritize #20571 over such typographical issues, so I wouldn't sweat too hard over parentheses at this point. Another issue: while it's nice to have informative error messages, error strings that cost a lot to be constructed only to be caught by an "except" statement can mean a performance penalty. This is more an issue in python than in many other languages because there's a culture in python (and perhaps even more so in some parts of sage) to use exceptions for regular program flow control, not just for error conditions.

Yes, that's my feeling too. While it is somehow unfortunate, I can very well live with it. 

I've fixed the doctests and tested the entire `src/sage/rings/polynomial`-directory; let's see what the patchbot thinks.


---

Comment by behackl created at 2016-05-09 15:24:08

Changing status from needs_work to needs_review.


---

Comment by vdelecroix created at 2016-05-10 04:48:51

Let's move to #20571.


---

Comment by vdelecroix created at 2016-05-10 04:48:51

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2016-05-17 07:16:35

Resolution: fixed
