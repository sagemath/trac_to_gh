# Issue 16141: list_plot throws a TypeError with complex lists

Issue created by migration from Trac.

Original creator: bradlys

Original creation time: 2014-05-20 01:45:44

CC:  ppurka

Example of the issue on SageMathCloud.

> L=[1+i,4+i,4+2*i,2+2*i,2+3*i,1+3*i,1+i]
>list_plot(L,plotjoined=True,aspect_ratio=1)

Error in lines 2-2
Traceback (most recent call last):
  File "/projects/70e0e4f6-0afa-4aad-af80-07b2d31c1ec6/.sagemathcloud/sage_server.py", line 733, in execute
    exec compile(block+'\n', '', 'single') in namespace, locals
  File "", line 1, in <module>
  File "/usr/local/sage/sage-6.2.rc0/local/lib/python2.7/site-packages/sage/misc/decorators.py", line 550, in wrapper
    return func(*args, **options)
  File "/usr/local/sage/sage-6.2.rc0/local/lib/python2.7/site-packages/sage/plot/plot.py", line 1810, in list_plot
    data = [(z.real(), z.imag()) for z in [CC(z[1]) for z in data]]
TypeError: 'sage.symbolic.expression.Expression' object does not support indexing


---

Comment by bradlys created at 2014-05-20 01:46:16

Set assignee to bradlys.


---

Comment by kcrisman created at 2014-05-20 14:59:03

Normally, `L` should be changed to `list(enumerate(L))` so that this works fine, but apparently we are finally tripping the `pass` created when we get a `TypeError` in this branch of `list_plot`.  I'm not sure where this happened yet, though.


---

Comment by bradlys created at 2014-05-26 01:36:24

I think what's happening is that at line 1792, a TypeError is thrown.


```
try:
    from sage.rings.all import RDF #1791
    tmp = RDF(data[0]) #1792
    data = list(enumerate(data)) #1793
except TypeError:
    pass
try:
    if plotjoined:
        return line(data, **kwargs)
    else:
        return point(data, **kwargs)
except (TypeError, IndexError):
    # Assume we have complex-valued input and plot real and imaginary parts.
    # Need to catch IndexError because if data is, say, [(0, 1), (1, I)],
    # point3d() throws an IndexError on the (0,1) before it ever
    # gets to (1, I).
    from sage.rings.complex_field import ComplexField
    CC = ComplexField()
    # if we get here, we already did "list(enumerate(data))",
    # so look at z[1] in inner list
    data = [(z.real(), z.imag()) for z in [CC(z[1]) for z in data]] # LINE 1810
    if plotjoined:
        return line(data, **kwargs)
    else:
        return point(data, **kwargs)
```


I tested this theory by running this code in a sage worksheet on SMC:

```
from sage.rings.all import RDF
data = [1+i,4+i,4+2*i,2+2*i,2+3*i,1+3*i,1+i]
tmp = RDF(data[0])
```

Which throws a TypeError saying "TypeError: Unable to convert 1.0 + 1.0*I to float; use abs() or real_part() as desired".

That makes sense but that ends up skipping line 1793 where we need data = list(enumerate(data)) to occur. I could add data = list(enumerate(data)) at line 1809 and I think that would solve the issue since that's the case where you have complex-valued input.

I tried this snippet, again in SMC, which does produce the desired output as far as I can tell.


```
from sage.rings.all import RDF
data = [1+i,4+i,4+2*i,2+2*i,2+3*i,1+3*i,1+i]
data = list(enumerate(data))
from sage.rings.complex_field import ComplexField
CC = ComplexField()
data = [(z.real(), z.imag()) for z in [CC(z[1]) for z in data]]
point(data)
```



---

Comment by kcrisman created at 2014-05-27 14:56:24

Thanks for adding the full details; that is exactly what I was alluding to.  The question is **why** this is happening now, because I don't think this behavior of `RDF(data[0])` is any different from before (well, the error message is somewhat different, but a `TypeError` is raised even in much older version of Sage, as it should be) - hence my saying "finally".  

And I'm stumped on that.  In 5.12 all is well.  I hate to have to bisect things, though I agree that adding the line in the place you mention should work, but my suspicion is that there is another change/bug involved and it would be best to get to the bottom of this  - in case it was fixed another time and then we ended up enumerating an enumerated list, causing a different bug.


---

Comment by bradlys created at 2014-05-27 23:51:05

This is how list_plot works from 5.1.2. It's significantly different than the current implementation. I'm not sure how to track down where the changes were made as I am pretty new to fixing bugs for Sage.

```
from sage.plot.all import line, point
if data == {} or data == () or data == []:
	return Graphics()
if isinstance(data, dict):
	if plotjoined:
		list_data = sorted(list(data.iteritems()))
	else:
		list_data = list(data.iteritems())
	return list_plot(list_data, plotjoined=plotjoined, **kwargs)
if not isinstance(data[0], (list, tuple)):
	data = zip(range(len(data)), data)
if isinstance(plotjoined, (list, tuple)):
	raise TypeError, "The second argument 'plotjoined' should be boolean (True or False).  If you meant to plot two lists 'x' and 'y' against each other, use 'list_plot(zip(x,y))'."
try:
	if plotjoined:
		return line(data, **kwargs)
	else:
		return point(data, **kwargs)
except (TypeError, IndexError):
	# Assume we have complex-valued input and plot real and imaginary parts.
	# Need to catch IndexError because if data is, say, [(0, 1), (1, I)],
	# point3d() throws an IndexError on the (0,1) before it ever
	# gets to (1, I).
	from sage.rings.complex_field import ComplexField
	CC = ComplexField()
	# if we get here, we already did "zip(range(len(data)), data)",
	# so look at z[1] in inner list
	data = [(z.real(), z.imag()) for z in [CC(z[1]) for z in data]]
	if plotjoined:
		return line(data, **kwargs)
	else:
		return point(data, **kwargs)
```



---

Comment by kcrisman created at 2014-05-28 00:04:26

> This is how list_plot works from 5.1.2. It's significantly different than the current implementation. I'm not sure how to track down where the changes were made as I am pretty new to fixing bugs for Sage.

Thanks - I haven't had enough working installations around lately, but this will undoubtedly make it easier to track down.

In fact, I see one thing already - `zip(range(len(data)), data)` is functionally equivalent to `enumerate(data)`, and so apparently someone got too cute.  I should be able to track down where this change was made now momentarily.


---

Comment by kcrisman created at 2014-05-28 00:14:17

Changing component from packages: standard to graphics.


---

Comment by kcrisman created at 2014-05-28 00:14:17

It was basu, in #11787.

```

commit 603ea722edbbd46d2dcde0abb6c85f32ef6cdf18
Author: Punarbasu Purkayastha <ppurka`@`gmail.com>
Date:   Fri Apr 19 15:56:20 2013 +0000

    allow numpy arrays in list_plot, line, points
```

He's very efficient and knowledgeable and it should not be hard to get a fix in soon, maybe even in 6.3.  The reason this wasn't caught is because 

```

    try:
        from sage.rings.all import RDF
        tmp = RDF(data[0])
        data = list(enumerate(data))

```

and in all the examples in the documentation, you ***can*** put the first element in the list into `RDF`!  So we should be more careful; any one element could be complex and that would be enough to need the enumerate.


---

Comment by ppurka created at 2014-05-28 15:21:59

Sorry guys. Looks like I failed to notice this in #11787.

The reason to move away from

```
if not isinstance(data[0], (list, tuple)):
```

is because of the introduction of numpy arrays. The following would break otherwise

```
sage: A = numpy.array([[1,2], [2,3], [3,4]])
sage: list_plot(A)       # this is fine now with the RDF() check

sage: A[0]               # even though A[0] is a two dimensional object...
array([1, 2])            # ... it is neither a tuple nor a list (see below)

sage: isinstance(A[0], (list, tuple))
False
```

I went through many iterations in #11787 to completely avoid importing numpy unnecessarily. I will be adding a patch shortly to check for elements in `SR`.


---

Comment by ppurka created at 2014-05-28 15:59:23

Patch is up for review. Passes all doctests in sage/plot. `<sup>.</sup>`
----
New commits:


---

Comment by ppurka created at 2014-05-28 15:59:23

Changing status from new to needs_review.


---

Comment by kcrisman created at 2014-05-28 16:21:27

I'm not sure I buy this, though.  What if the result is complex but not in the symbolic ring?  (Or are even things in CDF also in SR?)


---

Comment by ppurka created at 2014-05-28 18:14:10

Replying to [comment:13 kcrisman]:
> I'm not sure I buy this, though.  What if the result is complex but not in the symbolic ring?  (Or are even things in CDF also in SR?) 

If it is complex but not in the symbolic ring, then it is automatically handled by `line()` and `point()` directly. These inputs are tested [here](https://github.com/sagemath/sage/blob/master/src/sage/plot/plot.py#L1701), [here](https://github.com/sagemath/sage/blob/master/src/sage/plot/plot.py#L1692), and possibly also in `line` and `point` docstrings.

If they fail `tmp = RDF(data[0])`, they will be handled correctly by `line` and/or `point`. All I have done in the above patch is make sure `SR` is taken care of separately.


EDIT: References in `line` and `point`: [here](https://github.com/sagemath/sage/blob/master/src/sage/plot/line.py#L404), [here](https://github.com/sagemath/sage/blob/master/src/sage/plot/point.py#L388).


---

Comment by kcrisman created at 2014-05-28 19:55:09

> > I'm not sure I buy this, though.  What if the result is complex but not in the symbolic ring?  (Or are even things in CDF also in SR?) 
> 
> If it is complex but not in the symbolic ring, then it is automatically handled by `line()` and `point()` directly. These inputs are tested [here](https://github.com/sagemath/sage/blob/master/src/sage/plot/plot.py#L1701), [here](https://github.com/sagemath/sage/blob/master/src/sage/plot/plot.py#L1692), and possibly also in `line` and `point` docstrings.
> 
> If they fail `tmp = RDF(data[0])`, they will be handled correctly by `line` and/or `point`. All I have done in the above patch is make sure `SR` is taken care of separately.

Okay, just thinking out loud here... what if the first element is in SR but not following ones, or vice versa?  (My guess is you've thought of that, but the `data[0]` just makes me nervous.)


---

Comment by ppurka created at 2014-05-29 01:42:36

Replying to [comment:15 kcrisman]:
> Okay, just thinking out loud here... what if the first element is in SR but not following ones, or vice versa?  (My guess is you've thought of that, but the `data[0]` just makes me nervous.)

They have always worked fine before (before my numpy patch). I just added some tests to indicate that it is possible to mix and match SR, CC and reals.


---

Comment by git created at 2014-05-29 01:43:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kcrisman created at 2014-08-15 10:58:54

Changing status from needs_review to positive_review.


---

Comment by kcrisman created at 2014-08-15 10:58:54

Got a little time to test... This is interesting because

```
sage: list_plot([1,2,3])
sage: list_plot([1,i,3])
```

so it switches from the one form of list plot to the other.   But whatever, this is good.


---

Comment by vbraun created at 2014-08-16 09:32:23

Resolution: fixed
