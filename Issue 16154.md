# Issue 16154: Helper functions for OA constructions

archive/issues_016154.json:
```json
{
    "body": "CC:  @videlec @KPanComputes @brettpim\n\nThis adds two helper functions that are heavily used by all the OA construction routines that I currently implement. Aaaaaaand which will be in Sage asap !\n\nNathann\n\nIssue created by migration from https://trac.sagemath.org/ticket/16391\n\n",
    "created_at": "2014-05-23T15:34:07Z",
    "labels": [
        "component: combinatorial designs"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.3",
    "title": "Helper functions for OA constructions",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16154",
    "user": "https://github.com/nathanncohen"
}
```
CC:  @videlec @KPanComputes @brettpim

This adds two helper functions that are heavily used by all the OA construction routines that I currently implement. Aaaaaaand which will be in Sage asap !

Nathann

Issue created by migration from https://trac.sagemath.org/ticket/16391





---

archive/issue_comments_210573.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-05-23T15:35:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210573",
    "user": "https://github.com/nathanncohen"
}
```

New commits:



---

archive/issue_comments_210574.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-05-23T15:35:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210574",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_210575.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-26T12:58:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210575",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210576.json:
```json
{
    "body": "Small update to find an \"independent set of order x\" with a Linear Program.\n\n- Calling `Graph.independent_set()` would work but the function could take forever trying to decide if there exists an independent set of order 14 or 15 when we only need 2.\n\n- Calling `subgraph_search` as was done just before this commit is a bad algorithm when there are no solutions. A VERY bad algorithm `:-P`\n\nNathann",
    "created_at": "2014-05-29T17:50:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210576",
    "user": "https://github.com/nathanncohen"
}
```

Small update to find an "independent set of order x" with a Linear Program.

- Calling `Graph.independent_set()` would work but the function could take forever trying to decide if there exists an independent set of order 14 or 15 when we only need 2.

- Calling `subgraph_search` as was done just before this commit is a bad algorithm when there are no solutions. A VERY bad algorithm `:-P`

Nathann



---

archive/issue_comments_210577.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-29T17:55:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210577",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210578.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-02T10:50:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210578",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210579.json:
```json
{
    "body": "Hi Nathann,\n\nI switch to this one from #16361 because of the comment I wrote there. But in the function `OA_with_holes` implemented in the branch associated to that ticket, you do strictly the same thing. You rely heavily on the output of `designs.orthogonal_array(k,n)` whose specifications are : \"Returns **an** orthogonal array with parameters (k,n)\". It is neither intended to be constant over time (and you do not want to impose that) and it is not optimized with respect to any property. One reason is that we want to shortcut as possible the recursive constructions which are time consuming. If someone comes with a nice one parameter family of `OA(k, k^2 + 3*k + 19)` we would use that first whatever it breaks elsewhere.\n\nYou can not reasonably force the implementation of `designs.orthogonal_array` to output something optimal with respect to the property you are interested in today. It might really be that tomorrow, you would prefer to have a `designs.orthogonal_array` with very few multiplicity of `TD(k,1)` in it.\n\nRight now, we have several constructions of OA with the same parameters (for example, several Wilson construction might be available). The multiplicity of `TD(k,1)` you obtain must strongly depend on the way you did your construction and **we do not want** that `designs.orthogonal_array` takes this strategy.\n\nVincent",
    "created_at": "2014-06-03T11:19:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210579",
    "user": "https://github.com/videlec"
}
```

Hi Nathann,

I switch to this one from #16361 because of the comment I wrote there. But in the function `OA_with_holes` implemented in the branch associated to that ticket, you do strictly the same thing. You rely heavily on the output of `designs.orthogonal_array(k,n)` whose specifications are : "Returns **an** orthogonal array with parameters (k,n)". It is neither intended to be constant over time (and you do not want to impose that) and it is not optimized with respect to any property. One reason is that we want to shortcut as possible the recursive constructions which are time consuming. If someone comes with a nice one parameter family of `OA(k, k^2 + 3*k + 19)` we would use that first whatever it breaks elsewhere.

You can not reasonably force the implementation of `designs.orthogonal_array` to output something optimal with respect to the property you are interested in today. It might really be that tomorrow, you would prefer to have a `designs.orthogonal_array` with very few multiplicity of `TD(k,1)` in it.

Right now, we have several constructions of OA with the same parameters (for example, several Wilson construction might be available). The multiplicity of `TD(k,1)` you obtain must strongly depend on the way you did your construction and **we do not want** that `designs.orthogonal_array` takes this strategy.

Vincent



---

archive/issue_comments_210580.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2014-06-03T11:19:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210580",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_210581.json:
```json
{
    "body": "Yo Vincent !\n\nI cannot claim that `OA_with_holes` will always output \"optimal results\", and I never did.\n\nI need those designs for constructions of OA that we cannot build at the moment, and I have no other way to produce them. What is the problem with seeing this function as \n\n1) When x<=3 we know that it exists\n\n2) When there is a `OA(k+1,n)` we know that it exists\n\n3) If everything else fails, see if you are lucky\n\nAnd you want me to remove feature 3), even though it does return helpful things. I never claimed that the results would not change, and what I know for sure is that the results WILL improve as we add new OA. It is true, I cannot prove that eventually feature 3) will never become less powerful.\n\nAnd so what ? Do I throw all my useful code away because of that ? I really have no other way to generate these designs.\n\n> The multiplicity of TD(k,1) you obtain must strongly depend on the way you did your construction\n\nWe have no proof of that. And I did not claim the contrary, but we have no proof of that. For instance the proof that it always exists when x<=3 is the proof that any OA contains an independent set of size 3, which means that the result will always hold in this case regardless of which OA is returned.\n\nNathann",
    "created_at": "2014-06-03T11:29:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210581",
    "user": "https://github.com/nathanncohen"
}
```

Yo Vincent !

I cannot claim that `OA_with_holes` will always output "optimal results", and I never did.

I need those designs for constructions of OA that we cannot build at the moment, and I have no other way to produce them. What is the problem with seeing this function as 

1) When x<=3 we know that it exists

2) When there is a `OA(k+1,n)` we know that it exists

3) If everything else fails, see if you are lucky

And you want me to remove feature 3), even though it does return helpful things. I never claimed that the results would not change, and what I know for sure is that the results WILL improve as we add new OA. It is true, I cannot prove that eventually feature 3) will never become less powerful.

And so what ? Do I throw all my useful code away because of that ? I really have no other way to generate these designs.

> The multiplicity of TD(k,1) you obtain must strongly depend on the way you did your construction

We have no proof of that. And I did not claim the contrary, but we have no proof of that. For instance the proof that it always exists when x<=3 is the proof that any OA contains an independent set of size 3, which means that the result will always hold in this case regardless of which OA is returned.

Nathann



---

archive/issue_comments_210582.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2014-06-03T11:37:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210582",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_210583.json:
```json
{
    "body": "(by the way, the \"independent set\" problem makes it independent from the actual labelling of the OA. Even though, of course, it says nothing about non-isomorphic OA)",
    "created_at": "2014-06-03T11:37:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210583",
    "user": "https://github.com/nathanncohen"
}
```

(by the way, the "independent set" problem makes it independent from the actual labelling of the OA. Even though, of course, it says nothing about non-isomorphic OA)



---

archive/issue_comments_210584.json:
```json
{
    "body": "Hi Nathann,\n\nThanks for your clarification.\n\nReplying to [comment:8 ncohen]:\n> I cannot claim that `OA_with_holes` will always output \"optimal results\", and I never did.\n> \n> I need those designs for constructions of OA that we cannot build at the moment, and I have no other way to produce them. What is the problem with seeing this function as \n> \n> 1) When k<=3 we know that it exists\n> 2) When there is a `OA(k+1,n)` we know that it exists\n> 3) If everything else fails, see if you are lucky\n> \n> And you want me to remove feature 3), even though it does return helpful things. I never claimed that the results would not change, and what I know for sure is that the results WILL improve as we add new OA. It is true, I cannot prove that eventually feature 3) will never become less powerful.\n\nI do not want you to remove it but I do not want to see code or doctests that depend on the lucky case 3). Which implies that you should not use `k > 3` anywhere. In the current ticket this function is not used at all, so... Where this code is merged with #16391?\n \n> > The multiplicity of TD(k,1) you obtain must strongly depend on the way you did your construction\n> \n> We have no proof of that. And I did not claim the contrary, but we have no proof of that. For instance the proof that it always exists when k<=3 is the proof that any OA contains an independent set of size 3, which means that the result will always hold in this case regardless of which OA is returned.\n\nIs there a way to find the largest set of disjoint blocks?\n\nVincent",
    "created_at": "2014-06-03T11:41:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210584",
    "user": "https://github.com/videlec"
}
```

Hi Nathann,

Thanks for your clarification.

Replying to [comment:8 ncohen]:
> I cannot claim that `OA_with_holes` will always output "optimal results", and I never did.
> 
> I need those designs for constructions of OA that we cannot build at the moment, and I have no other way to produce them. What is the problem with seeing this function as 
> 
> 1) When k<=3 we know that it exists
> 2) When there is a `OA(k+1,n)` we know that it exists
> 3) If everything else fails, see if you are lucky
> 
> And you want me to remove feature 3), even though it does return helpful things. I never claimed that the results would not change, and what I know for sure is that the results WILL improve as we add new OA. It is true, I cannot prove that eventually feature 3) will never become less powerful.

I do not want you to remove it but I do not want to see code or doctests that depend on the lucky case 3). Which implies that you should not use `k > 3` anywhere. In the current ticket this function is not used at all, so... Where this code is merged with #16391?
 
> > The multiplicity of TD(k,1) you obtain must strongly depend on the way you did your construction
> 
> We have no proof of that. And I did not claim the contrary, but we have no proof of that. For instance the proof that it always exists when k<=3 is the proof that any OA contains an independent set of size 3, which means that the result will always hold in this case regardless of which OA is returned.

Is there a way to find the largest set of disjoint blocks?

Vincent



---

archive/issue_comments_210585.json:
```json
{
    "body": "Yo !\n\n> I do not want you to remove it but I do not want to see code or doctests that depend on the lucky case 3). Which implies that you should not use `k > 3` anywhere. \n\n....\n\nSo I can implement it but I am forbidden to use it ?...\n\nLook at what you are doing : you are telling me that it is very bad that in the future some OA with holes may not exist anymore, for the very same reason that in the future some OA with holes may become available.\n\nBecause we may change constructions, and because if a change can occur in one direction it can occur in the other direction too.\n\nSo the problem is that the \"performance may change\" in the future, and in both directions. And more importanty that a doctest may be broken because somebody ADDS a construction of an OA we were already able to build, which should not have any effect...\n\nLook man, I have no way around that. I am quite ready to accept that adding a construction may destroy another whose existence could not be proved formally, because this thing is useful for a lot of stuff.\n\nAnd that, again, I have no way around.\n\nAnd that it only returns true results anyway.\n\nIt is a heuristic. It returns true things, but it may not always find them.\n\n> In the current ticket this function is not used at all, so... Where this code is merged with #16391?\n\n#16391 is the ticket on which we are talking, so I guess you talk about #16361. And the ticket which makes #16361 use this helper function is Wilson's construction #16347. I gave you the updated version of that code in my last comment on #16361.\n\n> Is there a way to find the largest set of disjoint blocks?\n\nWell, this is precisely what this function does. It solves a maximum independent set problem on the intersection graph. On a specific OA of course.\n\nIf you want to know if theory knows what the largest set of disjoint blocks for any k,n I expect that the answer is no. If there exists an OA(k+1,n) there there exists an OA(k,n)-n.OA(k,1) but it is apparently not an equivalence.\n\nNathann",
    "created_at": "2014-06-03T11:57:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210585",
    "user": "https://github.com/nathanncohen"
}
```

Yo !

> I do not want you to remove it but I do not want to see code or doctests that depend on the lucky case 3). Which implies that you should not use `k > 3` anywhere. 

....

So I can implement it but I am forbidden to use it ?...

Look at what you are doing : you are telling me that it is very bad that in the future some OA with holes may not exist anymore, for the very same reason that in the future some OA with holes may become available.

Because we may change constructions, and because if a change can occur in one direction it can occur in the other direction too.

So the problem is that the "performance may change" in the future, and in both directions. And more importanty that a doctest may be broken because somebody ADDS a construction of an OA we were already able to build, which should not have any effect...

Look man, I have no way around that. I am quite ready to accept that adding a construction may destroy another whose existence could not be proved formally, because this thing is useful for a lot of stuff.

And that, again, I have no way around.

And that it only returns true results anyway.

It is a heuristic. It returns true things, but it may not always find them.

> In the current ticket this function is not used at all, so... Where this code is merged with #16391?

#16391 is the ticket on which we are talking, so I guess you talk about #16361. And the ticket which makes #16361 use this helper function is Wilson's construction #16347. I gave you the updated version of that code in my last comment on #16361.

> Is there a way to find the largest set of disjoint blocks?

Well, this is precisely what this function does. It solves a maximum independent set problem on the intersection graph. On a specific OA of course.

If you want to know if theory knows what the largest set of disjoint blocks for any k,n I expect that the answer is no. If there exists an OA(k+1,n) there there exists an OA(k,n)-n.OA(k,1) but it is apparently not an equivalence.

Nathann



---

archive/issue_comments_210586.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-05T10:48:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210586",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210587.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2014-06-06T19:05:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210587",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_210588.json:
```json
{
    "body": "Hi,\n\n1) What you called OA with holes are \"incomplete orthogonal array\" in the Handbook (as well as their sisters \"incomplete transversal design\" and \"incomplete set of MOLS\"). See p 193-194. And the one you are interested in, the \"OA(k,n) - x.OA(k,1)\", are also denoted \"OA(k,n; 1, ..., 1)\". Am I right? If this is true, I would rather write a function `incomplete_orthogonal_array(k,n,holes)` where holes is a tuple of integers to fit with the standard names and notations. I also saw some general results in the Handbook (Theorems 4.16 and 4.17) about one hole and k=4,5... and a beautiful table of IMOLS.\n\n2) From the function you wrote, it is very easy to\n- allow `x` as None, in which case the function tries to optimize the number of holes\n- have an optional argument `OA` such that, if it is provided, the function looks for holes inside this orthogonal array.\n\nI did the change myself but the function looks a bit uglier so I am not sure what to do. I would like to have those two functions to study the number of holes depending on the OA. But on the other hand, I tried with the OA(4,10) that we have but it took lifetime to obtain the answer 9.\n\nA perhaps cleaner way to do things is to have two functions that would looks like\n- `incomplete_orthogonal_array(k,n,holes)` (this function would be available from the global namespace)\n- `look_for_holes_in_my_OA(OA,k,n,holes)`\n\nWhat do you think?\n\nVincent",
    "created_at": "2014-06-06T19:05:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210588",
    "user": "https://github.com/videlec"
}
```

Hi,

1) What you called OA with holes are "incomplete orthogonal array" in the Handbook (as well as their sisters "incomplete transversal design" and "incomplete set of MOLS"). See p 193-194. And the one you are interested in, the "OA(k,n) - x.OA(k,1)", are also denoted "OA(k,n; 1, ..., 1)". Am I right? If this is true, I would rather write a function `incomplete_orthogonal_array(k,n,holes)` where holes is a tuple of integers to fit with the standard names and notations. I also saw some general results in the Handbook (Theorems 4.16 and 4.17) about one hole and k=4,5... and a beautiful table of IMOLS.

2) From the function you wrote, it is very easy to
- allow `x` as None, in which case the function tries to optimize the number of holes
- have an optional argument `OA` such that, if it is provided, the function looks for holes inside this orthogonal array.

I did the change myself but the function looks a bit uglier so I am not sure what to do. I would like to have those two functions to study the number of holes depending on the OA. But on the other hand, I tried with the OA(4,10) that we have but it took lifetime to obtain the answer 9.

A perhaps cleaner way to do things is to have two functions that would looks like
- `incomplete_orthogonal_array(k,n,holes)` (this function would be available from the global namespace)
- `look_for_holes_in_my_OA(OA,k,n,holes)`

What do you think?

Vincent



---

archive/issue_comments_210589.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2014-06-07T08:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210589",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_210590.json:
```json
{
    "body": "Yo !\n\n> 1) What you called OA with holes are \"incomplete orthogonal array\" in the Handbook\n\nI see I see. Somehow I think that I was mixing together \"incomplete TD\" and \"truncated TD\". For me an \"incomplete TD\" could be an OA truncated in any way, though it seems that it actually is a \"nicely truncated TD\", i.e. that the missing stuff can potentially be filled with others TD.\n\nNote that I have no clue how I could compute a decomposition of a TD with holes of size > 1. No idea.\n\n> (as well as their sisters \"incomplete transversal design\" and \"incomplete set of MOLS\"). See p 193-194. And the one you are interested in, the \"OA(k,n) - x.OA(k,1)\", are also denoted \"OA(k,n; 1, ..., 1)\". Am I right? If this is true, I would rather write a function `incomplete_orthogonal_array(k,n,holes)` where holes is a tuple of integers to fit with the standard names and notations. I also saw some general results in the Handbook (Theorems 4.16 and 4.17) about one hole and k=4,5... and a beautiful table of IMOLS.\n\nOkay, then we can implement it like that : `incomplete_transversal_design(k,n,tuple_of_hole_sizes,OA=None)`.\n\nThe function would return an exception whenever there is an element in tuple_of_hole_sizes which is not equal to 1, and if `OA` is defined then it is the OA that will be used to compute the holes ?\n\n> 2) From the function you wrote, it is very easy to\n> - allow `x` as None, in which case the function tries to optimize the number of holes\n\nHoles of size 1.\n\n> - have an optional argument `OA` such that, if it is provided, the function looks for holes inside this orthogonal array.\n\nYepyep.\n\n> I did the change myself but the function looks a bit uglier so I am not sure what to do. I would like to have those two functions to study the number of holes depending on the OA. But on the other hand, I tried with the OA(4,10) that we have but it took lifetime to obtain the answer 9.\n\nYep. I tried different things an really this small LP appears to be the best choice. If we make the optimization available then we will have to call `Graph.independent_set`.\n\n> A perhaps cleaner way to do things is to have two functions that would looks like\n> - `incomplete_orthogonal_array(k,n,holes)` (this function would be available from the global namespace)\n\nYepyep, this could be `designs.incomplete_orthogonal_array`\n\n> - `look_for_holes_in_my_OA(OA,k,n,holes)`\n\nI would not know where to write that. It does not belong to `designs.<tab>`. We could write it somewhere in the `orthogonal_array` file, to let it be exposed later when all this will have become a class.\n\n> What do you think?\n\nWhat do you think ? Answer my questions above and I will write the code. And rebase what needs to be, above.\n\nNathann",
    "created_at": "2014-06-07T08:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210590",
    "user": "https://github.com/nathanncohen"
}
```

Yo !

> 1) What you called OA with holes are "incomplete orthogonal array" in the Handbook

I see I see. Somehow I think that I was mixing together "incomplete TD" and "truncated TD". For me an "incomplete TD" could be an OA truncated in any way, though it seems that it actually is a "nicely truncated TD", i.e. that the missing stuff can potentially be filled with others TD.

Note that I have no clue how I could compute a decomposition of a TD with holes of size > 1. No idea.

> (as well as their sisters "incomplete transversal design" and "incomplete set of MOLS"). See p 193-194. And the one you are interested in, the "OA(k,n) - x.OA(k,1)", are also denoted "OA(k,n; 1, ..., 1)". Am I right? If this is true, I would rather write a function `incomplete_orthogonal_array(k,n,holes)` where holes is a tuple of integers to fit with the standard names and notations. I also saw some general results in the Handbook (Theorems 4.16 and 4.17) about one hole and k=4,5... and a beautiful table of IMOLS.

Okay, then we can implement it like that : `incomplete_transversal_design(k,n,tuple_of_hole_sizes,OA=None)`.

The function would return an exception whenever there is an element in tuple_of_hole_sizes which is not equal to 1, and if `OA` is defined then it is the OA that will be used to compute the holes ?

> 2) From the function you wrote, it is very easy to
> - allow `x` as None, in which case the function tries to optimize the number of holes

Holes of size 1.

> - have an optional argument `OA` such that, if it is provided, the function looks for holes inside this orthogonal array.

Yepyep.

> I did the change myself but the function looks a bit uglier so I am not sure what to do. I would like to have those two functions to study the number of holes depending on the OA. But on the other hand, I tried with the OA(4,10) that we have but it took lifetime to obtain the answer 9.

Yep. I tried different things an really this small LP appears to be the best choice. If we make the optimization available then we will have to call `Graph.independent_set`.

> A perhaps cleaner way to do things is to have two functions that would looks like
> - `incomplete_orthogonal_array(k,n,holes)` (this function would be available from the global namespace)

Yepyep, this could be `designs.incomplete_orthogonal_array`

> - `look_for_holes_in_my_OA(OA,k,n,holes)`

I would not know where to write that. It does not belong to `designs.<tab>`. We could write it somewhere in the `orthogonal_array` file, to let it be exposed later when all this will have become a class.

> What do you think?

What do you think ? Answer my questions above and I will write the code. And rebase what needs to be, above.

Nathann



---

archive/issue_comments_210591.json:
```json
{
    "body": "Hello,\n\nReplying to [comment:14 ncohen]:\n> Yo !\n> \n> > 1) What you called OA with holes are \"incomplete orthogonal array\" in the Handbook\n> \n> I see I see. Somehow I think that I was mixing together \"incomplete TD\" and \"truncated TD\". For me an \"incomplete TD\" could be an OA truncated in any way, though it seems that it actually is a \"nicely truncated TD\", i.e. that the missing stuff can potentially be filled with others TD.\n> \n> Note that I have no clue how I could compute a decomposition of a TD with holes of size > 1. No idea.\n\nFor now, we do not care. But there are examples and references in the Handbook.\n\n> Okay, then we can implement it like that : `incomplete_transversal_design(k,n,tuple_of_hole_sizes,OA=None)`.\n> \n> The function would return an exception whenever there is an element in tuple_of_hole_sizes which is not equal to 1, and if `OA` is defined then it is the OA that will be used to compute the holes ?\n\nPerfect. It is a bit dummy but it is more terminology compliant and lets the door open.\n\n> > 2) From the function you wrote, it is very easy to\n> > - allow `x` as None, in which case the function tries to optimize the number of holes\n> \n> Holes of size 1.\n\nyes. my mistake.\n \n> > - have an optional argument `OA` such that, if it is provided, the function looks for holes inside this orthogonal array.\n> \n> Yepyep.\n> \n> > I did the change myself but the function looks a bit uglier so I am not sure what to do. I would like to have those two functions to study the number of holes depending on the OA. But on the other hand, I tried with the OA(4,10) that we have but it took lifetime to obtain the answer 9.\n> \n> Yep. I tried different things and really this small LP appears to be the best choice. If we make the optimization available then we will have to call `Graph.independent_set`.\n\nWith the OA(4,10) that has 100 blocks, what would be the best strategy? It took me more than a minute with the MILP (using either glpk or cbc).\n\n> > A perhaps cleaner way to do things is to have two functions that would looks like\n> > - `incomplete_orthogonal_array(k,n,holes)` (this function would be available from the global namespace)\n> \n> Yepyep, this could be `designs.incomplete_orthogonal_array`\n\nGreat!\n\n> > - `look_for_holes_in_my_OA(OA,k,n,holes)`\n> \n> I would not know where to write that. It does not belong to `designs.<tab>`. We could write it somewhere in the `orthogonal_array` file, to let it be exposed later when all this will have become a class.\n\nThis is what I meant, not a public function. You can call it whatever you want. But I really would like that it accepts an optional OA as argument in the very same way `graphs.OrthogonalArrayBlockGraph` does. Perhaps a more appropriate name would be, `OA_find_disjoint_block`?\n\nVincent",
    "created_at": "2014-06-07T09:12:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210591",
    "user": "https://github.com/videlec"
}
```

Hello,

Replying to [comment:14 ncohen]:
> Yo !
> 
> > 1) What you called OA with holes are "incomplete orthogonal array" in the Handbook
> 
> I see I see. Somehow I think that I was mixing together "incomplete TD" and "truncated TD". For me an "incomplete TD" could be an OA truncated in any way, though it seems that it actually is a "nicely truncated TD", i.e. that the missing stuff can potentially be filled with others TD.
> 
> Note that I have no clue how I could compute a decomposition of a TD with holes of size > 1. No idea.

For now, we do not care. But there are examples and references in the Handbook.

> Okay, then we can implement it like that : `incomplete_transversal_design(k,n,tuple_of_hole_sizes,OA=None)`.
> 
> The function would return an exception whenever there is an element in tuple_of_hole_sizes which is not equal to 1, and if `OA` is defined then it is the OA that will be used to compute the holes ?

Perfect. It is a bit dummy but it is more terminology compliant and lets the door open.

> > 2) From the function you wrote, it is very easy to
> > - allow `x` as None, in which case the function tries to optimize the number of holes
> 
> Holes of size 1.

yes. my mistake.
 
> > - have an optional argument `OA` such that, if it is provided, the function looks for holes inside this orthogonal array.
> 
> Yepyep.
> 
> > I did the change myself but the function looks a bit uglier so I am not sure what to do. I would like to have those two functions to study the number of holes depending on the OA. But on the other hand, I tried with the OA(4,10) that we have but it took lifetime to obtain the answer 9.
> 
> Yep. I tried different things and really this small LP appears to be the best choice. If we make the optimization available then we will have to call `Graph.independent_set`.

With the OA(4,10) that has 100 blocks, what would be the best strategy? It took me more than a minute with the MILP (using either glpk or cbc).

> > A perhaps cleaner way to do things is to have two functions that would looks like
> > - `incomplete_orthogonal_array(k,n,holes)` (this function would be available from the global namespace)
> 
> Yepyep, this could be `designs.incomplete_orthogonal_array`

Great!

> > - `look_for_holes_in_my_OA(OA,k,n,holes)`
> 
> I would not know where to write that. It does not belong to `designs.<tab>`. We could write it somewhere in the `orthogonal_array` file, to let it be exposed later when all this will have become a class.

This is what I meant, not a public function. You can call it whatever you want. But I really would like that it accepts an optional OA as argument in the very same way `graphs.OrthogonalArrayBlockGraph` does. Perhaps a more appropriate name would be, `OA_find_disjoint_block`?

Vincent



---

archive/issue_comments_210592.json:
```json
{
    "body": "Sorry, I meant\n\n- `designs.incomplete_transversal_design(k,n,holes)`   <--- no OA argument here\n- a private `OA_find_disjoint_blocks(k,n,x,OA=None)`\n\nAnd of course you can use caching on the first one.\n\nVincent",
    "created_at": "2014-06-07T09:14:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210592",
    "user": "https://github.com/videlec"
}
```

Sorry, I meant

- `designs.incomplete_transversal_design(k,n,holes)`   <--- no OA argument here
- a private `OA_find_disjoint_blocks(k,n,x,OA=None)`

And of course you can use caching on the first one.

Vincent



---

archive/issue_comments_210593.json:
```json
{
    "body": "Hello !\n\nHere is the updated code.\n\nAs it is the feature \"give me the maximum number of disjoint blocks\" is not available, but it can be easily added later. This being said if we do that perhaps the best algorithm to use is not the LP solver but rather `graphs.OrthogonalArrayBlockGraph(k,n).independent_set(algorithm=something)`. And it seems that the best something, even though it is an optional package at the moment, may be MCQD #16083.\n\nReady for review again !\n\nNathann",
    "created_at": "2014-06-07T13:48:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210593",
    "user": "https://github.com/nathanncohen"
}
```

Hello !

Here is the updated code.

As it is the feature "give me the maximum number of disjoint blocks" is not available, but it can be easily added later. This being said if we do that perhaps the best algorithm to use is not the LP solver but rather `graphs.OrthogonalArrayBlockGraph(k,n).independent_set(algorithm=something)`. And it seems that the best something, even though it is an optional package at the moment, may be MCQD #16083.

Ready for review again !

Nathann



---

archive/issue_comments_210594.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-07T13:49:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210594",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210595.json:
```json
{
    "body": "Hi,\n\nGreat. But you did not remove the holes! An `IOA(k,n; h_1, ..., h_s)` must have `n^2 - sum(h_i^2)` blocks. Would that be hard to adapt?\n\nI wrote a function `is_incomplete_orthogonal_array` but I do not want interferences with #16295. I will attach the file to the ticket.\n\nVincent",
    "created_at": "2014-06-07T16:03:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210595",
    "user": "https://github.com/videlec"
}
```

Hi,

Great. But you did not remove the holes! An `IOA(k,n; h_1, ..., h_s)` must have `n^2 - sum(h_i^2)` blocks. Would that be hard to adapt?

I wrote a function `is_incomplete_orthogonal_array` but I do not want interferences with #16295. I will attach the file to the ticket.

Vincent



---

archive/issue_comments_210596.json:
```json
{
    "body": "Attachment [is_incomplete_orthogonal_array.py](tarball://root/attachments/some-uuid/ticket16391/is_incomplete_orthogonal_array.py) by @videlec created at 2014-06-07 16:03:58\n\nan implementation of is_incomplete_orthogonal_array",
    "created_at": "2014-06-07T16:03:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210596",
    "user": "https://github.com/videlec"
}
```

Attachment [is_incomplete_orthogonal_array.py](tarball://root/attachments/some-uuid/ticket16391/is_incomplete_orthogonal_array.py) by @videlec created at 2014-06-07 16:03:58

an implementation of is_incomplete_orthogonal_array



---

archive/issue_comments_210597.json:
```json
{
    "body": "Changing status from needs_review to needs_info.",
    "created_at": "2014-06-07T16:04:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210597",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to needs_info.



---

archive/issue_comments_210598.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-07T19:17:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210598",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210599.json:
```json
{
    "body": "Back to needs_review !\n\nNathann",
    "created_at": "2014-06-07T19:26:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210599",
    "user": "https://github.com/nathanncohen"
}
```

Back to needs_review !

Nathann



---

archive/issue_comments_210600.json:
```json
{
    "body": "Changing status from needs_info to needs_review.",
    "created_at": "2014-06-07T19:26:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210600",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_info to needs_review.



---

archive/issue_comments_210601.json:
```json
{
    "body": "Ouch. I had a commit for that...\n\n- why are you using tuples instead of lists?\n- there is a problem for holes_sizes=(1,)\n\nYou can look at what I did at u/vdelecroix/16391\n\nVincent",
    "created_at": "2014-06-07T19:33:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210601",
    "user": "https://github.com/videlec"
}
```

Ouch. I had a commit for that...

- why are you using tuples instead of lists?
- there is a problem for holes_sizes=(1,)

You can look at what I did at u/vdelecroix/16391

Vincent



---

archive/issue_comments_210602.json:
```json
{
    "body": "Yo !\n\n> - why are you using tuples instead of lists?\n\nWhat do you mean ? For the caching ? If so, that's because you get an exception when a `@`cached_method gets a non-hashable input.\n\n> - there is a problem for holes_sizes=(1,)\n\n`O_o`\n\nFunny. I fixed it, but I am pretty sure I had fixed it before in the very same way/trick. Weird `O_o`\n\nNathann",
    "created_at": "2014-06-07T21:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210602",
    "user": "https://github.com/nathanncohen"
}
```

Yo !

> - why are you using tuples instead of lists?

What do you mean ? For the caching ? If so, that's because you get an exception when a `@`cached_method gets a non-hashable input.

> - there is a problem for holes_sizes=(1,)

`O_o`

Funny. I fixed it, but I am pretty sure I had fixed it before in the very same way/trick. Weird `O_o`

Nathann



---

archive/issue_comments_210603.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-07T21:40:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210603",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210604.json:
```json
{
    "body": "Oh. I had fixed it in \"trac #16347: Genelarized Wilson construction\" `:-P`\n\nNathann",
    "created_at": "2014-06-08T07:37:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210604",
    "user": "https://github.com/nathanncohen"
}
```

Oh. I had fixed it in "trac #16347: Genelarized Wilson construction" `:-P`

Nathann



---

archive/issue_comments_210605.json:
```json
{
    "body": "Replying to [comment:25 ncohen]:\n> Yo !\n> \n> > - why are you using tuples instead of lists?\n> \n> What do you mean ? For the caching ? If so, that's because you get an exception when a `@`cached_method gets a non-hashable input.\n\nI mean for the output!",
    "created_at": "2014-06-08T09:45:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210605",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:25 ncohen]:
> Yo !
> 
> > - why are you using tuples instead of lists?
> 
> What do you mean ? For the caching ? If so, that's because you get an exception when a `@`cached_method gets a non-hashable input.

I mean for the output!



---

archive/issue_comments_210606.json:
```json
{
    "body": "Oh. I see. Then, that's because if you cache the output of a function and that this output is mutable, there is no certainty that users will not change the content of the cache by modifying the result returned by the function.\n\nThat's why I was forced to convert to \"tuple\" the output of `orthogonal_array` in #16347, which I totally hate. But I will rewrite this to only cache the boolean values, I will implement this manually as soon as all the dependencies are reviewed.\n\nThat's also why it is painful to not be able to cache only what you want.\n\nNathann",
    "created_at": "2014-06-08T09:55:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210606",
    "user": "https://github.com/nathanncohen"
}
```

Oh. I see. Then, that's because if you cache the output of a function and that this output is mutable, there is no certainty that users will not change the content of the cache by modifying the result returned by the function.

That's why I was forced to convert to "tuple" the output of `orthogonal_array` in #16347, which I totally hate. But I will rewrite this to only cache the boolean values, I will implement this manually as soon as all the dependencies are reviewed.

That's also why it is painful to not be able to cache only what you want.

Nathann



---

archive/issue_comments_210607.json:
```json
{
    "body": "\n```\nsage: @cached_function\n....: def a():\n....:     return []\n....: \nsage: a()\n[]\nsage: x=a()\nsage: x.append(8)\nsage: a()\n[8]\n```\n",
    "created_at": "2014-06-08T09:55:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210607",
    "user": "https://github.com/nathanncohen"
}
```


```
sage: @cached_function
....: def a():
....:     return []
....: 
sage: a()
[]
sage: x=a()
sage: x.append(8)
sage: a()
[8]
```




---

archive/issue_comments_210608.json:
```json
{
    "body": "Hi,\n\nSome small changes in u/vdelecroix/16391 (above your last commit). The modification of the `NOTE` is the most important one (it was wrong before).\n\nI really do not like the fact that `designs.orthogonal_array` return list of lists while `designs.incomplete_orthogonal_array` returns tuple of tuples. Can we make all tuple of tuples (at least in a later ticket)?\n\nBeyond that, I am happy with the ticket.\n\nVincent\n\nPS: the search of disjoint blocks for the OA(4,10) is **much** faster using increasing values of `x` instead of a `set_objective`...",
    "created_at": "2014-06-08T17:08:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210608",
    "user": "https://github.com/videlec"
}
```

Hi,

Some small changes in u/vdelecroix/16391 (above your last commit). The modification of the `NOTE` is the most important one (it was wrong before).

I really do not like the fact that `designs.orthogonal_array` return list of lists while `designs.incomplete_orthogonal_array` returns tuple of tuples. Can we make all tuple of tuples (at least in a later ticket)?

Beyond that, I am happy with the ticket.

Vincent

PS: the search of disjoint blocks for the OA(4,10) is **much** faster using increasing values of `x` instead of a `set_objective`...



---

archive/issue_comments_210609.json:
```json
{
    "body": "Yo !\n\n> Some small changes in u/vdelecroix/16391 (above your last commit). The modification of the `NOTE` is the most important one (it was wrong before).\n\nWas it ? I thought that your version was wrong too, so I added a commit. What do you think ?\n\n> I really do not like the fact that `designs.orthogonal_array` return list of lists while `designs.incomplete_orthogonal_array` returns tuple of tuples. Can we make all tuple of tuples (at least in a later ticket)?\n\nI do not want any of them to be tuples. I have no other choice but to make them tuples because nobody is willing to review #16353 which would let me cache only boolean answers (meaning that the constructors could all return lists of lists as it would be best).\n\nIf #16353 is not reviewed I will have no other choice but to implement a chaching method for all three constructors (with a common cache) for booleans answers, and of course yet another one for this function.\n\nWhich is a sheer waste of time.\n\n> Beyond that, I am happy with the ticket.\n\nTell me if you are okay with this additional commit !\n\n> PS: the search of disjoint blocks for the OA(4,10) is **much** faster using increasing values of `x` instead of a `set_objective`...\n\nThat's because when you give it the number of disjoint blocks it does not have to prove that you cannot find a strictly larger set of blocks by itself. If `k` is the largest amount of disjoint blocks in a `OA(4,10)` try with value `k+1`. Should take the same time.\n\nNathann",
    "created_at": "2014-06-08T18:35:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210609",
    "user": "https://github.com/nathanncohen"
}
```

Yo !

> Some small changes in u/vdelecroix/16391 (above your last commit). The modification of the `NOTE` is the most important one (it was wrong before).

Was it ? I thought that your version was wrong too, so I added a commit. What do you think ?

> I really do not like the fact that `designs.orthogonal_array` return list of lists while `designs.incomplete_orthogonal_array` returns tuple of tuples. Can we make all tuple of tuples (at least in a later ticket)?

I do not want any of them to be tuples. I have no other choice but to make them tuples because nobody is willing to review #16353 which would let me cache only boolean answers (meaning that the constructors could all return lists of lists as it would be best).

If #16353 is not reviewed I will have no other choice but to implement a chaching method for all three constructors (with a common cache) for booleans answers, and of course yet another one for this function.

Which is a sheer waste of time.

> Beyond that, I am happy with the ticket.

Tell me if you are okay with this additional commit !

> PS: the search of disjoint blocks for the OA(4,10) is **much** faster using increasing values of `x` instead of a `set_objective`...

That's because when you give it the number of disjoint blocks it does not have to prove that you cannot find a strictly larger set of blocks by itself. If `k` is the largest amount of disjoint blocks in a `OA(4,10)` try with value `k+1`. Should take the same time.

Nathann



---

archive/issue_comments_210610.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-08T18:35:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210610",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210611.json:
```json
{
    "body": "Hi Nathann,\n\nI do not agree with your corrections. By definition, the holes are subsets of the ground set `V = {0,...,n-1}`. Perhaps it depend on where we read the definition.\n\nCould we just get rid of the caching and return list of lists in the very same way as `orthogonal_array`? The time needed to find 3 disjoint blocks is not big compared to the time you need to build an orthogonal array. It would make more sense to implement the caching at the level of `orthogonal_array`. And I think, it would better if done in another ticket.\n\nVincent",
    "created_at": "2014-06-09T07:43:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210611",
    "user": "https://github.com/videlec"
}
```

Hi Nathann,

I do not agree with your corrections. By definition, the holes are subsets of the ground set `V = {0,...,n-1}`. Perhaps it depend on where we read the definition.

Could we just get rid of the caching and return list of lists in the very same way as `orthogonal_array`? The time needed to find 3 disjoint blocks is not big compared to the time you need to build an orthogonal array. It would make more sense to implement the caching at the level of `orthogonal_array`. And I think, it would better if done in another ticket.

Vincent



---

archive/issue_comments_210612.json:
```json
{
    "body": "Yo !\n\n> I do not agree with your corrections. By definition, the holes are subsets of the ground set `V = {0,...,n-1}`. Perhaps it depend on where we read the definition.\n\nWell, I did not find definition of incomplete OA in the handbook though they define incomplete transversal designs, and for this they introduce sets `H_1,H_2, ...`. Well, to define a hole in general you need to give a subset for each column... Your phrasing assumes that the OA has been relabelled so that the coordinates of the hole are the same in every column... But honestly everybody would understand it the way it is, adding this `^k` just emphasizes that we give the coordinate for every column.\n\n> Could we just get rid of the caching and return list of lists in the very same way as `orthogonal_array`? \n\nDon't you want to review #16353 ? This would make everything MUCH easier.\n\nI am willing to implement this correctly and -- if posible -- uniformly, but if people refuse to review stuff like #16353 for theological reasons then I am stuck, and I have no other way but to find workarounds.\n\nIn the constructions I will add when all this will be reviewed this function is called often. You can see that it will be called by the new version of Wilson's theorem, because holes are realy needed there. And it will be good to have it cached.\n\n> The time needed to find 3 disjoint blocks is not big compared to the time you need to build an orthogonal array. It would make more sense to implement the caching at the level of `orthogonal_array`. And I think, it would better if done in another ticket.\n\nCome on man. All the boolean answers should be cached. It costs nothing, and it can only help.\n\nNathann",
    "created_at": "2014-06-09T07:56:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210612",
    "user": "https://github.com/nathanncohen"
}
```

Yo !

> I do not agree with your corrections. By definition, the holes are subsets of the ground set `V = {0,...,n-1}`. Perhaps it depend on where we read the definition.

Well, I did not find definition of incomplete OA in the handbook though they define incomplete transversal designs, and for this they introduce sets `H_1,H_2, ...`. Well, to define a hole in general you need to give a subset for each column... Your phrasing assumes that the OA has been relabelled so that the coordinates of the hole are the same in every column... But honestly everybody would understand it the way it is, adding this `^k` just emphasizes that we give the coordinate for every column.

> Could we just get rid of the caching and return list of lists in the very same way as `orthogonal_array`? 

Don't you want to review #16353 ? This would make everything MUCH easier.

I am willing to implement this correctly and -- if posible -- uniformly, but if people refuse to review stuff like #16353 for theological reasons then I am stuck, and I have no other way but to find workarounds.

In the constructions I will add when all this will be reviewed this function is called often. You can see that it will be called by the new version of Wilson's theorem, because holes are realy needed there. And it will be good to have it cached.

> The time needed to find 3 disjoint blocks is not big compared to the time you need to build an orthogonal array. It would make more sense to implement the caching at the level of `orthogonal_array`. And I think, it would better if done in another ticket.

Come on man. All the boolean answers should be cached. It costs nothing, and it can only help.

Nathann



---

archive/issue_comments_210613.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-09T08:09:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210613",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210614.json:
```json
{
    "body": "Here it is. Note that Wilson's decomposition as it is implemented in #16347 was making `orthogonal_array` return tuples too.\n\nAnd I will still need #16353 to update this properly. It is better to output lists than tuples, but if we cannot cache resuls we cannot even build the MOLS table once that #16347 will be implemented --> too slow.\n\nNathann",
    "created_at": "2014-06-09T08:11:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210614",
    "user": "https://github.com/nathanncohen"
}
```

Here it is. Note that Wilson's decomposition as it is implemented in #16347 was making `orthogonal_array` return tuples too.

And I will still need #16353 to update this properly. It is better to output lists than tuples, but if we cannot cache resuls we cannot even build the MOLS table once that #16347 will be implemented --> too slow.

Nathann



---

archive/issue_comments_210615.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-06-09T09:15:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210615",
    "user": "https://github.com/videlec"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_210616.json:
```json
{
    "body": "Replying to [comment:35 ncohen]:\n> Yo !\n> \n> > I do not agree with your corrections. By definition, the holes are subsets of the ground set `V = {0,...,n-1}`. Perhaps it depend on where we read the definition.\n> \n> Well, I did not find definition of incomplete OA in the handbook though they define incomplete transversal designs, and for this they introduce sets `H_1,H_2, ...`. Well, to define a hole in general you need to give a subset for each column... Your phrasing assumes that the OA has been relabelled so that the coordinates of the hole are the same in every column... But honestly everybody would understand it the way it is, adding this `^k` just emphasizes that we give the coordinate for every column.\n\nI had a look at various papers and they define holes as subset of `V`. But I agree, it is fine the way you did.\n \n> > Could we just get rid of the caching and return list of lists in the very same way as `orthogonal_array`? \n> \n> Don't you want to review #16353 ? This would make everything MUCH easier.\n\nI can review it, but I do not want to see it used in designs!\n\n> I am willing to implement this correctly and -- if posible -- uniformly, but if people refuse to review stuff like #16353 for theological reasons then I am stuck, and I have no other way but to find workarounds.\n> \n> In the constructions I will add when all this will be reviewed this function is called often. You can see that it will be called by the new version of Wilson's theorem, because holes are really needed there. And it will be good to have it cached.\n\nAll right. Then I will changed my mind at this point.\n\n> > The time needed to find 3 disjoint blocks is not big compared to the time you need to build an orthogonal array. It would make more sense to implement the caching at the level of `orthogonal_array`. And I think, it would better if done in another ticket.\n> \n> Come on man. All the boolean answers should be cached. It costs nothing, and it can only help.\n\nNo. We should cache a dictionnary `n -> (k_exists,k_unknown)`. This would be more efficient. Sometimes you have a TD(k+5,n) but was looking for a TD(k,n), so you loose information. Similarly, if you start caching (incomplete) orthogonal array you would only cache the one which has the maximum number of holes with respect to a fixed k or the on which has the maximum size with respect to a fixed set of holes.\n\nVincent",
    "created_at": "2014-06-09T09:15:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210616",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:35 ncohen]:
> Yo !
> 
> > I do not agree with your corrections. By definition, the holes are subsets of the ground set `V = {0,...,n-1}`. Perhaps it depend on where we read the definition.
> 
> Well, I did not find definition of incomplete OA in the handbook though they define incomplete transversal designs, and for this they introduce sets `H_1,H_2, ...`. Well, to define a hole in general you need to give a subset for each column... Your phrasing assumes that the OA has been relabelled so that the coordinates of the hole are the same in every column... But honestly everybody would understand it the way it is, adding this `^k` just emphasizes that we give the coordinate for every column.

I had a look at various papers and they define holes as subset of `V`. But I agree, it is fine the way you did.
 
> > Could we just get rid of the caching and return list of lists in the very same way as `orthogonal_array`? 
> 
> Don't you want to review #16353 ? This would make everything MUCH easier.

I can review it, but I do not want to see it used in designs!

> I am willing to implement this correctly and -- if posible -- uniformly, but if people refuse to review stuff like #16353 for theological reasons then I am stuck, and I have no other way but to find workarounds.
> 
> In the constructions I will add when all this will be reviewed this function is called often. You can see that it will be called by the new version of Wilson's theorem, because holes are really needed there. And it will be good to have it cached.

All right. Then I will changed my mind at this point.

> > The time needed to find 3 disjoint blocks is not big compared to the time you need to build an orthogonal array. It would make more sense to implement the caching at the level of `orthogonal_array`. And I think, it would better if done in another ticket.
> 
> Come on man. All the boolean answers should be cached. It costs nothing, and it can only help.

No. We should cache a dictionnary `n -> (k_exists,k_unknown)`. This would be more efficient. Sometimes you have a TD(k+5,n) but was looking for a TD(k,n), so you loose information. Similarly, if you start caching (incomplete) orthogonal array you would only cache the one which has the maximum number of holes with respect to a fixed k or the on which has the maximum size with respect to a fixed set of holes.

Vincent



---

archive/issue_comments_210617.json:
```json
{
    "body": "Yo !\n\n> I had a look at various papers and they define holes as subset of `V`. But I agree, it is fine the way you did.\n\nThanks.\n\n> I can review it, but I do not want to see it used in designs!\n\n....\n\nIt's cool to say \"I do not want to see it used in design\" but I am still the one who writes the code. Having this generic cache would make stuff better. And you can't really refuse an improvement because \"there would be a better way to implement it\" that you expect me to implement instead.\n\nPfffff...\n\nSpoiled reviewers...\n\n> No. We should cache a dictionnary `n -> (k_exists,k_unknown)`. This would be more efficient. Sometimes you have a TD(k+5,n) but was looking for a TD(k,n), so you loose information. Similarly, if you start caching (incomplete) orthogonal array you would only cache the one which has the maximum number of holes with respect to a fixed k or the on which has the maximum size with respect to a fixed set of holes.\n\nI know, I told you about it myself.\n\n...\n\nI will do it.\n\nIt just takes time, and I have been stuck for 5 weeks with a straightforward code that does not get reviewed, and I can't add patch over patch over patch forever, knowing that names and specifications will change in the dependencies. It would have been done already otherwise.\n\nNathann",
    "created_at": "2014-06-09T09:20:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210617",
    "user": "https://github.com/nathanncohen"
}
```

Yo !

> I had a look at various papers and they define holes as subset of `V`. But I agree, it is fine the way you did.

Thanks.

> I can review it, but I do not want to see it used in designs!

....

It's cool to say "I do not want to see it used in design" but I am still the one who writes the code. Having this generic cache would make stuff better. And you can't really refuse an improvement because "there would be a better way to implement it" that you expect me to implement instead.

Pfffff...

Spoiled reviewers...

> No. We should cache a dictionnary `n -> (k_exists,k_unknown)`. This would be more efficient. Sometimes you have a TD(k+5,n) but was looking for a TD(k,n), so you loose information. Similarly, if you start caching (incomplete) orthogonal array you would only cache the one which has the maximum number of holes with respect to a fixed k or the on which has the maximum size with respect to a fixed set of holes.

I know, I told you about it myself.

...

I will do it.

It just takes time, and I have been stuck for 5 weeks with a straightforward code that does not get reviewed, and I can't add patch over patch over patch forever, knowing that names and specifications will change in the dependencies. It would have been done already otherwise.

Nathann



---

archive/issue_comments_210618.json:
```json
{
    "body": "Could you add your name as a reviewer ?\n\nNathann",
    "created_at": "2014-06-09T09:21:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210618",
    "user": "https://github.com/nathanncohen"
}
```

Could you add your name as a reviewer ?

Nathann



---

archive/issue_comments_210619.json:
```json
{
    "body": "Replying to [comment:40 ncohen]:\n> Could you add your name as a reviewer ?\n\nHa! I always forgot that.",
    "created_at": "2014-06-09T09:29:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210619",
    "user": "https://github.com/videlec"
}
```

Replying to [comment:40 ncohen]:
> Could you add your name as a reviewer ?

Ha! I always forgot that.



---

archive/issue_comments_210620.json:
```json
{
    "body": "> I will do it.\n\n#16353\n\nNathann",
    "created_at": "2014-06-09T12:53:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210620",
    "user": "https://github.com/nathanncohen"
}
```

> I will do it.

#16353

Nathann



---

archive/issue_comments_210621.json:
```json
{
    "body": "\n```\nLaTeX Warning: Hyper reference `sage/combinat/designs/orthogonal_arrays:sage.co\nmbinat.designs.orthogonal_arrays.wilson_construction' on page 2472 undefined on\n input line 213303.\n\n! Extra }, or forgotten $.\nl.213341 ...ound set is always $V = \\{0, ..., n-1}\n                                                  $ and the\n? \n! Emergency stop.\nl.213341 ...ound set is always $V = \\{0, ..., n-1}\n                                                  $ and the\n!  ==> Fatal error occurred, no output PDF file produced!\nTranscript written on combinat.log.\nmake[1]: *** [combinat.pdf] Error 1\nmake[1]: Leaving directory `/home/release/Sage/src/doc/output/latex/en/reference/combinat'\nError building the documentation.\n```\n",
    "created_at": "2014-06-09T22:53:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210621",
    "user": "https://github.com/vbraun"
}
```


```
LaTeX Warning: Hyper reference `sage/combinat/designs/orthogonal_arrays:sage.co
mbinat.designs.orthogonal_arrays.wilson_construction' on page 2472 undefined on
 input line 213303.

! Extra }, or forgotten $.
l.213341 ...ound set is always $V = \{0, ..., n-1}
                                                  $ and the
? 
! Emergency stop.
l.213341 ...ound set is always $V = \{0, ..., n-1}
                                                  $ and the
!  ==> Fatal error occurred, no output PDF file produced!
Transcript written on combinat.log.
make[1]: *** [combinat.pdf] Error 1
make[1]: Leaving directory `/home/release/Sage/src/doc/output/latex/en/reference/combinat'
Error building the documentation.
```




---

archive/issue_comments_210622.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2014-06-09T22:53:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210622",
    "user": "https://github.com/vbraun"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_210623.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-06-10T08:08:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210623",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_210624.json:
```json
{
    "body": "Sorry for that.\n\nNow \"make doc-clean && make doc-pdf\" breaks when compiling some french document, but that's unrelated.\n\nNathann",
    "created_at": "2014-06-10T08:08:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210624",
    "user": "https://github.com/nathanncohen"
}
```

Sorry for that.

Now "make doc-clean && make doc-pdf" breaks when compiling some french document, but that's unrelated.

Nathann



---

archive/issue_comments_210625.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2014-06-10T08:08:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210625",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_210626.json:
```json
{
    "body": "Changing status from positive_review to needs_review.",
    "created_at": "2014-06-12T14:29:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210626",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Changing status from positive_review to needs_review.



---

archive/issue_comments_210627.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. Last 10 new commits:",
    "created_at": "2014-06-12T14:29:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210627",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. Last 10 new commits:



---

archive/issue_comments_210628.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-06-12T14:30:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210628",
    "user": "https://github.com/nathanncohen"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_210629.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-06-14T19:59:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16154",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16154#issuecomment-210629",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
