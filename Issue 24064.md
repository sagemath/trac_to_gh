# Issue 24064: nonsensical comparison of GammaH groups

archive/issues_024064.json:
```json
{
    "body": "\n```\nsage: G1 = GammaH(105, [52, 104])\nsage: G2 = GammaH(105, kronecker_character_upside_down(105).kernel())\nsage: G1.is_subgroup(G2)\nTrue\nsage: G2.is_subgroup(G1)\nTrue\nsage: G1 == G2\nFalse\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/24301\n\n",
    "created_at": "2017-11-29T20:07:19Z",
    "labels": [
        "modular forms",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.1",
    "title": "nonsensical comparison of GammaH groups",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/24064",
    "user": "davidloeffler"
}
```

```
sage: G1 = GammaH(105, [52, 104])
sage: G2 = GammaH(105, kronecker_character_upside_down(105).kernel())
sage: G1.is_subgroup(G2)
True
sage: G2.is_subgroup(G1)
True
sage: G1 == G2
False
```


Issue created by migration from https://trac.sagemath.org/ticket/24301





---

archive/issue_comments_337251.json:
```json
{
    "body": "This works for me in 8.1.rc3 (ie G1==G2). Which version of sage are you using ?",
    "created_at": "2017-11-29T20:49:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337251",
    "user": "chapoton"
}
```

This works for me in 8.1.rc3 (ie G1==G2). Which version of sage are you using ?



---

archive/issue_comments_337252.json:
```json
{
    "body": "It fails in the current stable release (8.0) but I can confirm that it also works for me with 8.1.rc2.\n\nLooking at the git log, it seems that this got fixed as a side-effect of one of your commits, b0f1552f8e07d80c529f349fa3ce2898636d65f4 (there is no trac ticket number in the commit message, but the message says something about Python3 and cmp).\n\nThere is still some shadow of the bug left in 8.1.rc2, but it is much harder to expose:\n\n```\nsage: G1 = GammaH(105, [52, 104])\nsage: G2 = GammaH(105, kronecker_character_upside_down(105).kernel())\nsage: G1.image_mod_n() == G2.image_mod_n()\nFalse\n```\n",
    "created_at": "2017-11-30T07:05:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337252",
    "user": "davidloeffler"
}
```

It fails in the current stable release (8.0) but I can confirm that it also works for me with 8.1.rc2.

Looking at the git log, it seems that this got fixed as a side-effect of one of your commits, b0f1552f8e07d80c529f349fa3ce2898636d65f4 (there is no trac ticket number in the commit message, but the message says something about Python3 and cmp).

There is still some shadow of the bug left in 8.1.rc2, but it is much harder to expose:

```
sage: G1 = GammaH(105, [52, 104])
sage: G2 = GammaH(105, kronecker_character_upside_down(105).kernel())
sage: G1.image_mod_n() == G2.image_mod_n()
False
```




---

archive/issue_comments_337253.json:
```json
{
    "body": "FYI - the ticket is #23150 (I just searched for the commit on trac).",
    "created_at": "2017-11-30T07:15:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337253",
    "user": "tscrim"
}
```

FYI - the ticket is #23150 (I just searched for the commit on trac).



---

archive/issue_comments_337254.json:
```json
{
    "body": "Actually I was wrong about what precisely it was that fixed this  issue. Ticket #23150 was already merged in 8.0, in which the bug is still present, so whatever fixed this, it wasn't that ticket. Anyway, the point is that something happened between 8.0 and 8.1.rc2 which fixed this -- it doesn't matter what! :-)",
    "created_at": "2017-11-30T07:23:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337254",
    "user": "davidloeffler"
}
```

Actually I was wrong about what precisely it was that fixed this  issue. Ticket #23150 was already merged in 8.0, in which the bug is still present, so whatever fixed this, it wasn't that ticket. Anyway, the point is that something happened between 8.0 and 8.1.rc2 which fixed this -- it doesn't matter what! :-)



---

archive/issue_comments_337255.json:
```json
{
    "body": "could you please recycle the ticket (title and description) for the remaining bug ?",
    "created_at": "2017-11-30T08:40:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337255",
    "user": "chapoton"
}
```

could you please recycle the ticket (title and description) for the remaining bug ?



---

archive/issue_comments_337256.json:
```json
{
    "body": "Changing component from modular forms to group theory.",
    "created_at": "2017-11-30T09:05:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337256",
    "user": "davidloeffler"
}
```

Changing component from modular forms to group theory.



---

archive/issue_comments_337257.json:
```json
{
    "body": "This behaviour probably counts as \"broken by design\", since the docstring for the method `FinitelyGeneratedMatrixGroup_gap.__richcmp__` states\n\n> \"We treat two matrix groups as equal if their generators are the same in the same order.\"\n\nThis is a very strange notion of \"equality\" if you ask me!",
    "created_at": "2017-11-30T09:12:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337257",
    "user": "davidloeffler"
}
```

This behaviour probably counts as "broken by design", since the docstring for the method `FinitelyGeneratedMatrixGroup_gap.__richcmp__` states

> "We treat two matrix groups as equal if their generators are the same in the same order."

This is a very strange notion of "equality" if you ask me!



---

archive/issue_comments_337258.json:
```json
{
    "body": "Replying to [comment:8 davidloeffler]:\n> This behaviour probably counts as \"broken by design\", since the docstring for the method `FinitelyGeneratedMatrixGroup_gap.__richcmp__` states\n> \n> > \"We treat two matrix groups as equal if their generators are the same in the same order.\"\n> \n> This is a very strange notion of \"equality\" if you ask me!\n\nIt's not uncommon for objects to compare equality differently than isomorphism. For example, two graphs can be not equal but isomorphic, or two symbolic expressions can give the same function but not be equal (under `==`). This is done because it can be expensive to compute isomorphism, whereas a general quick trivial \"equals\" can get somewhat far. So this is a feature, not a bug. If you need real isomorphism testing, then use `is_isomorphic`.",
    "created_at": "2017-11-30T11:37:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337258",
    "user": "tscrim"
}
```

Replying to [comment:8 davidloeffler]:
> This behaviour probably counts as "broken by design", since the docstring for the method `FinitelyGeneratedMatrixGroup_gap.__richcmp__` states
> 
> > "We treat two matrix groups as equal if their generators are the same in the same order."
> 
> This is a very strange notion of "equality" if you ask me!

It's not uncommon for objects to compare equality differently than isomorphism. For example, two graphs can be not equal but isomorphic, or two symbolic expressions can give the same function but not be equal (under `==`). This is done because it can be expensive to compute isomorphism, whereas a general quick trivial "equals" can get somewhat far. So this is a feature, not a bug. If you need real isomorphism testing, then use `is_isomorphic`.



---

archive/issue_comments_337259.json:
```json
{
    "body": "This isn't about isomorphism testing. Both H1 and H2 are, by definition, subgroups of the same ambient group, namely GL2(Z / 105 Z). I claim there is one and only one sensible way to define what it means for two subgroups of the same group to be \"equal\".",
    "created_at": "2017-11-30T11:52:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337259",
    "user": "davidloeffler"
}
```

This isn't about isomorphism testing. Both H1 and H2 are, by definition, subgroups of the same ambient group, namely GL2(Z / 105 Z). I claim there is one and only one sensible way to define what it means for two subgroups of the same group to be "equal".



---

archive/issue_comments_337260.json:
```json
{
    "body": "Replying to [comment:10 davidloeffler]:\n> This isn't about isomorphism testing. Both H1 and H2 are, by definition, subgroups of the same ambient group, namely GL2(Z / 105 Z). I claim there is one and only one sensible way to define what it means for two subgroups of the same group to be \"equal\".\n\nNo, there is not. What I think you are asking for is secretly a check for isomorphism and taking advantage of the extra structure, but this can still be *very* expensive to compute. Imagine the subgroups are big, testing all elements are the same means iterating over the subgroups (which in general means also storing all of the elements) and then comparing equality of each of the set of elements (rather than by looking at sorted lits).\n\nI find that I am usually constructing algebraic objects, such as groups, where it is sufficient to check the generating set. There has been other points in Sage where Python `==` versus math `=` differs and causes confusion, but there could be some major speed regressions with changing the comparison code to be closer to math `=`.\n\nI understand why you disagree with `==` returning false, but IMO it is not practical to have a test that is basically isomorphism testing. However, you are free to ask about this on sage-devel and if there is a consensus for changing this, then I will do the review. My opinion is that either you should be calling `is_isomorphic` (which could have a special case for when two groups are finite subgroups of the same group) or do the same functionality in a new method `is_equal`(`_subgroup` or other name).",
    "created_at": "2017-11-30T13:00:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337260",
    "user": "tscrim"
}
```

Replying to [comment:10 davidloeffler]:
> This isn't about isomorphism testing. Both H1 and H2 are, by definition, subgroups of the same ambient group, namely GL2(Z / 105 Z). I claim there is one and only one sensible way to define what it means for two subgroups of the same group to be "equal".

No, there is not. What I think you are asking for is secretly a check for isomorphism and taking advantage of the extra structure, but this can still be *very* expensive to compute. Imagine the subgroups are big, testing all elements are the same means iterating over the subgroups (which in general means also storing all of the elements) and then comparing equality of each of the set of elements (rather than by looking at sorted lits).

I find that I am usually constructing algebraic objects, such as groups, where it is sufficient to check the generating set. There has been other points in Sage where Python `==` versus math `=` differs and causes confusion, but there could be some major speed regressions with changing the comparison code to be closer to math `=`.

I understand why you disagree with `==` returning false, but IMO it is not practical to have a test that is basically isomorphism testing. However, you are free to ask about this on sage-devel and if there is a consensus for changing this, then I will do the review. My opinion is that either you should be calling `is_isomorphic` (which could have a special case for when two groups are finite subgroups of the same group) or do the same functionality in a new method `is_equal`(`_subgroup` or other name).



---

archive/issue_comments_337261.json:
```json
{
    "body": ">> This isn't about isomorphism testing. Both H1 and H2 are, by definition, subgroups of the same ambient group, namely GL2(Z / 105 Z). I claim there is one and only one sensible way to define what it means for two subgroups of the same group to be \"equal\".\n> \n> No, there is not. [...] Imagine the subgroups are big, testing all elements are the same means iterating over the subgroups (which in general means also storing all of the elements) and then comparing equality of each of the set of elements (rather than by looking at sorted lits).\n\nI wasn't talking about algorithms. I'm saying there's one and only one mathematically meaningful interpretation of the relation of \"equality\" in this case, which is \"having the same elements\". Of course there may be good and bad algorithms to compute this relation; listing all elements is probably a bad algorithm; and it may be the case that there is no good algorithm computing this relation, and one has to make do with an algorithm that checks some other relation instead. But I claim that no other relation deserves to be called \"equality\" in this setting.\n\nIf you disagree and want to close this ticket, then go ahead, I'm not that bothered.",
    "created_at": "2017-11-30T14:58:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337261",
    "user": "davidloeffler"
}
```

>> This isn't about isomorphism testing. Both H1 and H2 are, by definition, subgroups of the same ambient group, namely GL2(Z / 105 Z). I claim there is one and only one sensible way to define what it means for two subgroups of the same group to be "equal".
> 
> No, there is not. [...] Imagine the subgroups are big, testing all elements are the same means iterating over the subgroups (which in general means also storing all of the elements) and then comparing equality of each of the set of elements (rather than by looking at sorted lits).

I wasn't talking about algorithms. I'm saying there's one and only one mathematically meaningful interpretation of the relation of "equality" in this case, which is "having the same elements". Of course there may be good and bad algorithms to compute this relation; listing all elements is probably a bad algorithm; and it may be the case that there is no good algorithm computing this relation, and one has to make do with an algorithm that checks some other relation instead. But I claim that no other relation deserves to be called "equality" in this setting.

If you disagree and want to close this ticket, then go ahead, I'm not that bothered.



---

archive/issue_comments_337262.json:
```json
{
    "body": "Replying to [comment:11 tscrim]:\n> No, there is not. What I think you are asking for is secretly a check for isomorphism and taking advantage of the extra structure, but this can still be *very* expensive to compute.\n\nI agree with David that this is *not* an isomorphism check. It is a check of having the same elements. Two matrix groups can be isomorphic but not equal (say, they are both cyclic groups of the same order but containing different matrices).",
    "created_at": "2017-11-30T16:06:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337262",
    "user": "jdemeyer"
}
```

Replying to [comment:11 tscrim]:
> No, there is not. What I think you are asking for is secretly a check for isomorphism and taking advantage of the extra structure, but this can still be *very* expensive to compute.

I agree with David that this is *not* an isomorphism check. It is a check of having the same elements. Two matrix groups can be isomorphic but not equal (say, they are both cyclic groups of the same order but containing different matrices).



---

archive/issue_comments_337263.json:
```json
{
    "body": "Right, this is a pure equality check. Sorry.\n\nReplying to [comment:12 davidloeffler]:\n> >> This isn't about isomorphism testing. Both H1 and H2 are, by definition, subgroups of the same ambient group, namely GL2(Z / 105 Z). I claim there is one and only one sensible way to define what it means for two subgroups of the same group to be \"equal\".\n> > \n> > No, there is not. [...] Imagine the subgroups are big, testing all elements are the same means iterating over the subgroups (which in general means also storing all of the elements) and then comparing equality of each of the set of elements (rather than by looking at sorted lits).\n> \n> I wasn't talking about algorithms. I'm saying there's one and only one mathematically meaningful interpretation of the relation of \"equality\" in this case, which is \"having the same elements\". Of course there may be good and bad algorithms to compute this relation; listing all elements is probably a bad algorithm; and it may be the case that there is no good algorithm computing this relation, and one has to make do with an algorithm that checks some other relation instead. But I claim that no other relation deserves to be called \"equality\" in this setting.\n\nWhat I am saying is there are good reasons for Python `==` to not always be the same as mathematical `=`. I agree that there is only one mathematically equals, but I think that would be ineffective for subgroups given by a set of generators. With the example in the description:\n\n```\nsage: _ = H1.gap(), H2.gap()\nsage: %time H1.gap() == H2.gap()\nCPU times: user 1.7 s, sys: 120 ms, total: 1.82 s\nWall time: 1.82 s\nTrue\n```\n\nSo GAP does mathematical equality testing, but as you can see, it takes a lot of time even for a somewhat small group (2520 elements). So algorithms are part of the question in my mind as it goes to usability. I cannot see a better algorithm other than listing all of the elements of at least one group and checking the generators of the other are included (with appropriate short-circuiting for returning `True`), but we can always just pass this off to GAP when it will take it.\n\nI think we should give the user more control over how strict they want equality to be tested. So if you insist on making `==` be mathematical equals, then you need to provide a method `is_trivially_equal`. Yet, my experience is that in most cases if the generators are different, than the groups are different. Although in fairness, I work with Coxeter groups, which have extra structure, can utilize `UniqueRepresentation`, and would not be affected by this change.\n\nPerhaps a good comparison is what is done with permutation groups. For them, it feeds it off to GAP and lets GAP return the equality. So maybe what we should do is just let GAP handle things and hope that the cases where the equality-by-gens-check is not a common occurrence that people are relying on.",
    "created_at": "2017-12-01T00:33:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337263",
    "user": "tscrim"
}
```

Right, this is a pure equality check. Sorry.

Replying to [comment:12 davidloeffler]:
> >> This isn't about isomorphism testing. Both H1 and H2 are, by definition, subgroups of the same ambient group, namely GL2(Z / 105 Z). I claim there is one and only one sensible way to define what it means for two subgroups of the same group to be "equal".
> > 
> > No, there is not. [...] Imagine the subgroups are big, testing all elements are the same means iterating over the subgroups (which in general means also storing all of the elements) and then comparing equality of each of the set of elements (rather than by looking at sorted lits).
> 
> I wasn't talking about algorithms. I'm saying there's one and only one mathematically meaningful interpretation of the relation of "equality" in this case, which is "having the same elements". Of course there may be good and bad algorithms to compute this relation; listing all elements is probably a bad algorithm; and it may be the case that there is no good algorithm computing this relation, and one has to make do with an algorithm that checks some other relation instead. But I claim that no other relation deserves to be called "equality" in this setting.

What I am saying is there are good reasons for Python `==` to not always be the same as mathematical `=`. I agree that there is only one mathematically equals, but I think that would be ineffective for subgroups given by a set of generators. With the example in the description:

```
sage: _ = H1.gap(), H2.gap()
sage: %time H1.gap() == H2.gap()
CPU times: user 1.7 s, sys: 120 ms, total: 1.82 s
Wall time: 1.82 s
True
```

So GAP does mathematical equality testing, but as you can see, it takes a lot of time even for a somewhat small group (2520 elements). So algorithms are part of the question in my mind as it goes to usability. I cannot see a better algorithm other than listing all of the elements of at least one group and checking the generators of the other are included (with appropriate short-circuiting for returning `True`), but we can always just pass this off to GAP when it will take it.

I think we should give the user more control over how strict they want equality to be tested. So if you insist on making `==` be mathematical equals, then you need to provide a method `is_trivially_equal`. Yet, my experience is that in most cases if the generators are different, than the groups are different. Although in fairness, I work with Coxeter groups, which have extra structure, can utilize `UniqueRepresentation`, and would not be affected by this change.

Perhaps a good comparison is what is done with permutation groups. For them, it feeds it off to GAP and lets GAP return the equality. So maybe what we should do is just let GAP handle things and hope that the cases where the equality-by-gens-check is not a common occurrence that people are relying on.



---

archive/issue_comments_337264.json:
```json
{
    "body": "See also #24535",
    "created_at": "2018-06-03T10:30:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337264",
    "user": "vdelecroix"
}
```

See also #24535



---

archive/issue_comments_337265.json:
```json
{
    "body": "Here is another annoying bug.\nIt may or may not be related to this ticket.\n\n```\nsage: G = GL(2,5)\nsage: g = G( matrix([[1,0],[0,4]]))\nsage: H = G.subgroup([g])\nsage: g in H\nFalse\n```\n\nIn any case, it makes me dream of going back to magma.",
    "created_at": "2018-06-26T11:24:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/24064",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/24064#issuecomment-337265",
    "user": "wuthrich"
}
```

Here is another annoying bug.
It may or may not be related to this ticket.

```
sage: G = GL(2,5)
sage: g = G( matrix([[1,0],[0,4]]))
sage: H = G.subgroup([g])
sage: g in H
False
```

In any case, it makes me dream of going back to magma.
