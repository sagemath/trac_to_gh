# Issue 25115: Biconnected components Boost interface

archive/issues_025115.json:
```json
{
    "body": "CC:  @dcoudert @dimpase\n\nKeywords: biconnected components, boost, bc tree\n\nSome background: I'm trying to create an interface with Boost for the biconnected components and blocks and cut trees. For this, I need to add a function in `boost_interface.cpp` file in the `BoostGraph` object to compute the biconnected components. Another function has to be added in the `boost_graph.pyx` which calls the function written in `boost_interface.cpp`. In `boost_interface.cpp`, while making a call to biconnected_components function, one of the parameters in `ComponentMap` which basically assigned the component number to each edge.\n\nI am slightly confused as to what parameter to send to the biconnected_components function of Boost. According to the docs of Boost [docs of Boost](https://www.boost.org/doc/libs/1_67_0/libs/graph/doc/biconnected_components.html), --\n\nthe parameter `ComponentMap` type must be a model of [Writable Property Map](https://www.boost.org/doc/libs/1_67_0/libs/property_map/doc/WritablePropertyMap.html). The value type should be an integer type, preferably the same as the edges_size_type of the graph. The key type must be the graph's edge descriptor type.\n\nThis is the parameter I am having an issue with. I tried using `Boost::edge_vertex_t`, I tried using a struct defined for it as mentioned in this [example code on Boost](https://www.boost.org/doc/libs/1_67_0/libs/graph/example/biconnected_components.cpp). But I end up getting the same error which more or less states that the parameter type is not as expected (I am attaching a file with the error I get while compiling  - but I know the error is related to the parameter of `property_map` as I have tested the other parts of the code and they are fine. ) Maybe I should use the `EdgeProperty` of a graph as defined in the `adjacency_list` which is used as a graph. I tried this too, and I end up with the same error.\n\nI have added a comment `// This is the error` beside the line where I defined the `property_map` in the file `boost_interface.cpp`. Also, I know the return type of the function `bc_tree()` is not suited for the purpose and I am also not returning the required answer, I am printing it. I want to get the function to work first, after that parsing the output and returning it as required for Sage will be straightforward.\n\nPlease give me any leads on what should be the parameter for `property_map`.\n\nIssue created by migration from https://trac.sagemath.org/ticket/25352\n\n",
    "created_at": "2018-05-12T10:10:10Z",
    "labels": [
        "component: graph theory"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-8.3",
    "title": "Biconnected components Boost interface",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/25115",
    "user": "https://github.com/meghanamreddy"
}
```
CC:  @dcoudert @dimpase

Keywords: biconnected components, boost, bc tree

Some background: I'm trying to create an interface with Boost for the biconnected components and blocks and cut trees. For this, I need to add a function in `boost_interface.cpp` file in the `BoostGraph` object to compute the biconnected components. Another function has to be added in the `boost_graph.pyx` which calls the function written in `boost_interface.cpp`. In `boost_interface.cpp`, while making a call to biconnected_components function, one of the parameters in `ComponentMap` which basically assigned the component number to each edge.

I am slightly confused as to what parameter to send to the biconnected_components function of Boost. According to the docs of Boost [docs of Boost](https://www.boost.org/doc/libs/1_67_0/libs/graph/doc/biconnected_components.html), --

the parameter `ComponentMap` type must be a model of [Writable Property Map](https://www.boost.org/doc/libs/1_67_0/libs/property_map/doc/WritablePropertyMap.html). The value type should be an integer type, preferably the same as the edges_size_type of the graph. The key type must be the graph's edge descriptor type.

This is the parameter I am having an issue with. I tried using `Boost::edge_vertex_t`, I tried using a struct defined for it as mentioned in this [example code on Boost](https://www.boost.org/doc/libs/1_67_0/libs/graph/example/biconnected_components.cpp). But I end up getting the same error which more or less states that the parameter type is not as expected (I am attaching a file with the error I get while compiling  - but I know the error is related to the parameter of `property_map` as I have tested the other parts of the code and they are fine. ) Maybe I should use the `EdgeProperty` of a graph as defined in the `adjacency_list` which is used as a graph. I tried this too, and I end up with the same error.

I have added a comment `// This is the error` beside the line where I defined the `property_map` in the file `boost_interface.cpp`. Also, I know the return type of the function `bc_tree()` is not suited for the purpose and I am also not returning the required answer, I am printing it. I want to get the function to work first, after that parsing the output and returning it as required for Sage will be straightforward.

Please give me any leads on what should be the parameter for `property_map`.

Issue created by migration from https://trac.sagemath.org/ticket/25352





---

archive/issue_comments_353017.json:
```json
{
    "body": "Compile error I get, the last 10 lines state the error",
    "created_at": "2018-05-12T10:11:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353017",
    "user": "https://github.com/meghanamreddy"
}
```

Compile error I get, the last 10 lines state the error



---

archive/issue_comments_353018.json:
```json
{
    "body": "Attachment [compile_error_bctree.txt](tarball://root/attachments/some-uuid/ticket25352/compile_error_bctree.txt) by @meghanamreddy created at 2018-05-12 10:20:08",
    "created_at": "2018-05-12T10:20:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353018",
    "user": "https://github.com/meghanamreddy"
}
```

Attachment [compile_error_bctree.txt](tarball://root/attachments/some-uuid/ticket25352/compile_error_bctree.txt) by @meghanamreddy created at 2018-05-12 10:20:08



---

archive/issue_comments_353019.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-12T10:48:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353019",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353020.json:
```json
{
    "body": "Could you try writing a standalone C++ program that replicates this?\nTo me it looks as if it's a basic issue with using Boost's API.",
    "created_at": "2018-05-13T15:56:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353020",
    "user": "https://github.com/dimpase"
}
```

Could you try writing a standalone C++ program that replicates this?
To me it looks as if it's a basic issue with using Boost's API.



---

archive/issue_comments_353021.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-17T18:41:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353021",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353022.json:
```json
{
    "body": "There is currently one drawback error I am looking at. Basically, if the input graph contains isolated vertices, the Boost implementation does not report it as either a block or a cut vertex, these vertices are just ignored. The implementation available in Sage, however, treats isolated vertices as a biconnected component and lists it as a block.\n\nHence, I will have to do the following. In `boost_graph.pyx`, after I have the output of Boost's `biconnected_components()` method, I can add all the vertices in all the blocks into a set, and check which vertices are not part of any block - such vertices must be isolated vertices. So I add each of these vertices as a block in the output.",
    "created_at": "2018-05-17T18:51:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353022",
    "user": "https://github.com/meghanamreddy"
}
```

There is currently one drawback error I am looking at. Basically, if the input graph contains isolated vertices, the Boost implementation does not report it as either a block or a cut vertex, these vertices are just ignored. The implementation available in Sage, however, treats isolated vertices as a biconnected component and lists it as a block.

Hence, I will have to do the following. In `boost_graph.pyx`, after I have the output of Boost's `biconnected_components()` method, I can add all the vertices in all the blocks into a set, and check which vertices are not part of any block - such vertices must be isolated vertices. So I add each of these vertices as a block in the output.



---

archive/issue_comments_353023.json:
```json
{
    "body": "Excellent news.\n\nI had a look at your code. Some comments:\n- Instead of `Uses Boost to compute the blocks and cut vertices of the input graph.`, I would rather use `Compute the blocks and cut vertices of the graph.`. Then you can add a short text saying that this method uses the implementation available in boost of Tarjan's algorithm.\n\n- In the method implemented in `generic_graph.py`, we consider the graph as undirected, and loops or multiple edges are ignored. In your implementation, I'm not sure what happens if you give a directed graph with symmetric edges (i.e., `[(0,1), (1,0)]`). It might be considered as multiple edges for the underlying undirected graph. Please check what is mandatory and how to cope with this at low cost.\n\n- `cdef dict vertex_to_int = {v:i for i,v in enumerate(g.vertices())}` is apparently not used, so you may remove it.\n\n- `result_blocks = []` -> `cdef list result_blocks = []` ? and the same for `result_cut` ?\n\n- You should define a new variable with value `len(result)-1` as you use this several times.\n\n- Why do you need to do `result[i] = list(set(result[i]))` ?\n\n- Can't we find a faster method to identify articulation points than calling the boost method which itself calls the biconnected components method ? For instance, assume you have an array of booleans initialized to False. Then you iterate over all biconnected components. If a vertex has already been seen, it is necessarily an articulation points and you can store it. Otherwise, you mark it as seen. \n\n  At the end of this loop, vertices that have not been seen are the isolated vertices you are looking for ;) Actually, what if the graph has 2 disjoints biconnected components ? will the boost method find both or only one ?",
    "created_at": "2018-05-18T09:36:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353023",
    "user": "https://github.com/dcoudert"
}
```

Excellent news.

I had a look at your code. Some comments:
- Instead of `Uses Boost to compute the blocks and cut vertices of the input graph.`, I would rather use `Compute the blocks and cut vertices of the graph.`. Then you can add a short text saying that this method uses the implementation available in boost of Tarjan's algorithm.

- In the method implemented in `generic_graph.py`, we consider the graph as undirected, and loops or multiple edges are ignored. In your implementation, I'm not sure what happens if you give a directed graph with symmetric edges (i.e., `[(0,1), (1,0)]`). It might be considered as multiple edges for the underlying undirected graph. Please check what is mandatory and how to cope with this at low cost.

- `cdef dict vertex_to_int = {v:i for i,v in enumerate(g.vertices())}` is apparently not used, so you may remove it.

- `result_blocks = []` -> `cdef list result_blocks = []` ? and the same for `result_cut` ?

- You should define a new variable with value `len(result)-1` as you use this several times.

- Why do you need to do `result[i] = list(set(result[i]))` ?

- Can't we find a faster method to identify articulation points than calling the boost method which itself calls the biconnected components method ? For instance, assume you have an array of booleans initialized to False. Then you iterate over all biconnected components. If a vertex has already been seen, it is necessarily an articulation points and you can store it. Otherwise, you mark it as seen. 

  At the end of this loop, vertices that have not been seen are the isolated vertices you are looking for ;) Actually, what if the graph has 2 disjoints biconnected components ? will the boost method find both or only one ?



---

archive/issue_comments_353024.json:
```json
{
    "body": "Replying to [comment:7 dcoudert]:\n> - Instead of `Uses Boost to compute the blocks and cut vertices of the input graph.`, I would rather use `Compute the blocks and cut vertices of the graph.`. Then you can add a short text saying that this method uses the implementation available in boost of Tarjan's algorithm.\n> \nOkay, I will do that.\n> - In the method implemented in `generic_graph.py`, we consider the graph as undirected, and loops or multiple edges are ignored. In your implementation, I'm not sure what happens if you give a directed graph with symmetric edges (i.e., `[(0,1), (1,0)]`). It might be considered as multiple edges for the underlying undirected graph. Please check what is mandatory and how to cope with this at low cost.\nAs of now, we convert the graph to an undirected and simple graph. Then the computations will be done assuming only one edge between `0` and `1` existed.\n> - `cdef dict vertex_to_int = {v:i for i,v in enumerate(g.vertices())}` is apparently not used, so you may remove it.\nOh right. Will do that.\n> - `result_blocks = []` -> `cdef list result_blocks = []` ? and the same for `result_cut` ?\n> - You should define a new variable with value `len(result)-1` as you use this several times.\nOkay, I will change it.\n> - Why do you need to do `result[i] = list(set(result[i]))` ?\n> \nSo the Boost `biconnected_components()` method assigns an integer to each edge denoting which biconnected component it belongs to. I am iterating through every edge, and adding the incident vertices to the corresponding biconnected components. If a vertex which is not a cut vertex has more than one edge incident, then we will come across this vertex atleast twice. Hence we need to store the vertices of each biconnected component as a set. Instead of doing this in `boost_interface.cpp`, I am doing it in `boost_graph.pyx`.\n> - Can't we find a faster method to identify articulation points than calling the boost method which itself calls the biconnected components method ? For instance, assume you have an array of booleans initialized to False. Then you iterate over all biconnected components. If a vertex has already been seen, it is necessarily an articulation points and you can store it. Otherwise, you mark it as seen. \n> \n>   At the end of this loop, vertices that have not been seen are the isolated vertices you are looking for ;) Actually, what if the graph has 2 disjoints biconnected components ? will the boost method find both or only one ?\n\nYes, this is a very good idea. Thank you. I will implement this. And yes, if the graph has 2 disjoint subgraphs, Boost method computes the articulation points and biconnected components of both. Only problem was isolated vertices, which will be solved by your method.\n\nAnother point I wanted to ask - is it required to sort the vertices in each biconnected component? The Sage implementation does this but I wasn't sure if it is necessary.",
    "created_at": "2018-05-19T19:37:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353024",
    "user": "https://github.com/meghanamreddy"
}
```

Replying to [comment:7 dcoudert]:
> - Instead of `Uses Boost to compute the blocks and cut vertices of the input graph.`, I would rather use `Compute the blocks and cut vertices of the graph.`. Then you can add a short text saying that this method uses the implementation available in boost of Tarjan's algorithm.
> 
Okay, I will do that.
> - In the method implemented in `generic_graph.py`, we consider the graph as undirected, and loops or multiple edges are ignored. In your implementation, I'm not sure what happens if you give a directed graph with symmetric edges (i.e., `[(0,1), (1,0)]`). It might be considered as multiple edges for the underlying undirected graph. Please check what is mandatory and how to cope with this at low cost.
As of now, we convert the graph to an undirected and simple graph. Then the computations will be done assuming only one edge between `0` and `1` existed.
> - `cdef dict vertex_to_int = {v:i for i,v in enumerate(g.vertices())}` is apparently not used, so you may remove it.
Oh right. Will do that.
> - `result_blocks = []` -> `cdef list result_blocks = []` ? and the same for `result_cut` ?
> - You should define a new variable with value `len(result)-1` as you use this several times.
Okay, I will change it.
> - Why do you need to do `result[i] = list(set(result[i]))` ?
> 
So the Boost `biconnected_components()` method assigns an integer to each edge denoting which biconnected component it belongs to. I am iterating through every edge, and adding the incident vertices to the corresponding biconnected components. If a vertex which is not a cut vertex has more than one edge incident, then we will come across this vertex atleast twice. Hence we need to store the vertices of each biconnected component as a set. Instead of doing this in `boost_interface.cpp`, I am doing it in `boost_graph.pyx`.
> - Can't we find a faster method to identify articulation points than calling the boost method which itself calls the biconnected components method ? For instance, assume you have an array of booleans initialized to False. Then you iterate over all biconnected components. If a vertex has already been seen, it is necessarily an articulation points and you can store it. Otherwise, you mark it as seen. 
> 
>   At the end of this loop, vertices that have not been seen are the isolated vertices you are looking for ;) Actually, what if the graph has 2 disjoints biconnected components ? will the boost method find both or only one ?

Yes, this is a very good idea. Thank you. I will implement this. And yes, if the graph has 2 disjoint subgraphs, Boost method computes the articulation points and biconnected components of both. Only problem was isolated vertices, which will be solved by your method.

Another point I wanted to ask - is it required to sort the vertices in each biconnected component? The Sage implementation does this but I wasn't sure if it is necessary.



---

archive/issue_comments_353025.json:
```json
{
    "body": "> > - Why do you need to do `result[i] = list(set(result[i]))` ?\n> > \n> So the Boost `biconnected_components()` method assigns an integer to each edge denoting which biconnected component it belongs to. I am iterating through every edge, and adding the incident vertices to the corresponding biconnected components. If a vertex which is not a cut vertex has more than one edge incident, then we will come across this vertex atleast twice. Hence we need to store the vertices of each biconnected component as a set. Instead of doing this in `boost_interface.cpp`, I am doing it in `boost_graph.pyx`.\n\nYou should add some comments in the code to explain it. When I read the code, my understanding is that boost put in `result[i]` the list of vertices of block `i` and that this list may contains repetitions that you remove doing `list(set(result[i]))`.\n\nThen, since `result[i]` is a list, the for loop should be\n\n```\nfor z in result[i]:\n    result_temp.append(int_to_vertex[<int> z])\n```\n\nwith z of the right type.\n\nor if you combine with previous instruction, you can do\n\n```\nfor z in set(result[i]):\n    result_temp.append(int_to_vertex[<int> z])\n```\n\nthe advantage is that you don't modify `result[i]`...\n\n  \nYou should also do something for the loop `for i in range(len(result[len(result)-1])):` like `for z in result[len(result)-1]:`.\n\n> Another point I wanted to ask - is it required to sort the vertices in each biconnected component? The Sage implementation does this but I wasn't sure if it is necessary. \n\nNo, it's not mandatory. We did it in the Sage implementation because it makes it easier to read when you print the solution, but, as for the list of vertices which are sorted, it adds extra computations for little benefit.",
    "created_at": "2018-05-20T08:39:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353025",
    "user": "https://github.com/dcoudert"
}
```

> > - Why do you need to do `result[i] = list(set(result[i]))` ?
> > 
> So the Boost `biconnected_components()` method assigns an integer to each edge denoting which biconnected component it belongs to. I am iterating through every edge, and adding the incident vertices to the corresponding biconnected components. If a vertex which is not a cut vertex has more than one edge incident, then we will come across this vertex atleast twice. Hence we need to store the vertices of each biconnected component as a set. Instead of doing this in `boost_interface.cpp`, I am doing it in `boost_graph.pyx`.

You should add some comments in the code to explain it. When I read the code, my understanding is that boost put in `result[i]` the list of vertices of block `i` and that this list may contains repetitions that you remove doing `list(set(result[i]))`.

Then, since `result[i]` is a list, the for loop should be

```
for z in result[i]:
    result_temp.append(int_to_vertex[<int> z])
```

with z of the right type.

or if you combine with previous instruction, you can do

```
for z in set(result[i]):
    result_temp.append(int_to_vertex[<int> z])
```

the advantage is that you don't modify `result[i]`...

  
You should also do something for the loop `for i in range(len(result[len(result)-1])):` like `for z in result[len(result)-1]:`.

> Another point I wanted to ask - is it required to sort the vertices in each biconnected component? The Sage implementation does this but I wasn't sure if it is necessary. 

No, it's not mandatory. We did it in the Sage implementation because it makes it easier to read when you print the solution, but, as for the list of vertices which are sorted, it adds extra computations for little benefit.



---

archive/issue_comments_353026.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-20T09:58:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353026",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353027.json:
```json
{
    "body": "Replying to [comment:9 dcoudert]:\n\nI have made all the changes. Please check.",
    "created_at": "2018-05-20T09:59:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353027",
    "user": "https://github.com/meghanamreddy"
}
```

Replying to [comment:9 dcoudert]:

I have made all the changes. Please check.



---

archive/issue_comments_353028.json:
```json
{
    "body": "We can do something smarter, combining the loops and the ideas ;)\n\nLet `vertex_status` be an array of `n` integers initialized to `-1`. The idea is that if `vertex_status[v] == -1`, the vertex has not been seen yet. If `vertex_status[v] == i`, then `v` belongs to the ith block. If `vertex_status[v] != -1 and vertex_status[v] < i` then `v` belongs to at least 2 blocks so is an articulation point.\n\n```\nfor i in range(len(result)):\n    result_temp = []\n    for v in result[i]:\n        if vertex_status[v] == -1:\n            # First time we see this vertex\n            result_temp.append(int_to_vertex[<int> v])\n            vertex_status[v] = i\n\n        elif vertex_status[v] < i:\n            # This vertex also belongs to another block, so it is an articulation point\n            result_cut.append(int_to_vertex[<int> v])\n            # We change the block number to avoid adding it twice as an articulation point in case this vertex is repeated in the current block\n            vertex_status[v] = i\n\n        # no else. If the vertex is already in this block, it is a repetition and we simply skip it\n\n    result_blocks.append(result_temp)\n\n# Finally, we deal with isolated vertices\nfor i in range(g.order()):\n    if vertex_status[i] == -1:\n        result_blocks.append([int_to_vertex[<int> i]])\n```\n\n\ndo not forget to declare variables `i` and `v`.",
    "created_at": "2018-05-20T10:47:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353028",
    "user": "https://github.com/dcoudert"
}
```

We can do something smarter, combining the loops and the ideas ;)

Let `vertex_status` be an array of `n` integers initialized to `-1`. The idea is that if `vertex_status[v] == -1`, the vertex has not been seen yet. If `vertex_status[v] == i`, then `v` belongs to the ith block. If `vertex_status[v] != -1 and vertex_status[v] < i` then `v` belongs to at least 2 blocks so is an articulation point.

```
for i in range(len(result)):
    result_temp = []
    for v in result[i]:
        if vertex_status[v] == -1:
            # First time we see this vertex
            result_temp.append(int_to_vertex[<int> v])
            vertex_status[v] = i

        elif vertex_status[v] < i:
            # This vertex also belongs to another block, so it is an articulation point
            result_cut.append(int_to_vertex[<int> v])
            # We change the block number to avoid adding it twice as an articulation point in case this vertex is repeated in the current block
            vertex_status[v] = i

        # no else. If the vertex is already in this block, it is a repetition and we simply skip it

    result_blocks.append(result_temp)

# Finally, we deal with isolated vertices
for i in range(g.order()):
    if vertex_status[i] == -1:
        result_blocks.append([int_to_vertex[<int> i]])
```


do not forget to declare variables `i` and `v`.



---

archive/issue_comments_353029.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-20T13:17:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353029",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353030.json:
```json
{
    "body": "I have combined the two loops now.\nBut the type of the variable `v` depends on the input graph. I cannot define it as `int` or `string`. Is there a generic type for graph vertices?",
    "created_at": "2018-05-20T13:19:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353030",
    "user": "https://github.com/meghanamreddy"
}
```

I have combined the two loops now.
But the type of the variable `v` depends on the input graph. I cannot define it as `int` or `string`. Is there a generic type for graph vertices?



---

archive/issue_comments_353031.json:
```json
{
    "body": "Do we agree that the values in `result[i]` are integers (= index of vertices in the boost graph) ? If so, the solution I proposed should work.",
    "created_at": "2018-05-20T13:58:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353031",
    "user": "https://github.com/dcoudert"
}
```

Do we agree that the values in `result[i]` are integers (= index of vertices in the boost graph) ? If so, the solution I proposed should work.



---

archive/issue_comments_353032.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-20T14:12:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353032",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353033.json:
```json
{
    "body": "Replying to [comment:15 dcoudert]:\n> Do we agree that the values in `result[i]` are integers (= index of vertices in the boost graph) ? If so, the solution I proposed should work.\n> \nMy bad, I didn't pay keen attention to your solution, so I was storing the status of the vertices of Sage graph in `vertex_status` instead of the Boost graph, and hence the confusion. I have changed it now.",
    "created_at": "2018-05-20T14:15:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353033",
    "user": "https://github.com/meghanamreddy"
}
```

Replying to [comment:15 dcoudert]:
> Do we agree that the values in `result[i]` are integers (= index of vertices in the boost graph) ? If so, the solution I proposed should work.
> 
My bad, I didn't pay keen attention to your solution, so I was storing the status of the vertices of Sage graph in `vertex_status` instead of the Boost graph, and hence the confusion. I have changed it now.



---

archive/issue_comments_353034.json:
```json
{
    "body": "Could you:\n- add an empty line after `Computes the blocks and cut vertices of the graph.`\n\n- At the end of the method, you can simply do\n\n```\n-    result_tup = [result_blocks, result_cut]\n-    return tuple(result_tup)\n+    return (result_blocks, result_cut)\n```\n\n\nand don't forget to set the ticket to \"needs review\" when you think it is ready.",
    "created_at": "2018-05-20T15:33:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353034",
    "user": "https://github.com/dcoudert"
}
```

Could you:
- add an empty line after `Computes the blocks and cut vertices of the graph.`

- At the end of the method, you can simply do

```
-    result_tup = [result_blocks, result_cut]
-    return tuple(result_tup)
+    return (result_blocks, result_cut)
```


and don't forget to set the ticket to "needs review" when you think it is ready.



---

archive/issue_comments_353035.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-20T18:11:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353035",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353036.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2018-05-20T18:12:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353036",
    "user": "https://github.com/meghanamreddy"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_353037.json:
```json
{
    "body": "There is a doctest failure. In the test you expect `TypeError: the input must be a Sage Graph` but in the code you raise `TypeError(\"the input must be a Sage graph\")`. So use either `sage` or `Sage`.\n\nRecall that you should test your code and the doctest.\n- `./sage -tp src/sage/graphs/base/boost_graph.pyx` will run the doctests on the file\n- `./sage -tp src/sage/graphs/` will run the doctests of all files in the directory\n\n\nAnother issue is that we may add multiple times a cut vertex to the list of cut vertices. \n\n```\nsage: G = graphs.StarGraph(5)\nsage: G.blocks_and_cut_vertices(algorithm=\"Tarjan_Boost\")\n([[0, 1], [0, 2], [0, 3], [0, 4], [0, 5]], [0, 0, 0, 0])\n```\n\nTo avoid that, you can change the type of `result_cut` to set (`cdef set result_cut = set()`), and then return `list(result_cut)`",
    "created_at": "2018-05-21T08:34:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353037",
    "user": "https://github.com/dcoudert"
}
```

There is a doctest failure. In the test you expect `TypeError: the input must be a Sage Graph` but in the code you raise `TypeError("the input must be a Sage graph")`. So use either `sage` or `Sage`.

Recall that you should test your code and the doctest.
- `./sage -tp src/sage/graphs/base/boost_graph.pyx` will run the doctests on the file
- `./sage -tp src/sage/graphs/` will run the doctests of all files in the directory


Another issue is that we may add multiple times a cut vertex to the list of cut vertices. 

```
sage: G = graphs.StarGraph(5)
sage: G.blocks_and_cut_vertices(algorithm="Tarjan_Boost")
([[0, 1], [0, 2], [0, 3], [0, 4], [0, 5]], [0, 0, 0, 0])
```

To avoid that, you can change the type of `result_cut` to set (`cdef set result_cut = set()`), and then return `list(result_cut)`



---

archive/issue_comments_353038.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2018-05-21T08:34:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353038",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_353039.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-21T11:50:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353039",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353040.json:
```json
{
    "body": "I have fixed the errors.",
    "created_at": "2018-05-21T12:17:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353040",
    "user": "https://github.com/meghanamreddy"
}
```

I have fixed the errors.



---

archive/issue_comments_353041.json:
```json
{
    "body": "Sorry for not asking before, but could you put line `# Change the block number to avoid adding the vertex twice as a cut vertex if it is repeated in block i` in 80 columns mode. I think that other comments are already in this mode.",
    "created_at": "2018-05-21T13:13:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353041",
    "user": "https://github.com/dcoudert"
}
```

Sorry for not asking before, but could you put line `# Change the block number to avoid adding the vertex twice as a cut vertex if it is repeated in block i` in 80 columns mode. I think that other comments are already in this mode.



---

archive/issue_comments_353042.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2018-05-21T13:21:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353042",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_353043.json:
```json
{
    "body": "Replying to [comment:24 dcoudert]:\n> Sorry for not asking before, but could you put line `# Change the block number to avoid adding the vertex twice as a cut vertex if it is repeated in block i` in 80 columns mode. I think that other comments are already in this mode.\n\nSorry, I thought the 80 column mode was important for the documentation of the function, which also appears in the docs. So I hadn't ensured 80 column mode for the comments in the code. I will ensure I maintain 80 column mode from now on.",
    "created_at": "2018-05-21T13:25:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353043",
    "user": "https://github.com/meghanamreddy"
}
```

Replying to [comment:24 dcoudert]:
> Sorry for not asking before, but could you put line `# Change the block number to avoid adding the vertex twice as a cut vertex if it is repeated in block i` in 80 columns mode. I think that other comments are already in this mode.

Sorry, I thought the 80 column mode was important for the documentation of the function, which also appears in the docs. So I hadn't ensured 80 column mode for the comments in the code. I will ensure I maintain 80 column mode from now on.



---

archive/issue_comments_353044.json:
```json
{
    "body": "Good to go !",
    "created_at": "2018-05-21T13:34:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353044",
    "user": "https://github.com/dcoudert"
}
```

Good to go !



---

archive/issue_comments_353045.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2018-05-21T13:34:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353045",
    "user": "https://github.com/dcoudert"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_353046.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2018-05-24T07:10:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/25115",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/25115#issuecomment-353046",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
