# Issue 32072: Lazy Dirichlet Series

Issue created by migration from https://trac.sagemath.org/ticket/32309

Original creator: mantepse

Original creation time: 2021-07-30 08:15:11

CC:  tscrim @tejasvicsr1 slelievre kcrisman




---

Comment by mantepse created at 2021-07-30 08:27:37

Changing component from PLEASE CHANGE to combinatorics.


---

Comment by mantepse created at 2021-07-30 08:27:37

Changing type from PLEASE CHANGE to enhancement.


---

Comment by mantepse created at 2021-07-30 08:27:37

Last 10 new commits:


---

Comment by mantepse created at 2021-07-30 08:28:38

Changing keywords from "" to "LazyPowerSeries, FormalSeries".


---

Comment by git created at 2021-07-31 19:10:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-07-31 19:42:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-01 09:39:26

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-01 09:52:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-01 11:01:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-03 12:19:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-04 09:26:34

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by chapoton created at 2021-08-17 06:47:24

when using latex command in the doc, you need to start with `r"""` instead of `"""`

For example, when using ``\infty``


---

Comment by mantepse created at 2021-08-17 07:19:57

Thank you for the hint, I tend to overlook this :-9

Warning: this ticket is currently not updated, the newest version is in #32324 and #32345, because it turned out to be important to get a broader view on the lazy framework.  Once this framework is stable (very likely soon after #31897 is in), I will probably backport, if that makes review easier.


---

Comment by git created at 2021-08-25 20:48:20

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2021-08-25 21:26:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-25 21:35:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-08-26 10:08:41

This fixes the composition issues we talked about plus I did some other misc stuff.
----
New commits:


---

Comment by mantepse created at 2021-08-26 11:52:57

Thank you Travis!

I think it would be good to split `LazyLaurentSeries.__call__` into subroutines, 110 lines of code don't fit on a screen and I find it hard to see the execution path.

line 1993:

```
            if (not isinstance(g, LazyDirichletSeries)
                and isinstance(g._coeff_stream, Stream_exact)
                and not g._coeff_stream._constant):
```

I think it might be better to say

```
            if (isinstance(g, LazyCauchyProductSeries)
                and isinstance(g._coeff_stream, Stream_exact)
                and not g._coeff_stream._constant):
```


line 2054:

```
        # Perhaps we just don't yet know if the valuation is positive
        if g._coeff_stream._approximate_order <= 0:
            if any(g._coeff_stream[i] for i in range(g._coeff_stream._approximate_order, 1)):
                raise ValueError("can only compose with a positive valuation series")
            g._coeff_stream._approximate_order = 1
```

looks suspicious for lazy Dirichlet series, because if the approximate order is 1 then we do not have positive valuation.

Martin


---

Comment by mantepse created at 2021-08-26 12:29:09

I think, the following should work:

```
sage: D = LazyDirichletSeriesRing(QQ, "s")
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: e = L(lambda n: 1/factorial(n), 0)
sage: g = D(None, valuation=2)
sage: o = D(constant=1, valuation=2)
sage: g.define(e(g)*o)
AssertionError: Dirichlet convolution is only defined for coefficient streams with minimal index of nonzero coefficient at least 1
```



---

Comment by git created at 2021-08-26 13:40:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-26 13:48:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-08-26 15:08:18

Replying to [comment:21 mantepse]:
> I think, the following should work:
> {{{
> sage: D = LazyDirichletSeriesRing(QQ, "s")
> sage: L.<z> = LazyLaurentSeriesRing(QQ)
> sage: e = L(lambda n: 1/factorial(n), 0)
> sage: g = D(None, valuation=2)
> sage: o = D(constant=1, valuation=2)
> sage: g.define(e(g)*o)
> AssertionError: Dirichlet convolution is only defined for coefficient streams with minimal index of nonzero coefficient at least 1
> }}}

After fixing the bug in ​https://trac.sagemath.org/ticket/32309?replyto=21#comment:22, the following actually works:

```
sage: g.define(o*e(g)); g
1/(2^s) + 1/(3^s) + 2/4^s + 1/(5^s) + 3/6^s + 1/(7^s) + 9/2/8^s + O(1/(9^s))
```

(but not `g.define(e(g)*o)`)


---

Comment by tscrim created at 2021-08-27 00:48:49

I remember us coming across this problem with Cauchy multiplication as we don't actually need a coefficient because the other side is 0. Here, we can at least get it to the same level, where we add an extra check against the valuation. I will push a fix for this in a second.

In more detail, for this computation, it is computing the pairs of coefficients (2,1) and (1,2). However, we only test one side (the left) is nonzero before computing the right, which is why we have this broken symmetry.


---

Comment by git created at 2021-08-27 00:49:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-27 00:51:16

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2021-08-27 00:54:51

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-08-27 01:01:15

Replying to [comment:20 mantepse]:
> I think it would be good to split `LazyLaurentSeries.__call__` into subroutines, 110 lines of code don't fit on a screen and I find it hard to see the execution path.

With the major points/cases commented, I think it is fine (you can just have your editor fold the different cases to see the larger structure). However, if you want to split it and handle all of the documentation stuff, then go ahead an do it.

> line 1993:

Yea, you're right. This should only happen if a series implements the Cauchy product. Changed.
 
> line 2054: [snip]
> looks suspicious for lazy Dirichlet series, because if the approximate order is 1 then we do not have positive valuation.

That is the generic code, it then falls into the next if statement, which is the Dirichlet specialized code, to check explicitly the `approximate order == 1` case. I tweaked the code so that it does update `g._coeff_stream._approximate_order = 2` since it knows that at that point.


---

Comment by tscrim created at 2021-08-27 01:03:31

Question: Do we want all of the lazy series to have the same global options for printing? There is a way to link the two together by

```
options = LazyLaurentSeriesRing.options
```

in `LazyDirichletSeriesRing` (see `SkewTableaux` for an example`).


---

Comment by mantepse created at 2021-08-27 06:01:50

Great! making options more global is not important to me.

I do think it would be good to have some tests for lazy series having lazy series as coefficients. Most interesting would be the case where an initial coefficients vanishes mysteriously.

I am without computer until noon.


---

Comment by mantepse created at 2021-08-27 09:25:55

Indeed:

```
sage: D = LazyDirichletSeriesRing(QQ, "s")
sage: L.<t> = LazyLaurentSeriesRing(D)
sage: zeta = D(constant=1)
sage: 1/(1-t*zeta)
---------------------------------------------------------------------------
...
KeyError: (Lazy Laurent Series Ring in t over Lazy Dirichlet Series Ring in s over Rational Field, Lazy Dirichlet Series Ring in s over Rational Field, <built-in function mul>)

During handling of the above exception, another exception occurred:

AssertionError                            Traceback (most recent call last)
<ipython-input-13-d6c44f5d7f68> in <module>
----> 1 Integer(1)/(Integer(1)-t*zeta)

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element.__mul__ (build/cythonized/sage/structure/element.c:12204)()
   1513             return (<Element>left)._mul_(right)
   1514         if BOTH_ARE_ELEMENT(cl):
-> 1515             return coercion_model.bin_op(left, right, mul)
   1516 
   1517         cdef long value

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/coerce.pyx in sage.structure.coerce.CoercionModel.bin_op (build/cythonized/sage/structure/coerce.c:10524)()
   1189             action = self._action_maps.get(xp, yp, op)
   1190         except KeyError:
-> 1191             action = self.get_action(xp, yp, op, x, y)
   1192         if action is not None:
   1193             if (<Action>action)._is_left:

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/coerce.pyx in sage.structure.coerce.CoercionModel.get_action (build/cythonized/sage/structure/coerce.c:17356)()
   1718         except KeyError:
   1719             pass
-> 1720         action = self.discover_action(R, S, op, r, s)
   1721         action = self.verify_action(action, R, S, op)
   1722         self._action_maps.set(R, S, op, action)

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/coerce.pyx in sage.structure.coerce.CoercionModel.discover_action (build/cythonized/sage/structure/coerce.c:18792)()
   1849         """
   1850         if isinstance(R, Parent):
-> 1851             action = (<Parent>R).get_action(S, op, True, r, s)
   1852             if action is not None:
   1853                 return action

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.get_action (build/cythonized/sage/structure/parent.c:20503)()
   2541         action = self._get_action_(S, op, self_on_left)
   2542         if action is None:
-> 2543             action = self.discover_action(S, op, self_on_left, self_el, S_el)
   2544 
   2545         if action is not None:

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.discover_action (build/cythonized/sage/structure/parent.c:21521)()
   2622                 # detect actions defined by _rmul_, _lmul_, _act_on_, and _acted_upon_ methods
   2623                 from .coerce_actions import detect_element_action
-> 2624                 action = detect_element_action(self, S, self_on_left, self_el, S_el)
   2625                 if action is not None:
   2626                     return action

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/coerce_actions.pyx in sage.structure.coerce_actions.detect_element_action (build/cythonized/sage/structure/coerce_actions.c:5439)()
    229     if isinstance(Y, Parent):
    230         try:
--> 231             if x._acted_upon_(y, X_on_left) is not None:
    232                 return ActedUponAction(Y, X, not X_on_left, False)
    233         except CoercionException:

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element._acted_upon_ (build/cythonized/sage/structure/element.c:8976)()
    951         return None
    952 
--> 953     cpdef _acted_upon_(self, x, bint self_on_left):
    954         """
    955         Use this method to implement ``self`` acted on by x.

~/sage-develop/local/lib/python3.8/site-packages/sage/rings/lazy_series.py in _acted_upon_(self, scalar, self_on_left)
   1098             init_coeffs = self._coeff_stream._initial_coefficients
   1099             if self_on_left:
-> 1100                 c = self._coeff_stream._constant * scalar
   1101                 initial_coefficients = [val * scalar for val in init_coeffs]
   1102             else:

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element.__mul__ (build/cythonized/sage/structure/element.c:12169)()
   1511         cdef int cl = classify_elements(left, right)
   1512         if HAVE_SAME_PARENT(cl):
-> 1513             return (<Element>left)._mul_(right)
   1514         if BOTH_ARE_ELEMENT(cl):
   1515             return coercion_model.bin_op(left, right, mul)

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element._mul_ (build/cythonized/sage/structure/element.c:12522)()
   1557             raise bin_op_exception('*', self, other)
   1558         else:
-> 1559             return python_op(other)
   1560 
   1561     cdef _mul_long(self, long n):

~/sage-develop/local/lib/python3.8/site-packages/sage/rings/lazy_series.py in _mul_(self, other)
   2508             and right.order() == 1):
   2509             return self
-> 2510         coeff = Stream_dirichlet_convolve(left, right)
   2511         # Performing exact arithmetic is slow because the series grow large
   2512         #   very quickly as we are multiplying the degree

~/sage-develop/local/lib/python3.8/site-packages/sage/data_structures/stream.py in __init__(self, left, right)
   1444             raise NotImplementedError
   1445 
-> 1446         assert left._approximate_order > 0 and right._approximate_order > 0, "Dirichlet convolution is only defined for coefficient streams with minimal index of nonzero coefficient at least 1"
   1447 
   1448         vl = left._approximate_order

AssertionError: Dirichlet convolution is only defined for coefficient streams with minimal index of nonzero coefficient at least 1
```



---

Comment by mantepse created at 2021-08-27 09:32:41

In fact:

```
sage: D = LazyDirichletSeriesRing(QQ, "s")
sage: L.<t> = LazyLaurentSeriesRing(D)
sage: zeta = D(constant=1)
sage: t*L(zeta)
(1 + 1/(2^s) + 1/(3^s) + O(1/(4^s)))*t
sage: L(1)-t*L(zeta)
<repr(<sage.rings.lazy_series_ring.LazyLaurentSeriesRing_with_category.element_class at 0x7f51ac047680>) failed: ValueError: undecidable as lazy Laurent series>
sage: t*zeta
...
AssertionError: Dirichlet convolution is only defined for coefficient streams with minimal index of nonzero coefficient at least 1
```



---

Comment by mantepse created at 2021-08-27 09:38:53

This possibly belongs to the #31897...

```
sage: A.<t> = LazyLaurentSeriesRing(QQ)
sage: B.<z> = LazyLaurentSeriesRing(A)
sage: 1/(1-B(t)*z)
1 + t*z + (t^2 + O(t^9))*z^2 + (t^3 + O(t^10))*z^3 + (t^4 + O(t^11))*z^4 + (t^5 + O(t^12))*z^5 + (t^6 + O(t^13))*z^6 + O(z^7)
sage: 1/(1-t*z)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-40-8a7010489778> in <module>
----> 1 Integer(1)/(Integer(1)-t*z)

~/sage-develop/local/lib/python3.8/site-packages/sage/rings/integer.pyx in sage.rings.integer.Integer.__truediv__ (build/cythonized/sage/rings/integer.c:14503)()
   2053             return y
   2054 
-> 2055         return coercion_model.bin_op(left, right, operator.truediv)
   2056 
   2057     cpdef _div_(self, right):

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/coerce.pyx in sage.structure.coerce.CoercionModel.bin_op (build/cythonized/sage/structure/coerce.c:10671)()
   1202             self._record_exception()
   1203         else:
-> 1204             return PyObject_CallObject(op, xy)
   1205 
   1206         if op is mul:

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element.__truediv__ (build/cythonized/sage/structure/element.c:13152)()
   1733         cdef int cl = classify_elements(left, right)
   1734         if HAVE_SAME_PARENT(cl):
-> 1735             return (<Element>left)._div_(right)
   1736         if BOTH_ARE_ELEMENT(cl):
   1737             return coercion_model.bin_op(left, right, truediv)

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element._div_ (build/cythonized/sage/structure/element.c:13412)()
   1771             raise bin_op_exception('/', self, other)
   1772         else:
-> 1773             return python_op(other)
   1774 
   1775     def __floordiv__(left, right):

~/sage-develop/local/lib/python3.8/site-packages/sage/rings/lazy_series.py in _div_(self, other)
   1487         if (isinstance(left, Stream_exact)
   1488             and isinstance(right, Stream_exact)):
-> 1489             if not left._constant and not right._constant:
   1490                 R = P._laurent_poly_ring
   1491                 # pl = left.polynomial_part(R)

~/sage-develop/local/lib/python3.8/site-packages/sage/rings/lazy_series.py in __bool__(self)
    538         if self[self._coeff_stream._approximate_order]:
    539             return True
--> 540         raise ValueError("undecidable as lazy Laurent series")
    541 
    542     def define(self, s):

ValueError: undecidable as lazy Laurent series
```



---

Comment by mantepse created at 2021-08-27 10:11:47

Worse:

```
sage: A.<t> = LazyLaurentSeriesRing(QQ)
sage: B.<z> = LazyLaurentSeriesRing(A)
sage: 1-z
<repr(<sage.rings.lazy_series_ring.LazyLaurentSeriesRing_with_category.element_class at 0x7f9f96a70a40>) failed: ValueError: undecidable as lazy Laurent series>
```



---

Comment by mantepse created at 2021-08-27 12:14:35

I have fixed all of these, however, most of the fixes belong into #31897.


---

Comment by tscrim created at 2021-08-27 12:25:00

It would be better to not do it on #31897 as that has been positively reviewed for a bit. If Volker has already merged it into his upcoming beta branch, then the new commits might be lost. It really should be on a followup ticket.

We also should not be making any promises on doing things over lazy series because we are being very cautious about equality checking and raising errors (in places that are almost never supposed to raise them).

That being said, the last one is really bad and some basic things like that should work.


---

Comment by git created at 2021-08-27 12:27:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-27 12:29:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-08-27 12:30:57

I'm sorry, too late, please forgive.


---

Comment by mantepse created at 2021-08-27 14:02:40

Another one:

```
sage: D = LazyDirichletSeriesRing(QQ, "s")
sage: L.<z> = LazyLaurentSeriesRing(D)
sage: e = L(lambda n: D(1/factorial(n)), 0)
sage: e
1 + z + 1/2*z^2 + 1/6*z^3 + 1/24*z^4 + 1/120*z^5 + 1/720*z^6 + O(z^7)
sage: e = L(lambda n: 1/factorial(n), 0)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-22-db8dff4bdc41> in <module>
----> 1 e = L(lambda n: Integer(1)/factorial(n), Integer(0))

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9365)()
    898                 return mor._call_(x)
    899             else:
--> 900                 return mor._call_with_args(x, args, kwds)
    901 
    902         raise TypeError(_LazyString(_lazy_format, ("No conversion defined from %s to %s", R, self), {}))

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_with_args (build/cythonized/sage/structure/coerce_maps.c:5153)()
    178                 print(type(C), C)
    179                 print(type(C._element_constructor), C._element_constructor)
--> 180             raise
    181 
    182 

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_with_args (build/cythonized/sage/structure/coerce_maps.c:4993)()
    171             else:
    172                 if len(kwds) == 0:
--> 173                     return C._element_constructor(x, *args)
    174                 else:
    175                     return C._element_constructor(x, *args, **kwds)

~/sage-develop/local/lib/python3.8/site-packages/sage/rings/lazy_series_ring.py in _element_constructor_(self, x, valuation, constant, degree)
    589                     raise ValueError("you must specify the degree for the polynomial 0")
    590                 degree = valuation
--> 591             if x == R.zero():
    592                 coeff_stream = Stream_exact([], self._sparse, order=degree, constant=constant)
    593                 return self.element_class(self, coeff_stream)

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element.__richcmp__ (build/cythonized/sage/structure/element.c:10345)()
   1107             # an instance of Element. The explicit casts below make
   1108             # Cython generate optimized code for this call.
-> 1109             return (<Element>self)._richcmp_(other, op)
   1110         else:
   1111             return coercion_model.richcmp(self, other, op)

~/sage-develop/local/lib/python3.8/site-packages/sage/rings/polynomial/laurent_polynomial.pyx in sage.rings.polynomial.laurent_polynomial.LaurentPolynomial_univariate._richcmp_ (build/cythonized/sage/rings/polynomial/laurent_polynomial.c:15758)()
   1429             y.extend([zero] * (len(x) - len(y)))
   1430 
-> 1431         return richcmp(x, y, op)
   1432 
   1433     def valuation(self, p=None):

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/richcmp.pxd in sage.structure.richcmp.richcmp (build/cythonized/sage/rings/polynomial/laurent_polynomial.c:37615)()
     48         False
     49     """
---> 50     return PyObject_RichCompare(x, y, op)
     51 
     52 

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element.__richcmp__ (build/cythonized/sage/structure/element.c:10345)()
   1107             # an instance of Element. The explicit casts below make
   1108             # Cython generate optimized code for this call.
-> 1109             return (<Element>self)._richcmp_(other, op)
   1110         else:
   1111             return coercion_model.richcmp(self, other, op)

~/sage-develop/local/lib/python3.8/site-packages/sage/structure/element.pyx in sage.structure.element.Element._richcmp_ (build/cythonized/sage/structure/element.c:10451)()
   1111             return coercion_model.richcmp(self, other, op)
   1112 
-> 1113     cpdef _richcmp_(left, right, int op):
   1114         r"""
   1115         Basic default implementation of rich comparisons for elements with

~/sage-develop/local/lib/python3.8/site-packages/sage/rings/lazy_series.py in _richcmp_(self, other, op)
    467                 if self._coeff_stream != other._coeff_stream:
    468                     return False
--> 469                 raise ValueError("undecidable")
    470 
    471             # Both are Stream_exact, which implements a full check

ValueError: undecidable
```



---

Comment by mantepse created at 2021-08-27 14:22:39

One problem is, that `R(x)` in `_element_constructor_` succeeds:

```
        R = self._laurent_poly_ring
        BR = self.base_ring()
        try:
            # Try to build stuff using the polynomial ring constructor
            x = R(x)
        except (TypeError, ValueError):
            pass
```

`R` is the `Univariate Laurent Polynomial Ring in z over Lazy Dirichlet Series Ring in s over Rational Field`, and `x` is converted into a lazy Dirichlet series, because it is callable.


---

Comment by mantepse created at 2021-08-27 14:49:52

I guess the correct solution is to make the arguments given to the `element_constructor` more explicit: we could, for example, have an optional argument `coefficients`, and do something like

```
if coefficients is None:
    proceed as we currently do
else:
   assert x == 0
   ...
```



---

Comment by mantepse created at 2021-08-29 17:29:11

Autsch.

```
sage: D = LazyDirichletSeriesRing(QQ, "s")
sage: zeta = D(constant=1)
sage: zeta*(2-zeta)
1 + 1/(2^s) + 1/(3^s) + O(1/(4^s))
sage: zeta*(-2+zeta)
-1 + 1/(4^s) + 2/6^s + O(1/(8^s))
sage: zeta*(2-zeta)
1 + 1/(2^s) + 1/(3^s) + O(1/(4^s))
sage: zeta*(2-zeta).truncate(10)
1 - 1/(4^s) - 2/6^s + O(1/(8^s))
```



---

Comment by git created at 2021-08-29 17:52:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-08-31 20:28:04

Autsch part 2:

```
sage: D = LazyDirichletSeriesRing(QQ, "s")
sage: ~D(1)
1 + O(1/(8^s))
sage: ~D.one()
-2 + O(1/(8^s))
```



---

Comment by git created at 2021-08-31 20:48:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-09-01 08:14:29

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-09-01 09:00:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-09-01 09:01:51

Changing status from new to needs_review.


---

Comment by mantepse created at 2021-09-01 09:01:51

I think that this is ready, too.


---

Comment by tscrim created at 2021-09-01 12:42:54

Ah, right, the coercion system defaults to sending `0` as an input.

I also wanted to avoid having that massive `coefficients is None` block, but perhaps there is no way around that. We need to also change the `.. NOTE::` and make the corresponding change for the lazy Dirichlet series element constructor as that will run into the same problem.

I don't think we should cache `monomial` as that is a good way to each up memory with a lot of transient objects.

We should keep using `_polynomial_part` in `_div_` and `__pow__` (preferred) or we should implement a faster version for the lazy Laurent series. I know you are thinking a bit about the Taylor series (which should be handled on that ticket since we can test it there), but I think we can simply extend the `_polynomial_part` to have a `multivariate` option since at some point somewhere, that has to be handled slightly differently.


---

Comment by git created at 2021-09-02 07:07:01

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-09-02 07:14:15

Unfortunately, allowing exotic base rings for `LazyDirichletSeriesRing` involves some work, because its 'truncated ring'  is currently simply the symbolic ring.

Here is, what might become a doctest:

```
        In the next example the argument is interpreted as a constant
        polynomial, which happens to be a Dirichlet series::

            sage: D = LazyDirichletSeriesRing(QQ, "s")
            sage: E = LazyDirichletSeriesRing(D, "t")
            sage: E(lambda n: 1/factorial(n))

        We can also specify that the given function should be
        interpreted as the coefficients of the Laurent series::

            sage: E(coefficients=lambda n: 1/factorial(n))[:10]
```


I completely forgot about `finite_part`, etc.  I guess we will have to resolve this in this ticket, or should we postpone it further?


---

Comment by git created at 2021-09-02 08:56:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-09-02 09:15:18

Let me try to summarise my view on the situation concerning `finite_part`:

* the idea of `finite_part` is to return the truncation of `self` as an element of the appropriate truncation ring `self.parent()._laurent_poly_ring`.  A slow generic version is possible (using `self.parent().monomial()`), a fast version could be provided by the individual classes.  In fact, I'd expect that any sensible `self.parent()._laurent_poly_ring` would support construction from a list, which would then be fast.  This should not be significantly slower than calling `Stream_exact._polynomial_part()`, there would be one additional `isinstance` check, but more useful, because it could include the case of non-exact series.  I think it should also render the `LazyLaurentSeries.polynomial` method obsolete.

* Is it possible to make `L._element_constructor(x)` fast when `x` is an element of `L._laurent_poly_ring`?  If not, it may make sense to have a specialised method in `L` that does this.  This would also help making `L._element_constructor` easier to read.

* The code in `LazyCauchyProductSeries._div_` and `_pow_` is currently duplicating the corresponding bits of `L._element_constructor` does, which is not ideal because it increases the likelihood of bugs.  (in fact, it was sheer luck that I noticed a bug which occurred because of the rename from `valuation` to `order` and because the corresponding doctest missed the `sage:` prefix)


---

Comment by mantepse created at 2021-09-02 19:02:49

Here is code that I just wrote, but I'm not sure how helpful it is.
Right now it seems more useful to me to have a method that turns a _list_ into a series, because what I wrote below doesn't work for the Dirichlet case, unless we force the developer to write a class for Dirichlet polynomials.  (I am not against writing this class, I am against making the framework harder to extend.)

```diff
diff --git a/src/sage/data_structures/stream.py b/src/sage/data_structures/stream.py
index 552aeafcc1..e3d78882f1 100644
--- a/src/sage/data_structures/stream.py
+++ b/src/sage/data_structures/stream.py
@@ -526,7 +526,8 @@ class Stream_exact(Stream):
         else:
             self._degree = degree
 
-        assert order + len(initial_coefficients) <= self._degree
+        if order + len(initial_coefficients) > self._degree:
+            raise ValueError("the given degree is too small")
 
         # We do not insist that the last entry of
         # initial_coefficients is different from constant in case
diff --git a/src/sage/rings/lazy_series_ring.py b/src/sage/rings/lazy_series_ring.py
index aeb5d15687..252b86cfb8 100644
--- a/src/sage/rings/lazy_series_ring.py
+++ b/src/sage/rings/lazy_series_ring.py
@@ -405,6 +405,56 @@ class LazyLaurentSeriesRing(UniqueRepresentation, Parent):
         # by UnitalAlgebras.ParentMethods._coerce_map_from_base_ring.
         return self._generic_coerce_map(self.base_ring())
 
+    def _from_polynomial(self, x, valuation, degree, constant):
+        """
+        Construct a Laurent series from a Laurent polynomial ``x``.
+
+        INPUT:
+
+        - ``x`` -- a Laurent polynomial
+        - ``valuation`` -- ``None`` or an integer specifying the
+          valuation of the resulting series
+        - ``degree`` -- ``None`` or an integer specifying the degree
+          from which the coefficients are eventually ``constant``
+        - ``constant`` -- ``None`` or an element of the base ring,
+          specifying the value of all coefficients larger than
+          ``degree``
+
+        EXAMPLES::
+
+            sage: P.<x> = LaurentPolynomialRing(QQ)
+            sage: p = x^-2 + 3*x^3
+            sage: L.<x> = LazyLaurentSeriesRing(ZZ)
+            sage: L._from_polynomial(p, None, None, None)
+            x^-2 + 3*x^3
+            sage: L._from_polynomial(p, None, None, 1)
+            x^-2 + 3*x^3 + x^4 + x^5 + x^6 + O(x^7)
+            sage: L._from_polynomial(p, 0, None, 1)
+            1 + 3*x^5 + x^6 + x^7 + x^8 + O(x^9)
+            sage: L._from_polynomial(p, 0, 10, 1)
+            1 + 3*x^5 + x^10 + x^11 + x^12 + O(x^13)
+            sage: L._from_polynomial(p, 0, 1, 1)
+            Traceback (most recent call last):
+            ...
+            ValueError: the given degree is too small
+
+        """
+        if not x and not constant:
+            return self.zero()
+        if x and valuation is not None:
+            x = x.shift(valuation - x.valuation())
+        if degree is None and not x:
+            if valuation is None:
+                raise ValueError("you must specify the degree for the polynomial 0")
+            degree = valuation
+        if not x:
+            coeff_stream = Stream_exact([], self._sparse, order=degree, constant=constant)
+            return self.element_class(self, coeff_stream)
+        initial_coefficients = [x[i] for i in range(x.valuation(), x.degree() + 1)]
+        coeff_stream = Stream_exact(initial_coefficients, self._sparse,
+                                    order=x.valuation(), constant=constant, degree=degree)
+        return self.element_class(self, coeff_stream)
+
     def _element_constructor_(self, x=None, valuation=None, degree=None, constant=None, coefficients=None):
         """
         Construct a Laurent series from ``x``.
@@ -657,24 +707,8 @@ class LazyLaurentSeriesRing(UniqueRepresentation, Parent):
                 x = R(x)
             except (TypeError, ValueError):
                 pass
-
-            # If x has been converted to the Laurent polynomial ring
-            if parent(x) is R:
-                if not x and not constant:
-                    return self.zero()
-                if x and valuation is not None:
-                    x = x.shift(valuation - x.valuation())
-                if degree is None and not x:
-                    if valuation is None:
-                        raise ValueError("you must specify the degree for the polynomial 0")
-                    degree = valuation
-                if x == R.zero():
-                    coeff_stream = Stream_exact([], self._sparse, order=degree, constant=constant)
-                    return self.element_class(self, coeff_stream)
-                initial_coefficients = [x[i] for i in range(x.valuation(), x.degree() + 1)]
-                coeff_stream = Stream_exact(initial_coefficients, self._sparse,
-                                                       order=x.valuation(), constant=constant, degree=degree)
-                return self.element_class(self, coeff_stream)
+            else:
+                return self._from_polynomial(x, valuation, degree, constant)
 
             if isinstance(x, LazyCauchyProductSeries):
                 if x._coeff_stream._is_sparse is not self._sparse:
@@ -689,8 +723,8 @@ class LazyLaurentSeriesRing(UniqueRepresentation, Parent):
                         if valuation is None:
                             raise ValueError("you must specify the degree for the polynomial 0")
                         degree = valuation
-                    coeff_stream = Stream_exact([], self._sparse, order=degree,
-                                                           constant=constant)
+                    coeff_stream = Stream_exact([], self._sparse,
+                                                order=degree, constant=constant)
                     return self.element_class(self, coeff_stream)
 
                 # Make the result exact
@@ -734,8 +768,8 @@ class LazyLaurentSeriesRing(UniqueRepresentation, Parent):
             p = [BR(x(i)) for i in range(valuation, degree)]
             if not any(p) and not constant:
                 return self.zero()
-            coeff_stream = Stream_exact(p, self._sparse, order=valuation,
-                                                   constant=constant, degree=degree)
+            coeff_stream = Stream_exact(p, self._sparse,
+                                        order=valuation, constant=constant, degree=degree)
             return self.element_class(self, coeff_stream)
 
         raise ValueError(f"unable to convert {x} into a lazy Laurent series")
```



---

Comment by mantepse created at 2021-09-14 08:44:05

Dear Travis!

Since the lazy backend is now merged, I think it would be good to attempt progress on this one.

I am not sure how fruitful it is to think about `finite_part`, `_polynomial_part` and `polynomial` now.  Possibly it is best to remove `finite_part` from this ticket entirely, and think about it when finalizing #32324. See also comment:55.

Another, different thing to consider: I'm afraid that eventually it is necessary to have a proper `truncated ring` structure for `_laurent_poly_ring` (warning, misnomer), because eventually somebody will want to do computations over exotic coefficient rings.  See comment:53.

Finally, I noticed that exact multiplication is commented out for Dirichlet series, because it is slow.  This is true, of course.  I guess, however, what is really slow and badly done and should be improved in a separate ticket is the fallback mechanism for composition, currently only used for Dirichlet series:

```python
        if isinstance(g, LazyDirichletSeries):
            if g._coeff_stream._approximate_order == 1:
                if g._coeff_stream[1] != 0:
                    raise ValueError("can only compose with a positive valuation series")
                g._coeff_stream._approximate_order = 2
            # we assume that the valuation of self[i](g) is at least i
            def coefficient(n):
                return sum(self[i] * (g**i)[n] for i in range(n+1))
            coeff_stream = Stream_function(coefficient, P._coeff_ring, P._sparse, 1)
            return P.element_class(P, coeff_stream)
```

Note that `(g**i)[n]` will compute terms which are finally thrown away again.  I am guessing that the correct solution would be a generic composition class in `stream.py`.

To conclude: how about removing `finite_part`, and open new tickets (possibly recycling some ticket numbers) for the three points above, and be done with it for now?


---

Comment by git created at 2021-09-16 04:23:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-09-16 04:30:06

Sorry for not being able to get to this sooner. I had to try a few different things, but I think I settled on something that works well and eliminates a lot of duplication.

The main thing I did was implement an `_internal_poly_ring` attribute that uses a Laurent poly ring to parse in lists and the like for Dirichlet series as a transient object for the `_element_constructor_`. I guess this could be replaced by the `_coeff_ring` in the Taylor series ticket. Now everything flows through one `_element_constructor_` with a little bit of data prep for the Dirichlet series.

I fixed up the documentation and fixed some other failures from the file renaming I didn't catch earlier (thank you patchbots). I also removed mostly duplicate `change_ring()`. I renamed `monomial` to `_monomial` and implemented a fallback option for Dirichlet series.

I removed the `finite_part()` as we can reintroduce that later when we need it.

I agree with you that the best way to implement composition would be to add another `Stream` subclass to store the intermediate powers in the generic case.


---

Comment by mantepse created at 2021-09-16 13:05:31

Wow, you put in a lot of work!

I don't really understand the meaning of `_internal_poly_ring` yet.

There is one issue, which is important to me (and a doctest in the Taylor ticket, which, for some reason, I overlooked while backporting).  I am against ordinary polynomials being re-interpreted as Dirichlet series.  This is going to be a source of bugs which are very hard to understand.

```
sage: D = LazyDirichletSeriesRing(ZZ, 't')
sage: m = D(moebius); m
1 - 1/(2^t) - 1/(3^t) - 1/(5^t) + 1/(6^t) - 1/(7^t) + O(1/(8^t))
sage: P.<x, y> = QQ[]
sage: L.<z> = LazyLaurentSeriesRing(P)
sage: L(m)
z - z^2 - z^3 - z^5 + z^6 - z^7 + O(z^8)
```

Also, continuing with the definitions above, I think the below is at least fishy:

```
sage: R.<q> = QQ[]
sage: L(q)
z
sage: L(x)
x
sage: D(q)
1
sage: L(q^-1)
z^-1
sage: D(q^-1)
1
sage: D(x)
<repr(<sage.rings.lazy_series_ring.LazyDirichletSeriesRing_with_category.element_class at 0x7faeaca0c640>) failed: TypeError: number of arguments does not match number of variables in parent>
```


Note that the element constructor for polynomials is stricter here, and I think that this is how it should be:

```
sage: R(x)
...
TypeError: not a constant polynomial
```



---

Comment by git created at 2021-09-16 23:34:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-09-16 23:44:20

Replying to [comment:60 mantepse]:
> Wow, you put in a lot of work!
> 
> I don't really understand the meaning of `_internal_poly_ring` yet.

It is something that we use to internally to manipulate things. Mainly it is a way around the `shift` issue (although with a bit more data preprocessing in the Dirichlet `_element_constructor_`, it might become redundant; this was the lazier approach).

> There is one issue, which is important to me (and a doctest in the Taylor ticket, which, for some reason, I overlooked while backporting).  I am against ordinary polynomials being re-interpreted as Dirichlet series.  This is going to be a source of bugs which are very hard to understand.
> {{{
> sage: D = LazyDirichletSeriesRing(ZZ, 't')
> sage: m = D(moebius); m
> 1 - 1/(2^t) - 1/(3^t) - 1/(5^t) + 1/(6^t) - 1/(7^t) + O(1/(8^t))
> sage: P.<x, y> = QQ[]
> sage: L.<z> = LazyLaurentSeriesRing(P)
> sage: L(m)
> z - z^2 - z^3 - z^5 + z^6 - z^7 + O(z^8)
> }}}

When you say ordinary polynomials, do you mean Laurent/Taylor/etc. series? I think this conversion is fine; it is not a coercion. IMO, we should trust that users knows what they is doing. We should not go out of our way to tell users they are misusing something. However, if you feel strongly about it, I know a way to easily extend things to stop this conversion, but I think it is a small bit of technical debt.

> Also, continuing with the definitions above, I think the below is at least fishy:
> {{{
> sage: R.<q> = QQ[]
> sage: L(q)
> z
> sage: L(x)
> x
> sage: D(q)
> 1
> sage: L(q^-1)
> z^-1
> sage: D(q^-1)
> 1
> sage: D(x)
> <repr(<sage.rings.lazy_series_ring.LazyDirichletSeriesRing_with_category.element_class at 0x7faeaca0c640>) failed: TypeError: number of arguments does not match number of variables in parent>
> }}}

I have fixed it so that `D(q^-1)` no longer thinks it is a valid series.

> Note that the element constructor for polynomials is stricter here, and I think that this is how it should be:
> {{{
> sage: R(x)
> ...
> TypeError: not a constant polynomial
> }}}

I am pretty sure we cannot do anything better here because we take callables as valid input and perhaps someone wants to use a polynomial (which doesn't convert into the internal poly ring) to compute coefficients. I believe your previous code would have the same behavior.


---

Comment by mantepse created at 2021-09-17 15:00:01

Replying to [comment:62 tscrim]:
> Replying to [comment:60 mantepse]:

> > I don't really understand the meaning of `_internal_poly_ring` yet.
> 
> It is something that we use to internally to manipulate things. Mainly it is a way around the `shift` issue (although with a bit more data preprocessing in the Dirichlet `_element_constructor_`, it might become redundant; this was the lazier approach).

I cannot remember what the `shift` issue is, sorry.

> When you say ordinary polynomials, do you mean Laurent/Taylor/etc. series?

Both.  I think that all of the following should raise errors:

```
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: D = LazyDirichletSeriesRing(QQ, 't')
sage: P.<q> = QQ[]
sage: D(z) # this is extremely fishy, the result is not in the correct ring
z
sage: D(q)
1
sage: D(q) == D(1)
True
sage: L(D([1,2,3]))
z + 2*z^2 + 3*z^3
```


I was actually mistaken that the polynomial ring would be much stricter, there seems to be some inconsistency:

```
sage: R.<x,y> = QQ[]
sage: S.<q> = QQ[]
sage: T.<t> = QQ[]
sage: T(q)
t
sage: T(x)
TypeError                                 Traceback (most recent call last)
...
TypeError: not a constant polynomial
```


> I am pretty sure we cannot do anything better here because we take callables as valid input and perhaps someone wants to use a polynomial (which doesn't convert into the internal poly ring) to compute coefficients. I believe your previous code would have the same behavior.

At least before your work, using a polynomial `p` as a callable (via the `coefficients` argument) would produce the series with coefficients `p(0), p(1), ...` in the Laurent case, which I think is fine.

What I think is not correct is that a (Laurent or ordinary) polynomial or a Laurent of Dirichlet series is interpreted as a sequence of coefficients.  This didn't happen before, at least not in the Taylor ticket code.


---

Comment by git created at 2021-09-21 07:39:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-09-21 07:41:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-09-21 07:46:42

The first was a bug, which I fixed. Then I got rid of that because I implemented a bit of a hack to prohibit what you want (I think that is unnecessary because of the `coefficients` parameter and it is not wrong to do this) and not have lots of duplicated code.


---

Comment by mantepse created at 2021-09-21 11:24:22

OK.  I am still unhappy about the following:

```
sage: L.<z> = LazyLaurentSeriesRing(QQ)
sage: D = LazyDirichletSeriesRing(QQ, 't')
sage: L(D(z))
z + 2*z^2 + 3*z^3 + 4*z^4 + 5*z^5 + 6*z^6 + 7*z^7 + O(z^8)
sage: L(D([1,2,3]))
z + 2*z^2 + 3*z^3
sage: D(L([1,2,3]))
6 + 17/2^t + 34/3^t + 57/4^t + 86/5^t + 121/6^t + 162/7^t + O(1/(8^t))
```

I also think it would be better to disallow polynomial input for Dirichlet series.  I would rather require the user here to ask for `D(coefficients=q^2+1)`.

```
sage: P.<q> = QQ[]
sage: D(q^2+1)
2 + 5/2^t + 10/3^t + 17/4^t + 26/5^t + 37/6^t + 50/7^t + O(1/(8^t))
```



---

Comment by git created at 2021-09-26 06:19:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2021-09-26 06:23:58

Replying to [comment:67 mantepse]:
> OK.  I am still unhappy about the following:
> {{{
> sage: L.<z> = LazyLaurentSeriesRing(QQ)
> sage: D = LazyDirichletSeriesRing(QQ, 't')
> sage: L(D(z))
> z + 2*z^2 + 3*z^3 + 4*z^4 + 5*z^5 + 6*z^6 + 7*z^7 + O(z^8)
> sage: L(D([1,2,3]))
> z + 2*z^2 + 3*z^3
> sage: D(L([1,2,3]))
> 6 + 17/2^t + 34/3^t + 57/4^t + 86/5^t + 121/6^t + 162/7^t + O(1/(8^t))
> }}}

I made it so the first two fail, but they only fail because finite length Dirichlet series are not callable. If they become callable, then it will give a valid series output. I do not want to spend any more time making the code more brittle and complex to prevent some user input that may or may not be unwanted. There is no way to change the last one because it is callable and gets treated like a coefficient function, which is something the user might want. I would get upset as a user if `moebius` worked without naming the argument but another callable does not.

> I also think it would be better to disallow polynomial input for Dirichlet series.  I would rather require the user here to ask for `D(coefficients=q^2+1)`.
> {{{
> sage: P.<q> = QQ[]
> sage: D(q^2+1)
> 2 + 5/2^t + 10/3^t + 17/4^t + 26/5^t + 37/6^t + 50/7^t + O(1/(8^t))
> }}}

See comment above about callables.

Greetings from Japan.


---

Comment by git created at 2021-09-27 11:43:32

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dimpase created at 2021-09-27 11:45:07

please check that this merge makes sense.


---

Comment by tmonteil created at 2021-09-27 11:45:32

Just a small suggestion: the `á` in `Kalmár` is not an ASCII letter, hence you should add the line `# -*- coding: utf-8 -*-` in the beginning of the `src/sage/rings/lazy_series.py` file.


---

Comment by git created at 2021-09-27 12:30:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2021-09-27 12:33:24

Changing status from needs_review to positive_review.


---

Comment by mantepse created at 2021-09-27 12:33:24

I agree with your assessment!  Thank you!


---

Comment by tscrim created at 2021-09-28 11:30:18

Replying to [comment:73 tmonteil]:
> Just a small suggestion: the `á` in `Kalmár` is not an ASCII letter, hence you should add the line `# -*- coding: utf-8 -*-` in the beginning of the `src/sage/rings/lazy_series.py` file.

I also said the same thing on another ticket before someone pointed out to me this is no longer necessary now that we are Python3 only.


---

Comment by vbraun created at 2021-10-09 11:09:59

Resolution: fixed
