# Issue 26107: Nilpotent Lie groups

Issue created by migration from https://trac.sagemath.org/ticket/26344

Original creator: @ehaka

Original creation time: 2018-09-25 06:28:14

CC:  tscrim egourgoulhon

Keywords: Lie groups, Lie algebras, manifolds, nilpotent

Implementation of nilpotent Lie groups as manifolds with a distinguished global coordinate system (exponential coordinates).

Planned features:

* representation of elements in exponential coordinates of the first or second kind
* multiplication of symbolic points (using the manifold point framework)
* the frames of left-invariant and right-invariant vector fields
* the exponential map `exp:\mathfrak{g}\to G` and the logarithm
* the adjoint map `Ad:G\times \mathfrak{g}\to\mathfrak{g}`


---

Comment by @ehaka created at 2018-09-25 06:38:57

A partial first version is now ready, containing the exponential map, exponential coordinates of the first and second kind and group multiplication. Vector fields and the adjoint map are still completely missing, but I thought it would be good to get a working copy up in case there are already some glaring flaws.

In particular, one thing that did not feel quite right was the current method of computing the symbolic group law. The only way I could think of was to extract the structural coefficients of the Lie algebra and to create a new Lie algebra over `SR` using the same structural coefficients. Two immediate issues of the current approach are

1. the overhead of creating a new Lie algebra
2. the original base ring of the Lie algebra needs to admit a coercion into `SR`

Another thing is how to handle the symbolic group law. Currently it is done by creating two dummy-variables, computing the group law as a vector expression in exponential coordinates (through the BCH formula) and then evaluating the group law by substitution of the dummy-variables.

This is still work-in-progress, but I would be happy to hear comments or suggestions.
----
New commits:


---

Comment by tscrim created at 2018-09-25 07:25:37

Eric, I am cc-ing you in case you have any comments.

The symbolic ring is usually a bit of a slow beast. it definitely feels wrong to have to have a second copy of the Lie algebra over `SR`. You probably could just use the structure coeffs info.

Anyways, I will think more about this.


---

Comment by egourgoulhon created at 2018-09-25 21:18:50

Good to see that Lie groups are arriving in Sage!
I'll have a look tomorrow, focusing on the `SR` issue.


---

Comment by git created at 2018-09-26 05:56:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-09-26 10:04:51

I am not sure I agree with caching the `*_invariant_frame`. I think this is already done by the atlas for the manifold and there is probably not much benefit to having this cached at the top level as not a lot of computation is done in the methods themselves.

Another comment is that `structure_coefficients` should exist anytime the Lie algebra has a basis because of the category. I believe the `variable_names()` and `indices()` should not fail either. So I don't see a meaningful exception being thrown.

Now that I have enough time, I see why you are using the symbolic ring to create the group law. You are considering things as generic parameters and seeing what the result is. In principle, creating the `LieAlgebraWithStructureCoefficients` should be relatively quick. It might be better to implement a `change_ring()` method for the class instead of the helper function (which could have more general use). Unfortunately I don't see a way out of creating that (at least, one that is efficient), but it should not take a lot (well, a disproportionate amount) of memory.


---

Comment by @ehaka created at 2018-09-26 12:26:35

Replying to [comment:6 tscrim]:
> I am not sure I agree with caching the `*_invariant_frame`. I think this is already done by the atlas for the manifold and there is probably not much benefit to having this cached at the top level as not a lot of computation is done in the methods themselves.

Right, I did not realize there is manifold level caching. I will remove it from here.

> Another comment is that `structure_coefficients` should exist anytime the Lie algebra has a basis because of the category. 

This is a good point, and I should in fact change `indices()` to `basis().keys()` as in the category code of `structure_coefficients`, so it will work regardless within the category.

> It might be better to implement a `change_ring()` method for the class instead of the helper function (which could have more general use).

Ideally construction of a Lie group would not rely on the Lie algebra having a `change_ring()` method, but instead only rely on things required/defined in the finite dimensional (nilpotent) Lie algebras with basis category. 

However it would make sense to by default use `change_ring` if it exists, and to implement this at least for `LieAlgebraWithStructureCoefficients`. Then only in the case when `change_ring` is not defined, the code could fall back to creation of a new Lie algebra using `structure_coefficients()`.

Thanks for the comments!


---

Comment by git created at 2018-09-26 16:19:09

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by egourgoulhon created at 2018-09-26 22:23:07

I gave a first glance: this looks very nice!

A very minor remark: in the example shown in line 151 of `lie_group.py` (as well as in other similar examples), a shortcut for

```
sage: list(X[0].components(exp1_frame))
```

is 

```
sage: X[0][exp1_frame,:]
```

Maybe you chose the longer version as being more explicit?
Also you can display the components of the vector field `X[0]` by

```
sage: X[0].display(exp1_frame)
X_0 = d/dx_0 - 1/2*x_1 d/dx_2
```

Since `exp1_frame` is the default vector frame on `G`, this can be shorten to simply
`X[0].display()`.


---

Comment by @ehaka created at 2018-09-27 04:36:22

Replying to [comment:9 egourgoulhon]:
> I gave a first glance: this looks very nice!
>
> A very minor remark: in the example shown in line 151 of `lie_group.py` (as well as in other similar examples), a shortcut for
> {{{
> sage: list(X[0].components(exp1_frame))
> }}}
> is 
> {{{
> sage: X[0][exp1_frame,:]
> }}}
> Maybe you chose the longer version as being more explicit?
> Also you can display the components of the vector field `X[0]` by
> {{{
> sage: X[0].display(exp1_frame)
> X_0 = d/dx_0 - 1/2*x_1 d/dx_2
> }}}

This choice was just a consequence of lack of knowledge on my part. Thanks for the advice, this will clean up the doc quite a bit!

> Since `exp1_frame` is the default vector frame on `G`, this can be shorten to simply
> `X[0].display()`. 

At this point I don't know what should be the default frame. The best sounding options are either the coordinate frame of the default system of coordinates, or the left-invariant frame.


---

Comment by egourgoulhon created at 2018-09-27 08:42:54

Replying to [comment:10 gh-ehaka]:
> > Since `exp1_frame` is the default vector frame on `G`, this can be shorten to simply
> > `X[0].display()`. 
> 
> At this point I don't know what should be the default frame. The best sounding options are either the coordinate frame of the default system of coordinates, or the left-invariant frame.
In this case, it is probably better to keep the explicit form, i.e. `X[0].display(exp1_frame)`.


---

Comment by egourgoulhon created at 2018-09-27 08:58:36

In the documentation, maybe you could use the method `at()` of vector fields to illustrate that the members of `G.left_invariant_frame()` do obey the definition of a left invariant vector field, for instance:

```
sage: L = lie_algebras.Heisenberg(QQ, 1)
sage: G = NilpotentLieGroup(L, 'G'); G
Lie group of Heisenberg algebra of rank 1 over Rational Field
sage: p,q,z = L.basis()
```

Let us first introduce a specific element `k` and generic element `g` in `G`: 

```
sage: k = G.exp(p)*G.exp(q); k
exp(p1 + q1 + 1/2*z)
sage: g = G(G.chart_exp1()[:]); g  # a generic element of G
exp(x_0*p1 + x_1*q1 + x_2*z)
```

We introduce next the left translation by `k`:

```
sage: L_k = G.diff_map(G, coord_functions=(k*g).coordinates()); L_k
Differentiable map from the Lie group of Heisenberg algebra of rank 1 over Rational Field to itself
sage: L_k.display()
G --> G
   (x_0, x_1, x_2) |--> (x_0 + 1, x_1 + 1, -1/2*x_0 + 1/2*x_1 + x_2 + 1/2)
```

Then we check that `X[0]` obeys the definition of a left invariant vector field as follows:

```
sage: X = G.left_invariant_frame(); X
Vector frame (G, (X_0,X_1,X_2))
sage: L_k.differential(g)(X[0].at(g)) == X[0].at(L_k(g))
True
```

Of course, we have as well

```
sage: L_k.differential(g)(X[1].at(g)) == X[1].at(L_k(g))
True
sage: L_k.differential(g)(X[2].at(g)) == X[2].at(L_k(g))
True
```

Of course, a full check would require that `k` is a generic element of `G`; this is possible, by defining `k` from symbolic coordinates.


---

Comment by @ehaka created at 2018-09-27 17:35:16

I moved the code over to a public branch so you can feel free to add improvements in if you so wish. I'm also still happy to hear comments and corrections and do the implementation myself as well.

Replying to [comment:12 egourgoulhon]:
> In the documentation, maybe you could use the method `at()` of vector fields to illustrate that the members of `G.left_invariant_frame()` do obey the definition of a left invariant vector field

Thanks for the suggestion, this is indeed a very good demonstration of basic Lie group functionality. I also ended up adding the creation of left/right translations as a prebuilt method as these maps should see heavy use in practice.

I have still to add in the methods for the logarithm and adjoint maps, after that I would for the moment be satisfied with the basic Lie group functionality. Or at least I can't think of what it is I am missing.
----
New commits:


---

Comment by tscrim created at 2018-09-27 21:54:39

There is also no real penalty for having more tickets (at least, I will continue to be reviewing tickets for at least the next year `:)`). So it doesn't hurt to do things in smaller bites too.


---

Comment by git created at 2018-09-28 05:01:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @ehaka created at 2018-09-28 05:15:52

The missing parts of the initial set of features I had in mind are now in. It didn't seem right to add the adjoint without adding the conjugation map as well so that is now there as well.

At this point I'll move the ticket over to the bug-hunting/improvement phase.


---

Comment by @ehaka created at 2018-09-28 05:15:52

Changing status from new to needs_review.


---

Comment by egourgoulhon created at 2018-09-28 08:34:43

I took the liberty of adding a new section "Lie groups" at the manifold metaticket #18528 and put your ticket there. I hope you don't mind.


---

Comment by egourgoulhon created at 2018-09-28 08:58:39

A question came to my mind: at the moment

```
sage: L = G.lie_algebra(); L
Heisenberg algebra of rank 1 over Rational Field
sage: T1G = G.tangent_space(G.one()); T1G
Tangent space at exp(0)
```

are two different beasts:

```
sage: L.category()
Category of finite dimensional nilpotent lie algebras with basis over Rational Field
sage: T1G.category()
Category of finite dimensional vector spaces over Symbolic Ring
sage: L.basis()
Finite family {'p1': p1, 'q1': q1, 'z': z}
sage: T1G.bases()
[Basis (d/dx_0,d/dx_1,d/dx_2) on the Tangent space at exp(0)]
```

also as Python objects: `L` inherits from `sage.algebras.lie_algebras.lie_algebra.LieAlgebraWithGenerators`, while `T1G` inherits from `sage.tensor.modules.finite_rank_free_module.FiniteRankFreeModule`.

Would it be worth to implement the canonical vector space isomorphism between the two? Would this be useful? A natural way to do it would be via Sage coercions, i.e. implement at least a coercion from `L` to `T1G` (the reverse may not work for vectors with symbolic components). If you think this is worth, this could anyway be postponed to another ticket...


---

Comment by @ehaka created at 2018-09-28 09:28:03

Replying to [comment:17 egourgoulhon]:
> I took the liberty of adding a new section "Lie groups" at the manifold metaticket #18528 and put your ticket there. I hope you don't mind.

This is perfectly fine by me, organization is good.

Replying to [comment:18 egourgoulhon]:
> Would it be worth to implement the canonical vector space isomorphism between the two? Would this be useful? A natural way to do it would be via Sage coercions, i.e. implement at least a coercion from `L` to `T1G` (the reverse may not work for vectors with symbolic components). If you think this is worth, this could anyway be postponed to another ticket...

Yes this makes sense, and at least the simple coercion should be quite immediate to define, since the basis of the Lie algebra and the basis coming from the exponential coordinate frame are already in direct correspondence as lists. 

It might actually also be nice to give `T1G` the full Lie algebra structure and upgrade the coercion to one of Lie algebras. Since vector fields already have a Lie bracket operation defined, this should be doable through computation with the left-invariant frame. It would also allow computing symbolic Lie brackets.

All of this combined would add up to quite a bit though. I think leaving it to a new ticket would be a good idea.


---

Comment by tscrim created at 2018-09-28 21:48:44

While having a coercion would be good, as Eric points out, the mismatch of base rings would force the direction of the coercion `L -> T1G`. However, because coercions have to preserve structure, `T1G` would have to carry a Lie algebra structure.

Now, this does not have to be a coercion. You could implement the conversions (and have a helper method, such as `to_construction_Lie_algebra` or some better name) between the two objects. You probably could do this for the tangent space at a generic element since that just corresponds to conjugating by the element.

Also as previously stated, that would be good for a followup ticket.

For this ticket, the only other things I might want to see are a `lie_group` method on the Lie algebra (a generic one would raise a `NotImplementedError` or be an ``@`abstract_method(optional=True)`) and an `exp` method on the Lie algebra element that does `self.parent().lie_group().exp(self)`.


---

Comment by git created at 2018-09-29 05:39:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-09-29 05:45:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @ehaka created at 2018-09-29 05:55:48

I currently set the Lie algebra -> Lie group interface to default to naming the group 'G'. This allows both `L.lie_group()` and `X.exp()`, since requiring the name parameter for `exp` did not seem convenient for use.

Should different(ly named) Lie groups of the same Lie algebra have a predefined canonical coercion between each other? Or should these be considered separate objects? I'm not sure about the intended use of the `_name` parameter when the underlying manifold is the same. In particular,  it is clear that

```
sage: NilpotentLieGroup(L, 'G') is NilpotentLieGroup(L, 'H')
False
```

is desired behavior. Would

```
sage: NilpotentLieGroup(L, 'G') == NilpotentLieGroup(L, 'H')
False
```

also be desired behavior?


---

Comment by @ehaka created at 2018-09-29 07:37:54

Another question I have is where should the Lie group functionality go in the source and reference?
Currently the source is under `sage.groups.lie_group.py` and the doc is not linked anywhere since I didn't know where to put it.


---

Comment by egourgoulhon created at 2018-09-29 12:43:49

Replying to [comment:23 gh-ehaka]:
> I currently set the Lie algebra -> Lie group interface to default to naming the group 'G'. This allows both `L.lie_group()` and `X.exp()`, since requiring the name parameter for `exp` did not seem convenient for use.
> 

I would favor passing the Lie group itself and not the string representing its name as the argument of the `exp` defined in the element methods of `LieAlgebras`, i.e. 
something like

```
def exp(self, lie_group=None):
    if not lie_group:
        return self.parent().lie_group().exp(self)
    return lie_group.exp(self)
```

This seems more robust to me, especially at this level (element method of _all_ Lie algebras).

> Should different(ly named) Lie groups of the same Lie algebra have a predefined canonical coercion between each other? Or should these be considered separate objects? I'm not sure about the intended use of the `_name` parameter when the underlying manifold is the same. In particular,  it is clear that
> {{{
> sage: NilpotentLieGroup(L, 'G') is NilpotentLieGroup(L, 'H')
> False
> }}}
> is desired behavior. 
Yes.
> Would
> {{{
> sage: NilpotentLieGroup(L, 'G') == NilpotentLieGroup(L, 'H')
> False
> }}}
> also be desired behavior?
I would say yes as well (this would be in the same vein as what we have for manifolds), but I am not 100% sure this is the best option.


---

Comment by egourgoulhon created at 2018-09-29 12:57:26

Replying to [comment:24 gh-ehaka]:
> Another question I have is where should the Lie group functionality go in the source and reference?
> Currently the source is under `sage.groups.lie_group.py` and the doc is not linked anywhere since I didn't know where to put it.

For the reference manual, there are naturally two options:
- a new subsection "Lie groups" of 
  http://doc.sagemath.org/html/en/reference/groups/
- a new subsection "Lie groups" of http://doc.sagemath.org/html/en/reference/manifolds/

since Lie groups lie at the intersection of both topics. Depending on which one you choose, I would rename the source file `lie_group.py` to `nilpotent_lie_group.py` and place it in the new subdirectory `src/sage/groups/lie_groups` or `src/sage/manifolds/differentiable/lie_groups`.


---

Comment by tscrim created at 2018-09-29 23:13:13

I would probably put it in with the groups as I think that is there more prominent feature. Moreover, our canonical Lie groups are usually thought of as (matrix) groups, GL, O, U, etc.


---

Comment by git created at 2018-09-30 05:06:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @ehaka created at 2018-09-30 05:13:48

I moved the file to `sage/groups/lie_gps/nilpotent_lie_group.py`. All the other subfolders in groups were `*_gps` so I copied that folder convention. 

I added the subsection of Lie groups to the group reference, but it is slightly disturbing to have a separate "Lie groups" subsection when there is the matrix groups heading containing GL and others. On the other hand, the abstract-manifold Lie group doesn't fit under the "Matrix and affine groups" heading, and extending it to something like "Matrix, affine, and Lie groups" seemed even worse. Hopefully this a problem that will solve itself once more Lie group functionality eventually gets added in so that the "Lie groups" heading feels more fleshed out.


---

Comment by tscrim created at 2018-09-30 07:36:40

I would argue that this is okay since the other matrix groups do not know they are Lie groups when working over topological fields and also work for a larger class of base fields (e.g., finite fields).


---

Comment by git created at 2018-10-03 04:56:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @ehaka created at 2018-10-03 05:02:06

I changed the docs of `NilpotentLieGroup` to suggest using the `L.lie_group('G')` syntax over `NilpotentLieGroup(L, 'G')`. Having now played around with these for a bit, the former seemed to be the more convenient entry point.

Although now the `NilpotentLieGroup` entry point is not really even relevant as it does not provide any extra functionality. Possibly it could/should be removed from the global namespace? The only benefit I see to keeping it at this moment is being able to use `NilpotentLieGroup?` to see some usage examples.


---

Comment by git created at 2018-10-03 11:05:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-10-03 11:06:34

It probably should be removed, but it should be a new subcatalog `groups.lie`. So I did this.

I removed the `Group.__init__` as that was not doing anything useful.

I cached `chart_exp2` and just called that instead of `_Exp2`.

Other misc doc tweaks.

If my changes are good, then I think we can set a positive review unless Eric has some more comments.


---

Comment by git created at 2018-10-03 14:23:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @ehaka created at 2018-10-03 14:24:40

Ah, I didn't know about the groups catalog, this is a very good solution, thanks! I fixed a typo in the catalog and removed the now empty file `lie_gps/all.py`

I modified the `_repr_` method of Lie group elements to avoid unnecessarily calling `chart_exp2` in case the default chart is `_Exp1`, since the computation is quite expensive. Although the current form is not ideal either, since now if the default coordinate chart is something other than `chart_exp2` or `_Exp1`, then it will still unnecessarily compute the transitions to and from exp-2 coordinates. Not sure how to handle this without the `_Exp2=None` default.

Other than that, the changes look good to me.


---

Comment by egourgoulhon created at 2018-10-03 22:03:52

Replying to [comment:34 tscrim]:
> If my changes are good, then I think we can set a positive review unless Eric has some more comments.

Everything looks good to me, so I agree with the positive review.
Thanks for the nice work!


---

Comment by egourgoulhon created at 2018-10-03 22:04:20

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-10-05 16:56:55

Resolution: fixed


---

Comment by embray created at 2018-10-28 14:52:23

This should be re-targeted for 8.5.
