# Issue 14970: SageObject breaks pickling circular structures

archive/issues_014970.json:
```json
{
    "body": "CC:  simonking @vbraun jkeitel\n\nSee [this sage-devel thread](https://groups.google.com/d/msg/sage-devel/pgqLGu7sGKA/VsOw_qrHpTMJ). There's a problem where `SageObject.__hash__` requires `__repr__` to be operational, which with standard pickling may not be the case, because attributes only set after `__setstate__` may be required.\n\nThe solution is to change the way objects are constructed during unpickling. Python offers several hooks for this. The purpose of this ticket is to find a way that is easy to adapt.\n\nIssue created by migration from https://trac.sagemath.org/ticket/15207\n\n",
    "created_at": "2013-09-18T04:58:22Z",
    "labels": [
        "misc",
        "major",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "SageObject breaks pickling circular structures",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/14970",
    "user": "@nbruin"
}
```
CC:  simonking @vbraun jkeitel

See [this sage-devel thread](https://groups.google.com/d/msg/sage-devel/pgqLGu7sGKA/VsOw_qrHpTMJ). There's a problem where `SageObject.__hash__` requires `__repr__` to be operational, which with standard pickling may not be the case, because attributes only set after `__setstate__` may be required.

The solution is to change the way objects are constructed during unpickling. Python offers several hooks for this. The purpose of this ticket is to find a way that is easy to adapt.

Issue created by migration from https://trac.sagemath.org/ticket/15207





---

archive/issue_comments_191225.json:
```json
{
    "body": "\n```python\nclass Node(base):\n    def __init__(self,i):\n        self.i=i\n        self.neighbours=set()\n    def __repr__(self):\n        return \"Node %s with neighbours %s\"%(self.i,sorted([c.i for c in self.neighbours]))\n    def connected_component(self):\n        nodelist=[]\n        todo=[self]\n        visited=set()\n        while todo:\n            n=todo.pop()\n            if n.i not in visited:\n                nodelist.append(n)\n                todo.extend(n.neighbours)\n                visited.add(n.i)\n        nodelist.sort(key=lambda n:n.i)\n        return nodelist\n```\n\nwith `base=object` this works:\n\n```python\nfrom richpickle import Node\nn=4\nN=[Node(i) for i in range(n)]\nfor j in range(n):\n        N[j].neighbours=set(N[i] for i in range(n) if i != j)\n\nloads(dumps(N[0])).connected_component()\n```\n\nwith `base=SageObject` it fails, because now the attribute `i` in required for `__hash__` via `__repr__`.",
    "created_at": "2013-09-18T05:20:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14970#issuecomment-191225",
    "user": "@nbruin"
}
```


```python
class Node(base):
    def __init__(self,i):
        self.i=i
        self.neighbours=set()
    def __repr__(self):
        return "Node %s with neighbours %s"%(self.i,sorted([c.i for c in self.neighbours]))
    def connected_component(self):
        nodelist=[]
        todo=[self]
        visited=set()
        while todo:
            n=todo.pop()
            if n.i not in visited:
                nodelist.append(n)
                todo.extend(n.neighbours)
                visited.add(n.i)
        nodelist.sort(key=lambda n:n.i)
        return nodelist
```

with `base=object` this works:

```python
from richpickle import Node
n=4
N=[Node(i) for i in range(n)]
for j in range(n):
        N[j].neighbours=set(N[i] for i in range(n) if i != j)

loads(dumps(N[0])).connected_component()
```

with `base=SageObject` it fails, because now the attribute `i` in required for `__hash__` via `__repr__`.



---

archive/issue_comments_191226.json:
```json
{
    "body": "a possibly light interface",
    "created_at": "2013-09-18T05:22:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14970#issuecomment-191226",
    "user": "@nbruin"
}
```

a possibly light interface



---

archive/issue_comments_191227.json:
```json
{
    "body": "Attachment [richpickle.py](tarball://root/attachments/some-uuid/ticket15207/richpickle.py) by @nbruin created at 2013-09-18 05:27:37\n\nThe attached file is a rough draft. The idea is that just adding the line\n\n```python\n    _init_attributes = ('i',)\n```\n\nto the class definition of `Node`, together with setting `base=RichPickle,SageObject`, restores pickling circular structures, because the initialization of `i` is moved forward.\n\nJust specifying which attributes need to be reinstated earlier may feel a lot lighter to people implementing classes than having to write a full `__reduce__`.",
    "created_at": "2013-09-18T05:27:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14970#issuecomment-191227",
    "user": "@nbruin"
}
```

Attachment [richpickle.py](tarball://root/attachments/some-uuid/ticket15207/richpickle.py) by @nbruin created at 2013-09-18 05:27:37

The attached file is a rough draft. The idea is that just adding the line

```python
    _init_attributes = ('i',)
```

to the class definition of `Node`, together with setting `base=RichPickle,SageObject`, restores pickling circular structures, because the initialization of `i` is moved forward.

Just specifying which attributes need to be reinstated earlier may feel a lot lighter to people implementing classes than having to write a full `__reduce__`.



---

archive/issue_comments_191228.json:
```json
{
    "body": "So, you suggest to introduce a base class `RichPickle`, which manages certain attributes that absolutely must be present before `__setstate__`. These attributes are indicated by a list of strings stored as a class attribute.\n\nThis makes sense to me. I guess this new base class will save me a lot of trouble when attempting to implement proper pickling on all homsets. So, thumbs up from me...",
    "created_at": "2013-09-18T08:21:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14970#issuecomment-191228",
    "user": "@simon-king-jena"
}
```

So, you suggest to introduce a base class `RichPickle`, which manages certain attributes that absolutely must be present before `__setstate__`. These attributes are indicated by a list of strings stored as a class attribute.

This makes sense to me. I guess this new base class will save me a lot of trouble when attempting to implement proper pickling on all homsets. So, thumbs up from me...



---

archive/issue_comments_191229.json:
```json
{
    "body": "Replying to [comment:4 SimonKing]:\n\nIndeed, that's the idea. The next step is interface and performance:\n- Should we try to also implement the `__getnewargs__` protocol to dredge up the arguments needed for the new call?\n- should we just depend on `super.__reduce__` and modify its return value to include the actions we want to take?\n- the `base` on which `__new__` gets called upon reconstruction needs more attention: When inheriting from `SageObject, RichPickle` (rather than the other way around) upickling triggers an error about an unsafe `__new__`.\n- I think it's a good idea to walk the MRO to collect all the attributes that need special treatment (this is already implemented), so that RickPickle also works properly when multiple classes in the MRO make use of it. Do we need to do that every time, though or should we store what we found?\n- Should this be a separate class or should we integrate this behaviour into some existing class (logically, I think it should be separate, but perhaps it's better for performance to arrange it otherwise)\n- We need a better name. `RichPickle` really doesn't tell you what's so rich about it -- and really, it's only a modest extension of the protocol followed for `object`, so it's not so rich anyway.",
    "created_at": "2013-09-18T15:47:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14970#issuecomment-191229",
    "user": "@nbruin"
}
```

Replying to [comment:4 SimonKing]:

Indeed, that's the idea. The next step is interface and performance:
- Should we try to also implement the `__getnewargs__` protocol to dredge up the arguments needed for the new call?
- should we just depend on `super.__reduce__` and modify its return value to include the actions we want to take?
- the `base` on which `__new__` gets called upon reconstruction needs more attention: When inheriting from `SageObject, RichPickle` (rather than the other way around) upickling triggers an error about an unsafe `__new__`.
- I think it's a good idea to walk the MRO to collect all the attributes that need special treatment (this is already implemented), so that RickPickle also works properly when multiple classes in the MRO make use of it. Do we need to do that every time, though or should we store what we found?
- Should this be a separate class or should we integrate this behaviour into some existing class (logically, I think it should be separate, but perhaps it's better for performance to arrange it otherwise)
- We need a better name. `RichPickle` really doesn't tell you what's so rich about it -- and really, it's only a modest extension of the protocol followed for `object`, so it's not so rich anyway.



---

archive/issue_comments_191230.json:
```json
{
    "body": "A slightly different approach for `CategoryObject`: it caches its hash already, so all we need to do is pickle it as well and ensure the cache is reinitialized by the constructor, not by setstate. If we add the following to `sage.structure.category_object.CategoryObject`:\n\n```\n    def __reduce__(self):\n        if not isinstance(self,CategoryObject):\n            raise TypeError(\"this only works for CategoryObject\")\n        cdef CategoryObject Cco=self\n        try:\n            getstate = self.__getstate__\n        except AttributeError:\n            if getattr(self, \"__slots__\", None):\n                raise TypeError(\"a class that defines __slots__ without \"\n                                \"defining __getstate__ cannot be pickled\")\n            try:\n                dict = self.__dict__\n            except AttributeError:\n                dict = None\n        else:\n            dict = getstate()\n        if Cco._hash_value == -1:\n            reconstructor = reconstruct_CategoryObject_without_hash\n            args=(self.__class__)\n        else:\n            reconstructor = reconstruct_CategoryObject_with_hash\n            args=(self.__class__,Cco._hash_value,)\n        if dict:\n            return reconstructor, args, dict\n        else:\n            return reconstructor, args\n```\n\nas well as:\n\n```\ndef reconstruct_CategoryObject_with_hash(cls,hash,*args):\n    C=cls.__new__(cls,*args)\n    if not isinstance(C,CategoryObject):\n        raise TypeError(\"this only works for CategoryObject\")\n    cdef CategoryObject Cco=C\n    Cco._hash_value=hash\n    return C\n    \ndef reconstruct_CategoryObject_without_hash(cls,*args):\n    return cls.__new__(cls,*args)\n\n```\n\nwe can do:\n\n```\nsage: L=LaurentPolynomialRing(QQ,'t')\nsage: L.d={L:1}\nsage: C=loads(dumps(L))\n```\n\nwhich otherwise would fail. There are some doctests in `src/sage/structure/factory.pyx` that fail, so this approach needs a bit of adjustment, but I think something along these lines would help a lot.\n\nOf course, we just kick the can a little further. It's easy to create two non-identical rings with the same hash, so that equality testing really becomes important for the dictionary lookup:\n\n```\nsage: L1=LaurentPolynomialRing(QQ,'u,v',order=\"deglex\")\nsage: L2=LaurentPolynomialRing(QQ,'u,v',order=\"lex\")\nsage: L1.d={L1:1,L2:2}\nsage: L2.d={L1:1,L2:2}\nsage: loads(dumps(L1))\nAttributeError: 'LaurentPolynomialRing_mpair_with_category' object has no attribute '_R'\n```\n\nbecause although the rings hash OK, their `_R` attribute, required in the `__cmp__` implementation, is not initialized.",
    "created_at": "2013-11-20T01:38:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/14970",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/14970#issuecomment-191230",
    "user": "@nbruin"
}
```

A slightly different approach for `CategoryObject`: it caches its hash already, so all we need to do is pickle it as well and ensure the cache is reinitialized by the constructor, not by setstate. If we add the following to `sage.structure.category_object.CategoryObject`:

```
    def __reduce__(self):
        if not isinstance(self,CategoryObject):
            raise TypeError("this only works for CategoryObject")
        cdef CategoryObject Cco=self
        try:
            getstate = self.__getstate__
        except AttributeError:
            if getattr(self, "__slots__", None):
                raise TypeError("a class that defines __slots__ without "
                                "defining __getstate__ cannot be pickled")
            try:
                dict = self.__dict__
            except AttributeError:
                dict = None
        else:
            dict = getstate()
        if Cco._hash_value == -1:
            reconstructor = reconstruct_CategoryObject_without_hash
            args=(self.__class__)
        else:
            reconstructor = reconstruct_CategoryObject_with_hash
            args=(self.__class__,Cco._hash_value,)
        if dict:
            return reconstructor, args, dict
        else:
            return reconstructor, args
```

as well as:

```
def reconstruct_CategoryObject_with_hash(cls,hash,*args):
    C=cls.__new__(cls,*args)
    if not isinstance(C,CategoryObject):
        raise TypeError("this only works for CategoryObject")
    cdef CategoryObject Cco=C
    Cco._hash_value=hash
    return C
    
def reconstruct_CategoryObject_without_hash(cls,*args):
    return cls.__new__(cls,*args)

```

we can do:

```
sage: L=LaurentPolynomialRing(QQ,'t')
sage: L.d={L:1}
sage: C=loads(dumps(L))
```

which otherwise would fail. There are some doctests in `src/sage/structure/factory.pyx` that fail, so this approach needs a bit of adjustment, but I think something along these lines would help a lot.

Of course, we just kick the can a little further. It's easy to create two non-identical rings with the same hash, so that equality testing really becomes important for the dictionary lookup:

```
sage: L1=LaurentPolynomialRing(QQ,'u,v',order="deglex")
sage: L2=LaurentPolynomialRing(QQ,'u,v',order="lex")
sage: L1.d={L1:1,L2:2}
sage: L2.d={L1:1,L2:2}
sage: loads(dumps(L1))
AttributeError: 'LaurentPolynomialRing_mpair_with_category' object has no attribute '_R'
```

because although the rings hash OK, their `_R` attribute, required in the `__cmp__` implementation, is not initialized.
