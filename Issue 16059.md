# Issue 16059: Speed improvements for categories with axioms

Issue created by migration from https://trac.sagemath.org/ticket/16296

Original creator: SimonKing

Original creation time: 2014-05-06 13:55:40

CC:  nthiery mmezzarobba

Keywords: cython performance categories

With the "axiomatic" approach towards categories introduced in #10963, we are now using join categories far more frequently than in the past. This involves many little operations (sorting, computation of index, ...) that should be made as fast as possible.

Hence, this ticket is about using Cython and optimizing basic algorithms in sage.categories.category and friends.


---

Comment by SimonKing created at 2014-05-06 13:55:53

Changing type from PLEASE CHANGE to enhancement.


---

Comment by ncohen created at 2014-05-06 13:58:10

(curious)


---

Comment by SimonKing created at 2014-05-06 14:48:27

First observation: Moving sage.categories.category to Cython is not trivial, since it relies on abstract_method, which currently only accepts Python functions. Hence, abstract_method needs to be cythoned, too, or at least needs to be more permissive in the assertion that the input is `types.FunctionType`.


---

Comment by SimonKing created at 2014-05-06 14:49:16

Good: If one removes the assertion from abstract_method, then Sage starts.


---

Comment by SimonKing created at 2014-05-06 15:32:26

I have pushed an initial branch (starting with #10963, of course), changing the assertion so that both `types.FunctionType` and `cython_function_or_method` are permitted (no idea how to test the latter more elegantly than by the name of the type...), and I changing `AbstractMethod.__repr__` so that it gives comparable output for both Python and Cython methods.

Note: I don't think we should Cython `AbstractMethod`. After all, they are just placeholders for "real" methods and are thus not time-critical.

With the branch, Sage starts.
----
Last 10 new commits:


---

Comment by SimonKing created at 2014-05-06 18:00:03

Since #10963 is supposed to be merged together with #15801, which changes sage.categories.category, we should have #15801 as dependency. Pushing the next merge now...


---

Comment by git created at 2014-05-06 18:01:42

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by SimonKing created at 2014-05-06 19:35:48

All tests in srs/sage/categories/ pass with the branch. Now, one can start to try and improve some operations...


---

Comment by SimonKing created at 2014-05-08 12:44:26

Some functions in `c3_controlled` can not be cdef'd, because they contain "any(...)" clauses. For example:

```
        for i in range(max_i): #from 0 <= i < max_i:
            O = heads[i]
            # Does O appear in none of the tails?
            O_key = key(O)
            if any(O_key in tailsets[j] for j in range(nbheads) if j != i):
                continue
```

It might be worth-while to see if the "any(...)" clause can be improved by something that is faster and does not use a clause. To the very least, I guess giving Cython some hints on the type (`tailsets[j]` is a set!) might pay off.


---

Comment by SimonKing created at 2014-05-08 12:58:06

Indeed:

```python
def test1(list L):
    cdef int i,j
    cdef int max_i = len(L)
    for i in range(max_i):
        if any(100 in L[j] for j in range(max_i) if j!=i):
            continue
        
def test2(list L):
    cdef int i,j
    cdef int max_i = len(L)
    for i in range(max_i):
        if any(100 in <set>(L[j]) for j in range(max_i) if j!=i):
            continue
        
cpdef test3(list L):
    cdef int i,j
    cdef int max_i = len(L)
    cdef bint cont
    for i in range(max_i):
        cont = False
        for j from 0<=j<i:
            if 100 in <set>(L[j]):
                cont = True
                break
        if cont:
            continue
        for j from i<j<max_i:
            if 100 in <set>(L[j]):
                break
```

yields

```
sage: L = [set([randint(0,10000) for i in range(200)]) for j in range(200)]
sage: %timeit test1(L)
100 loops, best of 3: 2.5 ms per loop
sage: %timeit test2(L)
100 loops, best of 3: 2.5 ms per loop
sage: %timeit test3(L)
1000 loops, best of 3: 1.25 ms per loop
```

So, let's do it like this. I hope I am not mistaken that what is happening inside `test3()` is equivalent to the "any" clause in the other two functions.


---

Comment by SimonKing created at 2014-05-08 12:59:43

PS: `100 in <set>(L[j])` seems to have no advantage over `100 in L[j]`.


---

Comment by SimonKing created at 2014-05-08 13:16:42

Another closure occurs in the following definition:

```
cdef list tailsets = [set(key(O) for O in tail) for tail in tails]
```

Let's see how to make this a little faster without a closure:

```python
def set_test1(list tails):
    cdef list tail
    return [set(O**2 for O in tail) for tail in tails]

cpdef list set_test2(list tails):
    cdef list tail
    cdef set part_set = set()
    cdef list result = []
    for tail in tails:
        part_set = set()
        for O in tail:
            part_set.add(O**2)
        result.append(part_set)
    return result
```

yields

```
sage: L = [[randint(0,10000) for i in range(200)] for j in range(200)]
sage: set_test1(L) == set_test2(L)
True
sage: %timeit set_test1(L)
100 loops, best of 3: 8.52 ms per loop
sage: %timeit set_test2(L)
100 loops, best of 3: 6.51 ms per loop
```

This time, we do not gain so much, but it is something, and we can make the function cpdef then, reducing the calling overhead after (c)importing it into another module.


---

Comment by git created at 2014-05-08 13:56:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2014-05-08 13:59:25

With #15801, I get

```
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort_uniq(L)
10000 loops, best of 3: 25.2 µs per loop
sage: %timeit Category._sort(L)
100000 loops, best of 3: 6.22 µs per loop
```


With the current branch from here, I get

```
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort_uniq(L)
100000 loops, best of 3: 14.1 µs per loop
sage: %timeit Category._sort(L)
100000 loops, best of 3: 5.61 µs per loop
```

Making `sage.categories.category` Cython means that we could now cimport `WeakValueDictionary` and get a bit more speed by accessing the contents by cdef methods.


---

Comment by SimonKing created at 2014-05-08 14:15:11

Too bad: With the current branch,

```
sage: from sage.misc.sageinspect import sage_getargspec
sage: sage_getargspec(Category.join)
  File "<string>", line unknown
SyntaxError: Syntactical group starting with '(' did not end with ')'
```

Hence, the doc doesn't build. It seems that I need to create a dependency for this, improving `sage_getargspec`.


---

Comment by SimonKing created at 2014-05-08 14:23:45

I created #16309 for the argspec issue.


---

Comment by SimonKing created at 2014-05-08 21:31:18

With #16309, the documentation builds, and

```
sage: from sage.misc.sageinspect import sage_getargspec
sage: sage_getargspec(Category.join)
ArgSpec(args=['categories', 'as_list', 'ignore_axioms', 'axioms'], varargs=None, keywords=None, defaults=(False, (), ()))
```

I am running tests now. However, even if they pass, I'd like to try and get some more speed for the `WeakValueDictionary` used in `sage.categories.category`, and `sage.categories.category_with_axiom` probably has more potential for improvements.


---

Comment by SimonKing created at 2014-05-08 22:58:59

Interestingly, with #16309 alone, the tests of sageinspect.py pass. But adding the commits from here, one test in sageinspect.py fails:

```
        sage: C = Rings()
        sage: HC = C.hom_category()
        sage: sage_getsourcelines(HC)
        (['    class HomCategory(HomCategory):\n', ...], ...)
```

is expected, but the indentation (that is due to the nesting) is wrong.

Actually it is even more wrong than that: The relevant class is defined as a nested class in sage.categories.rings, but we get

```
sage: from sage.misc.sageinspect import _sage_getdoc_unformatted
sage: _sage_getdoc_unformatted(HC)
"File: sage/categories/category.pyx (starting at line 2361)\n\n        Initializes this HomCategory\n\n        INPUT:\n         - ``category`` -- the category whose Homsets are the objects of this category.\n         - ``name`` -- An optional name for this category.\n\n        EXAMPLES:\n\n        We need to skip one test, since the hierarchy of hom categories isn't\n        consistent yet::\n\n            sage: C = sage.categories.category.HomCategory(Rings()); C\n            Category of hom sets in Category of rings\n            sage: TestSuite(C).run(skip=['_test_category_graph'])\n        "
```

That's all really strange. The code of the nested class is

```
    class HomCategory(HomCategory):
        pass
```

and indeed we have

```
sage: HC.__doc__
```

Why is _sage_getdoc_unformatted returning something nonempty, even though the class has empty `__doc__`?


---

Comment by SimonKing created at 2014-05-08 23:31:20

Now I get what is going wrong.

Since `Rings.HomCategory` has no docstring, `_sage_getdoc_unformatted` returns the docstring of `Rings.HomCategory.__init__`. This used to by a Python method, hence had no embedded information on the source code. But with this branch, `__init__` is a Cython information and thus has embedding information, that unfortunately lets `sage_getsourcelines` look up the wrong file.

But in the first place: Why do we need to look up `_sage_getdoc_unformatted` when calling `sage_getsourcelines`? After all, `Rings.HomCategory` is a Python class in a Python file! Shouldn't it provide all relevant information?


---

Comment by SimonKing created at 2014-05-08 23:32:46

Probably the problem lies in the nesting:

```
sage: inspect.getsourcelines(HC.__class__)
---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
<ipython-input-12-91ebc0139037> in <module>()
----> 1 inspect.getsourcelines(HC.__class__)

/home/king/Sage/git/sage/local/lib/python/inspect.pyc in getsourcelines(object)
    688     original source file the first line of code was found.  An IOError is
    689     raised if the source code cannot be retrieved."""
--> 690     lines, lnum = findsource(object)
    691 
    692     if ismodule(object): return lines, 0

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/IPython/core/ultratb.pyc in findsource(object)
    189             return lines, candidates[0][1]
    190         else:
--> 191             raise IOError('could not find class definition')
    192 
    193     if ismethod(object):

IOError: could not find class definition
```



---

Comment by SimonKing created at 2014-05-09 00:27:33

With the newest version of #16309, the problem from comment:21 is fixed. So, back to (first) fixing doctests (if there is anything broken) and (second) improve speed further.


---

Comment by git created at 2014-05-09 06:45:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2014-05-09 06:48:40

With the new commits from #16309 and one change in the import location of a doctest, all tests pass. But this is now not more than an intermediate stage, as I want to tweak `sage.categories.category_with_axiom` and want to improve weak cache access.


---

Comment by SimonKing created at 2014-05-09 07:43:42

Just for the record: The following is faster than `uncamelcase`.

```python
cpdef inline default_match_splitter(match):
    cdef str g = match.group()
    return g[0]+'_'+g[1]

camel_splitter = re.compile("[a-z][A-Z]")

def new_uncamelcase(s, separator=None):
    if separator is None:
        return camel_splitter.sub(default_match_splitter, s).lower()
    return camel_splitter.sub(lambda match: match.group()[0]+separator+match.group()[1], s).lower()

```

However, since `uncamelcase` is rarely called, I will leave it.


---

Comment by SimonKing created at 2014-05-09 07:48:14

Or perhaps I should _not_ leave it. I just notice that `uncamelcase` is also called (once) in `Category._sort`, and this _is_ critical for speed.


---

Comment by SimonKing created at 2014-05-09 07:50:33

Replying to [comment:28 SimonKing]:
> Or perhaps I should _not_ leave it. I just notice that `uncamelcase` is also called (once) in `Category._sort`, and this _is_ critical for speed.

Forget this comment. Apparently this is only because I tested an example involving "Finite".


---

Comment by nthiery created at 2014-05-09 16:27:44

Hi Simon!

Thanks so much for exploring how much we could potentially gain by
cythonizing some of the category infrastructure code; we need this
kind of facts to take good decisions. At this point definitely +1 on
optimizing lower level things like c3, since the interface and
algorithms are quite final.

On the other hand, I am wondering whether the current not so massive
speed improvements make a compelling case for actually cythonizing the
file category.py right now. The point is that cythonizing makes the
code much harder to debug (I agree, this is a problem of pdb: we
really would need to have a debugger supporting both python and cython
code; alas I don't see progress in this direction anytime soon).

E.g. I find the coercion code very painful to work with precisely
because of this. In fact, when I tried to fix things a couple years
ago, I first uncythonized it ...

I fear that it would similarly slow down the followup development we
want to do with categories, e.g. improving the join algorithm.

What do you think?

Cheers,
                                 Nicolas


---

Comment by SimonKing created at 2014-05-09 20:26:20

Replying to [comment:30 nthiery]:
> On the other hand, I am wondering whether the current not so massive
> speed improvements make a compelling case for actually cythonizing the
> file category.py right now. The point is that cythonizing makes the
> code much harder to debug

Even if it is a Python class defined in a Cython file? I thought that problems will only start if things are cdef.

> I fear that it would similarly slow down the followup development we
> want to do with categories, e.g. improving the join algorithm.
> 
> What do you think?

Actually improving the join algorithm speed-wise is my main goal for this ticket. I am not sure if much progress can be achieved without Cython.

I'd say: I try to improve the speed as much as possible by as much Cython as needed. In a second step, we can see if some of it can also be done in Python, or if some parts can be moved to a Cython file separate from `sage.categories.category`.


---

Comment by nthiery created at 2014-05-09 21:01:08

Replying to [comment:31 SimonKing]:
> Even if it is a Python class defined in a Cython file?

That's kind of a shame, but yes, even in this case. Put this in
`test_debug_cython.pyx`:

```
import pdb
def f(x):
    for i in range(10):
        pdb.set_trace()
        x = x + 1
```

and run

```
sage: load("test_debug_cython.pyx")
Compiling ./test_debug_cython.pyx...
sage: f(3)
```


The function f does not even appear in the backtrace.

> Actually improving the join algorithm speed-wise is my main goal for
> this ticket. I am not sure if much progress can be achieved without
> Cython.

The upcoming work is not only about speed, but also functionality. Or
trying alternative algorithms, like your pet boolean polynomial ideals
approach. And even speedwise, there may be room to improve the
algorithm itself, rather than the implementation.

> I'd say: I try to improve the speed as much as possible by as much Cython as needed.
> In a second step, we can see if some of it can also be done in Python, or

Definitely worth trying hard and see how much we can gain. And see if
it's worth making the code more complex / harder to trace.

> if some parts can be moved to a Cython file separate from `sage.categories.category`.

This could be a good approach indeed.

Cheers,
                                     Nicolas


---

Comment by SimonKing created at 2014-05-09 21:03:19

As I have indicated on #10963, one could replace the tuple all_axioms by a container derived from dict. It is used in `canonicalise_axioms`, which can be accelerated by 35%.


---

Comment by SimonKing created at 2014-05-09 21:17:22

43% actually...


---

Comment by nthiery created at 2014-05-09 21:38:36

Replying to [comment:33 SimonKing]:
> As I have indicated on #10963, one could replace the tuple all_axioms by a container derived from dict. It is used in `canonicalise_axioms`, which can be accelerated by 35%.

+1!


---

Comment by git created at 2014-05-09 21:42:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2014-05-09 21:51:29

With #15801:

```
sage: from sage.categories.category_with_axiom import canonicalize_axioms
sage: L = ["Commutative", "Connected", "Commutative", "WithBasis", "Finite"]
sage: %timeit canonicalize_axioms(L)
100000 loops, best of 3: 8.23 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort(L)
100000 loops, best of 3: 6.12 µs per loop
sage: %timeit Category._sort_uniq(L)
10000 loops, best of 3: 24.7 µs per loop
sage: %timeit Category.join(L)
10000 loops, best of 3: 854 µs per loop
```


With the branch from here:

```
sage: from sage.categories.category_with_axiom import canonicalize_axioms
sage: L = ["Commutative", "Connected", "Commutative", "WithBasis", "Finite"]
sage: %timeit canonicalize_axioms(L)
100000 loops, best of 3: 3.77 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort(L)
100000 loops, best of 3: 5.49 µs per loop
sage: %timeit Category._sort_uniq(L)
100000 loops, best of 3: 13.8 µs per loop
sage: %timeit Category.join(L)
10000 loops, best of 3: 659 µs per loop
```


So, there is an improvement of >50% in `canonicalize_axioms`, 44% in `_sort_uniq` (but not in `_sort`), and 22% in `join`.


---

Comment by nthiery created at 2014-05-10 07:19:25

Nice. How much would you say is due to the "cythonization" of all_axioms and friends, and how much to the cythonization of the full file?


---

Comment by SimonKing created at 2014-05-10 12:50:13

According to grep, `Category._sort()` is not really used. So, would you mind if I remove `_sort()`, and only replace `_sort_uniq()` by a Cython function?

Best regards,
Simon


---

Comment by git created at 2014-05-10 13:27:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2014-05-10 13:37:37

I switched `sage.categories.category` and `sage.categories.category_with_axiom` back to Python. Instead, I created a module with helper functions. Fortunately, `_sort_uniq` is a static method, and thus it is no problem to replace it with a cpdef function imported from the helper module.

The current timings:

```
sage: from sage.categories.category_with_axiom import canonicalize_axioms, all_axioms
sage: canonicalize_axioms(all_axioms, ["Commutative", "Connected", "Commutative", "WithBasis", "Finite"])
('Finite', 'Connected', 'WithBasis', 'Commutative')
sage: %timeit canonicalize_axioms(all_axioms, L)
100000 loops, best of 3: 3.83 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort(L)
100000 loops, best of 3: 6.25 µs per loop
sage: %timeit Category._sort_uniq(L)
100000 loops, best of 3: 15.9 µs per loop
sage: %timeit Category.join(L)
10000 loops, best of 3: 816 µs per loop
```

Note: Since I want to keep `all_axioms` in `sage.categories.category_with_axiom`, I need to provide it to `canonicalize_axioms` (now defined in the helper module) as an argument.

__Evaluation__

- `canonicalize_axioms` is still fast, and so is (almost) `_sort_uniq`.
- I kept `_sort` in for now, but it isn't used, and I'd simply remove it.
- The join is now slow again, since it is Python.

__Concerning join__

Perhaps one could create another helper function for the join. It is static, hence, a cpdef function won't be a problem. However, it uses a cache. This cache should be local to `sage.categories.category.Category`, but when defining the `join` in the helper module, we'd like to have cython-speed access to it. OTOH, we could define the cache in the helper module, and then assign it as an attribute to `Category`, if we think that the cache is needed outside of the helper.


---

Comment by SimonKing created at 2014-05-10 14:14:41

Something more about the join:

- The cache key is computed with _sort_uniq. Fine, this is cythonised already.
- There remains a new cython function to create the flattened, normalised etc. list of super categories of the to-be-created join.
- `Category.join` would be simply like this:
  {{{
    def join(...):
        T = _sort_uniq(...)
        try:
            if as_list:
                return Category._join_cache[T]._super_categories
            return Category._join_cache[T]
        except KeyError:
            pass
        S = create_super_categories(T) # this will be a list!
        if as_list:
            return S # or do caching?
        J = JoinCategory(S)
        _join_cache[T] = J
        return J
  }}}

I think this would be a good compromise between cythonisation and "keeping the function where it belongs". In particular, the documentation would stay in `Categories.join`. Since `_sort`, `_sort_uniq` and `_flatten_categories` are not part of the docs anyway (or am I mistaken?), I think there should be no problem to move these over to the helper module.


---

Comment by SimonKing created at 2014-05-10 15:50:13

Nicolas, can you comment on this. In the join construction, I see the line

```python
        todo.update( (category, axiom)
                     for axiom in axioms.difference(axs) )
```

Since category is fixed, wouldn't this mean to just set `todo[category]` to the last axiom in `axioms.difference(axs)`? Is this a bug, or intended?


---

Comment by SimonKing created at 2014-05-10 15:51:48

Replying to [comment:43 SimonKing]:
> Nicolas, can you comment on this. In the join construction, I see the line
> {{{
> #!python
>         todo.update( (category, axiom)
>                      for axiom in axioms.difference(axs) )
> }}}
> Since category is fixed, wouldn't this mean to just set `todo[category]` to the last axiom in `axioms.difference(axs)`? Is this a bug, or intended?

Oooops, sorry, `todo` is a set, not a dict. So, everything is alright...


---

Comment by git created at 2014-05-10 18:28:50

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2014-05-10 18:35:42

Nicolas, do you think that the new code layout (in particular for `Category.join`) is sound?

Repeating the benchmarks:

```
sage: from sage.categories.category_with_axiom import canonicalize_axioms, all_axioms
sage: L = ["Commutative", "Connected", "Commutative", "WithBasis", "Finite"]
sage: %timeit canonicalize_axioms(all_axioms, L)
100000 loops, best of 3: 3.81 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort(L)
100000 loops, best of 3: 6.01 µs per loop
sage: %timeit Category._sort_uniq(L)
100000 loops, best of 3: 15.9 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category.join(L)
1000 loops, best of 3: 510 µs per loop
```



---

Comment by nthiery created at 2014-05-10 18:42:25

Replying to [comment:42 SimonKing]:
> Something more about the join:
> 
> - The cache key is computed with _sort_uniq. Fine, this is cythonised already.
> - There remains a new cython function to create the flattened, normalised etc. list of super categories of the to-be-created join.
> - `Category.join` would be simply like this:
>   {{{
>     def join(...):
>         T = _sort_uniq(...)
>         try:
>             if as_list:
>                 return Category._join_cache[T]._super_categories
>             return Category._join_cache[T]
>         except KeyError:
>             pass
>         S = create_super_categories(T) # this will be a list!
>         if as_list:
>             return S # or do caching?
>         J = JoinCategory(S)
>         _join_cache[T] = J
>         return J
>   }}}
> I think this would be a good compromise between cythonisation and
> "keeping the function where it belongs". In particular, the
> documentation would stay in `Categories.join`.

So the core of the join algorithm would be in
`create_super_categories`, right? Since it's non trivial, we should
strive hard to keep it easy to find to read, and to debug. But yes,
this can be an option if we believe the difference is important enough.

> Since `_sort`, `_sort_uniq` and `_flatten_categories` are not part of the docs anyway (or am I mistaken?), I think there should be no problem to move these over to the helper module.

I think I ended up adding them to the docs. But they are explicitly
private methods, and thus susceptible to be moved at any time if this
suits us.

Now, since they are static methods, maybe you could do

```
from ... import _sort_uniq

class Category:
    _sort_uniq = _sort_uniq
```

and then the code could keep using Category._sort_uniq as before, right?

Cheers,


---

Comment by nthiery created at 2014-05-10 18:44:28

Replying to [comment:38 nthiery]:
> Nice. How much would you say is due to the "cythonization" of all_axioms and friends, and how much to the cythonization of the full file?

Well, it's used in `sort_uniq` :-) And we might want to use it in `_super_categories` at some point. But I agree that's it's not critical. You could also just leave it in the Python file; if not just for testing purposes.

Cheers,
                                          Nicolas


---

Comment by SimonKing created at 2014-05-10 18:49:35

Replying to [comment:47 nthiery]:
> and then the code could keep using Category._sort_uniq as before, right?

Why should we add an attribute look-up?


---

Comment by SimonKing created at 2014-05-10 18:53:26

PS: Of course, currently some tests will file due to some wrong import locations. I am running `make ptest` now to get an overview.


---

Comment by SimonKing created at 2014-05-10 18:58:43

PPS: We should find better benchmark tests.

On the one hand, we have the creation of the cache key, and there should be a test (with warm cache) that sees how much faster the cache key creation becomes.

On the other hand, we have the "category mangling" for finding the super categories of the join category. There should be a test that works around the cache. Say, with using a series of joins where the base ring varies.


---

Comment by SimonKing created at 2014-05-10 19:24:34

Surprisingly, I only get few errors. But this one is annoying:

```
Failed example:
    Category.join((Sets(), Rings(), Monoids()), as_list=True)
Expected:
    [Category of rings]
Got:
    [Category of rngs, Category of semirings]
```


But this is just due to my using the cache if `as_list=True`. I must check whether the category in the cache is a `JoinCategory`. If it isn't, then the cache item is returned, if it is, then the list of super categories is returned.


---

Comment by git created at 2014-05-10 19:38:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2014-05-10 19:40:42

Dear Nicolas,

all tests in sage.categories pass. Some of the new stuff needs to be documented and tested. But please first comment if the code distribution of Python vs. Cython works for you.

And next I'll try to find better benchmarks.


---

Comment by SimonKing created at 2014-05-10 19:52:18

Here is another benchmark. Idea: We have a list of tuples of categories, with varying base rings. For each tuple, we form the join category, first with cold cache, then with warm cache.

With #15801:

```
sage: L = [(Coalgebras(GF(q,'a')), Sets.Finite(), CommutativeRings(), SimplicialComplexes()) for q in prime_powers(2,50000)]
sage: %time C = [Category.join(Cats) for Cats in L]
CPU times: user 21.1 s, sys: 136 ms, total: 21.2 s
Wall time: 21.2 s
sage: %time C = [Category.join(Cats) for Cats in L]
CPU times: user 230 ms, sys: 1 ms, total: 231 ms
Wall time: 231 ms
```


With this branch:

```
sage: L = [(Coalgebras(GF(q,'a')), Sets.Finite(), CommutativeRings(), SimplicialComplexes()) for q in prime_powers(2,50000)]
sage: %time C = [Category.join(Cats) for Cats in L]
CPU times: user 18.7 s, sys: 172 ms, total: 18.9 s
Wall time: 18.9 s
sage: %time C = [Category.join(Cats) for Cats in L]
CPU times: user 150 ms, sys: 0 ns, total: 150 ms
Wall time: 162 ms
```


__Discussion of the benchmark__

- I am still not sure if this is a good test. Yes, there is some category+axiom mangling involved, but other examples might provide more of it.
- We have a speedup of 11% with cold cache.
- We have a speedup of 34% with warm cache.


---

Comment by SimonKing created at 2014-05-10 21:16:09

FWIW, all tests pass. More tests of new functions need to be added.


---

Comment by git created at 2014-05-10 22:22:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by SimonKing created at 2014-05-10 22:24:14

Changing status from new to needs_review.


---

Comment by tscrim created at 2014-07-24 06:54:06

Ping - needs rebasing.


---

Comment by tscrim created at 2014-07-27 04:29:59

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2014-07-27 04:29:59

I've rebased it (it was trivial) and removed `get_all_axioms` since this is still in python and we can access the module level attribute `all_axioms` easily (before this was needed since [Simon] had made `all_axioms` a cdef attribute). Since my change was removing an unused method (except in testing), I'm going to set this to positive review since the patch LGTM.
----
New commits:


---

Comment by vbraun created at 2014-07-28 03:55:41

Resolution: fixed
