# Issue 16059: Speed improvements for categories with axioms

archive/issues_016059.json:
```json
{
    "body": "CC:  nthiery mmezzarobba\n\nKeywords: cython performance categories\n\nWith the \"axiomatic\" approach towards categories introduced in #10963, we are now using join categories far more frequently than in the past. This involves many little operations (sorting, computation of index, ...) that should be made as fast as possible.\n\nHence, this ticket is about using Cython and optimizing basic algorithms in sage.categories.category and friends.\n\nIssue created by migration from https://trac.sagemath.org/ticket/16296\n\n",
    "created_at": "2014-05-06T13:55:40Z",
    "labels": [
        "categories",
        "major"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.3",
    "title": "Speed improvements for categories with axioms",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16059",
    "user": "SimonKing"
}
```
CC:  nthiery mmezzarobba

Keywords: cython performance categories

With the "axiomatic" approach towards categories introduced in #10963, we are now using join categories far more frequently than in the past. This involves many little operations (sorting, computation of index, ...) that should be made as fast as possible.

Hence, this ticket is about using Cython and optimizing basic algorithms in sage.categories.category and friends.

Issue created by migration from https://trac.sagemath.org/ticket/16296





---

archive/issue_comments_209038.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to enhancement.",
    "created_at": "2014-05-06T13:55:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209038",
    "user": "SimonKing"
}
```

Changing type from PLEASE CHANGE to enhancement.



---

archive/issue_comments_209039.json:
```json
{
    "body": "(curious)",
    "created_at": "2014-05-06T13:58:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209039",
    "user": "ncohen"
}
```

(curious)



---

archive/issue_comments_209040.json:
```json
{
    "body": "First observation: Moving sage.categories.category to Cython is not trivial, since it relies on abstract_method, which currently only accepts Python functions. Hence, abstract_method needs to be cythoned, too, or at least needs to be more permissive in the assertion that the input is `types.FunctionType`.",
    "created_at": "2014-05-06T14:48:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209040",
    "user": "SimonKing"
}
```

First observation: Moving sage.categories.category to Cython is not trivial, since it relies on abstract_method, which currently only accepts Python functions. Hence, abstract_method needs to be cythoned, too, or at least needs to be more permissive in the assertion that the input is `types.FunctionType`.



---

archive/issue_comments_209041.json:
```json
{
    "body": "Good: If one removes the assertion from abstract_method, then Sage starts.",
    "created_at": "2014-05-06T14:49:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209041",
    "user": "SimonKing"
}
```

Good: If one removes the assertion from abstract_method, then Sage starts.



---

archive/issue_comments_209042.json:
```json
{
    "body": "I have pushed an initial branch (starting with #10963, of course), changing the assertion so that both `types.FunctionType` and `cython_function_or_method` are permitted (no idea how to test the latter more elegantly than by the name of the type...), and I changing `AbstractMethod.__repr__` so that it gives comparable output for both Python and Cython methods.\n\nNote: I don't think we should Cython `AbstractMethod`. After all, they are just placeholders for \"real\" methods and are thus not time-critical.\n\nWith the branch, Sage starts.\n----\nLast 10 new commits:",
    "created_at": "2014-05-06T15:32:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209042",
    "user": "SimonKing"
}
```

I have pushed an initial branch (starting with #10963, of course), changing the assertion so that both `types.FunctionType` and `cython_function_or_method` are permitted (no idea how to test the latter more elegantly than by the name of the type...), and I changing `AbstractMethod.__repr__` so that it gives comparable output for both Python and Cython methods.

Note: I don't think we should Cython `AbstractMethod`. After all, they are just placeholders for "real" methods and are thus not time-critical.

With the branch, Sage starts.
----
Last 10 new commits:



---

archive/issue_comments_209043.json:
```json
{
    "body": "Since #10963 is supposed to be merged together with #15801, which changes sage.categories.category, we should have #15801 as dependency. Pushing the next merge now...",
    "created_at": "2014-05-06T18:00:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209043",
    "user": "SimonKing"
}
```

Since #10963 is supposed to be merged together with #15801, which changes sage.categories.category, we should have #15801 as dependency. Pushing the next merge now...



---

archive/issue_comments_209044.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2014-05-06T18:01:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209044",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_209045.json:
```json
{
    "body": "All tests in srs/sage/categories/ pass with the branch. Now, one can start to try and improve some operations...",
    "created_at": "2014-05-06T19:35:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209045",
    "user": "SimonKing"
}
```

All tests in srs/sage/categories/ pass with the branch. Now, one can start to try and improve some operations...



---

archive/issue_comments_209046.json:
```json
{
    "body": "Some functions in `c3_controlled` can not be cdef'd, because they contain \"any(...)\" clauses. For example:\n\n```\n        for i in range(max_i): #from 0 <= i < max_i:\n            O = heads[i]\n            # Does O appear in none of the tails?\n            O_key = key(O)\n            if any(O_key in tailsets[j] for j in range(nbheads) if j != i):\n                continue\n```\n\nIt might be worth-while to see if the \"any(...)\" clause can be improved by something that is faster and does not use a clause. To the very least, I guess giving Cython some hints on the type (`tailsets[j]` is a set!) might pay off.",
    "created_at": "2014-05-08T12:44:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209046",
    "user": "SimonKing"
}
```

Some functions in `c3_controlled` can not be cdef'd, because they contain "any(...)" clauses. For example:

```
        for i in range(max_i): #from 0 <= i < max_i:
            O = heads[i]
            # Does O appear in none of the tails?
            O_key = key(O)
            if any(O_key in tailsets[j] for j in range(nbheads) if j != i):
                continue
```

It might be worth-while to see if the "any(...)" clause can be improved by something that is faster and does not use a clause. To the very least, I guess giving Cython some hints on the type (`tailsets[j]` is a set!) might pay off.



---

archive/issue_comments_209047.json:
```json
{
    "body": "Indeed:\n\n```python\ndef test1(list L):\n    cdef int i,j\n    cdef int max_i = len(L)\n    for i in range(max_i):\n        if any(100 in L[j] for j in range(max_i) if j!=i):\n            continue\n        \ndef test2(list L):\n    cdef int i,j\n    cdef int max_i = len(L)\n    for i in range(max_i):\n        if any(100 in <set>(L[j]) for j in range(max_i) if j!=i):\n            continue\n        \ncpdef test3(list L):\n    cdef int i,j\n    cdef int max_i = len(L)\n    cdef bint cont\n    for i in range(max_i):\n        cont = False\n        for j from 0<=j<i:\n            if 100 in <set>(L[j]):\n                cont = True\n                break\n        if cont:\n            continue\n        for j from i<j<max_i:\n            if 100 in <set>(L[j]):\n                break\n```\n\nyields\n\n```\nsage: L = [set([randint(0,10000) for i in range(200)]) for j in range(200)]\nsage: %timeit test1(L)\n100 loops, best of 3: 2.5 ms per loop\nsage: %timeit test2(L)\n100 loops, best of 3: 2.5 ms per loop\nsage: %timeit test3(L)\n1000 loops, best of 3: 1.25 ms per loop\n```\n\nSo, let's do it like this. I hope I am not mistaken that what is happening inside `test3()` is equivalent to the \"any\" clause in the other two functions.",
    "created_at": "2014-05-08T12:58:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209047",
    "user": "SimonKing"
}
```

Indeed:

```python
def test1(list L):
    cdef int i,j
    cdef int max_i = len(L)
    for i in range(max_i):
        if any(100 in L[j] for j in range(max_i) if j!=i):
            continue
        
def test2(list L):
    cdef int i,j
    cdef int max_i = len(L)
    for i in range(max_i):
        if any(100 in <set>(L[j]) for j in range(max_i) if j!=i):
            continue
        
cpdef test3(list L):
    cdef int i,j
    cdef int max_i = len(L)
    cdef bint cont
    for i in range(max_i):
        cont = False
        for j from 0<=j<i:
            if 100 in <set>(L[j]):
                cont = True
                break
        if cont:
            continue
        for j from i<j<max_i:
            if 100 in <set>(L[j]):
                break
```

yields

```
sage: L = [set([randint(0,10000) for i in range(200)]) for j in range(200)]
sage: %timeit test1(L)
100 loops, best of 3: 2.5 ms per loop
sage: %timeit test2(L)
100 loops, best of 3: 2.5 ms per loop
sage: %timeit test3(L)
1000 loops, best of 3: 1.25 ms per loop
```

So, let's do it like this. I hope I am not mistaken that what is happening inside `test3()` is equivalent to the "any" clause in the other two functions.



---

archive/issue_comments_209048.json:
```json
{
    "body": "PS: `100 in <set>(L[j])` seems to have no advantage over `100 in L[j]`.",
    "created_at": "2014-05-08T12:59:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209048",
    "user": "SimonKing"
}
```

PS: `100 in <set>(L[j])` seems to have no advantage over `100 in L[j]`.



---

archive/issue_comments_209049.json:
```json
{
    "body": "Another closure occurs in the following definition:\n\n```\ncdef list tailsets = [set(key(O) for O in tail) for tail in tails]\n```\n\nLet's see how to make this a little faster without a closure:\n\n```python\ndef set_test1(list tails):\n    cdef list tail\n    return [set(O**2 for O in tail) for tail in tails]\n\ncpdef list set_test2(list tails):\n    cdef list tail\n    cdef set part_set = set()\n    cdef list result = []\n    for tail in tails:\n        part_set = set()\n        for O in tail:\n            part_set.add(O**2)\n        result.append(part_set)\n    return result\n```\n\nyields\n\n```\nsage: L = [[randint(0,10000) for i in range(200)] for j in range(200)]\nsage: set_test1(L) == set_test2(L)\nTrue\nsage: %timeit set_test1(L)\n100 loops, best of 3: 8.52 ms per loop\nsage: %timeit set_test2(L)\n100 loops, best of 3: 6.51 ms per loop\n```\n\nThis time, we do not gain so much, but it is something, and we can make the function cpdef then, reducing the calling overhead after (c)importing it into another module.",
    "created_at": "2014-05-08T13:16:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209049",
    "user": "SimonKing"
}
```

Another closure occurs in the following definition:

```
cdef list tailsets = [set(key(O) for O in tail) for tail in tails]
```

Let's see how to make this a little faster without a closure:

```python
def set_test1(list tails):
    cdef list tail
    return [set(O**2 for O in tail) for tail in tails]

cpdef list set_test2(list tails):
    cdef list tail
    cdef set part_set = set()
    cdef list result = []
    for tail in tails:
        part_set = set()
        for O in tail:
            part_set.add(O**2)
        result.append(part_set)
    return result
```

yields

```
sage: L = [[randint(0,10000) for i in range(200)] for j in range(200)]
sage: set_test1(L) == set_test2(L)
True
sage: %timeit set_test1(L)
100 loops, best of 3: 8.52 ms per loop
sage: %timeit set_test2(L)
100 loops, best of 3: 6.51 ms per loop
```

This time, we do not gain so much, but it is something, and we can make the function cpdef then, reducing the calling overhead after (c)importing it into another module.



---

archive/issue_comments_209050.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-08T13:56:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209050",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209051.json:
```json
{
    "body": "With #15801, I get\n\n```\nsage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]\nsage: %timeit Category._sort_uniq(L)\n10000 loops, best of 3: 25.2 \u00b5s per loop\nsage: %timeit Category._sort(L)\n100000 loops, best of 3: 6.22 \u00b5s per loop\n```\n\n\nWith the current branch from here, I get\n\n```\nsage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]\nsage: %timeit Category._sort_uniq(L)\n100000 loops, best of 3: 14.1 \u00b5s per loop\nsage: %timeit Category._sort(L)\n100000 loops, best of 3: 5.61 \u00b5s per loop\n```\n\nMaking `sage.categories.category` Cython means that we could now cimport `WeakValueDictionary` and get a bit more speed by accessing the contents by cdef methods.",
    "created_at": "2014-05-08T13:59:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209051",
    "user": "SimonKing"
}
```

With #15801, I get

```
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort_uniq(L)
10000 loops, best of 3: 25.2 µs per loop
sage: %timeit Category._sort(L)
100000 loops, best of 3: 6.22 µs per loop
```


With the current branch from here, I get

```
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort_uniq(L)
100000 loops, best of 3: 14.1 µs per loop
sage: %timeit Category._sort(L)
100000 loops, best of 3: 5.61 µs per loop
```

Making `sage.categories.category` Cython means that we could now cimport `WeakValueDictionary` and get a bit more speed by accessing the contents by cdef methods.



---

archive/issue_comments_209052.json:
```json
{
    "body": "Too bad: With the current branch,\n\n```\nsage: from sage.misc.sageinspect import sage_getargspec\nsage: sage_getargspec(Category.join)\n  File \"<string>\", line unknown\nSyntaxError: Syntactical group starting with '(' did not end with ')'\n```\n\nHence, the doc doesn't build. It seems that I need to create a dependency for this, improving `sage_getargspec`.",
    "created_at": "2014-05-08T14:15:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209052",
    "user": "SimonKing"
}
```

Too bad: With the current branch,

```
sage: from sage.misc.sageinspect import sage_getargspec
sage: sage_getargspec(Category.join)
  File "<string>", line unknown
SyntaxError: Syntactical group starting with '(' did not end with ')'
```

Hence, the doc doesn't build. It seems that I need to create a dependency for this, improving `sage_getargspec`.



---

archive/issue_comments_209053.json:
```json
{
    "body": "I created #16309 for the argspec issue.",
    "created_at": "2014-05-08T14:23:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209053",
    "user": "SimonKing"
}
```

I created #16309 for the argspec issue.



---

archive/issue_comments_209054.json:
```json
{
    "body": "With #16309, the documentation builds, and\n\n```\nsage: from sage.misc.sageinspect import sage_getargspec\nsage: sage_getargspec(Category.join)\nArgSpec(args=['categories', 'as_list', 'ignore_axioms', 'axioms'], varargs=None, keywords=None, defaults=(False, (), ()))\n```\n\nI am running tests now. However, even if they pass, I'd like to try and get some more speed for the `WeakValueDictionary` used in `sage.categories.category`, and `sage.categories.category_with_axiom` probably has more potential for improvements.",
    "created_at": "2014-05-08T21:31:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209054",
    "user": "SimonKing"
}
```

With #16309, the documentation builds, and

```
sage: from sage.misc.sageinspect import sage_getargspec
sage: sage_getargspec(Category.join)
ArgSpec(args=['categories', 'as_list', 'ignore_axioms', 'axioms'], varargs=None, keywords=None, defaults=(False, (), ()))
```

I am running tests now. However, even if they pass, I'd like to try and get some more speed for the `WeakValueDictionary` used in `sage.categories.category`, and `sage.categories.category_with_axiom` probably has more potential for improvements.



---

archive/issue_comments_209055.json:
```json
{
    "body": "Interestingly, with #16309 alone, the tests of sageinspect.py pass. But adding the commits from here, one test in sageinspect.py fails:\n\n```\n        sage: C = Rings()\n        sage: HC = C.hom_category()\n        sage: sage_getsourcelines(HC)\n        (['    class HomCategory(HomCategory):\\n', ...], ...)\n```\n\nis expected, but the indentation (that is due to the nesting) is wrong.\n\nActually it is even more wrong than that: The relevant class is defined as a nested class in sage.categories.rings, but we get\n\n```\nsage: from sage.misc.sageinspect import _sage_getdoc_unformatted\nsage: _sage_getdoc_unformatted(HC)\n\"File: sage/categories/category.pyx (starting at line 2361)\\n\\n        Initializes this HomCategory\\n\\n        INPUT:\\n         - ``category`` -- the category whose Homsets are the objects of this category.\\n         - ``name`` -- An optional name for this category.\\n\\n        EXAMPLES:\\n\\n        We need to skip one test, since the hierarchy of hom categories isn't\\n        consistent yet::\\n\\n            sage: C = sage.categories.category.HomCategory(Rings()); C\\n            Category of hom sets in Category of rings\\n            sage: TestSuite(C).run(skip=['_test_category_graph'])\\n        \"\n```\n\nThat's all really strange. The code of the nested class is\n\n```\n    class HomCategory(HomCategory):\n        pass\n```\n\nand indeed we have\n\n```\nsage: HC.__doc__\n```\n\nWhy is _sage_getdoc_unformatted returning something nonempty, even though the class has empty `__doc__`?",
    "created_at": "2014-05-08T22:58:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209055",
    "user": "SimonKing"
}
```

Interestingly, with #16309 alone, the tests of sageinspect.py pass. But adding the commits from here, one test in sageinspect.py fails:

```
        sage: C = Rings()
        sage: HC = C.hom_category()
        sage: sage_getsourcelines(HC)
        (['    class HomCategory(HomCategory):\n', ...], ...)
```

is expected, but the indentation (that is due to the nesting) is wrong.

Actually it is even more wrong than that: The relevant class is defined as a nested class in sage.categories.rings, but we get

```
sage: from sage.misc.sageinspect import _sage_getdoc_unformatted
sage: _sage_getdoc_unformatted(HC)
"File: sage/categories/category.pyx (starting at line 2361)\n\n        Initializes this HomCategory\n\n        INPUT:\n         - ``category`` -- the category whose Homsets are the objects of this category.\n         - ``name`` -- An optional name for this category.\n\n        EXAMPLES:\n\n        We need to skip one test, since the hierarchy of hom categories isn't\n        consistent yet::\n\n            sage: C = sage.categories.category.HomCategory(Rings()); C\n            Category of hom sets in Category of rings\n            sage: TestSuite(C).run(skip=['_test_category_graph'])\n        "
```

That's all really strange. The code of the nested class is

```
    class HomCategory(HomCategory):
        pass
```

and indeed we have

```
sage: HC.__doc__
```

Why is _sage_getdoc_unformatted returning something nonempty, even though the class has empty `__doc__`?



---

archive/issue_comments_209056.json:
```json
{
    "body": "Now I get what is going wrong.\n\nSince `Rings.HomCategory` has no docstring, `_sage_getdoc_unformatted` returns the docstring of `Rings.HomCategory.__init__`. This used to by a Python method, hence had no embedded information on the source code. But with this branch, `__init__` is a Cython information and thus has embedding information, that unfortunately lets `sage_getsourcelines` look up the wrong file.\n\nBut in the first place: Why do we need to look up `_sage_getdoc_unformatted` when calling `sage_getsourcelines`? After all, `Rings.HomCategory` is a Python class in a Python file! Shouldn't it provide all relevant information?",
    "created_at": "2014-05-08T23:31:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209056",
    "user": "SimonKing"
}
```

Now I get what is going wrong.

Since `Rings.HomCategory` has no docstring, `_sage_getdoc_unformatted` returns the docstring of `Rings.HomCategory.__init__`. This used to by a Python method, hence had no embedded information on the source code. But with this branch, `__init__` is a Cython information and thus has embedding information, that unfortunately lets `sage_getsourcelines` look up the wrong file.

But in the first place: Why do we need to look up `_sage_getdoc_unformatted` when calling `sage_getsourcelines`? After all, `Rings.HomCategory` is a Python class in a Python file! Shouldn't it provide all relevant information?



---

archive/issue_comments_209057.json:
```json
{
    "body": "Probably the problem lies in the nesting:\n\n```\nsage: inspect.getsourcelines(HC.__class__)\n---------------------------------------------------------------------------\nIOError                                   Traceback (most recent call last)\n<ipython-input-12-91ebc0139037> in <module>()\n----> 1 inspect.getsourcelines(HC.__class__)\n\n/home/king/Sage/git/sage/local/lib/python/inspect.pyc in getsourcelines(object)\n    688     original source file the first line of code was found.  An IOError is\n    689     raised if the source code cannot be retrieved.\"\"\"\n--> 690     lines, lnum = findsource(object)\n    691 \n    692     if ismodule(object): return lines, 0\n\n/home/king/Sage/git/sage/local/lib/python2.7/site-packages/IPython/core/ultratb.pyc in findsource(object)\n    189             return lines, candidates[0][1]\n    190         else:\n--> 191             raise IOError('could not find class definition')\n    192 \n    193     if ismethod(object):\n\nIOError: could not find class definition\n```\n",
    "created_at": "2014-05-08T23:32:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209057",
    "user": "SimonKing"
}
```

Probably the problem lies in the nesting:

```
sage: inspect.getsourcelines(HC.__class__)
---------------------------------------------------------------------------
IOError                                   Traceback (most recent call last)
<ipython-input-12-91ebc0139037> in <module>()
----> 1 inspect.getsourcelines(HC.__class__)

/home/king/Sage/git/sage/local/lib/python/inspect.pyc in getsourcelines(object)
    688     original source file the first line of code was found.  An IOError is
    689     raised if the source code cannot be retrieved."""
--> 690     lines, lnum = findsource(object)
    691 
    692     if ismodule(object): return lines, 0

/home/king/Sage/git/sage/local/lib/python2.7/site-packages/IPython/core/ultratb.pyc in findsource(object)
    189             return lines, candidates[0][1]
    190         else:
--> 191             raise IOError('could not find class definition')
    192 
    193     if ismethod(object):

IOError: could not find class definition
```




---

archive/issue_comments_209058.json:
```json
{
    "body": "With the newest version of #16309, the problem from comment:21 is fixed. So, back to (first) fixing doctests (if there is anything broken) and (second) improve speed further.",
    "created_at": "2014-05-09T00:27:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209058",
    "user": "SimonKing"
}
```

With the newest version of #16309, the problem from comment:21 is fixed. So, back to (first) fixing doctests (if there is anything broken) and (second) improve speed further.



---

archive/issue_comments_209059.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-09T06:45:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209059",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209060.json:
```json
{
    "body": "With the new commits from #16309 and one change in the import location of a doctest, all tests pass. But this is now not more than an intermediate stage, as I want to tweak `sage.categories.category_with_axiom` and want to improve weak cache access.",
    "created_at": "2014-05-09T06:48:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209060",
    "user": "SimonKing"
}
```

With the new commits from #16309 and one change in the import location of a doctest, all tests pass. But this is now not more than an intermediate stage, as I want to tweak `sage.categories.category_with_axiom` and want to improve weak cache access.



---

archive/issue_comments_209061.json:
```json
{
    "body": "Just for the record: The following is faster than `uncamelcase`.\n\n```python\ncpdef inline default_match_splitter(match):\n    cdef str g = match.group()\n    return g[0]+'_'+g[1]\n\ncamel_splitter = re.compile(\"[a-z][A-Z]\")\n\ndef new_uncamelcase(s, separator=None):\n    if separator is None:\n        return camel_splitter.sub(default_match_splitter, s).lower()\n    return camel_splitter.sub(lambda match: match.group()[0]+separator+match.group()[1], s).lower()\n\n```\n\nHowever, since `uncamelcase` is rarely called, I will leave it.",
    "created_at": "2014-05-09T07:43:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209061",
    "user": "SimonKing"
}
```

Just for the record: The following is faster than `uncamelcase`.

```python
cpdef inline default_match_splitter(match):
    cdef str g = match.group()
    return g[0]+'_'+g[1]

camel_splitter = re.compile("[a-z][A-Z]")

def new_uncamelcase(s, separator=None):
    if separator is None:
        return camel_splitter.sub(default_match_splitter, s).lower()
    return camel_splitter.sub(lambda match: match.group()[0]+separator+match.group()[1], s).lower()

```

However, since `uncamelcase` is rarely called, I will leave it.



---

archive/issue_comments_209062.json:
```json
{
    "body": "Or perhaps I should *not* leave it. I just notice that `uncamelcase` is also called (once) in `Category._sort`, and this *is* critical for speed.",
    "created_at": "2014-05-09T07:48:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209062",
    "user": "SimonKing"
}
```

Or perhaps I should *not* leave it. I just notice that `uncamelcase` is also called (once) in `Category._sort`, and this *is* critical for speed.



---

archive/issue_comments_209063.json:
```json
{
    "body": "Replying to [comment:28 SimonKing]:\n> Or perhaps I should *not* leave it. I just notice that `uncamelcase` is also called (once) in `Category._sort`, and this *is* critical for speed.\n\nForget this comment. Apparently this is only because I tested an example involving \"Finite\".",
    "created_at": "2014-05-09T07:50:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209063",
    "user": "SimonKing"
}
```

Replying to [comment:28 SimonKing]:
> Or perhaps I should *not* leave it. I just notice that `uncamelcase` is also called (once) in `Category._sort`, and this *is* critical for speed.

Forget this comment. Apparently this is only because I tested an example involving "Finite".



---

archive/issue_comments_209064.json:
```json
{
    "body": "Hi Simon!\n\nThanks so much for exploring how much we could potentially gain by\ncythonizing some of the category infrastructure code; we need this\nkind of facts to take good decisions. At this point definitely +1 on\noptimizing lower level things like c3, since the interface and\nalgorithms are quite final.\n\nOn the other hand, I am wondering whether the current not so massive\nspeed improvements make a compelling case for actually cythonizing the\nfile category.py right now. The point is that cythonizing makes the\ncode much harder to debug (I agree, this is a problem of pdb: we\nreally would need to have a debugger supporting both python and cython\ncode; alas I don't see progress in this direction anytime soon).\n\nE.g. I find the coercion code very painful to work with precisely\nbecause of this. In fact, when I tried to fix things a couple years\nago, I first uncythonized it ...\n\nI fear that it would similarly slow down the followup development we\nwant to do with categories, e.g. improving the join algorithm.\n\nWhat do you think?\n\nCheers,\n                                 Nicolas",
    "created_at": "2014-05-09T16:27:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209064",
    "user": "nthiery"
}
```

Hi Simon!

Thanks so much for exploring how much we could potentially gain by
cythonizing some of the category infrastructure code; we need this
kind of facts to take good decisions. At this point definitely +1 on
optimizing lower level things like c3, since the interface and
algorithms are quite final.

On the other hand, I am wondering whether the current not so massive
speed improvements make a compelling case for actually cythonizing the
file category.py right now. The point is that cythonizing makes the
code much harder to debug (I agree, this is a problem of pdb: we
really would need to have a debugger supporting both python and cython
code; alas I don't see progress in this direction anytime soon).

E.g. I find the coercion code very painful to work with precisely
because of this. In fact, when I tried to fix things a couple years
ago, I first uncythonized it ...

I fear that it would similarly slow down the followup development we
want to do with categories, e.g. improving the join algorithm.

What do you think?

Cheers,
                                 Nicolas



---

archive/issue_comments_209065.json:
```json
{
    "body": "Replying to [comment:30 nthiery]:\n> On the other hand, I am wondering whether the current not so massive\n> speed improvements make a compelling case for actually cythonizing the\n> file category.py right now. The point is that cythonizing makes the\n> code much harder to debug\n\nEven if it is a Python class defined in a Cython file? I thought that problems will only start if things are cdef.\n\n> I fear that it would similarly slow down the followup development we\n> want to do with categories, e.g. improving the join algorithm.\n> \n> What do you think?\n\nActually improving the join algorithm speed-wise is my main goal for this ticket. I am not sure if much progress can be achieved without Cython.\n\nI'd say: I try to improve the speed as much as possible by as much Cython as needed. In a second step, we can see if some of it can also be done in Python, or if some parts can be moved to a Cython file separate from `sage.categories.category`.",
    "created_at": "2014-05-09T20:26:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209065",
    "user": "SimonKing"
}
```

Replying to [comment:30 nthiery]:
> On the other hand, I am wondering whether the current not so massive
> speed improvements make a compelling case for actually cythonizing the
> file category.py right now. The point is that cythonizing makes the
> code much harder to debug

Even if it is a Python class defined in a Cython file? I thought that problems will only start if things are cdef.

> I fear that it would similarly slow down the followup development we
> want to do with categories, e.g. improving the join algorithm.
> 
> What do you think?

Actually improving the join algorithm speed-wise is my main goal for this ticket. I am not sure if much progress can be achieved without Cython.

I'd say: I try to improve the speed as much as possible by as much Cython as needed. In a second step, we can see if some of it can also be done in Python, or if some parts can be moved to a Cython file separate from `sage.categories.category`.



---

archive/issue_comments_209066.json:
```json
{
    "body": "Replying to [comment:31 SimonKing]:\n> Even if it is a Python class defined in a Cython file?\n\nThat's kind of a shame, but yes, even in this case. Put this in\n`test_debug_cython.pyx`:\n\n```\nimport pdb\ndef f(x):\n    for i in range(10):\n        pdb.set_trace()\n        x = x + 1\n```\n\nand run\n\n```\nsage: load(\"test_debug_cython.pyx\")\nCompiling ./test_debug_cython.pyx...\nsage: f(3)\n```\n\n\nThe function f does not even appear in the backtrace.\n\n> Actually improving the join algorithm speed-wise is my main goal for\n> this ticket. I am not sure if much progress can be achieved without\n> Cython.\n\nThe upcoming work is not only about speed, but also functionality. Or\ntrying alternative algorithms, like your pet boolean polynomial ideals\napproach. And even speedwise, there may be room to improve the\nalgorithm itself, rather than the implementation.\n\n> I'd say: I try to improve the speed as much as possible by as much Cython as needed.\n> In a second step, we can see if some of it can also be done in Python, or\n\nDefinitely worth trying hard and see how much we can gain. And see if\nit's worth making the code more complex / harder to trace.\n\n> if some parts can be moved to a Cython file separate from `sage.categories.category`.\n\nThis could be a good approach indeed.\n\nCheers,\n                                     Nicolas",
    "created_at": "2014-05-09T21:01:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209066",
    "user": "nthiery"
}
```

Replying to [comment:31 SimonKing]:
> Even if it is a Python class defined in a Cython file?

That's kind of a shame, but yes, even in this case. Put this in
`test_debug_cython.pyx`:

```
import pdb
def f(x):
    for i in range(10):
        pdb.set_trace()
        x = x + 1
```

and run

```
sage: load("test_debug_cython.pyx")
Compiling ./test_debug_cython.pyx...
sage: f(3)
```


The function f does not even appear in the backtrace.

> Actually improving the join algorithm speed-wise is my main goal for
> this ticket. I am not sure if much progress can be achieved without
> Cython.

The upcoming work is not only about speed, but also functionality. Or
trying alternative algorithms, like your pet boolean polynomial ideals
approach. And even speedwise, there may be room to improve the
algorithm itself, rather than the implementation.

> I'd say: I try to improve the speed as much as possible by as much Cython as needed.
> In a second step, we can see if some of it can also be done in Python, or

Definitely worth trying hard and see how much we can gain. And see if
it's worth making the code more complex / harder to trace.

> if some parts can be moved to a Cython file separate from `sage.categories.category`.

This could be a good approach indeed.

Cheers,
                                     Nicolas



---

archive/issue_comments_209067.json:
```json
{
    "body": "As I have indicated on #10963, one could replace the tuple all_axioms by a container derived from dict. It is used in `canonicalise_axioms`, which can be accelerated by 35%.",
    "created_at": "2014-05-09T21:03:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209067",
    "user": "SimonKing"
}
```

As I have indicated on #10963, one could replace the tuple all_axioms by a container derived from dict. It is used in `canonicalise_axioms`, which can be accelerated by 35%.



---

archive/issue_comments_209068.json:
```json
{
    "body": "43% actually...",
    "created_at": "2014-05-09T21:17:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209068",
    "user": "SimonKing"
}
```

43% actually...



---

archive/issue_comments_209069.json:
```json
{
    "body": "Replying to [comment:33 SimonKing]:\n> As I have indicated on #10963, one could replace the tuple all_axioms by a container derived from dict. It is used in `canonicalise_axioms`, which can be accelerated by 35%.\n\n+1!",
    "created_at": "2014-05-09T21:38:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209069",
    "user": "nthiery"
}
```

Replying to [comment:33 SimonKing]:
> As I have indicated on #10963, one could replace the tuple all_axioms by a container derived from dict. It is used in `canonicalise_axioms`, which can be accelerated by 35%.

+1!



---

archive/issue_comments_209070.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-09T21:42:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209070",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209071.json:
```json
{
    "body": "With #15801:\n\n```\nsage: from sage.categories.category_with_axiom import canonicalize_axioms\nsage: L = [\"Commutative\", \"Connected\", \"Commutative\", \"WithBasis\", \"Finite\"]\nsage: %timeit canonicalize_axioms(L)\n100000 loops, best of 3: 8.23 \u00b5s per loop\nsage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]\nsage: %timeit Category._sort(L)\n100000 loops, best of 3: 6.12 \u00b5s per loop\nsage: %timeit Category._sort_uniq(L)\n10000 loops, best of 3: 24.7 \u00b5s per loop\nsage: %timeit Category.join(L)\n10000 loops, best of 3: 854 \u00b5s per loop\n```\n\n\nWith the branch from here:\n\n```\nsage: from sage.categories.category_with_axiom import canonicalize_axioms\nsage: L = [\"Commutative\", \"Connected\", \"Commutative\", \"WithBasis\", \"Finite\"]\nsage: %timeit canonicalize_axioms(L)\n100000 loops, best of 3: 3.77 \u00b5s per loop\nsage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]\nsage: %timeit Category._sort(L)\n100000 loops, best of 3: 5.49 \u00b5s per loop\nsage: %timeit Category._sort_uniq(L)\n100000 loops, best of 3: 13.8 \u00b5s per loop\nsage: %timeit Category.join(L)\n10000 loops, best of 3: 659 \u00b5s per loop\n```\n\n\nSo, there is an improvement of >50% in `canonicalize_axioms`, 44% in `_sort_uniq` (but not in `_sort`), and 22% in `join`.",
    "created_at": "2014-05-09T21:51:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209071",
    "user": "SimonKing"
}
```

With #15801:

```
sage: from sage.categories.category_with_axiom import canonicalize_axioms
sage: L = ["Commutative", "Connected", "Commutative", "WithBasis", "Finite"]
sage: %timeit canonicalize_axioms(L)
100000 loops, best of 3: 8.23 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort(L)
100000 loops, best of 3: 6.12 µs per loop
sage: %timeit Category._sort_uniq(L)
10000 loops, best of 3: 24.7 µs per loop
sage: %timeit Category.join(L)
10000 loops, best of 3: 854 µs per loop
```


With the branch from here:

```
sage: from sage.categories.category_with_axiom import canonicalize_axioms
sage: L = ["Commutative", "Connected", "Commutative", "WithBasis", "Finite"]
sage: %timeit canonicalize_axioms(L)
100000 loops, best of 3: 3.77 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort(L)
100000 loops, best of 3: 5.49 µs per loop
sage: %timeit Category._sort_uniq(L)
100000 loops, best of 3: 13.8 µs per loop
sage: %timeit Category.join(L)
10000 loops, best of 3: 659 µs per loop
```


So, there is an improvement of >50% in `canonicalize_axioms`, 44% in `_sort_uniq` (but not in `_sort`), and 22% in `join`.



---

archive/issue_comments_209072.json:
```json
{
    "body": "Nice. How much would you say is due to the \"cythonization\" of all_axioms and friends, and how much to the cythonization of the full file?",
    "created_at": "2014-05-10T07:19:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209072",
    "user": "nthiery"
}
```

Nice. How much would you say is due to the "cythonization" of all_axioms and friends, and how much to the cythonization of the full file?



---

archive/issue_comments_209073.json:
```json
{
    "body": "According to grep, `Category._sort()` is not really used. So, would you mind if I remove `_sort()`, and only replace `_sort_uniq()` by a Cython function?\n\nBest regards,\nSimon",
    "created_at": "2014-05-10T12:50:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209073",
    "user": "SimonKing"
}
```

According to grep, `Category._sort()` is not really used. So, would you mind if I remove `_sort()`, and only replace `_sort_uniq()` by a Cython function?

Best regards,
Simon



---

archive/issue_comments_209074.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-10T13:27:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209074",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209075.json:
```json
{
    "body": "I switched `sage.categories.category` and `sage.categories.category_with_axiom` back to Python. Instead, I created a module with helper functions. Fortunately, `_sort_uniq` is a static method, and thus it is no problem to replace it with a cpdef function imported from the helper module.\n\nThe current timings:\n\n```\nsage: from sage.categories.category_with_axiom import canonicalize_axioms, all_axioms\nsage: canonicalize_axioms(all_axioms, [\"Commutative\", \"Connected\", \"Commutative\", \"WithBasis\", \"Finite\"])\n('Finite', 'Connected', 'WithBasis', 'Commutative')\nsage: %timeit canonicalize_axioms(all_axioms, L)\n100000 loops, best of 3: 3.83 \u00b5s per loop\nsage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]\nsage: %timeit Category._sort(L)\n100000 loops, best of 3: 6.25 \u00b5s per loop\nsage: %timeit Category._sort_uniq(L)\n100000 loops, best of 3: 15.9 \u00b5s per loop\nsage: %timeit Category.join(L)\n10000 loops, best of 3: 816 \u00b5s per loop\n```\n\nNote: Since I want to keep `all_axioms` in `sage.categories.category_with_axiom`, I need to provide it to `canonicalize_axioms` (now defined in the helper module) as an argument.\n\n__Evaluation__\n\n- `canonicalize_axioms` is still fast, and so is (almost) `_sort_uniq`.\n- I kept `_sort` in for now, but it isn't used, and I'd simply remove it.\n- The join is now slow again, since it is Python.\n\n__Concerning join__\n\nPerhaps one could create another helper function for the join. It is static, hence, a cpdef function won't be a problem. However, it uses a cache. This cache should be local to `sage.categories.category.Category`, but when defining the `join` in the helper module, we'd like to have cython-speed access to it. OTOH, we could define the cache in the helper module, and then assign it as an attribute to `Category`, if we think that the cache is needed outside of the helper.",
    "created_at": "2014-05-10T13:37:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209075",
    "user": "SimonKing"
}
```

I switched `sage.categories.category` and `sage.categories.category_with_axiom` back to Python. Instead, I created a module with helper functions. Fortunately, `_sort_uniq` is a static method, and thus it is no problem to replace it with a cpdef function imported from the helper module.

The current timings:

```
sage: from sage.categories.category_with_axiom import canonicalize_axioms, all_axioms
sage: canonicalize_axioms(all_axioms, ["Commutative", "Connected", "Commutative", "WithBasis", "Finite"])
('Finite', 'Connected', 'WithBasis', 'Commutative')
sage: %timeit canonicalize_axioms(all_axioms, L)
100000 loops, best of 3: 3.83 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort(L)
100000 loops, best of 3: 6.25 µs per loop
sage: %timeit Category._sort_uniq(L)
100000 loops, best of 3: 15.9 µs per loop
sage: %timeit Category.join(L)
10000 loops, best of 3: 816 µs per loop
```

Note: Since I want to keep `all_axioms` in `sage.categories.category_with_axiom`, I need to provide it to `canonicalize_axioms` (now defined in the helper module) as an argument.

__Evaluation__

- `canonicalize_axioms` is still fast, and so is (almost) `_sort_uniq`.
- I kept `_sort` in for now, but it isn't used, and I'd simply remove it.
- The join is now slow again, since it is Python.

__Concerning join__

Perhaps one could create another helper function for the join. It is static, hence, a cpdef function won't be a problem. However, it uses a cache. This cache should be local to `sage.categories.category.Category`, but when defining the `join` in the helper module, we'd like to have cython-speed access to it. OTOH, we could define the cache in the helper module, and then assign it as an attribute to `Category`, if we think that the cache is needed outside of the helper.



---

archive/issue_comments_209076.json:
```json
{
    "body": "Something more about the join:\n\n- The cache key is computed with _sort_uniq. Fine, this is cythonised already.\n- There remains a new cython function to create the flattened, normalised etc. list of super categories of the to-be-created join.\n- `Category.join` would be simply like this:\n  {{{\n    def join(...):\n        T = _sort_uniq(...)\n        try:\n            if as_list:\n                return Category._join_cache[T]._super_categories\n            return Category._join_cache[T]\n        except KeyError:\n            pass\n        S = create_super_categories(T) # this will be a list!\n        if as_list:\n            return S # or do caching?\n        J = JoinCategory(S)\n        _join_cache[T] = J\n        return J\n  }}}\n\nI think this would be a good compromise between cythonisation and \"keeping the function where it belongs\". In particular, the documentation would stay in `Categories.join`. Since `_sort`, `_sort_uniq` and `_flatten_categories` are not part of the docs anyway (or am I mistaken?), I think there should be no problem to move these over to the helper module.",
    "created_at": "2014-05-10T14:14:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209076",
    "user": "SimonKing"
}
```

Something more about the join:

- The cache key is computed with _sort_uniq. Fine, this is cythonised already.
- There remains a new cython function to create the flattened, normalised etc. list of super categories of the to-be-created join.
- `Category.join` would be simply like this:
  {{{
    def join(...):
        T = _sort_uniq(...)
        try:
            if as_list:
                return Category._join_cache[T]._super_categories
            return Category._join_cache[T]
        except KeyError:
            pass
        S = create_super_categories(T) # this will be a list!
        if as_list:
            return S # or do caching?
        J = JoinCategory(S)
        _join_cache[T] = J
        return J
  }}}

I think this would be a good compromise between cythonisation and "keeping the function where it belongs". In particular, the documentation would stay in `Categories.join`. Since `_sort`, `_sort_uniq` and `_flatten_categories` are not part of the docs anyway (or am I mistaken?), I think there should be no problem to move these over to the helper module.



---

archive/issue_comments_209077.json:
```json
{
    "body": "Nicolas, can you comment on this. In the join construction, I see the line\n\n```python\n        todo.update( (category, axiom)\n                     for axiom in axioms.difference(axs) )\n```\n\nSince category is fixed, wouldn't this mean to just set `todo[category]` to the last axiom in `axioms.difference(axs)`? Is this a bug, or intended?",
    "created_at": "2014-05-10T15:50:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209077",
    "user": "SimonKing"
}
```

Nicolas, can you comment on this. In the join construction, I see the line

```python
        todo.update( (category, axiom)
                     for axiom in axioms.difference(axs) )
```

Since category is fixed, wouldn't this mean to just set `todo[category]` to the last axiom in `axioms.difference(axs)`? Is this a bug, or intended?



---

archive/issue_comments_209078.json:
```json
{
    "body": "Replying to [comment:43 SimonKing]:\n> Nicolas, can you comment on this. In the join construction, I see the line\n> {{{\n> #!python\n>         todo.update( (category, axiom)\n>                      for axiom in axioms.difference(axs) )\n> }}}\n> Since category is fixed, wouldn't this mean to just set `todo[category]` to the last axiom in `axioms.difference(axs)`? Is this a bug, or intended?\n\nOooops, sorry, `todo` is a set, not a dict. So, everything is alright...",
    "created_at": "2014-05-10T15:51:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209078",
    "user": "SimonKing"
}
```

Replying to [comment:43 SimonKing]:
> Nicolas, can you comment on this. In the join construction, I see the line
> {{{
> #!python
>         todo.update( (category, axiom)
>                      for axiom in axioms.difference(axs) )
> }}}
> Since category is fixed, wouldn't this mean to just set `todo[category]` to the last axiom in `axioms.difference(axs)`? Is this a bug, or intended?

Oooops, sorry, `todo` is a set, not a dict. So, everything is alright...



---

archive/issue_comments_209079.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-10T18:28:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209079",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209080.json:
```json
{
    "body": "Nicolas, do you think that the new code layout (in particular for `Category.join`) is sound?\n\nRepeating the benchmarks:\n\n```\nsage: from sage.categories.category_with_axiom import canonicalize_axioms, all_axioms\nsage: L = [\"Commutative\", \"Connected\", \"Commutative\", \"WithBasis\", \"Finite\"]\nsage: %timeit canonicalize_axioms(all_axioms, L)\n100000 loops, best of 3: 3.81 \u00b5s per loop\nsage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]\nsage: %timeit Category._sort(L)\n100000 loops, best of 3: 6.01 \u00b5s per loop\nsage: %timeit Category._sort_uniq(L)\n100000 loops, best of 3: 15.9 \u00b5s per loop\nsage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]\nsage: %timeit Category.join(L)\n1000 loops, best of 3: 510 \u00b5s per loop\n```\n",
    "created_at": "2014-05-10T18:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209080",
    "user": "SimonKing"
}
```

Nicolas, do you think that the new code layout (in particular for `Category.join`) is sound?

Repeating the benchmarks:

```
sage: from sage.categories.category_with_axiom import canonicalize_axioms, all_axioms
sage: L = ["Commutative", "Connected", "Commutative", "WithBasis", "Finite"]
sage: %timeit canonicalize_axioms(all_axioms, L)
100000 loops, best of 3: 3.81 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category._sort(L)
100000 loops, best of 3: 6.01 µs per loop
sage: %timeit Category._sort_uniq(L)
100000 loops, best of 3: 15.9 µs per loop
sage: L = [Coalgebras(QQ), Sets().Finite(), Algebras(ZZ), SimplicialComplexes()]
sage: %timeit Category.join(L)
1000 loops, best of 3: 510 µs per loop
```




---

archive/issue_comments_209081.json:
```json
{
    "body": "Replying to [comment:42 SimonKing]:\n> Something more about the join:\n> \n> - The cache key is computed with _sort_uniq. Fine, this is cythonised already.\n> - There remains a new cython function to create the flattened, normalised etc. list of super categories of the to-be-created join.\n> - `Category.join` would be simply like this:\n>   {{{\n>     def join(...):\n>         T = _sort_uniq(...)\n>         try:\n>             if as_list:\n>                 return Category._join_cache[T]._super_categories\n>             return Category._join_cache[T]\n>         except KeyError:\n>             pass\n>         S = create_super_categories(T) # this will be a list!\n>         if as_list:\n>             return S # or do caching?\n>         J = JoinCategory(S)\n>         _join_cache[T] = J\n>         return J\n>   }}}\n> I think this would be a good compromise between cythonisation and\n> \"keeping the function where it belongs\". In particular, the\n> documentation would stay in `Categories.join`.\n\nSo the core of the join algorithm would be in\n`create_super_categories`, right? Since it's non trivial, we should\nstrive hard to keep it easy to find to read, and to debug. But yes,\nthis can be an option if we believe the difference is important enough.\n\n> Since `_sort`, `_sort_uniq` and `_flatten_categories` are not part of the docs anyway (or am I mistaken?), I think there should be no problem to move these over to the helper module.\n\nI think I ended up adding them to the docs. But they are explicitly\nprivate methods, and thus susceptible to be moved at any time if this\nsuits us.\n\nNow, since they are static methods, maybe you could do\n\n```\nfrom ... import _sort_uniq\n\nclass Category:\n    _sort_uniq = _sort_uniq\n```\n\nand then the code could keep using Category._sort_uniq as before, right?\n\nCheers,",
    "created_at": "2014-05-10T18:42:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209081",
    "user": "nthiery"
}
```

Replying to [comment:42 SimonKing]:
> Something more about the join:
> 
> - The cache key is computed with _sort_uniq. Fine, this is cythonised already.
> - There remains a new cython function to create the flattened, normalised etc. list of super categories of the to-be-created join.
> - `Category.join` would be simply like this:
>   {{{
>     def join(...):
>         T = _sort_uniq(...)
>         try:
>             if as_list:
>                 return Category._join_cache[T]._super_categories
>             return Category._join_cache[T]
>         except KeyError:
>             pass
>         S = create_super_categories(T) # this will be a list!
>         if as_list:
>             return S # or do caching?
>         J = JoinCategory(S)
>         _join_cache[T] = J
>         return J
>   }}}
> I think this would be a good compromise between cythonisation and
> "keeping the function where it belongs". In particular, the
> documentation would stay in `Categories.join`.

So the core of the join algorithm would be in
`create_super_categories`, right? Since it's non trivial, we should
strive hard to keep it easy to find to read, and to debug. But yes,
this can be an option if we believe the difference is important enough.

> Since `_sort`, `_sort_uniq` and `_flatten_categories` are not part of the docs anyway (or am I mistaken?), I think there should be no problem to move these over to the helper module.

I think I ended up adding them to the docs. But they are explicitly
private methods, and thus susceptible to be moved at any time if this
suits us.

Now, since they are static methods, maybe you could do

```
from ... import _sort_uniq

class Category:
    _sort_uniq = _sort_uniq
```

and then the code could keep using Category._sort_uniq as before, right?

Cheers,



---

archive/issue_comments_209082.json:
```json
{
    "body": "Replying to [comment:38 nthiery]:\n> Nice. How much would you say is due to the \"cythonization\" of all_axioms and friends, and how much to the cythonization of the full file?\n\nWell, it's used in `sort_uniq` :-) And we might want to use it in `_super_categories` at some point. But I agree that's it's not critical. You could also just leave it in the Python file; if not just for testing purposes.\n\nCheers,\n                                          Nicolas",
    "created_at": "2014-05-10T18:44:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209082",
    "user": "nthiery"
}
```

Replying to [comment:38 nthiery]:
> Nice. How much would you say is due to the "cythonization" of all_axioms and friends, and how much to the cythonization of the full file?

Well, it's used in `sort_uniq` :-) And we might want to use it in `_super_categories` at some point. But I agree that's it's not critical. You could also just leave it in the Python file; if not just for testing purposes.

Cheers,
                                          Nicolas



---

archive/issue_comments_209083.json:
```json
{
    "body": "Replying to [comment:47 nthiery]:\n> and then the code could keep using Category._sort_uniq as before, right?\n\nWhy should we add an attribute look-up?",
    "created_at": "2014-05-10T18:49:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209083",
    "user": "SimonKing"
}
```

Replying to [comment:47 nthiery]:
> and then the code could keep using Category._sort_uniq as before, right?

Why should we add an attribute look-up?



---

archive/issue_comments_209084.json:
```json
{
    "body": "PS: Of course, currently some tests will file due to some wrong import locations. I am running `make ptest` now to get an overview.",
    "created_at": "2014-05-10T18:53:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209084",
    "user": "SimonKing"
}
```

PS: Of course, currently some tests will file due to some wrong import locations. I am running `make ptest` now to get an overview.



---

archive/issue_comments_209085.json:
```json
{
    "body": "PPS: We should find better benchmark tests.\n\nOn the one hand, we have the creation of the cache key, and there should be a test (with warm cache) that sees how much faster the cache key creation becomes.\n\nOn the other hand, we have the \"category mangling\" for finding the super categories of the join category. There should be a test that works around the cache. Say, with using a series of joins where the base ring varies.",
    "created_at": "2014-05-10T18:58:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209085",
    "user": "SimonKing"
}
```

PPS: We should find better benchmark tests.

On the one hand, we have the creation of the cache key, and there should be a test (with warm cache) that sees how much faster the cache key creation becomes.

On the other hand, we have the "category mangling" for finding the super categories of the join category. There should be a test that works around the cache. Say, with using a series of joins where the base ring varies.



---

archive/issue_comments_209086.json:
```json
{
    "body": "Surprisingly, I only get few errors. But this one is annoying:\n\n```\nFailed example:\n    Category.join((Sets(), Rings(), Monoids()), as_list=True)\nExpected:\n    [Category of rings]\nGot:\n    [Category of rngs, Category of semirings]\n```\n\n\nBut this is just due to my using the cache if `as_list=True`. I must check whether the category in the cache is a `JoinCategory`. If it isn't, then the cache item is returned, if it is, then the list of super categories is returned.",
    "created_at": "2014-05-10T19:24:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209086",
    "user": "SimonKing"
}
```

Surprisingly, I only get few errors. But this one is annoying:

```
Failed example:
    Category.join((Sets(), Rings(), Monoids()), as_list=True)
Expected:
    [Category of rings]
Got:
    [Category of rngs, Category of semirings]
```


But this is just due to my using the cache if `as_list=True`. I must check whether the category in the cache is a `JoinCategory`. If it isn't, then the cache item is returned, if it is, then the list of super categories is returned.



---

archive/issue_comments_209087.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-10T19:38:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209087",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209088.json:
```json
{
    "body": "Dear Nicolas,\n\nall tests in sage.categories pass. Some of the new stuff needs to be documented and tested. But please first comment if the code distribution of Python vs. Cython works for you.\n\nAnd next I'll try to find better benchmarks.",
    "created_at": "2014-05-10T19:40:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209088",
    "user": "SimonKing"
}
```

Dear Nicolas,

all tests in sage.categories pass. Some of the new stuff needs to be documented and tested. But please first comment if the code distribution of Python vs. Cython works for you.

And next I'll try to find better benchmarks.



---

archive/issue_comments_209089.json:
```json
{
    "body": "Here is another benchmark. Idea: We have a list of tuples of categories, with varying base rings. For each tuple, we form the join category, first with cold cache, then with warm cache.\n\nWith #15801:\n\n```\nsage: L = [(Coalgebras(GF(q,'a')), Sets.Finite(), CommutativeRings(), SimplicialComplexes()) for q in prime_powers(2,50000)]\nsage: %time C = [Category.join(Cats) for Cats in L]\nCPU times: user 21.1 s, sys: 136 ms, total: 21.2 s\nWall time: 21.2 s\nsage: %time C = [Category.join(Cats) for Cats in L]\nCPU times: user 230 ms, sys: 1 ms, total: 231 ms\nWall time: 231 ms\n```\n\n\nWith this branch:\n\n```\nsage: L = [(Coalgebras(GF(q,'a')), Sets.Finite(), CommutativeRings(), SimplicialComplexes()) for q in prime_powers(2,50000)]\nsage: %time C = [Category.join(Cats) for Cats in L]\nCPU times: user 18.7 s, sys: 172 ms, total: 18.9 s\nWall time: 18.9 s\nsage: %time C = [Category.join(Cats) for Cats in L]\nCPU times: user 150 ms, sys: 0 ns, total: 150 ms\nWall time: 162 ms\n```\n\n\n__Discussion of the benchmark__\n\n- I am still not sure if this is a good test. Yes, there is some category+axiom mangling involved, but other examples might provide more of it.\n- We have a speedup of 11% with cold cache.\n- We have a speedup of 34% with warm cache.",
    "created_at": "2014-05-10T19:52:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209089",
    "user": "SimonKing"
}
```

Here is another benchmark. Idea: We have a list of tuples of categories, with varying base rings. For each tuple, we form the join category, first with cold cache, then with warm cache.

With #15801:

```
sage: L = [(Coalgebras(GF(q,'a')), Sets.Finite(), CommutativeRings(), SimplicialComplexes()) for q in prime_powers(2,50000)]
sage: %time C = [Category.join(Cats) for Cats in L]
CPU times: user 21.1 s, sys: 136 ms, total: 21.2 s
Wall time: 21.2 s
sage: %time C = [Category.join(Cats) for Cats in L]
CPU times: user 230 ms, sys: 1 ms, total: 231 ms
Wall time: 231 ms
```


With this branch:

```
sage: L = [(Coalgebras(GF(q,'a')), Sets.Finite(), CommutativeRings(), SimplicialComplexes()) for q in prime_powers(2,50000)]
sage: %time C = [Category.join(Cats) for Cats in L]
CPU times: user 18.7 s, sys: 172 ms, total: 18.9 s
Wall time: 18.9 s
sage: %time C = [Category.join(Cats) for Cats in L]
CPU times: user 150 ms, sys: 0 ns, total: 150 ms
Wall time: 162 ms
```


__Discussion of the benchmark__

- I am still not sure if this is a good test. Yes, there is some category+axiom mangling involved, but other examples might provide more of it.
- We have a speedup of 11% with cold cache.
- We have a speedup of 34% with warm cache.



---

archive/issue_comments_209090.json:
```json
{
    "body": "FWIW, all tests pass. More tests of new functions need to be added.",
    "created_at": "2014-05-10T21:16:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209090",
    "user": "SimonKing"
}
```

FWIW, all tests pass. More tests of new functions need to be added.



---

archive/issue_comments_209091.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-05-10T22:22:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209091",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_209092.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-05-10T22:24:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209092",
    "user": "SimonKing"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_209093.json:
```json
{
    "body": "Ping - needs rebasing.",
    "created_at": "2014-07-24T06:54:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209093",
    "user": "tscrim"
}
```

Ping - needs rebasing.



---

archive/issue_comments_209094.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-07-27T04:29:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209094",
    "user": "tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_209095.json:
```json
{
    "body": "I've rebased it (it was trivial) and removed `get_all_axioms` since this is still in python and we can access the module level attribute `all_axioms` easily (before this was needed since [Simon] had made `all_axioms` a cdef attribute). Since my change was removing an unused method (except in testing), I'm going to set this to positive review since the patch LGTM.\n----\nNew commits:",
    "created_at": "2014-07-27T04:29:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209095",
    "user": "tscrim"
}
```

I've rebased it (it was trivial) and removed `get_all_axioms` since this is still in python and we can access the module level attribute `all_axioms` easily (before this was needed since [Simon] had made `all_axioms` a cdef attribute). Since my change was removing an unused method (except in testing), I'm going to set this to positive review since the patch LGTM.
----
New commits:



---

archive/issue_comments_209096.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-07-28T03:55:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16059",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16059#issuecomment-209096",
    "user": "vbraun"
}
```

Resolution: fixed
