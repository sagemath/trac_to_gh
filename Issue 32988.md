# Issue 32988: Lazy transition maps

Issue created by migration from https://trac.sagemath.org/ticket/33225

Original creator: @mjungmath

Original creation time: 2022-01-24 10:48:59

CC:  tscrim egourgoulhon @tobiasdiez tkarn

Keywords: lazy, charts

As discussed in #31249, a lazy implementation of charts or transition maps comes in handy in some situations as the number of transition maps explodes very easily.

In this ticket, we introduce a lazy implementation of transition maps that only initializes most attributes, especially the associated `MultiCoordFunction` and the inverse, if necessary.


---

Comment by @mjungmath created at 2022-01-24 10:56:08

We could try to speed up initialization by using [__slots__](https://docs.python.org/3/reference/datamodel.html#slots). In my opinion, this is something we should use more frequently in `manifolds` anyway.


---

Comment by tscrim created at 2022-01-25 00:05:00

This seems like a good partial measure to do and is much smaller in scope than broad lazy objects. I also support the more targeted focus on the most computationally intensive part.

I would worry about doing `__slots__` on a later ticket unless it is both easy and simple to do for this.


---

Comment by tscrim created at 2022-01-25 00:05:16

Changing type from PLEASE CHANGE to enhancement.


---

Comment by tkarn created at 2022-02-02 15:18:54

Are there any good examples of lazy objects in the existing codebase which we could use for inspiration?


---

Comment by @mjungmath created at 2022-02-02 22:17:56

To name a few:
- [Lazy Attributes](https://doc.sagemath.org/html/en/reference/misc/sage/misc/lazy_attribute.html)
- [Lazy Lists](https://doc.sagemath.org/html/en/reference/misc/sage/misc/lazy_list.html)
- [Lazy Power Series](https://doc.sagemath.org/html/en/reference/combinat/sage/combinat/species/series.html)


---

Comment by @mjungmath created at 2022-02-02 22:20:19

Replying to [comment:2 tscrim]:
> I would worry about doing `__slots__` on a later ticket unless it is both easy and simple to do for this. 

It shouldn't be very difficult. Actually it's quite straightforward. You only add a `__slots__` attribute. Done. Keep in mind that the corresponding class has no `__dict__` attribute then.


---

Comment by tscrim created at 2022-02-03 01:29:46

Replying to [comment:6 gh-mjungmath]:
> Replying to [comment:2 tscrim]:
> > I would worry about doing `__slots__` on a later ticket unless it is both easy and simple to do for this. 
> 
> It shouldn't be very difficult. Actually it's quite straightforward. You only add a `__slots__` attribute. Done. Keep in mind that the corresponding class has no `__dict__` attribute then.

That is not a trivial thing as it can have very far-reaching effects because you cannot free add attributes and it doesn't work well with ``@`cached_method` IIRC. It puts the class much more in the C++ realm (not necessarily a bad thing, but it can mean a lot of boilerplate code).


---

Comment by tscrim created at 2022-02-03 01:32:45

Replying to [comment:4 tkarn]:
> Are there any good examples of lazy objects in the existing codebase which we could use for inspiration?

Two basic implementation ideas would be you either use an ``@`lazy_attribute` decorator for the relevant attribute(s) or you set it to `None` on `__init__` and compute it when called for. (IMO, the first option is much better for Python both in terms of code maintenance, readability, and efficiency.) However, each individual implementation might require some variations.


---

Comment by tkarn created at 2022-02-06 17:06:54

Replying to [comment:8 tscrim]:
> Replying to [comment:4 tkarn]:
> > Are there any good examples of lazy objects in the existing codebase which we could use for inspiration?
> 
> Two basic implementation ideas would be you either use an ``@`lazy_attribute` decorator for the relevant attribute(s) or you set it to `None` on `__init__` and compute it when called for. (IMO, the first option is much better for Python both in terms of code maintenance, readability, and efficiency.) However, each individual implementation might require some variations.

Thanks so much!

Thinking about the original motivation for this, the Grassmannian, the problem we are looking to solve is the large overhead created by the creation of many charts. Looking at each individual chart and transition map it doesn't appear to me to have too much overhead. Are we looking to create something that is more of a "lazy atlas" or is a lazy transition map really what we want?


---

Comment by @mjungmath created at 2022-02-06 17:35:36

Replying to [comment:9 tkarn]:
> Thinking about the original motivation for this, the Grassmannian, the problem we are looking to solve is the large overhead created by the creation of many charts. Looking at each individual chart and transition map it doesn't appear to me to have too much overhead. Are we looking to create something that is more of a "lazy atlas" or is a lazy transition map really what we want?

I don't know for sure. My suggestion is to make a prun test on high-dimensional projective spaces and see what the culprits are.

Notice that one transition map is always accompanied by a `MultiCoordFunction` object, and another transition map, namely its inverse, again with a `MultiCoordFunction` object. However, there is no need to initialize the inverse on the fly when the formulas are known. My hope is that this leads to some speed-up.

Implementing `__slots__` for charts might also help a little (speeds up initialization and access).


---

Comment by tscrim created at 2022-02-06 22:08:23

I would look at the sphere with perhaps stereographic and spherical coordinates. Really any manifold that has more complicated change of coordinates by default. (One way to get some speed might be to turn off checks; IDK if this is done already or not.) Please avoid doing slots on this ticket; that should be it's own ticket if we decide to do that.


---

Comment by egourgoulhon created at 2022-02-07 17:25:10

Replying to [comment:10 gh-mjungmath]:
> Replying to [comment:9 tkarn]:
> > Thinking about the original motivation for this, the Grassmannian, the problem we are looking to solve is the large overhead created by the creation of many charts. Looking at each individual chart and transition map it doesn't appear to me to have too much overhead. Are we looking to create something that is more of a "lazy atlas" or is a lazy transition map really what we want?
> 
> I don't know for sure. My suggestion is to make a prun test on high-dimensional projective spaces and see what the culprits are.

+1


---

Comment by egourgoulhon created at 2022-02-07 17:28:53

Replying to [comment:11 tscrim]:
> I would look at the sphere with perhaps stereographic and spherical coordinates. Really any manifold that has more complicated change of coordinates by default. (One way to get some speed might be to turn off checks; IDK if this is done already or not.) 

This is done already for spheres, cf. line 1029 of `sage/manifolds/differentiable/examples/sphere.py`:


```
spher_to_stereoN.set_inverse(*coordfunc, check=False)
```


>Please avoid doing slots on this ticket; that should be it's own ticket if we decide to do that.

+1
