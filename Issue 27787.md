# Issue 27787: Add FractionField support to specialization

Issue created by migration from https://trac.sagemath.org/ticket/28024

Original creator: @Torrencem

Original creation time: 2019-06-20 13:09:03

CC:  bhutz

The specialization function doesn't support having a FractionField splitting a tower of nested polynomial rings:


```
R.<c> = QQ[]
F = Frac(R)
S.<x> = F[]

(x + c).specialization({c:2})
# prints x + c
```


This ticket introduces a branch which adds this feature


---

Comment by @Torrencem created at 2019-06-20 13:11:29

Changing keywords from "" to "SI2019".


---

Comment by @Torrencem created at 2019-06-20 13:18:56

Changing status from new to needs_review.


---

Comment by bhutz created at 2019-06-22 17:01:09

Changing status from needs_review to needs_work.


---

Comment by bhutz created at 2019-06-22 17:01:09

I think you're off to a good start here. I have a couple issues and a couple questions. Also, my branch simplifies the commit structure a little and adds the ticket number to the message.

in fraction field element:

- specialization needs better documentation (second longer description, doc test, inputs, output)

- add a _sub_specialization example

- line 515: not sure what this is doing. It seems to be saying a dictionary entry in not anywhere in the tower, but when I attempt that no error is raised

```
else:
   raise NameError("argument " + str(var) + " is not a generator anywhere in the polynomial tower")
```

The following example seems like it should fail this test, yet does not. Also the following example is giving incorrect output (u is being treated as c)

```
Rr.<u>=QQ[]
R.<c> = PolynomialRing(ZZ)
S.<x,y,z> = PolynomialRing(FractionField(R))
T.<a,b>=PolynomialRing(FractionField(S))
D = dict({u:1,x:1})
from sage.rings.polynomial.flatten import SpecializationMorphism
f = SpecializationMorphism(T, D)
f._sub_specialization
g=a^2+c*x*y
g.specialization(D)
```


I don't think passing in a value for u should fail, it should just do nothing with it.

- Some more comments in the Fractional Specializaiton Morphism class wouldn't hurt to explain the recursive calling structure

- 659: ("p must be a fractional field element") -> fraction field

- no trailing white space in lines 640, 663

- no blank line 656
----
New commits:


---

Comment by @Torrencem created at 2019-06-22 20:57:41

So about your example, I will continue working on it, but for future reference it's a case of a particularly nasty looking FlatteningMorphism bug (on master):


```
# Rr is completely unrelated to our polynomial tower
Rr.<u> = QQ[]

# Notice: no fractions
R.<c> = ZZ[]
S.<x,y,z> = R[]

from sage.rings.polynomial.flatten import FlatteningMorphism

F = FlatteningMorphism(S)
F(u)
# returns 'c' for some reason! Should give some kind of error
```


The code I wrote didn't anticipate this, so I'll take a closer look later this weekend!


---

Comment by bhutz created at 2019-06-22 22:38:43

I didn't check master, so this bug was already there :(.

It's actually a pretty bad bug since I was getting examples where the specialization contains values for both u and c and it was choosing the u value to specialize c to even though u was not in the tower at all.

It may be an issue of sage being somewhat too helpful along the lines of coercing R(u) = c. If you use Rr.<u,v>=QQ[] then u is not treated as c in these examples. So it may be that somewhere in the code you need to explicitly map the variables instead of coercing.


---

Comment by @Torrencem created at 2019-06-22 23:31:46

I added a check at the beginning of the function that catches this error case. The bug in FlattenMorphism looks difficult because it just uses the ring constructor, which is very generous in converting variables into other rings. This change should be enough for specialization, however
----
New commits:


---

Comment by git created at 2019-06-22 23:57:10

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by bhutz created at 2019-06-24 16:44:57

The new commits do catch the unused variables. Although I think it should work like .subs({D}) does in that it ignores anything passed in that is not in the tower (rather than raise an error).

I'm not sure we want to 'fix' the Specialization Morphism call. It may seem weird when you first do it, but having the behavior consistent with how the polynomial ring constructors work in general is a good thing. So, whatever coercion sage would do in the ring constructor for the domain/codomain should behave the same way as for the morphism call (which it does).

Specialization is a little different as we are substituting in values for variables, and that change of variable names leads to unexpected behavior.


---

Comment by git created at 2019-06-24 20:31:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @Torrencem created at 2019-06-24 20:33:14

I agree. The latest commit changes from an error to just filtering them out for passing variables who's names aren't in the tower somewhere


---

Comment by @Torrencem created at 2019-07-06 13:39:25

Since we've decided we're not changing the Specialization Morphism call, and I've updated so it ignores anything not in the tower


---

Comment by @Torrencem created at 2019-07-06 13:39:25

Changing status from needs_work to needs_review.


---

Comment by bhutz created at 2019-07-09 14:26:17

Changing status from needs_review to positive_review.


---

Comment by bhutz created at 2019-07-09 14:26:17

looks good


---

Comment by vbraun created at 2019-07-11 18:53:54

Resolution: fixed
