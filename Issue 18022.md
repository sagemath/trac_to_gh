# Issue 18022: comparison of symbolic functions

Issue created by migration from Trac.

Original creator: dkrenn

Original creation time: 2015-04-20 12:46:33

CC:  rws vdelecroix

We have the following strange (wrong) behavior:

```
sage: f(x) = 2*x
sage: bool(f == 2*x)
True
```

On the other hand we have

```
sage: f(x) = 2*x
sage: g(y) = 2*y
sage: bool(f == g)
False
```



---

Comment by dkrenn created at 2015-04-20 12:46:48

This came up in #18092.


---

Comment by nbruin created at 2015-04-21 15:46:44

This is a consequence of how coercion and comparison are implemented:

```
sage: var('y')
y
sage: f(x)=x*y
sage: A=x*y
sage: cSR=parent(f)
sage: cSR.coerce_map_from(SR)
Conversion map:
  From: Symbolic Ring
  To:   Callable function ring with arguments (x,)
sage: SR.coerce_map_from(cSR) is None
True
```

So, A coerces into the parent of f (and not the other way around): That means that for equality testing, A is coerced into the parent of f and then the comparison is done: comparison testing in sage is defined to be "equal up to coercion" (which probably necessarily breaks in all kinds of particular cases).

If you do *not* want these things to compare equal then you should break the coercion. That might be reasonable. Conversion can still exist. Currently you can do:

```
sage: f+y^2
x |--> x*y + y^2
```

without coercion but with conversion, this would need to be:

```
sage: f+cSR(y^2)
x |--> x*y + y^2
```

which does not seem unreasonable to me.


---

Comment by vdelecroix created at 2015-04-21 15:57:13

Replying to [comment:2 nbruin]:
Hi Niles,

Why not modifying the comparison codes for Callable function ring?

> If you do *not* want these things to compare equal then you should break the coercion. That might be reasonable. Conversion can still exist. Currently you can do:
> {{{
> sage: f+y^2
> x |--> x*y + y^2
> }}}
> without coercion but with conversion, this would need to be:
> {{{
> sage: f+cSR(y^2)
> x |--> x*y + y^2
> }}}
> which does not seem unreasonable to me.

I definitely would like to be able to do `f+1` without an error!

Vincent


---

Comment by nbruin created at 2015-04-21 16:23:46

Replying to [comment:3 vdelecroix]:
> Why not modifying the comparison codes for Callable function ring?
[...]
> I definitely would like to be able to do `f+1` without an error!

The second would probably still work if the integers still coerce into `cSR` (and since `cSR` inherits from `SR` it would be a lot of work to break that). But it's a direct consequence that if `f+1` works then `bool( cSR(1) == 1)` will be true, basically because `cSR(1)-1` is then 0 (instead of an error), which is what happens in the example in the ticket too.

If you're going to change the comparison for the callable function ring you'd be letting `cSR` behave completely different from other sage parents. It would also be a lot of work because currently comparison on `cSR` is just inherited from `SR`.

The implementation of comparison tests on `SR` only comes into play after the coercion framework has had its way with the arguments.
