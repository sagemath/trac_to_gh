# Issue 27691: Implement Lex DFS

Issue created by migration from https://trac.sagemath.org/ticket/27928

Original creator: @giorgosgiapis

Original creation time: 2019-06-04 14:42:54

Keywords: gsoc19

In this ticket, we implement Lex DFS traversal as described in [this](http://www.cs.toronto.edu/~krueger/papers/unified.ps) paper. Also, we rewrite the code for Lex BFS to follow the pseudocode in the paper which is easier to understand.


---

Comment by @giorgosgiapis created at 2019-06-04 15:16:24

Changing status from new to needs_review.


---

Comment by @giorgosgiapis created at 2019-06-04 15:16:24

New commits:


---

Comment by dcoudert created at 2019-06-12 15:04:24

Long time ago, we tried to implement the linear time algorithm for LexBFS, but it's not finalized. See #11736. It could give you some ideas. At least a working and clean LexBFS is a great improvement.


Some comments:

- You should let a brief description of the algorithm and add a reference in `src/doc/en/reference/references/index.rst`

```diff
-        This algorithm maintains for each vertex left in the graph a code
-        corresponding to the vertices already removed. The vertex of maximal
-        code (according to the lexicographic order) is then removed, and the
-        codes are updated.
+        The algorithm used is described in
+        `this <http://www.cs.toronto.edu/~krueger/papers/unified.ps>`_ by
+        Derek G. Corneil and Richard Krueger.
```


- no need for this empty line

```diff
+
+        nV = self.order()
```


- unless I missed something

```diff
-            edges = [(id_inv[i], id_inv[pred[i]]) for i in range(self.order()) if pred[i] != -1]
+            edges = [(id_inv[i], id_inv[pred[i]]) for i in range(nV) if pred[i] != -1]
```


- instead of lambda, it might be better to use a def

```diff
         l = lambda x: code[x]
+        def l(x):
+            return code[x]
```



- in `lex_DFS`, instead of defining `add_element = (lambda y: value.append(id_inv[y])) if not reverse else (lambda y: value.insert(0, id_inv[y]))`, you should always do `value.append(id_inv[y])` and after the while loop reverse the list if `reverse` is true. Indeed, inserting at the beginning of a list is costly.

- in the code, is it possible to insert at the end of the list and use a different comparison function ? I'm not sure it is a good idea. At least think about it.

- I did not check carefully if the 3-sun graph is already defined in our graph constructors...

- both methods are defined in `generic_graph.py`. What happen if `self` is directed ?


---

Comment by @giorgosgiapis created at 2019-06-13 10:03:41

Both Lex BFS and Lex DFS can be implemented in O(n+m) time. In #27518 I implemented a function to return the adjacency list of a boost graph. What we could do now is just convert our graph to a boost graph, get its adjacency list and then run the linear time algorithm for both Lex BFS and Lex DFS. Should I proceed to the creation of this method in `generic_graph_pyx`?\\
\\


> - both methods are defined in `generic_graph.py`. What happen if `self` is directed ?

I don't think that a directed graph can cause any problem. The algorithm should work for both directed and undirected graphs.


---

Comment by dcoudert created at 2019-06-13 15:54:01

Replying to [comment:4 gh-giorgosgiapis]:
> Both Lex BFS and Lex DFS can be implemented in O(n+m) time. In #27518 I implemented a function to return the adjacency list of a boost graph.
which method ?

> What we could do now is just convert our graph to a boost graph, get its adjacency list and then run the linear time algorithm for both Lex BFS and Lex DFS. Should I proceed to the creation of this method in `generic_graph_pyx`?

If you use boost, the best is certainly to add the method to `boost_graph.pyx`

> > - both methods are defined in `generic_graph.py`. What happen if `self` is directed ?
> 
> I don't think that a directed graph can cause any problem. The algorithm should work for both directed and undirected graphs.

You should try and add appropriate doctests .


---

Comment by @giorgosgiapis created at 2019-06-13 16:03:58

Replying to [comment:5 dcoudert]:

> which method ?

Method `edge_list()` in  `boost_interface.cpp`. It doesn't directly return the adjacency list but we can create it easily from the edge list. I  am not sure however whether or not it is more efficient to do this rather than building it directly from the sage graph.


---

Comment by dcoudert created at 2019-06-13 16:18:50

From a Sage Graph, we already have access to the list of edges, the list of neighbors, the list of incident edges, etc. so I don't understand why you want to use `edge_list` from boost. Of course, if it helps getting a much faster code, then go for it.


---

Comment by @giorgosgiapis created at 2019-06-13 18:09:08

Replying to [comment:7 dcoudert]:
> From a Sage Graph, we already have access to the list of edges, the list of neighbors, the list of incident edges, etc. so I don't understand why you want to use `edge_list` from boost. Of course, if it helps getting a much faster code, then go for it.

I have implemented Lex BFS in Cython. Should I remove Lex BFS from `generic_graph.py` or leave it there and just call the Cython version from inside the method?


---

Comment by dcoudert created at 2019-06-13 18:14:22

It's better to call the cython version from the Python version. Add parameter `algorithm=...`. This way you can add a doctest to check that both methods return the same result.


---

Comment by @giorgosgiapis created at 2019-06-13 18:45:50

Replying to [comment:9 dcoudert]:
> It's better to call the cython version from the Python version. Add parameter `algorithm=...`. This way you can add a doctest to check that both methods return the same result.

Unfortunately, the current lex BFS method does not work with DiGraphs, the reason being that to get the neighbors of a vertex `v` it examines the `v-th` **column** of the adjacency matrix whereas it should examine the `v-th` **row**. In undirected graphs this isn't a problem since this matrix is symmetric.


---

Comment by @giorgosgiapis created at 2019-06-13 19:16:41

Also, I do not think it is needed to have two separate algorithms to perform Lex BFS since both do exactly the same thing and their only difference is the data structures used. Therefore I believe that it is better to just call the Cython method from the one in `generic_graph.py`.


---

Comment by git created at 2019-06-13 19:44:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-06-13 19:47:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-06-14 06:40:52

Replying to [comment:10 gh-giorgosgiapis]:
> Unfortunately, the current lex BFS method does not work with DiGraphs, the reason being that to get the neighbors of a vertex `v` it examines the `v-th` **column** of the adjacency matrix whereas it should examine the `v-th` **row**. In undirected graphs this isn't a problem since this matrix is symmetric.

The code prior to this comment was not using the adjacency matrix, and we have iterators to get the neighbors, out neighbors, etc. So I don't understand this comment.
 
> Also, I do not think it is needed to have two separate algorithms to perform Lex BFS since both do exactly the same thing and their only difference is the data structures used. Therefore I believe that it is better to just call the Cython method from the one in `generic_graph.py`. 

It's never bas to have 2 methods, even if very similar, to check the correctness of the new one.

In the `Cython code`:
- instead of creating `adjacency_list` with `vector`, you could use static sparse graphs. See for instance in `distances_all_pairs.pyx`
- the test `if nV == 0:` should be done before feeding other data structures
- `cdef dict int_to_v = dict(enumerate(G))` -> `cdef list int_to_v = list(G)`
- `cdef u_int, v_int` -> `cdef int u_int, v_int`
- for `pred`, why not using an integer array instead of a list ?

May be we should create a new file names `graph_traversals.pyx` to host lexBFS, lexDFS, lexM, etc.


---

Comment by @giorgosgiapis created at 2019-06-14 09:43:49

Replying to [comment:14 dcoudert]:
> Replying to [comment:10 gh-giorgosgiapis]:
> > Unfortunately, the current lex BFS method does not work with DiGraphs, the reason being that to get the neighbors of a vertex `v` it examines the `v-th` **column** of the adjacency matrix whereas it should examine the `v-th` **row**. In undirected graphs this isn't a problem since this matrix is symmetric.
> 
> The code prior to this comment was not using the adjacency matrix, and we have iterators to get the neighbors, out neighbors, etc. So I don't understand this comment.
\\
The original code I see uses the adjacency matrix I mentioned and does not work for directed graphs. The version I have is 8.8.beta4. Maybe the code was patched in a newer beta release?\\
\\
> In the `Cython code`:
> - instead of creating `adjacency_list` with `vector`, you could use static sparse graphs. See for instance in `distances_all_pairs.pyx`
> - the test `if nV == 0:` should be done before feeding other data structures
> - `cdef dict int_to_v = dict(enumerate(G))` -> `cdef list int_to_v = list(G)`
> - `cdef u_int, v_int` -> `cdef int u_int, v_int`
> - for `pred`, why not using an integer array instead of a list ?
\\
Will do.\\
\\

> May be we should create a new file names `graph_traversals.pyx` to host lexBFS, lexDFS, lexM, etc.
\\
When all of these methods are created I will add them to this new file.


---

Comment by git created at 2019-06-14 12:43:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-06-14 13:04:12

> The original code I see uses the adjacency matrix I mentioned and does not work for directed graphs. The version I have is 8.8.beta4. Maybe the code was patched in a newer beta release?
Oups, my fault. So yes, it's not good for digraphs.


---

Comment by git created at 2019-07-01 13:45:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by embray created at 2019-07-03 11:37:56

Moving tickets from the Sage 8.8 milestone that have been actively worked on in the last six months to the next release milestone (optimistically).


---

Comment by @giorgosgiapis created at 2019-07-03 14:48:08

I'm adding both methods in a new file called `traversals.pyx`


---

Comment by git created at 2019-07-03 16:09:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-07-03 16:11:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-07-06 13:16:44

I have edited the code and pushed to a new branch in `public/` so that we can both edit it.

More precisely, I did the following
- rebase on `8.9.beta1`

- in `generic_graph_pyx.pxd`, remove (no longer needed here)

```diff
+from libcpp.vector cimport vector
+
+
```

- in `generic_graph_pyx.pyx`, remove 

```diff
+import collections
```


- in `generic_graph.py`: use alias to methods instead of extra frontend method. It's shorter and more efficient this way.

- in `traversals.pyx`
 - change file header, add table of methods and copyright
 - extend one line description of methods
 - put proper bibliographic reference
 - add missing deallocation of short digraph
 - make the graph simple if it allows loops or multiple edges.  In general, **DO NOT MODIFY INPUT GRAPH**. This is strictly forbidden ! Either we raise an error, or use `to_simple` to make a copy without loop/multiedges. Here, instead of checking if the graph effectively has loops or multiedges, I directly make a copy. I think it's more efficient like that, but may be not...


What remains to be done:
- add tests for corner case (empty (di)graph, etc.)
- try other (di)graphs, in particular a symmetric digraph to check if it's working well
- Check if further improvements are possible
- BFS and DFS are iterators. Can't we turn LexBFS and LexDFS to iterators as well ? it might not be possible when `reverse=True`.

----
New commits:


---

Comment by git created at 2019-07-06 13:19:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-07-06 13:22:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-07-06 13:24:11

Also, I'm currently unable to build the documentation of sagemath. Try to do it and check if the html code is nice.


---

Comment by @giorgosgiapis created at 2019-07-06 14:08:20

Replying to [comment:26 dcoudert]:
> Also, I'm currently unable to build the documentation of sagemath. Try to do it and check if the html code is nice.

I'm now building the documentation. Once that is done I will create some tests.


---

Comment by @giorgosgiapis created at 2019-07-06 14:09:27

Also, I am unable to build the documentation in my Mac OS system (it works fine in Linux). Is this a known issue with sage?


---

Comment by dcoudert created at 2019-07-06 14:23:27

Replying to [comment:28 gh-giorgosgiapis]:
> Also, I am unable to build the documentation in my Mac OS system (it works fine in Linux). Is this a known issue with sage?
Not that I'm aware of. I also have issue on mac but my laptop is old and its system as well. I'm too lazy to update it because it's never a good time... I'm waiting for a new laptop.

Have you done a `make doc-clean` before trying to build the doc ? what's the error message ? You can call for help on [sage-devel](https://groups.google.com/forum/#!forum/sage-devel)


---

Comment by @giorgosgiapis created at 2019-07-06 18:51:00

Documentation finished building but I can't seem to find the html files for the new file. What did I do wrong?

(I can see the documentation for the methods in generic_graph's documentation only. Is this how it is supposed to be?)


---

Comment by dcoudert created at 2019-07-06 20:38:14

You must add `sage/graphs/traversals` to `src/doc/en/reference/graphs/index.rst`. See e.g., #25436.

But I'm pretty sure you can already see it. It's the same path than other files of the graph module, so `sage/local/share/doc/sage/...`


---

Comment by git created at 2019-07-06 22:28:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @giorgosgiapis created at 2019-07-06 22:29:07

Now everything seems ok with the display of the documentation.


---

Comment by dcoudert created at 2019-07-07 09:19:22

I have a doubt on the use of memset. I might be wrong, but I think you fill each byte of each integer of array pred with -1. A for loop might be safer here, no ?

Also:

```diff
-        for i in range (0, out_degree(sd, v)):
+        for i in range(0, out_degree(sd, v)):
```



---

Comment by git created at 2019-07-09 13:54:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @giorgosgiapis created at 2019-07-09 14:01:11

I have added some tests for both methods to ensure they are working. As for memset, I don't think it will cause a problem. We can, however, initialize the array with a loop though I believe memset is a bit faster here.


---

Comment by dcoudert created at 2019-07-10 08:11:24

As `lex_BFS` is exposed in `Graph`, there is no need for this change

```diff
-        sage: Graph(1).lex_BFS(tree=True)
+        sage: from sage.graphs.traversals import lex_BFS
+        sage: lex_BFS(Graph(1), tree=True)
```

So you should use `G.lex_BFS()` and `G.lex_DFS()` in all doctests.

For the test with symmetric digraph, you can do:

```
G = Graph([(1, 2), (1, 3), (2, 3), (2, 4), (2, 5), (3, 5), (3, 6), (4, 5), (5, 6)])
D = DiGraph(G)
G.lex_BFS() == D.lex_DFS()
```



---

Comment by git created at 2019-07-10 14:44:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dcoudert created at 2019-07-12 07:27:58

LGTM.


---

Comment by dcoudert created at 2019-07-12 07:27:58

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2019-07-14 08:32:25

Resolution: fixed
