# Issue 27962: gcd can be very slow in AA[x]

archive/issues_027962.json:
```json
{
    "body": "CC:  @bgrenet @mezzarobba\n\nHere is a x50 slower example\n\n```\nsage: x,y = polygens(QQ,\"x,y\")\nsage: p1 = x^5 + 6*x^4 - 42*x^3 - 142*x^2 + 467*x + 422\nsage: p2 = p1(x=(x-1)^2)\nsage: p3 = p2(x=x*y).resultant(p2,x).univariate_polynomial()\nsage: p4, = [f[0] for f in p3.factor() if f[0].degree() == 80]\nsage: %time _ = p4.squarefree_decomposition()\nCPU times: user 807 \u00b5s, sys: 0 ns, total: 807 \u00b5s\nWall time: 883 \u00b5s\nsage: %time _ = p4.change_ring(AA).squarefree_decomposition()\nCPU times: user 40.1 s, sys: 3.21 ms, total: 40.1 s\nWall time: 40.1 s\n```\n\nThis problem originally appeared in #17895 (where a better workaround has been found).\n\nIssue created by migration from https://trac.sagemath.org/ticket/28199\n\n",
    "created_at": "2019-07-14T22:14:25Z",
    "labels": [
        "component: algebra",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "gcd can be very slow in AA[x]",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/27962",
    "user": "https://github.com/videlec"
}
```
CC:  @bgrenet @mezzarobba

Here is a x50 slower example

```
sage: x,y = polygens(QQ,"x,y")
sage: p1 = x^5 + 6*x^4 - 42*x^3 - 142*x^2 + 467*x + 422
sage: p2 = p1(x=(x-1)^2)
sage: p3 = p2(x=x*y).resultant(p2,x).univariate_polynomial()
sage: p4, = [f[0] for f in p3.factor() if f[0].degree() == 80]
sage: %time _ = p4.squarefree_decomposition()
CPU times: user 807 µs, sys: 0 ns, total: 807 µs
Wall time: 883 µs
sage: %time _ = p4.change_ring(AA).squarefree_decomposition()
CPU times: user 40.1 s, sys: 3.21 ms, total: 40.1 s
Wall time: 40.1 s
```

This problem originally appeared in #17895 (where a better workaround has been found).

Issue created by migration from https://trac.sagemath.org/ticket/28199





---

archive/issue_comments_394636.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2019-07-15T08:34:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27962",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27962#issuecomment-394636",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_394637.json:
```json
{
    "body": "I've made a very quick try: Instead of using the plain old Euclidean algorithm, one can use the so-called subresultant algorithm. This algorithm is already provided for UFDs so I tried to branch this algorithms for fields also. The resulting timings are still bad, but slightly less so:\n\n\n```python\nsage: x,y = polygens(QQ,\"x,y\")\nsage: p1 = x^5 + 6*x^4 - 42*x^3 - 142*x^2 + 467*x + 422\nsage: p2 = p1(x=(x-1)^2)\nsage: p3 = p2(x=x*y).resultant(p2,x).univariate_polynomial()\nsage: p4, = [f[0] for f in p3.factor() if f[0].degree() == 80]\nsage: %time _ = p4.squarefree_decomposition()\nCPU times: user 1.89 ms, sys: 0 ns, total: 1.89 ms\nWall time: 1.91 ms\nsage: %time _ = p4.change_ring(AA).squarefree_decomposition()\nCPU times: user 3.14 s, sys: 15.3 ms, total: 3.16 s\nWall time: 3.16 s\n```\n",
    "created_at": "2019-07-15T08:40:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27962",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27962#issuecomment-394637",
    "user": "https://github.com/bgrenet"
}
```

I've made a very quick try: Instead of using the plain old Euclidean algorithm, one can use the so-called subresultant algorithm. This algorithm is already provided for UFDs so I tried to branch this algorithms for fields also. The resulting timings are still bad, but slightly less so:


```python
sage: x,y = polygens(QQ,"x,y")
sage: p1 = x^5 + 6*x^4 - 42*x^3 - 142*x^2 + 467*x + 422
sage: p2 = p1(x=(x-1)^2)
sage: p3 = p2(x=x*y).resultant(p2,x).univariate_polynomial()
sage: p4, = [f[0] for f in p3.factor() if f[0].degree() == 80]
sage: %time _ = p4.squarefree_decomposition()
CPU times: user 1.89 ms, sys: 0 ns, total: 1.89 ms
Wall time: 1.91 ms
sage: %time _ = p4.change_ring(AA).squarefree_decomposition()
CPU times: user 3.14 s, sys: 15.3 ms, total: 3.16 s
Wall time: 3.16 s
```




---

archive/issue_comments_394638.json:
```json
{
    "body": "You were quick :-) This is great: 10x improvement! There is no hope to beat the C-implementation from flint anyway.\n\nDo you know why the subresultant is not the default method over fields? Could it be always better?  \n\nThis reminds me the problem for computing determinant of matrices with rational coefficients. Going via Gauss elimination (which is a sort of \"default\" for fields) will create a terrible coefficient blowup.",
    "created_at": "2019-07-15T09:14:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27962",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27962#issuecomment-394638",
    "user": "https://github.com/videlec"
}
```

You were quick :-) This is great: 10x improvement! There is no hope to beat the C-implementation from flint anyway.

Do you know why the subresultant is not the default method over fields? Could it be always better?  

This reminds me the problem for computing determinant of matrices with rational coefficients. Going via Gauss elimination (which is a sort of "default" for fields) will create a terrible coefficient blowup.



---

archive/issue_comments_394639.json:
```json
{
    "body": "Replying to [comment:4 vdelecroix]:\n> You were quick :-) This is great: 10x improvement! There is no hope to beat the C-implementation from flint anyway.\n\nOf course, but I would hope for less than a second...\n\n> \n> Do you know why the subresultant is not the default method over fields? Could it be always better?  \n\nThat's why my first try. The problem is that it requires a `_floordiv_` and not all fields have it. For instance:\n\n\n```python\nsage: R.<x> = RR[]\nsage: p = (x^2-1)^2\nsage: p.is_squarefree()\nTraceback (most recent call last):\n...\nTypeError: unsupported operand parent(s) for //: 'Real Field with 53 bits of precision' and 'Real Field with 53 bits of precision'\n```\n\n\nor \n\n\n```python\nsage: S.<y> = GF(5)[]\nsage: Q = S.quotient_ring(y^2+y+1)\nsage: T.<z> = Q[]\nsage: gcd(y*z+1, z + y)\nTraceback (most recent call last):\n...\nTypeError: unsupported operand parent(s) for //: 'Univariate Quotient Polynomial Ring in ybar over Finite Field of size 5 with modulus y^2 + y + 1' and 'Univariate Quotient Polynomial Ring in ybar over Finite Field of size 5 with modulus y^2 + y + 1'\n```\n\n\nOne possibility to check is whether adding a `_floordiv_` method that simply calls `self._div_(other)` in the `Fields` category is sufficient and yields better timings.",
    "created_at": "2019-07-15T10:05:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27962",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27962#issuecomment-394639",
    "user": "https://github.com/bgrenet"
}
```

Replying to [comment:4 vdelecroix]:
> You were quick :-) This is great: 10x improvement! There is no hope to beat the C-implementation from flint anyway.

Of course, but I would hope for less than a second...

> 
> Do you know why the subresultant is not the default method over fields? Could it be always better?  

That's why my first try. The problem is that it requires a `_floordiv_` and not all fields have it. For instance:


```python
sage: R.<x> = RR[]
sage: p = (x^2-1)^2
sage: p.is_squarefree()
Traceback (most recent call last):
...
TypeError: unsupported operand parent(s) for //: 'Real Field with 53 bits of precision' and 'Real Field with 53 bits of precision'
```


or 


```python
sage: S.<y> = GF(5)[]
sage: Q = S.quotient_ring(y^2+y+1)
sage: T.<z> = Q[]
sage: gcd(y*z+1, z + y)
Traceback (most recent call last):
...
TypeError: unsupported operand parent(s) for //: 'Univariate Quotient Polynomial Ring in ybar over Finite Field of size 5 with modulus y^2 + y + 1' and 'Univariate Quotient Polynomial Ring in ybar over Finite Field of size 5 with modulus y^2 + y + 1'
```


One possibility to check is whether adding a `_floordiv_` method that simply calls `self._div_(other)` in the `Fields` category is sufficient and yields better timings.



---

archive/issue_comments_394640.json:
```json
{
    "body": "Actually I checked: It is not faster in general (you can for instance test in the ring `T` of my example of the previous comment). This is reasonable: The only cases where it is faster is when there is coefficient growth. So there is a difficulty to decide when to use each algorithm. Maybe I should add a test as: `if not self.base_ring().is_finite()`. Note that in that case, `RR` would use subresultants while it is slightly slower. (But not that computing (non-approximate) gcds for polynomials over `RR` is mainly nonsense because of approximation issues.)",
    "created_at": "2019-07-15T10:31:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27962",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27962#issuecomment-394640",
    "user": "https://github.com/bgrenet"
}
```

Actually I checked: It is not faster in general (you can for instance test in the ring `T` of my example of the previous comment). This is reasonable: The only cases where it is faster is when there is coefficient growth. So there is a difficulty to decide when to use each algorithm. Maybe I should add a test as: `if not self.base_ring().is_finite()`. Note that in that case, `RR` would use subresultants while it is slightly slower. (But not that computing (non-approximate) gcds for polynomials over `RR` is mainly nonsense because of approximation issues.)



---

archive/issue_comments_394641.json:
```json
{
    "body": "I think that exact algorithm should raise an error with non-approximate base ring.",
    "created_at": "2019-07-15T12:07:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27962",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27962#issuecomment-394641",
    "user": "https://github.com/videlec"
}
```

I think that exact algorithm should raise an error with non-approximate base ring.



---

archive/issue_comments_394642.json:
```json
{
    "body": "Ticket retargeted after milestone closed",
    "created_at": "2019-12-30T14:48:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27962",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27962#issuecomment-394642",
    "user": "https://github.com/embray"
}
```

Ticket retargeted after milestone closed



---

archive/issue_comments_394643.json:
```json
{
    "body": "Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.",
    "created_at": "2020-04-14T19:41:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27962",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27962#issuecomment-394643",
    "user": "https://github.com/mkoeppe"
}
```

Batch modifying tickets that will likely not be ready for 9.1, based on a review of the ticket title, branch/review status, and last modification date.



---

archive/issue_comments_394644.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/27962",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/27962#issuecomment-394644",
    "user": "https://github.com/mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
