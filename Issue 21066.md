# Issue 21066: Make hecke operators not blow up the memory

archive/issues_021066.json:
```json
{
    "body": "CC:  cremona kedlaya\n\nKeywords: eclib, modular symbols, hecke operators\n\nConstructing Hecke operators acting on modular symbols can blow up the memory usage, though it doesn't have to. In Cremona's code, there's a function calcop which covers the main computation:\n\n\n```\n  mat m(rk,rk);\n  for (long j=0; j<rk; j++) if (needed[j])\n     { svec colj = applyop(mlist,freemods[j]);\n       m.setcol(j+1,colj.as_vec());\n     }\n  if(cuspidal) m = restrict_mat(smat(m),kern).as_mat();\n```\n\n\nNote that this code correctly the columns as sparse vectors, but then inserts them into a dense matrix: then, if the form is cuspidal, it actually converts it to a sparse matrix, does the restriction, and converts it back to a dense matrix. \n\nRecommendation: have this (or another, similarly named function) do this entirely with sparse matrices, so that the memory stays minimal\n\nIssue created by migration from https://trac.sagemath.org/ticket/21303\n\n",
    "created_at": "2016-08-22T03:08:03Z",
    "labels": [
        "modular forms",
        "major",
        "bug"
    ],
    "title": "Make hecke operators not blow up the memory",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/21066",
    "user": "kartikv"
}
```
CC:  cremona kedlaya

Keywords: eclib, modular symbols, hecke operators

Constructing Hecke operators acting on modular symbols can blow up the memory usage, though it doesn't have to. In Cremona's code, there's a function calcop which covers the main computation:


```
  mat m(rk,rk);
  for (long j=0; j<rk; j++) if (needed[j])
     { svec colj = applyop(mlist,freemods[j]);
       m.setcol(j+1,colj.as_vec());
     }
  if(cuspidal) m = restrict_mat(smat(m),kern).as_mat();
```


Note that this code correctly the columns as sparse vectors, but then inserts them into a dense matrix: then, if the form is cuspidal, it actually converts it to a sparse matrix, does the restriction, and converts it back to a dense matrix. 

Recommendation: have this (or another, similarly named function) do this entirely with sparse matrices, so that the memory stays minimal

Issue created by migration from https://trac.sagemath.org/ticket/21303





---

archive/issue_comments_291850.json:
```json
{
    "body": "The `sage_matrix_over_ZZ` method of internal `Matrix` class in the `eclib` wrapper does have a flag `sparse` (defaults to `False`), but at this point it is too late; the Hecke matrix was already created as an eclib dense matrix (i.e., a C++ array of `long`'s). If I understand correctly, what is really needed is a flag in the `hecke_matrix` method that gets passed to `eclib`, so that the underlying C++ code switches correctly.",
    "created_at": "2016-08-22T21:30:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291850",
    "user": "kedlaya"
}
```

The `sage_matrix_over_ZZ` method of internal `Matrix` class in the `eclib` wrapper does have a flag `sparse` (defaults to `False`), but at this point it is too late; the Hecke matrix was already created as an eclib dense matrix (i.e., a C++ array of `long`'s). If I understand correctly, what is really needed is a flag in the `hecke_matrix` method that gets passed to `eclib`, so that the underlying C++ code switches correctly.



---

archive/issue_comments_291851.json:
```json
{
    "body": "You will also need to write a cython function to convert an eclib sparse matrix to a Sage one.  William and I did this for dense matrices in about 2008.\nThe eclib sparese matrix class is written at rather a low level for efficiency with arrays of pointers etc.  Ask me if it is not clear how to extract the information from one.\n\nThe output function at lne 729 of https://github.com/JohnCremona/eclib/blob/master/libsrc/smat.cc might help; also the associated header file.  I suggest that you loop through all the rows and for each one fetch all the (column, value) pairs.  One thing to watch out for:  if a row contains n nonzero entries then the 0'th entry in the associated col array stores n so that array has size n+1 while the values array has size n.  Row and column numbers start from 1 not 0.  Good luck.",
    "created_at": "2016-08-23T08:57:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291851",
    "user": "cremona"
}
```

You will also need to write a cython function to convert an eclib sparse matrix to a Sage one.  William and I did this for dense matrices in about 2008.
The eclib sparese matrix class is written at rather a low level for efficiency with arrays of pointers etc.  Ask me if it is not clear how to extract the information from one.

The output function at lne 729 of https://github.com/JohnCremona/eclib/blob/master/libsrc/smat.cc might help; also the associated header file.  I suggest that you loop through all the rows and for each one fetch all the (column, value) pairs.  One thing to watch out for:  if a row contains n nonzero entries then the 0'th entry in the associated col array stores n so that array has size n+1 while the values array has size n.  Row and column numbers start from 1 not 0.  Good luck.



---

archive/issue_comments_291852.json:
```json
{
    "body": "I got a rather crude version of this up and running, so here's a patch. The crude part is that I ask `eclib` for dense vectors one at a time, rather than asking for a whole sparse matrix; but this was easier to wrap (I didn't need to tamper with the include files to expose any functionality) and already avoids an obvious quadratic memory step. \n\nI tried this out on my usual compute server:\n\n```\nsage: time C = CremonaModularSymbols(400001, sign=-1)\nCPU times: user 26.6 s, sys: 119 ms, total: 26.7 s\nWall time: 26.7 s\nsage: time T2a = C.hecke_matrix(2)\nCPU times: user 17.7 s, sys: 4.9 s, total: 22.6 s\nWall time: 22.6 s\nsage: time T2b = T2a.sage_matrix_over_ZZ(sparse=True)\nCPU times: user 26.2 s, sys: 83 ms, total: 26.2 s\nWall time: 26.3 s\nsage: del T2a\nsage: time T2c = C.sparse_hecke_matrix(2)\nCPU times: user 1min 10s, sys: 548 ms, total: 1min 11s\nWall time: 1min 11s\nsage: time T2b == T2c # True but not instant for sparse matrices\nCPU times: user 11 s, sys: 650 ms, total: 11.7 s\nWall time: 11.7 s\nTrue\n```\n\nThe regression (48.9s to 71.7s) is annoying; the bottleneck is the line\n\n```\n        ans = M(entries=d)\n```\n\nwhere `M` is the matrix space of sparse matrices and `d` is the dict mapping coordinate pairs to matrix entries. I had the thought that the matrix constructor must be copying the dict (as is necessary generically) even though in this case it's not required, but I don't think that's the issue:\n\n```\nsage: time dd = copy(d) #too short\nCPU times: user 960 ms, sys: 73 ms, total: 1.03 s\nWall time: 1.03 s\nsage: time dd = deepcopy(d) #too long\nCPU times: user 2min 21s, sys: 1.7 s, total: 2min 23s\nWall time: 2min 23s\n```\n\nOn the memory side (crudely measured by watching `top`), the computation of `T2b` via `T2a` peaks at 5.9g whereas the computation of `T2c` peaks at 1.6g, so at least that went according to plan.\n\nAnd in my intended use case I work modulo some prime, and this is a big win:\n\n```\nsage: time T2d = C.sparse_hecke_matrix(2, base_ring=GF(2))\nCPU times: user 15.3 s, sys: 317 ms, total: 15.7 s\nWall time: 15.7 s\nsage: time T2e = C.sparse_hecke_matrix(2, base_ring=GF(next_prime(2^30)))\nCPU times: user 24.3 s, sys: 607 ms, total: 25 s\nWall time: 25 s\n}\n```\n\nso I'm taken care of.\n----\nNew commits:",
    "created_at": "2016-08-25T01:44:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291852",
    "user": "kedlaya"
}
```

I got a rather crude version of this up and running, so here's a patch. The crude part is that I ask `eclib` for dense vectors one at a time, rather than asking for a whole sparse matrix; but this was easier to wrap (I didn't need to tamper with the include files to expose any functionality) and already avoids an obvious quadratic memory step. 

I tried this out on my usual compute server:

```
sage: time C = CremonaModularSymbols(400001, sign=-1)
CPU times: user 26.6 s, sys: 119 ms, total: 26.7 s
Wall time: 26.7 s
sage: time T2a = C.hecke_matrix(2)
CPU times: user 17.7 s, sys: 4.9 s, total: 22.6 s
Wall time: 22.6 s
sage: time T2b = T2a.sage_matrix_over_ZZ(sparse=True)
CPU times: user 26.2 s, sys: 83 ms, total: 26.2 s
Wall time: 26.3 s
sage: del T2a
sage: time T2c = C.sparse_hecke_matrix(2)
CPU times: user 1min 10s, sys: 548 ms, total: 1min 11s
Wall time: 1min 11s
sage: time T2b == T2c # True but not instant for sparse matrices
CPU times: user 11 s, sys: 650 ms, total: 11.7 s
Wall time: 11.7 s
True
```

The regression (48.9s to 71.7s) is annoying; the bottleneck is the line

```
        ans = M(entries=d)
```

where `M` is the matrix space of sparse matrices and `d` is the dict mapping coordinate pairs to matrix entries. I had the thought that the matrix constructor must be copying the dict (as is necessary generically) even though in this case it's not required, but I don't think that's the issue:

```
sage: time dd = copy(d) #too short
CPU times: user 960 ms, sys: 73 ms, total: 1.03 s
Wall time: 1.03 s
sage: time dd = deepcopy(d) #too long
CPU times: user 2min 21s, sys: 1.7 s, total: 2min 23s
Wall time: 2min 23s
```

On the memory side (crudely measured by watching `top`), the computation of `T2b` via `T2a` peaks at 5.9g whereas the computation of `T2c` peaks at 1.6g, so at least that went according to plan.

And in my intended use case I work modulo some prime, and this is a big win:

```
sage: time T2d = C.sparse_hecke_matrix(2, base_ring=GF(2))
CPU times: user 15.3 s, sys: 317 ms, total: 15.7 s
Wall time: 15.7 s
sage: time T2e = C.sparse_hecke_matrix(2, base_ring=GF(next_prime(2^30)))
CPU times: user 24.3 s, sys: 607 ms, total: 25 s
Wall time: 25 s
}
```

so I'm taken care of.
----
New commits:



---

archive/issue_comments_291853.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2016-08-25T01:44:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291853",
    "user": "kedlaya"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_291854.json:
```json
{
    "body": "I should add that I have been running this code since I posted it and am observing a memory leak somewhere. Specifically, I've been running this code snippet (for various values of `i`):\n\n```\ndef zero_eigenvalue_multiplicity(m): #taken from trac #20788\n    n = 0\n    m1 = m\n    r = m.dimensions()[0]\n    while True:\n        m2 = m1.extended_echelon_form(subdivide=True)\n        t = r - m2.subdivisions()[0][0]\n        n += t\n        if t == 0 or t == r: return n\n        m3 = m2.subdivision(0,0)\n        m4 = m2.submatrix(0,r,r,r)\n        m5 = m3 * m4.inverse()\n        m1 = m5.submatrix(0,0,r-t,r-t)\n        r -= t\n\nfor n in range((i-5)*1000+1, i*1000, 2):\n    C = CremonaModularSymbols(n, cuspidal=True, sign=-1)\n    T2 = C.sparse_hecke_matrix(2, base_ring=GF(2)).dense_matrix()\n    t = (n, zero_eigenvalue_multiplicity(T2), zero_eigenvalue_multiplicity(T2+1))\n```\n\nand observing (via `top`) memory usage growing from 200-300mb for the initial stages to over 10gb later in the loop. My guess is that there is no serious memory leak in `eclib`, and I wouldn't suspect one in `m4ri` either; but I'm having trouble coming up with other options, and I'm not up to speed with `valgrind` enough to try checking that way.",
    "created_at": "2016-08-26T02:50:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291854",
    "user": "kedlaya"
}
```

I should add that I have been running this code since I posted it and am observing a memory leak somewhere. Specifically, I've been running this code snippet (for various values of `i`):

```
def zero_eigenvalue_multiplicity(m): #taken from trac #20788
    n = 0
    m1 = m
    r = m.dimensions()[0]
    while True:
        m2 = m1.extended_echelon_form(subdivide=True)
        t = r - m2.subdivisions()[0][0]
        n += t
        if t == 0 or t == r: return n
        m3 = m2.subdivision(0,0)
        m4 = m2.submatrix(0,r,r,r)
        m5 = m3 * m4.inverse()
        m1 = m5.submatrix(0,0,r-t,r-t)
        r -= t

for n in range((i-5)*1000+1, i*1000, 2):
    C = CremonaModularSymbols(n, cuspidal=True, sign=-1)
    T2 = C.sparse_hecke_matrix(2, base_ring=GF(2)).dense_matrix()
    t = (n, zero_eigenvalue_multiplicity(T2), zero_eigenvalue_multiplicity(T2+1))
```

and observing (via `top`) memory usage growing from 200-300mb for the initial stages to over 10gb later in the loop. My guess is that there is no serious memory leak in `eclib`, and I wouldn't suspect one in `m4ri` either; but I'm having trouble coming up with other options, and I'm not up to speed with `valgrind` enough to try checking that way.



---

archive/issue_comments_291855.json:
```json
{
    "body": "When eclib was first put into Sage back in about 2007 it was subjected to rigorous valgrinding by Michael Abshoff, which revealed several issues which were then fixed (with some effort!).  But there has been considerable change since then, so I should do that again.\n\nI have made this an Issue for eclib: https://github.com/JohnCremona/eclib/issues/18",
    "created_at": "2016-08-26T08:10:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291855",
    "user": "cremona"
}
```

When eclib was first put into Sage back in about 2007 it was subjected to rigorous valgrinding by Michael Abshoff, which revealed several issues which were then fixed (with some effort!).  But there has been considerable change since then, so I should do that again.

I have made this an Issue for eclib: https://github.com/JohnCremona/eclib/issues/18



---

archive/issue_comments_291856.json:
```json
{
    "body": "Update: I can reproduce the memory leak behavior by simply repeating the code from #20788 (as reported therein). That is not to say that running valgrind again on `eclib` wouldn't be advisable, but I am not specifically claiming a memory leak in the computation of Hecke matrices (though if you do find one, it would certainly help me for it to be fixed).",
    "created_at": "2016-08-29T04:50:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291856",
    "user": "kedlaya"
}
```

Update: I can reproduce the memory leak behavior by simply repeating the code from #20788 (as reported therein). That is not to say that running valgrind again on `eclib` wouldn't be advisable, but I am not specifically claiming a memory leak in the computation of Hecke matrices (though if you do find one, it would certainly help me for it to be fixed).



---

archive/issue_comments_291857.json:
```json
{
    "body": "Oh, now this is bad news.\n\n```\nsage: C = CremonaModularSymbols(45, cuspidal=True,sign=-1)\nsage: T2a = C.hecke_matrix(2).sage_matrix_over_ZZ()\nsage: print T2a\n[-1 -1 -1]\n[ 0  1  2]\n[ 0  0 -1] \nsage: T2b = C.sparse_hecke_matrix(2)\nsage: print T2b\n[-1 -1  0]\n[ 0  1  2]\n[ 0  0 -3]\n```\n\nThis is only an issue when `cuspidal=True`: the `eclib` function `heckeop` takes the projection onto the cuspidal subspace into account but `heckeop_col` does not. \n\nIt looks like `s_heckeop` does account for the cuspidal projection, so switching to that should fix this problem.",
    "created_at": "2016-08-30T08:25:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291857",
    "user": "kedlaya"
}
```

Oh, now this is bad news.

```
sage: C = CremonaModularSymbols(45, cuspidal=True,sign=-1)
sage: T2a = C.hecke_matrix(2).sage_matrix_over_ZZ()
sage: print T2a
[-1 -1 -1]
[ 0  1  2]
[ 0  0 -1] 
sage: T2b = C.sparse_hecke_matrix(2)
sage: print T2b
[-1 -1  0]
[ 0  1  2]
[ 0  0 -3]
```

This is only an issue when `cuspidal=True`: the `eclib` function `heckeop` takes the projection onto the cuspidal subspace into account but `heckeop_col` does not. 

It looks like `s_heckeop` does account for the cuspidal projection, so switching to that should fix this problem.



---

archive/issue_comments_291858.json:
```json
{
    "body": "Apologies for the inconsistencies.  There must be quite a few methods in this homspace class which are no longer used in the main programs and whose implementations have therefore not been kept consistent or tested.  Unlike Sage where every single method has its own test, I just have high-level test programs and there must be a lot of code which is no longer tested, thought of by me as obsolete but not actually deleted.  The number of people who have looked at this code in any detail is very small!",
    "created_at": "2016-08-30T08:49:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291858",
    "user": "cremona"
}
```

Apologies for the inconsistencies.  There must be quite a few methods in this homspace class which are no longer used in the main programs and whose implementations have therefore not been kept consistent or tested.  Unlike Sage where every single method has its own test, I just have high-level test programs and there must be a lot of code which is no longer tested, thought of by me as obsolete but not actually deleted.  The number of people who have looked at this code in any detail is very small!



---

archive/issue_comments_291859.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2016-08-30T21:31:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291859",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_291860.json:
```json
{
    "body": "I went ahead and switched over to `s_heckeop` and this indeed resolves the issue. I am still doing the silly thing of converting a sparse vector into a dense vector before transferring it into Python; that's because I'm not familiar enough with the C++-Python interaction to know how to correctly wrap the functions that provide direct access to the underlying dict-like structure of a sparse vector.\n\nTimings are similar, but now on a completely unloaded machine, so more indicative than before:\n\n```\nsage: sage: time C = CremonaModularSymbols(400001, sign=-1)\nCPU times: user 25.4 s, sys: 95 ms, total: 25.5 s\nWall time: 25.5 s\nsage: time T2a = C.hecke_matrix(2)\nCPU times: user 13.7 s, sys: 4.08 s, total: 17.8 s\nWall time: 17.8 s\nsage: time T2b = T2a.sage_matrix_over_ZZ(sparse=True)\nCPU times: user 25 s, sys: 59 ms, total: 25.1 s\nWall time: 25.1 s\nsage: time T2c = C.sparse_hecke_matrix(2)\nCPU times: user 1min 2s, sys: 476 ms, total: 1min 3s\nWall time: 1min 3s\nsage: time T2b == T2c\nCPU times: user 9.48 s, sys: 633 ms, total: 10.1 s\nWall time: 10.1 s\nTrue\nsage: time T2c = C.sparse_hecke_matrix(2, base_ring=GF(2))\nCPU times: user 17.4 s, sys: 328 ms, total: 17.7 s\nWall time: 17.7 s\n```\n",
    "created_at": "2016-08-30T21:34:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291860",
    "user": "kedlaya"
}
```

I went ahead and switched over to `s_heckeop` and this indeed resolves the issue. I am still doing the silly thing of converting a sparse vector into a dense vector before transferring it into Python; that's because I'm not familiar enough with the C++-Python interaction to know how to correctly wrap the functions that provide direct access to the underlying dict-like structure of a sparse vector.

Timings are similar, but now on a completely unloaded machine, so more indicative than before:

```
sage: sage: time C = CremonaModularSymbols(400001, sign=-1)
CPU times: user 25.4 s, sys: 95 ms, total: 25.5 s
Wall time: 25.5 s
sage: time T2a = C.hecke_matrix(2)
CPU times: user 13.7 s, sys: 4.08 s, total: 17.8 s
Wall time: 17.8 s
sage: time T2b = T2a.sage_matrix_over_ZZ(sparse=True)
CPU times: user 25 s, sys: 59 ms, total: 25.1 s
Wall time: 25.1 s
sage: time T2c = C.sparse_hecke_matrix(2)
CPU times: user 1min 2s, sys: 476 ms, total: 1min 3s
Wall time: 1min 3s
sage: time T2b == T2c
CPU times: user 9.48 s, sys: 633 ms, total: 10.1 s
Wall time: 10.1 s
True
sage: time T2c = C.sparse_hecke_matrix(2, base_ring=GF(2))
CPU times: user 17.4 s, sys: 328 ms, total: 17.7 s
Wall time: 17.7 s
```




---

archive/issue_comments_291861.json:
```json
{
    "body": "Note to myself: check to see whether the resolution of #22164 has had any effect on the memory leak reported above.",
    "created_at": "2017-10-02T04:30:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291861",
    "user": "kedlaya"
}
```

Note to myself: check to see whether the resolution of #22164 has had any effect on the memory leak reported above.



---

archive/issue_comments_291862.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-04T06:09:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291862",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_291863.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-10-04T13:00:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291863",
    "user": "jdemeyer"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_291864.json:
```json
{
    "body": "This syntax is deprecated and shouldn't be used anymore:\n\n```\nfor j from 1 <= j <= n:\n```\n\nCython will generate efficient code for `range()` if the variables are of some C type (which is the case here since you declared `cdef long j`).",
    "created_at": "2017-10-04T13:00:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291864",
    "user": "jdemeyer"
}
```

This syntax is deprecated and shouldn't be used anymore:

```
for j from 1 <= j <= n:
```

Cython will generate efficient code for `range()` if the variables are of some C type (which is the case here since you declared `cdef long j`).



---

archive/issue_comments_291865.json:
```json
{
    "body": "You should not put Python code inside `sig_on()`/`sig_off()` blocks.\n\nThere are two (not mutually exclusive) cases:\n\n(A) If there is any particular non-Python statement that takes a long time or might generate signals, put `sig_on()`/`sig_off()` around that particular statement.\n\n(B) If you just want to interrupt the loop, put `sig_check()` inside that loop.",
    "created_at": "2017-10-04T13:04:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291865",
    "user": "jdemeyer"
}
```

You should not put Python code inside `sig_on()`/`sig_off()` blocks.

There are two (not mutually exclusive) cases:

(A) If there is any particular non-Python statement that takes a long time or might generate signals, put `sig_on()`/`sig_off()` around that particular statement.

(B) If you just want to interrupt the loop, put `sig_check()` inside that loop.



---

archive/issue_comments_291866.json:
```json
{
    "body": "In the `eclib.pxd` file, you have a duplicate\n\n```\nctypedef int scalar\n```\n\n\nIt should be declared just once.",
    "created_at": "2017-10-04T13:06:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291866",
    "user": "jdemeyer"
}
```

In the `eclib.pxd` file, you have a duplicate

```
ctypedef int scalar
```


It should be declared just once.



---

archive/issue_comments_291867.json:
```json
{
    "body": "(NOTE: I just checked the Cython programming issues, I didn't actually try to understand the code; I assume that John can do that)",
    "created_at": "2017-10-04T13:08:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291867",
    "user": "jdemeyer"
}
```

(NOTE: I just checked the Cython programming issues, I didn't actually try to understand the code; I assume that John can do that)



---

archive/issue_comments_291868.json:
```json
{
    "body": "I looked at the code.  Congratulations for being the first person in history other than me and Luis Figueiredo (a student of Taylor in the 1990s) to read my sparse vector / matrix code!\n\nWhat you do is go through the rows, extract the i'th row as a sparse vector, convert it to a dense vector, and then go through its entries storing the nonzero ones in the new Sage sparse matrix.  This is inefficient as you look at all m*n netries (if the matrix is mxn).  It would be better to extract just the nonzero entries in the first place.  I can try to write that, or help someone else, but before  do I need to know if Cython will have access to the \"protected\" (in C++ terms) i.e. semi-private data components of the C++ sparse matrix.  If so I can write the necessary lines.",
    "created_at": "2017-10-04T14:49:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291868",
    "user": "cremona"
}
```

I looked at the code.  Congratulations for being the first person in history other than me and Luis Figueiredo (a student of Taylor in the 1990s) to read my sparse vector / matrix code!

What you do is go through the rows, extract the i'th row as a sparse vector, convert it to a dense vector, and then go through its entries storing the nonzero ones in the new Sage sparse matrix.  This is inefficient as you look at all m*n netries (if the matrix is mxn).  It would be better to extract just the nonzero entries in the first place.  I can try to write that, or help someone else, but before  do I need to know if Cython will have access to the "protected" (in C++ terms) i.e. semi-private data components of the C++ sparse matrix.  If so I can write the necessary lines.



---

archive/issue_comments_291869.json:
```json
{
    "body": "Replying to [comment:19 cremona]:\n> I need to know if Cython will have access to the \"protected\" (in C++ terms) i.e. semi-private data components of the C++ sparse matrix.  If so I can write the necessary lines.\n\nCython essentially just generates C or C++ code. So it won't have any more access than user-written C++ code. So that means that it cannot access arbitrary protected members.",
    "created_at": "2017-10-04T15:23:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291869",
    "user": "jdemeyer"
}
```

Replying to [comment:19 cremona]:
> I need to know if Cython will have access to the "protected" (in C++ terms) i.e. semi-private data components of the C++ sparse matrix.  If so I can write the necessary lines.

Cython essentially just generates C or C++ code. So it won't have any more access than user-written C++ code. So that means that it cannot access arbitrary protected members.



---

archive/issue_comments_291870.json:
```json
{
    "body": "That makes it harder.  The thing is an array of \"rows\" (one for each actual row even if the row is zero).  We know how many from M.nrows().  For the i'th row we store the number of nonzero entries, the list of columns they are in and the list of the entries.  The only difficulty is in getting the 0/1 rebasing correct since C, like Python goes from 0 bu my user interface goes from 1...\n\nI can see that to provide the interface needed will require adding to eclib.  Sorry.  Meanwhile it would still be simpler to extract just the nonzero entries from the sparse vector which we already extract for each row.  But even that requires access to protected members of the svec class (which are essentially dicts containing (index, netry) pairs).  So that leaves this:\n\n\n```\n        for i in range(n):\n            for j in range(n):\n                Mij = M.elem(i+1,j+1)\n                if Mij:\n                    d[(i, j)] = Mij\n```\n\n\nI don't expect that to be any better than the current version though since for each i,j the elem() method will do a linear search along the i'th row to see if the j'th entry is present.\n\nSorry not to have a low-level interface!",
    "created_at": "2017-10-04T15:38:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291870",
    "user": "cremona"
}
```

That makes it harder.  The thing is an array of "rows" (one for each actual row even if the row is zero).  We know how many from M.nrows().  For the i'th row we store the number of nonzero entries, the list of columns they are in and the list of the entries.  The only difficulty is in getting the 0/1 rebasing correct since C, like Python goes from 0 bu my user interface goes from 1...

I can see that to provide the interface needed will require adding to eclib.  Sorry.  Meanwhile it would still be simpler to extract just the nonzero entries from the sparse vector which we already extract for each row.  But even that requires access to protected members of the svec class (which are essentially dicts containing (index, netry) pairs).  So that leaves this:


```
        for i in range(n):
            for j in range(n):
                Mij = M.elem(i+1,j+1)
                if Mij:
                    d[(i, j)] = Mij
```


I don't expect that to be any better than the current version though since for each i,j the elem() method will do a linear search along the i'th row to see if the j'th entry is present.

Sorry not to have a low-level interface!



---

archive/issue_comments_291871.json:
```json
{
    "body": "A possible low-level interface could work like a Python iterator delivering triple (i,j,M[i,j]) with some signal at the end such as (0,0,0).  Without doing a lot of work that could easily be provided as a single 3xN matrix where N is one more than the number of nonzero entries.  Then the user can loop over that.  But such a change to eclib is for the future, and should not delay this.",
    "created_at": "2017-10-04T15:42:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291871",
    "user": "cremona"
}
```

A possible low-level interface could work like a Python iterator delivering triple (i,j,M[i,j]) with some signal at the end such as (0,0,0).  Without doing a lot of work that could easily be provided as a single 3xN matrix where N is one more than the number of nonzero entries.  Then the user can loop over that.  But such a change to eclib is for the future, and should not delay this.



---

archive/issue_comments_291872.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-05T03:40:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291872",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_291873.json:
```json
{
    "body": "I fixed the Cython issues (I think). \n\nThat said, `svec.h` does appear to include some access functions:\n\n```\n  // functions to enable iteration over the entries without direct\n  // access to the entries map:\n  map<int,scalar>::const_iterator begin() const {return entries.begin();}\n  map<int,scalar>::const_iterator end() const {return entries.end();}\n  map<int,scalar>::iterator begin() {return entries.begin();}\n  map<int,scalar>::iterator end() {return entries.end();}\n  void erase(int i);  // erases v[i]; error if not set\n  int first_index() const {return entries.upper_bound(0)->first;}\n  std::set<int> support() const;\n```\n\nthat should avoid creating a dense vector; but I need to learn a bit more about Cython to figure out how to exploit those.",
    "created_at": "2017-10-05T04:48:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291873",
    "user": "kedlaya"
}
```

I fixed the Cython issues (I think). 

That said, `svec.h` does appear to include some access functions:

```
  // functions to enable iteration over the entries without direct
  // access to the entries map:
  map<int,scalar>::const_iterator begin() const {return entries.begin();}
  map<int,scalar>::const_iterator end() const {return entries.end();}
  map<int,scalar>::iterator begin() {return entries.begin();}
  map<int,scalar>::iterator end() {return entries.end();}
  void erase(int i);  // erases v[i]; error if not set
  int first_index() const {return entries.upper_bound(0)->first;}
  std::set<int> support() const;
```

that should avoid creating a dense vector; but I need to learn a bit more about Cython to figure out how to exploit those.



---

archive/issue_comments_291874.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-10-05T04:48:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291874",
    "user": "kedlaya"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_291875.json:
```json
{
    "body": "Replying to [comment:24 kedlaya]:\n> I need to learn a bit more about Cython to figure out how to exploit those.\n\nCython does support that (I'm assuming that `map` means `std::map`):\n\n```\nfrom libcpp.map cimport map\n\ncdef extern from \"...\":\n    cdef cppclass ...:\n        map[int, scalar].iterator begin()\n        map[int, scalar].iterator end()\n```\n",
    "created_at": "2017-10-05T08:20:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291875",
    "user": "jdemeyer"
}
```

Replying to [comment:24 kedlaya]:
> I need to learn a bit more about Cython to figure out how to exploit those.

Cython does support that (I'm assuming that `map` means `std::map`):

```
from libcpp.map cimport map

cdef extern from "...":
    cdef cppclass ...:
        map[int, scalar].iterator begin()
        map[int, scalar].iterator end()
```




---

archive/issue_comments_291876.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-05T15:27:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291876",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_291877.json:
```json
{
    "body": "I tried to use the iterator following a model in the Cython documentation, but...:\n\n```\n[sagelib-8.1.beta6] ...\n[sagelib-8.1.beta6]         cdef smat M = self.H.s_heckeop(p, dual, verbose)\n[sagelib-8.1.beta6]         sig_off()\n[sagelib-8.1.beta6]         for i in range(n):\n[sagelib-8.1.beta6]             sv = M.row(i+1)\n[sagelib-8.1.beta6]             iter = sv.begin()\n[sagelib-8.1.beta6]             while iter != sv.end():\n[sagelib-8.1.beta6]                       ^\n[sagelib-8.1.beta6] ------------------------------------------------------------\n[sagelib-8.1.beta6]\n[sagelib-8.1.beta6] sage/libs/eclib/homspace.pyx:284:23: Invalid types for '!=' (<error>, iterator)\n```\n",
    "created_at": "2017-10-05T15:30:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291877",
    "user": "kedlaya"
}
```

I tried to use the iterator following a model in the Cython documentation, but...:

```
[sagelib-8.1.beta6] ...
[sagelib-8.1.beta6]         cdef smat M = self.H.s_heckeop(p, dual, verbose)
[sagelib-8.1.beta6]         sig_off()
[sagelib-8.1.beta6]         for i in range(n):
[sagelib-8.1.beta6]             sv = M.row(i+1)
[sagelib-8.1.beta6]             iter = sv.begin()
[sagelib-8.1.beta6]             while iter != sv.end():
[sagelib-8.1.beta6]                       ^
[sagelib-8.1.beta6] ------------------------------------------------------------
[sagelib-8.1.beta6]
[sagelib-8.1.beta6] sage/libs/eclib/homspace.pyx:284:23: Invalid types for '!=' (<error>, iterator)
```




---

archive/issue_comments_291878.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2017-10-05T15:30:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291878",
    "user": "kedlaya"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_291879.json:
```json
{
    "body": "Next time, please quote the **complete** error message:\n\n```\n[sagelib-8.1.beta7] Error compiling Cython file:\n[sagelib-8.1.beta7] ------------------------------------------------------------\n[sagelib-8.1.beta7] ...\n[sagelib-8.1.beta7]         cdef long n = self.dimension()\n[sagelib-8.1.beta7]         cdef long i=0\n[sagelib-8.1.beta7]         cdef long j=0\n[sagelib-8.1.beta7]         cdef vec v\n[sagelib-8.1.beta7]         cdef svec sv\n[sagelib-8.1.beta7]         cdef map[int, scalar].iterator iter\n[sagelib-8.1.beta7]             ^\n[sagelib-8.1.beta7] ------------------------------------------------------------\n[sagelib-8.1.beta7] \n[sagelib-8.1.beta7] sage/libs/eclib/homspace.pyx:276:13: 'map' is not a type identifier\n[sagelib-8.1.beta7] \n[sagelib-8.1.beta7] Error compiling Cython file:\n[sagelib-8.1.beta7] ------------------------------------------------------------\n[sagelib-8.1.beta7] ...\n[sagelib-8.1.beta7]         cdef smat M = self.H.s_heckeop(p, dual, verbose)\n[sagelib-8.1.beta7]         sig_off()\n[sagelib-8.1.beta7]         for i in range(n):\n[sagelib-8.1.beta7]             sv = M.row(i+1)\n[sagelib-8.1.beta7]             iter = sv.begin()\n[sagelib-8.1.beta7]             while iter != sv.end():\n[sagelib-8.1.beta7]                       ^\n[sagelib-8.1.beta7] ------------------------------------------------------------\n[sagelib-8.1.beta7] \n[sagelib-8.1.beta7] sage/libs/eclib/homspace.pyx:284:23: Invalid types for '!=' (<error>, iterator)\n```\n\n\nYou forgot `from libcpp.map cimport map`",
    "created_at": "2017-10-06T12:09:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291879",
    "user": "jdemeyer"
}
```

Next time, please quote the **complete** error message:

```
[sagelib-8.1.beta7] Error compiling Cython file:
[sagelib-8.1.beta7] ------------------------------------------------------------
[sagelib-8.1.beta7] ...
[sagelib-8.1.beta7]         cdef long n = self.dimension()
[sagelib-8.1.beta7]         cdef long i=0
[sagelib-8.1.beta7]         cdef long j=0
[sagelib-8.1.beta7]         cdef vec v
[sagelib-8.1.beta7]         cdef svec sv
[sagelib-8.1.beta7]         cdef map[int, scalar].iterator iter
[sagelib-8.1.beta7]             ^
[sagelib-8.1.beta7] ------------------------------------------------------------
[sagelib-8.1.beta7] 
[sagelib-8.1.beta7] sage/libs/eclib/homspace.pyx:276:13: 'map' is not a type identifier
[sagelib-8.1.beta7] 
[sagelib-8.1.beta7] Error compiling Cython file:
[sagelib-8.1.beta7] ------------------------------------------------------------
[sagelib-8.1.beta7] ...
[sagelib-8.1.beta7]         cdef smat M = self.H.s_heckeop(p, dual, verbose)
[sagelib-8.1.beta7]         sig_off()
[sagelib-8.1.beta7]         for i in range(n):
[sagelib-8.1.beta7]             sv = M.row(i+1)
[sagelib-8.1.beta7]             iter = sv.begin()
[sagelib-8.1.beta7]             while iter != sv.end():
[sagelib-8.1.beta7]                       ^
[sagelib-8.1.beta7] ------------------------------------------------------------
[sagelib-8.1.beta7] 
[sagelib-8.1.beta7] sage/libs/eclib/homspace.pyx:284:23: Invalid types for '!=' (<error>, iterator)
```


You forgot `from libcpp.map cimport map`



---

archive/issue_comments_291880.json:
```json
{
    "body": "In fact, Cython does type inference, so you could also just remove the line\n\n```\ncdef map[int, scalar].iterator iter\n```\n",
    "created_at": "2017-10-06T12:12:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291880",
    "user": "jdemeyer"
}
```

In fact, Cython does type inference, so you could also just remove the line

```
cdef map[int, scalar].iterator iter
```




---

archive/issue_comments_291881.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2017-10-06T20:10:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291881",
    "user": "git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_291882.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2017-10-06T20:12:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291882",
    "user": "kedlaya"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_291883.json:
```json
{
    "body": "OK, I think I now have a working interface that avoids instantiating any dense vectors.",
    "created_at": "2017-10-06T20:12:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291883",
    "user": "kedlaya"
}
```

OK, I think I now have a working interface that avoids instantiating any dense vectors.



---

archive/issue_comments_291884.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2017-10-27T20:07:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291884",
    "user": "roed"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_291885.json:
```json
{
    "body": "I made some trivial fixes.  Looks good to me.\n----\nNew commits:",
    "created_at": "2017-10-27T20:07:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291885",
    "user": "roed"
}
```

I made some trivial fixes.  Looks good to me.
----
New commits:



---

archive/issue_comments_291886.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2017-10-30T07:41:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/21066",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/21066#issuecomment-291886",
    "user": "vbraun"
}
```

Resolution: fixed
