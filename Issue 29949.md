# Issue 29949: containment check for standard bracketed lyndon words does not work

Issue created by migration from https://trac.sagemath.org/ticket/30186

Original creator: @kliem

Original creation time: 2020-07-21 07:06:57

Keywords: Standard bracketed Lyndon words


```
sage: SBLW33 = StandardBracketedLyndonWords(3,3)
sage: SBLW33.an_element() in SBLW33
False
sage: SBLW33.random_element() in SBLW33
False
```



---

Comment by @kliem created at 2020-07-21 07:08:50

In an ideal words, this should be implemented. If not, than it should raise a `NotImplementedError` instead of returning wrong things.


---

Comment by @mrejmon created at 2021-02-15 11:03:35

Changing status from new to needs_review.


---

Comment by @mrejmon created at 2021-02-15 11:03:35

New commits:


---

Comment by @kliem created at 2021-02-15 11:31:37


```
+        # If x = st is a standard Lyndon factorization, and y is a Lyndon word
+        # such that y <= t, then xy is standard (but not necessarily Lyndon).
+        if x < y and (len(t) == 0 or y <= t):
+            x += y
+            return x, y
```


There is a couple of things here. The way I understand it, the check should be that `y >= t`??

If I'm not mistaking, then checking whether `len(t) == 0` is also redundant.

I also would prefer to return `x + y, y` over adding `y` to `x`. This seems more transparent to me.


---

Comment by @mrejmon created at 2021-02-15 14:27:14

Replying to [comment:4 gh-kliem]:
> {{{
> +        # If x = st is a standard Lyndon factorization, and y is a Lyndon word
> +        # such that y <= t, then xy is standard (but not necessarily Lyndon).
> +        if x < y and (len(t) == 0 or y <= t):
> +            x += y
> +            return x, y
> }}}
> 
> There is a couple of things here. The way I understand it, the check should be that `y >= t`??
> 
> If I'm not mistaking, then checking whether `len(t) == 0` is also redundant.

With y >= t ((1, 2), 3) would pass as valid since 3 >= 2, but the correct bracketing is (1, (2, 3)). I didn't come up with y <= t myself so I'm not entirely sure why it works, I got it from [here](https://www.sciencedirect.com/science/article/pii/S0195669805001629), section 4.2, end of second paragraph. I tested it quite extensively though on words of length < 10 and it seems to work correctly.

> I also would prefer to return `x + y, y` over adding `y` to `x`. This seems more transparent to me.

I used `x += y` since extending the list should be slightly faster then creating a new one in some cases, and similar in other. Running:


```
sage: from sage.combinat.words.lyndon_word import standard_bracketing, standard_unbracketing
sage: w1 = standard_bracketing(Word('1222222222'))
sage: %timeit standard_unbracketing(w1)
sage: w2 = standard_bracketing(Word('1111111112'))
sage: %timeit standard_unbracketing(w2)
```


with `x += y; return x, y` prints for example:


```
5.64 µs ± 72.7 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
5.31 µs ± 19.5 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```


while with `return x + y, y` prints for example:


```
5.95 µs ± 16.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
5.48 µs ± 5.17 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```


I agree that it is less readable.


---

Comment by @kliem created at 2021-02-15 19:42:50

Thank you for explaining. At least I understand what standard bracketed lyndon words are. Learnt something new today.

I guess the benchmarking is reason enough for the code the way it is. It is not that hard to read.


---

Comment by @kliem created at 2021-02-15 19:43:06

Changing status from needs_review to positive_review.


---

Comment by @kliem created at 2021-02-15 19:43:06

Thank you for implementing this.


---

Comment by @mrejmon created at 2021-02-16 12:12:20

Thanks for your fast review!


---

Comment by @kliem created at 2021-02-16 12:23:52

Changing status from positive_review to needs_work.


---

Comment by @kliem created at 2021-02-16 12:23:52

Actually, on second thought, I don't really like returning `[]` when the function should have raised an error.

Could you change to something like:


```diff
     def standard_unbracketing_rec(w):
         if not isinstance(w, list):
             return [w], []
         if len(w) != 2:
-            return [], []
+            raise ValueError("not a standard brackening")
         x, t = standard_unbracketing_rec(w[0])
-        if not x:
-            return [], []
         y, _ = standard_unbracketing_rec(w[1])
-        if not y:
-            return [], []
         # If x = st is a standard Lyndon factorization, and y is a Lyndon word
         # such that y <= t, then xy is standard (but not necessarily Lyndon).
         if x < y and (len(t) == 0 or y <= t):
             x += y
             return x, y
         else:
-            return [], []
+            raise ValueError("not a standard brackening")
```

The method `__contains__` then needs to catch this error, but I think an error raising is appropriate here, because `standard_unbracketing` might be used on its own.


---

Comment by @mrejmon created at 2021-02-16 14:23:20

While implementing that I had another idea: rename `standard_unbracketing` to `is_standard_bracketing` (`is_standard_bracketed`?) and have it return !True/False, but also have a boolean parameter `return_word` with default value False, which would cause the method to return a pair of for example `True, [1, 2, 3]` or `False, None`. Or I could just hide it inside the ```__contains__``` method. What do you think?


---

Comment by @kliem created at 2021-02-16 17:10:52

I think `standard_unbracketing` should really return a finite word with the correct alphabet and raise an error if this is not a standard_bracketing`.

I don't see the advantage in adding an extra keyword and having various types of ouput. Return the word raise an error if the bracketing is incorrect or the word isn't lyndon should be fine for most purposes.

There is a couple of things to fix yet; probably not in this ticket:

- 

```
sage: S = StandardBracketedLyndonWords(2, 4)                                                                                                                                        
sage: S([1,2])                                                                                                                                                                      
[1, 2]
sage: S.random_element()                                                                                                                                                            
[1, [1, [1, 2]]]
sage: S([1,2,2,2])                                                                                                                                                                  
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-71-bd319410246c> in <module>
----> 1 S([Integer(1),Integer(2),Integer(2),Integer(2)])

/srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/combinat/words/lyndon_word.py in __call__(self, *args, **kwds)
    538             [1, [2, 3]]
    539         """
--> 540         return standard_bracketing(self._lyndon(*args, **kwds))
    541 
    542     def __iter__(self):

/srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/combinat/words/lyndon_word.py in __call__(self, *args, **kwds)
    415             raise ValueError("not a Lyndon word")
    416         if w.length() != self._n:
--> 417             raise ValueError("length is not n={}".format(self._n))
    418         return w
    419 

ValueError: length is not n=2
```

  This really is caused by an underlying bug:

```
sage: L = LyndonWords(2,4); L                                                                                                                                                       
Lyndon words from an alphabet of size 2 of length 4
sage: L.random_element()                                                                                                                                                            
word: 1222
sage: L([1,2])                                                                                                                                                                      
word: 12
sage: L([1,2,2,2])                                                                                                                                                                  
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-82-0ddb9da93b95> in <module>
----> 1 L([Integer(1),Integer(2),Integer(2),Integer(2)])

/srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/combinat/words/lyndon_word.py in __call__(self, *args, **kwds)
    415             raise ValueError("not a Lyndon word")
    416         if w.length() != self._n:
--> 417             raise ValueError("length is not n={}".format(self._n))
    418         return w
    419 

ValueError: length is not n=2
```


- `__contains__` is missing for most classes in this module. It can usually fixed by just `try ... except` calling `__call__`. Maybe not super efficient, but it works.


---

Comment by @mrejmon created at 2021-02-17 14:07:51

Replying to [comment:11 gh-kliem]:
> I think `standard_unbracketing` should really return a finite word with the correct alphabet and raise an error if this is not a standard_bracketing`.

By correct alphabet you mean something like this?

```
res = ...
return FiniteWords(list(set(res)))(res, datatype=list, check=False)
```


> I don't see the advantage in adding an extra keyword and having various types of ouput. Return the word raise an error if the bracketing is incorrect or the word isn't lyndon should be fine for most purposes.

Alright, I'll change it later.

> There is a couple of things to fix yet; probably not in this ticket:
> 
> - 
> {{{
> ... 
> ValueError: length is not n=2
> }}}

Definitely. I'll create a ticket for it after this is done, unless you want to do it.

> - `__contains__` is missing for most classes in this module. It can usually fixed by just `try ... except` calling `__call__`. Maybe not super efficient, but it works.

This however, it seems to me there are 4 classes in this file and 3 of them already have `__contains__` (and this branch adds the last one)?


---

Comment by @kliem created at 2021-02-17 14:53:07

Oh yes, I missed those `__contains__` methods. I think I got confused by the case where `__call__` does the wrong thing.


---

Comment by @kliem created at 2021-02-17 14:54:47

Yes, this I mean by correct alphabet. In that bracketing and unbracketing would be almost inverses then.


---

Comment by git created at 2021-02-18 10:54:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mrejmon created at 2021-02-18 11:02:36

Changing status from needs_work to needs_review.


---

Comment by @kliem created at 2021-02-18 16:04:04

Changing status from needs_review to needs_work.


---

Comment by @kliem created at 2021-02-18 16:04:04

Sorry about being misleading:

There is a problem with the alphabet length. In case of the word `13` you will actually return true for lyndon words over `{1, 2}`.

Maybe we really fix everything here, because it appears to be just small typos:

Around line 416:


```diff
-        if w.length() != self._n:
-            raise ValueError("length is not n={}".format(self._n))
+        if w.length() != self._k:
+            raise ValueError("length is not k={}".format(self._k))
```

and a corresponding doctest.

Around line 428


```diff
         if isinstance(w, list):
             w = self._words(w)
-        return w in self._words and w.length() == self._k and len(set(w)) <= self._n
+        return w in self._words and w.length() == self._k and w.is_lyndon()
```


this is a redundant and confusing thing. It is already taken care of by `w in self._words` and besides the length of the set of the alphabet doesn't mean a lot.
And the actual important thing is completely missed.

And then we treat our case likewise:


```
        try:
            lw = standard_unbracketing(sblw)
        except ValueError:
            return False
        return len(lw) == self._k and lw in self._lyndon._words
```


Does this sound plausible?


---

Comment by @kliem created at 2021-02-19 12:47:12

I can also do those changes, if you like.


---

Comment by @mrejmon created at 2021-02-19 15:17:23

Oh wow, I got confused by the `len(set(w)) <= self._n` and thought `LyndonWords(2, 2)` would also accept `word: 13`, so I implemented it the same way, but that is not the case.

The problem with `lw in self._lyndon._words` is that `__contains__` for `FiniteWords` is weird, and only returns true if the alphabets match exactly, so since

```
sage: F = FiniteWords(alphabet=[1, 2, 3])
sage: Word([1, 2, 2]) in F
False
sage: Word([1, 2, 2], alphabet=[1, 2]) in F
False
sage: Word([1, 2, 2], alphabet=[1, 2, 3]) in F
True
```

`[[1, 2], 2] in StandardBracketedLyndonWords(3, 3)` would also return false.

We could fix this by doing for example

```
        try:
            lw = standard_unbracketing(sblw)
        except ValueError:
            return False
        return len(lw) == self._k and all(1 <= x <= self._n for x in lw)
```

but

```
all(standard_unbracketing(standard_bracketing(u)) in LyndonWords(3, 3) for u in LyndonWords(3,3))
```

would still return false (as it does right now). So I think we should revert `standard_unbracketing` and make it return a list again? Or we could similarly modify `__contains__` for `LyndonWords_nk`.

Also I noticed that `[1, 3] in LyndonWords(2, 2)` throws an exception instead of returning false, which is a little weird.


---

Comment by @kliem created at 2021-02-19 15:31:28

I think that `__contains__` behaves weird is just the next bug.

The problem with `1 <= x <= self._n` is that it might just raise the next error message, if `x` is a letter. However, you can ask `x in range(1, self._n + 1)`, which is exactly what we want.


---

Comment by git created at 2021-02-20 12:14:40

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mrejmon created at 2021-02-20 12:22:04

I fixed the bugs you mentioned above + in the meantime I replaced `w in self._words` with a manual alphabet check in all classes.

Replying to [comment:20 gh-kliem]:
> I think that `__contains__` behaves weird is just the next bug.

I think that was done on purpose a long time ago, see #15481. Doesn't mean it can't get changed though.

> The problem with `1 <= x <= self._n` is that it might just raise the next error message, if `x` is a letter. However, you can ask `x in range(1, self._n + 1)`, which is exactly what we want.

Right, in the end I used `x in self._words.alphabet()`.


---

Comment by @mrejmon created at 2021-02-20 12:24:10

Changing status from needs_work to needs_review.


---

Comment by git created at 2021-02-20 13:27:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-02-20 15:08:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mrejmon created at 2021-02-20 15:11:38

Alright, now all `LyndonWords*.__contains__` should never throw an exception (and also shouldn't make decisions based on the alphabet of inputted words).


---

Comment by @kliem created at 2021-02-23 08:29:11

You should add a test that this is fixed:


```
sage: S = StandardBracketedLyndonWords(2, 4)                                                                                                                                        
sage: S([1,2])                                                                                                                                                                      
[1, 2]
sage: S(S.random_element())                                                                                                                                                         
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-3-601071e1255f> in <module>
----> 1 S(S.random_element())

/srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/combinat/words/lyndon_word.py in __call__(self, *args, **kwds)
    538             [1, [2, 3]]
    539         """
--> 540         return standard_bracketing(self._lyndon(*args, **kwds))
    541 
    542     def __iter__(self):

/srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/combinat/words/lyndon_word.py in __call__(self, *args, **kwds)
    411             ValueError: length is not n=3
    412         """
--> 413         w = self._words(*args, **kwds)
    414         if kwds.get('check', True) and not w.is_lyndon():
    415             raise ValueError("not a Lyndon word")

/srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/combinat/words/words.py in __call__(self, data, length, datatype, caching, check)
    816             elif not isinstance(data, (tuple, list)):
    817                 data = list(data)
--> 818             w = self._element_classes['char'](self, data)
    819 
    820         elif isinstance(data, list):

/srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/combinat/words/word_char.pyx in sage.combinat.words.word_char.WordDatatype_char.__init__ (build/cythonized/sage/combinat/words/word_char.c:3732)()
     95             data = list(data)
     96         if data:
---> 97             self._set_data(data)
     98 
     99     @cython.boundscheck(False) # assume that indexing will not cause any IndexErrors

/srv/public/kliem/sage/local/lib/python3.7/site-packages/sage/combinat/words/word_char.pyx in sage.combinat.words.word_char.WordDatatype_char._set_data (build/cythonized/sage/combinat/words/word_char.c:3831)()
    109 
    110         for i in range(self._length):
--> 111             self._data[i] = data[i]
    112 
    113     def __dealloc__(self):

TypeError: an integer is required
```


Maybe something like this:


```
Check that the correct length is checked when calling; see :trac:`30186`::

    sage: L = LyndonWonds(2, 4)
    sage: _ = L(L.random_element())
```



---

Comment by @kliem created at 2021-02-23 08:36:25

Otherwise this looks good.


---

Comment by git created at 2021-02-26 09:42:03

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mrejmon created at 2021-02-26 09:45:03

Replying to [comment:27 gh-kliem]:
> You should add a test that this is fixed:
>
> ...
>
> Maybe something like this:
> 
> {{{
> Check that the correct length is checked when calling; see :trac:`30186`::
> 
>     sage: L = LyndonWonds(2, 4)
>     sage: _ = L(L.random_element())
> }}}

Done.


---

Comment by @kliem created at 2021-02-26 10:36:48

LGTM.


---

Comment by @kliem created at 2021-02-26 10:36:48

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2021-03-07 17:06:22

Resolution: fixed


---

Comment by slelievre created at 2021-03-07 18:37:28

Note: the `__contains__` method has `EXAMPLES:` instead of `EXAMPLES::`.

This means that examples block will not be doctested.

Please fix in follow-up ticket #31462.
