# Issue 16859: Implement categories for filtered algebras

archive/issues_016859.json:
```json
{
    "body": "Assignee: @tscrim\n\nCC:  @nthiery @darijgr days64 sd67\n\nKeywords: filtered algebras\n\nThere are some upcoming algebras in Sage (Clifford algebras in #15300, Yangians in #15484, and orthogonal/symplectic basis for Sym #15536; likely others) that would benefit from having a category with common methods.\n\nIssue created by migration from https://trac.sagemath.org/ticket/17096\n\n",
    "created_at": "2014-10-03T15:24:44Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.10",
    "title": "Implement categories for filtered algebras",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/16859",
    "user": "https://github.com/tscrim"
}
```
Assignee: @tscrim

CC:  @nthiery @darijgr days64 sd67

Keywords: filtered algebras

There are some upcoming algebras in Sage (Clifford algebras in #15300, Yangians in #15484, and orthogonal/symplectic basis for Sym #15536; likely others) that would benefit from having a category with common methods.

Issue created by migration from https://trac.sagemath.org/ticket/17096





---

archive/issue_comments_222917.json:
```json
{
    "body": "Some design decisions:\n\n- Every graded algebra is a filtered algebra under the \"natural\" filtration of summing over (weakly) smaller degrees (assuming total ordering on the grading group). This is implicit in the category structure; nothing specific is implemented.\n- Every `graded_*` category has `filtered_*` as an immediate super category. In particular, this is needed for `GradedAlgebrasWithBasis` not picking up `FilteredAlgebrasWithBasis` in its super categories otherwise.\n- Homogeneous elements for filtered algebras are elements in F<sub>i</sub> not in F<sub>i-1</sub>. I don't know if this is a standard definition, but it allowed extensions of methods from graded to filtered.\n\nNeeds review.\n----\nNew commits:",
    "created_at": "2014-10-19T22:12:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222917",
    "user": "https://github.com/tscrim"
}
```

Some design decisions:

- Every graded algebra is a filtered algebra under the "natural" filtration of summing over (weakly) smaller degrees (assuming total ordering on the grading group). This is implicit in the category structure; nothing specific is implemented.
- Every `graded_*` category has `filtered_*` as an immediate super category. In particular, this is needed for `GradedAlgebrasWithBasis` not picking up `FilteredAlgebrasWithBasis` in its super categories otherwise.
- Homogeneous elements for filtered algebras are elements in F<sub>i</sub> not in F<sub>i-1</sub>. I don't know if this is a standard definition, but it allowed extensions of methods from graded to filtered.

Needs review.
----
New commits:



---

archive/issue_comments_222918.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-10-19T22:12:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222918",
    "user": "https://github.com/tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_222919.json:
```json
{
    "body": "Replying to [comment:1 tscrim]:\n> - Every graded algebra is a filtered algebra under the \"natural\" filtration of summing over (weakly) smaller degrees (assuming total ordering on the grading group). This is implicit in the category structure; nothing specific is implemented.\n\nOf course, depending on the context, the converse convention can also\nsense; but maybe that's ok because eventually we will have both\nfiltered and descendingFiltered (or something similar) categories.\n\nhttp://en.wikipedia.org/wiki/Filtration_%28mathematics%29\n\n> - Every `graded_*` category has `filtered_*` as an immediate super category. In particular, this is needed for `GradedAlgebrasWithBasis` not picking up `FilteredAlgebrasWithBasis` in its super categories otherwise.\n\nThis seems like the same situation as for quotients\nw.r.t. subquotients. So the same mechanism should do the job (see\n`sage.categories.quotients.Quotients.default_super_categories`). Please\nconfirm!\n\n> - Homogeneous elements for filtered algebras are elements in F<sub>i</sub> not in F<sub>i-1</sub>. I don't know if this is a standard definition, but it allowed extensions of methods from graded to filtered.\n\nI see the point. The inconvenient is of course that this makes the set\nof homogeneous elements for a given i not be a vector space. What do\nyou do with 0 btw?\n\nCheers,\n                               Nicolas",
    "created_at": "2014-10-20T13:07:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222919",
    "user": "https://github.com/nthiery"
}
```

Replying to [comment:1 tscrim]:
> - Every graded algebra is a filtered algebra under the "natural" filtration of summing over (weakly) smaller degrees (assuming total ordering on the grading group). This is implicit in the category structure; nothing specific is implemented.

Of course, depending on the context, the converse convention can also
sense; but maybe that's ok because eventually we will have both
filtered and descendingFiltered (or something similar) categories.

http://en.wikipedia.org/wiki/Filtration_%28mathematics%29

> - Every `graded_*` category has `filtered_*` as an immediate super category. In particular, this is needed for `GradedAlgebrasWithBasis` not picking up `FilteredAlgebrasWithBasis` in its super categories otherwise.

This seems like the same situation as for quotients
w.r.t. subquotients. So the same mechanism should do the job (see
`sage.categories.quotients.Quotients.default_super_categories`). Please
confirm!

> - Homogeneous elements for filtered algebras are elements in F<sub>i</sub> not in F<sub>i-1</sub>. I don't know if this is a standard definition, but it allowed extensions of methods from graded to filtered.

I see the point. The inconvenient is of course that this makes the set
of homogeneous elements for a given i not be a vector space. What do
you do with 0 btw?

Cheers,
                               Nicolas



---

archive/issue_comments_222920.json:
```json
{
    "body": "Replying to [comment:2 nthiery]:\n> Of course, depending on the context, the converse convention can also\n> sense; but maybe that's ok because eventually we will have both\n> filtered and descendingFiltered (or something similar) categories.\n> \n> http://en.wikipedia.org/wiki/Filtration_%28mathematics%29\n\nTrue, but I figured we'd cross that bridge when we have a need/desire for it.\n\n> This seems like the same situation as for quotients\n> w.r.t. subquotients. So the same mechanism should do the job (see\n> `sage.categories.quotients.Quotients.default_super_categories`). Please\n> confirm!\n\nThanks. Done.\n\n> I see the point. The inconvenient is of course that this makes the set\n> of homogeneous elements for a given i not be a vector space. What do\n> you do with 0 btw?\n\nRaise an error as previously for graded objects saying it doesn't have a well defined degree.\n----\nNew commits:",
    "created_at": "2014-10-20T15:19:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222920",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:2 nthiery]:
> Of course, depending on the context, the converse convention can also
> sense; but maybe that's ok because eventually we will have both
> filtered and descendingFiltered (or something similar) categories.
> 
> http://en.wikipedia.org/wiki/Filtration_%28mathematics%29

True, but I figured we'd cross that bridge when we have a need/desire for it.

> This seems like the same situation as for quotients
> w.r.t. subquotients. So the same mechanism should do the job (see
> `sage.categories.quotients.Quotients.default_super_categories`). Please
> confirm!

Thanks. Done.

> I see the point. The inconvenient is of course that this makes the set
> of homogeneous elements for a given i not be a vector space. What do
> you do with 0 btw?

Raise an error as previously for graded objects saying it doesn't have a well defined degree.
----
New commits:



---

archive/issue_comments_222921.json:
```json
{
    "body": "1) What does the `_element_constructor_` in `associated_graded.py` do? I understand that it constructs an element of gr A from an element a of A, but the way it does this I do not think is correct.\n\nThe \"right\" thing to do is this: For a given pair `(a, n)` where `n` is a nonnegative integer and `a` is an element of the `n`-th filtered part of `A`, the residue class of `a` modulo the `(n-1)`-th filtered part of `A` is an element of the `n`-th graded component of `\\gr A`. The `n` is part of the input; you can try to reconstruct it as the smallest `i` such that `a` lies in the `i`-th filtered part of `A`, but such a definition will be ill-behaved.\n\n2) I think you need some requirements on the basis of a FilteredModulesWithBasis for your code to work. I would guess you want the basis to be a sequence `(B_0, B_1, B_2, ...)` of sets such that for every `n`, the union `B_0 \\cup B_1 \\cup ...\\cup B_n` is a basis of the `n`-th filtered component. Is it what you want?",
    "created_at": "2014-10-28T19:28:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222921",
    "user": "https://github.com/darijgr"
}
```

1) What does the `_element_constructor_` in `associated_graded.py` do? I understand that it constructs an element of gr A from an element a of A, but the way it does this I do not think is correct.

The "right" thing to do is this: For a given pair `(a, n)` where `n` is a nonnegative integer and `a` is an element of the `n`-th filtered part of `A`, the residue class of `a` modulo the `(n-1)`-th filtered part of `A` is an element of the `n`-th graded component of `\gr A`. The `n` is part of the input; you can try to reconstruct it as the smallest `i` such that `a` lies in the `i`-th filtered part of `A`, but such a definition will be ill-behaved.

2) I think you need some requirements on the basis of a FilteredModulesWithBasis for your code to work. I would guess you want the basis to be a sequence `(B_0, B_1, B_2, ...)` of sets such that for every `n`, the union `B_0 \cup B_1 \cup ...\cup B_n` is a basis of the `n`-th filtered component. Is it what you want?



---

archive/issue_comments_222922.json:
```json
{
    "body": "Replying to [comment:4 darij]:\n> 1) What does the `_element_constructor_` in `associated_graded.py` do? I understand that it constructs an element of gr A from an element a of A, but the way it does this I do not think is correct.\n> \n> The \"right\" thing to do is this: For a given pair `(a, n)` where `n` is a nonnegative integer and `a` is an element of the `n`-th filtered part of `A`, the residue class of `a` modulo the `(n-1)`-th filtered part of `A` is an element of the `n`-th graded component of `\\gr A`. The `n` is part of the input; you can try to reconstruct it as the smallest `i` such that `a` lies in the `i`-th filtered part of `A`, but such a definition will be ill-behaved.\n\nHmmm....maybe this shouldn't be a coercion then since if `ab = c1 + c2` (where `deg(c1) > deg(c2)`), then `G(ab) != G(c1) + G(c2)`. The implementation of `_element_constructor_` is definitely the right conversion however (the natural vector space isomorphism). So I'll remove the coercion part but leave the `_element_constructor_`.\n\n> 2) I think you need some requirements on the basis of a FilteredModulesWithBasis for your code to work. I would guess you want the basis to be a sequence `(B_0, B_1, B_2, ...)` of sets such that for every `n`, the union `B_0 \\cup B_1 \\cup ...\\cup B_n` is a basis of the `n`-th filtered component. Is it what you want?\n\nNo, the basis does not have to be ordered with respect to the degree. I also don't see where in the code this is used (I just moved it over from the graded modules, so I may not have looked hard enough).",
    "created_at": "2014-10-28T21:49:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222922",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:4 darij]:
> 1) What does the `_element_constructor_` in `associated_graded.py` do? I understand that it constructs an element of gr A from an element a of A, but the way it does this I do not think is correct.
> 
> The "right" thing to do is this: For a given pair `(a, n)` where `n` is a nonnegative integer and `a` is an element of the `n`-th filtered part of `A`, the residue class of `a` modulo the `(n-1)`-th filtered part of `A` is an element of the `n`-th graded component of `\gr A`. The `n` is part of the input; you can try to reconstruct it as the smallest `i` such that `a` lies in the `i`-th filtered part of `A`, but such a definition will be ill-behaved.

Hmmm....maybe this shouldn't be a coercion then since if `ab = c1 + c2` (where `deg(c1) > deg(c2)`), then `G(ab) != G(c1) + G(c2)`. The implementation of `_element_constructor_` is definitely the right conversion however (the natural vector space isomorphism). So I'll remove the coercion part but leave the `_element_constructor_`.

> 2) I think you need some requirements on the basis of a FilteredModulesWithBasis for your code to work. I would guess you want the basis to be a sequence `(B_0, B_1, B_2, ...)` of sets such that for every `n`, the union `B_0 \cup B_1 \cup ...\cup B_n` is a basis of the `n`-th filtered component. Is it what you want?

No, the basis does not have to be ordered with respect to the degree. I also don't see where in the code this is used (I just moved it over from the graded modules, so I may not have looked hard enough).



---

archive/issue_comments_222923.json:
```json
{
    "body": "That `_element_constructor_` definitely shouldn't be a coercion, but even not being a coercion it should be surrounded with big fat warning signs for not being what one would expect.\n\nI don't understand your answer to 2). Even your own doc says that the basis is graded:\n\n```\n+ def basis(self, d=None):\n+ \"\"\"\n+ Return the basis for (an homogeneous component of) ``self``.\n```\n\nThis means precisely that the basis elements have nonnegative integers ascribed to them, which stand for something like degree.\n\nGenerally, it seems to me that your filtered modules are precisely the same as graded modules, and only the richer \"sub\"categories (filtered algebras, filtered coalgebras etc.) differ from their graded counterparts. If so, this is a perfectly fine design decision, but it would help to document it explicitly.",
    "created_at": "2014-10-29T02:14:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222923",
    "user": "https://github.com/darijgr"
}
```

That `_element_constructor_` definitely shouldn't be a coercion, but even not being a coercion it should be surrounded with big fat warning signs for not being what one would expect.

I don't understand your answer to 2). Even your own doc says that the basis is graded:

```
+ def basis(self, d=None):
+ """
+ Return the basis for (an homogeneous component of) ``self``.
```

This means precisely that the basis elements have nonnegative integers ascribed to them, which stand for something like degree.

Generally, it seems to me that your filtered modules are precisely the same as graded modules, and only the richer "sub"categories (filtered algebras, filtered coalgebras etc.) differ from their graded counterparts. If so, this is a perfectly fine design decision, but it would help to document it explicitly.



---

archive/issue_comments_222924.json:
```json
{
    "body": "Replying to [comment:6 darij]:\n> That `_element_constructor_` definitely shouldn't be a coercion, but even not being a coercion it should be surrounded with big fat warning signs for not being what one would expect.\n\nYou wouldn't expect it to be the canonical linear isomorphism (as modules)? So given some `x + y` in the filtered algebra `A`, you wouldn't expect it to return `x + y` in `gr A`? Instead you'd want it to return only `x` (assuming it has larger degree)? This would be extremely surprising to me (we have a method to remove the lower order terms too). Or am I not understanding what you're saying?\n\n> I don't understand your answer to 2). Even your own doc says that the basis is graded:\n> {{{\n> + def basis(self, d=None):\n> + \"\"\"\n> + Return the basis for (an homogeneous component of) ``self``.\n> }}}\n> This means precisely that the basis elements have nonnegative integers ascribed to them, which stand for something like degree.\n\nWell, any (additive) abelian group. Yet I'm not requiring that the `i`-th element of the basis be the only element of degree `i`. Again, an element is homogeneous of degree d if it belongs to F<sub>d</sub> but not F<sub>d-1</sub>. However I am requiring that F<sub>d</sub> is a subspace.\n\n> Generally, it seems to me that your filtered modules are precisely the same as graded modules, and only the richer \"sub\"categories (filtered algebras, filtered coalgebras etc.) differ from their graded counterparts. If so, this is a perfectly fine design decision, but it would help to document it explicitly.\n\nIn my (naive) world, filtrations are not really different than grading for modules. That's not to say they aren't useful though because of things like `I`-adic topology (TBH, this is wikipedia talking). However I don't think we need doc on this. Nicolas, do you have any thoughts?\n\nI could add something about the terminology for homogeneous in terms of the filtration if that's non-standard or unclear.\n\nQuestion, should we make Weyl and Clifford algebras filtered on this ticket or on a followup since that's been closed? Same for group algebras by the length function.",
    "created_at": "2014-10-29T02:52:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222924",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:6 darij]:
> That `_element_constructor_` definitely shouldn't be a coercion, but even not being a coercion it should be surrounded with big fat warning signs for not being what one would expect.

You wouldn't expect it to be the canonical linear isomorphism (as modules)? So given some `x + y` in the filtered algebra `A`, you wouldn't expect it to return `x + y` in `gr A`? Instead you'd want it to return only `x` (assuming it has larger degree)? This would be extremely surprising to me (we have a method to remove the lower order terms too). Or am I not understanding what you're saying?

> I don't understand your answer to 2). Even your own doc says that the basis is graded:
> {{{
> + def basis(self, d=None):
> + """
> + Return the basis for (an homogeneous component of) ``self``.
> }}}
> This means precisely that the basis elements have nonnegative integers ascribed to them, which stand for something like degree.

Well, any (additive) abelian group. Yet I'm not requiring that the `i`-th element of the basis be the only element of degree `i`. Again, an element is homogeneous of degree d if it belongs to F<sub>d</sub> but not F<sub>d-1</sub>. However I am requiring that F<sub>d</sub> is a subspace.

> Generally, it seems to me that your filtered modules are precisely the same as graded modules, and only the richer "sub"categories (filtered algebras, filtered coalgebras etc.) differ from their graded counterparts. If so, this is a perfectly fine design decision, but it would help to document it explicitly.

In my (naive) world, filtrations are not really different than grading for modules. That's not to say they aren't useful though because of things like `I`-adic topology (TBH, this is wikipedia talking). However I don't think we need doc on this. Nicolas, do you have any thoughts?

I could add something about the terminology for homogeneous in terms of the filtration if that's non-standard or unclear.

Question, should we make Weyl and Clifford algebras filtered on this ticket or on a followup since that's been closed? Same for group algebras by the length function.



---

archive/issue_comments_222925.json:
```json
{
    "body": "Replying to [comment:7 tscrim]:\n> Replying to [comment:6 darij]:\n> > That `_element_constructor_` definitely shouldn't be a coercion, but even not being a coercion it should be surrounded with big fat warning signs for not being what one would expect.\n> \n> You wouldn't expect it to be the canonical linear isomorphism (as modules)? So given some `x + y` in the filtered algebra `A`, you wouldn't expect it to return `x + y` in `gr A`? Instead you'd want it to return only `x` (assuming it has larger degree)? This would be extremely surprising to me (we have a method to remove the lower order terms too). Or am I not understanding what you're saying?\n\nWell, I wouldn't expect to have any map from `A` to `gr(A)` when `A` is a filtered module/algebra, and the closest thing that comes to such a map would be a sequence of maps `p_0, p_1, p_2, ...` where `p_n` sends degree-\\leq n elements of `A` to the `n`-th graded component of `gr(A)`. However, when `A` is a filtered module/algebra *with basis*, then your `_element_constructor` can be viewed as a canonical map from `A` to `gr(A)` indeed (it depends on the basis, but this is no problem because the basis is part of `A`'s data). You may find this a squeamish distinction, but the way most algebraists think about filtrations is not the way you do. For most algebraists, a filtered algebra has an associated graded algebra even if it does not have a basis or has several natural bases; and when things depend on a choice of basis, one regards these things as properties of the basis rather than properties of the algebra. This is why I want you to document this all so carefully.\n\n> Well, any (additive) abelian group. Yet I'm not requiring that the `i`-th element of the basis be the only element of degree `i`.\n\nOh! I think we misunderstood each other here.\n\n> In my (naive) world, filtrations are not really different than grading for modules.\n\nOnce again, this is good (I think this is the best we can do explicitly in a CAS, whereas the algebraists' notion of a filtered algebra would be some indiscrete lazy object) -- but this absolutely needs to be doced. This is plainly not the way algebraists think.\n\n> Question, should we make Weyl and Clifford algebras filtered on this ticket or on a followup since that's been closed? Same for group algebras by the length function.\n\nFollowup, definitely. The ticket has been closed already and I don't think this one will be done too quickly.",
    "created_at": "2014-10-29T03:02:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222925",
    "user": "https://github.com/darijgr"
}
```

Replying to [comment:7 tscrim]:
> Replying to [comment:6 darij]:
> > That `_element_constructor_` definitely shouldn't be a coercion, but even not being a coercion it should be surrounded with big fat warning signs for not being what one would expect.
> 
> You wouldn't expect it to be the canonical linear isomorphism (as modules)? So given some `x + y` in the filtered algebra `A`, you wouldn't expect it to return `x + y` in `gr A`? Instead you'd want it to return only `x` (assuming it has larger degree)? This would be extremely surprising to me (we have a method to remove the lower order terms too). Or am I not understanding what you're saying?

Well, I wouldn't expect to have any map from `A` to `gr(A)` when `A` is a filtered module/algebra, and the closest thing that comes to such a map would be a sequence of maps `p_0, p_1, p_2, ...` where `p_n` sends degree-\leq n elements of `A` to the `n`-th graded component of `gr(A)`. However, when `A` is a filtered module/algebra *with basis*, then your `_element_constructor` can be viewed as a canonical map from `A` to `gr(A)` indeed (it depends on the basis, but this is no problem because the basis is part of `A`'s data). You may find this a squeamish distinction, but the way most algebraists think about filtrations is not the way you do. For most algebraists, a filtered algebra has an associated graded algebra even if it does not have a basis or has several natural bases; and when things depend on a choice of basis, one regards these things as properties of the basis rather than properties of the algebra. This is why I want you to document this all so carefully.

> Well, any (additive) abelian group. Yet I'm not requiring that the `i`-th element of the basis be the only element of degree `i`.

Oh! I think we misunderstood each other here.

> In my (naive) world, filtrations are not really different than grading for modules.

Once again, this is good (I think this is the best we can do explicitly in a CAS, whereas the algebraists' notion of a filtered algebra would be some indiscrete lazy object) -- but this absolutely needs to be doced. This is plainly not the way algebraists think.

> Question, should we make Weyl and Clifford algebras filtered on this ticket or on a followup since that's been closed? Same for group algebras by the length function.

Followup, definitely. The ticket has been closed already and I don't think this one will be done too quickly.



---

archive/issue_comments_222926.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-29T22:47:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222926",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222927.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-29T22:50:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222927",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222928.json:
```json
{
    "body": "Okay, I've put in some comments about the translation `A <-> gr A` (it actually wasn't a coercion to begin with) and defined some terms. If you feel anything more needs to be doc'ed, then could you add it in since I'm not sure what more you think is needed?\n\nAlthough I think there is still a module isomorphism which sends `G_i -> F_i - F_{i-1}` (since I require each `F_i` to be a module. Perhaps I'm missing something subtle (and I can't really think in coordinate-free terms very well).",
    "created_at": "2014-10-29T22:53:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222928",
    "user": "https://github.com/tscrim"
}
```

Okay, I've put in some comments about the translation `A <-> gr A` (it actually wasn't a coercion to begin with) and defined some terms. If you feel anything more needs to be doc'ed, then could you add it in since I'm not sure what more you think is needed?

Although I think there is still a module isomorphism which sends `G_i -> F_i - F_{i-1}` (since I require each `F_i` to be a module. Perhaps I'm missing something subtle (and I can't really think in coordinate-free terms very well).



---

archive/issue_comments_222929.json:
```json
{
    "body": "I think your doc is inconsistent. This can't be:\n\n```\n+We require all `F_i \\setminus F_{i-1}` to be modules for all `i`.\n```\n\nWhat do you want `F_i` to be? The span of all elements UP TO degree `i`, or the span of all elements that are added by degree `i`? So when you consider a graded module as a filtered module, then will `F_i` be the `i`-th graded component or the direct sum of the `0, 1, ..., i`-th graded components? In the former case, you don't want a setminus at all. In the latter case, setminus is the right idea but the wrong notation, and you want to say something like `F_i = F_{i-1} \\oplus G_i` where `G_i` is the submodule spanned by the degree `i`-basis elements.",
    "created_at": "2014-10-30T04:05:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222929",
    "user": "https://github.com/darijgr"
}
```

I think your doc is inconsistent. This can't be:

```
+We require all `F_i \setminus F_{i-1}` to be modules for all `i`.
```

What do you want `F_i` to be? The span of all elements UP TO degree `i`, or the span of all elements that are added by degree `i`? So when you consider a graded module as a filtered module, then will `F_i` be the `i`-th graded component or the direct sum of the `0, 1, ..., i`-th graded components? In the former case, you don't want a setminus at all. In the latter case, setminus is the right idea but the wrong notation, and you want to say something like `F_i = F_{i-1} \oplus G_i` where `G_i` is the submodule spanned by the degree `i`-basis elements.



---

archive/issue_comments_222930.json:
```json
{
    "body": "For filtered algebras, we (only) have F<sub>0</sub> <= F<sub>1</sub> <= ..., so for graded modules, we'd have G<sub>i</sub> = F<sub>i</sub> - F<sub>i-1</sub> because we want that construction of F<sub>i</sub> = F<sub>i-1</sub> (+) G<sub>i</sub> (starting with F<sub>0</sub> = G<sub>0</sub>). Actually, there is something that is wrong; the setminus isn't correct because it removes 0. It should be a quotient F<sub>i</sub> / F<sub>i-1</sub>, but other than that, it's consistent.",
    "created_at": "2014-10-30T04:35:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222930",
    "user": "https://github.com/tscrim"
}
```

For filtered algebras, we (only) have F<sub>0</sub> <= F<sub>1</sub> <= ..., so for graded modules, we'd have G<sub>i</sub> = F<sub>i</sub> - F<sub>i-1</sub> because we want that construction of F<sub>i</sub> = F<sub>i-1</sub> (+) G<sub>i</sub> (starting with F<sub>0</sub> = G<sub>0</sub>). Actually, there is something that is wrong; the setminus isn't correct because it removes 0. It should be a quotient F<sub>i</sub> / F<sub>i-1</sub>, but other than that, it's consistent.



---

archive/issue_comments_222931.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-31T21:58:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222931",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222932.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-10-31T22:00:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222932",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222933.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-09T19:26:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222933",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222934.json:
```json
{
    "body": "I have rewritten the doc to convey *my* understanding of your classes. It will probably have typos and wrong references -- sorry for that, I just can't manage to keep looking at sage categories for longer than a couple hours --, but if you see something that looks seriously wrong to you, chances are I have misunderstood your code and we need to discuss it over. I suspect I am not done with this patch either way, but I am going to return to tableaux and polytopes for a week or so.\n\nI think there should be a one-stop shop in the doc to read up all of the (nonstandard but reasonable!) terminology around filtrations and gradings in Sage. Which should explain what \"homogeneous\" means for a filtered algebra, etc., and which should be referenced in the method-level and maybe even in the class-level docs. Where do you think such a thing would fit?\n\nAlso, there are two doctests failure that this patch incurs for some weird reason:\n\n```\nsage -t src/sage/categories/category_with_axiom.py\n**********************************************************************\nFile \"src/sage/categories/category_with_axiom.py\", line 2513, in sage.categories.category_with_axiom.CategoryWithAxiom_singleton\nFailed example:\n    C.FiniteDimensional()\nExpected:\n    Category of finite dimensional connected test objects over base ring over Ring of integers modulo 2\nGot:\n    Category of finite dimensional test objects over base ring over Ring of integers modulo 2\n**********************************************************************\nFile \"src/sage/categories/category_with_axiom.py\", line 2515, in sage.categories.category_with_axiom.CategoryWithAxiom_singleton\nFailed example:\n    C.Connected()\nExpected:\n    Category of connected test objects over base ring over Ring of integers modulo 2\nGot:\n    Category of test objects over base ring over Ring of integers modulo 2\n**********************************************************************\n```\n\n\nAlso, an easy one:\n\n```\nsage -t src/sage/categories/category.py\n**********************************************************************\nFile \"src/sage/categories/category.py\", line 2627, in sage.categories.category.category_graph\nFailed example:\n    sage.categories.category.category_graph().plot()\nExpected:\n    Graphics object consisting of 312 graphics primitives\nGot:\n    Graphics object consisting of 324 graphics primitives\n```\n",
    "created_at": "2014-11-09T19:31:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222934",
    "user": "https://github.com/darijgr"
}
```

I have rewritten the doc to convey *my* understanding of your classes. It will probably have typos and wrong references -- sorry for that, I just can't manage to keep looking at sage categories for longer than a couple hours --, but if you see something that looks seriously wrong to you, chances are I have misunderstood your code and we need to discuss it over. I suspect I am not done with this patch either way, but I am going to return to tableaux and polytopes for a week or so.

I think there should be a one-stop shop in the doc to read up all of the (nonstandard but reasonable!) terminology around filtrations and gradings in Sage. Which should explain what "homogeneous" means for a filtered algebra, etc., and which should be referenced in the method-level and maybe even in the class-level docs. Where do you think such a thing would fit?

Also, there are two doctests failure that this patch incurs for some weird reason:

```
sage -t src/sage/categories/category_with_axiom.py
**********************************************************************
File "src/sage/categories/category_with_axiom.py", line 2513, in sage.categories.category_with_axiom.CategoryWithAxiom_singleton
Failed example:
    C.FiniteDimensional()
Expected:
    Category of finite dimensional connected test objects over base ring over Ring of integers modulo 2
Got:
    Category of finite dimensional test objects over base ring over Ring of integers modulo 2
**********************************************************************
File "src/sage/categories/category_with_axiom.py", line 2515, in sage.categories.category_with_axiom.CategoryWithAxiom_singleton
Failed example:
    C.Connected()
Expected:
    Category of connected test objects over base ring over Ring of integers modulo 2
Got:
    Category of test objects over base ring over Ring of integers modulo 2
**********************************************************************
```


Also, an easy one:

```
sage -t src/sage/categories/category.py
**********************************************************************
File "src/sage/categories/category.py", line 2627, in sage.categories.category.category_graph
Failed example:
    sage.categories.category.category_graph().plot()
Expected:
    Graphics object consisting of 312 graphics primitives
Got:
    Graphics object consisting of 324 graphics primitives
```




---

archive/issue_comments_222935.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-16T20:54:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222935",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222936.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-16T21:02:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222936",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222937.json:
```json
{
    "body": "I've fixed some things around, in particular, I made the definitions as general as possible. Because the basis for a filtered module are assumed to be homogeneous elements, the multiplication for the associated graded algebras is independent of the choice of basis. Actually, I'm pretty sure the important chunk of the assoc. graded algebras could be generalized for filtered algebras without a distinguished basis (or when the input is not a CombinatorialFreeModule), but I think that can wait. I also put Clifford and (Diff) Weyl algebras as filtered algebras because it was easy enough to do.",
    "created_at": "2014-11-16T21:12:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222937",
    "user": "https://github.com/tscrim"
}
```

I've fixed some things around, in particular, I made the definitions as general as possible. Because the basis for a filtered module are assumed to be homogeneous elements, the multiplication for the associated graded algebras is independent of the choice of basis. Actually, I'm pretty sure the important chunk of the assoc. graded algebras could be generalized for filtered algebras without a distinguished basis (or when the input is not a CombinatorialFreeModule), but I think that can wait. I also put Clifford and (Diff) Weyl algebras as filtered algebras because it was easy enough to do.



---

archive/issue_comments_222938.json:
```json
{
    "body": "Can you go skype-on?",
    "created_at": "2014-11-16T21:20:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222938",
    "user": "https://github.com/darijgr"
}
```

Can you go skype-on?



---

archive/issue_comments_222939.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-16T23:58:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222939",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222940.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-17T04:53:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222940",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222941.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-17T04:57:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222941",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222942.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-17T06:31:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222942",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222943.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-17T08:06:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222943",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222944.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-17T08:26:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222944",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222945.json:
```json
{
    "body": "I have left a few TODOs in the doc, which would profit a lot from someone looking into them.\n\nNote to self: I am at `filtered_modules_with_basis.py`.",
    "created_at": "2014-11-17T08:27:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222945",
    "user": "https://github.com/darijgr"
}
```

I have left a few TODOs in the doc, which would profit a lot from someone looking into them.

Note to self: I am at `filtered_modules_with_basis.py`.



---

archive/issue_comments_222946.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-17T16:12:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222946",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222947.json:
```json
{
    "body": "[Only a quick look at Clifford -- too swamped with work again.]\n\nYou implemented a `graded_algebra` method on the Clifford algebra; but does the algebra it return satisfy the contract of an associated graded algebra? Will it have the `_element_constructor_`, `to_graded_conversion`, `from_graded_conversion` and `projection` methods that allow one to relate its elements to the elements of the Clifford?",
    "created_at": "2014-11-17T18:10:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222947",
    "user": "https://github.com/darijgr"
}
```

[Only a quick look at Clifford -- too swamped with work again.]

You implemented a `graded_algebra` method on the Clifford algebra; but does the algebra it return satisfy the contract of an associated graded algebra? Will it have the `_element_constructor_`, `to_graded_conversion`, `from_graded_conversion` and `projection` methods that allow one to relate its elements to the elements of the Clifford?



---

archive/issue_comments_222948.json:
```json
{
    "body": "Replying to [comment:30 darij]:\n> [Only a quick look at Clifford -- too swamped with work again.]\n> \n> You implemented a `graded_algebra` method on the Clifford algebra; but does the algebra it return satisfy the contract of an associated graded algebra? Will it have the `_element_constructor_`, `to_graded_conversion`, `from_graded_conversion` and `projection` methods that allow one to relate its elements to the elements of the Clifford?\n\nCurrently there is no such contract (all graded algebras would not satisfy such a contract as well because they return themselves). However the `_element_constructor_` and the natural conversion (projection) comes along for free (at least I believe it should, I didn't explicitly check).",
    "created_at": "2014-11-17T18:51:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222948",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:30 darij]:
> [Only a quick look at Clifford -- too swamped with work again.]
> 
> You implemented a `graded_algebra` method on the Clifford algebra; but does the algebra it return satisfy the contract of an associated graded algebra? Will it have the `_element_constructor_`, `to_graded_conversion`, `from_graded_conversion` and `projection` methods that allow one to relate its elements to the elements of the Clifford?

Currently there is no such contract (all graded algebras would not satisfy such a contract as well because they return themselves). However the `_element_constructor_` and the natural conversion (projection) comes along for free (at least I believe it should, I didn't explicitly check).



---

archive/issue_comments_222949.json:
```json
{
    "body": "For the graded algebras returning themselves, this can -- and should -- be fixed. I think the contract is important -- the ass. gr. algebra without it is like a free algebra without a way to access its generators. Is it necessary to define the ass. gr. algebra of a filtered Clifford algebra to be the exterior algebra?\n\nEDIT: On a second thought, maybe it is better to implement the projection and the back-and-forth isos not as methods on the ass. gr. algebra but as methods on the filtered algebra. This allows one and the same graded algebra to serve as the ass. gr. alegbra for several different filtered algebras. Would this make sense?",
    "created_at": "2014-11-17T20:28:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222949",
    "user": "https://github.com/darijgr"
}
```

For the graded algebras returning themselves, this can -- and should -- be fixed. I think the contract is important -- the ass. gr. algebra without it is like a free algebra without a way to access its generators. Is it necessary to define the ass. gr. algebra of a filtered Clifford algebra to be the exterior algebra?

EDIT: On a second thought, maybe it is better to implement the projection and the back-and-forth isos not as methods on the ass. gr. algebra but as methods on the filtered algebra. This allows one and the same graded algebra to serve as the ass. gr. alegbra for several different filtered algebras. Would this make sense?



---

archive/issue_comments_222950.json:
```json
{
    "body": "Replying to [comment:32 darij]:\n> For the graded algebras returning themselves, this can -- and should -- be fixed. I think the contract is important -- the ass. gr. algebra without it is like a free algebra without a way to access its generators. Is it necessary to define the ass. gr. algebra of a filtered Clifford algebra to be the exterior algebra?\n> \n> EDIT: On a second thought, maybe it is better to implement the projection and the back-and-forth isos not as methods on the ass. gr. algebra but as methods on the filtered algebra. This allows one and the same graded algebra to serve as the ass. gr. alegbra for several different filtered algebras. Would this make sense?\n\nActually, these were bad ideas. Sorry, I don't think overwriting the `graded_algebra` method does any good, unless the return value is a refinement of what it would normally be (i.e., the `AssociatedGradedAlgebra` of `self`).\n\nFor an example why preserving a contract (and having a contract in the first place) is important, let's recall that `gr` is a functor. In fact, every filtration-preserving map `f : A -> B` of filtered modules induces a graded map `gr f : gr A -> gr B` of the associated gradeds. This map `gr f` sends the residue class of any `a \\in F_n(A)` (this means the `n`-th filtered part of `A`) to the residue class of `f(a) \\in F_n(B)`. (This is *not* the map that would be obtained by composing the canonical iso `gr A -> A` with `f : A -> B` and then with the canonical iso `B -> gr B` when `A` and `B` are graded with basis. It is defined even without bases.) How would we implement this (on filtered modules or algebras with basis)? I would proceed like this:\n\n\n```\ndef induced_graded_map(self, other, f):\n    r\"\"\"\n    Return the graded linear map ``self`` `\\to` ``other`` canonically\n    induced by a linear map `f` from the filtered module whose\n    associated graded module is ``self`` to the filtered module whose\n    associated graded module is ``other``.\n\n    [...]\n\n    \"\"\"\n    # not tested\n    A = self._A # This requires ``self`` to have a ``_A`` attribute,\n                # which must be part of the contract.\n    def on_basis(m):\n        i = self.degree_on_basis(m)\n        # This needs a ``degree_on_basis`` method on ``self``.\n        return other.projection(i)(f(A.monomial(m)))\n        # This needs the ``projection`` method to exist on\n        # ``other``.\n        # This assumes that the basis element of ``A`` indexed\n        # by ``m`` is a lift of the basis element of ``self``\n        # indexed by ``m``. This is a fairly harmless assumption.\n    return self.module_morphism(on_basis=on_basis,\n                                codomain=other, category=self.category())\n    \"\"\"\n```\n\n\nThis is a piece of code so basic and general that it should be in `associated_graded.py`. But if we start redefining `graded_algebra` in ways that remove its `_A` attribute, its `projection` method and whatever else, then this code breaks.\n\nI suck at Python OOP; do you know a way to take an existing instance of `AssociatedGraded` and add some methods to it? If this is possible, then I think this is what overrides of `graded_algebra` should be doing. For instance, the graded algebra of a Clifford algebra should be its `AssociatedGraded`, but with a coercion to and from the exterior algebra.",
    "created_at": "2014-11-17T23:32:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222950",
    "user": "https://github.com/darijgr"
}
```

Replying to [comment:32 darij]:
> For the graded algebras returning themselves, this can -- and should -- be fixed. I think the contract is important -- the ass. gr. algebra without it is like a free algebra without a way to access its generators. Is it necessary to define the ass. gr. algebra of a filtered Clifford algebra to be the exterior algebra?
> 
> EDIT: On a second thought, maybe it is better to implement the projection and the back-and-forth isos not as methods on the ass. gr. algebra but as methods on the filtered algebra. This allows one and the same graded algebra to serve as the ass. gr. alegbra for several different filtered algebras. Would this make sense?

Actually, these were bad ideas. Sorry, I don't think overwriting the `graded_algebra` method does any good, unless the return value is a refinement of what it would normally be (i.e., the `AssociatedGradedAlgebra` of `self`).

For an example why preserving a contract (and having a contract in the first place) is important, let's recall that `gr` is a functor. In fact, every filtration-preserving map `f : A -> B` of filtered modules induces a graded map `gr f : gr A -> gr B` of the associated gradeds. This map `gr f` sends the residue class of any `a \in F_n(A)` (this means the `n`-th filtered part of `A`) to the residue class of `f(a) \in F_n(B)`. (This is *not* the map that would be obtained by composing the canonical iso `gr A -> A` with `f : A -> B` and then with the canonical iso `B -> gr B` when `A` and `B` are graded with basis. It is defined even without bases.) How would we implement this (on filtered modules or algebras with basis)? I would proceed like this:


```
def induced_graded_map(self, other, f):
    r"""
    Return the graded linear map ``self`` `\to` ``other`` canonically
    induced by a linear map `f` from the filtered module whose
    associated graded module is ``self`` to the filtered module whose
    associated graded module is ``other``.

    [...]

    """
    # not tested
    A = self._A # This requires ``self`` to have a ``_A`` attribute,
                # which must be part of the contract.
    def on_basis(m):
        i = self.degree_on_basis(m)
        # This needs a ``degree_on_basis`` method on ``self``.
        return other.projection(i)(f(A.monomial(m)))
        # This needs the ``projection`` method to exist on
        # ``other``.
        # This assumes that the basis element of ``A`` indexed
        # by ``m`` is a lift of the basis element of ``self``
        # indexed by ``m``. This is a fairly harmless assumption.
    return self.module_morphism(on_basis=on_basis,
                                codomain=other, category=self.category())
    """
```


This is a piece of code so basic and general that it should be in `associated_graded.py`. But if we start redefining `graded_algebra` in ways that remove its `_A` attribute, its `projection` method and whatever else, then this code breaks.

I suck at Python OOP; do you know a way to take an existing instance of `AssociatedGraded` and add some methods to it? If this is possible, then I think this is what overrides of `graded_algebra` should be doing. For instance, the graded algebra of a Clifford algebra should be its `AssociatedGraded`, but with a coercion to and from the exterior algebra.



---

archive/issue_comments_222951.json:
```json
{
    "body": "Don't forget that code like this (which initializes default categories):\n\n```\n+ if graded:\n+     category = AlgebrasWithBasis(R).Graded()\n+ else:\n+     category = AlgebrasWithBasis(R).Filtered()\n```\n\nshould do instead `AlgebrasWithBasis(R.category())` to avoid a certain source of memory leaks: categories are immortal, so you should avoid making potentially arbitrarily many of them as much as possible. See:\n\n```\nsage: GF(3)['x'].category()\nJoin of Category of euclidean domains and Category of commutative algebras over (finite fields and subquotients of monoids and quotients of semigroups)\n```\n\nOnce someone asks for `[AlgebrasWithBasis(GF(p)): p in prime_range(2,100000)]` they're in it by choice, but by default we should not be making categories that explicitly refer to parametrized quantities. We can store those in the parents themselves, where avoiding memory leaks is hard enough. The design of categories simply didn't take into account that they might need to be collected again.\n\nSee #17360 for a similar category initialization problem.",
    "created_at": "2014-11-18T00:03:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222951",
    "user": "https://github.com/nbruin"
}
```

Don't forget that code like this (which initializes default categories):

```
+ if graded:
+     category = AlgebrasWithBasis(R).Graded()
+ else:
+     category = AlgebrasWithBasis(R).Filtered()
```

should do instead `AlgebrasWithBasis(R.category())` to avoid a certain source of memory leaks: categories are immortal, so you should avoid making potentially arbitrarily many of them as much as possible. See:

```
sage: GF(3)['x'].category()
Join of Category of euclidean domains and Category of commutative algebras over (finite fields and subquotients of monoids and quotients of semigroups)
```

Once someone asks for `[AlgebrasWithBasis(GF(p)): p in prime_range(2,100000)]` they're in it by choice, but by default we should not be making categories that explicitly refer to parametrized quantities. We can store those in the parents themselves, where avoiding memory leaks is hard enough. The design of categories simply didn't take into account that they might need to be collected again.

See #17360 for a similar category initialization problem.



---

archive/issue_comments_222952.json:
```json
{
    "body": "A few questions and comments: \n\n- in `filtered_modules.py`, it talks about modules over a commutative ring, but the word \"commutative\" can be deleted, I think.\n- in the same file, it says\n\n```\n.. TODO::\n\n    Implement a notion for decreasing filtrations: where `F_j \\subseteq F_i`.\n```\n\n If you want to keep this remark, then you should add \"when i \\leq j\". But do you need to keep this? If you want a decreasing filtration, just use the non-positive integers for your indexing set instead of non-negative integers. For example, if you have an algebra `A` and an ideal `I`, then you can set `F_{-n}A` equal to the `n`th power of `I`. Then you have `F_0 \\supseteq F_{-1} \\supseteq F_{-2} \\supseteq ...`: a decreasing filtration.\n- How could we implement an algebra which is both graded and filtered? This is the situation for the Steenrod algebra, for example.",
    "created_at": "2014-11-18T00:27:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222952",
    "user": "https://github.com/jhpalmieri"
}
```

A few questions and comments: 

- in `filtered_modules.py`, it talks about modules over a commutative ring, but the word "commutative" can be deleted, I think.
- in the same file, it says

```
.. TODO::

    Implement a notion for decreasing filtrations: where `F_j \subseteq F_i`.
```

 If you want to keep this remark, then you should add "when i \leq j". But do you need to keep this? If you want a decreasing filtration, just use the non-positive integers for your indexing set instead of non-negative integers. For example, if you have an algebra `A` and an ideal `I`, then you can set `F_{-n}A` equal to the `n`th power of `I`. Then you have `F_0 \supseteq F_{-1} \supseteq F_{-2} \supseteq ...`: a decreasing filtration.
- How could we implement an algebra which is both graded and filtered? This is the situation for the Steenrod algebra, for example.



---

archive/issue_comments_222953.json:
```json
{
    "body": "I have edited my latest reply.\n\nIn other news, is it guaranteed that every instance of `FilteredAlgebrasWithBasis` is a subcategory of `FilteredModulesWithBasis`? If so, I suggest moving the `ElementMethods` `is_homogeneous`, `homogeneous_degree`, `degree` and `maximal_degree` out of the algebras class and into the modules class (merging their doctests in case both exist).\n\nThe associated-graded construction should also be defined for modules rather than algebras; the algebras version should be a refinement that additionally gives a multiplication and a unity. Can this be implemented easily in your framework, Travis?",
    "created_at": "2014-11-18T01:20:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222953",
    "user": "https://github.com/darijgr"
}
```

I have edited my latest reply.

In other news, is it guaranteed that every instance of `FilteredAlgebrasWithBasis` is a subcategory of `FilteredModulesWithBasis`? If so, I suggest moving the `ElementMethods` `is_homogeneous`, `homogeneous_degree`, `degree` and `maximal_degree` out of the algebras class and into the modules class (merging their doctests in case both exist).

The associated-graded construction should also be defined for modules rather than algebras; the algebras version should be a refinement that additionally gives a multiplication and a unity. Can this be implemented easily in your framework, Travis?



---

archive/issue_comments_222954.json:
```json
{
    "body": "`@`darij\nI really don't like the restrictions of this contract you want to impose; it's too restrictive. It should not take a new *class* to do something which is mathematically trivial (by our current implementation of an implicit filtration). IMO, the better way to do things is to implement additional methods in the category for the projections (similar to `truncate`) since the methods only use the `degree` methods. Also I think requesting a conversion for the returned object `graded_algebra` is fine, but not making it a requirement.\n\nAs for the induced morphisms, we might actually want to make the method a functor object. This I think will solve many of the issues you want to do with contracts.\n\nAll I wanted with the `AssociatedGradedAlgebra` class was to prove a generic implementation do to the computations and the method `graded_algebra` just to return an object which *is* the associated graded algebra. My implementation of `AssociatedGradedAlgebra` just happens to have the need for the extra data.\n\nEvery `FilteredAlgebrasWithBasis` is a subcategory of `FilteredModulesWithBasis`. I'm okay with this move. If we use methods (instead of contracts) at the `FilteredModules` level (perhaps `WithBasis`), then we could implement a very lightweight class for this, but I'm worried about having the extra burden of methods that only are really useful for modules (and get superseded for \"better\" named methods). Although if we use a functor to do the construction, then I feel like we get away from all of it.\n\nHowever I feel that much of this should be done on followup ticket(s) as getting the basic framework into Sage can be split and doesn't need the full features to be useful.\n\n`@`jhpalmieri\nI'll make those changes. However we can't get a descending filtration unless the grading set can be negated. As for algebras that are both filtered and graded, it's the same issue as when an algebra has 2 natural gradings (as we use `degree` for both filtration and grading). Although as things evolve and the filtration can be generalized from using `degree`, this can be rectified. For now, you have to choose the \"best\" one for `degree` (or have it be an optional arg like how I'm doing for Clifford algebras).\n\n`@`nbruin\nWill fix. Forgot that the categories are not collectible.",
    "created_at": "2014-11-18T04:49:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222954",
    "user": "https://github.com/tscrim"
}
```

`@`darij
I really don't like the restrictions of this contract you want to impose; it's too restrictive. It should not take a new *class* to do something which is mathematically trivial (by our current implementation of an implicit filtration). IMO, the better way to do things is to implement additional methods in the category for the projections (similar to `truncate`) since the methods only use the `degree` methods. Also I think requesting a conversion for the returned object `graded_algebra` is fine, but not making it a requirement.

As for the induced morphisms, we might actually want to make the method a functor object. This I think will solve many of the issues you want to do with contracts.

All I wanted with the `AssociatedGradedAlgebra` class was to prove a generic implementation do to the computations and the method `graded_algebra` just to return an object which *is* the associated graded algebra. My implementation of `AssociatedGradedAlgebra` just happens to have the need for the extra data.

Every `FilteredAlgebrasWithBasis` is a subcategory of `FilteredModulesWithBasis`. I'm okay with this move. If we use methods (instead of contracts) at the `FilteredModules` level (perhaps `WithBasis`), then we could implement a very lightweight class for this, but I'm worried about having the extra burden of methods that only are really useful for modules (and get superseded for "better" named methods). Although if we use a functor to do the construction, then I feel like we get away from all of it.

However I feel that much of this should be done on followup ticket(s) as getting the basic framework into Sage can be split and doesn't need the full features to be useful.

`@`jhpalmieri
I'll make those changes. However we can't get a descending filtration unless the grading set can be negated. As for algebras that are both filtered and graded, it's the same issue as when an algebra has 2 natural gradings (as we use `degree` for both filtration and grading). Although as things evolve and the filtration can be generalized from using `degree`, this can be rectified. For now, you have to choose the "best" one for `degree` (or have it be an optional arg like how I'm doing for Clifford algebras).

`@`nbruin
Will fix. Forgot that the categories are not collectible.



---

archive/issue_comments_222955.json:
```json
{
    "body": "> I'll make those changes. However we can't get a descending filtration unless the grading set can be negated.\n\nYou can get something mathematically equivalent to a descending filtration, though, and maybe that should be good enough?\n\nI wonder if we should use `degree` for grading and `filtration` for a filtration: `x.filtration()` would return `n` if `x` is in `F_n` but not in `F_{n-1}`. For a filtered object, `degree` would default to be `filtration`, but you could override it in any specific case. (Maybe these aren't the best names, but you get the idea.)\n\nIf this is the first ticket with filtrations, at least in any systematic way, we can decide how to set it up now rather than having to fix it later.",
    "created_at": "2014-11-18T05:13:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222955",
    "user": "https://github.com/jhpalmieri"
}
```

> I'll make those changes. However we can't get a descending filtration unless the grading set can be negated.

You can get something mathematically equivalent to a descending filtration, though, and maybe that should be good enough?

I wonder if we should use `degree` for grading and `filtration` for a filtration: `x.filtration()` would return `n` if `x` is in `F_n` but not in `F_{n-1}`. For a filtered object, `degree` would default to be `filtration`, but you could override it in any specific case. (Maybe these aren't the best names, but you get the idea.)

If this is the first ticket with filtrations, at least in any systematic way, we can decide how to set it up now rather than having to fix it later.



---

archive/issue_comments_222956.json:
```json
{
    "body": "Replying to [comment:37 tscrim]:\n> `@`darij\n> I really don't like the restrictions of this contract you want to impose; it's too restrictive. It should not take a new *class* to do something which is mathematically trivial (by our current implementation of an implicit filtration). IMO, the better way to do things is to implement additional methods in the category for the projections (similar to `truncate`) since the methods only use the `degree` methods.\n\nCare to elaborate how this will work?",
    "created_at": "2014-11-18T05:20:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222956",
    "user": "https://github.com/darijgr"
}
```

Replying to [comment:37 tscrim]:
> `@`darij
> I really don't like the restrictions of this contract you want to impose; it's too restrictive. It should not take a new *class* to do something which is mathematically trivial (by our current implementation of an implicit filtration). IMO, the better way to do things is to implement additional methods in the category for the projections (similar to `truncate`) since the methods only use the `degree` methods.

Care to elaborate how this will work?



---

archive/issue_comments_222957.json:
```json
{
    "body": "Replying to [comment:39 darij]:\n> Care to elaborate how this will work?\n\nMove `to_graded_conversion`, `from_graded_conversion`, and `projection` into `FilteredModulesWithBasis`. This would have the effect of reversing the meaning of to/from, but it would make me feel better that the morphisms are tied to the domain (whereas putting them in the graded part, they would be tied to the codomain, making the maps collectible and can cause the coercion issues). Plus it gives a natural extension to `GradedModulesWithBasis` and you could use the `homogeneous_component` method to construct the `projection` method.\n\nIn fact, if we do this properly, we can have a category for algebras whose associated graded is commutative (I thought this was called something like virtually commutative, but I can't find where I saw this...) where we can use a faster generic implementation. Again, something for later.",
    "created_at": "2014-11-18T17:27:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222957",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:39 darij]:
> Care to elaborate how this will work?

Move `to_graded_conversion`, `from_graded_conversion`, and `projection` into `FilteredModulesWithBasis`. This would have the effect of reversing the meaning of to/from, but it would make me feel better that the morphisms are tied to the domain (whereas putting them in the graded part, they would be tied to the codomain, making the maps collectible and can cause the coercion issues). Plus it gives a natural extension to `GradedModulesWithBasis` and you could use the `homogeneous_component` method to construct the `projection` method.

In fact, if we do this properly, we can have a category for algebras whose associated graded is commutative (I thought this was called something like virtually commutative, but I can't find where I saw this...) where we can use a faster generic implementation. Again, something for later.



---

archive/issue_comments_222958.json:
```json
{
    "body": "Ah! This is a good idea; then `induced_graded_map` will also have to be moved to the filtered algebra class. Can you move the three methods you mentioned please? I will then implement `induced_graded_map`.\n\nSo let me get it right: The class `AssociatedGraded` is not going to be a class to be inherited from; it will plainly be the way to construct associated graded algebras if nothing better is known. The data connecting `gr(A)` to `A` will be stored on `A` rather than on `gr(A)`. I assume it makes sense to make `graded_algebra` a cached method to avoid cases where it is not `UniqueRepresentation`?\n\nAlso, could you reply to my post 36? I don't see `FilteredAlgebrasWithBasis` ever mentioning `FilteredModulesWithBasis` as a supercategory, but I guess it should, and I guess its methods should be on `FilteredModulesWithBasis` as well.",
    "created_at": "2014-11-19T06:32:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222958",
    "user": "https://github.com/darijgr"
}
```

Ah! This is a good idea; then `induced_graded_map` will also have to be moved to the filtered algebra class. Can you move the three methods you mentioned please? I will then implement `induced_graded_map`.

So let me get it right: The class `AssociatedGraded` is not going to be a class to be inherited from; it will plainly be the way to construct associated graded algebras if nothing better is known. The data connecting `gr(A)` to `A` will be stored on `A` rather than on `gr(A)`. I assume it makes sense to make `graded_algebra` a cached method to avoid cases where it is not `UniqueRepresentation`?

Also, could you reply to my post 36? I don't see `FilteredAlgebrasWithBasis` ever mentioning `FilteredModulesWithBasis` as a supercategory, but I guess it should, and I guess its methods should be on `FilteredModulesWithBasis` as well.



---

archive/issue_comments_222959.json:
```json
{
    "body": "Replying to [comment:41 darij]:\n> Ah! This is a good idea; then `induced_graded_map` will also have to be moved to the filtered algebra class. Can you move the three methods you mentioned please? I will then implement `induced_graded_map`.\n\nWill do tomorrow, but will do (plus incorporate John's and Nils' changes).\n\n> So let me get it right: The class `AssociatedGraded` is not going to be a class to be inherited from; it will plainly be the way to construct associated graded algebras if nothing better is known. The data connecting `gr(A)` to `A` will be stored on `A` rather than on `gr(A)`. I assume it makes sense to make `graded_algebra` a cached method to avoid cases where it is not `UniqueRepresentation`?\n\nYes, that's correct (although it could be subclasssed but that's not my intent when I designed it). However it doesn't need to be a cached method because everything comes along for the ride from the category (and it should return an equal object every time). Nils, does this lead to a memory leak when a ``@`cached_method` return a `UniqueRepresentation`? I think it does but I don't remember...\n\n> Also, could you reply to my post 36? I don't see `FilteredAlgebrasWithBasis` ever mentioning `FilteredModulesWithBasis` as a supercategory, but I guess it should, and I guess its methods should be on `FilteredModulesWithBasis` as well.\n\nI did in comment:37 and said it was okay with me to move the methods. It's the category and axiom magic which makes the supercategory property hold.",
    "created_at": "2014-11-19T07:02:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222959",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:41 darij]:
> Ah! This is a good idea; then `induced_graded_map` will also have to be moved to the filtered algebra class. Can you move the three methods you mentioned please? I will then implement `induced_graded_map`.

Will do tomorrow, but will do (plus incorporate John's and Nils' changes).

> So let me get it right: The class `AssociatedGraded` is not going to be a class to be inherited from; it will plainly be the way to construct associated graded algebras if nothing better is known. The data connecting `gr(A)` to `A` will be stored on `A` rather than on `gr(A)`. I assume it makes sense to make `graded_algebra` a cached method to avoid cases where it is not `UniqueRepresentation`?

Yes, that's correct (although it could be subclasssed but that's not my intent when I designed it). However it doesn't need to be a cached method because everything comes along for the ride from the category (and it should return an equal object every time). Nils, does this lead to a memory leak when a ``@`cached_method` return a `UniqueRepresentation`? I think it does but I don't remember...

> Also, could you reply to my post 36? I don't see `FilteredAlgebrasWithBasis` ever mentioning `FilteredModulesWithBasis` as a supercategory, but I guess it should, and I guess its methods should be on `FilteredModulesWithBasis` as well.

I did in comment:37 and said it was okay with me to move the methods. It's the category and axiom magic which makes the supercategory property hold.



---

archive/issue_comments_222960.json:
```json
{
    "body": "Replying to [comment:42 tscrim]:\n> Yes, that's correct (although it could be subclasssed but that's not my intent when I designed it). However it doesn't need to be a cached method because everything comes along for the ride from the category (and it should return an equal object every time).\n\nCare to explain this? I'm still a newbie to memory handling, so I might be missing more of the context than you expect. My worry was that every time `A.graded_algebra()` is called (and it will be called a lot, say, from the `to_graded_conversion` and `projection` methods), a new instance of this algebra is created, which takes time and space and might require additional work to make these instances coerce to each other nicely (I guess they will do so themselves automatically, but e.g. their polynomial rings might not).\n\nAlso, should I then explain in the doc that everybody who overshadows `graded_algebra` must also overshadow `projection`, `to_graded_conversion` and `from_graded_conversion`?\n\n> I did in comment:37 and said it was okay with me to move the methods. It's the category and axiom magic which makes the supercategory property hold.\n\nGreat -- as long as this magic doesn't force every algebra which happens to be filtered as a module to automatically be considered a filtered algebra.",
    "created_at": "2014-11-19T17:26:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222960",
    "user": "https://github.com/darijgr"
}
```

Replying to [comment:42 tscrim]:
> Yes, that's correct (although it could be subclasssed but that's not my intent when I designed it). However it doesn't need to be a cached method because everything comes along for the ride from the category (and it should return an equal object every time).

Care to explain this? I'm still a newbie to memory handling, so I might be missing more of the context than you expect. My worry was that every time `A.graded_algebra()` is called (and it will be called a lot, say, from the `to_graded_conversion` and `projection` methods), a new instance of this algebra is created, which takes time and space and might require additional work to make these instances coerce to each other nicely (I guess they will do so themselves automatically, but e.g. their polynomial rings might not).

Also, should I then explain in the doc that everybody who overshadows `graded_algebra` must also overshadow `projection`, `to_graded_conversion` and `from_graded_conversion`?

> I did in comment:37 and said it was okay with me to move the methods. It's the category and axiom magic which makes the supercategory property hold.

Great -- as long as this magic doesn't force every algebra which happens to be filtered as a module to automatically be considered a filtered algebra.



---

archive/issue_comments_222961.json:
```json
{
    "body": "Replying to [comment:42 tscrim]:\n\n> Yes, that's correct (although it could be subclasssed but that's not my intent when I designed it). However it doesn't need to be a cached method because everything comes along for the ride from the category (and it should return an equal object every time). Nils, does this lead to a memory leak when a ``@`cached_method` return a `UniqueRepresentation`? I think it does but I don't remember...\n\nQuite possibly. See [#14356 comment 6](http://trac.sagemath.org/ticket/14356#comment:6) and\n[https://groups.google.com/forum/#!msg/sage-devel/q5uy_lI11jg/CB15fcRmE4cJ](https://groups.google.com/forum/#!msg/sage-devel/q5uy_lI11jg/CB15fcRmE4cJ)\n\nThe main thing to watch out for is caching on an object A a UniqueRepresentation object B that has A as a construction parameter.\n\nAs pointed out in the referenced comment, one is usually in the clear if the construction parameters of a UniqueRepresentation are fundamentally simpler than the object itself. I'd say that fails for AssociatedGradedAlgebra if that takes an algebra it's isomorphic to as an ungraded algebra as construction parameter! I would consider making it a factory and construct from only the base ring, generator names, grading information etc. and then link it via the coercion framework/cached methods. Then at least it's clear that strong references are held locally. It's important to realize that UniqueRepresentation has a serious cost associated with it.",
    "created_at": "2014-11-19T22:05:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222961",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:42 tscrim]:

> Yes, that's correct (although it could be subclasssed but that's not my intent when I designed it). However it doesn't need to be a cached method because everything comes along for the ride from the category (and it should return an equal object every time). Nils, does this lead to a memory leak when a ``@`cached_method` return a `UniqueRepresentation`? I think it does but I don't remember...

Quite possibly. See [#14356 comment 6](http://trac.sagemath.org/ticket/14356#comment:6) and
[https://groups.google.com/forum/#!msg/sage-devel/q5uy_lI11jg/CB15fcRmE4cJ](https://groups.google.com/forum/#!msg/sage-devel/q5uy_lI11jg/CB15fcRmE4cJ)

The main thing to watch out for is caching on an object A a UniqueRepresentation object B that has A as a construction parameter.

As pointed out in the referenced comment, one is usually in the clear if the construction parameters of a UniqueRepresentation are fundamentally simpler than the object itself. I'd say that fails for AssociatedGradedAlgebra if that takes an algebra it's isomorphic to as an ungraded algebra as construction parameter! I would consider making it a factory and construct from only the base ring, generator names, grading information etc. and then link it via the coercion framework/cached methods. Then at least it's clear that strong references are held locally. It's important to realize that UniqueRepresentation has a serious cost associated with it.



---

archive/issue_comments_222962.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-19T23:55:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222962",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222963.json:
```json
{
    "body": "Replying to [comment:43 darij]:\n> Care to explain this? I'm still a newbie to memory handling, so I might be missing more of the context than you expect. My worry was that every time `A.graded_algebra()` is called (and it will be called a lot, say, from the `to_graded_conversion` and `projection` methods), a new instance of this algebra is created, which takes time and space and might require additional work to make these instances coerce to each other nicely (I guess they will do so themselves automatically, but e.g. their polynomial rings might not).\n\nSee Nils comment for the memory. Short version is you get a reference loop `A -> grA` and `grA -> A` such that `A` is stored as a global strong reference (making it uncollectible). I opted to make the output of `graded_algebra` be a non-`cached_method` as the `UniqueRepresentation` of `AssociatedGradedAlgebra` will make sure it's extremely rarely (re)created (and because I need the filtered algebra to do the computations, so it has to be part of the construction data). As this will likely be what gets created, we don't have to worry about this (and most parents will end up being UR's). If the user creates a non-UR parent for the assoc. gr., then they have to override `graded_algebra` anyways and can make it a cached method.\n\n> Also, should I then explain in the doc that everybody who overshadows `graded_algebra` must also overshadow `projection`, `to_graded_conversion` and `from_graded_conversion`?\n\nI don't think these methods would need to be overwritten as they are completely generic.\n\n> Great -- as long as this magic doesn't force every algebra which happens to be filtered as a module to automatically be considered a filtered algebra.\n\nI think that gets into the issue (and is related with John's comment) with what do for filtrations in general. I want to use `degree` for the filtration parameter so we don't have to duplicate code, it's natural for graded modules/algebras, and which filtration component is not well-defined (most elements belong to multiple, possibly infinite, F<sub>i</sub> components). Overall, we will need a framework for construction of general filtrations, but I don't think we can do that at the category level. What will probably be best (a quick thought) is to have a method `filtration` which returns the filtration of the module/algebra as a `Family` of submodules indexed by `I`. However we will still need a method `degree` to be computationally quick. This would allow filtrations different from the grading in a way and perhaps we could add a method to the graded categories such as `filtration_degree` which by default returns the usual degree. Anyways, I think about more later.",
    "created_at": "2014-11-20T00:10:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222963",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:43 darij]:
> Care to explain this? I'm still a newbie to memory handling, so I might be missing more of the context than you expect. My worry was that every time `A.graded_algebra()` is called (and it will be called a lot, say, from the `to_graded_conversion` and `projection` methods), a new instance of this algebra is created, which takes time and space and might require additional work to make these instances coerce to each other nicely (I guess they will do so themselves automatically, but e.g. their polynomial rings might not).

See Nils comment for the memory. Short version is you get a reference loop `A -> grA` and `grA -> A` such that `A` is stored as a global strong reference (making it uncollectible). I opted to make the output of `graded_algebra` be a non-`cached_method` as the `UniqueRepresentation` of `AssociatedGradedAlgebra` will make sure it's extremely rarely (re)created (and because I need the filtered algebra to do the computations, so it has to be part of the construction data). As this will likely be what gets created, we don't have to worry about this (and most parents will end up being UR's). If the user creates a non-UR parent for the assoc. gr., then they have to override `graded_algebra` anyways and can make it a cached method.

> Also, should I then explain in the doc that everybody who overshadows `graded_algebra` must also overshadow `projection`, `to_graded_conversion` and `from_graded_conversion`?

I don't think these methods would need to be overwritten as they are completely generic.

> Great -- as long as this magic doesn't force every algebra which happens to be filtered as a module to automatically be considered a filtered algebra.

I think that gets into the issue (and is related with John's comment) with what do for filtrations in general. I want to use `degree` for the filtration parameter so we don't have to duplicate code, it's natural for graded modules/algebras, and which filtration component is not well-defined (most elements belong to multiple, possibly infinite, F<sub>i</sub> components). Overall, we will need a framework for construction of general filtrations, but I don't think we can do that at the category level. What will probably be best (a quick thought) is to have a method `filtration` which returns the filtration of the module/algebra as a `Family` of submodules indexed by `I`. However we will still need a method `degree` to be computationally quick. This would allow filtrations different from the grading in a way and perhaps we could add a method to the graded categories such as `filtration_degree` which by default returns the usual degree. Anyways, I think about more later.



---

archive/issue_comments_222964.json:
```json
{
    "body": "Replying to [comment:46 tscrim]:\n> > Also, should I then explain in the doc that everybody who overshadows `graded_algebra` must also overshadow `projection`, `to_graded_conversion` and `from_graded_conversion`?\n> \n> I don't think these methods would need to be overwritten as they are completely generic.\n\nWhat do you mean by this?\n\nAnyway, should I continue the review or are you still working on the changes?",
    "created_at": "2014-11-21T04:36:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222964",
    "user": "https://github.com/darijgr"
}
```

Replying to [comment:46 tscrim]:
> > Also, should I then explain in the doc that everybody who overshadows `graded_algebra` must also overshadow `projection`, `to_graded_conversion` and `from_graded_conversion`?
> 
> I don't think these methods would need to be overwritten as they are completely generic.

What do you mean by this?

Anyway, should I continue the review or are you still working on the changes?



---

archive/issue_comments_222965.json:
```json
{
    "body": "Replying to [comment:47 darij]:\n> Replying to [comment:46 tscrim]:\n> > I don't think these methods would need to be overwritten as they are completely generic.\n> \n> What do you mean by this?\n\nI mean we only need the methods defined in the category, so it's generic in that sense (i.e. independent of implementation).\n\n> Anyway, should I continue the review or are you still working on the changes?\n\nI'm done making changes; please continue.",
    "created_at": "2014-11-21T06:39:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222965",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:47 darij]:
> Replying to [comment:46 tscrim]:
> > I don't think these methods would need to be overwritten as they are completely generic.
> 
> What do you mean by this?

I mean we only need the methods defined in the category, so it's generic in that sense (i.e. independent of implementation).

> Anyway, should I continue the review or are you still working on the changes?

I'm done making changes; please continue.



---

archive/issue_comments_222966.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-24T01:55:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222966",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222967.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-24T03:55:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222967",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222968.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-24T04:10:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222968",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222969.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-24T04:25:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222969",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222970.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-24T04:29:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222970",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222971.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-24T05:53:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222971",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222972.json:
```json
{
    "body": "Done for today. I'll add some more doctests tomorrow and hopefully get to read through the rest of the files, although I'd much prefer if you get rid of some of the TODOs beforehand. I'll then try to generalize `graded_algebra` and `AssociatedGraded` to filtered modules (not just filtered algebras); IMHO this is a highly natural step to do.\n\nIf the Clifford issues become too complicated, what do you think of splitting this patch into a general filtrations one and a Clifford one? I see nontrivial work ahead in both of them, so a split would speed up the merge of the general code.",
    "created_at": "2014-11-24T05:53:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222972",
    "user": "https://github.com/darijgr"
}
```

Done for today. I'll add some more doctests tomorrow and hopefully get to read through the rest of the files, although I'd much prefer if you get rid of some of the TODOs beforehand. I'll then try to generalize `graded_algebra` and `AssociatedGraded` to filtered modules (not just filtered algebras); IMHO this is a highly natural step to do.

If the Clifford issues become too complicated, what do you think of splitting this patch into a general filtrations one and a Clifford one? I see nontrivial work ahead in both of them, so a split would speed up the merge of the general code.



---

archive/issue_comments_222973.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-24T16:04:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222973",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222974.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-24T16:14:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222974",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222975.json:
```json
{
    "body": "Another issue with the Clifford-Weyl part of this patch: The Clifford algebra is graded by default, whereas the Weyl algebra is graded by default. There is no reason why there should be different behavior here; the Weyl algebra is Z/2-graded as much as the Clifford one is.",
    "created_at": "2014-11-24T16:17:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222975",
    "user": "https://github.com/darijgr"
}
```

Another issue with the Clifford-Weyl part of this patch: The Clifford algebra is graded by default, whereas the Weyl algebra is graded by default. There is no reason why there should be different behavior here; the Weyl algebra is Z/2-graded as much as the Clifford one is.



---

archive/issue_comments_222976.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2014-11-24T16:37:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222976",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222977.json:
```json
{
    "body": "Enough for now (FPSAC deadline is approaching). I have now checked all of the non-Clifford/Weyl part of this patch, and here is all that I'd like to be done before the merge of this part:\n\n- TODO: Formulate an interface and a contract for `FilteredModulesWithBasis` objects. Is a `CombinatorialFreeModule` with a `degree_on_basis` method enough? Or is `basis` still needed? (See the `FIXME` in `src/sage/categories/examples/filtered_modules_with_basis.py`.)\n\n- TODO: Make sense of `A.basis(d)` for `A` a filtered module and `d` an integer. This has always been broken and we can leave it for later, but it then needs a trac ticket.\n\n- TODO: doctesting `A.basis(d)` for `A` graded. Very easy once above is fixed.\n\n- TODO: overriding the `to_graded_conversion`, `from_graded_conversion` and `projection` methods on graded algebras for the sake of speed, or deciding not to. [EDIT: This would be difficult with the current design.]\n\n- [DONE:] Generalizing `graded_algebra` to modules. This doesn't seem too difficult; I am in favor of keeping the name \"associated graded *algebra*\" even for modules, as it seems to have a ring to it that algebraists recognize, but maybe some discussion is in order.\n\nOn the Clifford/Weyl front, I'll review it once you deal with the TODOs and the Clifford-Weyl mismatch; the changes IMHO are nontrivial enough (and orthogonal to the categories themselves) to warrant an extra ticket. (I'll need to check through all the methods in the two files.)",
    "created_at": "2014-11-24T16:49:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222977",
    "user": "https://github.com/darijgr"
}
```

Enough for now (FPSAC deadline is approaching). I have now checked all of the non-Clifford/Weyl part of this patch, and here is all that I'd like to be done before the merge of this part:

- TODO: Formulate an interface and a contract for `FilteredModulesWithBasis` objects. Is a `CombinatorialFreeModule` with a `degree_on_basis` method enough? Or is `basis` still needed? (See the `FIXME` in `src/sage/categories/examples/filtered_modules_with_basis.py`.)

- TODO: Make sense of `A.basis(d)` for `A` a filtered module and `d` an integer. This has always been broken and we can leave it for later, but it then needs a trac ticket.

- TODO: doctesting `A.basis(d)` for `A` graded. Very easy once above is fixed.

- TODO: overriding the `to_graded_conversion`, `from_graded_conversion` and `projection` methods on graded algebras for the sake of speed, or deciding not to. [EDIT: This would be difficult with the current design.]

- [DONE:] Generalizing `graded_algebra` to modules. This doesn't seem too difficult; I am in favor of keeping the name "associated graded *algebra*" even for modules, as it seems to have a ring to it that algebraists recognize, but maybe some discussion is in order.

On the Clifford/Weyl front, I'll review it once you deal with the TODOs and the Clifford-Weyl mismatch; the changes IMHO are nontrivial enough (and orthogonal to the categories themselves) to warrant an extra ticket. (I'll need to check through all the methods in the two files.)



---

archive/issue_comments_222978.json:
```json
{
    "body": "Replying to [comment:37 tscrim]:\n> `@`jhpalmieri\n> I'll make those changes. However we can't get a descending filtration unless the grading set can be negated. As for algebras that are both filtered and graded, it's the same issue as when an algebra has 2 natural gradings (as we use `degree` for both filtration and grading). Although as things evolve and the filtration can be generalized from using `degree`, this can be rectified. For now, you have to choose the \"best\" one for `degree` (or have it be an optional arg like how I'm doing for Clifford algebras).\n\nI still don't understand this design choice. Why not separate filtrations and gradings? A graded object without additional filtration could still be considered to be filtered (by having the filtration method default to calling `degree`), but this wouldn't have to be the only choice.\n\nReplying to [comment:60 darij]:\n\n> Generalizing graded_algebra to modules. This doesn't seem too difficult; I am in favor of keeping the name \"associated graded *algebra*\" even for modules, as it seems to have a ring to it that algebraists recognize, but maybe some discussion is in order. \n\n\"Have a ring to it\". Heh.\n\nI would object to calling a module an \"algebra\" if there is no multiplicative structure. \"Associated graded module\" is just fine, or \"associated graded object\" more generally.",
    "created_at": "2014-11-24T22:06:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222978",
    "user": "https://github.com/jhpalmieri"
}
```

Replying to [comment:37 tscrim]:
> `@`jhpalmieri
> I'll make those changes. However we can't get a descending filtration unless the grading set can be negated. As for algebras that are both filtered and graded, it's the same issue as when an algebra has 2 natural gradings (as we use `degree` for both filtration and grading). Although as things evolve and the filtration can be generalized from using `degree`, this can be rectified. For now, you have to choose the "best" one for `degree` (or have it be an optional arg like how I'm doing for Clifford algebras).

I still don't understand this design choice. Why not separate filtrations and gradings? A graded object without additional filtration could still be considered to be filtered (by having the filtration method default to calling `degree`), but this wouldn't have to be the only choice.

Replying to [comment:60 darij]:

> Generalizing graded_algebra to modules. This doesn't seem too difficult; I am in favor of keeping the name "associated graded *algebra*" even for modules, as it seems to have a ring to it that algebraists recognize, but maybe some discussion is in order. 

"Have a ring to it". Heh.

I would object to calling a module an "algebra" if there is no multiplicative structure. "Associated graded module" is just fine, or "associated graded object" more generally.



---

archive/issue_comments_222979.json:
```json
{
    "body": "Replying to [comment:61 jhpalmieri]:\n> I still don't understand this design choice. Why not separate filtrations and gradings? A graded object without additional filtration could still be considered to be filtered (by having the filtration method default to calling `degree`), but this wouldn't have to be the only choice.\n\nHow do you suggest separating them?\n\n(In a better language, there would be a way to handle this using some kind of aliases. Note that there are many modules and algebras in nature having multiple filtrations, so just creating a slot for a grading and a slot for filtrations doesn't seem like a scalable solution to me.)\n\n`@`nbruin: I only really digested your post right now. So my changes do cause memleaks. OK, nothing easier than removing some `@`cached_method decorators. But... can you look at the code for `induced_graded_map` and tell me how to avoid having it re-construct the `other.projection(i)` method every time I call its return value? (And while the ass. gr. algebra itself might be UniqueRepresentations, things like the `projection` map are not unless we hash them.)",
    "created_at": "2014-11-24T23:45:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222979",
    "user": "https://github.com/darijgr"
}
```

Replying to [comment:61 jhpalmieri]:
> I still don't understand this design choice. Why not separate filtrations and gradings? A graded object without additional filtration could still be considered to be filtered (by having the filtration method default to calling `degree`), but this wouldn't have to be the only choice.

How do you suggest separating them?

(In a better language, there would be a way to handle this using some kind of aliases. Note that there are many modules and algebras in nature having multiple filtrations, so just creating a slot for a grading and a slot for filtrations doesn't seem like a scalable solution to me.)

`@`nbruin: I only really digested your post right now. So my changes do cause memleaks. OK, nothing easier than removing some `@`cached_method decorators. But... can you look at the code for `induced_graded_map` and tell me how to avoid having it re-construct the `other.projection(i)` method every time I call its return value? (And while the ass. gr. algebra itself might be UniqueRepresentations, things like the `projection` map are not unless we hash them.)



---

archive/issue_comments_222980.json:
```json
{
    "body": "When you initialize a filtered object, you could pass an argument saying how it is filtered:\n\n```\nFilteredObject(A, filtration=fcn)\n```\n\nwhere `A` is an object and `fcn` is a function which takes an element of `A` as input and returns an element of the filtering monoid. (Change 'object' to 'algebra', 'module', 'group', 'ring', throughout if you'd rather.) So a simple example could be\n\n```\nFilteredObject(A, filtration=degree)\n```\n\nbut you could also have\n\n```\nFilteredObject(A, filtration=smith_filtration)\nFilteredObject(A, filtration=lambda x: 2 + 3*x.jones_filtration())\nFilteredObject(A, filtration=lambda x: 0 if x.is_zero() else Infinity)\n...\n```\n\nOne point is that, even if an object has many possible filtrations, when you consider it as a filtered object, you are at that point choosing a filtration. It's like the difference between a `Module` and a `ModuleWithBasis`. I guess I should have called this `ObjectWithFiltration` instead? Anyway, it's not `FilterableObject`, allowing for multiple possible filtrations, it's `FilteredObject`.\n\nIf the `filtration` keyword is missing, then perhaps first you see if the `Element` class has a `filtration` method, and if not, you see if it has a `degree` method.",
    "created_at": "2014-11-25T00:13:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222980",
    "user": "https://github.com/jhpalmieri"
}
```

When you initialize a filtered object, you could pass an argument saying how it is filtered:

```
FilteredObject(A, filtration=fcn)
```

where `A` is an object and `fcn` is a function which takes an element of `A` as input and returns an element of the filtering monoid. (Change 'object' to 'algebra', 'module', 'group', 'ring', throughout if you'd rather.) So a simple example could be

```
FilteredObject(A, filtration=degree)
```

but you could also have

```
FilteredObject(A, filtration=smith_filtration)
FilteredObject(A, filtration=lambda x: 2 + 3*x.jones_filtration())
FilteredObject(A, filtration=lambda x: 0 if x.is_zero() else Infinity)
...
```

One point is that, even if an object has many possible filtrations, when you consider it as a filtered object, you are at that point choosing a filtration. It's like the difference between a `Module` and a `ModuleWithBasis`. I guess I should have called this `ObjectWithFiltration` instead? Anyway, it's not `FilterableObject`, allowing for multiple possible filtrations, it's `FilteredObject`.

If the `filtration` keyword is missing, then perhaps first you see if the `Element` class has a `filtration` method, and if not, you see if it has a `degree` method.



---

archive/issue_comments_222981.json:
```json
{
    "body": "How is that any different for objects with multiple natural gradings? The point I'm trying to make is `GradedAlgebra` is not an algebra that has *some* grading (all algebras have a trivial grading), but that they have a *distinguished* grading, just like (`FiniteDimensional`)`AlgebrasWithBasis` are algebras with a distinguished basis (can replace grading by filtered).\n\nThe main reason why I chose to use `grading` is so we don't have to duplicate all of the code for graded algebras but just replacing `degree` by `smallest_filtered_component` (or whatever name you want to call it).\n\nFor the Clifford algebras, we don't yet have the category framework in place (I know how I want to do it, but I haven't done so yet). Perhaps it is a bad choice to give Clifford algebras that option right now for the future outlook. Also now that we have the filtered algebras, we don't need the graded algebras to get extra features.\n\nThis relates to John's suggestion, and that we probably need something at the *class* level, not the *category* level which is what this ticket is about, which set's the degree function. I want to stress that the category has a distinguished filtration/grading (perhaps I forgot to reflect this in the documentation).\n\nI will take a more detailed look at all of the changes later tonight.",
    "created_at": "2014-11-25T01:24:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222981",
    "user": "https://github.com/tscrim"
}
```

How is that any different for objects with multiple natural gradings? The point I'm trying to make is `GradedAlgebra` is not an algebra that has *some* grading (all algebras have a trivial grading), but that they have a *distinguished* grading, just like (`FiniteDimensional`)`AlgebrasWithBasis` are algebras with a distinguished basis (can replace grading by filtered).

The main reason why I chose to use `grading` is so we don't have to duplicate all of the code for graded algebras but just replacing `degree` by `smallest_filtered_component` (or whatever name you want to call it).

For the Clifford algebras, we don't yet have the category framework in place (I know how I want to do it, but I haven't done so yet). Perhaps it is a bad choice to give Clifford algebras that option right now for the future outlook. Also now that we have the filtered algebras, we don't need the graded algebras to get extra features.

This relates to John's suggestion, and that we probably need something at the *class* level, not the *category* level which is what this ticket is about, which set's the degree function. I want to stress that the category has a distinguished filtration/grading (perhaps I forgot to reflect this in the documentation).

I will take a more detailed look at all of the changes later tonight.



---

archive/issue_comments_222982.json:
```json
{
    "body": "Replying to [comment:62 darij]:\n\n> `@`nbruin: I only really digested your post right now. So my changes do cause memleaks. OK, nothing easier than removing some `@`cached_method decorators. But... can you look at the code for `induced_graded_map` and tell me how to avoid having it re-construct the `other.projection(i)` method every time I call its return value? (And while the ass. gr. algebra itself might be UniqueRepresentations, things like the `projection` map are not unless we hash them.)\n\nYes, that's tricky. I didn't read the code in detail, but in general I would expect that with caching maps on objects that use each other as construction parameters, you do end up with the problematic reference cycles, rooted in a global cache reference.\n\nIf your projection can somehow be obtained as a coercion/conversion you may be able to lift on the effort that went in there (internally, those maps drop their reference to the domain now. Since they are normally cached on the codomain, that seems to usually be enough to break cycles).\n\nI don't have a proof of the following, but conceptually it seems reasonable to me that you can choose one of the following approaches, but that mixing them will lead to memory leaks:\n- either you express the relation between objects by using one as a UniqueRepresentation parameter for the other and you rely entirely on that relation to tie the objects together\n- or you manage the link yourself, by caching stuff on the objects. In the latter case, you should *not* let any of the globally cached construction parameters refer to the objects involved. That will usually mean using UniqueFactory rather than UniqueRepresentation, so that you can process the keys a bit.\n\nI suspect that what we need is that there is a partial ordering on our globally cached objects, where `A<B` if `A` can occur as part of a construction cache key for `B`. Having both `A<B` and `B<A` would naturally lead to a reference cycle and hence a leak.\n\nFurthermore, if `A<B` and A holds a strong reference to B in any form then there's a leak too.\n\nFor instance `QQ` can be a construction parameter of `QQ[x]` because `QQ` does not refer to `QQ[x]` in any way (the fact that `QQ` coerces into `QQ[x]` is stored on `QQ[x]`).\n\nIn the case here, where I think we have things like `A=CommutativeAlgebra(QQ,['x','y','z'])` and `B=GradedCommutativeAlgebra(QQ,['x','y','z'])` it is not clear if we should have `A<B` or `B<A`. So I think we should have neither (the constructions above definitely don't need it) and then you're free to cache on these things in either direction, provided you don't coerce (:-)) the coercion framework into holding a reference cycle.\n\nIn hindsight I really think UniqueRepresentation is a mistaken design decision. We sort of need it for efficient coercion, though.",
    "created_at": "2014-11-25T01:37:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222982",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:62 darij]:

> `@`nbruin: I only really digested your post right now. So my changes do cause memleaks. OK, nothing easier than removing some `@`cached_method decorators. But... can you look at the code for `induced_graded_map` and tell me how to avoid having it re-construct the `other.projection(i)` method every time I call its return value? (And while the ass. gr. algebra itself might be UniqueRepresentations, things like the `projection` map are not unless we hash them.)

Yes, that's tricky. I didn't read the code in detail, but in general I would expect that with caching maps on objects that use each other as construction parameters, you do end up with the problematic reference cycles, rooted in a global cache reference.

If your projection can somehow be obtained as a coercion/conversion you may be able to lift on the effort that went in there (internally, those maps drop their reference to the domain now. Since they are normally cached on the codomain, that seems to usually be enough to break cycles).

I don't have a proof of the following, but conceptually it seems reasonable to me that you can choose one of the following approaches, but that mixing them will lead to memory leaks:
- either you express the relation between objects by using one as a UniqueRepresentation parameter for the other and you rely entirely on that relation to tie the objects together
- or you manage the link yourself, by caching stuff on the objects. In the latter case, you should *not* let any of the globally cached construction parameters refer to the objects involved. That will usually mean using UniqueFactory rather than UniqueRepresentation, so that you can process the keys a bit.

I suspect that what we need is that there is a partial ordering on our globally cached objects, where `A<B` if `A` can occur as part of a construction cache key for `B`. Having both `A<B` and `B<A` would naturally lead to a reference cycle and hence a leak.

Furthermore, if `A<B` and A holds a strong reference to B in any form then there's a leak too.

For instance `QQ` can be a construction parameter of `QQ[x]` because `QQ` does not refer to `QQ[x]` in any way (the fact that `QQ` coerces into `QQ[x]` is stored on `QQ[x]`).

In the case here, where I think we have things like `A=CommutativeAlgebra(QQ,['x','y','z'])` and `B=GradedCommutativeAlgebra(QQ,['x','y','z'])` it is not clear if we should have `A<B` or `B<A`. So I think we should have neither (the constructions above definitely don't need it) and then you're free to cache on these things in either direction, provided you don't coerce (:-)) the coercion framework into holding a reference cycle.

In hindsight I really think UniqueRepresentation is a mistaken design decision. We sort of need it for efficient coercion, though.



---

archive/issue_comments_222983.json:
```json
{
    "body": "`@`nbruin: Thanks for the explanations. So it is what I feared. Someone please remove the `@`cached_methods; it appears there is no easy way to get rid of the performance issues.\n\nCaching these maps relating A to gr(A) on gr(A) was my first idea (and I think Travis wanted to implement them as conversions), but it conflicts with Travis's design decision (which is a good one!) to allow overriding `graded_algebra` with simpler stuff than the default `AssociatedGraded` construction. Many different complicated algebras A will end up having the same simple gr(A) (for example, for every universal enveloping algebra A = U(g) of a Lie algebra g over a field, we have gr(A) \\cong S(g)), and gr(A) is not supposed to \"know\" anything about A. Overriding `_element_constructor` of gr(A) would be messy and unscalable.",
    "created_at": "2014-11-25T01:46:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222983",
    "user": "https://github.com/darijgr"
}
```

`@`nbruin: Thanks for the explanations. So it is what I feared. Someone please remove the `@`cached_methods; it appears there is no easy way to get rid of the performance issues.

Caching these maps relating A to gr(A) on gr(A) was my first idea (and I think Travis wanted to implement them as conversions), but it conflicts with Travis's design decision (which is a good one!) to allow overriding `graded_algebra` with simpler stuff than the default `AssociatedGraded` construction. Many different complicated algebras A will end up having the same simple gr(A) (for example, for every universal enveloping algebra A = U(g) of a Lie algebra g over a field, we have gr(A) \cong S(g)), and gr(A) is not supposed to "know" anything about A. Overriding `_element_constructor` of gr(A) would be messy and unscalable.



---

archive/issue_comments_222984.json:
```json
{
    "body": "Replying to [comment:64 tscrim]:\n> How is that any different for objects with multiple natural gradings? \n\nIt's the same issue.\n\n> The main reason why I chose to use `grading` is so we don't have to duplicate all of the code for graded algebras but just replacing `degree` by `smallest_filtered_component` (or whatever name you want to call it).\n\nMy main concern is that I want to be able to have a graded algebra with an additional filtration on it (ideally so that the associated graded algebra is bigraded). I think you said (or someone said) that this could be done with some reworking of the code in this branch. If that's accurate, then it seems like it would be better to have more flexible code that could handle this right from the start, instead of implementing it one way and then rewriting it later on.",
    "created_at": "2014-11-25T03:12:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222984",
    "user": "https://github.com/jhpalmieri"
}
```

Replying to [comment:64 tscrim]:
> How is that any different for objects with multiple natural gradings? 

It's the same issue.

> The main reason why I chose to use `grading` is so we don't have to duplicate all of the code for graded algebras but just replacing `degree` by `smallest_filtered_component` (or whatever name you want to call it).

My main concern is that I want to be able to have a graded algebra with an additional filtration on it (ideally so that the associated graded algebra is bigraded). I think you said (or someone said) that this could be done with some reworking of the code in this branch. If that's accurate, then it seems like it would be better to have more flexible code that could handle this right from the start, instead of implementing it one way and then rewriting it later on.



---

archive/issue_comments_222985.json:
```json
{
    "body": "Replying to [comment:66 darij]:\n\n> Caching these maps relating A to gr(A) on gr(A) was my first idea (and I think Travis wanted to implement them as conversions), but it conflicts with Travis's design decision (which is a good one!) to allow overriding `graded_algebra` with simpler stuff than the default `AssociatedGraded` construction. Many different complicated algebras A will end up having the same simple gr(A) (for example, for every universal enveloping algebra A = U(g) of a Lie algebra g over a field, we have gr(A) \\cong S(g)), and gr(A) is not supposed to \"know\" anything about A. Overriding `_element_constructor` of gr(A) would be messy and unscalable.\n\nThat suggests that gr(A) should be the simpler object. I'm not sure you want to go as far as having `gr(A)<A`, but it does strongly suggest you *don't* want `A<gr(A)`. You're saying yourself that gr(A) is not supposed to \"know\" about A. That implies that `A` is not a construction parameter for gr(A). Instead, gr(A) should be constructed from basic parameters that can be retrieved from `A`. Mind you, that doesn't preclude the existence of an interface function `GradedAlgebra(A)`, but instead of being a `UniqueRepresentation` class constructor, it would be a factory function that creates the relevant object from the relevant parameters from A.\n\nWhether the coercion from A to gr(A) should then be managed by an \"embedding\" (that's coercion stored on A) is a different question. There is a good potential for creating memory leaks via those too.",
    "created_at": "2014-11-25T04:06:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222985",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:66 darij]:

> Caching these maps relating A to gr(A) on gr(A) was my first idea (and I think Travis wanted to implement them as conversions), but it conflicts with Travis's design decision (which is a good one!) to allow overriding `graded_algebra` with simpler stuff than the default `AssociatedGraded` construction. Many different complicated algebras A will end up having the same simple gr(A) (for example, for every universal enveloping algebra A = U(g) of a Lie algebra g over a field, we have gr(A) \cong S(g)), and gr(A) is not supposed to "know" anything about A. Overriding `_element_constructor` of gr(A) would be messy and unscalable.

That suggests that gr(A) should be the simpler object. I'm not sure you want to go as far as having `gr(A)<A`, but it does strongly suggest you *don't* want `A<gr(A)`. You're saying yourself that gr(A) is not supposed to "know" about A. That implies that `A` is not a construction parameter for gr(A). Instead, gr(A) should be constructed from basic parameters that can be retrieved from `A`. Mind you, that doesn't preclude the existence of an interface function `GradedAlgebra(A)`, but instead of being a `UniqueRepresentation` class constructor, it would be a factory function that creates the relevant object from the relevant parameters from A.

Whether the coercion from A to gr(A) should then be managed by an "embedding" (that's coercion stored on A) is a different question. There is a good potential for creating memory leaks via those too.



---

archive/issue_comments_222986.json:
```json
{
    "body": "Replying to [comment:67 jhpalmieri]:\n> It's the same issue.\n\nOkay, we're on the same page. I think the solution is the same.\n\n> My main concern is that I want to be able to have a graded algebra with an additional filtration on it (ideally so that the associated graded algebra is bigraded). I think you said (or someone said) that this could be done with some reworking of the code in this branch. If that's accurate, then it seems like it would be better to have more flexible code that could handle this right from the start, instead of implementing it one way and then rewriting it later on.\n\nI spoke off-hand that there might be a good way to do this as the code evolved. With some more thought, I think if you have `degree` return `(f, g)` where `f` is the filtration and `g` the grading, then it should handle things properly in the same was if you were trying to construct a bigraded algebra.",
    "created_at": "2014-11-25T04:45:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222986",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:67 jhpalmieri]:
> It's the same issue.

Okay, we're on the same page. I think the solution is the same.

> My main concern is that I want to be able to have a graded algebra with an additional filtration on it (ideally so that the associated graded algebra is bigraded). I think you said (or someone said) that this could be done with some reworking of the code in this branch. If that's accurate, then it seems like it would be better to have more flexible code that could handle this right from the start, instead of implementing it one way and then rewriting it later on.

I spoke off-hand that there might be a good way to do this as the code evolved. With some more thought, I think if you have `degree` return `(f, g)` where `f` is the filtration and `g` the grading, then it should handle things properly in the same was if you were trying to construct a bigraded algebra.



---

archive/issue_comments_222987.json:
```json
{
    "body": "Replying to [comment:68 nbruin]:\n> Replying to [comment:66 darij]:\n> \n> > Caching these maps relating A to gr(A) on gr(A) was my first idea (and I think Travis wanted to implement them as conversions), but it conflicts with Travis's design decision (which is a good one!) to allow overriding `graded_algebra` with simpler stuff than the default `AssociatedGraded` construction. Many different complicated algebras A will end up having the same simple gr(A) (for example, for every universal enveloping algebra A = U(g) of a Lie algebra g over a field, we have gr(A) \\cong S(g)), and gr(A) is not supposed to \"know\" anything about A. Overriding `_element_constructor` of gr(A) would be messy and unscalable.\n> \n> That suggests that gr(A) should be the simpler object. I'm not sure you want to go as far as having `gr(A)<A`, but it does strongly suggest you *don't* want `A<gr(A)`. You're saying yourself that gr(A) is not supposed to \"know\" about A. That implies that `A` is not a construction parameter for gr(A). Instead, gr(A) should be constructed from basic parameters that can be retrieved from `A`. Mind you, that doesn't preclude the existence of an interface function `GradedAlgebra(A)`, but instead of being a `UniqueRepresentation` class constructor, it would be a factory function that creates the relevant object from the relevant parameters from A.\n> \n> Whether the coercion from A to gr(A) should then be managed by an \"embedding\" (that's coercion stored on A) is a different question. There is a good potential for creating memory leaks via those too.\n\nIt's not true that `gr(A)` is (suppose to be) independent of `A`. The multiplication of `gr(A)` is defined from the multiplication in `A` (plus the imposed filtration). However, that's not to say we can't construct the associated graded algebra without appealing to `A`, but we're essentially just using specialize code. From that, I strongly believe we want `A < gr(A)`, to the point that I'd want to implement `gr` as a `Functor` instance in a follow-up (at least, I'm pretty sure it is a functor).",
    "created_at": "2014-11-25T04:55:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222987",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:68 nbruin]:
> Replying to [comment:66 darij]:
> 
> > Caching these maps relating A to gr(A) on gr(A) was my first idea (and I think Travis wanted to implement them as conversions), but it conflicts with Travis's design decision (which is a good one!) to allow overriding `graded_algebra` with simpler stuff than the default `AssociatedGraded` construction. Many different complicated algebras A will end up having the same simple gr(A) (for example, for every universal enveloping algebra A = U(g) of a Lie algebra g over a field, we have gr(A) \cong S(g)), and gr(A) is not supposed to "know" anything about A. Overriding `_element_constructor` of gr(A) would be messy and unscalable.
> 
> That suggests that gr(A) should be the simpler object. I'm not sure you want to go as far as having `gr(A)<A`, but it does strongly suggest you *don't* want `A<gr(A)`. You're saying yourself that gr(A) is not supposed to "know" about A. That implies that `A` is not a construction parameter for gr(A). Instead, gr(A) should be constructed from basic parameters that can be retrieved from `A`. Mind you, that doesn't preclude the existence of an interface function `GradedAlgebra(A)`, but instead of being a `UniqueRepresentation` class constructor, it would be a factory function that creates the relevant object from the relevant parameters from A.
> 
> Whether the coercion from A to gr(A) should then be managed by an "embedding" (that's coercion stored on A) is a different question. There is a good potential for creating memory leaks via those too.

It's not true that `gr(A)` is (suppose to be) independent of `A`. The multiplication of `gr(A)` is defined from the multiplication in `A` (plus the imposed filtration). However, that's not to say we can't construct the associated graded algebra without appealing to `A`, but we're essentially just using specialize code. From that, I strongly believe we want `A < gr(A)`, to the point that I'd want to implement `gr` as a `Functor` instance in a follow-up (at least, I'm pretty sure it is a functor).



---

archive/issue_comments_222988.json:
```json
{
    "body": "You can't have `A < gr(A)` as long as you choose to identify (say) the ass. gr. of a Clifford algebra with an exterior algebra, and the ass. gr. of a graded algebra with itself.",
    "created_at": "2014-11-25T04:57:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222988",
    "user": "https://github.com/darijgr"
}
```

You can't have `A < gr(A)` as long as you choose to identify (say) the ass. gr. of a Clifford algebra with an exterior algebra, and the ass. gr. of a graded algebra with itself.



---

archive/issue_comments_222989.json:
```json
{
    "body": "Why not? There's nothing wrong with that. Technically we're saying there's no relation, but it's okay to remove relations from this poset.",
    "created_at": "2014-11-25T05:01:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222989",
    "user": "https://github.com/tscrim"
}
```

Why not? There's nothing wrong with that. Technically we're saying there's no relation, but it's okay to remove relations from this poset.



---

archive/issue_comments_222990.json:
```json
{
    "body": "When `A` is graded, how do you want `A < A`?",
    "created_at": "2014-11-25T05:05:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222990",
    "user": "https://github.com/darijgr"
}
```

When `A` is graded, how do you want `A < A`?



---

archive/issue_comments_222991.json:
```json
{
    "body": "`A` is constructed from independent data and `graded_algebra` in that case does not construct any new objects. So there would be no `A < A`.",
    "created_at": "2014-11-25T05:09:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222991",
    "user": "https://github.com/tscrim"
}
```

`A` is constructed from independent data and `graded_algebra` in that case does not construct any new objects. So there would be no `A < A`.



---

archive/issue_comments_222992.json:
```json
{
    "body": "What do you mean by \"`A` is constructed from independent data\"? What if `A` is UniqueRep and constructs itself? (Skype?)",
    "created_at": "2014-11-25T05:11:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222992",
    "user": "https://github.com/darijgr"
}
```

What do you mean by "`A` is constructed from independent data"? What if `A` is UniqueRep and constructs itself? (Skype?)



---

archive/issue_comments_222993.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-21T17:19:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222993",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222994.json:
```json
{
    "body": "About why I think `FilteredModulesWithBasis` needs a contract:\n\nHere are the methods on `F` that are used in the implementations of the methods of `FilteredModulesWithBasis` when `F` is cast as a `FilteredModulesWithBasis`:\n\n\n```\nParentMethods:\ndegree_on_basis\nsum_of_terms\nmonomial\n_indices\n\nElementMethods:\nsupport\nleading_support\nis_homogeneous\nis_zero\n```\n\n\nI hear the quacking of a `CombinatorialFreeModule` duck here (except for `degree_on_basis` which should be explicitly required). Are there any more general categories which offer these methods?",
    "created_at": "2015-03-21T17:33:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222994",
    "user": "https://github.com/darijgr"
}
```

About why I think `FilteredModulesWithBasis` needs a contract:

Here are the methods on `F` that are used in the implementations of the methods of `FilteredModulesWithBasis` when `F` is cast as a `FilteredModulesWithBasis`:


```
ParentMethods:
degree_on_basis
sum_of_terms
monomial
_indices

ElementMethods:
support
leading_support
is_homogeneous
is_zero
```


I hear the quacking of a `CombinatorialFreeModule` duck here (except for `degree_on_basis` which should be explicitly required). Are there any more general categories which offer these methods?



---

archive/issue_comments_222995.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-21T18:41:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222995",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_222996.json:
```json
{
    "body": "On the subject of associated graded objects of filtered *modules*, they are now implemented (see the doctests for why they are a useful notion -- it is really the `induced_graded_map` that makes them useful). But naming them `graded_algebra` is questionable, and I understand jhpalmieri's objections to it. What about renaming `graded_algebra` as `associated_graded` (for both modules and algebras)? Nicolas just suggested this and I like the idea.\n\n(We algebraists don't have a good name for this notion. \"Associated graded\" is too long and an adjective that makes the listener search in vain for a noun. \"gr\" is too short and hard to pronounce.)",
    "created_at": "2015-03-21T18:45:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222996",
    "user": "https://github.com/darijgr"
}
```

On the subject of associated graded objects of filtered *modules*, they are now implemented (see the doctests for why they are a useful notion -- it is really the `induced_graded_map` that makes them useful). But naming them `graded_algebra` is questionable, and I understand jhpalmieri's objections to it. What about renaming `graded_algebra` as `associated_graded` (for both modules and algebras)? Nicolas just suggested this and I like the idea.

(We algebraists don't have a good name for this notion. "Associated graded" is too long and an adjective that makes the listener search in vain for a noun. "gr" is too short and hard to pronounce.)



---

archive/issue_comments_222997.json:
```json
{
    "body": "`@`Travis: here is the main thing I want you to address before I review the Clifford & Weyl stuff in this ticket:\n\n> Another issue with the Clifford-Weyl part of this patch: The Clifford algebra is graded by default, whereas the Weyl algebra is graded [oops: I meant filtered here] by default. There is no reason why there should be different behavior here; the Weyl algebra is Z/2-graded as much as the Clifford one is.",
    "created_at": "2015-03-21T18:48:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222997",
    "user": "https://github.com/darijgr"
}
```

`@`Travis: here is the main thing I want you to address before I review the Clifford & Weyl stuff in this ticket:

> Another issue with the Clifford-Weyl part of this patch: The Clifford algebra is graded by default, whereas the Weyl algebra is graded [oops: I meant filtered here] by default. There is no reason why there should be different behavior here; the Weyl algebra is Z/2-graded as much as the Clifford one is.



---

archive/issue_comments_222998.json:
```json
{
    "body": "As Darij and I discussed today, we should make Weyl and Clifford algebras super filtered algebras, so we need #18044.",
    "created_at": "2015-03-24T03:02:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222998",
    "user": "https://github.com/tscrim"
}
```

As Darij and I discussed today, we should make Weyl and Clifford algebras super filtered algebras, so we need #18044.



---

archive/issue_comments_222999.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-26T20:32:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-222999",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_223000.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-03-27T06:33:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223000",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_events_049685.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2015-03-27T06:37:10Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "milestone": "sage-6.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16859#event-49685"
}
```



---

archive/issue_comments_223001.json:
```json
{
    "body": "I talk a bit about this ticket with Nicolas tonight, and we decided to not make `support` an abstract method right now, but instead leave a message in the category about this. We will fix `support` along with many other issues with an object in `ModulesWithBasis` being too close to a `CombinatorialFreeModule` in the followup #18066. I think with this we've handled everything from comment:60.",
    "created_at": "2015-03-27T06:37:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223001",
    "user": "https://github.com/tscrim"
}
```

I talk a bit about this ticket with Nicolas tonight, and we decided to not make `support` an abstract method right now, but instead leave a message in the category about this. We will fix `support` along with many other issues with an object in `ModulesWithBasis` being too close to a `CombinatorialFreeModule` in the followup #18066. I think with this we've handled everything from comment:60.



---

archive/issue_comments_223002.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. Last 10 new commits:",
    "created_at": "2015-04-14T22:10:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223002",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:



---

archive/issue_comments_223003.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-04-22T03:12:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223003",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_223004.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-05-17T18:21:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223004",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_223005.json:
```json
{
    "body": "see also #15328",
    "created_at": "2015-08-09T18:58:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223005",
    "user": "https://github.com/fchapoton"
}
```

see also #15328



---

archive/issue_comments_223006.json:
```json
{
    "body": "Patchbot is not yet happy (but for very stupid reasons).",
    "created_at": "2015-08-09T19:02:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223006",
    "user": "https://github.com/videlec"
}
```

Patchbot is not yet happy (but for very stupid reasons).



---

archive/issue_comments_223007.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-04T14:15:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223007",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_223008.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-04T14:17:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223008",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_223009.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-04T17:59:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223009",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_events_049686.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2015-10-04T18:02:24Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "milestone": "sage-6.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16859#event-49686"
}
```



---

archive/issue_events_049687.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2015-10-04T18:02:24Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "milestone": "sage-6.10",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16859#event-49687"
}
```



---

archive/issue_comments_223010.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2015-10-04T21:25:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223010",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_223011.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2015-10-04T21:54:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223011",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_223012.json:
```json
{
    "body": "After a harrowing hour of discussing the category framework, I found myself agreeing with this ticket. Thanks Travis for the changes!",
    "created_at": "2015-10-04T21:56:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223012",
    "user": "https://github.com/darijgr"
}
```

After a harrowing hour of discussing the category framework, I found myself agreeing with this ticket. Thanks Travis for the changes!



---

archive/issue_comments_223013.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2015-10-04T21:56:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223013",
    "user": "https://github.com/darijgr"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_events_049688.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2015-10-12T07:16:25Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/16859#event-49688"
}
```



---

archive/issue_comments_223014.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2015-10-12T07:16:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/16859",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/16859#issuecomment-223014",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed
