# Issue 20024: Coercion of 0 in cyclotomic field fails

Issue created by migration from https://trac.sagemath.org/ticket/20261

Original creator: fstromberg

Original creation time: 2016-03-23 13:58:30

CC:  bhutz chapoton cremona jdemeyer kedlaya mmezzarobba nbruin slelievre tscrim vdelecroix

In some cases the element 0 of one cyclotomic field can not be coerced properly to 0 in another cyclotomic field.
For instance tested in Sage 7.1: 
sage: K1=CyclotomicField(12)
sage: K2=CyclotomicField(6)
sage: K1(K2(0))
0
sage: K2(K1(0))
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
...
TypeError: unable to coerce <class 'sage.rings.infinity.PlusInfinity'> to an integer


---

Comment by slelievre created at 2016-05-19 08:11:05

Changing keywords from "" to "cyclotomic".


---

Comment by slelievre created at 2016-05-19 08:11:05

Fix code typesetting in ticket description. Cc cyclotomic-interested people.


---

Comment by cremona created at 2016-05-19 09:51:54

See related #20513 which I am currently testing.  I'll see if it fixes this too, and if so this could be closed.


---

Comment by vdelecroix created at 2016-05-19 13:51:05

You might also want to fix more general conversions

```
sage: K6(K12.one())
1
sage: K6(K12.gen()**2)
zeta6
sage: K6(K12.one() + K12.gen()**2)
# BOOM
```

When there is an embedding `K1 -> K2` the conversions from `K2` to `K1` is unambiguous.


---

Comment by tscrim created at 2016-05-19 13:52:01

I would say this is an issue with _conversion_, not coercion.


---

Comment by tscrim created at 2016-05-19 13:53:22

It also is more general issue:

```
sage: K13 = CyclotomicField(13)
sage: K5 = CyclotomicField(5)
sage: K5(K13(0))
# BOOM
```



---

Comment by vdelecroix created at 2016-05-19 13:53:57

Indeed, I did not have a look at the title!


---

Comment by tscrim created at 2016-05-19 13:54:46

Probably the quickest (best?) way around this might be to just special case 0 in the `_element_constructor_`:

```python
if x == x.parent().zero():
    return self.zero()
```



---

Comment by cremona created at 2016-05-19 14:05:00

#20513 does fix the first of these: 

```
sage: K12(K6(0))
0
```

but

```
sage: K6(K12(0))
```

rather amaingly gives

```
TypeError: unable to coerce <class 'sage.rings.infinity.PlusInfinity'> to an integer
```


I suggest that #20513 is amended to deal with these cases, with extra doctests, rather than starting a new branch for it.


---

Comment by tscrim created at 2016-05-19 14:13:07

I think this and #20513 are separate issues and it is better to have a separate ticket (and branch) (which if there are conflicts, base this on #20513). With 7.2:

```
sage: K12 = CyclotomicField(12)
sage: K6 = CyclotomicField(6)
sage: K12(K6(0))
0
```

works just fine for me. If the latter is fails with #20513, then indeed these issues are separate.


---

Comment by vdelecroix created at 2016-05-19 14:33:40

As Travis said `K6 -> K12` is a *coercion* and is working just fine with or without #20513. The latter ticket deals with towers of coercions such as `K6 -> K12 -> K36 -> K64`. 

The (partial) conversion `K12 -> K6` which is the object of this ticket is another story.


---

Comment by vdelecroix created at 2016-05-19 14:34:13

Replying to [comment:7 tscrim]:
> Probably the quickest (best?) way around this might be to just special case 0 in the `_element_constructor_`:
> {{{#!python
> if x == x.parent().zero():
>     return self.zero()
> }}}

Even better

```python
if x.is_rational():
    return self(QQ(x))
```



---

Comment by vdelecroix created at 2016-05-19 14:38:27

It is explicitely mentioned in the documentation of `_coerce_from_other_cycltomic_field` that the method works only for roots of unity. And indeed

```
sage: K6(K12(2))
# BOOM
sage: K6(K12.gen()**2 + 1)
# BOOM
```



---

Comment by cremona created at 2021-02-12 10:18:55

Almost all of the BOOMs reported here now work.  Personally I don't think it is worth implemention any partial maps from K_n to K_m (where K_n is the n'th cyclotomic field) when m and n are coprime, so the only elements which would make sense as arguments would be rationals.

My inclination would be to close this.


---

Comment by kedlaya created at 2021-02-12 15:29:28

Some of the BOOMs must have been fixed by #29511. The example at the top of the ticket now works. However, this one persists:

```
sage: K13 = CyclotomicField(13)
sage: K5 = CyclotomicField(5)
sage: K5(K13(0))
# BOOM
```

Another example with roots of unity (which might have been broken by #29511, now that I think of it):

```
sage: K3 = CyclotomicField(3)
sage: K9 = CyclotomicField(9)                                                   
sage: K12 = CyclotomicField(12)     
sage: K12(K3(K9.gen()^3))                                                       
zeta12^2 - 1                           
sage: K12(K9.gen()^3) # should be the same?  
# BOOM
```

But it might be worth creating a new ticket (or more than one) that more precisely identifies the remaining issue(s), and then closing this one as a duplicate.


---

Comment by cremona created at 2021-02-12 16:16:46

I think a new ticket is in order here.  To be able to map a in K_m to K_n in a meaningful way, I think you have to think of K_l, where l=lcm(m,n), as a subfield of both, and only allow it if a lies i that common subfield.  Some care will be needed to allow for K_n=K_{2n} for odd n.  As a special case, when m and n are coprime, this will be possible iff a in in Q=K_1.

If that is mathematically reasonable and well-defined it is probably worth doing.


---

Comment by kedlaya created at 2021-02-12 16:38:04

If I understand correctly, as long as m and n are even, the partial map K_m ---> K_n is just the composition of the partial map K_m ---> K_{gcd(m,n)} with the genuine map K_{gcd(m,n)} -> K_n, and in particular is defined exactly where the first map is defined.

I believe thanks to #29511 the partial map K_m -> K_n is already fully implemented when n divides m, so it should be an easy fix to upgrade this to the general case.


---

Comment by kedlaya created at 2021-02-13 04:17:25

Looking at what I did on #29511, in `src/sage/rings/number_field/number_field_morphisms.pyx` I defined a class `CyclotomicFieldConversion` which implements canonical conversions between arbitrary cyclotomic fields. What I don't know how to do offhand is to force this to get called when a coercion is needed between two cyclotomic fields, neither one containing the other.
