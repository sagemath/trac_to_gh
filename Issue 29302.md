# Issue 29302: Bug in torsion subgroup of elliptic curves over number fields

Issue created by migration from https://trac.sagemath.org/ticket/29539

Original creator: cremona

Original creation time: 2020-04-21 09:27:38

Keywords: elliptic curve torsin subgroup

In #28488 the code for computing torsion subgroups of elliptic curves over number fields was upgraded and made much more efficient, specifically the function torsion_bound() in `ell_torsion.py`.  That code was tested extensively on a large number of curves, all base-changes of curves defined over QQ, which is (for efficiency) treated as a special case in that function.

I am now running the new code on another large number of curves in the LMFDB and am running into problems which are not easily reproducible, causing run-time errors in lines 408-410 of this file, when the curve is reduced modulo primes.  Typically this only happens after processing hundreds of curves, and when the problematic curve is run by itself it works fine.

I am investigating and will fix this.


---

Comment by cremona created at 2020-04-22 09:07:04

I am also getting different errors from the saturation code, as previously fixed in #27387.  There, the probem was in consistently reducing a curve mod P and points on the curve mod P.
I will try to fix both issues together: both involve reducing curves over number fields modulo primes.  Both are not deterministic, in that I can the same examples more than once and an error is not always raised.  This is not so surprising since in both cases we compute the cardinality and/or group structure and generators of al elliptic curve defined over a finite field, and the latter is done using random points.


---

Comment by cremona created at 2020-04-22 10:13:01

I think I have fixed the second bug, and will say what the problem is here before I forget.  When applying p-saturation to a list of points (which are independent points of infinite order) we first append to the list up to 2 torsion generators, just those (if any) whose order is divisible by p.  When the code does this (on line 449 of saturation.py) it forgot that the elements of E.torsion_subgroup().gens() are not actually points, even though they display as points, but elements of an abstract group structure.  To get the actual point from one of these, say T, you need to use T.element().  Later on, the torsion points added wrongly to the list i nthis way were not being correctly reduced modulo auxiliary primes Q.

I have been stung by this several times before.  It is nice that the elements of E.torsion_subgroup() display just like actual points, and it is efficient that they are actually elements of a finite abelian group when it comes to asking their order, for example, but it leads to problems like this which are hard to diagnose.


---

Comment by cremona created at 2020-05-19 08:02:17

After spending a huge amount of time on the saturation code, which will result in a simplification of the code (but not actual change to the algorithm) I finally hit on a real bug, and it is not in code I wrote at all but in the discrete_log_lambda function.  Example below.  It was very hard to track down sine when one does E.abelian_group() for E an elliptic curve over a finite field, then generators are not deterministic, and the bug only occurs for some choices of generators.

```
sage: F = GF(29)
sage: E = EllipticCurve(F,[18,23,22,4,11])
sage: G = E.abelian_group()
sage: g = 8*G.gens()[0]; g; g.order()
(20 : 4 : 1)
5
sage: [discrete_log_rho(i*g,g,ord=5,operation='+') for i in range(5)]
[0, 1, 2, 3, 4]
sage: [discrete_log(i*g,g,ord=5,operation='+') for i in range(5)]
[0, 1, 2, 3, 4]
sage: [discrete_log_lambda(i*g,g,bounds=(0,4),operation='+') for i in range(4)]
[0, 1, 2, 3]
```

but

```
sage: discrete_log_lambda(4*g,g,bounds=(0,4),operation='+')
...
ValueError: Pollard Lambda failed to find a log
```

I think the issue is that some (but not all) of the discrete log variants have a parameter bounds which is a tuple (lb,ub) and the functions are inconsistent as to whether the range of log values is intended to be lb<=v<ub or lb<=v<=ub.


---

Comment by cremona created at 2020-05-29 09:14:28

Not yet quite ready for review but the branch is here already.

Changes in saturation code: much refactoring in saturation.py, with both code simplification and also some algorithmic enhancements:

   1. Reduction primes Q are degree 1 primes above rational primes q chosen to make the reduction simplest: not ramified and not dividing the index of the equation order (i.e. not dividing the discriminant of the defining polynomial of th base field).   With such q, Q can be found by factoring the defining polynomial and then the reduction of the curve can be defined directly over GF(q) by simply reducing the curve coefficients.  Secondly, q does not divide the denominators of the points being saturated, so that reducing the points is also simpler.

   2. Saturation is now carried out within a new class `EllipticCurveSaturator`.  This enables the information about the reduced curves and their cardinality to be re-used when p-saturating for many primes p, which is more efficient, since that information is stored within the class.

   3. I noticed a special case taking a long time, namely for curves with rational CM by a discriminant D, p-saturation when kronecker(D,p)=-1 was taking a long time, much longer than when kronecker(D,p)=+1.   This is because the mod-p representation is non-split Cartan which in turn means that the p-torsion is defined over a cyclic extension of degree `p^2-1` and hence the density of Q which are usable is `1/(p^2-1)`.  By only testing q such that q=1 (mod p) this is reduced to 1/(p+1) which is OK.  In th split case the density is 1/(p-1) anyway.  This step helped a lot in saturating curves over QQ(sqrt(D)) for D=-3,-4,-7,-8,-11 which are in the LMFDB.
----
New commits:


---

Comment by cremona created at 2020-05-29 09:14:28

Set assignee to cremona.


---

Comment by cremona created at 2020-05-29 09:14:28

Changing keywords from "elliptic curve torsin subgroup" to "elliptic curve saturation".


---

Comment by git created at 2020-05-29 16:13:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2020-06-02 13:06:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2020-06-02 13:32:00

This is now ready for review.

I have to come clean on one matter.  The (stand-alone) function `p_projections(Eq, points, p)` in saturation.py still sometimes and un-reproducibly raises an error.  The function which calls this one catches that and uses a different reduction prime, so no fatal error is raised and everything works OK.  The error always occurs when p=2 and the 2-primary part of Eq.abelian_group() is not cyclic.  (Here Eq is an elliptic curve over GF(q), oints is a list of points on Eq, and p is a prime.) After multiplying the generators of Eq by the prime-to-p part of the group order one should still have 2 non-trivial generators and then use the part of the code for this case, which uses the Weil pairing.  But occasionally after that multiplication only one non-trivial generator remains, the code for the cyclic case runs, and fails when any of the points in the supplied list is not a multiple of the only generator.  I have so far been unable to find any example of this which is reproducible, and I was careful (I think) to clear caches.  But I want to move on.

Apat from this one issue (which has been there ever since this code was first written) the other changes made on this ticket are all worth having as they simplify and speed up saturation.  I have run this on several hundred thousand curves.  For example, i one run which is ongoing, after saturating 28656 curves over several quartic fields, I have seen the issue 5 times.

For the record, here is one example (https://www.lmfdb.org/EllipticCurve/4.4.18496.1/36.4/i/2)

```
sage: x = polygen(QQ)
sage: K.<a> = NumberField(x^4 - 2*x^3 - 11*x^2 + 12*x + 2)
sage: E = EllipticCurve([1, 2/9*a^3 - 1/3*a^2 - 19/9*a + 10/9, -1/9*a^3 + 2/3*a^2 + 14/9*a - 23/9, -2*a^3 - 5*a^2 + 4*a + 3, -89/9*a^3 - 56/3*a^2 + 301/9*a + 32/9])
sage: points = [E([-5/9*a^3 + 1/3*a^2 + 52/9*a + 2/9 , 10/9*a^3 - 5/3*a^2 - 131/9*a - 4/9 ])]
```

where the output with debug=True was once

```
In p_projections(G,Plist,p) with G = Additive abelian group isomorphic to Z/24 + Z/2 embedded in Abelian group of points on Elliptic Curve defined by y^2 + x*y + 37*y = x^3 + 7*x^2 + 12*x + 38 over Finite Field of size 47, Plist = [(25 : 30 : 1), (35 : 11 : 1)], p = 2
m=3, n=48
gens for 2-primary part of G: [(14 : 38 : 1)]
3*points: [(0 : 9 : 1), (35 : 11 : 1)]
Cyclic case, taking dlogs to base (14 : 38 : 1) of order 8
```

Here the group structure is 24*2 so multiplying by 3 maps to the 2-primary part with structure 8*2, however multiplying the gens by 3 and then dropping any which are 0 here results in a list of length 1 not 2.

```
sage: from sage.schemes.elliptic_curves.saturation import EllipticCurveSaturator
sage: saturator = EllipticCurveSaturator(E, verbose=True)
sage: saturator.full_p_saturation(points, p=2)
 --starting full 2-saturation
Adding 1 torsion generators before 2-saturation
Using sieve method to saturate...
E has 2-torsion over Finite Field of size 47, projecting points
 --> [(13 : 1 : 1), (33 : 43 : 1)]
 --rank is now 1
 --rank is now 2
Reached full rank: points were 2-saturated
Removing the torsion generators after 2-saturation
Points were 2-saturated
([(-5/9*a^3 + 1/3*a^2 + 52/9*a + 2/9 : 10/9*a^3 - 5/3*a^2 - 131/9*a - 4/9 : 1)],
 0)
```


The underlying reason for the lack of reproducibility is that Eq.abelian_group() uses random points.  I did some testing with all possible pairs of generators but had no luck.  So I am wondering if some code somewhere is overwriting the cached gens.


---

Comment by cremona created at 2020-06-02 13:32:00

Changing status from new to needs_review.


---

Comment by vbraun created at 2020-08-07 19:05:05

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-08-07 19:05:05

I'm getting the 

```
**********************************************************************
File "src/sage/schemes/elliptic_curves/saturation.py", line 417, in sage.schemes.elliptic_curves.saturation.dict
Failed example:
    full_p_saturation([P,Q+3*R,Q-4*R],7)
Exception raised:
    Traceback (most recent call last):
      File "/home/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 715, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/home/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/doctest/forker.py", line 1139, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.schemes.elliptic_curves.saturation.dict[9]>", line 1, in <module>
        full_p_saturation([P,Q+Integer(3)*R,Q-Integer(4)*R],Integer(7))
      File "/home/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/schemes/elliptic_curves/saturation.py", line 460, in full_p_saturation
        res = p_saturation(Plist, p, True, lin_combs, verbose)
      File "/home/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/schemes/elliptic_curves/saturation.py", line 311, in p_saturation
        vecs = projections(Q, p)
      File "/home/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/schemes/elliptic_curves/saturation.py", line 297, in projections
        return [vector(GF(p), [a(pt,gen) for pt in projPlist]) for gen in gg]
      File "/home/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/schemes/elliptic_curves/saturation.py", line 297, in <listcomp>
        return [vector(GF(p), [a(pt,gen) for pt in projPlist]) for gen in gg]
      File "/home/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/schemes/elliptic_curves/saturation.py", line 297, in <listcomp>
        return [vector(GF(p), [a(pt,gen) for pt in projPlist]) for gen in gg]
      File "/home/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/schemes/elliptic_curves/saturation.py", line 295, in a
        return discrete_log_lambda(w,zeta,(0,p1),'*')
      File "/home/buildbot/slave/sage_git/build/local/lib/python3.7/site-packages/sage/groups/generic.py", line 944, in discrete_log_lambda
        raise ValueError("Pollard Lambda failed to find a log")
    ValueError: Pollard Lambda failed to find a log
**********************************************************************
```

test failure randomly on the patchbots, hopefully this ticket will fix it ;-)


---

Comment by vbraun created at 2020-08-08 08:14:36

Changing status from positive_review to needs_work.


---

Comment by vbraun created at 2020-08-08 08:14:36

PDF documentation fails to build


---

Comment by cremona created at 2020-08-08 11:00:39

Yes, I do hope that this ticket will fix those random failures.

I will look at the doc build issue.


---

Comment by cremona created at 2020-08-09 09:21:57

Replying to [comment:10 cremona]:
> Yes, I do hope that this ticket will fix those random failures.
> 
> I will look at the doc build issue.

Got it: there were 4 occurrences of \F instead of \GF in saturation.py.  I'll upload a corrected branch.


---

Comment by git created at 2020-08-10 10:08:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cremona created at 2020-08-10 10:09:43

Changing status from needs_work to needs_review.


---

Comment by cremona created at 2020-08-10 10:09:43

This had a positive review apart from the docstring issue which is now fixed.


---

Comment by vbraun created at 2020-08-10 11:50:49

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2020-08-12 19:53:46

Resolution: fixed
