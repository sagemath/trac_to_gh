# Issue 16300: Python 3 preparation: Use "rich comparison" - std function  cmp() is gone, method __cmp__ is ignored

Issue created by migration from Trac.

Original creator: wluebbe

Original creation time: 2014-06-25 13:58:48

CC:  jpflori

Keywords: python3

Since Py2.1 there are the //rich comparison// special methods (`__eq__, __ne__, __lt__, __le__, __gt__, __ge__`) to implement comparison operators (`==, !=, <, <=, >, >=` respectively) for custom classes.

This is more flexible (but somewhat more tedious) than defining the special method `__cmp__`.

In Py3 the special method `__cmp__` is ignored. The standard function `cmp()` (which is mostly used to implement `__cmp__` methods) is gone.

One may define a replacement function like

```
def cmp(a, b):
    return (a > b) - (a < b)
```


But this does not improved performance. And it does not seem forward looking ...

Unfortunately `__cmp__` and `cmp()` are used a LOT in Sage. And the migration to rich comparison can not be done purely mechanical :-(

Since Py2.7 there is a class decorator [functools.total_ordering](https://docs.python.org/2/library/functools.html?highlight=total_ordering#functools.total_ordering) to help to create the full set of special method `__lt__, __le__, __gt__, __ge__` when given one of those.


See Lennart Regebro's [Chapter: Use rich comparison operators](http://python3porting.com/preparing.html) for a more detailed discussion.


This ticket is tracked as a dependency of meta-ticket ticket:15980.


---

Comment by wluebbe created at 2014-06-27 15:21:04

I did some grepping to get a first impression of the amount of work required:
|                                     |   |
|-------------------------------------|---|
|`git grep -P "def\s+__cmp__" |wc -l` |377|
| | |
|`git grep -P "def\s+__eq__"  |wc -l` |170|
|`git grep -P "def\s+__ne__"  |wc -l` |70|
|`git grep -P "def\s+__lt__"  |wc -l` |29|
|`git grep -P "def\s+__le__"  |wc -l` |18|
|`git grep -P "def\s+__gt__"  |wc -l` |21|
|`git grep -P "def\s+__ge__"  |wc -l` |18|
| | |
|`git grep -P "\bcmp\s*\(" |wc -l` |1042|
The conclusion seems that we have to implement //rich comparison// (i.e. define `__eq__` with `__ne__` and `__gt__` with the class decorator `functools.total_ordering`) for about 350 classes!

And then there are those 1000+ calls to `cmp`.

And unfortunately the changes are mostly not syntactical but they require insight into the code!


---

Attachment

Python script to demonstrate some "features" of rich comparison.


---

Attachment


---

Attachment


---

Attachment


---

Attachment


---

Attachment


---

Attachment


---

Attachment

Some remarks on the attached files:
* The 1st script shows the effects of varying which of the special methods `__eq__, __ne__, __lt__` and ``@`total_ordering` are defined. The 2nd and 3rd files show the results for Py2 and Py3 respectively.
  * In Py2 all of ("eq", "ne", "lt", "total") must be used to always obtain correct results.
  * In Py3 it appears that "ne" is implied (be "eq").
  * For correct behavior in Py2 and Py3 all of "eq", "ne", "lt", "total" should be used.
* The 4th script shows the results of the comparison operators when defining no `__cmp_` or using a self defined `cmp` or using the standard library `cmp`. The 5th and 6th files show the results for Py2 and Py3 respectively.
  * In Py2 "no_cmp" gives often wrong results, but always correct results when `__cmp__` is defined.
  * In Py3 there are always type errors for "lt", "le", "gt"and "ge". For "eq" and "ne" some wrong and some correct.
  * `__cmp__` does not work in Py3! Rich comparison must be implemented!
* The 7th script shows whether it possible to define the rich comparison special methods  using `cmp`. The 8nd and 9th files show the results for Py2 and Py3 respectively.
  * In Py2 it is possible.
  * In Py3 one needs a user defined `cmp` function that is based on `<` and `>`.
  * Both in Py2 and Py3 ``@`total_ordering` is required.


---

Comment by rws created at 2015-02-17 17:04:33

Can the work be reduced by including the code in http://www.voidspace.org.uk/python/articles/comparison.shtml into the `SageObject` class?


---

Comment by nbruin created at 2015-02-17 19:55:24

Replying to [comment:5 rws]:
> Can the work be reduced by including the code in http://www.voidspace.org.uk/python/articles/comparison.shtml into the `SageObject` class?

I suspect that `sage.structure.element.Element` is a better location for it, since `SageObject` doesn't have any comparison infrastructure, and `Element` has.

In any case, the quoted code cannot be used verbatim, since these classes are cdef cython, where the interface is via the `__richcmp__` special method, not the various `__eq__` etc. 

Element already has a `__richcmp__`, as well as a `__cmp__`. Precedence rules for comparison lookup in Python 2 imply that `__cmp__` should never be triggered. The implementation there in some branches will try to look up `__cmp__`. This would be a good place to start looking into how much we really depend on `__cmp__`.


---

Comment by jdemeyer created at 2015-03-06 08:51:41

Currently, a Sage `Element` already implements rich comparison using `__cmp__`/`_cmp_`/`_cmp_c_impl` (for simplification of this, see #17890). In my opinion, there is nothing wrong with keeping that behaviour even in Python 3.

My conclusion from this is that the problem really is `cmp()` and not `__cmp__`.


---

Comment by jdemeyer created at 2016-05-02 13:33:23

Changing component from distribution to python3.


---

Comment by chapoton created at 2016-09-23 06:08:59

Changing type from PLEASE CHANGE to enhancement.


---

Comment by chapoton created at 2017-11-16 19:54:30

There is no longer any call of cmp() in the code. There remains a few in the doc.

And probably we still need to convert a few `__cmp__` to `__richcmp__`.


---

Comment by embray created at 2017-12-12 09:38:03

As a word of warning, it seems that ``@`total_ordering` does not work with pure Python classes that have a Cython base class that implements `__richcmp__`, as it will inherit all the generated slots from the base class.  For `Element` classes they can implement `_richcmp_`, but I'm not sure what the best solution is in general.


---

Comment by embray created at 2017-12-12 09:47:28

In particular I ran into this with a class that was derived from `WithEqualityById`, which implements `__richcmp__`.  Looking at its `__richcmp__`, though, it really shouldn't have one, and should only implement `__eq__` I think, since the ordering operators are all `NotImplemented` anyways.


---

Comment by embray created at 2017-12-12 09:56:55

It looks like even if just implementing `__eq__`, CPython adds its own slots for all the comparison operators that override any defined in the base classes.  So that's kind of annoying.


---

Comment by embray created at 2017-12-12 11:22:09

Oh well, I forgot Jeroen did `richcmp_method`, even though I think I reviewed it.  That should be preferred over `total_ordering` probably.


---

Comment by jdemeyer created at 2017-12-12 16:06:09

Replying to [comment:16 embray]:
> As a word of warning, it seems that ``@`total_ordering` does not work with pure Python classes that have a Cython base class that implements `__richcmp__`, as it will inherit all the generated slots from the base class.

Why does this problem not appear for every (new-style) class then? The base class `object` already has those slots:

```
>>> object.__lt__
<method-wrapper '__lt__' of type object at 0x7fe14ebdf0e0>
```



---

Comment by chapoton created at 2017-12-15 13:46:22

There remains also `self.cmp_letters = cmp` in `sage/combinat/words/words.py`

EDIT: see #24383 for that


---

Comment by embray created at 2017-12-15 13:46:56

That's exactly the problem.  The way `total_ordering` implemented it does something like:


```
for op in ['__lt__', '__gt__', ...]:
    if getattr(cls, op, None) is not getattr(object, op, None):
        # Do something...
```


So if there is a built-in base class that is not `object` it fails, even if it's still wrapping the standard implementation of that slot.  I would consider this a bug in Python--it shouldn't be doing identity comparison on the slot wrapper object itself.


---

Comment by embray created at 2017-12-15 13:48:15

Replying to [comment:21 chapoton]:
> There remains also `self.cmp_letters = cmp` in `sage/combinat/words/words.py`

I think my plan was to just remove that outright since it's deprecated for some time and nothing uses it.


---

Comment by jdemeyer created at 2017-12-15 13:53:35

Sorry, I was wrong. Actually, `object.__eq__` is really the method `type.__eq__` bound to the `object` instance:

```
>>> object.__eq__(object)
True
```

So the type `object` does _not_ have rich comparison slots.


---

Comment by embray created at 2017-12-15 14:03:58

Replying to [comment:24 jdemeyer]:
> Sorry, I was wrong. Actually, `object.__eq__` is really the method `type.__eq__` bound to the `object` instance:
> {{{
> >>> object.__eq__(object)
> True
> }}}
> So the type `object` does _not_ have rich comparison slots.

To be clear (and part of the problem) is that there's only _one_ rich comparison slot (`tp_richcompare`).  So if even one rich comparison operator is overloaded in a `cdef class` (say, `__eq__`), then all the rich comparison methods get new slot wrappers rather than inheriting them from `object`, even though the implementations for those operators are still the defaults.


---

Comment by jdemeyer created at 2017-12-15 14:08:33

Replying to [comment:25 embray]:
> all the rich comparison methods get new slot wrappers rather than inheriting them from `object`

As I said, I was wrong: `object` does not implement rich comparison:

```
>>> a = object()
>>> a.__lt__
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'object' object has no attribute '__lt__'
```

So rich comparison obviously cannot be inherited from `object`.


---

Comment by embray created at 2017-12-15 14:10:23

You must be looking at Python 2. On Python 3 it does.  There's just a slight difference in where it inherits the default behavior from.


---

Comment by jdemeyer created at 2017-12-15 14:13:20

Replying to [comment:27 embray]:
> You must be looking at Python 2. On Python 3 it does.  There's just a slight difference in where it inherits the default behavior from.

Right!

```
Python 3.4.1 (default, Sep  4 2015, 12:50:14) 
[GCC 4.8.4] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> a = object()
>>> a.__lt__
<method-wrapper '__lt__' of object object at 0x7f4ccf850070>
```


On Python 2, `object` has neither `__cmp__` nor `__eq__`.


---

Comment by embray created at 2017-12-15 14:24:53

I must be missing your point. I'm not talking about Python 2.


---

Comment by jdemeyer created at 2017-12-15 14:36:27

Replying to [comment:29 embray]:
> I'm not talking about Python 2.

Yes, I understood that now..


---

Comment by embray created at 2018-02-23 13:54:46

Changing keywords from "python3" to "python3, richcmp".


---

Comment by embray created at 2018-02-23 13:54:46

Adding a table or tracking modules that still need `__cmp__` work (maybe--this is just based on a grep and has not been closely reviewed).


---

Comment by jdemeyer created at 2018-02-26 08:49:09

For cdef classes in Cython code, this will be slightly easier with Cython 0.28 since that allows using Python methods like `__eq__` instead of `__richcmp__`. That makes sense in particular when you only really want to implement `==` and `!=`.


---

Comment by embray created at 2018-02-26 14:44:53

I'm still working on organizing some of these things.  Instead of putting notes in the "ticket" column please just put notes in the module column (or a separate column--perhaps I'll do that).

Even "deprecated" modules still need a ticket related to removing them if it's deprecated.


---

Comment by embray created at 2018-02-26 14:48:45

Replying to [comment:35 jdemeyer]:
> For cdef classes in Cython code, this will be slightly easier with Cython 0.28 since that allows using Python methods like `__eq__` instead of `__richcmp__`. That makes sense in particular when you only really want to implement `==` and `!=`.

Sort of. There's a bug in Cython that makes it impossible to compile such code if the comparison method has a docstring.


---

Comment by jdemeyer created at 2018-02-26 21:04:03

Replying to [comment:38 embray]:
> Sort of. There's a bug in Cython that makes it impossible to compile such code if the comparison method has a docstring.

That's why I said Cython 0.28 :-)


---

Comment by jdemeyer created at 2018-03-29 12:51:32

#22349 is a major open issue here.


---

Comment by vdelecroix created at 2018-08-03 19:20:18

update milestone 8.3 -> 8.4


---

Comment by slelievre created at 2020-09-10 18:05:21

Ready to close this? With only #22349 left open,
the meta-ticket is less useful.


---

Comment by slelievre created at 2020-09-10 18:05:21

Changing status from new to needs_review.


---

Comment by chapoton created at 2020-09-11 12:17:06

Resolution: fixed


---

Comment by chapoton created at 2020-09-11 12:17:06

ok, I guess this can be closed. Agreed.
