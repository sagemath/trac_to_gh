# Issue 34142: Implement a hook to access free (graded) resolutions

Issue created by migration from https://trac.sagemath.org/ticket/34379

Original creator: tscrim

Original creation time: 2022-08-17 00:58:02

CC:  klee

In #33950, free (graded) resolutions for modules over polynomial rings were added. However, one needs to import a top-level function to do the construction. The goal of this ticket is to add a method, such as `free_resolution()`, to these (sub)modules (and ideals) to ease access.


---

Comment by tscrim created at 2022-08-17 01:16:22

`@`klee How broadly is Singular's functionality for free (graded) resolutions support to work? I can't seem to find anything definitive in the online documentation. Will it work for any commutative ring? How about any integral domain, such as

```
sage: R.<x,y> = QQ[]
sage: I = R.ideal([x^2 - y^2 - 1])
sage: Q = R.quo(I)
sage: Q.is_integral_domain()
True
```

The submodule code currently does not quite do this. (I am doing #34380 to be able to make submodules over more arbitrary integral domains.)


---

Comment by klee created at 2022-08-17 01:45:15

Replying to [comment:1 tscrim]:
> How broadly is Singular's functionality for free (graded) resolutions supposed to work?

Only quotients of free modules over multivariate polynomial rings.

> I can't seem to find anything definitive in the online documentation. 

This is pretty definitive:

https://www.singular.uni-kl.de/Manual/4-3-1/sing_988.htm#SEC1047

> Will it work for any commutative ring?

Definitely not. Singular uses Groebner bases, which do not apply to arbitrary commutative rings. Or do I misunderstand your question?


---

Comment by tscrim created at 2022-08-17 01:59:34

Replying to [comment:2 klee]:
> Replying to [comment:1 tscrim]:
> > How broadly is Singular's functionality for free (graded) resolutions supposed to work?
> 
> Only quotients of free modules over multivariate polynomial rings.
> 
> > I can't seem to find anything definitive in the online documentation. 
> 
> This is pretty definitive:
> 
> https://www.singular.uni-kl.de/Manual/4-3-1/sing_988.htm#SEC1047

I don't find it so clear. What `R` is there? Is it a quotient of a polynomial ring like for the syzygies? The invocation of the Hilbert Syzygy Theorem does suggest that it is only for polynomial rings, but it might also be saying that it might not work for some quotients (but it might try).

> > Will it work for any commutative ring?
> 
> Definitely not. Singular uses Groebner bases, which do not apply to arbitrary commutative rings. Or do I misunderstand your question? 

I am not an expert in (computational) commutative algebras; thank you for the explanation.

So I will likely have to raise `NotImplementedError` in a number of cases, but at least it will be more publicly visible.


---

Comment by klee created at 2022-08-17 02:49:58

Replying to [comment:3 tscrim]:
> I don't find it so clear. What `R` is there? Is it a quotient of a polynomial ring like for the syzygies? The invocation of the Hilbert Syzygy Theorem does suggest that it is only for polynomial rings, but it might also be saying that it might not work for some quotients (but it might try).

I agree that it is vague. It says that `R` is a quotient of K[x]_> where K[x] is a multivariate polynomial ring.

In Singular, a monomial order > can be global, local, or mixed. Depending on this, K[x]_> may define just K[x], a localization of K[x], or something more complicated.

So according to the above definition, `R` can be something far from the plain K[x].

I never worked in Singular  with a monomial order other than global, the usual monomial orders. As far as I know, Sage also uses Singular's functionality limited to global monomial orders.

For (graded) free resolutions imported into Sage in a recent ticket, `R` is definitely the plain K[x].

I just looked over Singular manual, and I found no example of computing a free resolution for a module where `R` is other than the plain K[x], though I might be just unlucky.
 
> Will it work for any commutative ring?

`free_resolution()` could be attached to at least

- quotients of polynomial rings
- ideals of polynomial rings
- quotients of free modules over polynomial rings
- submodules of free modules over polynomial rings


---

Comment by tscrim created at 2022-08-17 03:23:55

It seems that #33950 doesn't handle the univariate case either:

```
sage: R.<x> = QQ[]
sage: I = R.ideal([x^4 + 3*x^2 + 2])
sage: FreeResolution(I)
<repr(<sage.homology.free_resolution.FreeResolution at 0x7fb357e0f9d0>) failed: TypeError: unknown argument type '<class 'sage.rings.polynomial.ideal.Ideal_1poly_field'>'>
```


```
sage: M = R^3
sage: v = M([x^4 + 3*x^2 + 2, x^3 + x - 2, x + 1])
sage: w = M([x^3 + 2*x + 4, x^2 + 3*x + 2, 2*x + 3])
sage: S = M.submodule([v, w])
sage: S
Free module of degree 3 and rank 2 over Univariate Polynomial Ring in x over Rational Field
Echelon basis matrix:
[                                                 1 -3/17*x^4 - 11/68*x^3 - 9/34*x^2 + 31/68*x + 11/34  -2/17*x^4 - 5/34*x^3 - 7/34*x^2 + 11/68*x + 49/68]
[                                                 0           3*x^5 + 2*x^4 + 7*x^3 + 6*x^2 + 6*x + 12            2*x^5 + 2*x^4 + 5*x^3 + 7*x^2 - 2*x + 2]
sage: FreeResolution(S)
<repr(<sage.homology.free_resolution.FreeResolution at 0x7fb357ef4700>) failed: TypeError: unknown argument type '<class 'sage.matrix.matrix_polynomial_dense.Matrix_polynomial_dense'>'>
```

Is this expected?

From the Singular documentation, I am guessing it also requires the polynomial ring to be over a field (mainly *Z* is not allowed either)?


---

Comment by tscrim created at 2022-08-17 03:28:24

Of course, I can trick Sage into making the univariate polynomial ring believe it is a multivariate one implemented in Singular. Although I would hope there would be an easier mechanism for doing this.


---

Comment by tscrim created at 2022-08-17 03:28:58

For example

```
sage: R.<x> = PolynomialRing(QQ, implementation="singular")
sage: type(R)
<class 'sage.rings.polynomial.multi_polynomial_libsingular.MPolynomialRing_libsingular'>
sage: I = R.ideal([x^4 + 3*x^2 + 2])
sage: FreeResolution(I)
S^1 <-- S^1 <-- 0
sage: M = R^3
sage: v = M([x^4 + 3*x^2 + 2, x^3 + x - 2, x + 1])
sage: w = M([x^3 + 2*x + 4, x^2 + 3*x + 2, 2*x + 3])
sage: S = M.submodule([v, w])
sage: FreeResolution(S)
S^3 <-- S^2 <-- 0
```



---

Comment by tscrim created at 2022-08-17 03:46:03

Another way of asking the above is there an easy way to make the univariate case work without converting everything to the Singular implementation?


---

Comment by tscrim created at 2022-08-17 03:53:04

Univariate polynomial rings over fields are PIDs and submodules of free modules over PIDs are free, right? So perhaps we should just handle this case within Sage?


---

Comment by tscrim created at 2022-08-17 04:05:44

A very minor typographical bug:

```
sage: GradedFreeResolution(I, degrees=[2,1], shifts=[-3])
S(--3) <-- S(--2)⊕S(-1) <-- S(-2) <-- 0
```



---

Comment by klee created at 2022-08-17 04:16:56

Replying to [comment:9 tscrim]:

You meant #33950.

> Univariate polynomial rings over fields are PIDs and submodules of free modules over PIDs are free, right? 

Right.

> So perhaps we should just handle this case within Sage?

Perhaps Singular requires K of K[x] to be a field. With R univariate polynomial ring, there is nothing interesting with free resolutions, as all submodules are free as you said.


---

Comment by tscrim created at 2022-08-17 04:22:35

Replying to [comment:11 klee]:
> Replying to [comment:9 tscrim]:
> 
> You meant #33950.

Yes; I fixed this above.

> > So perhaps we should just handle this case within Sage?
> 
> Perhaps Singular requires K of K[x] to be a field. With R univariate polynomial ring, there is nothing interesting with free resolutions, as all submodules are free as you said.

It actually doesn't seem to be too hard to have a check for this and tweak the code to handle these cases.


---

Comment by klee created at 2022-08-17 06:48:20

Replying to [comment:10 tscrim]:
> A very minor typographical bug:
> {{{
> sage: GradedFreeResolution(I, degrees=[2,1], shifts=[-3])
> S(--3) <-- S(--2)⊕S(-1) <-- S(-2) <-- 0
> }}}

How did you get this? What is `I`?


---

Comment by tscrim created at 2022-08-17 06:57:02

I am using `I` from comment:7. The point is that positive shifts are represented by double negatives.


---

Comment by klee created at 2022-08-17 07:10:54

Replying to [comment:14 tscrim]:
> I am using `I` from comment:7. 

`I` is not homogeneous, and the size of `degrees` is not the number of variables. So it is a wrong input.

> The point is that positive shifts are represented by double negatives.

I see. Please fix this here.


---

Comment by tscrim created at 2022-08-17 07:25:06

Replying to [comment:15 klee]:
> Replying to [comment:14 tscrim]:
> > I am using `I` from comment:7. 
> 
> `I` is not homogeneous, and the size of `degrees` is not the number of variables. So it is a wrong input.

Actually, there is no way it is the one from comment:7...I just forgot which one I used in my haste. `^^;;`

> > The point is that positive shifts are represented by double negatives.
> 
> I see. Please fix this here.

Will do.


---

Comment by tscrim created at 2022-08-17 08:26:06

Changing status from new to needs_review.


---

Comment by tscrim created at 2022-08-17 08:26:06

Okay, it is finally all ready. It took me a bit of time to figure out that when the matrix over-determines the system over a PID, then we should compute the echelon form.

One point of controversy might be the repr for the multigraded cases. My change effects the prints `(0,...,0)` and `(-a, -b)` instead of `0` and `-(a, b)`, respectively. I think this is better to indicate the multigrading by being verbose here. I can also change it so that `M((0,0))` gets printed as `M(0, 0)` instead, which might also be better.
----
New commits:


---

Comment by git created at 2022-08-22 07:32:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-22 07:33:19

This should now pass the patchbot.


---

Comment by klee created at 2022-08-23 05:59:12

I doubt if the code and examples around the attribute `_is_free_module` is worth to be added to `[Graded]FreeResolution` class so that the class is overloaded.

(1) As mentioned in :comment:11, no one is interested in computing the free resolution of a free module, because it is trivially defined by a free basis of the free module. Hence

(2) `[Graded]FreeResolution` is designed (and documented so) to work with modules over **multivariate** polynomial rings (via Singular). Moreover

(3) The added logic slows down the class, however slightly, for most useful cases just because of trivial cases no serious user of free resolutions would use. 

If you want to support free resolutions for free modules for completeness (I understand this motivation because you are adding the method `.[graded]free_resolution()` to arbitrary modules), you define a new class `FreeResolution_free_module` (and may need renaming `FreeResolution` to `FreeResolution_polynomial`) and make the `free_resolution()` method dispatch for appropriate resolution class depending on the kind of the module (or the base ring).


---

Comment by tscrim created at 2022-08-23 06:28:09

(1) No, but it can easily happen that your computation ends up doing some corner case. You shouldn't have to special case that for something that I would expect to just work.

(1') Actually, in #33953, can you guarantee that the result of `defining_ideal()` is always over a multivariate polynomial ring? I should have asked that during my review of that ticket. If this cannot be promised, then you only get to remove one of the `if`'s (the one in `_maps`; see below).

(2) Yes, but it can be extended.

(3) It is basically two fairly simple and fast `if` statements. If you are using it in a tight loop that that has a real impact on the performance (i.e., something not measured in microseconds or less than 1% of the computation time), then I will be extremely surprised.

That being said, I agree with you that it very reasonable to separate out this as a subclass as the main implementation (`_maps`) is quite different. I will need to think a bit about the best way to refactor this.


---

Comment by klee created at 2022-08-23 07:04:47

Replying to [comment:22 tscrim]:
> but it can easily happen that your computation ends up doing some corner case. 

No. The base ring does not change during the computation.

> (1') Actually, in #33953, can you guarantee that the result of `defining_ideal()` is always over a multivariate polynomial ring? 

Yes. It is about projective morphisms. The smallest projective space is `P^1`, whose coordinate ring has two variables.

> That being said, I agree with you that it is very reasonable to separate out this as a subclass as the main implementation (`_maps`) is quite different. 

It was my mistake that I didn't name it `FreeResolution_polynomial` from the first.

> I will need to think a bit about the best way to refactor this.

Thank you for working on this.


---

Comment by git created at 2022-08-23 07:56:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-23 07:57:36

Not quite done; still a few errors to quash. However, I wanted you to take a look at it with the conventions I chose. I can't work on it for the rest of tonight. Probably something stupid I did during the refactoring that are causing the current failures.


---

Comment by git created at 2022-08-24 03:33:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-08-24 03:36:15

I have fixed them all; it is ready.


---

Comment by git created at 2022-08-24 03:44:52

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-08-24 03:45:22

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2022-08-24 09:27:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2022-08-24 09:30:15

The last commit is experimental. I separated a constructor (function) and the abstract base class (of free resolutions) from your `FreeResolution` class. Isn't this more clear?


---

Comment by tscrim created at 2022-08-24 14:06:45

From a strictly local perspective about the logic of the creation, I agree. However, I oppose (probably even strongly) these types of constructors as it disassociates the class from the construction. In particular, the result of `FreeResolution` is not `isinstance(res, FreeResolution)` and the creation documentation is either duplicated or separate from the class. This kind of construction/dispatch idiom is used all over Sage (usually with `UniqueRepresentation`).


---

Comment by klee created at 2022-08-25 05:45:15

Replying to [comment:32 tscrim]:
> In particular, the result of `FreeResolution` is not `isinstance(res, FreeResolution)`

I agree that this is unfortunate. But it seems that it is rather hard to find a case that this is true.

```
sage: F.<x> = FunctionField(QQ)
sage: isinstance(F, FunctionField)
TypeError...
sage: P.<x> = PolynomialRing(QQ)
sage: isinstance(P, PolynomialRing)
TypeError...
sage: C = EllipticCurve(QQ, [1,1])
sage: isinstance(C, EllipticCurve)
TypeError...
```



---

Comment by klee created at 2022-08-25 05:47:58

I can't work on this in following days. Let me get back to you later, with other (perhaps minor) edits.


---

Comment by tscrim created at 2022-08-25 06:57:02

It helps to not look in old code:

```
sage: isinstance(Partitions(), Partitions)
True
sage: isinstance(Partitions(5), Partitions)
True
sage: isinstance(Tableaux(), Tableaux)
True
sage: isinstance(Tableaux(max_entry=5), Tableaux)
True
sage: isinstance(Tableaux(shape=[2,1], max_entry=5), Tableaux)
True
```

This isn't universal, and for very complicated implementations, like matrices and polynomial rings, the burden on developers (and sometimes because of the implementation choice) would be too great to have this feature.

No problem. There isn't a rush on this as this almost certainly won't get into 9.7.


---

Comment by git created at 2022-08-28 09:29:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2022-08-28 09:42:50

This is still experimental. 

I introduced `ConstructorBaseclassMetaclass` slightly modified from `ClasscallMetaclass`. The idea is to separate the constructor definition from the base class definition but still manage so that `isinstance(r, FreeResolution)` holds.

For me, the separation is more important, but the `isinstance` feature is more visible. Hence this compromise.


---

Comment by tscrim created at 2022-08-29 00:53:33

I don't see the point in this added complexity. This paradigm puts the constructor code "far" (not necessarily literally) from the code that actually should be doing the construction. I would want to put the constructor as a method called `__constructor__` instead of `__classcall__`/`__classcall_private__`. This also creates tension (to maybe even an outright conflict) with any `UniqueRepresentation` class, including those that do a combination of normalizing inputs and dispatching to subclasses. Basically, you can do the same thing but have `__classcall_private__ = construction_function` with no additional metaclass.

In either case, it would still require some justification for why it is not simply a method of the class. As mentioned, the separation is actually the problem: The programmer should find within the class called the method doing the construction. (Of course, this is not a hard rule as there can be good reasons, typically due to code complexity.) It is a standard idiom within Sage that `__classcall_[private_]_` is called before `__init__`.

Here is also something I see as a roughly equivalent scenario. Suppose to have a class that in its `__init__` instead changes its `__class__` attribute based upon its input (rather than dispatching out to an appropriate subclass, which could be reasonable as the subclass would do nothing different with its input). Should that `__init__` method be a separate construction function? NB: `Parent` does this with the category.


---

Comment by klee created at 2022-08-29 02:22:01

Replying to [comment:38 tscrim]:
> In either case, it would still require some justification for why it is not simply a method of the class. As mentioned, the separation is actually the problem: The programmer should find within the class called the method doing the construction. (Of course, this is not a hard rule as there can be good reasons, typically due to code complexity.) 

Code complexity is the justification. The constructor involves all subclasses of the base class. The programmer expects to find the constructor outside of(even in a different file, but not within) one of those classes. The sole reason to put the constructor inside the class via `__classcall_private__` is to make `isinstance` feature work. You agreed with this. No?

Moreover it is hard to realize that the code defined in the method `__classcall_private__` actually serves as a constructor. The new metaclass is explicit about this. 

`Parent` is unique in the whole sage library. It is irrelevant how `Parent` solves its own problem.


---

Comment by tscrim created at 2022-08-29 05:55:27

Replying to [comment:39 klee]:
> Replying to [comment:38 tscrim]:
> > In either case, it would still require some justification for why it is not simply a method of the class. As mentioned, the separation is actually the problem: The programmer should find within the class called the method doing the construction. (Of course, this is not a hard rule as there can be good reasons, typically due to code complexity.) 
> 
> Code complexity is the justification. The constructor involves all subclasses of the base class. The programmer expects to find the constructor outside of(even in a different file, but not within) one of those classes.

If you were going to construct a `FreeResolution`, which returned something where `isinstance(res, FreeResolution)` is `True`, you would actually be looking at a different place for the construction than in `FreeResolution`? This is completely contrary with the behavior of `__init__`.

> The sole reason to put the constructor inside the class via `__classcall_private__` is to make `isinstance` feature work. You agreed with this. No?

Not with it being the sole reason; just a reason. It also associates the constructor (and any potential normalization of inputs) with the class itself. It also means you do not have to write duplicate documentation or have any question about where certain documentation aspects should go. It also makes it visible by, e.g., `FreeResolution??`.

> Moreover it is hard to realize that the code defined in the method `__classcall_private__` actually serves as a constructor. The new metaclass is explicit about this. 

I agree that the name makes it somewhat difficult to see this without realizing that you have something with a `ClasscallMetaclass` for the uninitiated, including what the method `__classcall_[private_]_` is suppose to do.

The problems I have with it are:

1. It is duplicating what `ClasscallMetaclass` does with a different name.
2. How do you resolve the issue of who-does-what when it also is, e.g., a `UniqueRepresentation` (both normalization and dispatch)?
3. It is not scalable: You need a completely parallel tree of classcall metaclass subclass tree (e.g., `ClasscallMetaclassInheritComparisons`).

Because of the size of the duplication, (1) is a relatively small issue. However, it does have a code smell to me.
(2) could be resolved with judicious and meticulous documentation, but I suspect it will just reinforce (1).
(3) Right now, the number of classes is small, but it does create lots of extra maintenance burden for future developers (basically technical debt).

Since your biggest issue seems to be discoverability for a programmer with the name (which could potentially also be resolved in cases like this with some code comments, say, just before the class declaration or the `__init__()` method), perhaps we can add a feature to `ClasscallMetaclass` that also parses in `__construction__` (using your experimental name; not 100% set on it yet, possible alternatives `__dispatcher__` or `__factory__`).

> `Parent` is unique in the whole sage library. It is irrelevant how `Parent` solves its own problem.  

It is just an example. Right now I don't think we have any others, but this is something that has its uses (although there are likely better methods of doing this; this [SO post](https://stackoverflow.com/questions/13280680/how-dangerous-is-setting-self-class-to-something-else) talks a bit about them). However, what would you expect in such a case? In particular, why is that different than automatic dispatching to a subclass?


---

Comment by klee created at 2022-08-30 02:44:30

Replying to [comment:40 tscrim]:
> If you were going to construct a `FreeResolution`, which returned something where `isinstance(res, FreeResolution)` is `True`, you would actually be looking at a different place for the construction than in `FreeResolution`? This is completely contrary with the behavior of `__init__`.

By your idiom, we have "constructor + base class" (CB). It seems you see CB primarily as a constructor and I see CB as primarily a base class. This controversy itself indicates CB is a bad idiom. CB is against the principle of separation of concerns.

> > The sole reason to put the constructor inside the class via `__classcall_private__` is to make `isinstance` feature work. You agreed with this. No?
> 
> Not with it being the sole reason; just a reason. It also associates the constructor (and any potential normalization of inputs) with the class itself. It also means you do not have to write duplicate documentation or have any question about where certain documentation aspects should go. 

I don't see why it is desirable to associate the constructor and the base class by combining the code. There is no duplication in documentations. Actually in (CB), there is no place for either of them.

> It also makes it visible by, e.g., `FreeResolution??`.

Hmm. This is a critical disadvantage of my new metaclass (MC). It will show the documentation of the base class. But this might be fixed.

As I originally suggested, I prefer the classical solution (CL): 

```
def FreeResolution(...):  # constructor
    ...

class FreeResolution_base(...):  # base class
    ....
```


The sole reason I devised the new metaclass is to make `isinstance` feature work. (I think your idiom was first devised for the same purpose. No?) By the way, how important is this feature? This is for end users. I don't really see a use case. Is it important when working with combinatorial objects?

> 2. How do you resolve the issue of who-does-what when it also is, e.g., a `UniqueRepresentation` (both normalization and dispatch)?
> 3. It is not scalable: You need a completely parallel tree of classcall metaclass subclass tree (e.g., `ClasscallMetaclassInheritComparisons`).

Sorry. I don't really understand the issues. A simple-minded answer: do not use MC in problematic situations.

> Since your biggest issue seems to be discoverability for a programmer with the name ...

My biggest issue is the presence of the definition of the constructor inside the base class. This looks strange and is hard to understand what is going on with the class. It will be the same when a developer sees it for the first time. 

> > `Parent` is unique in the whole sage library. It is irrelevant how `Parent` solves its own problem.  
> 
> It is just an example. Right now I don't think we have any others, but this is something that has its uses (although there are likely better methods of doing this; this [SO post](https://stackoverflow.com/questions/13280680/how-dangerous-is-setting-self-class-to-something-else) talks a bit about them). However, what would you expect in such a case? In particular, why is that different than automatic dispatching to a subclass?

The difference from what `Parent` does with `__class__` is that the detailed **code** of the automatic dispatching (what a constructor does) is all visible inside the base class. (MC) works in the same way with (CB) but moves the dispatching code out of the base class.


---

Comment by tscrim created at 2022-08-30 05:37:57

Replying to [comment:41 klee]:
> Replying to [comment:40 tscrim]:
> > If you were going to construct a `FreeResolution`, which returned something where `isinstance(res, FreeResolution)` is `True`, you would actually be looking at a different place for the construction than in `FreeResolution`? This is completely contrary with the behavior of `__init__`.
> 
> By your idiom, we have "constructor + base class" (CB). It seems you see CB primarily as a constructor and I see CB as primarily a base class.

No, I see it as both because a base class should have a way to return an instance of itself based upon inputs. Good OOP says you don't care about the implementation details; in this case, the exact class is constructed. Python just doesn't have a good hook for this; `__init__` is already working with a specific instance.

> This controversy itself indicates CB is a bad idiom.

That is an absurd argument: Any controversy implies bad idiom.

> CB is against the principle of separation of concerns.

This makes no sense. It is the concern of the object to construct itself.

From doing a bit of Google searching, the modern trend in a factory design pattern (which is the construction function/method here) when there is a common base case is to associate the factory object to the base class ([a C++ example](https://www.linkedin.com/pulse/factory-design-pattern-vishal-chovatiya/)). This is what this idiom is doing with a bit of syntatic sugar to make it work through the usual `__call__` protocol (by overriding that special method). We have just chosen a fairly generic name of `__classcall__` (that reflects when the method is called) rather than something more specific like `__construction__` or `_factory_`.

> > > The sole reason to put the constructor inside the class via `__classcall_private__` is to make `isinstance` feature work. You agreed with this. No?
> > 
> > Not with it being the sole reason; just a reason. It also associates the constructor (and any potential normalization of inputs) with the class itself. It also means you do not have to write duplicate documentation or have any question about where certain documentation aspects should go. 
> 
> I don't see why it is desirable to associate the constructor and the base class by combining the code. There is no duplication in documentations.

Yes there is. If we take (CL) remember that the forward facing documentation is in the constructor function. So `FreeResolution?` gives that documentation. However, if we do the same for `res?`, we get the class documentation of `FreeResolution_base`. Thus, where should the description of the object go?

Another way to think of this, which is what I am getting at with overriding `__class__`, is that it is an upscale version of `__init__` of the class. We at least agree that `__init__` should be defined in the class, right?

Remember that subclasses are a very useful way of getting around having a bunch of `if` statements in the code deciding behavior of objects (and generally reduces the maintenance burden). This is basically why we have the two different classes for the Singular version and the free module version (or if we come along with a different implementation later on). They are implementation details that do not change the general model the code is representing, and associating the constructor with the base class is in line with that implementation too.

(I actually thought about splitting the resolution code up based upon the input being a module/ideal/matrix. However, I concluded that the tradeoff in complexity for doing that wasn't worth it.)

> Actually in (CB), there is no place for either of them.

All documentation about the object should clearly go in the class level description of the base class. Furthermore, if you need to document specific inputs to the base class, that can go in the `__init__` documentation, which is the natural place to look as it is describing its inputs.

> > It also makes it visible by, e.g., `FreeResolution??`.
> 
> Hmm. This is a critical disadvantage of my new metaclass (MC). It will show the documentation of the base class. But this might be fixed.

I am just guessing about your possible solutions to this, but the top one would be to copy the base class's doc. However, you would also have to deal with the raw code (where there would be a disassociation with the documentation), doctests (how would I associate a particular doctest with the constructor versus the base class), and how we measure coverage (related also with how many duplicate tests would this yield). Although I probably shouldn't comment too much until there is an actual proposal.

> As I originally suggested, I prefer the classical solution (CL): 
> The sole reason I devised the new metaclass is to make `isinstance` feature work. (I think your idiom was first devised for the same purpose. No?)

AFAIK, the `ClasscallMetaclass` was originally for normalizing inputs to `CachedRepresentation`. Although it was soon applied to handle construction (and possibly dispatch) of element classes, such as `Tableau`, without having to construct an explicit parent. This was mostly used for combinatorial objects early on.

> By the way, how important is this feature? This is for end users. I don't really see a use case. Is it important when working with combinatorial objects?

It is also useful for things like algebras that have different implementations based upon their inputs. Polynomial rings are a great example of this (but don't currently implement this idiom). For instance, you could have code like

```python
def foo(R=None):
    if R is None:
        R = PolynomialRing(QQ, 'x,y')
    if isinstance(R, PolynomialRing_general):
        return 1
    return 2
```

From a naïve look, why would the default argument for `R` lead to case `1`? It seems like they should be different. By being separate, the constructor is not under even a tacit promise to return a subclass of `PolynomialRing_general`. In fact, this is true in this example as there is no common ABC for univariate and multivariate polynomial rings (which has caused me some headaches).

You also have to rename something when there is a conflict between the name of the base class and the factory name:

```
sage: import_statements(matrix)
# ** Warning **: several names for that object: Matrix, matrix
from sage.matrix.constructor import Matrix
sage: from sage.structure.element import Matrix  # not the constructor!
```

Hence, it would make it easier on the developer who has to use the class.

> > 2. How do you resolve the issue of who-does-what when it also is, e.g., a `UniqueRepresentation` (both normalization and dispatch)?
> > 3. It is not scalable: You need a completely parallel tree of classcall metaclass subclass tree (e.g., `ClasscallMetaclassInheritComparisons`).
> 
> Sorry. I don't really understand the issues. A simple-minded answer: do not use MC in problematic situations.

Please define what you mean by a problematic situation. It seems like you are wanting to say it is a case when there is a conflict between your new metaclass and `UniqueRepresentation` (or anything else that uses one of the other metaclasses). This is not a feasible option as we need to support both behaviors. Your proposal is creating issues where there were none previously.

> > Since your biggest issue seems to be discoverability for a programmer with the name ...
> 
> My biggest issue is the presence of the definition of the constructor inside the base class. This looks strange and is hard to understand what is going on with the class. It will be the same when a developer sees it for the first time. 

That is true for basically any idiom, especially the project-specific ones. (As I mentioned above, this is not so Sage specific, mostly just the name `__classcall_private__`.) For instance, `UniqueRepresentation`. I agree that a new Sage developer who is an experienced programmer will have to learn something; there is no perfect solution. However, this idiom is easy to teach, simple, flexible, and has many natural aspects.

> > > `Parent` is unique in the whole sage library. It is irrelevant how `Parent` solves its own problem.  
> > 
> > It is just an example. Right now I don't think we have any others, but this is something that has its uses (although there are likely better methods of doing this; this [SO post](https://stackoverflow.com/questions/13280680/how-dangerous-is-setting-self-class-to-something-else) talks a bit about them). However, what would you expect in such a case? In particular, why is that different than automatic dispatching to a subclass?
> 
> The difference from what `Parent` does with `__class__` is that the detailed **code** of the automatic dispatching (what a constructor does) is all visible inside the base class. (MC) works in the same way with (CB) but moves the dispatching code out of the base class. 

I don't understand this. The base class is the one that chooses which instance to build and ultimately dispatches out to that `__init__`. There is no initialization or construction dispatching done with `Parent` setting `__class__` to a dynamic subclass built from the category (in particular, it never goes back down or calls any other `__init__` lower that `Parent` in its MRO). In fact, that the constructor code becoming visible somewhere in the MRO with the (CB) method is what you want, right?


---

Comment by klee created at 2022-08-30 07:40:21

Replying to [comment:42 tscrim]:
> because a base class should have a way to return an instance of itself based upon inputs. 

But not of its subclass. It looks like that in your idiom.

Sorry. I feel tired of this discussion. I can't follow your arguments and I don't want to repeat my arguments. 

As least, your idiom works. My complaint is only about the organization of the code. I will revert back the branch to your idiom.


---

Comment by git created at 2022-09-01 00:25:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2022-09-01 00:27:48

Mostly minor edits. I modified or deleted some examples of graded free resolutions with non-homogeneous inputs. 

Otherwise looks good to me.


---

Comment by tscrim created at 2022-09-01 08:53:43

Thank you.

The only thing I am not sure about is the change for the resolution in free module handling things rather than `FreeResolution`. This also includes my implementation for the multipolynomial ideals (I think at the time, I didn’t have a single such entry point). We are duplicating some of the logic there, so there is more work to be done if another implementation is provided (in particular, if it expands the capabilities).

This isn’t really a big thing as we can revisit it should additional implementations be provided. I just wanted to see what you thought about this.


---

Comment by klee created at 2022-09-02 02:50:57

Replying to [comment:47 tscrim]:
> Thank you.
> 
> The only thing I am not sure about is the change for the resolution in free module handling things rather than `FreeResolution`. 

Like your `M.graded_free_resolution()`, the dispatching to specific free resolution subclasses (those with `_singular` and `_free_module` postfixes) should happen in `M.free_resolution()` as this method has information about `M`. I regard these methods as the primary dispatcher to the free resolution subclasses.

Then there is your `FreeResolution` dispatcher (I will not use the term "constructor" as, it seems, we understand the term differently) inside `FreeResolution` base class. I regard this as a secondary way to use the free resolution subclasses. Hence your dispatcher may use the methods `M.[graded_]free_resolution()` depending on the type of the input `M`. Then there would be no duplication of code.

> ... my implementation for the multipolynomial ideals (I think at the time, I didn’t have a single such entry point). 

I don't understand this. Would you name it explicitly? Where is it?


---

Comment by tscrim created at 2022-09-02 05:43:51

Replying to [comment:48 klee]:
> Replying to [comment:47 tscrim]:
> > Thank you.
> > 
> > The only thing I am not sure about is the change for the resolution in free module handling things rather than `FreeResolution`. 
> 
> Like your `M.graded_free_resolution()`, the dispatching to specific free resolution subclasses (those with `_singular` and `_free_module` postfixes) should happen in `M.free_resolution()` as this method has information about `M`. I regard these methods as the primary dispatcher to the free resolution subclasses.

Your current proposal is not a good programming practice as it is not scalable. More concretely, you now have at least two different ways (that are not linked) for creating the free resolutions from, e.g., a module. Now you need to keep them consistent, which can be tedious as the code grows.

> Then there is your `FreeResolution` dispatcher (I will not use the term "constructor" as, it seems, we understand the term differently) inside `FreeResolution` base class. I regard this as a secondary way to use the free resolution subclasses. Hence your dispatcher may use the methods `M.[graded_]free_resolution()` depending on the type of the input `M`. Then there would be no duplication of code.

This would be good with me. So we would have

```python
def __classcall_private__(cls, M, *args, **kwds):
    try:
        return M.free_resolution(*args, **kwds)
    except AttributeError:
        raise ValueError(“unable to construct a free resolution”)
```

It is just right now we are duplicating the code. You will also need to add a `[graded_]free_resolution()` method to matrices.

The reason I didn’t chose this approach was because there would still be some code duplication and scalability to address since all of these inputs types are treated as a module. For instance, if I implement a way to compute resolutions using a polynomial ring over an arbitrary field (not just ones that Singular can recognize). Then we need to update all of the different free resolution methods to allow for this more general case. However your proposal is reasonable and isn’t (yet) so unwieldy that it is a significant burden, so let’s go with it.

> > ... my implementation for the multipolynomial ideals (I think at the time, I didn’t have a single such entry point). 
> 
> I don't understand this. Would you name it explicitly? Where is it?

Clearly the main entry point was designed to be `FreeResolution`.


---

Comment by klee created at 2022-09-02 06:18:23

Replying to [comment:49 tscrim]:
> You will also need to add a `[graded_]free_resolution()` method to matrices.

Free resolutions are about modules (ideals are also modules). Matrix is one way to specify a module. You don't need to attach the methods to matrices. I would not.


---

Comment by tscrim created at 2022-09-02 06:29:48

Replying to [comment:50 klee]:
> Replying to [comment:49 tscrim]:
> > You will also need to add a `[graded_]free_resolution()` method to matrices.
> 
> Free resolutions are about modules (ideals are also modules). Matrix is one way to specify a module. You don't need to attach the methods to matrices. I would not. 

Then we should disallow a matrix as input altogether.


---

Comment by klee created at 2022-09-02 07:24:36

Replying to [comment:51 tscrim]:
> Replying to [comment:50 klee]:
> > Replying to [comment:49 tscrim]:
> > > You will also need to add a `[graded_]free_resolution()` method to matrices.
> > 
> > Free resolutions are about modules (ideals are also modules). Matrix is one way to specify a module. You don't need to attach the methods to matrices. I would not. 
> 
> Then we should disallow a matrix as input altogether.

You may do so for `FreeResolution` dispatcher. But please do not remove it from the free resolution classes for internal use. By allowing a matrix as input to our free resolution classes, we may remove a small amount of conversion overhead (matrix -> module -> matrix) in those not-uncommon cases that we have a matrix on our hand.


---

Comment by tscrim created at 2022-09-02 07:57:53

I think you’re trying to have it both ways with matrices being automatically being treated as submodules (for an insignificant optimization  (relative to the main computations) at the cost of code complexity). However, what I will do is have special handling within the `FreeResolution` hook because being consistent across the inputs is important to me and I want to do what I can to accommodate your viewpoints.


---

Comment by klee created at 2022-09-02 08:49:48

Replying to [comment:53 tscrim]:
> I think you’re trying to have it both ways with matrices being automatically being treated as submodules (for an insignificant optimization  (relative to the main computations) 

Yes.

> at the cost of code complexity. 

As I see it, the code complexity is also insignificant, and the code is already there.

> what I will do is have special handling within the `FreeResolution` hook because being consistent across the inputs is important to me.

Okay. Then I won't insist on the matrix input if, as you see it, it would be a maintenance burden for your work with free resolution classes.


---

Comment by klee created at 2022-09-07 04:36:40

Are you working on this or waiting for review as it is?


---

Comment by tscrim created at 2022-09-07 04:59:54

Sorry, I have been busy with family stuff and writing grants, and I did not have access to my laptop. Right now Sage is building on my laptop, and I plan to make the change after that is done. Give me a few more hours.


---

Comment by git created at 2022-09-07 10:44:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-07 10:45:49

Here we go. I did was we agreed upon: the `FreeResolution` dispatches out to `[graded_]free_resolution()` with special handling for matrices.

I changed the projective morphism to use the hook.

I also fixed some an issue with the previous ticket that I should have caught: the `singular.pyx` has full coverage now.


---

Comment by git created at 2022-09-07 11:41:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by klee created at 2022-09-07 11:57:33

In `FreeModule`, why do you check if the `module` is a free module only when `module` is a matrix? You wanted to provide free resolutions for free modules.  

In `sage.rings.ideal`, you provided `free_resolution()` hook. In this context, an ideal is of a general commutative ring, but your code seems to assume that the ring is a univariate polynomial ring over a field. You need to check this first. If the ring is other than that, raise a `NotImplemented` error.


---

Comment by tscrim created at 2022-09-07 12:32:51

Replying to [comment:60 Kwankyu Lee]:
> In `FreeModule`, why do you check if the `module` is a free module only when `module` is a matrix? You wanted to provide free resolutions for free modules.  

This is what we agreed on: special check for matrices because you wanted the code to handle it but not add a method to the matrix classes. Thus, the main entry point needs to process it. Everything else is delegated to `free_resolution()`.

> In `sage.rings.ideal`, you provided `free_resolution()` hook. In this context, an ideal is of a general commutative ring, but your code seems to assume that the ring is a univariate polynomial ring over a field. You need to check this first. If the ring is other than that, raise a `NotImplemented` error. 

I require the ideal is principal, which is automatically free because it has a single generator. This case holds for all commutative rings, right? All other cases will raise an `NotImplementedError` either via the `is_principal()` call or from the result being `False`.


---

Comment by klee created at 2022-09-07 13:55:16

Replying to [comment:61 Travis Scrimshaw]:
> > In `sage.rings.ideal`, you provided `free_resolution()` hook. In this context, an ideal is of a general commutative ring, but your code seems to assume that the ring is a univariate polynomial ring over a field. You need to check this first. If the ring is other than that, raise a `NotImplemented` error. 
> 
> I require the ideal is principal, which is automatically free because it has a single generator. This case holds for all commutative rings, right? 

Yes.

> All other cases will raise an `NotImplementedError` either via the `is_principal()` call or from the result being `False`.

I see. Okay.


---

Comment by tscrim created at 2022-09-07 14:16:34

If you’re good with my changes and the patchbot comes back green (or you are confident with the appropriate tests being run), then positive review?


---

Comment by klee created at 2022-09-07 14:29:13

Replying to [comment:61 Travis Scrimshaw]:
> Replying to [comment:60 Kwankyu Lee]:
> > In `FreeModule`, why do you check if the `module` is a free module only when `module` is a matrix? You wanted to provide free resolutions for free modules.  
> 
> This is what we agreed on: special check for matrices because you wanted the code to handle it 

No. I wanted that the matrix input is kept in (`__init__()` of) free resolution subclasses.
But I even agreed to remove it if you want because of maintenance burden.

For `FreeResolution` dispatcher, I think that not accepting matrix input is the right way. I think I agreed upon this...


---

Comment by klee created at 2022-09-07 14:41:10

You removed 

```
        if isinstance(module, Ideal_generic):
            S = module.ring()
            if len(module.gens()) == 1 and S in IntegralDomains():
                is_free_module = True
        elif isinstance(module, Module_free_ambient):
            S = module.base_ring()
            if (S in PrincipalIdealDomains()
                or isinstance(module, FreeModule_generic)):
                is_free_module = True 
```

from `FreeResolution` dispatcher, are these cases handled in `free_resolution()`? Or you decided not to handle those cases?


---

Comment by tscrim created at 2022-09-07 14:58:59

Replying to [comment:64 Kwankyu Lee]:
> Replying to [comment:61 Travis Scrimshaw]:
> > Replying to [comment:60 Kwankyu Lee]:
> > > In `FreeModule`, why do you check if the `module` is a free module only when `module` is a matrix? You wanted to provide free resolutions for free modules.  
> > 
> > This is what we agreed on: special check for matrices because you wanted the code to handle it 
> 
> No. I wanted that the matrix input is kept in (`__init__()` of) free resolution subclasses.
> But I even agreed to remove it if you want because of maintenance burden.
 
This isn't really that much of a burden, especially since we don't fundamentally want to work with the module but the underlying matrix. We have a good justification for the special case of matrices.

> For `FreeResolution` dispatcher, I think that not accepting matrix input is the right way. I think I agreed upon this...

If the class accepts a matrix, then the dispatcher should be able to handle the matrix. I think it would be really strange to have this discrepancy. Plus the constructor does some things to sanitize the input; in particular, it makes sure the matrix is immutable as this can lead to some very subtle bugs that are very hard to track down. (For example, you pass a mutable matrix into the constructor, compute the resolution, mutate the matrix; now the resolution does not necessarily match the input matrix.)

Actually, this makes me think of a case it should also handle: a free resolution input (where it would just return the input up to maybe stripping/adding the grading).


---

Comment by tscrim created at 2022-09-07 14:59:43

Replying to [comment:65 Kwankyu Lee]:
> You removed 
> {{{
>         if isinstance(module, Ideal_generic):
>             S = module.ring()
>             if len(module.gens()) == 1 and S in IntegralDomains():
>                 is_free_module = True
>         elif isinstance(module, Module_free_ambient):
>             S = module.base_ring()
>             if (S in PrincipalIdealDomains()
>                 or isinstance(module, FreeModule_generic)):
>                 is_free_module = True 
> }}}
> from `FreeResolution` dispatcher, are these cases handled in `free_resolution()`? Or you decided not to handle those cases?

These are handled by the respective `free_resolution()` methods in, e.g., ideal.


---

Comment by klee created at 2022-09-07 15:16:53

Replying to [comment:66 Travis Scrimshaw]:
> Actually, this makes me think of a case it should also handle: a free resolution input (where it would just return the input up to maybe stripping/adding the grading).

Why? This is strange. `PolynomialRing(PolynomialRing(QQ))` does not work in that way.


---

Comment by klee created at 2022-09-07 15:18:17

trac is buggy...


---

Comment by tscrim created at 2022-09-07 15:23:20

Replying to [comment:69 Kwankyu Lee]:
> Replying to [comment:66 Travis Scrimshaw]:
> > Actually, this makes me think of a case it should also handle: a free resolution input (where it would just return the input up to maybe stripping/adding the grading).
> 
> Why? This is strange. `PolynomialRing(PolynomialRing(QQ))` does not work in that way.

Right, that was dumb of me. I was thinking it was more `Element`-like (e.g., `Partition`), but it is `Parent`-like (or function-like).

Do you think it would be useful to implement a method in graded free resolutions like `as_ungraded()` that forgets the grading?


---

Comment by klee created at 2022-09-07 15:47:09

Replying to [comment:71 Travis Scrimshaw]:
> Do you think it would be useful to implement a method in graded free resolutions like `as_ungraded()` that forgets the grading?

No as far as I know. Let's leave that as a future work for who needs it.


---

Comment by klee created at 2022-09-07 15:48:07

Now let this go.


---

Comment by klee created at 2022-09-07 15:48:07

Changing status from needs_review to positive_review.


---

Comment by git created at 2022-09-07 16:20:22

Branch pushed to git repo; I updated commit sha1 and set ticket back to needs_review. New commits:


---

Comment by git created at 2022-09-07 16:20:22

Changing status from positive_review to needs_review.


---

Comment by klee created at 2022-09-07 16:21:26

Changing status from needs_review to positive_review.


---

Comment by tscrim created at 2022-09-07 23:34:02

Thank you. This improved the code from my original proposal.

It took me a minute to realize that this is equivalent to the way I am used to seeing the definition of a resolution with `0 <- M <- F_1 <- ...`. However, this is definitely the better way to present this given the string representation.


---

Comment by klee created at 2022-09-08 00:31:04

Replying to [comment:76 Travis Scrimshaw]:
> Thank you. This improved the code from my original proposal.

Thank you for the work. 

If we want to be more mathematical, matrix input may be entirely removed. But we may regard matrix input as an added conveniency feature. I am happy in either way.
 
> It took me a minute to realize that this is equivalent to the way I am used to seeing the definition of a resolution with `0 <- M <- F_1 <- ...`. However, this is definitely the better way to present this given the string representation.

A resolution of `M` is also said to be a resolution of `F_1/M`. See pages 22-23 of

https://faculty.math.illinois.edu/Macaulay2/Book/ComputationsBook/book/book.pdf

It seems that "resolution of `M`" is more conventional, but I think "resolution of `F_1/M`" is more reasonable. If you want to augment `F_1 <- ... <- 0` at the left to get an exact sequence, that should be

`0 <- F_1/M <- F_1 <- ... <- 0`

where the canonical map `F_1/M <- F_1` is our 0-th differential map and `F_1/M` is our `target()`.


---

Comment by vbraun created at 2022-09-22 22:35:33

Resolution: fixed
