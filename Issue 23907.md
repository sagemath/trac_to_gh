# Issue 23907: Implement Psi and Phi bases for QSym

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2017-11-03 02:12:12

CC:  sage-combinat darij zabrocki saliola amypang

Keywords: qsym, symmetric functions

Following https://arxiv.org/abs/1710.11613, we can define Psi and Phi bases for QSym: the powersum bases of the first and second kind.


---

Comment by tscrim created at 2017-11-03 02:13:45

Changing status from new to needs_review.


---

Comment by tscrim created at 2017-11-03 02:13:45

Just a basic implementation. It does do a slight abuse of `dual`, but I think in a very natural way, and I modified `duality_pairing` accordingly.
----
New commits:


---

Comment by darij created at 2017-11-04 04:31:01

A couple comments (I'm not reviewing this in foreseeable time, but these things caught my eye):

1) I don't like the redefinition of `duality_pairing`. If I make Sage compute the duality pairing between an element in the QSym Phi basis and the NSym H basis, then "who wins" -- the standard pairing or the rescaled one? (I guess the rescaled one, but this isn't very natural.)

Could you move the `ncsf.py` changes to a different ticket, or do you actually use them in `qsym.py`? That would make reviewing easier.

2) 

```
+            \Phi_I = \sum_{J \succ I} z_I / sp_{I,J} M_I,
```

The M_I should be M_J here. Same in the \Psi_I formula.

3) I doubt that the Phi-basis is defined over any base ring. Don't they give the example
Phi_322 = 2M_322 + M_52 + M_34 + 1/3 M_7
in the preprint?

[OT: Speaking of splitting tickets for easier review, I'm wondering what you think of splitting out the Hall basis from the free-Lie-algebra ticket... I'm pretty positive I could review the Lyndon basis easily enough.]


---

Comment by tscrim created at 2017-11-04 04:46:42

Replying to [comment:2 darij]:
> A couple comments (I'm not reviewing this in foreseeable time, but these things caught my eye):
> 
> 1) I don't like the redefinition of `duality_pairing`. If I make Sage compute the duality pairing between an element in the QSym Phi basis and the NSym H basis, then "who wins" -- the standard pairing or the rescaled one? (I guess the rescaled one, but this isn't very natural.)

It doesn't matter because they give the same value.

> Could you move the `ncsf.py` changes to a different ticket, or do you actually use them in `qsym.py`? That would make reviewing easier.

In some ways that is a loaded question. I don't specifically use them, but they do now have a well-defined "dual" basis (up to the rescaling). So in some sense it is wrong to not define them, and those are easy, localized additions in `ncsf.py`.

> 2) 
> {{{
> +            \Phi_I = \sum_{J \succ I} z_I / sp_{I,J} M_I,
> }}}
> The M_I should be M_J here. Same in the \Psi_I formula.

Fixed.

> 3) I doubt that the Phi-basis is defined over any base ring. Don't they give the example
> Phi_322 = 2M_322 + M_52 + M_34 + 1/3 M_7
> in the preprint?

I copied the wrong disclaimer. Fixed.

> [OT: Speaking of splitting tickets for easier review, I'm wondering what you think of splitting out the Hall basis from the free-Lie-algebra ticket... I'm pretty positive I could review the Lyndon basis easily enough.]

[I'm opposed to it. The name of the basis is not the best, but it is a different basis, it does work, and it fits naturally with that ticket. I just wish I could find the precise reference that I used for you to look at.]


---

Comment by git created at 2017-11-04 04:47:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by darij created at 2017-11-04 05:31:43

Thanks for the fix! But there's one little copypaste bug in there: You refer to "The `\Phi`-basis" in the Psi doc.

Anyone else wants to weigh in whether it is important that `dual` and `duality_pairing` on a CHA WithRealizations always refer to the same pairing, or whether it is OK that the pairing depends on the realization?

[OT about free Lie: Hard to tell without seeing the proper diff, but I believe there are more serious issues with the Hall basis than just the lack of a reference. But even with a reference, I'd need to actually read it. I would review the Lyndon basis ASAP, whereas the Hall one can wait until IMA coding sprints.]

PS. One more typo: `1^{m-1}` should be `1^{m_1}` in both Phi and Psi basis docs.


---

Comment by git created at 2017-11-04 05:36:49

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-11-04 05:37:46

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by tscrim created at 2017-11-04 05:39:03

Replying to [comment:5 darij]:
> Thanks for the fix! But there's one little copypaste bug in there: You refer to "The `\Phi`-basis" in the Psi doc.

Fixed (including the PS).

> Anyone else wants to weigh in whether it is important that `dual` and `duality_pairing` on a CHA WithRealizations always refer to the same pairing, or whether it is OK that the pairing depends on the realization?


---

Comment by amypang created at 2017-11-04 05:47:14

Replying to [comment:5 darij]:

> Anyone else wants to weigh in whether it is important that `dual` and `duality_pairing` on a CHA WithRealizations always refer to the same pairing, or whether it is OK that the pairing depends on the realization?
> 

I haven't read Travis's paper so I'm not totally sure what the issue is: are you saying that Sage will calculate a different duality pairing depending on the basis of the inputs? So the duality pairing of the same two elements would give different answers depending on which basis I expressed the elements in? If that's true, I would be bothered. In that case, can the new pairing be given a different name, e.g. `duality_pairing_phi` or `duality_pairing_scaled`??


---

Comment by tscrim created at 2017-11-04 05:52:56

Replying to [comment:9 amypang]:
> Replying to [comment:5 darij]:
> 
> > Anyone else wants to weigh in whether it is important that `dual` and `duality_pairing` on a CHA WithRealizations always refer to the same pairing, or whether it is OK that the pairing depends on the realization?
> > 
> 
> I haven't read Travis's paper

It is not my paper.

> so I'm not totally sure what the issue is: are you saying that Sage will calculate a different duality pairing depending on the basis of the inputs? So the duality pairing of the same two elements would give different answers depending on which basis I expressed the elements in? If that's true, I would be bothered. In that case, can the new pairing be given a different name, e.g. `duality_pairing_phi` or `duality_pairing_scaled`??

No, it will not do that. The `duality_pairing` converts the target object to an instance of its dual basis and then does the comparison. It is precisely the same algorithm as for the other bases, except now it just has a scalar when doing the computation. Do it will calculate the same value irregardless of the basis (unless there is a bug). Think of it in terms of bilinear forms, you did a change of basis and got a rescaled bilinear form.


---

Comment by amypang created at 2017-11-04 06:04:22

Replying to [comment:10 tscrim]:
> Replying to [comment:9 amypang]:
> > Replying to [comment:5 darij]:
> > 
> > > Anyone else wants to weigh in whether it is important that `dual` and `duality_pairing` on a CHA WithRealizations always refer to the same pairing, or whether it is OK that the pairing depends on the realization?
> > > 
> > 
> > I haven't read Travis's paper
> 
> It is not my paper.

Thanks for the correction.
> 
> > so I'm not totally sure what the issue is: are you saying that Sage will calculate a different duality pairing depending on the basis of the inputs? So the duality pairing of the same two elements would give different answers depending on which basis I expressed the elements in? If that's true, I would be bothered. In that case, can the new pairing be given a different name, e.g. `duality_pairing_phi` or `duality_pairing_scaled`??
> 
> No, it will not do that. The `duality_pairing` converts the target object to an instance of its dual basis and then does the comparison. It is precisely the same algorithm as for the other bases, except now it just has a scalar when doing the computation. Do it will calculate the same value irregardless of the basis (unless there is a bug). Think of it in terms of bilinear forms, you did a change of basis and got a rescaled bilinear form.

Does this mean the Psi basis of QSym is not dual to the Psi basis of NSym using the usual duality pairing, but using a rescaled version of that??

I don't think I understand how the math of this rescaling works, but since it still gives basis-independent answers I think it's ok.


---

Comment by tscrim created at 2017-11-04 06:08:57

Replying to [comment:11 amypang]:
> Replying to [comment:12 tscrim]:
> > No, it will not do that. The `duality_pairing` converts the target object to an instance of its dual basis and then does the comparison. It is precisely the same algorithm as for the other bases, except now it just has a scalar when doing the computation. Do it will calculate the same value irregardless of the basis (unless there is a bug). Think of it in terms of bilinear forms, you did a change of basis and got a rescaled bilinear form.
> 
> Does this mean the Psi basis of QSym is not dual to the Psi basis of NSym using the usual duality pairing, but using a rescaled version of that??

Yes, that is correct. They are orthogonal instead of orthonormal wrt the standard duality pairing in analogy with the usual powersum symmetric functions and the Hall inner product.


---

Comment by zabrocki created at 2017-11-04 12:50:54

As long as `b(F).duality_pairing(G)` for all bases `b` and all `F` in Qsym and `G` in NCSF (and `G` in QSym and `F` in NCSF) then I am ok with implementing it. Q: is this faster to implement duality pairing this way?  Before the computation was by coercion.  It is only reason that you might want to implement a version on a particular basis if that method will improve speed.

I object to using the short name for the basis `Phi` and `Psi`.  If you are doing computations in QSym/NCSF you are likely to be using both and the naming convention should be different.  Suggested alternatives: `Phid` and `Psid`, `phi` and `psi`, `Ph` and `Ps`.

You should add these bases to the list of shorthands.


---

Comment by zabrocki created at 2017-11-04 12:58:19

Eeks.  What am I saying?  The dual basis to `NCSF.Phi()` is not `QSym.Phi()`, it is `QSym.Phi()` normalized.  I think that you should not implement `dual_basis` for either of these bases unless you are going to implement the scaled version of the dual basis.

In analogy with symmetric functions we have:

```
sage: SymmetricFunctions(QQ).inject_shorthands(verbose=False)
sage: P = p.dual_basis()
sage: P(s[2,1])
2*d_p[1, 1, 1] - d_p[3]
```



---

Comment by zabrocki created at 2017-11-04 14:20:56

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-11-06 05:34:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-11-06 05:37:34

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2017-11-06 05:37:34

I opted to just remove the `dual` (and `duality_pairing`). I also chose `phi` and `psi` for the names of the bases in QSym, although this does break the convention of bases being indexed by uppercase letters. I don't quite want to change it to `Phid` and Psid` so to reserve those for when the actual duals get implemented.


---

Comment by git created at 2017-11-06 13:08:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-11-08 13:52:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2017-11-08 14:00:55

Does anyone object that there is a psi-involution and a psi basis (Darij? since you chose the name for psi-involution)?

```
sage: psi([3,2]).psi_involution()
-psi[3, 2] - 1/5*psi[5]
```



---

Comment by darij created at 2017-11-13 07:32:39

I'm fine with these names.


---

Comment by git created at 2017-11-14 11:50:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by zabrocki created at 2017-11-14 11:51:50

LGTM


---

Comment by zabrocki created at 2017-11-14 11:51:50

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2017-12-11 01:03:14

Resolution: fixed
