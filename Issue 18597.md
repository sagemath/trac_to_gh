# Issue 18597: Use Sage to compute clustering coefficient

Issue created by migration from Trac.

Original creator: ncohen

Original creation time: 2015-07-01 12:48:41

CC:  borassi dcoudert

Will have to be rebased+adapted over #18811.


---

Comment by git created at 2015-07-01 12:49:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-07-01 18:26:20

Changing status from new to needs_review.


---

Comment by git created at 2015-07-01 18:26:31

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2015-07-02 08:15:45

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by ncohen created at 2015-07-02 08:16:09

rebased on top of #18811.


---

Comment by dcoudert created at 2015-07-03 16:41:15

For me the patch is good to go (and the boost method is pretty fast in fact).
However, the patch could be rebased on beta7 to solve the patchbot issue.


---

Comment by git created at 2015-07-03 17:07:14

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by ncohen created at 2015-07-03 17:08:03

Done! But what do you mean by 'boost is pretty fast'?? Sage is 100x faster `O_o`


---

Comment by dcoudert created at 2015-07-03 17:24:17

On a clique that's for sure, but on other kinds of graphs...

```
sage: g = graphs.RandomBarabasiAlbert(1000,2)
sage: %timeit _=g.clustering_coeff(implementation="boost")
1000 loops, best of 3: 1.9 ms per loop
sage: %timeit _=g.clustering_coeff(implementation="dense_copy")
100 loops, best of 3: 7.34 ms per loop
sage: %timeit _=g.clustering_coeff(implementation="sparse_copy")
100 loops, best of 3: 13.9 ms per loop
sage: %timeit _=g.clustering_coeff(implementation="networkx")
100 loops, best of 3: 19.3 ms per loop

sage: g = graphs.RandomBarabasiAlbert(10000,2)
sage: %timeit _=g.clustering_coeff(implementation="boost")
10 loops, best of 3: 38 ms per loop
sage: %timeit _=g.clustering_coeff(implementation="dense_copy")
10 loops, best of 3: 143 ms per loop
sage: %timeit _=g.clustering_coeff(implementation="sparse_copy")
10 loops, best of 3: 148 ms per loop
sage: %timeit _=g.clustering_coeff(implementation="networkx")
1 loops, best of 3: 248 ms per loop
```



---

Comment by dcoudert created at 2015-07-03 17:26:51

Also, I have an issue:

```
sage: g = graphs.RandomGNP(1000,.1)
sage: N = 1000
sage: g = graphs.RandomGNP(N, log(N)/N)
sage: g.order(), g.size()
(1000, 3567)
sage: %timeit _=g.clustering_coeff(implementation="boost")
100 loops, best of 3: 2.78 ms per loop
sage: %timeit _=g.clustering_coeff(implementation="dense_copy")
---------------------------------------------------------------------------
ZeroDivisionError                         Traceback (most recent call last)
<ipython-input-31-cd519bf674aa> in <module>()
----> 1 get_ipython().magic(u'timeit _=g.clustering_coeff(implementation="dense_copy")')

/Users/dcoudert/sage/local/lib/python2.7/site-packages/IPython/core/interactiveshell.pyc in magic(self, arg_s)
   2305         magic_name, _, magic_arg_s = arg_s.partition(' ')
   2306         magic_name = magic_name.lstrip(prefilter.ESC_MAGIC)
-> 2307         return self.run_line_magic(magic_name, magic_arg_s)
   2308 
   2309     #-------------------------------------------------------------------------

/Users/dcoudert/sage/local/lib/python2.7/site-packages/IPython/core/interactiveshell.pyc in run_line_magic(self, magic_name, line)
   2226                 kwargs['local_ns'] = sys._getframe(stack_depth).f_locals
   2227             with self.builtin_trap:
-> 2228                 result = fn(*args,**kwargs)
   2229             return result
   2230 

/Users/dcoudert/sage/local/lib/python2.7/site-packages/IPython/core/magics/execution.pyc in timeit(self, line, cell)

/Users/dcoudert/sage/local/lib/python2.7/site-packages/IPython/core/magic.pyc in <lambda>(f, *a, **k)
    191     # but it's overkill for just that one bit of state.
    192     def magic_deco(arg):
--> 193         call = lambda f, *a, **k: f(*a, **k)
    194 
    195         if callable(arg):

/Users/dcoudert/sage/local/lib/python2.7/site-packages/IPython/core/magics/execution.pyc in timeit(self, line, cell)
   1034             number = 1
   1035             for _ in range(1, 10):
-> 1036                 time_number = timer.timeit(number)
   1037                 worst_tuning = max(worst_tuning, time_number / number)
   1038                 if time_number >= 0.2:

/Users/dcoudert/sage/local/lib/python2.7/site-packages/IPython/core/magics/execution.pyc in timeit(self, number)
    130         gc.disable()
    131         try:
--> 132             timing = self.inner(it, self.timer)
    133         finally:
    134             if gcold:

<magic-timeit> in inner(_it, _timer)

/Users/dcoudert/sage/local/lib/python2.7/site-packages/sage/graphs/generic_graph.pyc in clustering_coeff(self, nodes, weight, implementation, return_vertex_weights)
  12437             from sage.rings.integer import Integer
  12438             return {v:Integer(count)/((self.degree(v)*(self.degree(v)-1))/2)
> 12439                     for v,count in triangles_count(self).iteritems()}
  12440 
  12441     def cluster_transitivity(self):

/Users/dcoudert/sage/local/lib/python2.7/site-packages/sage/graphs/generic_graph.pyc in <dictcomp>((v, count))
  12437             from sage.rings.integer import Integer
  12438             return {v:Integer(count)/((self.degree(v)*(self.degree(v)-1))/2)
> 12439                     for v,count in triangles_count(self).iteritems()}
  12440 
  12441     def cluster_transitivity(self):

/Users/dcoudert/sage/src/sage/structure/element.pyx in sage.structure.element.RingElement.__div__ (/Users/dcoudert/sage/src/build/cythonized/sage/structure/element.c:17310)()
   1991         if have_same_parent_c(self, right):
   1992             return (<RingElement>self)._div_(<RingElement>right)
-> 1993         return coercion_model.bin_op(self, right, div)
   1994 
   1995     cpdef RingElement _div_(self, RingElement right):

/Users/dcoudert/sage/src/sage/structure/coerce.pyx in sage.structure.coerce.CoercionModel_cache_maps.bin_op (/Users/dcoudert/sage/src/build/cythonized/sage/structure/coerce.c:8195)()
    994         try:
    995             xy = self.canonical_coercion(x,y)
--> 996             return PyObject_CallObject(op, xy)
    997         except TypeError as err:
    998             if xy is not None:

/Users/dcoudert/sage/src/sage/structure/element.pyx in sage.structure.element.RingElement.__div__ (/Users/dcoudert/sage/src/build/cythonized/sage/structure/element.c:17293)()
   1990         """
   1991         if have_same_parent_c(self, right):
-> 1992             return (<RingElement>self)._div_(<RingElement>right)
   1993         return coercion_model.bin_op(self, right, div)
   1994 

/Users/dcoudert/sage/src/sage/rings/integer.pyx in sage.rings.integer.Integer._div_ (/Users/dcoudert/sage/src/build/cythonized/sage/rings/integer.c:11621)()
   1728         # This is vastly faster than doing it here, since here
   1729         # we can't cimport rationals.
-> 1730         return the_integer_ring._div(self, right)
   1731 
   1732     def __floordiv__(x, y):

/Users/dcoudert/sage/src/sage/rings/integer_ring.pyx in sage.rings.integer_ring.IntegerRing_class._div (/Users/dcoudert/sage/src/build/cythonized/sage/rings/integer_ring.c:4894)()
    420         cdef rational.Rational x = rational.Rational.__new__(rational.Rational)
    421         if mpz_sgn(right.value) == 0:
--> 422             raise ZeroDivisionError('Rational division by zero')
    423         mpz_set(mpq_numref(x.value), left.value)
    424         mpz_set(mpq_denref(x.value), right.value)

ZeroDivisionError: Rational division by zero
```

I'll send you the graph by mail if you want to investigate.


---

Comment by ncohen created at 2015-07-03 17:29:44

> On a clique that's for sure, but on other kinds of graphs...

Oh.. Wow..

HMmmm.. It seems that those graphs are stuffed with degree-2 vertices. I wonder how they do that `O_o`

Nathann


---

Comment by dcoudert created at 2015-07-03 17:31:00

I assume they iterate over the edges, which is what I would do on a sparse graph.


---

Comment by ncohen created at 2015-07-03 23:15:44

They probably do a dichotomic search where I do a linear search. I'll try to see tomorrow evening (I will sleep in an airport) if I can do something about that.


---

Comment by git created at 2015-07-04 20:48:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2015-07-05 13:12:46

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by ncohen created at 2015-07-05 13:15:21

A more correct fix.

About the difference in timings:


```
sage: g=graphs.RandomBarabasiAlbert(10000,2)
sage: %timeit _ = g.clustering_coeff()
10 loops, best of 3: 96.8 ms per loop
sage: from sage.graphs.base.static_sparse_graph import triangles_count
sage: %timeit _ = triangles_count(g)
10 loops, best of 3: 70 ms per loop
```


It seems that a nontrivial part of the difference in timing is taken by the construction of the.... final dictionary. Profiling the method does not show a major cost of the actual algorithm.. So well, it seems that this graph is so easy to deal with that returning the result is not negligible `:-P`

Nathann


---

Comment by dcoudert created at 2015-07-06 20:08:29

For me the patch is now good to go!


---

Comment by dcoudert created at 2015-07-06 20:08:29

Changing status from needs_review to positive_review.


---

Comment by ncohen created at 2015-07-07 06:57:09

Thanks !

Nathann


---

Comment by vbraun created at 2015-07-07 10:28:54

Resolution: fixed
