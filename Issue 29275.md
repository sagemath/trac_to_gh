# Issue 29275: Ideals for Laurent polynomial rings

archive/issues_029275.json:
```json
{
    "body": "CC:  @yuan-zhou @mwageringel\n\nKeywords: Laurent polynomial ring\n\nCurrently Laurent polynomial rings do not implement ideals. This would be relatively easy to do by converting back and forth between the corresponding ordinary polynomial ring, taking care to saturate the ideal in the polynomial ring with respect to the product of the generators.\n\nThis is just one of many instances of missing parallelism between ordinary and Laurent polynomials; but the others should go on other tickets.\n\nIssue created by migration from https://trac.sagemath.org/ticket/29512\n\n",
    "created_at": "2020-04-15T17:58:59Z",
    "labels": [
        "component: commutative algebra"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.2",
    "title": "Ideals for Laurent polynomial rings",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/29275",
    "user": "https://github.com/kedlaya"
}
```
CC:  @yuan-zhou @mwageringel

Keywords: Laurent polynomial ring

Currently Laurent polynomial rings do not implement ideals. This would be relatively easy to do by converting back and forth between the corresponding ordinary polynomial ring, taking care to saturate the ideal in the polynomial ring with respect to the product of the generators.

This is just one of many instances of missing parallelism between ordinary and Laurent polynomials; but the others should go on other tickets.

Issue created by migration from https://trac.sagemath.org/ticket/29512





---

archive/issue_comments_414537.json:
```json
{
    "body": "I ended up writing some code to do this, but at the moment it is not yet available as a patch. If someone is interested in reviewing this, let me know and I will bump this up in my queue.\n\nOne thing I learned by doing: the saturation of ideals can be quite expensive computationally, so for performance code it is useful to keep track of partial saturations and use those instead when feasible.",
    "created_at": "2020-05-05T16:40:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414537",
    "user": "https://github.com/kedlaya"
}
```

I ended up writing some code to do this, but at the moment it is not yet available as a patch. If someone is interested in reviewing this, let me know and I will bump this up in my queue.

One thing I learned by doing: the saturation of ideals can be quite expensive computationally, so for performance code it is useful to keep track of partial saturations and use those instead when feasible.



---

archive/issue_comments_414538.json:
```json
{
    "body": "I have attached a standalone Sage file with a class that I am using in some of my own code.",
    "created_at": "2020-05-15T21:44:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414538",
    "user": "https://github.com/kedlaya"
}
```

I have attached a standalone Sage file with a class that I am using in some of my own code.



---

archive/issue_comments_414539.json:
```json
{
    "body": "Changing keywords from \"Laurent polynomial ring\" to \"Laurent polynomial ring, ideals\".",
    "created_at": "2020-05-15T21:44:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414539",
    "user": "https://github.com/kedlaya"
}
```

Changing keywords from "Laurent polynomial ring" to "Laurent polynomial ring, ideals".



---

archive/issue_comments_414540.json:
```json
{
    "body": "I just noticed that the newest release of Singular (4-1-3) includes a new library `moddiq.lib` for ideal saturation using modular techniques. This might have a big practical impact here!",
    "created_at": "2020-05-25T20:59:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414540",
    "user": "https://github.com/kedlaya"
}
```

I just noticed that the newest release of Singular (4-1-3) includes a new library `moddiq.lib` for ideal saturation using modular techniques. This might have a big practical impact here!



---

archive/issue_comments_414541.json:
```json
{
    "body": "Attachment [lp_ideal.sage](tarball://root/attachments/some-uuid/ticket29512/lp_ideal.sage) by @kedlaya created at 2020-05-28 19:17:56\n\nPatch to implement ideals in Laurent polynomial rings",
    "created_at": "2020-05-28T19:17:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414541",
    "user": "https://github.com/kedlaya"
}
```

Attachment [lp_ideal.sage](tarball://root/attachments/some-uuid/ticket29512/lp_ideal.sage) by @kedlaya created at 2020-05-28 19:17:56

Patch to implement ideals in Laurent polynomial rings



---

archive/issue_comments_414542.json:
```json
{
    "body": "I made a few minor changes to the patch, so I have posted an update.",
    "created_at": "2020-05-28T19:18:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414542",
    "user": "https://github.com/kedlaya"
}
```

I made a few minor changes to the patch, so I have posted an update.



---

archive/issue_comments_414543.json:
```json
{
    "body": "This bubbled up to the top of my queue, so here goes with a proper commit. Note the side effect related to #26421.\n\nThis should be mostly ready for review, but let's give patchbot a chance to weigh in first.\n----\nNew commits:",
    "created_at": "2020-07-22T19:04:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414543",
    "user": "https://github.com/kedlaya"
}
```

This bubbled up to the top of my queue, so here goes with a proper commit. Note the side effect related to #26421.

This should be mostly ready for review, but let's give patchbot a chance to weigh in first.
----
New commits:



---

archive/issue_comments_414544.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-22T20:17:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414544",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_414545.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2020-07-23T19:00:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414545",
    "user": "https://github.com/kedlaya"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_414546.json:
```json
{
    "body": "It is nice to have this feature. I have some comments:\n\nFor efficiency, do you want to be passing `dict` objects to the parent and getting `self.dict()` in `rescale_vars()` and `toric_coordinate_change()` (possibly also `toric_substitute()`)? Wouldn't it be faster to copy the `PolyDict`, manipulate the copy, and then create a new instance using the `_new_c()`?\n\nYou could simplify the comparisons by using `_richcmp_`, which also will use coercion, or perhaps `__richcmp__` if you want to avoid the coercion?\n\nFollowing the Python convention:\n\n```diff\n-return ValueError(\"Ambient rings are not equal\")\n+return ValueError(\"ambient rings are not equal\")\n```\n",
    "created_at": "2020-07-24T08:15:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414546",
    "user": "https://github.com/tscrim"
}
```

It is nice to have this feature. I have some comments:

For efficiency, do you want to be passing `dict` objects to the parent and getting `self.dict()` in `rescale_vars()` and `toric_coordinate_change()` (possibly also `toric_substitute()`)? Wouldn't it be faster to copy the `PolyDict`, manipulate the copy, and then create a new instance using the `_new_c()`?

You could simplify the comparisons by using `_richcmp_`, which also will use coercion, or perhaps `__richcmp__` if you want to avoid the coercion?

Following the Python convention:

```diff
-return ValueError("Ambient rings are not equal")
+return ValueError("ambient rings are not equal")
```




---

archive/issue_comments_414547.json:
```json
{
    "body": "Thanks for the feedback!\n\nIt looks like `self.dict()` already returns a copy, so in `rescale_vars` I could definitely just edit the return value. For the others, I'm changing both the keys and the values; I don't have enough Python intuition to discern whether I'm paying much of a penalty by creating a new dict. (Is there a good example to point to in the existing code to illustrate your suggestion?)\n\nRe `_richcmp_` vs `__richcmp__`, I'm pretty sure I want to use the former so that I don't have to worry about the coercion myself. But would that lead to any appreciable loss of efficiency?",
    "created_at": "2020-07-24T16:03:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414547",
    "user": "https://github.com/kedlaya"
}
```

Thanks for the feedback!

It looks like `self.dict()` already returns a copy, so in `rescale_vars` I could definitely just edit the return value. For the others, I'm changing both the keys and the values; I don't have enough Python intuition to discern whether I'm paying much of a penalty by creating a new dict. (Is there a good example to point to in the existing code to illustrate your suggestion?)

Re `_richcmp_` vs `__richcmp__`, I'm pretty sure I want to use the former so that I don't have to worry about the coercion myself. But would that lead to any appreciable loss of efficiency?



---

archive/issue_comments_414548.json:
```json
{
    "body": "Replying to [comment:13 kedlaya]:\n> It looks like `self.dict()` already returns a copy, so in `rescale_vars` I could definitely just edit the return value. For the others, I'm changing both the keys and the values; I don't have enough Python intuition to discern whether I'm paying much of a penalty by creating a new dict. (Is there a good example to point to in the existing code to illustrate your suggestion?)\n\nWhen the data gets passed to the parent, it ends up recreating the data structure. So here is what happens when you create a (multivar.) Laurent polynomial `p` passing a `dict` `D`:\n\n1. The monomial `self._mon` for the common negative exponents is determined.\n2. The cleaned dict `D` is passed to the defining polynomial ring to set `self._poly`.\n\nThen when you call `p.dict()`:\n\n1. A `PolyDict` object `self._prod` created in `_compute_polydict` by multiplying the monomial `self._mon` with the `dict` version of `self._poly`. This is stored in `self._prod`.\n2. The dictionary of `self._prod` is created.\n\nAs a specific example, lets take `rescale_vars`. Since the underlying `self._prod` only changes in the coefficients, you can simply change the appropriate coefficients in the `PolyDict` object and set the `result._prod` value (this will make it avoid the call to `_compute_polydict`).\n\nThe polynomial part is a little more tricky as you don't want to create an intermediate polynomial object. The best way would be to break the encapsulation of the polynomial and just modify the monomials on a copy, but we don't really allow that. So probably the best (and easiest) thing to do is just pass a separate (rescaled by `self._mon`) `PolyDict` object, and let the ring sort out the construction.\n\nFor the other methods, similar things can be done. I can also do these changes next time I am in my office.\n\nAnother thing I noticed. While this will have some code duplication, I would consider factoring out the `if h is None:` check to minimize the number of checks. This seems like something that might get used a lot in tight loops.\n\nOne simple thing you can do, since this is done in Cython, is to `cdef dict d, d2` and `cdef ETuple v, v1, w`. Also this is faster:\n\n```diff\n-if self == 0:\n+if not self:\n```\n\n\nPerhaps I am also giving oversized importance to these methods. Side note, a similar change probably should be done for `_derivative` (definitely a separate ticket).\n\n> Re `_richcmp_` vs `__richcmp__`, I'm pretty sure I want to use the former so that I don't have to worry about the coercion myself. But would that lead to any appreciable loss of efficiency?\n\nProbably not since checking equality and containment will dominate rather than potentially creating a new object. Actually, your current equals is assuming that you are being given an ideal. I suspect if you trying doing `I == 0`, you will get an error. With the coercion, this will either check if `I` is the trivial ideal `0` (which I think the parent of ideals will properly coerce in) or return `False` (if it cannot coerce in IIRC).",
    "created_at": "2020-07-24T23:24:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414548",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:13 kedlaya]:
> It looks like `self.dict()` already returns a copy, so in `rescale_vars` I could definitely just edit the return value. For the others, I'm changing both the keys and the values; I don't have enough Python intuition to discern whether I'm paying much of a penalty by creating a new dict. (Is there a good example to point to in the existing code to illustrate your suggestion?)

When the data gets passed to the parent, it ends up recreating the data structure. So here is what happens when you create a (multivar.) Laurent polynomial `p` passing a `dict` `D`:

1. The monomial `self._mon` for the common negative exponents is determined.
2. The cleaned dict `D` is passed to the defining polynomial ring to set `self._poly`.

Then when you call `p.dict()`:

1. A `PolyDict` object `self._prod` created in `_compute_polydict` by multiplying the monomial `self._mon` with the `dict` version of `self._poly`. This is stored in `self._prod`.
2. The dictionary of `self._prod` is created.

As a specific example, lets take `rescale_vars`. Since the underlying `self._prod` only changes in the coefficients, you can simply change the appropriate coefficients in the `PolyDict` object and set the `result._prod` value (this will make it avoid the call to `_compute_polydict`).

The polynomial part is a little more tricky as you don't want to create an intermediate polynomial object. The best way would be to break the encapsulation of the polynomial and just modify the monomials on a copy, but we don't really allow that. So probably the best (and easiest) thing to do is just pass a separate (rescaled by `self._mon`) `PolyDict` object, and let the ring sort out the construction.

For the other methods, similar things can be done. I can also do these changes next time I am in my office.

Another thing I noticed. While this will have some code duplication, I would consider factoring out the `if h is None:` check to minimize the number of checks. This seems like something that might get used a lot in tight loops.

One simple thing you can do, since this is done in Cython, is to `cdef dict d, d2` and `cdef ETuple v, v1, w`. Also this is faster:

```diff
-if self == 0:
+if not self:
```


Perhaps I am also giving oversized importance to these methods. Side note, a similar change probably should be done for `_derivative` (definitely a separate ticket).

> Re `_richcmp_` vs `__richcmp__`, I'm pretty sure I want to use the former so that I don't have to worry about the coercion myself. But would that lead to any appreciable loss of efficiency?

Probably not since checking equality and containment will dominate rather than potentially creating a new object. Actually, your current equals is assuming that you are being given an ideal. I suspect if you trying doing `I == 0`, you will get an error. With the coercion, this will either check if `I` is the trivial ideal `0` (which I think the parent of ideals will properly coerce in) or return `False` (if it cannot coerce in IIRC).



---

archive/issue_comments_414549.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-25T04:30:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414549",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_414550.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-25T04:38:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414550",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_414551.json:
```json
{
    "body": "I made some changes as suggested. On the ideal side, I rewrote the comparisons using `_richcmp_`. On the polynomial side, I made a few of the easy changes (using `cdef` on some of the `dict` and `ETuple` objects) but I still haven't absorbed how to deal with `PolyDict` objects directly.\n\nSince I do want to get this right from an efficiency standpoint (my intended use case hits this code pretty hard), I would definitely appreciate a friendly amendment to avoid excessive dictionary creation.",
    "created_at": "2020-07-25T04:38:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414551",
    "user": "https://github.com/kedlaya"
}
```

I made some changes as suggested. On the ideal side, I rewrote the comparisons using `_richcmp_`. On the polynomial side, I made a few of the easy changes (using `cdef` on some of the `dict` and `ETuple` objects) but I still haven't absorbed how to deal with `PolyDict` objects directly.

Since I do want to get this right from an efficiency standpoint (my intended use case hits this code pretty hard), I would definitely appreciate a friendly amendment to avoid excessive dictionary creation.



---

archive/issue_comments_414552.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-26T03:16:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414552",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_414553.json:
```json
{
    "body": "Timing for `rescale_vars`:\n\n```\nsage: L.<x,y> = LaurentPolynomialRing(QQ, 2)\nsage: p = x^-2*y + x*y^-2\nsage: %timeit p.rescale_vars({0: 2, 1: 3})\n100000 loops, best of 5: 11.5 \u00b5s per loop\n```\n\nversus before\n\n```\n100000 loops, best of 5: 5.13 \u00b5s per loop\n```\n\nHowever, your code had two bugs: 1) the coefficients could go outside of the base ring; 2) you did not set the `ans._poly`; so this breaks:\n\n```\nsage: L.<x,y> = LaurentPolynomialRing(QQ, 2)\nsage: M.<u,v> = LaurentPolynomialRing(QQ)\nsage: phi = L.hom([u,v])\nsage: p = x^-2*y + x*y^-2\nsage: pp = p.rescale_vars({0: 3, 1: 3})\nsage: phi(pp)\n```\n\nIn particular, the second issue is why there is a slowdown. If I compare with 6d028fe, I get\n\n```\n100000 loops, best of 5: 14.9 \u00b5s per loop\n```\n\n\n----\n\nTiming for `toric_coordinate_change`:\n\n```\nsage: L.<x,y> = LaurentPolynomialRing(QQ, 2)\nsage: p = 2*x^2 + y - x*y\nsage: M = Matrix([[1,-3],[1,1]])\nsage: %timeit p.toric_coordinate_change(M)\n100000 loops, best of 5: 18.2 \u00b5s per loop\n```\n\nversus before:\n\n```\n10000 loops, best of 5: 33 \u00b5s per loop\n```\n\nHere I made an assumption that the matrix is a dense matrix and the results will generally have the full support.\n\n----\n\nFor `toric_substitute`:\n\n```\nsage: L.<x,y> = LaurentPolynomialRing(QQ, 2)\nsage: p = x + y\nsage: %timeit p.toric_substitute((2,3), (-1,1), 2)\n100000 loops, best of 5: 10.1 \u00b5s per loop\n```\n\nversus before\n\n```\n100000 loops, best of 5: 14.7 \u00b5s per loop\n```\n\n\nI thought about adding an extra `scalar` parameter to `ETuple.eadd`, but then the worry that the extra `if` check could lead to more substantial slowdowns got the better of me. I don't like the near-duplicated code, but nearly all of the method was copied within the `if` statement.\n\n----\n\nSome other misc comments:\n\nI find this a little strange and do this instead:\n\n```diff\n-lambda x, M=M: x.toric_coordinate_change(M)\n+lambda x: x.toric_coordinate_change(M)\n```\n\nand other similar changes.\n\nI made the methods above more robust if the `h` map moves you outside of your base ring (now it will raise an error).\n\n\n```diff\n-        - ``ring`` - the ring the ideal is defined in\n-\n-        - ``gens`` - a list of generators for the ideal\n-\n-        - ``coerce`` - coerce elements to the ring ``ring``?\n+        - ``ring`` -- the ring the ideal is defined in\n+        - ``gens`` -- a list of generators for the ideal\n+        - ``coerce`` -- whether or not to coerce elements into ``ring``\n```\n\n\nBikeshedding: I don't trust `\\dots`, so I would replace them with the corresponding explicit type (in this case, `\\ldots`).\n\n\n```diff\n-ideals in the ordinary polynomial ring `R[x_1, \\ldots, x_n]` which are\n+ideals in the ordinary polynomial ring `R[x_1, \\ldots, x_n]`, which are\n```\n\n----\nNew commits:",
    "created_at": "2020-07-27T05:46:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414553",
    "user": "https://github.com/tscrim"
}
```

Timing for `rescale_vars`:

```
sage: L.<x,y> = LaurentPolynomialRing(QQ, 2)
sage: p = x^-2*y + x*y^-2
sage: %timeit p.rescale_vars({0: 2, 1: 3})
100000 loops, best of 5: 11.5 µs per loop
```

versus before

```
100000 loops, best of 5: 5.13 µs per loop
```

However, your code had two bugs: 1) the coefficients could go outside of the base ring; 2) you did not set the `ans._poly`; so this breaks:

```
sage: L.<x,y> = LaurentPolynomialRing(QQ, 2)
sage: M.<u,v> = LaurentPolynomialRing(QQ)
sage: phi = L.hom([u,v])
sage: p = x^-2*y + x*y^-2
sage: pp = p.rescale_vars({0: 3, 1: 3})
sage: phi(pp)
```

In particular, the second issue is why there is a slowdown. If I compare with 6d028fe, I get

```
100000 loops, best of 5: 14.9 µs per loop
```


----

Timing for `toric_coordinate_change`:

```
sage: L.<x,y> = LaurentPolynomialRing(QQ, 2)
sage: p = 2*x^2 + y - x*y
sage: M = Matrix([[1,-3],[1,1]])
sage: %timeit p.toric_coordinate_change(M)
100000 loops, best of 5: 18.2 µs per loop
```

versus before:

```
10000 loops, best of 5: 33 µs per loop
```

Here I made an assumption that the matrix is a dense matrix and the results will generally have the full support.

----

For `toric_substitute`:

```
sage: L.<x,y> = LaurentPolynomialRing(QQ, 2)
sage: p = x + y
sage: %timeit p.toric_substitute((2,3), (-1,1), 2)
100000 loops, best of 5: 10.1 µs per loop
```

versus before

```
100000 loops, best of 5: 14.7 µs per loop
```


I thought about adding an extra `scalar` parameter to `ETuple.eadd`, but then the worry that the extra `if` check could lead to more substantial slowdowns got the better of me. I don't like the near-duplicated code, but nearly all of the method was copied within the `if` statement.

----

Some other misc comments:

I find this a little strange and do this instead:

```diff
-lambda x, M=M: x.toric_coordinate_change(M)
+lambda x: x.toric_coordinate_change(M)
```

and other similar changes.

I made the methods above more robust if the `h` map moves you outside of your base ring (now it will raise an error).


```diff
-        - ``ring`` - the ring the ideal is defined in
-
-        - ``gens`` - a list of generators for the ideal
-
-        - ``coerce`` - coerce elements to the ring ``ring``?
+        - ``ring`` -- the ring the ideal is defined in
+        - ``gens`` -- a list of generators for the ideal
+        - ``coerce`` -- whether or not to coerce elements into ``ring``
```


Bikeshedding: I don't trust `\dots`, so I would replace them with the corresponding explicit type (in this case, `\ldots`).


```diff
-ideals in the ordinary polynomial ring `R[x_1, \ldots, x_n]` which are
+ideals in the ordinary polynomial ring `R[x_1, \ldots, x_n]`, which are
```

----
New commits:



---

archive/issue_comments_414554.json:
```json
{
    "body": "Thanks, this all looks reasonable. One quick comment:\n\nReplying to [comment:19 tscrim]:\n> I find this a little strange and do this instead:\n> {{{#!diff\n> -lambda x, M=M: x.toric_coordinate_change(M)\n> +lambda x: x.toric_coordinate_change(M)\n> }}}\n> and other similar changes.\n> \nI got into the habit of using this syntax after getting burned by the following Python scoping rule: non-local variables referenced in a lambda function are defined in the scope where they are created, but at the time the lambda function is *executed* rather than when it is created. A minimal example:\n\n```\nsage: l = [(lambda x: x+i) for i in range(5)]\nsage: print([i(3) for i in l])\n[7, 7, 7, 7, 7]\nsage: l = [(lambda x,i=i: x+i) for i in range(5)]\nsage: print([i(3) for i in l])\n[3, 4, 5, 6, 7]\n```\n\nThat said, I don't think this issue arises here because (as in typical Python code) the lambda functions are being created individually and used right away.",
    "created_at": "2020-07-27T16:25:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414554",
    "user": "https://github.com/kedlaya"
}
```

Thanks, this all looks reasonable. One quick comment:

Replying to [comment:19 tscrim]:
> I find this a little strange and do this instead:
> {{{#!diff
> -lambda x, M=M: x.toric_coordinate_change(M)
> +lambda x: x.toric_coordinate_change(M)
> }}}
> and other similar changes.
> 
I got into the habit of using this syntax after getting burned by the following Python scoping rule: non-local variables referenced in a lambda function are defined in the scope where they are created, but at the time the lambda function is *executed* rather than when it is created. A minimal example:

```
sage: l = [(lambda x: x+i) for i in range(5)]
sage: print([i(3) for i in l])
[7, 7, 7, 7, 7]
sage: l = [(lambda x,i=i: x+i) for i in range(5)]
sage: print([i(3) for i in l])
[3, 4, 5, 6, 7]
```

That said, I don't think this issue arises here because (as in typical Python code) the lambda functions are being created individually and used right away.



---

archive/issue_comments_414555.json:
```json
{
    "body": "That is quite interesting, slightly surprising on first glance, but it makes sense from what the interpreter knows (although I might argue that particular example should raise an error since it is out of scope as Python3 has scope for variables IIRC, but it does illustrate the issue nicely).\n\nOnce those doc changes are done (assuming you agree with them; I can also do them quickly too), then this can be positively reviewed. There is a morally green patchbot run too.",
    "created_at": "2020-07-27T22:56:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414555",
    "user": "https://github.com/tscrim"
}
```

That is quite interesting, slightly surprising on first glance, but it makes sense from what the interpreter knows (although I might argue that particular example should raise an error since it is out of scope as Python3 has scope for variables IIRC, but it does illustrate the issue nicely).

Once those doc changes are done (assuming you agree with them; I can also do them quickly too), then this can be positively reviewed. There is a morally green patchbot run too.



---

archive/issue_comments_414556.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2020-07-27T23:56:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414556",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_414557.json:
```json
{
    "body": "I believe I made the doc changes you suggested, but do check to see if I missed any. I left the lambda functions alone because I didn't have a chance to test carefully whether they still work without the default argument (I suspect yes but would want to be sure; the last bug I had to fix regarding this issue was painful to diagnose).",
    "created_at": "2020-07-27T23:58:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414557",
    "user": "https://github.com/kedlaya"
}
```

I believe I made the doc changes you suggested, but do check to see if I missed any. I left the lambda functions alone because I didn't have a chance to test carefully whether they still work without the default argument (I suspect yes but would want to be sure; the last bug I had to fix regarding this issue was painful to diagnose).



---

archive/issue_comments_414558.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2020-07-28T01:04:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414558",
    "user": "https://github.com/tscrim"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_414559.json:
```json
{
    "body": "LGTM. Thank you.",
    "created_at": "2020-07-28T01:04:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414559",
    "user": "https://github.com/tscrim"
}
```

LGTM. Thank you.



---

archive/issue_comments_414560.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2020-08-02T08:20:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29275#issuecomment-414560",
    "user": "https://github.com/vbraun"
}
```

Resolution: fixed



---

archive/issue_events_075263.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2020-08-02T08:20:54Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/29275",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/29275#event-75263"
}
```
