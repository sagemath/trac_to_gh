# Issue 24218: _integer_ for QQbar and QQ raise different errors.

Issue created by migration from Trac.

Original creator: mcbell

Original creation time: 2018-01-01 15:23:03

Keywords: TypeError, ValueError, ZZ, QQbar



```
sage: ZZ(1/2)
```

fails and (correctly) raises a TypeError while


```
sage: ZZ(QQbar(sqrt(17)))
```


fails and (incorrectly) raises a ValueError. 

This has several knock on effects, in particular vector(ZZ, [list of algebraic numbers]) all of whoms try / except blocks are set up to catch a TypeError in the event that one of the elements fails to be coerced to an integer. This in turn causes Polyhedron([(AA(sqrt(17)),)]).integral_points() to fail as this ValueError is never caught.


---

Comment by vdelecroix created at 2018-01-01 16:16:31

I believe that `ValueError` for `ZZ(1/2)` is the correct one. The main reason is that the following *conversion* should work `ZZ(QQ(3))`. Hence, it is not due to the type of the object but its value.

Note that the following *coercion* should fail with a `TypeError` `ZZ.coerce(QQ(3))`.


---

Comment by mcbell created at 2018-01-01 18:06:35

Replying to [comment:1 vdelecroix]:
> I believe that `ValueError` for `ZZ(1/2)` is the correct one. The main reason is that the following *conversion* should work `ZZ(QQ(3))`. Hence, it is not due to the type of the object but its value.
> 
> Note that the following *coercion* should fail with a `TypeError` `ZZ.coerce(QQ(3))`.

Hmm, so does that mean that the Sequence initialiser in sage/structure/sequence.pyc should catch more types of errors since conversion can also fail due to a ValueError?


```
    455             for i in range(len(x)):
    456                 try:
    457                     x[i] = universe(x[i])
    458                 except TypeError:
    459                     raise TypeError("unable to convert {} to an element of {}"
```



---

Comment by vdelecroix created at 2018-01-01 18:09:25

Replying to [comment:2 mcbell]:
> Replying to [comment:1 vdelecroix]:
> > I believe that `ValueError` for `ZZ(1/2)` is the correct one. The main reason is that the following *conversion* should work `ZZ(QQ(3))`. Hence, it is not due to the type of the object but its value.
> > 
> > Note that the following *coercion* should fail with a `TypeError` `ZZ.coerce(QQ(3))`.
> 
> Hmm, so does that mean that the Sequence initialiser in sage/structure/sequence.pyc should catch more types of errors since conversion can also fail due to a ValueError?
> 
> {{{
>     455             for i in range(len(x)):
>     456                 try:
>     457                     x[i] = universe(x[i])
>     458                 except TypeError:
>     459                     raise TypeError("unable to convert {} to an element of {}"
> }}}

Two possibilities

1. (line 458) `except TypeError` -> `except (TypeError, ValueError)`
2. (line 457) `x[i] = universe.coerce(x[i])`

I do prefer the second one since coercion is stricter and more predictible.


---

Comment by mcbell created at 2018-01-01 20:29:51

Replying to [comment:3 vdelecroix]:
> Two possibilities
> 
> 1. (line 458) `except TypeError` -> `except (TypeError, ValueError)`
> 2. (line 457) `x[i] = universe.coerce(x[i])`
> 
> I do prefer the second one since coercion is stricter and more predictible.

I'm not sure that we can use the second option since we still want something like:

```
vector(ZZ, [7, 3/1])
```

to succeed. However I think the first would work perfectly well.


---

Comment by git created at 2018-01-02 10:44:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jdemeyer created at 2018-01-02 10:59:46

This is not the right fix. `_integer_` should `raise TypeError` instead.


---

Comment by mcbell created at 2018-01-02 11:23:02

Replying to [comment:7 jdemeyer]:
> This is not the right fix. `_integer_` should `raise TypeError` instead.

So I certainly agree that Rational._integer_ (which raises a TypeError) and AlgebraicNumber._integer_ (which raises a ValueError) should raise the same error. However I'm not sure why AlgebraicNumber._integer_ should be changed to raise a TypeError. I would have thought that a ValueError (https://docs.python.org/2/library/exceptions.html#exceptions.ValueError):

> Raised when a built-in operation or function receives an argument that has the right type but an inappropriate value, and the situation is not described by a more precise exception such as IndexError.

would be the appropriate error for both, similar to how `int('foo')` raises a ValueError.
