# Issue 26846: memory leak, possibly in crystals

archive/issues_026846.json:
```json
{
    "body": "CC:  @tscrim @slel\n\nKeywords: memory leak\n\nAs noticed in #27057:\n\n```\nsage: C = crystals.Letters(['A', 1])\nsage: C._dummy = True\nsage: del C\nsage: import gc\nsage: _ = gc.collect()\nsage: C = crystals.Letters(['A', 1])\nsage: C._dummy\nTrue\nsage: C = ShiftedPrimedTableaux([2,1], max_entry=2)\nsage: C._dummy = True\nsage: del C\nsage: _ = gc.collect()\nsage: C = ShiftedPrimedTableaux([2,1], max_entry=2)\nsage: C._dummy\nTrue\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/27083\n\n",
    "created_at": "2019-01-20T11:25:16Z",
    "labels": [
        "component: combinatorics",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-duplicate/invalid/wontfix",
    "title": "memory leak, possibly in crystals",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/26846",
    "user": "https://github.com/mantepse"
}
```
CC:  @tscrim @slel

Keywords: memory leak

As noticed in #27057:

```
sage: C = crystals.Letters(['A', 1])
sage: C._dummy = True
sage: del C
sage: import gc
sage: _ = gc.collect()
sage: C = crystals.Letters(['A', 1])
sage: C._dummy
True
sage: C = ShiftedPrimedTableaux([2,1], max_entry=2)
sage: C._dummy = True
sage: del C
sage: _ = gc.collect()
sage: C = ShiftedPrimedTableaux([2,1], max_entry=2)
sage: C._dummy
True
```


Issue created by migration from https://trac.sagemath.org/ticket/27083





---

archive/issue_comments_377227.json:
```json
{
    "body": "Actually, I think this is to be expected with `UniqueRepresentation`, no?\n\n```\nsage: C = SetPartitions()\nsage: C._dummy = True\nsage: del C\nsage: C = SetPartitions()\nsage: C._dummy\nTrue\n```\n",
    "created_at": "2019-01-20T11:33:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377227",
    "user": "https://github.com/mantepse"
}
```

Actually, I think this is to be expected with `UniqueRepresentation`, no?

```
sage: C = SetPartitions()
sage: C._dummy = True
sage: del C
sage: C = SetPartitions()
sage: C._dummy
True
```




---

archive/issue_comments_377228.json:
```json
{
    "body": "How is this a memory leak? Why is this a bug?",
    "created_at": "2019-01-20T13:49:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377228",
    "user": "https://github.com/jdemeyer"
}
```

How is this a memory leak? Why is this a bug?



---

archive/issue_comments_377229.json:
```json
{
    "body": "Replying to [comment:2 jdemeyer]:\n> How is this a memory leak? Why is this a bug?\n\nIt is a little suspicious because the `UniqueRepresentation` object `C` is deleted, so one would assume `C` should now be unreachable. Then `gc.collect()` is run, which should clean unreachable objects. So you'd expect after that to get a clean copy of `C` when it is recreated. But as you can see, it is not: it still has this `_dummy` attribute.\n\nTesting creating and deleting these objects in a loop and then checking if any pile up on the heap using `gc.get_objects` doesn't give worrisome results, however. And when `WeakRefs` are involved it's actually possible to prevent `gc` from collecting everything in one swoop, so I agree there doesn't seem to be a memory leak.\n\nBut I think the report had some merit to it in that it pointed out suspicious behaviour that warrants a little further investigation (which found nothing).",
    "created_at": "2019-01-20T16:32:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377229",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:2 jdemeyer]:
> How is this a memory leak? Why is this a bug?

It is a little suspicious because the `UniqueRepresentation` object `C` is deleted, so one would assume `C` should now be unreachable. Then `gc.collect()` is run, which should clean unreachable objects. So you'd expect after that to get a clean copy of `C` when it is recreated. But as you can see, it is not: it still has this `_dummy` attribute.

Testing creating and deleting these objects in a loop and then checking if any pile up on the heap using `gc.get_objects` doesn't give worrisome results, however. And when `WeakRefs` are involved it's actually possible to prevent `gc` from collecting everything in one swoop, so I agree there doesn't seem to be a memory leak.

But I think the report had some merit to it in that it pointed out suspicious behaviour that warrants a little further investigation (which found nothing).



---

archive/issue_comments_377230.json:
```json
{
    "body": "Martin, it is *not* because of `UniqueRepresentation`. Although I am a little surprised that running `gc.collect()` a few times after deleting it is not leading to a new object being created:\n\n```\nsage: P = GF(3037000453)['x','y']\nsage: P.dummy = True\nsage: P.dummy\nTrue\nsage: del P\nsage: gc.collect() # I ran this 5 times\nsage: P = GF(3037000453)['x','y']\nsage: P.dummy\n...\nAttributeError\n```\n\nAlthough in this example, it is not a `UniqueRepresentation` object, but I think it illustrates what should happen.\n\nI am also wondering if this is related to #18426.",
    "created_at": "2019-01-20T16:34:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377230",
    "user": "https://github.com/tscrim"
}
```

Martin, it is *not* because of `UniqueRepresentation`. Although I am a little surprised that running `gc.collect()` a few times after deleting it is not leading to a new object being created:

```
sage: P = GF(3037000453)['x','y']
sage: P.dummy = True
sage: P.dummy
True
sage: del P
sage: gc.collect() # I ran this 5 times
sage: P = GF(3037000453)['x','y']
sage: P.dummy
...
AttributeError
```

Although in this example, it is not a `UniqueRepresentation` object, but I think it illustrates what should happen.

I am also wondering if this is related to #18426.



---

archive/issue_comments_377231.json:
```json
{
    "body": "I do not seem to be able to actually free the memory in the loop mentioned.\n\nNils, can you remind me the code of how to check with `gc.get_objects()`? I can never seem to remember it.",
    "created_at": "2019-01-20T16:36:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377231",
    "user": "https://github.com/tscrim"
}
```

I do not seem to be able to actually free the memory in the loop mentioned.

Nils, can you remind me the code of how to check with `gc.get_objects()`? I can never seem to remember it.



---

archive/issue_comments_377232.json:
```json
{
    "body": "I flopped the direction of the loop to illustrate the problem more. Maybe the `get_memory_usage` is not the right test...",
    "created_at": "2019-01-20T16:40:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377232",
    "user": "https://github.com/tscrim"
}
```

I flopped the direction of the loop to illustrate the problem more. Maybe the `get_memory_usage` is not the right test...



---

archive/issue_comments_377233.json:
```json
{
    "body": "Replying to [comment:4 tscrim]:\n> Martin, it is *not* because of `UniqueRepresentation`.\n\nI only thought so because you can reproduce it also with other `UniqueRepresentation` instances.  For example:\n\n```\nsage: C = SetPartitions()\nsage: C.dummy = True\nsage: del C\nsage: gc.collect()\nsage: C = SetPartitions()\nsage: C.dummy\nTrue\n```\n",
    "created_at": "2019-01-20T16:46:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377233",
    "user": "https://github.com/mantepse"
}
```

Replying to [comment:4 tscrim]:
> Martin, it is *not* because of `UniqueRepresentation`.

I only thought so because you can reproduce it also with other `UniqueRepresentation` instances.  For example:

```
sage: C = SetPartitions()
sage: C.dummy = True
sage: del C
sage: gc.collect()
sage: C = SetPartitions()
sage: C.dummy
True
```




---

archive/issue_comments_377234.json:
```json
{
    "body": "Replying to [comment:5 tscrim]:\n> I do not seem to be able to actually free the memory in the loop mentioned.\n> \n> Nils, can you remind me the code of how to check with `gc.get_objects()`? I can never seem to remember it.\nThere's a pretty clean example on the ticket #18426 you referenced above and which you reported. That's where I copied the code from when I tried. I actually made a mistake. There does seem to be some leakage, but it seems capped, oddly enough; like there's an LRU cache in place or so.\n\n```\nimport gc\nfrom collections import Counter\ngc.collect()\npre={id(a) for a in gc.get_objects()}\nfor n in [2..600]:\n  r = ShiftedPrimedTableaux([n,1], max_entry=2)\n  r._dummy= True\ndel r\ngc.collect()\ngc.collect()\ngc.collect()\n\nT=Counter(str(type(a)) for a in gc.get_objects() if id(a) not in pre)\n[t for t in T.iteritems() if 'Primed' in t[0]]\n```\n\nFor me on 8.6, this finds 128 objects. And that number remains constant if I increase the bound 600 above.",
    "created_at": "2019-01-20T17:24:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377234",
    "user": "https://github.com/nbruin"
}
```

Replying to [comment:5 tscrim]:
> I do not seem to be able to actually free the memory in the loop mentioned.
> 
> Nils, can you remind me the code of how to check with `gc.get_objects()`? I can never seem to remember it.
There's a pretty clean example on the ticket #18426 you referenced above and which you reported. That's where I copied the code from when I tried. I actually made a mistake. There does seem to be some leakage, but it seems capped, oddly enough; like there's an LRU cache in place or so.

```
import gc
from collections import Counter
gc.collect()
pre={id(a) for a in gc.get_objects()}
for n in [2..600]:
  r = ShiftedPrimedTableaux([n,1], max_entry=2)
  r._dummy= True
del r
gc.collect()
gc.collect()
gc.collect()

T=Counter(str(type(a)) for a in gc.get_objects() if id(a) not in pre)
[t for t in T.iteritems() if 'Primed' in t[0]]
```

For me on 8.6, this finds 128 objects. And that number remains constant if I increase the bound 600 above.



---

archive/issue_comments_377235.json:
```json
{
    "body": "Replying to [comment:8 nbruin]:\n> Replying to [comment:5 tscrim]:\n> > I do not seem to be able to actually free the memory in the loop mentioned.\n> > \n> > Nils, can you remind me the code of how to check with `gc.get_objects()`? I can never seem to remember it.\n> There's a pretty clean example on the ticket #18426 you referenced above and which you reported. \n\n*facepalm*\n\n> That's where I copied the code from when I tried. I actually made a mistake. There does seem to be some leakage, but it seems capped, oddly enough; like there's an LRU cache in place or so.\n\nRunning this variant\n\n```\nimport gc\nfrom collections import Counter\ngc.collect()\npre={id(a) for a in gc.get_objects()}\nfor n in range(1000,2,-1):\n    C = crystals.Letters(['A',n])\n    T = tensor([C]*n)\n    del C\n    del T\ngc.collect()\ngc.collect()\ngc.collect()\n\nT=Counter(str(type(a)) for a in gc.get_objects() if id(a) not in pre)\n[t for t in T.iteritems() if 'letters' in t[0] or 'tensor_product' in t[0]]\n```\n\nresults in\n\n```\n[(\"<type 'sage.combinat.crystals.letters.Crystal_of_letters_type_A_element'>\",\n  624),\n (\"<class 'sage.combinat.crystals.tensor_product.FullTensorProductOfRegularCrystals_with_category'>\",\n  32),\n (\"<class 'sage.combinat.crystals.letters.ClassicalCrystalOfLetters_with_category'>\",\n  32)]\nsage: sum(crystals.Letters(['A',n]).cardinality() for n in range(3,35))\n624\n```\n\nSo I agree, there seems to be some sort of LRU cache going on, but no real memory leak.\n\nActually, I have vague recollection of some sort of discussion about doing an LRU cache on sage-devel at some point, but I don't remember the outcome or details.",
    "created_at": "2019-01-20T18:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377235",
    "user": "https://github.com/tscrim"
}
```

Replying to [comment:8 nbruin]:
> Replying to [comment:5 tscrim]:
> > I do not seem to be able to actually free the memory in the loop mentioned.
> > 
> > Nils, can you remind me the code of how to check with `gc.get_objects()`? I can never seem to remember it.
> There's a pretty clean example on the ticket #18426 you referenced above and which you reported. 

*facepalm*

> That's where I copied the code from when I tried. I actually made a mistake. There does seem to be some leakage, but it seems capped, oddly enough; like there's an LRU cache in place or so.

Running this variant

```
import gc
from collections import Counter
gc.collect()
pre={id(a) for a in gc.get_objects()}
for n in range(1000,2,-1):
    C = crystals.Letters(['A',n])
    T = tensor([C]*n)
    del C
    del T
gc.collect()
gc.collect()
gc.collect()

T=Counter(str(type(a)) for a in gc.get_objects() if id(a) not in pre)
[t for t in T.iteritems() if 'letters' in t[0] or 'tensor_product' in t[0]]
```

results in

```
[("<type 'sage.combinat.crystals.letters.Crystal_of_letters_type_A_element'>",
  624),
 ("<class 'sage.combinat.crystals.tensor_product.FullTensorProductOfRegularCrystals_with_category'>",
  32),
 ("<class 'sage.combinat.crystals.letters.ClassicalCrystalOfLetters_with_category'>",
  32)]
sage: sum(crystals.Letters(['A',n]).cardinality() for n in range(3,35))
624
```

So I agree, there seems to be some sort of LRU cache going on, but no real memory leak.

Actually, I have vague recollection of some sort of discussion about doing an LRU cache on sage-devel at some point, but I don't remember the outcome or details.



---

archive/issue_comments_377236.json:
```json
{
    "body": "Changing component from combinatorics to memleak.",
    "created_at": "2019-01-20T18:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377236",
    "user": "https://github.com/tscrim"
}
```

Changing component from combinatorics to memleak.



---

archive/issue_comments_377237.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2019-01-20T18:07:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377237",
    "user": "https://github.com/tscrim"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_377238.json:
```json
{
    "body": "Replacing `ShiftedPrimedTableaux([n,1], max_entry=2)` with `SetPartitions(n)` I get `<class 'sage.combinat.set_partition.SetPartitions_set_with_category'>\": 128`.\n\nPerhaps the thread https://groups.google.com/forum/#!searchin/sage-devel/lru/sage-devel/q5uy_lI11jg/kRWKxvCImwEJ from long ago is relevant?",
    "created_at": "2019-01-20T18:35:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377238",
    "user": "https://github.com/mantepse"
}
```

Replacing `ShiftedPrimedTableaux([n,1], max_entry=2)` with `SetPartitions(n)` I get `<class 'sage.combinat.set_partition.SetPartitions_set_with_category'>": 128`.

Perhaps the thread https://groups.google.com/forum/#!searchin/sage-devel/lru/sage-devel/q5uy_lI11jg/kRWKxvCImwEJ from long ago is relevant?



---

archive/issue_comments_377239.json:
```json
{
    "body": "Oh boy. It would seem that #24954 is responsible for this:\n\n[unique_representation.py:1012 ](https://github.com/sagemath/sage/blob/6abcb72592dd3d288c68fe601756c9cbc96efe8b/src/sage/structure/unique_representation.py#L1012)\n\nindeed it mentions a \"128\". So yes, there is no memory leak in the code, but after #24954 any test will indeed perceive a leak of something like 128 elements. In fact, with `crystal.Letters` there is apparently another implied construction, so we end up with only \"64\" elements.\n\nThis was exactly why I wasn't happy with #24954. It makes finding memory error that much harder. On the plus side: as this example shows, it does drive home the global nature of `UniqueRepresentation` elements a little more, and the fact that you shouldn't add or modify attributes on them.",
    "created_at": "2019-01-20T19:32:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377239",
    "user": "https://github.com/nbruin"
}
```

Oh boy. It would seem that #24954 is responsible for this:

[unique_representation.py:1012 ](https://github.com/sagemath/sage/blob/6abcb72592dd3d288c68fe601756c9cbc96efe8b/src/sage/structure/unique_representation.py#L1012)

indeed it mentions a "128". So yes, there is no memory leak in the code, but after #24954 any test will indeed perceive a leak of something like 128 elements. In fact, with `crystal.Letters` there is apparently another implied construction, so we end up with only "64" elements.

This was exactly why I wasn't happy with #24954. It makes finding memory error that much harder. On the plus side: as this example shows, it does drive home the global nature of `UniqueRepresentation` elements a little more, and the fact that you shouldn't add or modify attributes on them.



---

archive/issue_comments_377240.json:
```json
{
    "body": "See #24954 indeed.",
    "created_at": "2019-01-20T19:33:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377240",
    "user": "https://github.com/jdemeyer"
}
```

See #24954 indeed.



---

archive/issue_comments_377241.json:
```json
{
    "body": "Let us close this if nobody objects.",
    "created_at": "2021-08-19T22:42:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377241",
    "user": "https://github.com/slel"
}
```

Let us close this if nobody objects.



---

archive/issue_comments_377242.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2021-08-19T22:42:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377242",
    "user": "https://github.com/slel"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_377243.json:
```json
{
    "body": "Resolution: invalid",
    "created_at": "2021-08-26T02:08:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/26846",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/26846#issuecomment-377243",
    "user": "https://github.com/mkoeppe"
}
```

Resolution: invalid
