# Issue 19350: Implement the Chow ring of a matroid

Issue created by migration from Trac.

Original creator: tscrim

Original creation time: 2015-11-14 17:51:02

Assignee: tscrim

We implement the Chow ring of a matroid following http://arxiv.org/abs/1511.02888, which in turns follows Feitcher and Yuzvinsky.


---

Comment by tscrim created at 2015-11-14 17:58:27

New commits:


---

Comment by tscrim created at 2015-11-14 17:58:27

Changing status from new to needs_review.


---

Comment by Rudi created at 2015-11-20 10:21:32

Changing status from needs_review to positive_review.


---

Comment by Rudi created at 2015-11-20 10:21:32

Hi Travis,

I reviewed the code. I was worried that I might not have the necessary background to verify if the algebra is correct, but the definition of the chow ring is right on page two of the paper you refer to and is pretty straightforward. Your implementation follows the definition exactly.

The code also works on my favorite fringe cases, the empty matroid, several other rank-0 matroids, some uniform matroids, and on various other small matroids. 

As far as I can tell the code is correct, looks good, survives doctesting, so positive review! Thank you for keeping sage up to speed with the very latest developments in matroid theory this way.

The running time of your code does increase steeply with the size/rank of the matroid. 

```
sage: M=matroids.Uniform(3,5)
sage: M.chow_ring().gens()
```

is more or less instantaneous, but M=matroids.Uniform(4,5) simply does not finish on my machine, and neither does M=matroids.Uniform(3,6). Also, the computation for P8 gets killed by my linux machine, probably due to excessive resource hogging. 

Looking at the definition of chow ring, that makes sense. The full set of flats is simply a very very big set of generators already for small matroids. Just looking at the definition (and blissfully unaware of any further theory),  I wonder if computing the chow ring recursively may be more efficient, e.g. first computing the chow ring of the truncation, then adding the generators and relations involving the hyperplanes. Or perhaps another recursion, where you first compute a deletion or contraction minor.


---

Comment by Rudi created at 2015-11-20 12:50:24

Thinking a bit about efficiency, this seems to insert a quadratic number of relations:

```
L = [sum(gens[i] for i in flats_containing[x]) - sum(gens[i] for i in flats_containing[y]) 
      for j,x in enumerate(E) for y in E[j+1:]]
```

where a linear set of relations generates the same ideal J_M:

```
L = [sum(gens[i] for i in flats_containing[E[j]]) - sum(gens[i] for i in flats_containing[E[j+1]]) 
      for j in range(len(E)-1)]
```

But this does not affect the running time by much. The real pain seems to be in the relations defining I_M. 

I also see now that my plan for recursive calculation through truncation does not make sense. Truncation really changes the relations which define J_M, and does not just remove some of the relations.


---

Comment by tscrim created at 2015-11-20 17:06:03

Replying to [comment:2 Rudi]:
> I reviewed the code. I was worried that I might not have the necessary background to verify if the algebra is correct, but the definition of the chow ring is right on page two of the paper you refer to and is pretty straightforward. Your implementation follows the definition exactly.
> 
> The code also works on my favorite fringe cases, the empty matroid, several other rank-0 matroids, some uniform matroids, and on various other small matroids. 

That's good to hear; I didn't necessarily check on them... <.< >.>

> As far as I can tell the code is correct, looks good, survives doctesting, so positive review! Thank you for keeping sage up to speed with the very latest developments in matroid theory this way.

Thank you for doing the review Rudi.

> The running time of your code does increase steeply with the size/rank of the matroid. 
> {{{
> sage: M=matroids.Uniform(3,5)
> sage: M.chow_ring().gens()
> }}}
> is more or less instantaneous, but M=matroids.Uniform(4,5) simply does not finish on my machine, and neither does M=matroids.Uniform(3,6). Also, the computation for P8 gets killed by my linux machine, probably due to excessive resource hogging. 

I'm not too surprised because, as you said, it is roughly quadratic in the number of flats and along with the linear relations, this gives a lot of relations for computing the Gröbner basis. If I understand my quick Googling correctly, this grows exponentially in the number of relations.

I can create the Chow rings relatively quickly, but getting the Gröbner basis is what really takes the time. Using `U(3,6)` has 45 relations, and a bunch of the linear relations have 10+ terms. However, the `gens()` does work fairly quickly over `GF(2)` (where it has 352 polynomials) and `QQ` (with 407 polynomials). So the only thing we could really add to it at this point is a note saying to try it over other rings/fields (or make Singular go faster over `ZZ`)...


---

Comment by vbraun created at 2015-11-23 06:34:18

Resolution: fixed
