# Issue 29945: Family: support slices

Issue created by migration from https://trac.sagemath.org/ticket/30182

Original creator: mkoeppe

Original creation time: 2020-07-20 19:33:32

CC:  tscrim nthiery @mwageringel


```
sage: F = Family([0, 1, 4, 9])
sage: F[2]
4
sage: F[2:]
(4, 9)
```

This happens to work because it is passed on to `list.__item__`.
But:

```
sage: F = Family({0:0, 1:1, 2:4, 3:9})
sage: F[2]
4
sage: F[2:]
TypeError: unhashable type: 'slice'
```



---

Comment by @mwageringel created at 2020-07-20 19:46:34

+1

I have been looking for this functionality, too, recently.


---

Comment by nthiery created at 2020-07-20 19:58:59

It's a natural feature to wish. Yet one difficulty is what semantic do we want for `F[i:j]`, given that `F[i]` does not return the i-th element, but the element indexed by i?. Should this be the i-th to j-1-th element of the family? Or all elements with index k such that i<=k<j? In the latter case, for which order?


---

Comment by mkoeppe created at 2020-07-20 20:10:33

Thanks. I have clarified the ticket description


---

Comment by nthiery created at 2020-07-20 20:28:05

Hi Matthias,

Can you clarify the semantic you have in mind? I am not sure why the first should fail when the second one would not?


---

Comment by mkoeppe created at 2020-07-20 20:33:54

Edited the description to clarify


---

Comment by mkoeppe created at 2020-07-20 20:36:49

Replying to [comment:2 nthiery]:
> what semantic do we want for F[i:j], ...
> Should this be ... all elements with index k such that i<=k<j? In the latter case, for which order?

Yes, raising an `IndexError` if an element indexed by k is not present. In the order of increasing indices.


---

Comment by nthiery created at 2020-07-20 20:40:44

Ok. That's consistent indeed.


---

Comment by @mwageringel created at 2020-07-20 20:54:29

I am not sure about half-open slices. For example, what is the expected result of this?


```
sage: F = Family({0:0, 2:4, 3:9, 10:10})
sage: F[2:]
```


I would probably expect an error, as the keys `4..9` are missing, but it is not possible to obtain this information efficiently from the dictionary.


---

Comment by mkoeppe created at 2020-07-20 21:03:45

Replying to [comment:10 gh-mwageringel]:
> I am not sure about half-open slices. For example, what is the expected result of this?
> 
> {{{
> sage: F = Family({0:0, 2:4, 3:9, 10:10})
> sage: F[2:]
> }}}
> 
> I would probably expect an error, as the keys `4..9` are missing, but it is not possible to obtain this information efficiently from the dictionary.

This is certainly a point that needs clarification.


---

Comment by tscrim created at 2020-07-24 01:29:51

I don't expect that to be an error, but instead return `[4, 9, 10]` or maybe `Family({2:4, 3:9, 10:10})`.

What you are essentially asking for is a slice of a `dict`. However, I don't think this makes a lot of sense.

Also, what do you do when the keys are not (and cannot be) ordered?

I think this is fine when the `Family` object is list-like, but in general, I doubt it is possible to get something consistent.


---

Comment by mkoeppe created at 2020-07-24 01:43:18

My take is that `Family` is trying to abstract the difference between lists and hashes etc. away.  But currently the slicing behavior of lists leaks through to `__item__`.  It would be fine to just make the first example in the ticket description an error too.

But I think slicing *is* very useful, and the specification that we have worked out so far on the ticket seems consistent. We could just make unbounded ranges an error - bounded ranges would still be good enough.


---

Comment by tscrim created at 2020-07-24 02:14:48

I agree that slicing is useful.

Even with bounded ranges, there still is a problem when the keys are not comparable (say, indexed by complex numbers). If they form a poset, then the natural thing would be the interval between them, but the next question is how do you check you got everything? For finite posets, this isn't a problem, but a `Family` can be indexed by an infinite set. Do you want to just disallow slices when the set is infinite? Or perhaps just non-enumerated sets, where you don't have a `rank` function?


---

Comment by mkoeppe created at 2020-07-24 02:22:26

I am not sure about the interpretation of slice(a, b) as intervals. That is not really compatible with the idea that it is an error if an element is missing.

Rather I'd make the assumption that the index set is totally ordered and define slice(a,b) == slice(a, b, 1) and slice(a, b, step) == [ a, a+step, ... ]


---

Comment by tscrim created at 2020-07-24 02:48:54

Then what does "totally ordered" and "missing" mean here? The set `[0, 2, 3, 10]` is totally ordered, and there are 4! number of orderings possible to. What about if I do `[0, 2/3, 3/10, 5]` as my keys?


---

Comment by @mwageringel created at 2020-07-24 18:16:24

Replying to [comment:13 tscrim]:
> I don't expect that to be an error, but instead return `[4, 9, 10]` or maybe `Family({2:4, 3:9, 10:10})`.

Indeed, it might be better if it does not raise an error, especially if the example from the description is an intended use case in which a slice is used to restrict the support of an element in `CombinatorialFreeModule`.

This is also consistent with ordinary use of slices, as the following does not throw an error either:

```
sage: [0,1,2][0:10]
[0, 1, 2]
```


> Also, what do you do when the keys are not (and cannot be) ordered?

I think it is fine to focus on the case in which the keys are integers for now.


---

Comment by mkoeppe created at 2020-07-24 18:38:01

Replying to [comment:20 gh-mwageringel]:
> Replying to [comment:13 tscrim]:
> > I don't expect that to be an error, but instead return `[4, 9, 10]` or maybe `Family({2:4, 3:9, 10:10})`.
> 
> Indeed, it might be better if it does not raise an error, especially if the example from the description is an intended use case in which a slice is used to restrict the support of an element in `CombinatorialFreeModule`.
> 
> This is also consistent with ordinary use of slices, as the following does not throw an error either

Good point. This variant is fine with me.  Let's change the ticket description


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
