# Issue 29945: Family: support slices

archive/issues_029945.json:
```json
{
    "body": "CC:  tscrim nthiery @mwageringel\n\n\n```\nsage: F = Family([0, 1, 4, 9])\nsage: F[2]\n4\nsage: F[2:]\n(4, 9)\n```\n\nThis happens to work because it is passed on to `list.__item__`.\nBut:\n\n```\nsage: F = Family({0:0, 1:1, 2:4, 3:9})\nsage: F[2]\n4\nsage: F[2:]\nTypeError: unhashable type: 'slice'\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/30182\n\n",
    "created_at": "2020-07-20T19:33:32Z",
    "labels": [
        "combinatorics",
        "major",
        "enhancement"
    ],
    "title": "Family: support slices",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/29945",
    "user": "mkoeppe"
}
```
CC:  tscrim nthiery @mwageringel


```
sage: F = Family([0, 1, 4, 9])
sage: F[2]
4
sage: F[2:]
(4, 9)
```

This happens to work because it is passed on to `list.__item__`.
But:

```
sage: F = Family({0:0, 1:1, 2:4, 3:9})
sage: F[2]
4
sage: F[2:]
TypeError: unhashable type: 'slice'
```


Issue created by migration from https://trac.sagemath.org/ticket/30182





---

archive/issue_comments_425359.json:
```json
{
    "body": "+1\n\nI have been looking for this functionality, too, recently.",
    "created_at": "2020-07-20T19:46:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425359",
    "user": "@mwageringel"
}
```

+1

I have been looking for this functionality, too, recently.



---

archive/issue_comments_425360.json:
```json
{
    "body": "It's a natural feature to wish. Yet one difficulty is what semantic do we want for `F[i:j]`, given that `F[i]` does not return the i-th element, but the element indexed by i?. Should this be the i-th to j-1-th element of the family? Or all elements with index k such that i<=k<j? In the latter case, for which order?",
    "created_at": "2020-07-20T19:58:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425360",
    "user": "nthiery"
}
```

It's a natural feature to wish. Yet one difficulty is what semantic do we want for `F[i:j]`, given that `F[i]` does not return the i-th element, but the element indexed by i?. Should this be the i-th to j-1-th element of the family? Or all elements with index k such that i<=k<j? In the latter case, for which order?



---

archive/issue_comments_425361.json:
```json
{
    "body": "Thanks. I have clarified the ticket description",
    "created_at": "2020-07-20T20:10:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425361",
    "user": "mkoeppe"
}
```

Thanks. I have clarified the ticket description



---

archive/issue_comments_425362.json:
```json
{
    "body": "Hi Matthias,\n\nCan you clarify the semantic you have in mind? I am not sure why the first should fail when the second one would not?",
    "created_at": "2020-07-20T20:28:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425362",
    "user": "nthiery"
}
```

Hi Matthias,

Can you clarify the semantic you have in mind? I am not sure why the first should fail when the second one would not?



---

archive/issue_comments_425363.json:
```json
{
    "body": "Edited the description to clarify",
    "created_at": "2020-07-20T20:33:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425363",
    "user": "mkoeppe"
}
```

Edited the description to clarify



---

archive/issue_comments_425364.json:
```json
{
    "body": "Replying to [comment:2 nthiery]:\n> what semantic do we want for F[i:j], ...\n> Should this be ... all elements with index k such that i<=k<j? In the latter case, for which order?\n\nYes, raising an `IndexError` if an element indexed by k is not present. In the order of increasing indices.",
    "created_at": "2020-07-20T20:36:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425364",
    "user": "mkoeppe"
}
```

Replying to [comment:2 nthiery]:
> what semantic do we want for F[i:j], ...
> Should this be ... all elements with index k such that i<=k<j? In the latter case, for which order?

Yes, raising an `IndexError` if an element indexed by k is not present. In the order of increasing indices.



---

archive/issue_comments_425365.json:
```json
{
    "body": "Ok. That's consistent indeed.",
    "created_at": "2020-07-20T20:40:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425365",
    "user": "nthiery"
}
```

Ok. That's consistent indeed.



---

archive/issue_comments_425366.json:
```json
{
    "body": "I am not sure about half-open slices. For example, what is the expected result of this?\n\n\n```\nsage: F = Family({0:0, 2:4, 3:9, 10:10})\nsage: F[2:]\n```\n\n\nI would probably expect an error, as the keys `4..9` are missing, but it is not possible to obtain this information efficiently from the dictionary.",
    "created_at": "2020-07-20T20:54:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425366",
    "user": "@mwageringel"
}
```

I am not sure about half-open slices. For example, what is the expected result of this?


```
sage: F = Family({0:0, 2:4, 3:9, 10:10})
sage: F[2:]
```


I would probably expect an error, as the keys `4..9` are missing, but it is not possible to obtain this information efficiently from the dictionary.



---

archive/issue_comments_425367.json:
```json
{
    "body": "Replying to [comment:10 gh-mwageringel]:\n> I am not sure about half-open slices. For example, what is the expected result of this?\n> \n> {{{\n> sage: F = Family({0:0, 2:4, 3:9, 10:10})\n> sage: F[2:]\n> }}}\n> \n> I would probably expect an error, as the keys `4..9` are missing, but it is not possible to obtain this information efficiently from the dictionary.\n\nThis is certainly a point that needs clarification.",
    "created_at": "2020-07-20T21:03:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425367",
    "user": "mkoeppe"
}
```

Replying to [comment:10 gh-mwageringel]:
> I am not sure about half-open slices. For example, what is the expected result of this?
> 
> {{{
> sage: F = Family({0:0, 2:4, 3:9, 10:10})
> sage: F[2:]
> }}}
> 
> I would probably expect an error, as the keys `4..9` are missing, but it is not possible to obtain this information efficiently from the dictionary.

This is certainly a point that needs clarification.



---

archive/issue_comments_425368.json:
```json
{
    "body": "I don't expect that to be an error, but instead return `[4, 9, 10]` or maybe `Family({2:4, 3:9, 10:10})`.\n\nWhat you are essentially asking for is a slice of a `dict`. However, I don't think this makes a lot of sense.\n\nAlso, what do you do when the keys are not (and cannot be) ordered?\n\nI think this is fine when the `Family` object is list-like, but in general, I doubt it is possible to get something consistent.",
    "created_at": "2020-07-24T01:29:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425368",
    "user": "tscrim"
}
```

I don't expect that to be an error, but instead return `[4, 9, 10]` or maybe `Family({2:4, 3:9, 10:10})`.

What you are essentially asking for is a slice of a `dict`. However, I don't think this makes a lot of sense.

Also, what do you do when the keys are not (and cannot be) ordered?

I think this is fine when the `Family` object is list-like, but in general, I doubt it is possible to get something consistent.



---

archive/issue_comments_425369.json:
```json
{
    "body": "My take is that `Family` is trying to abstract the difference between lists and hashes etc. away.  But currently the slicing behavior of lists leaks through to `__item__`.  It would be fine to just make the first example in the ticket description an error too.\n\nBut I think slicing *is* very useful, and the specification that we have worked out so far on the ticket seems consistent. We could just make unbounded ranges an error - bounded ranges would still be good enough.",
    "created_at": "2020-07-24T01:43:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425369",
    "user": "mkoeppe"
}
```

My take is that `Family` is trying to abstract the difference between lists and hashes etc. away.  But currently the slicing behavior of lists leaks through to `__item__`.  It would be fine to just make the first example in the ticket description an error too.

But I think slicing *is* very useful, and the specification that we have worked out so far on the ticket seems consistent. We could just make unbounded ranges an error - bounded ranges would still be good enough.



---

archive/issue_comments_425370.json:
```json
{
    "body": "I agree that slicing is useful.\n\nEven with bounded ranges, there still is a problem when the keys are not comparable (say, indexed by complex numbers). If they form a poset, then the natural thing would be the interval between them, but the next question is how do you check you got everything? For finite posets, this isn't a problem, but a `Family` can be indexed by an infinite set. Do you want to just disallow slices when the set is infinite? Or perhaps just non-enumerated sets, where you don't have a `rank` function?",
    "created_at": "2020-07-24T02:14:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425370",
    "user": "tscrim"
}
```

I agree that slicing is useful.

Even with bounded ranges, there still is a problem when the keys are not comparable (say, indexed by complex numbers). If they form a poset, then the natural thing would be the interval between them, but the next question is how do you check you got everything? For finite posets, this isn't a problem, but a `Family` can be indexed by an infinite set. Do you want to just disallow slices when the set is infinite? Or perhaps just non-enumerated sets, where you don't have a `rank` function?



---

archive/issue_comments_425371.json:
```json
{
    "body": "I am not sure about the interpretation of slice(a, b) as intervals. That is not really compatible with the idea that it is an error if an element is missing.\n\nRather I'd make the assumption that the index set is totally ordered and define slice(a,b) == slice(a, b, 1) and slice(a, b, step) == [ a, a+step, ... ]",
    "created_at": "2020-07-24T02:22:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425371",
    "user": "mkoeppe"
}
```

I am not sure about the interpretation of slice(a, b) as intervals. That is not really compatible with the idea that it is an error if an element is missing.

Rather I'd make the assumption that the index set is totally ordered and define slice(a,b) == slice(a, b, 1) and slice(a, b, step) == [ a, a+step, ... ]



---

archive/issue_comments_425372.json:
```json
{
    "body": "Then what does \"totally ordered\" and \"missing\" mean here? The set `[0, 2, 3, 10]` is totally ordered, and there are 4! number of orderings possible to. What about if I do `[0, 2/3, 3/10, 5]` as my keys?",
    "created_at": "2020-07-24T02:48:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425372",
    "user": "tscrim"
}
```

Then what does "totally ordered" and "missing" mean here? The set `[0, 2, 3, 10]` is totally ordered, and there are 4! number of orderings possible to. What about if I do `[0, 2/3, 3/10, 5]` as my keys?



---

archive/issue_comments_425373.json:
```json
{
    "body": "Replying to [comment:13 tscrim]:\n> I don't expect that to be an error, but instead return `[4, 9, 10]` or maybe `Family({2:4, 3:9, 10:10})`.\n\nIndeed, it might be better if it does not raise an error, especially if the example from the description is an intended use case in which a slice is used to restrict the support of an element in `CombinatorialFreeModule`.\n\nThis is also consistent with ordinary use of slices, as the following does not throw an error either:\n\n```\nsage: [0,1,2][0:10]\n[0, 1, 2]\n```\n\n\n> Also, what do you do when the keys are not (and cannot be) ordered?\n\nI think it is fine to focus on the case in which the keys are integers for now.",
    "created_at": "2020-07-24T18:16:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425373",
    "user": "@mwageringel"
}
```

Replying to [comment:13 tscrim]:
> I don't expect that to be an error, but instead return `[4, 9, 10]` or maybe `Family({2:4, 3:9, 10:10})`.

Indeed, it might be better if it does not raise an error, especially if the example from the description is an intended use case in which a slice is used to restrict the support of an element in `CombinatorialFreeModule`.

This is also consistent with ordinary use of slices, as the following does not throw an error either:

```
sage: [0,1,2][0:10]
[0, 1, 2]
```


> Also, what do you do when the keys are not (and cannot be) ordered?

I think it is fine to focus on the case in which the keys are integers for now.



---

archive/issue_comments_425374.json:
```json
{
    "body": "Replying to [comment:20 gh-mwageringel]:\n> Replying to [comment:13 tscrim]:\n> > I don't expect that to be an error, but instead return `[4, 9, 10]` or maybe `Family({2:4, 3:9, 10:10})`.\n> \n> Indeed, it might be better if it does not raise an error, especially if the example from the description is an intended use case in which a slice is used to restrict the support of an element in `CombinatorialFreeModule`.\n> \n> This is also consistent with ordinary use of slices, as the following does not throw an error either\n\nGood point. This variant is fine with me.  Let's change the ticket description",
    "created_at": "2020-07-24T18:38:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425374",
    "user": "mkoeppe"
}
```

Replying to [comment:20 gh-mwageringel]:
> Replying to [comment:13 tscrim]:
> > I don't expect that to be an error, but instead return `[4, 9, 10]` or maybe `Family({2:4, 3:9, 10:10})`.
> 
> Indeed, it might be better if it does not raise an error, especially if the example from the description is an intended use case in which a slice is used to restrict the support of an element in `CombinatorialFreeModule`.
> 
> This is also consistent with ordinary use of slices, as the following does not throw an error either

Good point. This variant is fine with me.  Let's change the ticket description



---

archive/issue_comments_425375.json:
```json
{
    "body": "Setting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/29945",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/29945#issuecomment-425375",
    "user": "mkoeppe"
}
```

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.
