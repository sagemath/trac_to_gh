# Issue 12751: Comparison of vectors is O(n) even in the simple cases

Issue created by migration from Trac.

Original creator: hivert

Original creation time: 2012-05-08 13:26:03

Assignee: jason, was

CC:  mguaypaq

Keywords: vector equality

Comparison of large vectors in Sage is slow in a surprising way: even if all
the entries of the vectors are different, the cost is proportional to the
length of the vector instead of having constant cost !

```
sage: l = 1000;   m0 = vector(ZZ, [0]*l); m1 = vector(ZZ, [1]*l)
sage: %timeit m0 == m1
625 loops, best of 3: 656 ç›œ per loop
sage: l = 10000;   m0 = vector(ZZ, [0]*l); m1 = vector(ZZ, [1]*l)
sage: %timeit m0 == m1
125 loops, best of 3: 5.66 ms per loop
sage: l = 100000;   m0 = vector(ZZ, [0]*l); m1 = vector(ZZ, [1]*l)
sage: %timeit m0 == m1
5 loops, best of 3: 59.1 ms per loop
```

This seems to affect all the dense vectors independently from the base ring.


---

Comment by hivert created at 2012-05-08 13:26:36

Changing keywords from "vector equality" to "vector equality days38".


---

Attachment


---

Comment by hivert created at 2012-05-08 16:22:13

Changing status from new to needs_review.


---

Comment by tscrim created at 2012-05-14 22:57:38

Changing status from needs_review to needs_work.


---

Comment by tscrim created at 2012-05-14 22:57:38

It works fine for integers, but observe the following:

```
sage: l = 1000; v1 = vector(ZZ, [0]*l); v2 = vector(QQ, [1]*l)                 
sage: %timeit v1 == v2
5 loops, best of 3: 2.25 ms per loop
sage: %timeit v1 == v2
125 loops, best of 3: 3.24 ms per loop
sage: %timeit v1 == v2
125 loops, best of 3: 3.27 ms per loop
sage: %timeit v1 == v2
125 loops, best of 3: 3.35 ms per loop
sage: l = 2000; v1 = vector(ZZ, [0]*l); v2 = vector(QQ, [1]*l)
sage: %timeit v1 == v2
5 loops, best of 3: 4.72 ms per loop
sage: %timeit v1 == v2
125 loops, best of 3: 6.81 ms per loop
sage: %timeit v1 == v2
125 loops, best of 3: 6.64 ms per loop
```

I can't test any higher because running these tests completely kills my memory (the first comparison will allocate ~150MB RAM, the second ~450MB RAM). It only allocates when I call the comparison. Also my memory usage did not drop when I reassign v1 and v2.


---

Comment by hivert created at 2012-05-15 01:57:01

Replying to [comment:3 tscrim]:
> It works fine for integers, but observe the following:
> {{{
> sage: l = 1000; v1 = vector(ZZ, [0]*l); v2 = vector(QQ, [1]*l)
> }}}
> I can't test any higher because running these tests completely kills my memory (the first comparison will allocate ~150MB RAM, the second ~450MB RAM). It only allocates when I call the comparison. Also my memory usage did not drop when I reassign v1 and v2.

I'd rather to see that as a different problem. The goal of the code here is to
remove a bunch bug whose result was that the specialized code already written
wasn't called. I'm not optimizing anything as I don't have a serious use case
for those specific case, do you ? Note that I didn't made any serious
benchmark either. Comparing vectors with different base rings, which implies
different internal data structure could be certainly optimized, but I'd rather
leaving it to a different ticket.

Cheers,

Florent


---

Comment by hivert created at 2012-05-15 01:57:01

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2012-07-11 11:38:17

Works for comparisons between vectors in the same data structure as you intended.


---

Comment by tscrim created at 2012-07-11 11:38:17

Changing status from needs_review to positive_review.


---

Comment by jdemeyer created at 2012-07-27 20:44:02

Please fill in your real name as Reviewer.


---

Comment by jdemeyer created at 2012-08-01 12:11:25

Resolution: fixed


---

Comment by jdemeyer created at 2015-01-05 13:07:48

In this patch, you added in several places

```diff
+    # __hash__ is not properly inherited if comparison is changed
+    def __hash__(self):
+        """
+        TEST::
+
+            sage: w = vector(ZZ, [-1,0,0,0])
+            sage: w.set_immutable()
+            sage: isinstance(hash(w), int)
+            True
+        """
+        return free_module_element.FreeModuleElement.__hash__(self)
```


What's the reason for this? Removing these `__hash__` methods doesn't do any harm.


---

Comment by hivert created at 2015-01-05 13:33:04

Replying to [comment:9 jdemeyer]:
> In this patch, you added in several places
> What's the reason for this? Removing these `__hash__` methods doesn't do any harm.

In Cython when you overload comparison `__hash__` is not inherited anymore. See the following discussion on cython-user

https://groups.google.com/forum/#!searchin/cython-users/$20hash%28el%29$20does$20not$20work$20though/cython-users/6Jqb0v8g_Vo/f5jXtw4KpmYJ


---

Comment by jdemeyer created at 2015-01-05 14:12:03

Yes, sorry, you are right.

I got confused because

```
v.__hash__()
```

works but

```
hash(v)
```

doesn't.
