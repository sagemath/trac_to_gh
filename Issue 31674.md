# Issue 31674: Boolean symbolic expressions

Issue created by migration from https://trac.sagemath.org/ticket/31911

Original creator: mkoeppe

Original creation time: 2021-06-05 04:27:19

CC:  charpent nbruin egourgoulhon chapoton @spaghettisalat kcrisman

As proposed in https://groups.google.com/g/sage-devel/c/U_WGbYG2zOE/m/yq-EDEXDAgAJ


---

Comment by mkoeppe created at 2021-06-05 05:47:11

Here's an attempt 
----
New commits:


---

Comment by charpent created at 2021-06-05 23:03:16

Replying to [comment:2 mkoeppe]:
> Here's an attempt 
> ----
> New commits:
> ||[863c636](https://git.sagemath.org/sage.git/commit?id=863c636f52e73c08b3730a99ce7345cb694544da)||`sage.functions.boolean.AndSymbolic: New`||

I'll test that tomorrow. A couple remarks :

* `eval` can be farmed out to `sympy`'s `And` (one of the goals of this addition being the ability to use `Sympy`'s `Piecewise` expressions of integrals and ODE solutions, often involving logical expressions...). I was originally aiming at wrapping `Sympy`'s logical functions, but got stopped by :

* The showstopper problem I haven't been able to solve yet is **translation to Maxima** and //backtranslation//.

  This is utterly necessary if you want to keep logical symbolic expressions (or symbolic expressions involving logical parts, as in `case` calls) `simplify`able (other `Expression` methods are also farmed out to Maxima...).

  OTOH, `maxima_calculus` should be easier, since this interface works "naturally" with the Lisp function tree representing Maxima expressions.

* Translation to `Mathematica` and `Sympy` should be trivial (give the names in a  `conversions` argument). I don't know (yet) what is offered by `giac` and `fricas`, but maintaining universal translatability seems highly desirable...

HTH,


---

Comment by egourgoulhon created at 2021-06-06 21:20:30

Replying to [ticket:31911 mkoeppe]:
> 
> One application is for the restrictions of a `Chart`.
May I ask which application?


---

Comment by mkoeppe created at 2021-06-06 21:28:05

Right now, chart restrictions have an ad-hoc representation as nested lists and tuples of symbolic relation expressions; this could be replaced by the corresponding boolean expressions (instances of `AndSymbolic`, `OrSymbolic`)


---

Comment by egourgoulhon created at 2021-06-06 21:48:06

Replying to [comment:6 mkoeppe]:
> Right now, chart restrictions have an ad-hoc representation as nested lists and tuples of symbolic relation expressions; this could be replaced by the corresponding boolean expressions (instances of `AndSymbolic`, `OrSymbolic`)
Ah yes, this would be nice! Thanks for your answer.


---

Comment by mkoeppe created at 2021-08-13 22:23:51

For converting to maxima, some help would be welcome. My last failed attempt looked like this:

```diff
diff --git a/src/sage/functions/boolean.py b/src/sage/functions/boolean.py
index 58089dce81..d32acca761 100644
--- a/src/sage/functions/boolean.py
+++ b/src/sage/functions/boolean.py
@@ -31,7 +31,8 @@ class AndSymbolic(BuiltinFunction):
 
         """
         BuiltinFunction.__init__(self, 'and_symbolic', nargs=0,
-                                 conversions=dict(sympy='And'))
+                                 conversions=dict(sympy='And',
+                                                  maxima='andsymbolic'))
 
     def _eval_(self, *args):
 
diff --git a/src/sage/interfaces/maxima_lib.py b/src/sage/interfaces/maxima_lib.py
index 40367c5242..2f6ab545f8 100644
--- a/src/sage/interfaces/maxima_lib.py
+++ b/src/sage/interfaces/maxima_lib.py
@@ -113,6 +113,9 @@ ecl_eval('(defun principal nil (cond ($noprincipal (diverg)) ((not pcprntd) (mer
 ecl_eval("(remprop 'mfactorial 'grind)") # don't use ! for factorials (#11539)
 ecl_eval("(setf $errormsg nil)")
 
+ecl_eval("(defmfun $andsymbolic (&rest args) (simplify (cons '(mand) args)))")
+
+
 # the following is a direct adaptation of the definition of "retrieve"
 # in the Maxima file macsys.lisp. This routine is normally responsible
 # for displaying a question and returning the answer. We change it to
@@ -1213,7 +1216,8 @@ sage_op_dict = {
     sage.symbolic.expression.operator.neg : "MMINUS",
     sage.symbolic.expression.operator.pow : "MEXPT",
     sage.symbolic.expression.operator.or_ : "MOR",
-    sage.symbolic.expression.operator.and_ : "MAND",
+    #sage.symbolic.expression.operator.and_ : "MAND",
```



---

Comment by git created at 2021-08-13 22:24:35

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2021-08-13 22:47:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-13 23:08:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 02:45:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 03:10:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 03:39:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 04:51:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-08-14 05:02:05

Changing status from new to needs_review.


---

Comment by egourgoulhon created at 2021-08-14 15:34:21

Thank you for implementing this!

It seems that there is no entry for the new symbolic boolean operators in the reference manual. There should probably be more examples of use. A few naive trials:

```
sage: var('x y')
(x, y)
sage: s = x>0 & y<0
TypeError: unsupported operand type(s) for &: 'sage.symbolic.expression.Expression'
 and 'sage.symbolic.expression.Expression'
```



```
sage: from sage.functions.boolean import and_symbolic
sage: s = and_symbolic(x>0, y<0)
sage: bool(s.subs({x: 1, y: -2}))
TypeError: unable to make sense of Maxima expression 'and_symbolic(1>0,-2<0)'
 in Sage
```



---

Comment by git created at 2021-08-14 16:44:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-08-14 16:50:58

Replying to [comment:20 egourgoulhon]:
> {{{
> sage: var('x y')
> (x, y)
> sage: s = x>0 & y<0
> TypeError: unsupported operand type(s) for &: 'sage.symbolic.expression.Expression'
>  and 'sage.symbolic.expression.Expression'
> }}}

The `&` operator is now implemented -- note that due to Python operator precedence, the operands need to be put in parentheses:

```
sage: var('x y') 
(x, y) 
sage: (x>0) & (y<0)                                                                                                                                                            
and_symbolic(x > 0, y < 0)
```



---

Comment by git created at 2021-08-14 17:15:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by charpent created at 2021-08-14 17:19:28

This is work in progress, no ?

* A `symbolic_not` is necessary. It might implement De Morgan's equalities (or this could be delegated to `.expand` and `.factor`, or, alternatively delegated to the [logical functions](https://doc.sagemath.org/html/en/reference/logic/index.html)).

* These functions currently do nothing :


```
sage: var("a, b")                                                               
(a, b)
sage: and_symbolic((a>0), (b<0))                                                
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
<ipython-input-2-67fb44f33113> in <module>
----> 1 and_symbolic((a>Integer(0)), (b<Integer(0)))

NameError: name 'and_symbolic' is not defined
sage: (a>0) & (b<0)                                                             
and_symbolic(a > 0, b < 0)
sage: ((a>0) & (b<0)).subs(a==3)                                                
and_symbolic(3 > 0, b < 0)
```


Compare :

```
sage: ((a>0) & (b<0)).subs(a==3)._sympy_().simplify()._sage_()                  
b < 0
sage: sympy.Not(sympy.And(a._sympy_(), b._sympy_()))                            
~(a & b)
sage: sympy.Not(sympy.And(a._sympy_(), b._sympy_())).simplify()                 
~a | ~b
```


==> `needs_work`
----
New commits:


---

Comment by charpent created at 2021-08-14 17:19:28

Changing status from needs_review to needs_work.


---

Comment by mkoeppe created at 2021-08-14 17:22:16

Replying to [comment:25 charpent]:
> This is work in progress, no ?

Yes; setting it to "needs review" allows the patchbot to run


---

Comment by mkoeppe created at 2021-08-14 17:22:59

`and_symbolic` is not a global binding -- you need to import it to use it, or the `NameError` shows up. See doctests


---

Comment by mkoeppe created at 2021-08-14 17:25:22

Replying to [comment:25 charpent]:
> * A `symbolic_not` is necessary. 

Yes, good point; any help with implementing it is welcome...


---

Comment by mkoeppe created at 2021-08-14 17:39:40

Do we want `and_symbolic`, `or_symbolic`, `not_symbolic` as global bindings?

(The names are modeled after the existing `min_symbolic`, `max_symbolic`.)

In particular, for `not_symbolic`, we cannot rely on an operator to make it available: Sage already repurposes the bitwise inversion operator `~` for multiplicative inversion.


---

Comment by mkoeppe created at 2021-08-14 17:43:43

Changing status from needs_work to needs_info.


---

Comment by charpent created at 2021-08-14 17:44:18

Replying to [comment:27 mkoeppe]:
> `and_symbolic` is not a global binding -- you need to import it to use it, or the `NameError` shows up. See doctests

`and_symbolic` is a tad heavy to be exported. However, global `And`, `Or` and `Not` would be welcome...

BTW, that's how they are  known in Sympy...


---

Comment by mkoeppe created at 2021-08-14 17:49:17

But capitalized And, Or, Not seem out of line with our naming scheme for symbolic functions - they are all lowercase if I'm not mistaken.


---

Comment by mkoeppe created at 2021-08-14 17:50:29

(see `src/sage/functions/all.py`)


---

Comment by mkoeppe created at 2021-08-14 18:05:05

For extending `sage.misc.parser`, I would follow `sage.logic.logicparser` (even though I am not sure of its relevance), which uses `~` for logical 'not'. (It also uses `->` and `<->` for implication/equivalence; and (incompatible with the expression parser) `^` for logical 'xor'.)


---

Comment by git created at 2021-08-14 18:20:18

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by charpent created at 2021-08-14 18:23:10

Replying to [comment:34 mkoeppe]:
> For extending `sage.misc.parser`, I would follow `sage.logic.logicparser` (even though I am not sure of its relevance), which uses `~` for logical 'not'. (It also uses `->` and `<->` for implication/equivalence; and (incompatible with the expression parser) `^` for logical 'xor'.)

This would entail conditioning the interpretation of `~` to the type of its arguments, which is fishy : `~(x>0)` is indubitably a logical expression, but `~(x>0).subs(x==0)` could be understood as ~True}}}, which is ... -2 (!).

`Not` can be unambiguous, and nine characters lighter than "symbolic_not" ; furthermore, "our naming scheme for symbolic functions" is a scheme, not Gospel...
----
New commits:


---

Comment by git created at 2021-08-14 18:24:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-08-14 18:27:45

Replying to [comment:36 charpent]:
> Replying to [comment:34 mkoeppe]:
> > For extending `sage.misc.parser`, I would follow `sage.logic.logicparser` (even though I am not sure of its relevance), which uses `~` for logical 'not'. [...]
> 
> This would entail conditioning the interpretation of `~` [...]

Note, this is just for the expression parser, not for Python semantics.

As I said in comment:29, we cannot use Python operators to make the operation available. We agree here.


---

Comment by mkoeppe created at 2021-08-14 18:31:57

Replying to [comment:36 charpent]:
> `Not` can be unambiguous, and nine characters lighter than "symbolic_not" ; 

It would be `not_symbolic`, which is discoverable by typing `not<TAB>` and autocompletes from `not_<TAB>`, so I don't think the length is a significant burden.


---

Comment by charpent created at 2021-08-14 18:36:03

Replying to [comment:38 mkoeppe]:
> Replying to [comment:36 charpent]:
> > Replying to [comment:34 mkoeppe]:
> > > For extending `sage.misc.parser`, I would follow `sage.logic.logicparser` (even though I am not sure of its relevance), which uses `~` for logical 'not'. [...]
> > 
> > This would entail conditioning the interpretation of `~` [...]
> 
> Note, this is just for the expression parser, not for Python semantics.
> 
> As I said in comment:29, we cannot use Python operators to make the operation available. We agree here.



Possible alternatives :

* forget operators, and limit this functionality to logic functions.

* Borrow inspiration from R and create `&&`, `||` and possibly `~~` operators (analogous  to our representation of bit XOR as `^^`).

IMHO, a functional representatin is the most useful...


---

Comment by mkoeppe created at 2021-08-14 18:47:53

Replying to [comment:40 charpent]:
> create `&&`, `||` and possibly `~~` operators (analogous  to our representation of bit XOR as `^^`).

You mean in the preparser?  I'll not touch that.

In just Python, creating new operators such as `&&` is not possible.


---

Comment by charpent created at 2021-08-14 18:58:52

Something is fishhy in the maxima__>Sage conversion :


```
sage: maxima("(a>0) and (b<0)")                                                 
a>0andb<0
sage: maxima("(a>0) and (b<0)")._sage_()                                        
and_symbolic(a > 0, 0 < 0)
```


* The second clause is ill-translated

* the operator's translation should be `&` (or a call to `symbolic_and` or `And`).


---

Comment by mkoeppe created at 2021-08-14 19:00:27

Yes, see comment:10 -- I have not figured out maxima conversion -- hoping for help from the experts


---

Comment by mkoeppe created at 2021-08-14 19:01:27


```
sage: maxima("(a>0) and (b<0)")                                                 
a>0andb<0
```

Didn't you fix the whitespace-eating behavior some time recently?


---

Comment by mkoeppe created at 2021-08-14 19:15:09

Note

```
sage: sage.calculus.calculus.symbolic_expression_from_string("a>0andb<0", accept_sequence=True)                          
and_symbolic(a > 0, 0 < 0)
sage: sage.calculus.calculus.symbolic_expression_from_string("a>0and b<0", accept_sequence=True)                         
and_symbolic(a > 0, b < 0)
sage: sage.calculus.calculus.symbolic_expression_from_string("0andb", accept_sequence=True)                              
0
```



---

Comment by mkoeppe created at 2021-08-14 19:18:20

Our expression parser has poor error checking and silently ignores unexpected trailing tokens in some situations:

```
sage: sage.calculus.calculus.symbolic_expression_from_string("0fffffif", accept_sequence=True)                           
0
```



---

Comment by mkoeppe created at 2021-08-14 19:21:31

Actually, this is just implicit multiplication `0*fffffif`, which gets simplified to 0.


---

Comment by mkoeppe created at 2021-08-14 19:23:17

Replying to [comment:45 mkoeppe]:
> {{{
> sage: maxima("(a>0) and (b<0)")                                                 
> a>0andb<0
> }}}
> Didn't you fix the whitespace-eating behavior some time recently?

I see, that's #31796, which appears to be stuck


---

Comment by charpent created at 2021-08-14 20:21:19

Replying to [comment:45 mkoeppe]:
> {{{
> sage: maxima("(a>0) and (b<0)")                                                 
> a>0andb<0
> }}}
> Didn't you fix the whitespace-eating behavior some time recently?
> 

I tried. But this patch entailed other bugs, which I hanven't yet understood == back to the old drawing board...


---

Comment by git created at 2021-08-14 21:13:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-08-14 21:19:15

Now, with the repaired #31796 merged, the problem is fixed:

```
sage: maxima("(a>0) and (b<0)")                                                                                    
a > 0 and b < 0
sage: maxima("(a>0) and (b<0)")._sage_()                                                                           
and_symbolic(a > 0, b < 0)
```



---

Comment by mkoeppe created at 2021-08-14 21:22:49

I'm setting this again to `needs_review` so that the patchbot runs; obviously more work is needed.


---

Comment by mkoeppe created at 2021-08-14 21:22:49

Changing status from needs_info to needs_review.


---

Comment by charpent created at 2021-08-14 21:46:41

Replying to [comment:53 mkoeppe]:
> Now, with the repaired #31796 merged, the problem is fixed:
> {{{
> sage: maxima("(a>0) and (b<0)")                                                                                    
> a > 0 and b < 0
> sage: maxima("(a>0) and (b<0)")._sage_()                                                                           
> and_symbolic(a > 0, b < 0)
> }}}

Thanks a lot ; I was searching in that direction, but missed the target you reached masterfully. Kudos !

BTW : "something" translating Maxima's `is` would be as useful as a translation of Maxima's `and`, `or` and `not`, necessary for the present ticket : 


```
(%i3) is(a>2);
(%o3)                               unknown
(%i4) is(subst([a=3],a>2));
(%o4)                                true
```


Not coincidentally, it has the same Sage syntax collision problem...

Shouldn't it be added to this ticket ? Alternatively, we could create a new ticket for this and and depend on it.


---

Comment by mkoeppe created at 2021-08-14 21:57:28

Could you elaborate on `is`? What collides with what?


---

Comment by git created at 2021-08-14 22:19:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 22:22:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by charpent created at 2021-08-14 22:36:10

Replying to [comment:56 mkoeppe]:
> Could you elaborate on `is`? What collides with what?

`is` is a Sage operator, roughly equivalent to Lisp's `eq` :

```
sage: x.parent() is SR
True
```


Therefore, the Maxima's `is` can't be translated by the mechanism used for Maxima's functions : 

```
sage: maxima.is(x>0)
  File "<ipython-input-6-e177b9fc4016>", line 1
    maxima.is(x>Integer(0))
           ^
SyntaxError: invalid syntax

sage: maxima_calculus.is(x>0)
  File "<ipython-input-7-dea1cf49bee0>", line 1
    maxima_calculus.is(x>Integer(0))
                    ^
SyntaxError: invalid syntax
```



---

Comment by mkoeppe created at 2021-08-14 22:38:38

A simple workaround for this is:

```
sage: getattr(maxima, 'is')(x>0)                                                                                         
unknown
```



---

Comment by git created at 2021-08-14 22:51:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-14 23:43:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-15 00:20:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-08-15 00:26:55

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-08-15 00:27:34

Replying to [comment:10 mkoeppe]:
> For converting to maxima, some help would be welcome.

I think I figured a solution


---

Comment by git created at 2021-08-15 04:37:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by charpent created at 2021-08-15 09:20:25

Still problematic :

```
sage: not_symbolic((a>0) & ((b<0) | (x!=0))).simplify()
a <= 0
```

Worse :

```
sage: ((a>0) | (x!=0)).simplify()
1
```

BTW :

```
sage: ~((a>0) & ((b<0) | (x!=0)))
1/and_symbolic(a > 0, or_symbolic(b < 0, x != 0))
```



---

Comment by mkoeppe created at 2021-08-15 14:22:16

Indeed:

```
sage: var('a,b')                                                                                                         
(a, b)
sage: ((a>0) | (x!=0)).simplify()                                                                                        
1
sage: ((a>0) | (x!=0))._maxima_()                                                                                        
true
sage: ((a>0) | (x!=0))                                                                                                   
or_symbolic(a > 0, x != 0)
sage: f = ((a>0) | (x!=0))                                                                                               
sage: f._maxima_init_()                                                                                                  
'(_SAGE_VAR_a > 0) or (_SAGE_VAR_x # 0)'
sage: maxima(_)                                                                                                          
true
sage: (x!=0)._maxima_()                                                                                                  
_SAGE_VAR_x # 0
sage: (a>0)._maxima_()                                                                                                   
_SAGE_VAR_a > 0
sage: maxima('(a>0) or (x # 0)')                                                                                         
true
```

Is this a maxima bug?


---

Comment by mkoeppe created at 2021-08-15 14:29:39

Replying to [comment:69 charpent]:
> BTW :
> {{{
> sage: ~((a>0) & ((b<0) | (x!=0)))
> 1/and_symbolic(a > 0, or_symbolic(b < 0, x != 0))
> }}}

Yes, this is as discussed in comment:29, comment:38.


---

Comment by mkoeppe created at 2021-08-15 14:30:20

Replying to [comment:70 mkoeppe]:
> Is this a maxima bug?

Minimal example in plain maxima 5.45.0:

```
(%i8) (x#0);
(%o8)                                x # 0
(%i9) (x#0) or (x#0);
(%o9)                                true
```



---

Comment by mkoeppe created at 2021-08-15 15:02:22

I think our translation of Python's `==` and `!=` to `=` and `#` on the Maxima side is wrong, and we should use `equal` and `notequal` instead - see https://maxima.sourceforge.io/docs/manual/maxima_169.html (Special operator: if)


---

Comment by charpent created at 2021-08-15 15:27:09

Replying to [comment:72 mkoeppe]:
> Replying to [comment:70 mkoeppe]:
> > Is this a maxima bug?
> 
> Minimal example in plain maxima 5.45.0:
> {{{
> (%i8) (x#0);
> (%o8)                                x # 0
> (%i9) (x#0) or (x#0);
> (%o9)                                true
> }}}
> 

Did you (or do you plan to) report it in Maxima's bug report system ?

BTW : Sympy's logical functions seem exempt from this bug :

```
sage: foo = x!=0
sage: sympy.And(*map(lambda u:u._sympy_(), (foo, foo)))._sage_()
x != 0
sage: sympy.Or(*map(lambda u:u._sympy_(), (foo, foo)))._sage_()
x != 0
sage: sympy.Not(foo._sympy_())._sage_()
x == 0
```

Wrapping Sympy's functions may be a quick way out (that was my initial plan...).


---

Comment by charpent created at 2021-08-15 15:28:20

Replying to [comment:73 mkoeppe]:
> I think our translation of Python's `==` and `!=` to `=` and `#` on the Maxima side is wrong, and we should use `equal` and `notequal` instead - see https://maxima.sourceforge.io/docs/manual/maxima_169.html (Special operator: if)

Doesn't seem to be a question of precedence :

```
(%i9) x#0 or x#0;

(%o9) true
(%i10) (x#0) or (x#0);

(%o10) true
```



---

Comment by mkoeppe created at 2021-08-15 15:38:52

No, I no longer think this is a Maxima bug.

I think it is a bug in our interface `sage.interfaces.maxima_abstract`. There are already two places that work around it (by using `equal`, `notequal`): `Expression._maxima_init_assume_` and `test_relation_maxima`.


---

Comment by mkoeppe created at 2021-08-15 15:41:45

See the early tickets #1163, #2218


---

Comment by charpent created at 2021-08-15 15:46:59

Replying to [comment:76 mkoeppe]:
> No, I no longer think this is a Maxima bug.
> 
> I think it is a bug in our interface `sage.interfaces.maxima_abstract`. There are already two places that work around it (by using `equal`, `notequal`): `Expression._maxima_init_assume_` and `test_relation_maxima`.
> 

Indeed, the documentation is quite clear : `=` and `#` : //syntactic// (in)equality (i. e. isomorphic structures) ; `equal` and `unequal` : //value// (= structural) (in)equality.

This might be a heavy change. Separate ticket, separately tested ?


---

Comment by mkoeppe created at 2021-08-15 16:01:52

Yes, I agree. There is a big potential for breakage. I've opened #32383 for it.


---

Comment by charpent created at 2021-08-15 16:12:05

A possible plan B (independent of the Maxima snag) is to wrap Sympy's symbolic functions `And`, `Or` and `Not`, possibly leaving the logical operators to a later ticket. This is easy, the only problem being Maxima (1+back)translation, which you have solved.

Wrapping a Python method (imptementation of these functions in Sympy) shouldn't be as heavy as invoking a function in another interpreter : we stay in Python.

This is new functionality, after all : we don't (yet) have to worry about backwards compatibility. Introducing it with limited syntax (possibly extended later) isn't a drawback to anybody.

Thoughts ?


---

Comment by mkoeppe created at 2021-08-15 16:23:05

Sympy translation already works, in both directions.


---

Comment by mkoeppe created at 2021-08-15 16:25:50

And there is no remaining issue with "syntax".


---

Comment by git created at 2021-08-15 23:19:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-08-16 04:04:55

This passes tests but will need more work:
- without #32383, roundtripping through maxima is not safe
- `Parser`: Use a `make_...` function instead of importing `and_symbolic` and hardcoding its use - so that the other uses of `Parser` are not affected
- Add more documentation and tests
- possibly create a direct conversion from `bool` to `SR` so that we get to see `False`/`True`, not `0`/`1`
- various places, for example the `solve` method and global function, should be generalized so that they deal with (at least some) boolean symbolic expressions


---

Comment by mkoeppe created at 2021-08-16 04:04:55

Changing status from needs_review to needs_work.


---

Comment by git created at 2022-02-03 18:46:24

Branch pushed to git repo; I updated commit sha1. This was a forced push. Last 10 new commits:


---

Comment by mkoeppe created at 2022-02-03 18:48:29

Rebased.
