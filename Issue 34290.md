# Issue 34290: Make `Composition`s into a `collections.abc.Sequence`

Issue created by migration from https://trac.sagemath.org/ticket/34527

Original creator: tkarn

Original creation time: 2022-09-13 18:02:12

CC:  tscrim tkarn

Keywords: gsoc2022 compositions sequence

Currently Sage does not understand `Composition`s as a `collections.abc.Sequence`:


```
sage: c = Composition([3,4,2,4])
sage: from collections.abc import Sequence
sage: isinstance(c, Sequence)
False
```


This ticket implements the methods required to fix that, namely `Composition.__reversed__` and `Composition.count`


---

Comment by tkarn created at 2022-09-13 18:04:03

The methods required according to the collections documentation (https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes) are present except for `__reversed__` and `count`.


```
sage: c.__getitem__
<bound method CombinatorialObject.__getitem__ of [3, 4, 2, 4]>
sage: c.__len__
<bound method CombinatorialObject.__len__ of [3, 4, 2, 4]>
sage: c.__contains__
<bound method CombinatorialObject.__contains__ of [3, 4, 2, 4]>
sage: c.__iter__
<bound method CombinatorialObject.__iter__ of [3, 4, 2, 4]>
sage: c.__reversed__
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Input In [30], in <cell line: 1>()
----> 1 c.__reversed__

File ~/Applications/sage/src/sage/structure/element.pyx:494, in sage.structure.element.Element.__getattr__()
    492         AttributeError: 'LeftZeroSemigroup_with_category.element_class' object has no attribute 'blah_blah'
    493     """
--> 494     return self.getattr_from_category(name)
    495 
    496 cdef getattr_from_category(self, name):

File ~/Applications/sage/src/sage/structure/element.pyx:507, in sage.structure.element.Element.getattr_from_category()
    505     else:
    506         cls = P._abstract_element_class
--> 507     return getattr_from_other_class(self, cls, name)
    508 
    509 def __dir__(self):

File ~/Applications/sage/src/sage/cpython/getattr.pyx:356, in sage.cpython.getattr.getattr_from_other_class()
    354     dummy_error_message.cls = type(self)
    355     dummy_error_message.name = name
--> 356     raise AttributeError(dummy_error_message)
    357 cdef PyObject* attr = instance_getattr(cls, name)
    358 if attr is NULL:

AttributeError: 'Compositions_all_with_category.element_class' object has no attribute '__reversed__'
sage: index(c)
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Input In [31], in <cell line: 1>()
----> 1 index(c)

NameError: name 'index' is not defined
sage: c.index
<bound method CombinatorialObject.index of [3, 4, 2, 4]>
sage: c.count
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Input In [33], in <cell line: 1>()
----> 1 c.count

File ~/Applications/sage/src/sage/structure/element.pyx:494, in sage.structure.element.Element.__getattr__()
    492         AttributeError: 'LeftZeroSemigroup_with_category.element_class' object has no attribute 'blah_blah'
    493     """
--> 494     return self.getattr_from_category(name)
    495 
    496 cdef getattr_from_category(self, name):

File ~/Applications/sage/src/sage/structure/element.pyx:507, in sage.structure.element.Element.getattr_from_category()
    505     else:
    506         cls = P._abstract_element_class
--> 507     return getattr_from_other_class(self, cls, name)
    508 
    509 def __dir__(self):

File ~/Applications/sage/src/sage/cpython/getattr.pyx:356, in sage.cpython.getattr.getattr_from_other_class()
    354     dummy_error_message.cls = type(self)
    355     dummy_error_message.name = name
--> 356     raise AttributeError(dummy_error_message)
    357 cdef PyObject* attr = instance_getattr(cls, name)
    358 if attr is NULL:

AttributeError: 'Compositions_all_with_category.element_class' object has no attribute 'count'
```



---

Comment by tkarn created at 2022-09-13 18:49:23

New commits:


---

Comment by tkarn created at 2022-09-13 18:49:23

Changing status from new to needs_review.


---

Comment by mkoeppe created at 2022-09-13 19:01:12

Maybe some doctests to illustrate the supported operations would be good, to help other Sage users understand the Sequence protocol?


---

Comment by mkoeppe created at 2022-09-13 19:03:13

Also in the doctest I would suggest to use the fully qualified name `collections.abc.Sequence` for clarity because there's also the unrelated global binding `Sequence` in Sage.


---

Comment by tscrim created at 2022-09-13 23:28:07

+1 to Matthias’s comments; in particular the `count` method is a bit unnatural for compositions.

It might make more sense to simply inherit from `Sequence` instead of registering it and providing a `__reversed__` method (which should return a `Composition`). The default `count` should be okay.


---

Comment by tkarn created at 2022-09-15 03:22:37

It looks like things are sufficiently fixed just by calling `Sequence.register(Composition)`. As Matthias suggested, I updated the doctest. I'm not sure there is a need to actually implement the `__reversed__` or `count` methods as I had suggested earlier.


---

Comment by git created at 2022-09-15 03:23:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-15 04:14:01

Replying to [comment:7 Trevor Karn]:
> It looks like things are sufficiently fixed just by calling `Sequence.register(Composition)`.

Yes, this is equivalent to inheriting from `Sequence`.


---

Comment by mkoeppe created at 2022-09-15 04:14:08

comment:4?


---

Comment by tkarn created at 2022-09-15 04:18:41

Replying to [comment:10 Matthias Köppe]:
> comment:4?

Sorry, I think I misunderstood. Since we are registering it as a `Sequence` rather than implementing the "required" methods, the general `Sequence` protocol is not really followed. Maybe this is something that should go in the developer's guide rather than a doctest here?


---

Comment by tscrim created at 2022-09-15 04:19:29

Replying to [comment:7 Trevor Karn]:
> It looks like things are sufficiently fixed just by calling `Sequence.register(Composition)`.

Does it also pass the `issubclass` test too?

> As Matthias suggested, I updated the doctest. I'm not sure there is a need to actually implement the `__reversed__` or `count` methods as I had suggested earlier.

What is the type of the result from applying `reversed` to the composition? Some tests would help here, a la comment:4.


---

Comment by mkoeppe created at 2022-09-15 04:36:49

Replying to [comment:9 Matthias Köppe]:
> Replying to [comment:7 Trevor Karn]:
> > It looks like things are sufficiently fixed just by calling `Sequence.register(Composition)`.
> 
> Yes, this is equivalent to inheriting from `Sequence`.

I realize that I have to clarify this: It is equivalent as far as `isinstance` and `issubclass` are concerned, but you will get the mix-in methods listed in https://docs.python.org/3/library/collections.abc.html#collections-abstract-base-classes (`__reversed__`, `count`, etc.) only if you inherit from `Sequence` in the class definition.


---

Comment by mkoeppe created at 2022-09-15 04:37:32

Replying to [comment:12 Travis Scrimshaw]:
> Replying to [comment:7 Trevor Karn]:
> > It looks like things are sufficiently fixed just by calling `Sequence.register(Composition)`.
> 
> Does it also pass the `issubclass` test too?

Yes, of course, that should be added as a test maybe:

```
sage: import collections.abc
sage: C = Composition([3,2,3])
sage: issubclass(C.__class__, collections.abc.Sequence)
True
sage: isinstance(C, collections.abc.Sequence)
True
```



---

Comment by mkoeppe created at 2022-09-15 04:38:22

Replying to [comment:12 Travis Scrimshaw]:
> What is the type of the result from applying `reversed` to the composition? 

```
sage: reversed(C)
<reversed object at 0x7fe2e86c4e50>
```



---

Comment by mkoeppe created at 2022-09-15 04:39:28

Replying to [comment:11 Trevor Karn]:
> Replying to [comment:10 Matthias Köppe]:
> > comment:4?
> 
> Sorry, I think I misunderstood. Since we are registering it as a `Sequence` rather than implementing the "required" methods, the general `Sequence` protocol is not really followed.

It is followed. The "mixin" methods are not part of the protocol.


---

Comment by mkoeppe created at 2022-09-15 04:41:28

Replying to [comment:16 Matthias Köppe]:
> Replying to [comment:11 Trevor Karn]:
> > Replying to [comment:10 Matthias Köppe]:
> > > comment:4?
> > 
> > Sorry, I think I misunderstood. Since we are registering it as a `Sequence` rather than implementing the "required" methods, the general `Sequence` protocol is not really followed.
> 
> It is followed. The "mixin" methods are not part of the protocol.

No, sorry, my mistake. It's getting late here.

You are right, it is not allowed to register it without implementing these mixin methods.
But you'll get them for free by changing it to subclassing instead of registering.


---

Comment by tscrim created at 2022-09-15 04:41:37

Replying to [comment:15 Matthias Köppe]:
> Replying to [comment:12 Travis Scrimshaw]:
> > What is the type of the result from applying `reversed` to the composition? 
> {{{
> sage: reversed(C)
> <reversed object at 0x7fe2e86c4e50>
> }}}

Ah, right, duh. It is an iterator and does not return the reversed object.


---

Comment by tkarn created at 2022-09-15 05:14:29

After subclassing:

```
  File "/Users/trevorkarn/Applications/sage/src/sage/combinat/composition.py", line 50, in <module>
    class Composition(CombinatorialElement, Sequence):
TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
```


Should this be fixed at the `CombinatorialElement` level? Or would it be better to just make `Composition` a subclass of `ClonableArray` to update it?


---

Comment by git created at 2022-09-15 05:23:21

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2022-09-15 07:10:29

Replying to [comment:19 Trevor Karn]:
> After subclassing:
> {{{
>   File "/Users/trevorkarn/Applications/sage/src/sage/combinat/composition.py", line 50, in <module>
>     class Composition(CombinatorialElement, Sequence):
> TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
> }}}

Ouch. Python used a metaclass for their (collections) ABCs `abc.ABCMeta`. Well, I guess that settles it; we have to register it.

> Should this be fixed at the `CombinatorialElement` level?

No, that is going to go away at some point.

> Or would it be better to just make `Composition` a subclass of `ClonableArray` to update it?

This won't solve the problem:

```
sage: from sage.structure.list_clone import ClonableArray
sage: ClonableArray.__class__
<class 'sage.misc.inherit_comparison.InheritComparisonMetaclass'>
```



---

Comment by tkarn created at 2022-09-15 17:54:40

Replying to [comment:21 Travis Scrimshaw]:
> Replying to [comment:19 Trevor Karn]:
> > After subclassing:
> > {{{
> >   File "/Users/trevorkarn/Applications/sage/src/sage/combinat/composition.py", line 50, in <module>
> >     class Composition(CombinatorialElement, Sequence):
> > TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
> > }}}
> 
> Ouch. Python used a metaclass for their (collections) ABCs `abc.ABCMeta`. Well, I guess that settles it; we have to register it.

Got it - then I think this is ready for review. I tried to inclued the doctests which were relevant to this conversation, but please let me know if I need more.

> > Or would it be better to just make `Composition` a subclass of `ClonableArray` to update it?
> 
> This won't solve the problem:
> {{{
> sage: from sage.structure.list_clone import ClonableArray
> sage: ClonableArray.__class__
> <class 'sage.misc.inherit_comparison.InheritComparisonMetaclass'>
> }}}
Huh. Should `ClonableArray` be a `Sequence`?


---

Comment by tscrim created at 2022-09-16 00:01:51

Replying to [comment:22 Trevor Karn]:
> Replying to [comment:21 Travis Scrimshaw]:
> > Replying to [comment:19 Trevor Karn]:
> > > Or would it be better to just make `Composition` a subclass of `ClonableArray` to update it?
> > 
> > This won't solve the problem:
> > {{{
> > sage: from sage.structure.list_clone import ClonableArray
> > sage: ClonableArray.__class__
> > <class 'sage.misc.inherit_comparison.InheritComparisonMetaclass'>
> > }}}
> Huh. Should `ClonableArray` be a `Sequence`?

This is saying it also has a metaclass.


---

Comment by tkarn created at 2022-09-16 18:37:33

Changing status from needs_review to needs_work.


---

Comment by git created at 2022-09-17 14:07:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tkarn created at 2022-09-17 14:07:40

Changing status from needs_work to needs_review.


---

Comment by tkarn created at 2022-09-17 14:07:40

Documentation is updated.


---

Comment by tscrim created at 2022-09-18 00:06:49

Thanks. I am happy with this (modulo the one change below). Matthias?

Sphinx treats the backtick as normal text when between alpha(numeric?) characters:

```diff
     Typically, instances of ``collections.abc.Sequence`` have a ``.count`` method.
-    This is *not* the case for ``Composition``s::
+    This is *not* the case for a ``Composition``::
```



---

Comment by git created at 2022-09-18 01:48:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2022-09-18 05:32:33

I think in comment:17, I concluded that all mix-in methods must be provided. Too tired this evening to re-read the Python reference to confirm it


---

Comment by tkarn created at 2022-09-19 19:07:33

Replying to [comment:29 Matthias Köppe]:
> I think in comment:17, I concluded that all mix-in methods must be provided. Too tired this evening to re-read the Python reference to confirm it

I understand [this python discussion post](https://discuss.python.org/t/mapping-abc-and-friends-are-the-mixin-methods-required-to-satisfy-the-interface/9499/2) to mean that mix-in methods are *not* required.

On the other hand it is easy enough to implement `.count()` where `.count(n)` returns the number of parts of size `n`. So I'll do that later today.


---

Comment by git created at 2022-09-19 22:37:16

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tkarn created at 2022-09-19 22:38:33

Replying to [comment:29 Matthias Köppe]:
> I think in comment:17, I concluded that all mix-in methods must be provided. Too tired this evening to re-read the Python reference to confirm it

Ok. I think `Sequence` things should be good to go.


---

Comment by tscrim created at 2022-09-20 05:57:01

Replying to [comment:29 Matthias Köppe]:
> I think in comment:17, I concluded that all mix-in methods must be provided. Too tired this evening to re-read the Python reference to confirm it

This is in point (2) of the main Python ABC doc in comment:1.


---

Comment by tscrim created at 2022-09-20 05:59:40

That takes care of all of the mixin methods. So I am good with this. Anything objections to a positive review Matthias?


---

Comment by mkoeppe created at 2022-09-22 03:22:11

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2022-09-22 03:22:11

LGTM, thanks.


---

Comment by vbraun created at 2022-09-25 16:34:05

Resolution: fixed
