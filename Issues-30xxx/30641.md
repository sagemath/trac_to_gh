# Issue 30641: equality of graphs is 60 times slower than equality of their list of edges

archive/issues_030404.json:
```json
{
    "body": "On sage 9.1\n\n```\nsage: G = Graph(loops=False, multiedges=False)\nsage: G.add_edges([(i, (i+85)%100) for i in range(100)])\nsage: G.add_edges([(i, (i+37)%100) for i in range(100)])\nsage: G.add_edges([(i, (i+85)%100) for i in range(100)])\nsage: H = G.copy()\nsage: %timeit G == H\n196 \u00b5s \u00b1 708 ns per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\nsage: E = list(G.edges())\nsage: F = list(H.edges())\nsage: %timeit E == F\n3.3 \u00b5s \u00b1 5.33 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n```\nUsing immutable graphs is better by a factor 2 (and hence \"only\" 30x slower than list comparisons)\n\n```\nsage: E = [(i, (i+85)%100) for i in range(100)] + \\\n....:     [(i, (i+37)%100) for i in range(100)] + \\\n....:     [(i, (i+85)%100) for i in range(100)]\nsage: G = Graph(E, loops=False, multiedges=False, immutable=True)\nsage: H = G.copy()\nsage: %timeit G == H\n111 \u00b5s \u00b1 2.01 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n```\n\n**CC:**  @kliem @dimpase @dcoudert\n\n**Keywords:** thursdaysbdx\n\n**Status:** new\n\n**Dependencies:** #30645, #30665, #30776\n\nIssue created by migration from https://trac.sagemath.org/ticket/30641\n\n",
    "created_at": "2020-09-23T08:58:23Z",
    "labels": [
        "component: graph theory",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "equality of graphs is 60 times slower than equality of their list of edges",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/30641",
    "user": "https://github.com/videlec"
}
```
On sage 9.1

```
sage: G = Graph(loops=False, multiedges=False)
sage: G.add_edges([(i, (i+85)%100) for i in range(100)])
sage: G.add_edges([(i, (i+37)%100) for i in range(100)])
sage: G.add_edges([(i, (i+85)%100) for i in range(100)])
sage: H = G.copy()
sage: %timeit G == H
196 µs ± 708 ns per loop (mean ± std. dev. of 7 runs, 1000 loops each)
sage: E = list(G.edges())
sage: F = list(H.edges())
sage: %timeit E == F
3.3 µs ± 5.33 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
```
Using immutable graphs is better by a factor 2 (and hence "only" 30x slower than list comparisons)

```
sage: E = [(i, (i+85)%100) for i in range(100)] + \
....:     [(i, (i+37)%100) for i in range(100)] + \
....:     [(i, (i+85)%100) for i in range(100)]
sage: G = Graph(E, loops=False, multiedges=False, immutable=True)
sage: H = G.copy()
sage: %timeit G == H
111 µs ± 2.01 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
```

**CC:**  @kliem @dimpase @dcoudert

**Keywords:** thursdaysbdx

**Status:** new

**Dependencies:** #30645, #30665, #30776

Issue created by migration from https://trac.sagemath.org/ticket/30641





---

archive/issue_comments_578527.json:
```json
{
    "body": "**Changing keywords** from \"\" to \"thursdaysbdx\".",
    "created_at": "2020-09-23T09:01:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578527",
    "user": "https://github.com/videlec"
}
```

**Changing keywords** from "" to "thursdaysbdx".



---

archive/issue_comments_578528.json:
```json
{
    "body": "<a id='comment:2'></a>\nSo far, `G.edges()` returns a sorted list of edges. So the test `E == F` is simply a lexicographic comparison of lists, omitting the time to extract and sort the list of edges. The reporting time comparison is therefore not completely fair.\n\nFurthermore, since the switch to Python3, we can no longer rely on sorted list of edges (vertices and edge labels may be of different types, leading to an error when trying to sort the list). One objective is to deprecate this behavior.\n\nI think that the only way to speed up the test `G == H`, is to speed up the test `other.has_edge(...)`.",
    "created_at": "2020-09-23T09:15:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578528",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:2'></a>
So far, `G.edges()` returns a sorted list of edges. So the test `E == F` is simply a lexicographic comparison of lists, omitting the time to extract and sort the list of edges. The reporting time comparison is therefore not completely fair.

Furthermore, since the switch to Python3, we can no longer rely on sorted list of edges (vertices and edge labels may be of different types, leading to an error when trying to sort the list). One objective is to deprecate this behavior.

I think that the only way to speed up the test `G == H`, is to speed up the test `other.has_edge(...)`.



---

archive/issue_comments_578529.json:
```json
{
    "body": "<a id='comment:3'></a>\nThe reason why I created this ticket is that I have code which creates a big list of graphs and where I want to remove duplicates. Currently, the program spends more than 50% of its time in graph equality which is ridiculous.",
    "created_at": "2020-09-23T09:25:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578529",
    "user": "https://github.com/videlec"
}
```

<a id='comment:3'></a>
The reason why I created this ticket is that I have code which creates a big list of graphs and where I want to remove duplicates. Currently, the program spends more than 50% of its time in graph equality which is ridiculous.



---

archive/issue_comments_578530.json:
```json
{
    "body": "<a id='comment:4'></a>\nI agree. I recently made a #30510 to speed up method `subgraph` which was ridiculously slow. It's better now.\n\nHere, I don't know how to speed up the method without going deep into the backends...",
    "created_at": "2020-09-23T09:43:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578530",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:4'></a>
I agree. I recently made a #30510 to speed up method `subgraph` which was ridiculously slow. It's better now.

Here, I don't know how to speed up the method without going deep into the backends...



---

archive/issue_comments_578531.json:
```json
{
    "body": "<a id='comment:5'></a>\nI am fine with \"going deep into the backends\". My graphs have vertices `{0, 1, ..., n-1}` and there is no multiple edge. The weights are integers (but I don't think this is taken into account in the backend). The comparison of such graphs should be *faster* than the generic Python list comparison.",
    "created_at": "2020-09-23T09:53:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578531",
    "user": "https://github.com/videlec"
}
```

<a id='comment:5'></a>
I am fine with "going deep into the backends". My graphs have vertices `{0, 1, ..., n-1}` and there is no multiple edge. The weights are integers (but I don't think this is taken into account in the backend). The comparison of such graphs should be *faster* than the generic Python list comparison.



---

archive/issue_comments_578532.json:
```json
{
    "body": "<a id='comment:6'></a>\nAlready the edge iterator is pretty slow. It takes 76 \u00b5s out 175 for me.",
    "created_at": "2020-09-23T10:13:08Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578532",
    "user": "https://github.com/kliem"
}
```

<a id='comment:6'></a>
Already the edge iterator is pretty slow. It takes 76 µs out 175 for me.



---

archive/issue_comments_578533.json:
```json
{
    "body": "<a id='comment:7'></a>\nfor your code, it could be better to work with immutable graphs.\n\n```\nsage: sage: E = [(i, (i+85)%100) for i in range(100)] + [(i, (i+37)%100) for i in range(100)] + [(i, (i+85)%100) for i in range(100)]     \nsage: G = Graph([range(100), E], format='vertices_and_edges', loops=False, multiedges=False, immutable=True)                                  \nsage: H = G.copy()                                                                                                                  \nsage: %timeit G == H                                                                                                                \n131 \u00b5s \u00b1 1.78 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\nsage: sage: G = Graph(loops=False, multiedges=False) \n....: sage: G.add_edges([(i, (i+85)%100) for i in range(100)]) \n....: sage: G.add_edges([(i, (i+37)%100) for i in range(100)]) \n....: sage: G.add_edges([(i, (i+85)%100) for i in range(100)]) \n....: sage: H = G.copy() \n....: sage: %timeit G == H \n....:                                                                                                                               \n241 \u00b5s \u00b1 8.24 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n```\n\nBut of course it would be better to improve the backends to get faster edge iterator, edge membership tests, equality test, etc.",
    "created_at": "2020-09-23T11:08:40Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578533",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:7'></a>
for your code, it could be better to work with immutable graphs.

```
sage: sage: E = [(i, (i+85)%100) for i in range(100)] + [(i, (i+37)%100) for i in range(100)] + [(i, (i+85)%100) for i in range(100)]     
sage: G = Graph([range(100), E], format='vertices_and_edges', loops=False, multiedges=False, immutable=True)                                  
sage: H = G.copy()                                                                                                                  
sage: %timeit G == H                                                                                                                
131 µs ± 1.78 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
sage: sage: G = Graph(loops=False, multiedges=False) 
....: sage: G.add_edges([(i, (i+85)%100) for i in range(100)]) 
....: sage: G.add_edges([(i, (i+37)%100) for i in range(100)]) 
....: sage: G.add_edges([(i, (i+85)%100) for i in range(100)]) 
....: sage: H = G.copy() 
....: sage: %timeit G == H 
....:                                                                                                                               
241 µs ± 8.24 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
```

But of course it would be better to improve the backends to get faster edge iterator, edge membership tests, equality test, etc.



---

archive/issue_comments_578534.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -13,3 +13,14 @@\n sage: %timeit E == F\n 3.3 \u00b5s \u00b1 5.33 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n ```\n+Using immutable graphs is better by a factor 2 (and hence \"only\" 30x slower than list comparisons)\n+\n+```\n+sage: E = [(i, (i+85)%100) for i in range(100)] + \\\n+....:     [(i, (i+37)%100) for i in range(100)] + \\\n+....:     [(i, (i+85)%100) for i in range(100)]\n+sage: G = Graph(E, loops=False, multiedges=False, immutable=True)\n+sage: H = G.copy()\n+sage: %timeit G == H\n+111 \u00b5s \u00b1 2.01 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n+```\n``````\n",
    "created_at": "2020-09-23T11:59:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578534",
    "user": "https://github.com/videlec"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -13,3 +13,14 @@
 sage: %timeit E == F
 3.3 µs ± 5.33 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
 ```
+Using immutable graphs is better by a factor 2 (and hence "only" 30x slower than list comparisons)
+
+```
+sage: E = [(i, (i+85)%100) for i in range(100)] + \
+....:     [(i, (i+37)%100) for i in range(100)] + \
+....:     [(i, (i+85)%100) for i in range(100)]
+sage: G = Graph(E, loops=False, multiedges=False, immutable=True)
+sage: H = G.copy()
+sage: %timeit G == H
+111 µs ± 2.01 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
+```
``````




---

archive/issue_comments_578535.json:
```json
{
    "body": "<a id='comment:9'></a>\nI wrote a quick dirty solution that counts compares two vertices at a time and counts how much the out arcs differ. This takes about 34 \u00b5s instead of 175 using `out_arc_unsafe`.",
    "created_at": "2020-09-23T12:55:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578535",
    "user": "https://github.com/kliem"
}
```

<a id='comment:9'></a>
I wrote a quick dirty solution that counts compares two vertices at a time and counts how much the out arcs differ. This takes about 34 µs instead of 175 using `out_arc_unsafe`.



---

archive/issue_comments_578536.json:
```json
{
    "body": "<a id='comment:10'></a>\nI will start with a tiny ticket that does some trivial optimizations for `has_edge`.",
    "created_at": "2020-09-23T13:47:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578536",
    "user": "https://github.com/kliem"
}
```

<a id='comment:10'></a>
I will start with a tiny ticket that does some trivial optimizations for `has_edge`.



---

archive/issue_comments_578537.json:
```json
{
    "body": "**Dependencies:** #30645, #30665",
    "created_at": "2020-09-26T07:56:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578537",
    "user": "https://github.com/kliem"
}
```

**Dependencies:** #30645, #30665



---

archive/issue_comments_578538.json:
```json
{
    "body": "<a id='comment:12'></a>\n#30645 and #30665 are a good start I would say.\n\nThings are set up in a way, that we can implement an optimized containment check in `CGraph`.",
    "created_at": "2020-09-26T15:13:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578538",
    "user": "https://github.com/kliem"
}
```

<a id='comment:12'></a>
#30645 and #30665 are a good start I would say.

Things are set up in a way, that we can implement an optimized containment check in `CGraph`.



---

archive/issue_comments_578539.json:
```json
{
    "body": "<a id='comment:13'></a>\nNice. Thanks Jonathan for your efforts!\n\nI also wonder if we could implement a comparison that would bypass the translation between \"vertex labels\" and \"integers in {0, ..., n-1}\". Namely have a comparison of the internal representations (assuming the backend is the same).",
    "created_at": "2020-09-26T15:22:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578539",
    "user": "https://github.com/videlec"
}
```

<a id='comment:13'></a>
Nice. Thanks Jonathan for your efforts!

I also wonder if we could implement a comparison that would bypass the translation between "vertex labels" and "integers in {0, ..., n-1}". Namely have a comparison of the internal representations (assuming the backend is the same).



---

archive/issue_comments_578540.json:
```json
{
    "body": "<a id='comment:14'></a>\nDoes it make sense ? Currently, we check that the graphs have same settings and sets of vertices and edges. However, the internal representation might differ a lot. Suppose one graph G is the result of many additions/deletions of vertices of edges. Typically, at some point it has 100000 vertices, but at the end of the sequence of operations, it remains only 2. Internal bitsets/data structures might be very large.  Now, if H is a copy of G, it has a very compact internal representation. The 2 graphs are equal, but have different internal representations.",
    "created_at": "2020-09-26T15:58:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578540",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:14'></a>
Does it make sense ? Currently, we check that the graphs have same settings and sets of vertices and edges. However, the internal representation might differ a lot. Suppose one graph G is the result of many additions/deletions of vertices of edges. Typically, at some point it has 100000 vertices, but at the end of the sequence of operations, it remains only 2. Internal bitsets/data structures might be very large.  Now, if H is a copy of G, it has a very compact internal representation. The 2 graphs are equal, but have different internal representations.



---

archive/issue_comments_578541.json:
```json
{
    "body": "<a id='comment:15'></a>\nThat is one use case. Here is another. I am considering all trivalent graphs up to isomorphism on `n` vertices. I want to construct the flip graph where I put an edge between the trivalent graph `G1` and trivalent graph `G2` if they differ by a Whitehad move\n\n```\n A          C                      A          C\n  \\        /                        \\        /\n   \\      /                          \\      /\n    u -- v          ----------->      u -- v\n   /      \\                          /      \\\n  /        \\                        /        \\\n B          D                      D          B\n```\nIn order to generate this flip graph, one has to be able to identify the graph after a move. Since canonical labels are computed we need to compare graphs on `{0, ..., n-1}` with no surprise... and these are a lot of comparisons!",
    "created_at": "2020-09-26T16:06:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578541",
    "user": "https://github.com/videlec"
}
```

<a id='comment:15'></a>
That is one use case. Here is another. I am considering all trivalent graphs up to isomorphism on `n` vertices. I want to construct the flip graph where I put an edge between the trivalent graph `G1` and trivalent graph `G2` if they differ by a Whitehad move

```
 A          C                      A          C
  \        /                        \        /
   \      /                          \      /
    u -- v          ----------->      u -- v
   /      \                          /      \
  /        \                        /        \
 B          D                      D          B
```
In order to generate this flip graph, one has to be able to identify the graph after a move. Since canonical labels are computed we need to compare graphs on `{0, ..., n-1}` with no surprise... and these are a lot of comparisons!



---

archive/issue_comments_578542.json:
```json
{
    "body": "<a id='comment:16'></a>\nI see, not easy to do it efficiently.",
    "created_at": "2020-09-26T17:09:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578542",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:16'></a>
I see, not easy to do it efficiently.



---

archive/issue_comments_578543.json:
```json
{
    "body": "<a id='comment:17'></a>\nTo check whether one `CGraph` is contained in another one can store a translation array at the beginning. If you can guarantee that the vertices match, you can of course skip this step.\n\nAfter this initial step is pretty much the same as #30665. Just that you check `has_arc_unsafe` of other instead of yield. Things are a bit more complicated for multiple edges.\n\nIf you can guarantee the vertices to match, things should be really fast for dense graphs, but of course only, if you are somewhat dense (e.g. if `n <= 64`). Here you can just immediately compare to vertices.",
    "created_at": "2020-09-26T20:10:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578543",
    "user": "https://github.com/kliem"
}
```

<a id='comment:17'></a>
To check whether one `CGraph` is contained in another one can store a translation array at the beginning. If you can guarantee that the vertices match, you can of course skip this step.

After this initial step is pretty much the same as #30665. Just that you check `has_arc_unsafe` of other instead of yield. Things are a bit more complicated for multiple edges.

If you can guarantee the vertices to match, things should be really fast for dense graphs, but of course only, if you are somewhat dense (e.g. if `n <= 64`). Here you can just immediately compare to vertices.



---

archive/issue_comments_578544.json:
```json
{
    "body": "<a id='comment:18'></a>\nThings are improving, I think.\n\nIMO what would still improve things here:\n- better heuristics for vertex translation to `int`,\n- factor out the backends to standard backends and backends with vertices in `range(n)` (we could still have active vertices or not, but all vertices need to be in `range(n)`, if you add a new vertex that is too large, you will get a memory problem, but that is your problem),\n- implement specialized versions of `is_subgraph` and `subgraph_given_vertices` for dense graphs over `range(n)` (we need a good name for this graph backend yet), this should be much faster than the current methods\n\nSo instead of just `CGraphBackend` we would have `CGraphBackend`, `CGraphVertices` and `CGraphRangeVertices` (not good names yet). `DenseGraphBackend` as we know it would have to inherit from `CGraphBackend` and `CGraphVertices` and `DenseGraphBackendRangeVertices` would have to inherit from `CGraphBackend` and `CGraphRangeVertices`. Likewise for sparse and static sparse.\n\nDoes this sound plausible?\n\nDoes anyone have good suggestions for a naming scheme?",
    "created_at": "2020-10-16T08:59:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578544",
    "user": "https://github.com/kliem"
}
```

<a id='comment:18'></a>
Things are improving, I think.

IMO what would still improve things here:
- better heuristics for vertex translation to `int`,
- factor out the backends to standard backends and backends with vertices in `range(n)` (we could still have active vertices or not, but all vertices need to be in `range(n)`, if you add a new vertex that is too large, you will get a memory problem, but that is your problem),
- implement specialized versions of `is_subgraph` and `subgraph_given_vertices` for dense graphs over `range(n)` (we need a good name for this graph backend yet), this should be much faster than the current methods

So instead of just `CGraphBackend` we would have `CGraphBackend`, `CGraphVertices` and `CGraphRangeVertices` (not good names yet). `DenseGraphBackend` as we know it would have to inherit from `CGraphBackend` and `CGraphVertices` and `DenseGraphBackendRangeVertices` would have to inherit from `CGraphBackend` and `CGraphRangeVertices`. Likewise for sparse and static sparse.

Does this sound plausible?

Does anyone have good suggestions for a naming scheme?



---

archive/issue_comments_578545.json:
```json
{
    "body": "**Changing dependencies** from \"#30645, #30665\" to \"#30645, #30665, #30776\".",
    "created_at": "2020-10-16T08:59:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578545",
    "user": "https://github.com/kliem"
}
```

**Changing dependencies** from "#30645, #30665" to "#30645, #30665, #30776".



---

archive/issue_comments_578546.json:
```json
{
    "body": "<a id='comment:19'></a>\nBtw, dense graphs should really use bitsets. I don't understand why it isn't. Eventually this might be sped up with intrinsics. E.g. an iterator over a bitset should be much faster with an improved leading zero count (`_lzcnt_u64`).",
    "created_at": "2020-10-16T09:03:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578546",
    "user": "https://github.com/kliem"
}
```

<a id='comment:19'></a>
Btw, dense graphs should really use bitsets. I don't understand why it isn't. Eventually this might be sped up with intrinsics. E.g. an iterator over a bitset should be much faster with an improved leading zero count (`_lzcnt_u64`).



---

archive/issue_comments_578547.json:
```json
{
    "body": "<a id='comment:20'></a>\nI don't know if it's better to use bitsets for dense graphs. In case, we can use `src/sage/data_structures/binary_matrix.<pxi|pxd>`.",
    "created_at": "2020-10-16T09:25:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578547",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:20'></a>
I don't know if it's better to use bitsets for dense graphs. In case, we can use `src/sage/data_structures/binary_matrix.<pxi|pxd>`.



---

archive/issue_comments_578548.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [gh-kliem](#comment%3A18):\n> So instead of just `CGraphBackend` we would have `CGraphBackend`, `CGraphVertices` and `CGraphRangeVertices` (not good names yet). `DenseGraphBackend` as we know it would have to inherit from `CGraphBackend` and `CGraphVertices` and `DenseGraphBackendRangeVertices` would have to inherit from `CGraphBackend` and `CGraphRangeVertices`. Likewise for sparse and static sparse.\n> \n> Does this sound plausible?\n> \n> Does anyone have good suggestions for a naming scheme?\n\n\nThis is how `DisjointSet` (union-find data structure) is implemented in Sage.\n\n```\ndef DisjointSet(arg):\ncdef class DisjointSet_class(SageObject):\ncdef class DisjointSet_of_integers(DisjointSet_class):\ncdef class DisjointSet_of_hashables(DisjointSet_class):\n```\n\nin the sense that `DisjointSet_of_integers` uses directly the internal representation and `DisjointSet_of_hashables` uses maps from integers in range(n) to the hashable objects and vice versa. See https://github.com/sagemath/sage/blob/develop/src/sage/sets/disjoint_set.pyx\n\nI don't know if the naming scheme `_of_integers` and `_of_hashables` I chosen at the time is good or not.",
    "created_at": "2020-10-16T18:29:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578548",
    "user": "https://github.com/seblabbe"
}
```

<a id='comment:21'></a>
Replying to [gh-kliem](#comment%3A18):
> So instead of just `CGraphBackend` we would have `CGraphBackend`, `CGraphVertices` and `CGraphRangeVertices` (not good names yet). `DenseGraphBackend` as we know it would have to inherit from `CGraphBackend` and `CGraphVertices` and `DenseGraphBackendRangeVertices` would have to inherit from `CGraphBackend` and `CGraphRangeVertices`. Likewise for sparse and static sparse.
> 
> Does this sound plausible?
> 
> Does anyone have good suggestions for a naming scheme?


This is how `DisjointSet` (union-find data structure) is implemented in Sage.

```
def DisjointSet(arg):
cdef class DisjointSet_class(SageObject):
cdef class DisjointSet_of_integers(DisjointSet_class):
cdef class DisjointSet_of_hashables(DisjointSet_class):
```

in the sense that `DisjointSet_of_integers` uses directly the internal representation and `DisjointSet_of_hashables` uses maps from integers in range(n) to the hashable objects and vice versa. See https://github.com/sagemath/sage/blob/develop/src/sage/sets/disjoint_set.pyx

I don't know if the naming scheme `_of_integers` and `_of_hashables` I chosen at the time is good or not.



---

archive/issue_events_090148.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-10-24T20:15:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90148"
}
```



---

archive/issue_comments_578549.json:
```json
{
    "body": "<a id='comment:23'></a>\nTiming with 9.3.beta5 on a macbook air. It seems we are much better now !\n\n```\nsage: G = Graph(loops=False, multiedges=False) \nsage: G.add_edges([(i, (i+85)%100) for i in range(100)]) \nsage: G.add_edges([(i, (i+37)%100) for i in range(100)]) \nsage: G.add_edges([(i, (i+85)%100) for i in range(100)]) \nsage: H = G.copy() \nsage: %timeit G == H \n43.1 \u00b5s \u00b1 821 ns per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\nsage:\nsage: E = list(G.edges()) \nsage: F = list(H.edges()) \nsage: %timeit E == F \n12.4 \u00b5s \u00b1 357 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\nsage:\nsage: E = [(i, (i+85)%100) for i in range(100)] + \\ \n....:     [(i, (i+37)%100) for i in range(100)] + \\ \n....:     [(i, (i+85)%100) for i in range(100)] \nsage: G = Graph(E, loops=False, multiedges=False, immutable=True) \nsage: H = G.copy() \nsage: %timeit G == H                                                                                                                                               \n31 \u00b5s \u00b1 1.63 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n```",
    "created_at": "2020-12-29T17:28:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578549",
    "user": "https://github.com/dcoudert"
}
```

<a id='comment:23'></a>
Timing with 9.3.beta5 on a macbook air. It seems we are much better now !

```
sage: G = Graph(loops=False, multiedges=False) 
sage: G.add_edges([(i, (i+85)%100) for i in range(100)]) 
sage: G.add_edges([(i, (i+37)%100) for i in range(100)]) 
sage: G.add_edges([(i, (i+85)%100) for i in range(100)]) 
sage: H = G.copy() 
sage: %timeit G == H 
43.1 µs ± 821 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)
sage:
sage: E = list(G.edges()) 
sage: F = list(H.edges()) 
sage: %timeit E == F 
12.4 µs ± 357 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)
sage:
sage: E = [(i, (i+85)%100) for i in range(100)] + \ 
....:     [(i, (i+37)%100) for i in range(100)] + \ 
....:     [(i, (i+85)%100) for i in range(100)] 
sage: G = Graph(E, loops=False, multiedges=False, immutable=True) 
sage: H = G.copy() 
sage: %timeit G == H                                                                                                                                               
31 µs ± 1.63 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)
```



---

archive/issue_events_090149.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90149"
}
```



---

archive/issue_events_090150.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90150"
}
```



---

archive/issue_comments_578550.json:
```json
{
    "body": "<a id='comment:24'></a>\nSetting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30641#issuecomment-578550",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:24'></a>
Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_090151.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T02:58:13Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90151"
}
```



---

archive/issue_events_090152.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T02:58:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90152"
}
```



---

archive/issue_events_090153.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:41:23Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90153"
}
```



---

archive/issue_events_090154.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-18T19:41:23Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90154"
}
```



---

archive/issue_events_090155.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-02T04:32:35Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90155"
}
```



---

archive/issue_events_090156.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-04-02T04:32:35Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90156"
}
```



---

archive/issue_events_090157.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T05:25:02Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90157"
}
```



---

archive/issue_events_090158.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T05:25:02Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30641",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30641#event-90158"
}
```
