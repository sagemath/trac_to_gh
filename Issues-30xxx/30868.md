# Issue 30868: sage fails to start on Fedora 32 after the recent update to Python 3.8

archive/issues_030631.json:
```json
{
    "assignees": [],
    "body": "The crash report is attached. The installation is from the latest Fedora 32 package (sage 9.0).\n\nReviewer: **Samuel Leli\u00e8vre**\n\nComponent: **build**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/30868_\n\n",
    "closed_at": "2021-06-24T20:15:37Z",
    "created_at": "2020-11-07T04:13:29Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/bug",
        "https://github.com/sagemath/sage/labels/c%3A%20build",
        "https://github.com/sagemath/sage/labels/invalid"
    ],
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "sage fails to start on Fedora 32 after the recent update to Python 3.8",
    "type": "issue",
    "updated_at": "2021-06-24T20:15:37Z",
    "url": "https://github.com/sagemath/sage/issues/30868",
    "user": "https://github.com/AndrewLyasoff"
}
```
The crash report is attached. The installation is from the latest Fedora 32 package (sage 9.0).

Reviewer: **Samuel LeliÃ¨vre**

Component: **build**

_Issue created by migration from https://trac.sagemath.org/ticket/30868_





---

archive/issue_events_422615.json:
```json
{
    "actor": "https://github.com/AndrewLyasoff",
    "created_at": "2020-11-07T04:13:29Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422615"
}
```



---

archive/issue_events_422616.json:
```json
{
    "actor": "https://github.com/AndrewLyasoff",
    "created_at": "2020-11-07T04:13:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422616"
}
```



---

archive/issue_events_422617.json:
```json
{
    "actor": "https://github.com/AndrewLyasoff",
    "created_at": "2020-11-07T04:13:29Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422617"
}
```



---

archive/issue_comments_494233.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,1146 +1 @@\n-The installation is from the latest Fedora package (sage 9.0) and the crash report is below:\n-\n-***************************************************************************\n-\n-IPython post-mortem report.txt\n-\n-{'commit_hash': '033ab93c7',\n- 'commit_source': 'installation',\n- 'default_encoding': 'utf-8',\n- 'ipython_path': '/usr/lib64/sagemath/site-packages/IPython',\n- 'ipython_version': '5.8.0',\n- 'os_name': 'posix',\n- 'platform': 'Linux-5.8.17-200.fc32.x86_64-x86_64-with-glibc2.2.5',\n- 'sys_executable': '/usr/bin/python3',\n- 'sys_platform': 'linux',\n- 'sys_version': '3.8.6 (default, Sep 25 2020, 00:00:00) \\n'\n-                '[GCC 10.2.1 20200723 (Red Hat 10.2.1-1)]'}\n-\n-***************************************************************************\n-\n-\n-\n-***************************************************************************\n-\n-Crash traceback:\n-\n----\n-\n----\n-SystemError                                  Python 3.8.6: /usr/bin/python3\n-                                                   Fri Nov  6 18:53:51 2020\n-A problem occurred executing Python code.  Here is the sequence of function\n-calls leading up to the error, with the most recent (innermost) call last.\n-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyFieldElement.__complex__ (build/cythonized/sage/rings/real_lazy.c:9871)()\n-    820         try:\n---> 821             return self.eval(complex)\n-        global self.eval = undefined\n-        global complex = undefined\n-    822         except Exception:\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyAlgebraic.eval (build/cythonized/sage/rings/real_lazy.c:17914)()\n-   1645             if self._prec < 53:\n--> 1646                 self.eval(self.parent().interval_field(64)) # up the prec\n-        global self.eval = undefined\n-        global self.parent.interval_field = undefined\n-   1647         elif R.is_exact() or self._prec < R.prec():\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyAlgebraic.eval (build/cythonized/sage/rings/real_lazy.c:18065)()\n-   1671                 from sage.rings.qqbar import AA, QQbar\n--> 1672                 roots = self._poly.roots(ring = AA if isinstance(self._parent, RealLazyField_class) else QQbar)\n-        global roots = undefined\n-        global self._poly.roots = undefined\n-        global ring = undefined\n-        global AA = undefined\n-        global isinstance = undefined\n-        global self._parent = undefined\n-        global RealLazyField_class = <class 'sage.rings.real_lazy.RealLazyField_class'>\n-        global QQbar = undefined\n-   1673                 best_root = roots[0][0]\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.roots (build/cythonized/sage/rings/polynomial/polynomial_element.c:62120)()\n-   7798                 elif is_AlgebraicField(L):\n--> 7799                     rts = complex_roots(self, retval='algebraic')\n-        global rts = undefined\n-        global complex_roots = undefined\n-        global self = undefined\n-        global retval = undefined\n-   7800                 else:\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/complex_roots.py in complex_roots(p=x^2 + 1, skip_squarefree=False, retval='algebraic', min_prec=0)\n-    257             cfac = CCX(factor)\n---> 258             rts = cfac.roots(multiplicities=False)\n-        rts = undefined\n-        cfac.roots = <built-in method roots of PolynomialRing_field_with_category.element_class object at 0x7f5066326940>\n-        global multiplicities = undefined\n-    259             # Make sure the number of roots we found is the degree. If\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.roots (build/cythonized/sage/rings/polynomial/polynomial_element.c:59629)()\n-   7709             if output_complex:\n--> 7710                 rts = sort_complex_numbers_for_display([L(root) for root in ext_rts])\n-        global rts = undefined\n-        global sort_complex_numbers_for_display = <function sort_complex_numbers_for_display at 0x7f523b27d820>\n-        global L = undefined\n-        global root = undefined\n-        global ext_rts = undefined\n-   7711             else:\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/complex_field.py in __call__(self=Complex Field with 53 bits of precision, x=0.E-19 - 1.00000000000000*I, im=None)\n-    386             x = x, im\n---> 387         return Parent.__call__(self, x)\n-        global Parent.__call__ = <slot wrapper '__call__' of 'sage.structure.parent.Parent' objects>\n-        self = Complex Field with 53 bits of precision\n-        x = 0.E-19 - 1.00000000000000*I\n-    388 \n-\n-/usr/lib64/python3.8/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9218)()\n-    899             if no_extra_args:\n---> 900                 return mor._call_(x)\n-        global mor._call_ = undefined\n-        global x = undefined\n-    901             else:\n-\n-/usr/lib64/python3.8/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4556)()\n-    160                 print(type(C._element_constructor), C._element_constructor)\n---> 161             raise\n-    162 \n-\n-/usr/lib64/python3.8/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4448)()\n-    155         try:\n---> 156             return C._element_constructor(x)\n-        global C._element_constructor = undefined\n-        global x = undefined\n-    157         except Exception:\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/complex_field.py in _element_constructor_(self=Complex Field with 53 bits of precision, x=0.E-19 - 1.00000000000000*I)\n-    421             try:\n---> 422                 return self(x.sage())\n-        self = Complex Field with 53 bits of precision\n-        x.sage = <bound method Gen.sage of 0.E-19 - 1.00000000000000*I>\n-    423             except (AttributeError, TypeError):\n-\n-cypari2/gen.pyx in cypari2.gen.Gen.sage()\n-\n-/usr/lib64/python3.8/site-packages/sage/libs/pari/convert_sage.pyx in sage.libs.pari.convert_sage.gen_to_sage (build/cythonized/sage/libs/pari/convert_sage.c:4350)()\n-     31 \n----> 32 cpdef gen_to_sage(Gen z, locals=None):\n-        global cpdef = undefined\n-        global gen_to_sage = <built-in function gen_to_sage>\n-        global Gen = undefined\n-        global z = undefined\n-        global locals = undefined\n-     33     \"\"\"\n-\n-/usr/lib64/python3.8/site-packages/sage/libs/pari/convert_sage.pyx in sage.libs.pari.convert_sage.gen_to_sage (build/cythonized/sage/libs/pari/convert_sage.c:3140)()\n-    246     elif t == t_COMPLEX:\n---> 247         real = z.real()\n-        global real = undefined\n-        global z.real = undefined\n-    248         imag = z.imag()\n-\n-cypari2/auto_gen.pxi in cypari2.gen.Gen_base.real()\n-\n-cypari2/stack.pyx in cypari2.stack.new_gen()\n-\n-cypari2/stack.pyx in cypari2.stack.new_gen_noclear()\n-\n-SystemError: new_gen() argument not on PARI stack, not on PARI heap and not a universal constant\n-\n-During handling of the above exception, another exception occurred:\n-\n----\n-SystemError                                  Python 3.8.6: /usr/bin/python3\n-                                                   Fri Nov  6 18:53:51 2020\n-A problem occurred executing Python code.  Here is the sequence of function\n-calls leading up to the error, with the most recent (innermost) call last.\n-/usr/lib64/sagemath/local/bin/sage-ipython in <module>()\n-      1 #!/usr/bin/python3\n-      2 # -*- coding: utf-8 -*-\n-      3 \"\"\"\n-      4 Sage IPython startup script.\n-      5 \"\"\"\n-      6 \n-      7 # Display startup banner. Do this before anything else to give the user\n-      8 # early feedback that Sage is starting.\n-      9 from sage.misc.banner import banner\n-     10 banner()\n-     11 \n-     12 from sage.repl.interpreter import SageTerminalApp\n-     13 \n-     14 app = SageTerminalApp.instance()\n----> 15 app.initialize()\n-        global app.initialize = <bound method TerminalIPythonApp.initialize of <sage.repl.interpreter.SageTerminalApp object at 0x7f5244f33ee0>>\n-     16 app.start()\n-\n-</usr/lib/python3.8/site-packages/decorator.py:decorator-gen-110> in initialize(self=<sage.repl.interpreter.SageTerminalApp object>, argv=None)\n-\n-/usr/lib/python3.8/site-packages/traitlets/config/application.py in catch_config_error(method=<function TerminalIPythonApp.initialize>, app=<sage.repl.interpreter.SageTerminalApp object>, *args=(None,), **kwargs={})\n-     72     TRAITLETS_APPLICATION_RAISE_CONFIG_FILE_ERROR = False\n-     73 else:\n-     74     raise ValueError(\"Unsupported value for environment variable: 'TRAITLETS_APPLICATION_RAISE_CONFIG_FILE_ERROR' is set to '%s' which is none of  {'0', '1', 'false', 'true', ''}.\"% _envvar )\n-     75 \n-     76 \n-     77 `@`decorator\n-     78 def catch_config_error(method, app, *args, **kwargs):\n-     79     \"\"\"Method decorator for catching invalid config (Trait/ArgumentErrors) during init.\n-     80 \n-     81     On a TraitError (generally caused by bad config), this will print the trait's\n-     82     message, and exit the app.\n-     83 \n-     84     For use on init methods, to prevent invoking excepthook on invalid input.\n-     85     \"\"\"\n-     86     try:\n----> 87         return method(app, *args, **kwargs)\n-        method = <function TerminalIPythonApp.initialize at 0x7f5244a609d0>\n-        app = <sage.repl.interpreter.SageTerminalApp object at 0x7f5244f33ee0>\n-        args = (None,)\n-        kwargs = {}\n-     88     except (TraitError, ArgumentError) as e:\n-     89         app.print_help()\n-     90         app.log.fatal(\"Bad config encountered during initialization:\")\n-     91         app.log.fatal(str(e))\n-     92         app.log.debug(\"Config at the time: %s\", app.config)\n-     93         app.exit(1)\n-     94 \n-     95 \n-     96 class ApplicationError(Exception):\n-     97     pass\n-     98 \n-     99 \n-    100 class LevelFormatter(logging.Formatter):\n-    101     \"\"\"Formatter with additional `highlevel` record\n-    102 \n-\n-/usr/lib64/sagemath/site-packages/IPython/terminal/ipapp.py in initialize(self=<sage.repl.interpreter.SageTerminalApp object>, argv=None)\n-    301 \n-    302         return super(TerminalIPythonApp, self).parse_command_line(argv)\n-    303     \n-    304     `@`catch_config_error\n-    305     def initialize(self, argv=None):\n-    306         \"\"\"Do actions after construct, but before starting the app.\"\"\"\n-    307         super(TerminalIPythonApp, self).initialize(argv)\n-    308         if self.subapp is not None:\n-    309             # don't bother initializing further, starting subapp\n-    310             return\n-    311         # print self.extra_args\n-    312         if self.extra_args and not self.something_to_run:\n-    313             self.file_to_run = self.extra_args[0]\n-    314         self.init_path()\n-    315         # create the shell\n---> 316         self.init_shell()\n-        self.init_shell = <bound method SageTerminalApp.init_shell of <sage.repl.interpreter.SageTerminalApp object at 0x7f5244f33ee0>>\n-    317         # and draw the banner\n-    318         self.init_banner()\n-    319         # Now a variety of things that happen after the banner is printed.\n-    320         self.init_gui_pylab()\n-    321         self.init_extensions()\n-    322         self.init_code()\n-    323 \n-    324     def init_shell(self):\n-    325         \"\"\"initialize the InteractiveShell instance\"\"\"\n-    326         # Create an InteractiveShell instance.\n-    327         # shell.display_banner should always be False for the terminal\n-    328         # based app, because we call shell.show_banner() by hand below\n-    329         # so the banner shows *before* all extension loading stuff.\n-    330         self.shell = self.interactive_shell_class.instance(parent=self,\n-    331                         profile_dir=self.profile_dir,\n-\n-/usr/lib64/python3.8/site-packages/sage/repl/interpreter.py in init_shell(self=<sage.repl.interpreter.SageTerminalApp object>)\n-    772         self.shell.has_sage_extensions = SAGE_EXTENSION in self.extensions\n-    773 \n-    774         # Load the %lprun extension if available\n-    775         try:\n-    776             import line_profiler\n-    777         except ImportError:\n-    778             pass\n-    779         else:\n-    780             self.extensions.append('line_profiler')\n-    781 \n-    782         if self.shell.has_sage_extensions:\n-    783             self.extensions.remove(SAGE_EXTENSION)\n-    784 \n-    785             # load sage extension here to get a crash if\n-    786             # something is wrong with the sage library\n---> 787             self.shell.extension_manager.load_extension(SAGE_EXTENSION)\n-        self.shell.extension_manager.load_extension = <bound method ExtensionManager.load_extension of <IPython.core.extensions.ExtensionManager object at 0x7f5241d5eee0>>\n-        global SAGE_EXTENSION = 'sage'\n-    788 \n-    789 \n-\n-/usr/lib64/sagemath/site-packages/IPython/core/extensions.py in load_extension(self=<IPython.core.extensions.ExtensionManager object>, module_str='sage')\n-     70 \n-     71         Returns the string \"already loaded\" if the extension is already loaded,\n-     72         \"no load function\" if the module doesn't have a load_ipython_extension\n-     73         function, or None if it succeeded.\n-     74         \"\"\"\n-     75         if module_str in self.loaded:\n-     76             return \"already loaded\"\n-     77         \n-     78         from IPython.utils.syspathcontext import prepended_to_syspath\n-     79         \n-     80         with self.shell.builtin_trap:\n-     81             if module_str not in sys.modules:\n-     82                 with prepended_to_syspath(self.ipython_extension_dir):\n-     83                     __import__(module_str)\n-     84             mod = sys.modules[module_str]\n----> 85             if self._call_load_ipython_extension(mod):\n-        self._call_load_ipython_extension = <bound method ExtensionManager._call_load_ipython_extension of <IPython.core.extensions.ExtensionManager object at 0x7f5241d5eee0>>\n-        mod = <module 'sage' from '/usr/lib64/python3.8/site-packages/sage/__init__.py'>\n-     86                 self.loaded.add(module_str)\n-     87             else:\n-     88                 return \"no load function\"\n-     89 \n-     90     def unload_extension(self, module_str):\n-     91         \"\"\"Unload an IPython extension by its module name.\n-     92 \n-     93         This function looks up the extension's name in ``sys.modules`` and\n-     94         simply calls ``mod.unload_ipython_extension(self)``.\n-     95         \n-     96         Returns the string \"no unload function\" if the extension doesn't define\n-     97         a function to unload itself, \"not loaded\" if the extension isn't loaded,\n-     98         otherwise None.\n-     99         \"\"\"\n-    100         if module_str not in self.loaded:\n-\n-/usr/lib64/sagemath/site-packages/IPython/core/extensions.py in _call_load_ipython_extension(self=<IPython.core.extensions.ExtensionManager object>, mod=<module 'sage' from '/usr/lib64/python3.8/site-packages/sage/__init__.py'>)\n-    117         \"\"\"\n-    118         from IPython.utils.syspathcontext import prepended_to_syspath\n-    119 \n-    120         if (module_str in self.loaded) and (module_str in sys.modules):\n-    121             self.unload_extension(module_str)\n-    122             mod = sys.modules[module_str]\n-    123             with prepended_to_syspath(self.ipython_extension_dir):\n-    124                 reload(mod)\n-    125             if self._call_load_ipython_extension(mod):\n-    126                 self.loaded.add(module_str)\n-    127         else:\n-    128             self.load_extension(module_str)\n-    129 \n-    130     def _call_load_ipython_extension(self, mod):\n-    131         if hasattr(mod, 'load_ipython_extension'):\n---> 132             mod.load_ipython_extension(self.shell)\n-        mod.load_ipython_extension = <function load_ipython_extension at 0x7f5244f4a5e0>\n-        self.shell = <sage.repl.interpreter.SageTerminalInteractiveShell object at 0x7f5244a76970>\n-    133             return True\n-    134 \n-    135     def _call_unload_ipython_extension(self, mod):\n-    136         if hasattr(mod, 'unload_ipython_extension'):\n-    137             mod.unload_ipython_extension(self.shell)\n-    138             return True\n-    139 \n-    140     def install_extension(self, url, filename=None):\n-    141         \"\"\"Download and install an IPython extension. \n-    142 \n-    143         If filename is given, the file will be so named (inside the extension\n-    144         directory). Otherwise, the name from the URL will be used. The file must\n-    145         have a .py or .zip extension; otherwise, a ValueError will be raised.\n-    146 \n-    147         Returns the full path to the installed file.\n-\n-/usr/lib64/python3.8/site-packages/sage/__init__.py in load_ipython_extension(*args=(<sage.repl.interpreter.SageTerminalInteractiveShell object>,))\n-      1 `__all__` = ['all']\n-      2 \n-      3 # Set sage.__version__ to the current version number. This is analogous\n-      4 # to many other Python packages.\n-      5 from sage.version import version as `__version__`\n-      6 \n-      7 # Make sure that the correct zlib library is loaded. This is needed\n-      8 # to prevent the system zlib to be loaded instead of the Sage one.\n-      9 # See #23122\n-     10 import zlib\n-     11 \n-     12 # IPython calls this when starting up\n-     13 def load_ipython_extension(*args):\n-     14     import sage.repl.ipython_extension\n----> 15     sage.repl.ipython_extension.load_ipython_extension(*args)\n-        sage.repl.ipython_extension.load_ipython_extension = <function load_ipython_extension at 0x7f5241b550d0>\n-        args = (<sage.repl.interpreter.SageTerminalInteractiveShell object at 0x7f5244a76970>,)\n-     16 \n-     17 \n-     18 # Monkey-patch inspect.isfunction() to support Cython functions.\n-     19 def isfunction(obj):\n-     20     \"\"\"\n-     21     Check whether something is a function.\n-     22 \n-     23     We assume that anything which has a genuine ``__code__``\n-     24     attribute (not using ``__getattr__`` overrides) is a function.\n-     25     This is meant to support Cython functions.\n-     26 \n-     27     EXAMPLES::\n-     28 \n-     29         sage: from inspect import isfunction\n-     30         sage: def f(): pass\n-     31         sage: isfunction(f)\n-\n-/usr/lib64/python3.8/site-packages/sage/repl/ipython_extension.py in wrapper(*args=(<sage.repl.interpreter.SageTerminalInteractiveShell object>,), **kwargs={})\n-    549         ....:     if work:\n-    550         ....:         return 'foo worked'\n-    551         ....:     raise RuntimeError(\"foo didn't work\")\n-    552         sage: foo(False)\n-    553         Traceback (most recent call last):\n-    554         ...\n-    555         RuntimeError: foo didn't work\n-    556         sage: foo(True)\n-    557         'foo worked'\n-    558         sage: foo(False)\n-    559         sage: foo(True)\n-    560     \"\"\"\n-    561     `@`wraps(func)\n-    562     def wrapper(*args, **kwargs):\n-    563         if not wrapper.has_run:\n---> 564             result = func(*args, **kwargs)\n-        result = undefined\n-        global func = undefined\n-        args = (<sage.repl.interpreter.SageTerminalInteractiveShell object at 0x7f5244a76970>,)\n-        kwargs = {}\n-    565             wrapper.has_run = True\n-    566             return result\n-    567     wrapper.has_run = False\n-    568     return wrapper\n-    569 \n-    570 \n-    571 `@`run_once\n-    572 def load_ipython_extension(ip):\n-    573     \"\"\"\n-    574     Load the extension in IPython.\n-    575     \"\"\"\n-    576     # this modifies ip\n-    577     SageCustomizations(shell=ip)\n-\n-/usr/lib64/python3.8/site-packages/sage/repl/ipython_extension.py in load_ipython_extension(ip=<sage.repl.interpreter.SageTerminalInteractiveShell object>)\n-    562     def wrapper(*args, **kwargs):\n-    563         if not wrapper.has_run:\n-    564             result = func(*args, **kwargs)\n-    565             wrapper.has_run = True\n-    566             return result\n-    567     wrapper.has_run = False\n-    568     return wrapper\n-    569 \n-    570 \n-    571 `@`run_once\n-    572 def load_ipython_extension(ip):\n-    573     \"\"\"\n-    574     Load the extension in IPython.\n-    575     \"\"\"\n-    576     # this modifies ip\n---> 577     SageCustomizations(shell=ip)\n-        global SageCustomizations = <class 'sage.repl.ipython_extension.SageCustomizations'>\n-        global shell = undefined\n-        ip = <sage.repl.interpreter.SageTerminalInteractiveShell object at 0x7f5244a76970>\n-\n-/usr/lib64/python3.8/site-packages/sage/repl/ipython_extension.py in __init__(self=<sage.repl.ipython_extension.SageCustomizations object>, shell=<sage.repl.interpreter.SageTerminalInteractiveShell object>)\n-    420     def __init__(self, shell=None):\n-    421         \"\"\"\n-    422         Initialize the Sage plugin.\n-    423         \"\"\"\n-    424         self.shell = shell\n-    425 \n-    426         self.auto_magics = SageMagics(shell)\n-    427         self.shell.register_magics(self.auto_magics)\n-    428 \n-    429         import sage.misc.edit_module as edit_module\n-    430         self.shell.set_hook('editor', edit_module.edit_devel)\n-    431 \n-    432         self.init_inspector()\n-    433         self.init_line_transforms()\n-    434 \n---> 435         import sage.all # until sage's import hell is fixed\n-        sage.all = undefined\n-    436 \n-    437         self.shell.verbose_quit = True\n-    438         self.set_quit_hook()\n-    439 \n-    440         self.register_interface_magics()\n-    441 \n-    442         if SAGE_IMPORTALL == 'yes':\n-    443             self.init_environment()\n-    444 \n-    445     def register_interface_magics(self):\n-    446         \"\"\"\n-    447         Register magics for each of the Sage interfaces\n-    448         \"\"\"\n-    449         from sage.repl.interface_magic import InterfaceMagic\n-    450         InterfaceMagic.register_all(self.shell)\n-\n-/usr/lib64/python3.8/site-packages/sage/all.py in <module>()\n-     93 from sage.misc.all       import *         # takes a while\n-     94 from sage.typeset.all    import *\n-     95 from sage.repl.all       import *\n-     96 \n-     97 from sage.misc.sh import sh\n-     98 \n-     99 from sage.libs.all       import *\n-    100 from sage.data_structures.all import *\n-    101 from sage.doctest.all    import *\n-    102 \n-    103 from sage.structure.all  import *\n-    104 from sage.rings.all      import *\n-    105 from sage.arith.all      import *\n-    106 from sage.matrix.all     import *\n-    107 \n---> 108 from sage.symbolic.all   import *\n-        global sage.symbolic.all = undefined\n-    109 from sage.modules.all    import *\n-    110 from sage.monoids.all    import *\n-    111 from sage.algebras.all   import *\n-    112 from sage.modular.all    import *\n-    113 from sage.sat.all        import *\n-    114 from sage.schemes.all    import *\n-    115 from sage.graphs.all     import *\n-    116 from sage.groups.all     import *\n-    117 from sage.arith.power    import generic_power as power\n-    118 from sage.databases.all  import *\n-    119 from sage.categories.all import *\n-    120 from sage.sets.all       import *\n-    121 from sage.probability.all import *\n-    122 from sage.interfaces.all import *\n-    123 \n-\n-/usr/lib64/python3.8/site-packages/sage/symbolic/all.py in <module>()\n-      1 from `__future__` import absolute_import\n-      2 \n-\n----\n-        global sage.libs.pynac.pynac = undefined\n-        global I = undefined\n-      4 i = I\n-      5 \n-      6 from .ring import SR\n-      7 from .constants import (pi, e, NaN, golden_ratio, log2, euler_gamma, catalan,\n-      8                        khinchin, twinprime, mertens, glaisher)\n-      9 from .expression import Expression, solve_diophantine, hold\n-     10 from .callable import CallableSymbolicExpressionRing\n-     11 \n-     12 from sage.symbolic.relation import solve, solve_mod, solve_ineq\n-     13 from sage.symbolic.assumptions import assume, forget, assumptions, assuming\n-     14 \n-     15 from .units import units\n-\n-/usr/lib64/python3.8/site-packages/sage/libs/pynac/pynac.pyx in init sage.libs.pynac.pynac (build/cythonized/sage/libs/pynac/pynac.cpp:31605)()\n-   2523     py_funcs.ex_to_pyExpression = &ex_to_pyExpression\n-   2524     py_funcs.subs_args_to_PyTuple = &subs_args_to_PyTuple\n-   2525     py_funcs.py_print_function = &py_print_function\n-   2526     py_funcs.py_latex_function = &py_latex_function\n-   2527     py_funcs.py_get_ginac_serial = &py_get_ginac_serial\n-   2528     py_funcs.py_get_sfunction_from_serial = &py_get_sfunction_from_serial\n-   2529     py_funcs.py_get_serial_from_sfunction = &py_get_serial_from_sfunction\n-   2530     py_funcs.py_get_serial_for_new_sfunction = &py_get_serial_for_new_sfunction\n-   2531 \n-   2532     py_funcs.py_get_constant = &py_get_constant\n-   2533     py_funcs.py_print_fderivative =  &py_print_fderivative\n-   2534     py_funcs.py_latex_fderivative =  &py_latex_fderivative\n-   2535     py_funcs.paramset_to_PyTuple = &paramset_to_PyTuple\n-   2536 \n-   2537 init_function_table()\n--> 2538 init_pynac_I()\n-        global init_pynac_I = <built-in function init_pynac_I>\n-   2539 \n-   2540 set_ginac_fn_serial()\n-\n-/usr/lib64/python3.8/site-packages/sage/libs/pynac/pynac.pyx in sage.libs.pynac.pynac.init_pynac_I (build/cythonized/sage/libs/pynac/pynac.cpp:26828)()\n-   2425         <type 'sage.rings.number_field.number_field_element_quadratic.NumberFieldElement_quadratic'>\n-   2426 \n-   2427     Check that :trac:`10064` is fixed::\n-   2428 \n-   2429         sage: y = I*I*x / x # so y is the expression -1\n-   2430         sage: y.is_positive()\n-   2431         False\n-   2432         sage: z = -x / x\n-   2433         sage: z.is_positive()\n-   2434         False\n-   2435         sage: bool(z == y)\n-   2436         True\n-   2437     \"\"\"\n-   2438     global pynac_I, I\n-   2439     from sage.rings.number_field.number_field import QuadraticField\n--> 2440     K = QuadraticField(-1, 'I', embedding=CC.gen(), latex_name='i')\n-        global K = undefined\n-        global QuadraticField = undefined\n-        global embedding = undefined\n-        global CC.gen = <bound method ComplexField_class.gen of Complex Field with 53 bits of precision>\n-        global latex_name = undefined\n-   2441     pynac_I = K.gen()\n-   2442     ginac_pyinit_I(pynac_I)\n-   2443     I = new_Expression_from_GEx(ring.SR, g_I)\n-   2444 \n-   2445 \n-   2446 def init_function_table():\n-   2447     \"\"\"\n-   2448     Initializes the function pointer table in Pynac.  This must be\n-   2449     called before Pynac is used; otherwise, there will be segfaults.\n-   2450     \"\"\"\n-   2451 \n-   2452     py_funcs.py_gcd = &py_gcd\n-   2453     py_funcs.py_lcm = &py_lcm\n-   2454     py_funcs.py_real = &py_real\n-   2455     py_funcs.py_imag = &py_imag\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/number_field/number_field.py in QuadraticField(D=-1, name='I', check=True, embedding=1.00000000000000*I, latex_name='i', **args={})\n-    934         False\n-    935     \"\"\"\n-    936     D = QQ(D)\n-    937     if check:\n-    938         if D.is_square():\n-    939             raise ValueError(\"D must not be a perfect square.\")\n-    940     R = QQ['x']\n-    941     f = R([-D, 0, 1])\n-    942     if embedding is True:\n-    943         if D > 0:\n-    944             embedding = RLF(D).sqrt()\n-    945         else:\n-    946             embedding = CLF(D).sqrt()\n-    947     if latex_name == 'sqrt':\n-    948         latex_name = r'\\sqrt{%s}' % D\n---> 949     return NumberField(f, name, check=False, embedding=embedding, latex_name=latex_name, **args)\n-        global NumberField = <function NumberField at 0x7f5239490820>\n-        f = x^2 + 1\n-        name = 'I'\n-        check = True\n-        embedding = 1.00000000000000*I\n-        latex_name = 'i'\n-        args = {}\n-    950 \n-    951 def is_AbsoluteNumberField(x):\n-    952     \"\"\"\n-    953     Return True if x is an absolute number field.\n-    954 \n-    955     EXAMPLES::\n-    956 \n-    957         sage: from sage.rings.number_field.number_field import is_AbsoluteNumberField\n-    958         sage: is_AbsoluteNumberField(NumberField(x^2+1,'a'))\n-    959         True\n-    960         sage: is_AbsoluteNumberField(NumberField([x^3 + 17, x^2+1],'a'))\n-    961         False\n-    962 \n-    963     The rationals are a number field, but they're not of the absolute\n-    964     number field class.\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/number_field/number_field.py in NumberField(polynomial=x^2 + 1, name='I', check=False, names=None, embedding=1.00000000000000*I, latex_name='i', assume_disc_small=False, maximize_at_primes=None, structure=None, **kwds={})\n-    536           Defn: a |--> [0 1 0 0]\n-    537                        [0 0 1 0]\n-    538                        [0 0 0 1]\n-    539                        [2 0 0 0]\n-    540     \"\"\"\n-    541     if names is not None:\n-    542         name = names\n-    543     for key, val in kwds.items():\n-    544         if key not in ['implementation', 'prec']:\n-    545             raise TypeError(\"NumberField() got an unexpected keyword argument '%s'\"%key)\n-    546         if not (val is None or isinstance(val, list) and all(c is None for c in val)):\n-    547             raise NotImplementedError(\"Number field with prescribed %s is not implemented\"%key)\n-    548     if isinstance(polynomial, (list,tuple)):\n-    549         return NumberFieldTower(polynomial, names=name, check=check, embeddings=embedding, latex_names=latex_name, assume_disc_small=assume_disc_small, maximize_at_primes=maximize_at_primes, structures=structure)\n-    550 \n---> 551     return NumberField_version2(polynomial=polynomial, name=name, check=check, embedding=embedding, latex_name=latex_name, assume_disc_small=assume_disc_small, maximize_at_primes=maximize_at_primes, structure=structure)\n-        global NumberField_version2 = <sage.rings.number_field.number_field.NumberFieldFactory object at 0x7f5238f52bd0>\n-        polynomial = x^2 + 1\n-        name = 'I'\n-        check = False\n-        embedding = 1.00000000000000*I\n-        latex_name = 'i'\n-        assume_disc_small = False\n-        maximize_at_primes = None\n-        structure = None\n-    552 \n-    553 class NumberFieldFactory(UniqueFactory):\n-    554     r\"\"\"\n-    555     Factory for number fields.\n-    556 \n-    557     This should usually not be called directly, use :meth:`NumberField`\n-    558     instead.\n-    559 \n-    560     INPUT:\n-    561 \n-    562         - ``polynomial`` - a polynomial over `\\QQ` or a number field.\n-    563         - ``name`` - a string (default: ``'a'``), the name of the generator\n-    564         - ``check`` - a boolean (default: ``True``); do type checking and\n-    565           irreducibility checking.\n-    566         - ``embedding`` - ``None`` or an element, the images of the generator\n-\n-/usr/lib64/python3.8/site-packages/sage/structure/factory.pyx in sage.structure.factory.UniqueFactory.__call__ (build/cythonized/sage/structure/factory.c:2240)()\n-    354         It already created one, so don't re-create::\n-    355 \n-    356             sage: test_factory(1,2,3)\n-    357             <sage.structure.test_factory.A object at ...>\n-    358             sage: test_factory(1,2,3) is test_factory(1,2,3)\n-    359             True\n-    360 \n-    361         Of course, with a different key, a new object will be created::\n-    362 \n-    363             sage: test_factory(1,2,3) is test_factory(1,2,4)\n-    364             Making object (1, 2, 4)\n-    365             False\n-    366         \"\"\"\n-    367         key, kwds = self.create_key_and_extra_args(*args, **kwds)\n-    368         version = self.get_version(sage_version)\n---> 369         return self.get_object(version, key, kwds)\n-        global self.get_object = undefined\n-        global version = undefined\n-        global key = undefined\n-        global kwds = undefined\n-    370 \n-    371     cpdef get_object(self, version, key, extra_args):\n-    372         \"\"\"\n-    373         Returns the object corresponding to ``key``, creating it with\n-    374         ``extra_args`` if necessary (for example, it isn't in the cache\n-    375         or it is unpickling from an older version of Sage).\n-    376 \n-    377         EXAMPLES::\n-    378 \n-    379             sage: from sage.structure.test_factory import test_factory\n-    380             sage: a = test_factory.get_object(3.0, 'a', {}); a\n-    381             Making object a\n-    382             <sage.structure.test_factory.A object at ...>\n-    383             sage: test_factory.get_object(3.0, 'a', {}) is test_factory.get_object(3.0, 'a', {})\n-    384             True\n-\n-/usr/lib64/python3.8/site-packages/sage/structure/factory.pyx in sage.structure.factory.UniqueFactory.get_object (build/cythonized/sage/structure/factory.c:2444)()\n-    391 \n-    392         TESTS:\n-    393 \n-    394         Check that :trac:`16317` has been fixed, i.e., caching works for\n-    395         unhashable objects::\n-    396 \n-    397             sage: K.<u> = Qq(4)\n-    398             sage: test_factory.get_object(3.0, (K(1), 'c'), {})  is test_factory.get_object(3.0, (K(1), 'c'), {})\n-    399             Making object (1 + O(2^20), 'c')\n-    400             True\n-    401 \n-    402         \"\"\"\n-    403         cache_key = key\n-    404         try:\n-    405             try:\n---> 406                 return self._cache[version, cache_key]\n-        global self._cache = undefined\n-        global version = undefined\n-        global cache_key = undefined\n-    407             except TypeError: # key is unhashable\n-    408                 cache_key = _cache_key(cache_key)\n-    409                 return self._cache[version, cache_key]\n-    410         except KeyError:\n-    411             pass\n-    412         obj = self.create_object(version, key, **extra_args)\n-    413         self._cache[version, cache_key] = obj\n-    414         try:\n-    415             for key in self.other_keys(key, obj):\n-    416                 try:\n-    417                     self._cache[version, key] = obj\n-    418                 except TypeError: # key is unhashable\n-    419                     self._cache[version, _cache_key(key)] = obj\n-    420             obj._factory_data = self, version, key, extra_args\n-    421 \n-\n-/usr/lib64/python3.8/site-packages/sage/misc/weak_dict.pyx in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3623)()\n-    688 \n-    689             sage: D[10] = ZZ\n-    690             sage: D[int(10)]\n-    691             Integer Ring\n-    692 \n-    693         Check that :trac:`15956` has been fixed, i.e., a ``TypeError`` is\n-    694         raised for unhashable objects::\n-    695 \n-    696             sage: D = sage.misc.weak_dict.WeakValueDictionary()\n-    697             sage: D[matrix([])]\n-    698             Traceback (most recent call last):\n-    699             ...\n-    700             TypeError: mutable matrices are unhashable\n-    701 \n-    702         \"\"\"\n---> 703         cdef PyObject* wr = PyDict_GetItemWithError(self, k)\n-        global cdef = undefined\n-        global PyObject = undefined\n-        global wr = undefined\n-        global PyDict_GetItemWithError = undefined\n-        global self = undefined\n-        global k = undefined\n-    704         if wr == NULL:\n-    705             raise KeyError(k)\n-    706         out = PyWeakref_GetObject(wr)\n-    707         if out == Py_None:\n-    708             raise KeyError(k)\n-    709         return <object>out\n-    710 \n-    711     def __contains__(self, k):\n-    712         \"\"\"\n-    713         Containment in the set of keys.\n-    714 \n-    715         TESTS::\n-    716 \n-    717             sage: import sage.misc.weak_dict\n-    718             sage: class Vals(object): pass\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyFieldElement.__hash__ (build/cythonized/sage/rings/real_lazy.c:9119)()\n-    692         except TypeError:\n-    693             pass\n-    694         left, right = self.approx(), other.approx()\n-    695         return richcmp(left.endpoints(), right.endpoints(), op)\n-    696 \n-    697     def __hash__(self):\n-    698         \"\"\"\n-    699         Return the hash value of ``self``.\n-    700 \n-    701         EXAMPLES::\n-    702 \n-    703             sage: a = RLF(3)\n-    704             sage: hash(a)\n-    705             3\n-    706         \"\"\"\n---> 707         return hash(complex(self))\n-        global hash = undefined\n-        global complex = undefined\n-        global self = undefined\n-    708 \n-    709     cdef LazyFieldElement _new_wrapper(self, value):\n-    710         cdef LazyWrapper e = <LazyWrapper>LazyWrapper.__new__(LazyWrapper)\n-    711         e._parent = self._parent\n-    712         e._value = value\n-    713         return e\n-    714 \n-    715     cdef LazyFieldElement _new_binop(self, LazyFieldElement left, LazyFieldElement right, op):\n-    716         cdef LazyBinop e = <LazyBinop>LazyBinop.__new__(LazyBinop)\n-    717         e._parent = self._parent\n-    718         e._left = left\n-    719         e._right = right\n-    720         e._op = op\n-    721         return e\n-    722 \n-\n-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyFieldElement.__complex__ (build/cythonized/sage/rings/real_lazy.c:9949)()\n-    809     `_real_mpfi_` = `_complex_mpfi_` =_mpfr_ = `_complex_mpfr_field_` = `_generic_`\n-    810 \n-    811     def __complex__(self):\n-    812         \"\"\"\n-    813         Return ``self`` as a complex.\n-    814 \n-    815         EXAMPLES::\n-    816 \n-    817             sage: complex(CLF(-1)^(1/4))\n-    818             (0.707106781186547...+0.707106781186547...j)\n-    819         \"\"\"\n-    820         try:\n-    821             return self.eval(complex)\n-    822         except Exception:\n-    823             from .complex_field import ComplexField\n---> 824             return complex(self.eval(ComplexField(53)))\n-        global complex = undefined\n-        global self.eval = undefined\n-        global ComplexField = undefined\n-    825 \n-    826     cpdef eval(self, R):\n-    827         \"\"\"\n-    828         Abstract method for converting ``self`` into an element of ``R``.\n-    829 \n-    830         EXAMPLES::\n-    831 \n-    832             sage: a = RLF(12)\n-    833             sage: a.eval(ZZ)\n-    834             12\n-    835         \"\"\"\n-    836         raise NotImplementedError(\"Subclasses must override this method.\")\n-    837 \n-    838     cpdef int depth(self):\n-    839         \"\"\"\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyAlgebraic.eval (build/cythonized/sage/rings/real_lazy.c:18065)()\n-   1657 #                 else:\n-   1658 #                     z = (-b + R(self._quadratic_disc).sqrt()) / (2*a)\n-   1659 #                 if z.parent() is not R:\n-   1660 #                     z = R(z)\n-   1661 #                 self._root_approx = z\n-   1662 #                 from sage.rings.complex_interval_field import is_IntervalField\n-   1663 #                 if is_IntervalField(R):\n-   1664 #                     self._root_approx = (self._root_approx.upper() + self._root_approx.lower()) / 2\n-   1665 #                 self._prec = R.prec()\n-   1666 #                 return R(self._root_approx)\n-   1667             if self._root is None:\n-   1668                 # This could be done much more efficiently with Newton iteration,\n-   1669                 # but will require some care to make sure we get the right root, and\n-   1670                 # to the correct precision.\n-   1671                 from sage.rings.qqbar import AA, QQbar\n--> 1672                 roots = self._poly.roots(ring = AA if isinstance(self._parent, RealLazyField_class) else QQbar)\n-        global roots = undefined\n-        global self._poly.roots = undefined\n-        global ring = undefined\n-        global AA = undefined\n-        global isinstance = undefined\n-        global self._parent = undefined\n-        global RealLazyField_class = <class 'sage.rings.real_lazy.RealLazyField_class'>\n-        global QQbar = undefined\n-   1673                 best_root = roots[0][0]\n-   1674                 min_dist = abs(self._root_approx - best_root)\n-   1675                 for r, e in roots[1:]:\n-   1676                     dist = abs(self._root_approx - r)\n-   1677                     if dist < min_dist:\n-   1678                         best_root = r\n-   1679                         min_dist = dist\n-   1680                 self._root = best_root\n-   1681         if self._root is not None:\n-   1682             return R(self._root)\n-   1683 \n-   1684     def __float__(self):\n-   1685         \"\"\"\n-   1686         TESTS::\n-   1687 \n-\n-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.roots (build/cythonized/sage/rings/polynomial/polynomial_element.c:62120)()\n-   7784 \n-   7785                 if multiplicities:\n-   7786                     return rts\n-   7787                 else:\n-   7788                     return [rt for (rt, mult) in rts]\n-   7789 \n-   7790             if (is_IntegerRing(K) or is_RationalField(K)\n-   7791                 or is_AlgebraicField_common(K) or input_gaussian) and \\\n-   7792                 (is_ComplexIntervalField(L) or is_AlgebraicField_common(L)):\n-   7793 \n-   7794                 from sage.rings.polynomial.complex_roots import complex_roots\n-   7795 \n-   7796                 if is_ComplexIntervalField(L):\n-   7797                     rts = complex_roots(self, min_prec=L.prec())\n-   7798                 elif is_AlgebraicField(L):\n--> 7799                     rts = complex_roots(self, retval='algebraic')\n-        global rts = undefined\n-        global complex_roots = undefined\n-        global self = undefined\n-        global retval = undefined\n-   7800                 else:\n-   7801                     rts = complex_roots(self, retval='algebraic_real')\n-   7802 \n-   7803                 if multiplicities:\n-   7804                     return rts\n-   7805                 else:\n-   7806                     return [rt for (rt, mult) in rts]\n-   7807 \n-   7808             if output_fp and output_complex and not input_gaussian:\n-   7809                 # If we want the complex roots, and the input is not\n-   7810                 # floating point, we convert to a real polynomial\n-   7811                 # (except when the input coefficients are Gaussian rationals).\n-   7812                 if is_ComplexDoubleField(L):\n-   7813                     real_field = RDF\n-   7814                 else:\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/complex_roots.py in complex_roots(p=x^2 + 1, skip_squarefree=False, retval='algebraic', min_prec=0)\n-    243     if skip_squarefree:\n-    244         factors = [(p, 1)]\n-    245     else:\n-    246         factors = p.squarefree_decomposition()\n-    247 \n-    248     prec = 53\n-    249     while True:\n-    250         CC = ComplexField(prec)\n-    251         CCX = CC['x']\n-    252 \n-    253         all_rts = []\n-    254         ok = True\n-    255 \n-    256         for (factor, exp) in factors:\n-    257             cfac = CCX(factor)\n---> 258             rts = cfac.roots(multiplicities=False)\n-        rts = undefined\n-        cfac.roots = <built-in method roots of PolynomialRing_field_with_category.element_class object at 0x7f5066326dc0>\n-        global multiplicities = undefined\n-    259             # Make sure the number of roots we found is the degree. If\n-    260             # we don't find that many roots, it's because the\n-    261             # precision isn't big enough and though the (possibly\n-    262             # exact) polynomial \"factor\" is squarefree, it is not\n-    263             # squarefree as an element of CCX.\n-    264             if len(rts) < factor.degree():\n-    265                 ok = False\n-    266                 break\n-    267             irts = interval_roots(factor, rts, max(prec, min_prec))\n-    268             if irts is None:\n-    269                 ok = False\n-    270                 break\n-    271             if retval != 'interval':\n-    272                 factor = QQbar.common_polynomial(factor)\n-    273             for irt in irts:\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.roots (build/cythonized/sage/rings/polynomial/polynomial_element.c:59509)()\n-   7692                     ext_rts1 = numpy.roots(numpy_array)\n-   7693                     rts = []\n-   7694                     for rt in ext_rts1:\n-   7695                         rts.append(CDF(rt))\n-   7696                     rts.sort()\n-   7697                     ext_rts = rts\n-   7698                 except (ValueError, LinAlgError):\n-   7699                     if algorithm == 'either':\n-   7700                         algorithm = 'pari'\n-   7701                     else:\n-   7702                         raise\n-   7703 \n-   7704             if algorithm == 'pari':\n-   7705                 if not input_arbprec:\n-   7706                     self = self.change_ring(CC if input_complex else RR)\n--> 7707                 ext_rts = self.__pari__().polroots(precision=L.prec())\n-        global ext_rts = undefined\n-        global self.__pari__.polroots = undefined\n-        global precision = undefined\n-        global L.prec = undefined\n-   7708 \n-   7709             if output_complex:\n-   7710                 rts = sort_complex_numbers_for_display([L(root) for root in ext_rts])\n-   7711             else:\n-   7712                 rts = sorted([L(root.real()) for root in ext_rts if root.imag() == 0])\n-   7713 \n-   7714             rts_mult = []\n-   7715             j = 0\n-   7716             while j < len(rts):\n-   7717                 rt = rts[j]\n-   7718                 mult = rts.count(rt)\n-   7719                 rts_mult.append((rt, mult))\n-   7720                 j += mult\n-   7721 \n-   7722             if multiplicities:\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.__pari__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:49147)()\n-   6079             sage: R.<x> = S['x']\n-   6080             sage: pari(x^2 + 9*x)\n-   6081             x^2 + 2*x\n-   6082             sage: pari(a*x + 9*b*x^3)\n-   6083             2*b*x^3 + a*x\n-   6084 \n-   6085         ::\n-   6086 \n-   6087             sage: S.<a> = Integers(8)['a']\n-   6088             sage: R.<x> = S['x']\n-   6089             sage: pari(x^2 + 2*x)\n-   6090             Mod(1, 8)*x^2 + Mod(2, 8)*x\n-   6091             sage: pari(a*x + 10*x^3)\n-   6092             Mod(2, 8)*x^3 + Mod(1, 8)*a*x\n-   6093         \"\"\"\n--> 6094         return self._pari_with_name(self._parent.variable_name())\n-        global self._pari_with_name = undefined\n-        global self._parent.variable_name = undefined\n-   6095 \n-   6096     def _pari_or_constant(self, name=None):\n-   6097         r\"\"\"\n-   6098         Convert ``self`` to PARI.  This behaves identical to :meth:`__pari__`\n-   6099         or :meth:`_pari_with_name` except for constant polynomials:\n-   6100         then the constant is returned instead of a constant polynomial.\n-   6101 \n-   6102         INPUT:\n-   6103 \n-   6104         - ``name`` -- (default: None) Variable name.  If not given, use\n-   6105           ``self.parent().variable_name()``.  This argument is irrelevant\n-   6106           for constant polynomials.\n-   6107 \n-   6108         EXAMPLES::\n-   6109 \n-\n-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial._pari_with_name (build/cythonized/sage/rings/polynomial/polynomial_element.c:49540)()\n-   6132     def _pari_with_name(self, name='x'):\n-   6133         r\"\"\"\n-   6134         Return polynomial as a PARI object with topmost variable\n-   6135         ``name``.  By default, use 'x' for the variable name.\n-   6136 \n-   6137         For internal use only.\n-   6138 \n-   6139         EXAMPLES::\n-   6140 \n-   6141             sage: R.<a> = PolynomialRing(ZZ)\n-   6142             sage: (2*a^2 + a)._pari_with_name()\n-   6143             2*x^2 + x\n-   6144             sage: (2*a^2 + a)._pari_with_name('y')\n-   6145             2*y^2 + y\n-   6146         \"\"\"\n--> 6147         vals = [x.__pari__() for x in self.list()]\n-        global vals = undefined\n-        global x.__pari__ = undefined\n-        global x = undefined\n-        global self.list = undefined\n-   6148         return pari(vals).Polrev(name)\n-   6149 \n-   6150     def _pari_init_(self):\n-   6151         return repr(self.__pari__())\n-   6152 \n-   6153     def _magma_init_(self, magma):\n-   6154         \"\"\"\n-   6155         Return a string that evaluates in Magma to this polynomial.\n-   6156 \n-   6157         EXAMPLES::\n-   6158 \n-   6159             sage: magma = Magma()  # new session\n-   6160             sage: R.<y> = ZZ[]\n-   6161             sage: f = y^3 - 17*y + 5\n-   6162             sage: f._magma_init_(magma)        # optional - magma\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/complex_number.pyx in sage.rings.complex_number.ComplexNumber.__pari__ (build/cythonized/sage/rings/complex_number.c:7099)()\n-    575             <type 'cypari2.gen.Gen'>\n-    576             sage: a.__pari__()\n-    577             2.00000000000000 + 1.00000000000000*I\n-    578             sage: type(a.__pari__())\n-    579             <type 'cypari2.gen.Gen'>\n-    580             sage: a = CC(pi)\n-    581             sage: pari(a)\n-    582             3.14159265358979\n-    583             sage: pari(a).type()\n-    584             't_REAL'\n-    585             sage: a = CC(-2).sqrt()\n-    586             sage: pari(a)\n-    587             1.41421356237310*I\n-    588         \"\"\"\n-    589         if self.is_real():\n---> 590             return self.real().__pari__()\n-        global self.real.__pari__ = undefined\n-    591         return sage.libs.pari.all.pari.complex(self.real() or 0, self.imag())\n-    592 \n-    593     def __mpc__(self):\n-    594         \"\"\"\n-    595         Convert Sage ``ComplexNumber`` to gmpy2 ``mpc``.\n-    596 \n-    597         EXAMPLES::\n-    598 \n-    599             sage: c = ComplexNumber(2,1)\n-    600             sage: c.__mpc__()\n-    601             mpc('2.0+1.0j')\n-    602             sage: from gmpy2 import mpc\n-    603             sage: mpc(c)\n-    604             mpc('2.0+1.0j')\n-    605             sage: CF = ComplexField(134)\n-\n-/usr/lib64/python3.8/site-packages/sage/rings/real_mpfr.pyx in sage.rings.real_mpfr.RealNumber.__pari__ (build/cythonized/sage/rings/real_mpfr.c:22497)()\n-   3246         sig_on()\n-   3247         if mpfr_zero_p(self.value):\n-   3248             pari_float = real_0_bit(-rounded_prec)\n-   3249         else:\n-   3250             # Now we can extract the mantissa, and it will be normalized\n-   3251             # (the most significant bit of the most significant word will be 1).\n-   3252             mpz_init(mantissa)\n-   3253             exponent = mpfr_get_z_exp(mantissa, self.value)\n-   3254 \n-   3255             # Create a PARI REAL\n-   3256             pari_float = cgetr(2 + rounded_prec / wordsize)\n-   3257             pari_float[1] = evalexpo(exponent + rounded_prec - 1) + evalsigne(mpfr_sgn(self.value))\n-   3258             mpz_export(&pari_float[2], NULL, 1, wordsize // 8, 0, 0, mantissa)\n-   3259             mpz_clear(mantissa)\n-   3260 \n--> 3261         return new_gen(pari_float)\n-        global new_gen = undefined\n-        global pari_float = undefined\n-   3262 \n-   3263     def _mpmath_(self, prec=None, rounding=None):\n-   3264         \"\"\"\n-   3265         Return an mpmath version of this :class:`RealNumber`.\n-   3266 \n-   3267         .. NOTE::\n-   3268 \n-   3269            Currently the rounding mode is ignored.\n-   3270 \n-   3271         EXAMPLES::\n-   3272 \n-   3273             sage: RR(-1.5)._mpmath_()\n-   3274             mpf('-1.5')\n-   3275         \"\"\"\n-   3276         if prec is not None:\n-\n-cypari2/stack.pyx in cypari2.stack.new_gen()\n-\n-cypari2/stack.pyx in cypari2.stack.new_gen_noclear()\n-\n-SystemError: new_gen() argument not on PARI stack, not on PARI heap and not a universal constant\n-\n-***************************************************************************\n-\n-History of session input:\n-*** Last line of input (may not be in above history):\n-\n+The crash report is attached. The installation is from the latest Fedora 32 package (sage 9.0).\n``````\n",
    "created_at": "2020-11-07T04:17:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30868#issuecomment-494233",
    "user": "https://github.com/AndrewLyasoff"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,1146 +1 @@
-The installation is from the latest Fedora package (sage 9.0) and the crash report is below:
-
-***************************************************************************
-
-IPython post-mortem report.txt
-
-{'commit_hash': '033ab93c7',
- 'commit_source': 'installation',
- 'default_encoding': 'utf-8',
- 'ipython_path': '/usr/lib64/sagemath/site-packages/IPython',
- 'ipython_version': '5.8.0',
- 'os_name': 'posix',
- 'platform': 'Linux-5.8.17-200.fc32.x86_64-x86_64-with-glibc2.2.5',
- 'sys_executable': '/usr/bin/python3',
- 'sys_platform': 'linux',
- 'sys_version': '3.8.6 (default, Sep 25 2020, 00:00:00) \n'
-                '[GCC 10.2.1 20200723 (Red Hat 10.2.1-1)]'}
-
-***************************************************************************
-
-
-
-***************************************************************************
-
-Crash traceback:
-
----
-
----
-SystemError                                  Python 3.8.6: /usr/bin/python3
-                                                   Fri Nov  6 18:53:51 2020
-A problem occurred executing Python code.  Here is the sequence of function
-calls leading up to the error, with the most recent (innermost) call last.
-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyFieldElement.__complex__ (build/cythonized/sage/rings/real_lazy.c:9871)()
-    820         try:
---> 821             return self.eval(complex)
-        global self.eval = undefined
-        global complex = undefined
-    822         except Exception:
-
-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyAlgebraic.eval (build/cythonized/sage/rings/real_lazy.c:17914)()
-   1645             if self._prec < 53:
--> 1646                 self.eval(self.parent().interval_field(64)) # up the prec
-        global self.eval = undefined
-        global self.parent.interval_field = undefined
-   1647         elif R.is_exact() or self._prec < R.prec():
-
-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyAlgebraic.eval (build/cythonized/sage/rings/real_lazy.c:18065)()
-   1671                 from sage.rings.qqbar import AA, QQbar
--> 1672                 roots = self._poly.roots(ring = AA if isinstance(self._parent, RealLazyField_class) else QQbar)
-        global roots = undefined
-        global self._poly.roots = undefined
-        global ring = undefined
-        global AA = undefined
-        global isinstance = undefined
-        global self._parent = undefined
-        global RealLazyField_class = <class 'sage.rings.real_lazy.RealLazyField_class'>
-        global QQbar = undefined
-   1673                 best_root = roots[0][0]
-
-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.roots (build/cythonized/sage/rings/polynomial/polynomial_element.c:62120)()
-   7798                 elif is_AlgebraicField(L):
--> 7799                     rts = complex_roots(self, retval='algebraic')
-        global rts = undefined
-        global complex_roots = undefined
-        global self = undefined
-        global retval = undefined
-   7800                 else:
-
-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/complex_roots.py in complex_roots(p=x^2 + 1, skip_squarefree=False, retval='algebraic', min_prec=0)
-    257             cfac = CCX(factor)
---> 258             rts = cfac.roots(multiplicities=False)
-        rts = undefined
-        cfac.roots = <built-in method roots of PolynomialRing_field_with_category.element_class object at 0x7f5066326940>
-        global multiplicities = undefined
-    259             # Make sure the number of roots we found is the degree. If
-
-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.roots (build/cythonized/sage/rings/polynomial/polynomial_element.c:59629)()
-   7709             if output_complex:
--> 7710                 rts = sort_complex_numbers_for_display([L(root) for root in ext_rts])
-        global rts = undefined
-        global sort_complex_numbers_for_display = <function sort_complex_numbers_for_display at 0x7f523b27d820>
-        global L = undefined
-        global root = undefined
-        global ext_rts = undefined
-   7711             else:
-
-/usr/lib64/python3.8/site-packages/sage/rings/complex_field.py in __call__(self=Complex Field with 53 bits of precision, x=0.E-19 - 1.00000000000000*I, im=None)
-    386             x = x, im
---> 387         return Parent.__call__(self, x)
-        global Parent.__call__ = <slot wrapper '__call__' of 'sage.structure.parent.Parent' objects>
-        self = Complex Field with 53 bits of precision
-        x = 0.E-19 - 1.00000000000000*I
-    388 
-
-/usr/lib64/python3.8/site-packages/sage/structure/parent.pyx in sage.structure.parent.Parent.__call__ (build/cythonized/sage/structure/parent.c:9218)()
-    899             if no_extra_args:
---> 900                 return mor._call_(x)
-        global mor._call_ = undefined
-        global x = undefined
-    901             else:
-
-/usr/lib64/python3.8/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4556)()
-    160                 print(type(C._element_constructor), C._element_constructor)
---> 161             raise
-    162 
-
-/usr/lib64/python3.8/site-packages/sage/structure/coerce_maps.pyx in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (build/cythonized/sage/structure/coerce_maps.c:4448)()
-    155         try:
---> 156             return C._element_constructor(x)
-        global C._element_constructor = undefined
-        global x = undefined
-    157         except Exception:
-
-/usr/lib64/python3.8/site-packages/sage/rings/complex_field.py in _element_constructor_(self=Complex Field with 53 bits of precision, x=0.E-19 - 1.00000000000000*I)
-    421             try:
---> 422                 return self(x.sage())
-        self = Complex Field with 53 bits of precision
-        x.sage = <bound method Gen.sage of 0.E-19 - 1.00000000000000*I>
-    423             except (AttributeError, TypeError):
-
-cypari2/gen.pyx in cypari2.gen.Gen.sage()
-
-/usr/lib64/python3.8/site-packages/sage/libs/pari/convert_sage.pyx in sage.libs.pari.convert_sage.gen_to_sage (build/cythonized/sage/libs/pari/convert_sage.c:4350)()
-     31 
----> 32 cpdef gen_to_sage(Gen z, locals=None):
-        global cpdef = undefined
-        global gen_to_sage = <built-in function gen_to_sage>
-        global Gen = undefined
-        global z = undefined
-        global locals = undefined
-     33     """
-
-/usr/lib64/python3.8/site-packages/sage/libs/pari/convert_sage.pyx in sage.libs.pari.convert_sage.gen_to_sage (build/cythonized/sage/libs/pari/convert_sage.c:3140)()
-    246     elif t == t_COMPLEX:
---> 247         real = z.real()
-        global real = undefined
-        global z.real = undefined
-    248         imag = z.imag()
-
-cypari2/auto_gen.pxi in cypari2.gen.Gen_base.real()
-
-cypari2/stack.pyx in cypari2.stack.new_gen()
-
-cypari2/stack.pyx in cypari2.stack.new_gen_noclear()
-
-SystemError: new_gen() argument not on PARI stack, not on PARI heap and not a universal constant
-
-During handling of the above exception, another exception occurred:
-
----
-SystemError                                  Python 3.8.6: /usr/bin/python3
-                                                   Fri Nov  6 18:53:51 2020
-A problem occurred executing Python code.  Here is the sequence of function
-calls leading up to the error, with the most recent (innermost) call last.
-/usr/lib64/sagemath/local/bin/sage-ipython in <module>()
-      1 #!/usr/bin/python3
-      2 # -*- coding: utf-8 -*-
-      3 """
-      4 Sage IPython startup script.
-      5 """
-      6 
-      7 # Display startup banner. Do this before anything else to give the user
-      8 # early feedback that Sage is starting.
-      9 from sage.misc.banner import banner
-     10 banner()
-     11 
-     12 from sage.repl.interpreter import SageTerminalApp
-     13 
-     14 app = SageTerminalApp.instance()
----> 15 app.initialize()
-        global app.initialize = <bound method TerminalIPythonApp.initialize of <sage.repl.interpreter.SageTerminalApp object at 0x7f5244f33ee0>>
-     16 app.start()
-
-</usr/lib/python3.8/site-packages/decorator.py:decorator-gen-110> in initialize(self=<sage.repl.interpreter.SageTerminalApp object>, argv=None)
-
-/usr/lib/python3.8/site-packages/traitlets/config/application.py in catch_config_error(method=<function TerminalIPythonApp.initialize>, app=<sage.repl.interpreter.SageTerminalApp object>, *args=(None,), **kwargs={})
-     72     TRAITLETS_APPLICATION_RAISE_CONFIG_FILE_ERROR = False
-     73 else:
-     74     raise ValueError("Unsupported value for environment variable: 'TRAITLETS_APPLICATION_RAISE_CONFIG_FILE_ERROR' is set to '%s' which is none of  {'0', '1', 'false', 'true', ''}."% _envvar )
-     75 
-     76 
-     77 `@`decorator
-     78 def catch_config_error(method, app, *args, **kwargs):
-     79     """Method decorator for catching invalid config (Trait/ArgumentErrors) during init.
-     80 
-     81     On a TraitError (generally caused by bad config), this will print the trait's
-     82     message, and exit the app.
-     83 
-     84     For use on init methods, to prevent invoking excepthook on invalid input.
-     85     """
-     86     try:
----> 87         return method(app, *args, **kwargs)
-        method = <function TerminalIPythonApp.initialize at 0x7f5244a609d0>
-        app = <sage.repl.interpreter.SageTerminalApp object at 0x7f5244f33ee0>
-        args = (None,)
-        kwargs = {}
-     88     except (TraitError, ArgumentError) as e:
-     89         app.print_help()
-     90         app.log.fatal("Bad config encountered during initialization:")
-     91         app.log.fatal(str(e))
-     92         app.log.debug("Config at the time: %s", app.config)
-     93         app.exit(1)
-     94 
-     95 
-     96 class ApplicationError(Exception):
-     97     pass
-     98 
-     99 
-    100 class LevelFormatter(logging.Formatter):
-    101     """Formatter with additional `highlevel` record
-    102 
-
-/usr/lib64/sagemath/site-packages/IPython/terminal/ipapp.py in initialize(self=<sage.repl.interpreter.SageTerminalApp object>, argv=None)
-    301 
-    302         return super(TerminalIPythonApp, self).parse_command_line(argv)
-    303     
-    304     `@`catch_config_error
-    305     def initialize(self, argv=None):
-    306         """Do actions after construct, but before starting the app."""
-    307         super(TerminalIPythonApp, self).initialize(argv)
-    308         if self.subapp is not None:
-    309             # don't bother initializing further, starting subapp
-    310             return
-    311         # print self.extra_args
-    312         if self.extra_args and not self.something_to_run:
-    313             self.file_to_run = self.extra_args[0]
-    314         self.init_path()
-    315         # create the shell
---> 316         self.init_shell()
-        self.init_shell = <bound method SageTerminalApp.init_shell of <sage.repl.interpreter.SageTerminalApp object at 0x7f5244f33ee0>>
-    317         # and draw the banner
-    318         self.init_banner()
-    319         # Now a variety of things that happen after the banner is printed.
-    320         self.init_gui_pylab()
-    321         self.init_extensions()
-    322         self.init_code()
-    323 
-    324     def init_shell(self):
-    325         """initialize the InteractiveShell instance"""
-    326         # Create an InteractiveShell instance.
-    327         # shell.display_banner should always be False for the terminal
-    328         # based app, because we call shell.show_banner() by hand below
-    329         # so the banner shows *before* all extension loading stuff.
-    330         self.shell = self.interactive_shell_class.instance(parent=self,
-    331                         profile_dir=self.profile_dir,
-
-/usr/lib64/python3.8/site-packages/sage/repl/interpreter.py in init_shell(self=<sage.repl.interpreter.SageTerminalApp object>)
-    772         self.shell.has_sage_extensions = SAGE_EXTENSION in self.extensions
-    773 
-    774         # Load the %lprun extension if available
-    775         try:
-    776             import line_profiler
-    777         except ImportError:
-    778             pass
-    779         else:
-    780             self.extensions.append('line_profiler')
-    781 
-    782         if self.shell.has_sage_extensions:
-    783             self.extensions.remove(SAGE_EXTENSION)
-    784 
-    785             # load sage extension here to get a crash if
-    786             # something is wrong with the sage library
---> 787             self.shell.extension_manager.load_extension(SAGE_EXTENSION)
-        self.shell.extension_manager.load_extension = <bound method ExtensionManager.load_extension of <IPython.core.extensions.ExtensionManager object at 0x7f5241d5eee0>>
-        global SAGE_EXTENSION = 'sage'
-    788 
-    789 
-
-/usr/lib64/sagemath/site-packages/IPython/core/extensions.py in load_extension(self=<IPython.core.extensions.ExtensionManager object>, module_str='sage')
-     70 
-     71         Returns the string "already loaded" if the extension is already loaded,
-     72         "no load function" if the module doesn't have a load_ipython_extension
-     73         function, or None if it succeeded.
-     74         """
-     75         if module_str in self.loaded:
-     76             return "already loaded"
-     77         
-     78         from IPython.utils.syspathcontext import prepended_to_syspath
-     79         
-     80         with self.shell.builtin_trap:
-     81             if module_str not in sys.modules:
-     82                 with prepended_to_syspath(self.ipython_extension_dir):
-     83                     __import__(module_str)
-     84             mod = sys.modules[module_str]
----> 85             if self._call_load_ipython_extension(mod):
-        self._call_load_ipython_extension = <bound method ExtensionManager._call_load_ipython_extension of <IPython.core.extensions.ExtensionManager object at 0x7f5241d5eee0>>
-        mod = <module 'sage' from '/usr/lib64/python3.8/site-packages/sage/__init__.py'>
-     86                 self.loaded.add(module_str)
-     87             else:
-     88                 return "no load function"
-     89 
-     90     def unload_extension(self, module_str):
-     91         """Unload an IPython extension by its module name.
-     92 
-     93         This function looks up the extension's name in ``sys.modules`` and
-     94         simply calls ``mod.unload_ipython_extension(self)``.
-     95         
-     96         Returns the string "no unload function" if the extension doesn't define
-     97         a function to unload itself, "not loaded" if the extension isn't loaded,
-     98         otherwise None.
-     99         """
-    100         if module_str not in self.loaded:
-
-/usr/lib64/sagemath/site-packages/IPython/core/extensions.py in _call_load_ipython_extension(self=<IPython.core.extensions.ExtensionManager object>, mod=<module 'sage' from '/usr/lib64/python3.8/site-packages/sage/__init__.py'>)
-    117         """
-    118         from IPython.utils.syspathcontext import prepended_to_syspath
-    119 
-    120         if (module_str in self.loaded) and (module_str in sys.modules):
-    121             self.unload_extension(module_str)
-    122             mod = sys.modules[module_str]
-    123             with prepended_to_syspath(self.ipython_extension_dir):
-    124                 reload(mod)
-    125             if self._call_load_ipython_extension(mod):
-    126                 self.loaded.add(module_str)
-    127         else:
-    128             self.load_extension(module_str)
-    129 
-    130     def _call_load_ipython_extension(self, mod):
-    131         if hasattr(mod, 'load_ipython_extension'):
---> 132             mod.load_ipython_extension(self.shell)
-        mod.load_ipython_extension = <function load_ipython_extension at 0x7f5244f4a5e0>
-        self.shell = <sage.repl.interpreter.SageTerminalInteractiveShell object at 0x7f5244a76970>
-    133             return True
-    134 
-    135     def _call_unload_ipython_extension(self, mod):
-    136         if hasattr(mod, 'unload_ipython_extension'):
-    137             mod.unload_ipython_extension(self.shell)
-    138             return True
-    139 
-    140     def install_extension(self, url, filename=None):
-    141         """Download and install an IPython extension. 
-    142 
-    143         If filename is given, the file will be so named (inside the extension
-    144         directory). Otherwise, the name from the URL will be used. The file must
-    145         have a .py or .zip extension; otherwise, a ValueError will be raised.
-    146 
-    147         Returns the full path to the installed file.
-
-/usr/lib64/python3.8/site-packages/sage/__init__.py in load_ipython_extension(*args=(<sage.repl.interpreter.SageTerminalInteractiveShell object>,))
-      1 `__all__` = ['all']
-      2 
-      3 # Set sage.__version__ to the current version number. This is analogous
-      4 # to many other Python packages.
-      5 from sage.version import version as `__version__`
-      6 
-      7 # Make sure that the correct zlib library is loaded. This is needed
-      8 # to prevent the system zlib to be loaded instead of the Sage one.
-      9 # See #23122
-     10 import zlib
-     11 
-     12 # IPython calls this when starting up
-     13 def load_ipython_extension(*args):
-     14     import sage.repl.ipython_extension
----> 15     sage.repl.ipython_extension.load_ipython_extension(*args)
-        sage.repl.ipython_extension.load_ipython_extension = <function load_ipython_extension at 0x7f5241b550d0>
-        args = (<sage.repl.interpreter.SageTerminalInteractiveShell object at 0x7f5244a76970>,)
-     16 
-     17 
-     18 # Monkey-patch inspect.isfunction() to support Cython functions.
-     19 def isfunction(obj):
-     20     """
-     21     Check whether something is a function.
-     22 
-     23     We assume that anything which has a genuine ``__code__``
-     24     attribute (not using ``__getattr__`` overrides) is a function.
-     25     This is meant to support Cython functions.
-     26 
-     27     EXAMPLES::
-     28 
-     29         sage: from inspect import isfunction
-     30         sage: def f(): pass
-     31         sage: isfunction(f)
-
-/usr/lib64/python3.8/site-packages/sage/repl/ipython_extension.py in wrapper(*args=(<sage.repl.interpreter.SageTerminalInteractiveShell object>,), **kwargs={})
-    549         ....:     if work:
-    550         ....:         return 'foo worked'
-    551         ....:     raise RuntimeError("foo didn't work")
-    552         sage: foo(False)
-    553         Traceback (most recent call last):
-    554         ...
-    555         RuntimeError: foo didn't work
-    556         sage: foo(True)
-    557         'foo worked'
-    558         sage: foo(False)
-    559         sage: foo(True)
-    560     """
-    561     `@`wraps(func)
-    562     def wrapper(*args, **kwargs):
-    563         if not wrapper.has_run:
---> 564             result = func(*args, **kwargs)
-        result = undefined
-        global func = undefined
-        args = (<sage.repl.interpreter.SageTerminalInteractiveShell object at 0x7f5244a76970>,)
-        kwargs = {}
-    565             wrapper.has_run = True
-    566             return result
-    567     wrapper.has_run = False
-    568     return wrapper
-    569 
-    570 
-    571 `@`run_once
-    572 def load_ipython_extension(ip):
-    573     """
-    574     Load the extension in IPython.
-    575     """
-    576     # this modifies ip
-    577     SageCustomizations(shell=ip)
-
-/usr/lib64/python3.8/site-packages/sage/repl/ipython_extension.py in load_ipython_extension(ip=<sage.repl.interpreter.SageTerminalInteractiveShell object>)
-    562     def wrapper(*args, **kwargs):
-    563         if not wrapper.has_run:
-    564             result = func(*args, **kwargs)
-    565             wrapper.has_run = True
-    566             return result
-    567     wrapper.has_run = False
-    568     return wrapper
-    569 
-    570 
-    571 `@`run_once
-    572 def load_ipython_extension(ip):
-    573     """
-    574     Load the extension in IPython.
-    575     """
-    576     # this modifies ip
---> 577     SageCustomizations(shell=ip)
-        global SageCustomizations = <class 'sage.repl.ipython_extension.SageCustomizations'>
-        global shell = undefined
-        ip = <sage.repl.interpreter.SageTerminalInteractiveShell object at 0x7f5244a76970>
-
-/usr/lib64/python3.8/site-packages/sage/repl/ipython_extension.py in __init__(self=<sage.repl.ipython_extension.SageCustomizations object>, shell=<sage.repl.interpreter.SageTerminalInteractiveShell object>)
-    420     def __init__(self, shell=None):
-    421         """
-    422         Initialize the Sage plugin.
-    423         """
-    424         self.shell = shell
-    425 
-    426         self.auto_magics = SageMagics(shell)
-    427         self.shell.register_magics(self.auto_magics)
-    428 
-    429         import sage.misc.edit_module as edit_module
-    430         self.shell.set_hook('editor', edit_module.edit_devel)
-    431 
-    432         self.init_inspector()
-    433         self.init_line_transforms()
-    434 
---> 435         import sage.all # until sage's import hell is fixed
-        sage.all = undefined
-    436 
-    437         self.shell.verbose_quit = True
-    438         self.set_quit_hook()
-    439 
-    440         self.register_interface_magics()
-    441 
-    442         if SAGE_IMPORTALL == 'yes':
-    443             self.init_environment()
-    444 
-    445     def register_interface_magics(self):
-    446         """
-    447         Register magics for each of the Sage interfaces
-    448         """
-    449         from sage.repl.interface_magic import InterfaceMagic
-    450         InterfaceMagic.register_all(self.shell)
-
-/usr/lib64/python3.8/site-packages/sage/all.py in <module>()
-     93 from sage.misc.all       import *         # takes a while
-     94 from sage.typeset.all    import *
-     95 from sage.repl.all       import *
-     96 
-     97 from sage.misc.sh import sh
-     98 
-     99 from sage.libs.all       import *
-    100 from sage.data_structures.all import *
-    101 from sage.doctest.all    import *
-    102 
-    103 from sage.structure.all  import *
-    104 from sage.rings.all      import *
-    105 from sage.arith.all      import *
-    106 from sage.matrix.all     import *
-    107 
---> 108 from sage.symbolic.all   import *
-        global sage.symbolic.all = undefined
-    109 from sage.modules.all    import *
-    110 from sage.monoids.all    import *
-    111 from sage.algebras.all   import *
-    112 from sage.modular.all    import *
-    113 from sage.sat.all        import *
-    114 from sage.schemes.all    import *
-    115 from sage.graphs.all     import *
-    116 from sage.groups.all     import *
-    117 from sage.arith.power    import generic_power as power
-    118 from sage.databases.all  import *
-    119 from sage.categories.all import *
-    120 from sage.sets.all       import *
-    121 from sage.probability.all import *
-    122 from sage.interfaces.all import *
-    123 
-
-/usr/lib64/python3.8/site-packages/sage/symbolic/all.py in <module>()
-      1 from `__future__` import absolute_import
-      2 
-
----
-        global sage.libs.pynac.pynac = undefined
-        global I = undefined
-      4 i = I
-      5 
-      6 from .ring import SR
-      7 from .constants import (pi, e, NaN, golden_ratio, log2, euler_gamma, catalan,
-      8                        khinchin, twinprime, mertens, glaisher)
-      9 from .expression import Expression, solve_diophantine, hold
-     10 from .callable import CallableSymbolicExpressionRing
-     11 
-     12 from sage.symbolic.relation import solve, solve_mod, solve_ineq
-     13 from sage.symbolic.assumptions import assume, forget, assumptions, assuming
-     14 
-     15 from .units import units
-
-/usr/lib64/python3.8/site-packages/sage/libs/pynac/pynac.pyx in init sage.libs.pynac.pynac (build/cythonized/sage/libs/pynac/pynac.cpp:31605)()
-   2523     py_funcs.ex_to_pyExpression = &ex_to_pyExpression
-   2524     py_funcs.subs_args_to_PyTuple = &subs_args_to_PyTuple
-   2525     py_funcs.py_print_function = &py_print_function
-   2526     py_funcs.py_latex_function = &py_latex_function
-   2527     py_funcs.py_get_ginac_serial = &py_get_ginac_serial
-   2528     py_funcs.py_get_sfunction_from_serial = &py_get_sfunction_from_serial
-   2529     py_funcs.py_get_serial_from_sfunction = &py_get_serial_from_sfunction
-   2530     py_funcs.py_get_serial_for_new_sfunction = &py_get_serial_for_new_sfunction
-   2531 
-   2532     py_funcs.py_get_constant = &py_get_constant
-   2533     py_funcs.py_print_fderivative =  &py_print_fderivative
-   2534     py_funcs.py_latex_fderivative =  &py_latex_fderivative
-   2535     py_funcs.paramset_to_PyTuple = &paramset_to_PyTuple
-   2536 
-   2537 init_function_table()
--> 2538 init_pynac_I()
-        global init_pynac_I = <built-in function init_pynac_I>
-   2539 
-   2540 set_ginac_fn_serial()
-
-/usr/lib64/python3.8/site-packages/sage/libs/pynac/pynac.pyx in sage.libs.pynac.pynac.init_pynac_I (build/cythonized/sage/libs/pynac/pynac.cpp:26828)()
-   2425         <type 'sage.rings.number_field.number_field_element_quadratic.NumberFieldElement_quadratic'>
-   2426 
-   2427     Check that :trac:`10064` is fixed::
-   2428 
-   2429         sage: y = I*I*x / x # so y is the expression -1
-   2430         sage: y.is_positive()
-   2431         False
-   2432         sage: z = -x / x
-   2433         sage: z.is_positive()
-   2434         False
-   2435         sage: bool(z == y)
-   2436         True
-   2437     """
-   2438     global pynac_I, I
-   2439     from sage.rings.number_field.number_field import QuadraticField
--> 2440     K = QuadraticField(-1, 'I', embedding=CC.gen(), latex_name='i')
-        global K = undefined
-        global QuadraticField = undefined
-        global embedding = undefined
-        global CC.gen = <bound method ComplexField_class.gen of Complex Field with 53 bits of precision>
-        global latex_name = undefined
-   2441     pynac_I = K.gen()
-   2442     ginac_pyinit_I(pynac_I)
-   2443     I = new_Expression_from_GEx(ring.SR, g_I)
-   2444 
-   2445 
-   2446 def init_function_table():
-   2447     """
-   2448     Initializes the function pointer table in Pynac.  This must be
-   2449     called before Pynac is used; otherwise, there will be segfaults.
-   2450     """
-   2451 
-   2452     py_funcs.py_gcd = &py_gcd
-   2453     py_funcs.py_lcm = &py_lcm
-   2454     py_funcs.py_real = &py_real
-   2455     py_funcs.py_imag = &py_imag
-
-/usr/lib64/python3.8/site-packages/sage/rings/number_field/number_field.py in QuadraticField(D=-1, name='I', check=True, embedding=1.00000000000000*I, latex_name='i', **args={})
-    934         False
-    935     """
-    936     D = QQ(D)
-    937     if check:
-    938         if D.is_square():
-    939             raise ValueError("D must not be a perfect square.")
-    940     R = QQ['x']
-    941     f = R([-D, 0, 1])
-    942     if embedding is True:
-    943         if D > 0:
-    944             embedding = RLF(D).sqrt()
-    945         else:
-    946             embedding = CLF(D).sqrt()
-    947     if latex_name == 'sqrt':
-    948         latex_name = r'\sqrt{%s}' % D
---> 949     return NumberField(f, name, check=False, embedding=embedding, latex_name=latex_name, **args)
-        global NumberField = <function NumberField at 0x7f5239490820>
-        f = x^2 + 1
-        name = 'I'
-        check = True
-        embedding = 1.00000000000000*I
-        latex_name = 'i'
-        args = {}
-    950 
-    951 def is_AbsoluteNumberField(x):
-    952     """
-    953     Return True if x is an absolute number field.
-    954 
-    955     EXAMPLES::
-    956 
-    957         sage: from sage.rings.number_field.number_field import is_AbsoluteNumberField
-    958         sage: is_AbsoluteNumberField(NumberField(x^2+1,'a'))
-    959         True
-    960         sage: is_AbsoluteNumberField(NumberField([x^3 + 17, x^2+1],'a'))
-    961         False
-    962 
-    963     The rationals are a number field, but they're not of the absolute
-    964     number field class.
-
-/usr/lib64/python3.8/site-packages/sage/rings/number_field/number_field.py in NumberField(polynomial=x^2 + 1, name='I', check=False, names=None, embedding=1.00000000000000*I, latex_name='i', assume_disc_small=False, maximize_at_primes=None, structure=None, **kwds={})
-    536           Defn: a |--> [0 1 0 0]
-    537                        [0 0 1 0]
-    538                        [0 0 0 1]
-    539                        [2 0 0 0]
-    540     """
-    541     if names is not None:
-    542         name = names
-    543     for key, val in kwds.items():
-    544         if key not in ['implementation', 'prec']:
-    545             raise TypeError("NumberField() got an unexpected keyword argument '%s'"%key)
-    546         if not (val is None or isinstance(val, list) and all(c is None for c in val)):
-    547             raise NotImplementedError("Number field with prescribed %s is not implemented"%key)
-    548     if isinstance(polynomial, (list,tuple)):
-    549         return NumberFieldTower(polynomial, names=name, check=check, embeddings=embedding, latex_names=latex_name, assume_disc_small=assume_disc_small, maximize_at_primes=maximize_at_primes, structures=structure)
-    550 
---> 551     return NumberField_version2(polynomial=polynomial, name=name, check=check, embedding=embedding, latex_name=latex_name, assume_disc_small=assume_disc_small, maximize_at_primes=maximize_at_primes, structure=structure)
-        global NumberField_version2 = <sage.rings.number_field.number_field.NumberFieldFactory object at 0x7f5238f52bd0>
-        polynomial = x^2 + 1
-        name = 'I'
-        check = False
-        embedding = 1.00000000000000*I
-        latex_name = 'i'
-        assume_disc_small = False
-        maximize_at_primes = None
-        structure = None
-    552 
-    553 class NumberFieldFactory(UniqueFactory):
-    554     r"""
-    555     Factory for number fields.
-    556 
-    557     This should usually not be called directly, use :meth:`NumberField`
-    558     instead.
-    559 
-    560     INPUT:
-    561 
-    562         - ``polynomial`` - a polynomial over `\QQ` or a number field.
-    563         - ``name`` - a string (default: ``'a'``), the name of the generator
-    564         - ``check`` - a boolean (default: ``True``); do type checking and
-    565           irreducibility checking.
-    566         - ``embedding`` - ``None`` or an element, the images of the generator
-
-/usr/lib64/python3.8/site-packages/sage/structure/factory.pyx in sage.structure.factory.UniqueFactory.__call__ (build/cythonized/sage/structure/factory.c:2240)()
-    354         It already created one, so don't re-create::
-    355 
-    356             sage: test_factory(1,2,3)
-    357             <sage.structure.test_factory.A object at ...>
-    358             sage: test_factory(1,2,3) is test_factory(1,2,3)
-    359             True
-    360 
-    361         Of course, with a different key, a new object will be created::
-    362 
-    363             sage: test_factory(1,2,3) is test_factory(1,2,4)
-    364             Making object (1, 2, 4)
-    365             False
-    366         """
-    367         key, kwds = self.create_key_and_extra_args(*args, **kwds)
-    368         version = self.get_version(sage_version)
---> 369         return self.get_object(version, key, kwds)
-        global self.get_object = undefined
-        global version = undefined
-        global key = undefined
-        global kwds = undefined
-    370 
-    371     cpdef get_object(self, version, key, extra_args):
-    372         """
-    373         Returns the object corresponding to ``key``, creating it with
-    374         ``extra_args`` if necessary (for example, it isn't in the cache
-    375         or it is unpickling from an older version of Sage).
-    376 
-    377         EXAMPLES::
-    378 
-    379             sage: from sage.structure.test_factory import test_factory
-    380             sage: a = test_factory.get_object(3.0, 'a', {}); a
-    381             Making object a
-    382             <sage.structure.test_factory.A object at ...>
-    383             sage: test_factory.get_object(3.0, 'a', {}) is test_factory.get_object(3.0, 'a', {})
-    384             True
-
-/usr/lib64/python3.8/site-packages/sage/structure/factory.pyx in sage.structure.factory.UniqueFactory.get_object (build/cythonized/sage/structure/factory.c:2444)()
-    391 
-    392         TESTS:
-    393 
-    394         Check that :trac:`16317` has been fixed, i.e., caching works for
-    395         unhashable objects::
-    396 
-    397             sage: K.<u> = Qq(4)
-    398             sage: test_factory.get_object(3.0, (K(1), 'c'), {})  is test_factory.get_object(3.0, (K(1), 'c'), {})
-    399             Making object (1 + O(2^20), 'c')
-    400             True
-    401 
-    402         """
-    403         cache_key = key
-    404         try:
-    405             try:
---> 406                 return self._cache[version, cache_key]
-        global self._cache = undefined
-        global version = undefined
-        global cache_key = undefined
-    407             except TypeError: # key is unhashable
-    408                 cache_key = _cache_key(cache_key)
-    409                 return self._cache[version, cache_key]
-    410         except KeyError:
-    411             pass
-    412         obj = self.create_object(version, key, **extra_args)
-    413         self._cache[version, cache_key] = obj
-    414         try:
-    415             for key in self.other_keys(key, obj):
-    416                 try:
-    417                     self._cache[version, key] = obj
-    418                 except TypeError: # key is unhashable
-    419                     self._cache[version, _cache_key(key)] = obj
-    420             obj._factory_data = self, version, key, extra_args
-    421 
-
-/usr/lib64/python3.8/site-packages/sage/misc/weak_dict.pyx in sage.misc.weak_dict.WeakValueDictionary.__getitem__ (build/cythonized/sage/misc/weak_dict.c:3623)()
-    688 
-    689             sage: D[10] = ZZ
-    690             sage: D[int(10)]
-    691             Integer Ring
-    692 
-    693         Check that :trac:`15956` has been fixed, i.e., a ``TypeError`` is
-    694         raised for unhashable objects::
-    695 
-    696             sage: D = sage.misc.weak_dict.WeakValueDictionary()
-    697             sage: D[matrix([])]
-    698             Traceback (most recent call last):
-    699             ...
-    700             TypeError: mutable matrices are unhashable
-    701 
-    702         """
---> 703         cdef PyObject* wr = PyDict_GetItemWithError(self, k)
-        global cdef = undefined
-        global PyObject = undefined
-        global wr = undefined
-        global PyDict_GetItemWithError = undefined
-        global self = undefined
-        global k = undefined
-    704         if wr == NULL:
-    705             raise KeyError(k)
-    706         out = PyWeakref_GetObject(wr)
-    707         if out == Py_None:
-    708             raise KeyError(k)
-    709         return <object>out
-    710 
-    711     def __contains__(self, k):
-    712         """
-    713         Containment in the set of keys.
-    714 
-    715         TESTS::
-    716 
-    717             sage: import sage.misc.weak_dict
-    718             sage: class Vals(object): pass
-
-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyFieldElement.__hash__ (build/cythonized/sage/rings/real_lazy.c:9119)()
-    692         except TypeError:
-    693             pass
-    694         left, right = self.approx(), other.approx()
-    695         return richcmp(left.endpoints(), right.endpoints(), op)
-    696 
-    697     def __hash__(self):
-    698         """
-    699         Return the hash value of ``self``.
-    700 
-    701         EXAMPLES::
-    702 
-    703             sage: a = RLF(3)
-    704             sage: hash(a)
-    705             3
-    706         """
---> 707         return hash(complex(self))
-        global hash = undefined
-        global complex = undefined
-        global self = undefined
-    708 
-    709     cdef LazyFieldElement _new_wrapper(self, value):
-    710         cdef LazyWrapper e = <LazyWrapper>LazyWrapper.__new__(LazyWrapper)
-    711         e._parent = self._parent
-    712         e._value = value
-    713         return e
-    714 
-    715     cdef LazyFieldElement _new_binop(self, LazyFieldElement left, LazyFieldElement right, op):
-    716         cdef LazyBinop e = <LazyBinop>LazyBinop.__new__(LazyBinop)
-    717         e._parent = self._parent
-    718         e._left = left
-    719         e._right = right
-    720         e._op = op
-    721         return e
-    722 
-
-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyFieldElement.__complex__ (build/cythonized/sage/rings/real_lazy.c:9949)()
-    809     `_real_mpfi_` = `_complex_mpfi_` =_mpfr_ = `_complex_mpfr_field_` = `_generic_`
-    810 
-    811     def __complex__(self):
-    812         """
-    813         Return ``self`` as a complex.
-    814 
-    815         EXAMPLES::
-    816 
-    817             sage: complex(CLF(-1)^(1/4))
-    818             (0.707106781186547...+0.707106781186547...j)
-    819         """
-    820         try:
-    821             return self.eval(complex)
-    822         except Exception:
-    823             from .complex_field import ComplexField
---> 824             return complex(self.eval(ComplexField(53)))
-        global complex = undefined
-        global self.eval = undefined
-        global ComplexField = undefined
-    825 
-    826     cpdef eval(self, R):
-    827         """
-    828         Abstract method for converting ``self`` into an element of ``R``.
-    829 
-    830         EXAMPLES::
-    831 
-    832             sage: a = RLF(12)
-    833             sage: a.eval(ZZ)
-    834             12
-    835         """
-    836         raise NotImplementedError("Subclasses must override this method.")
-    837 
-    838     cpdef int depth(self):
-    839         """
-
-/usr/lib64/python3.8/site-packages/sage/rings/real_lazy.pyx in sage.rings.real_lazy.LazyAlgebraic.eval (build/cythonized/sage/rings/real_lazy.c:18065)()
-   1657 #                 else:
-   1658 #                     z = (-b + R(self._quadratic_disc).sqrt()) / (2*a)
-   1659 #                 if z.parent() is not R:
-   1660 #                     z = R(z)
-   1661 #                 self._root_approx = z
-   1662 #                 from sage.rings.complex_interval_field import is_IntervalField
-   1663 #                 if is_IntervalField(R):
-   1664 #                     self._root_approx = (self._root_approx.upper() + self._root_approx.lower()) / 2
-   1665 #                 self._prec = R.prec()
-   1666 #                 return R(self._root_approx)
-   1667             if self._root is None:
-   1668                 # This could be done much more efficiently with Newton iteration,
-   1669                 # but will require some care to make sure we get the right root, and
-   1670                 # to the correct precision.
-   1671                 from sage.rings.qqbar import AA, QQbar
--> 1672                 roots = self._poly.roots(ring = AA if isinstance(self._parent, RealLazyField_class) else QQbar)
-        global roots = undefined
-        global self._poly.roots = undefined
-        global ring = undefined
-        global AA = undefined
-        global isinstance = undefined
-        global self._parent = undefined
-        global RealLazyField_class = <class 'sage.rings.real_lazy.RealLazyField_class'>
-        global QQbar = undefined
-   1673                 best_root = roots[0][0]
-   1674                 min_dist = abs(self._root_approx - best_root)
-   1675                 for r, e in roots[1:]:
-   1676                     dist = abs(self._root_approx - r)
-   1677                     if dist < min_dist:
-   1678                         best_root = r
-   1679                         min_dist = dist
-   1680                 self._root = best_root
-   1681         if self._root is not None:
-   1682             return R(self._root)
-   1683 
-   1684     def __float__(self):
-   1685         """
-   1686         TESTS::
-   1687 
-
-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.roots (build/cythonized/sage/rings/polynomial/polynomial_element.c:62120)()
-   7784 
-   7785                 if multiplicities:
-   7786                     return rts
-   7787                 else:
-   7788                     return [rt for (rt, mult) in rts]
-   7789 
-   7790             if (is_IntegerRing(K) or is_RationalField(K)
-   7791                 or is_AlgebraicField_common(K) or input_gaussian) and \
-   7792                 (is_ComplexIntervalField(L) or is_AlgebraicField_common(L)):
-   7793 
-   7794                 from sage.rings.polynomial.complex_roots import complex_roots
-   7795 
-   7796                 if is_ComplexIntervalField(L):
-   7797                     rts = complex_roots(self, min_prec=L.prec())
-   7798                 elif is_AlgebraicField(L):
--> 7799                     rts = complex_roots(self, retval='algebraic')
-        global rts = undefined
-        global complex_roots = undefined
-        global self = undefined
-        global retval = undefined
-   7800                 else:
-   7801                     rts = complex_roots(self, retval='algebraic_real')
-   7802 
-   7803                 if multiplicities:
-   7804                     return rts
-   7805                 else:
-   7806                     return [rt for (rt, mult) in rts]
-   7807 
-   7808             if output_fp and output_complex and not input_gaussian:
-   7809                 # If we want the complex roots, and the input is not
-   7810                 # floating point, we convert to a real polynomial
-   7811                 # (except when the input coefficients are Gaussian rationals).
-   7812                 if is_ComplexDoubleField(L):
-   7813                     real_field = RDF
-   7814                 else:
-
-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/complex_roots.py in complex_roots(p=x^2 + 1, skip_squarefree=False, retval='algebraic', min_prec=0)
-    243     if skip_squarefree:
-    244         factors = [(p, 1)]
-    245     else:
-    246         factors = p.squarefree_decomposition()
-    247 
-    248     prec = 53
-    249     while True:
-    250         CC = ComplexField(prec)
-    251         CCX = CC['x']
-    252 
-    253         all_rts = []
-    254         ok = True
-    255 
-    256         for (factor, exp) in factors:
-    257             cfac = CCX(factor)
---> 258             rts = cfac.roots(multiplicities=False)
-        rts = undefined
-        cfac.roots = <built-in method roots of PolynomialRing_field_with_category.element_class object at 0x7f5066326dc0>
-        global multiplicities = undefined
-    259             # Make sure the number of roots we found is the degree. If
-    260             # we don't find that many roots, it's because the
-    261             # precision isn't big enough and though the (possibly
-    262             # exact) polynomial "factor" is squarefree, it is not
-    263             # squarefree as an element of CCX.
-    264             if len(rts) < factor.degree():
-    265                 ok = False
-    266                 break
-    267             irts = interval_roots(factor, rts, max(prec, min_prec))
-    268             if irts is None:
-    269                 ok = False
-    270                 break
-    271             if retval != 'interval':
-    272                 factor = QQbar.common_polynomial(factor)
-    273             for irt in irts:
-
-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.roots (build/cythonized/sage/rings/polynomial/polynomial_element.c:59509)()
-   7692                     ext_rts1 = numpy.roots(numpy_array)
-   7693                     rts = []
-   7694                     for rt in ext_rts1:
-   7695                         rts.append(CDF(rt))
-   7696                     rts.sort()
-   7697                     ext_rts = rts
-   7698                 except (ValueError, LinAlgError):
-   7699                     if algorithm == 'either':
-   7700                         algorithm = 'pari'
-   7701                     else:
-   7702                         raise
-   7703 
-   7704             if algorithm == 'pari':
-   7705                 if not input_arbprec:
-   7706                     self = self.change_ring(CC if input_complex else RR)
--> 7707                 ext_rts = self.__pari__().polroots(precision=L.prec())
-        global ext_rts = undefined
-        global self.__pari__.polroots = undefined
-        global precision = undefined
-        global L.prec = undefined
-   7708 
-   7709             if output_complex:
-   7710                 rts = sort_complex_numbers_for_display([L(root) for root in ext_rts])
-   7711             else:
-   7712                 rts = sorted([L(root.real()) for root in ext_rts if root.imag() == 0])
-   7713 
-   7714             rts_mult = []
-   7715             j = 0
-   7716             while j < len(rts):
-   7717                 rt = rts[j]
-   7718                 mult = rts.count(rt)
-   7719                 rts_mult.append((rt, mult))
-   7720                 j += mult
-   7721 
-   7722             if multiplicities:
-
-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial.__pari__ (build/cythonized/sage/rings/polynomial/polynomial_element.c:49147)()
-   6079             sage: R.<x> = S['x']
-   6080             sage: pari(x^2 + 9*x)
-   6081             x^2 + 2*x
-   6082             sage: pari(a*x + 9*b*x^3)
-   6083             2*b*x^3 + a*x
-   6084 
-   6085         ::
-   6086 
-   6087             sage: S.<a> = Integers(8)['a']
-   6088             sage: R.<x> = S['x']
-   6089             sage: pari(x^2 + 2*x)
-   6090             Mod(1, 8)*x^2 + Mod(2, 8)*x
-   6091             sage: pari(a*x + 10*x^3)
-   6092             Mod(2, 8)*x^3 + Mod(1, 8)*a*x
-   6093         """
--> 6094         return self._pari_with_name(self._parent.variable_name())
-        global self._pari_with_name = undefined
-        global self._parent.variable_name = undefined
-   6095 
-   6096     def _pari_or_constant(self, name=None):
-   6097         r"""
-   6098         Convert ``self`` to PARI.  This behaves identical to :meth:`__pari__`
-   6099         or :meth:`_pari_with_name` except for constant polynomials:
-   6100         then the constant is returned instead of a constant polynomial.
-   6101 
-   6102         INPUT:
-   6103 
-   6104         - ``name`` -- (default: None) Variable name.  If not given, use
-   6105           ``self.parent().variable_name()``.  This argument is irrelevant
-   6106           for constant polynomials.
-   6107 
-   6108         EXAMPLES::
-   6109 
-
-/usr/lib64/python3.8/site-packages/sage/rings/polynomial/polynomial_element.pyx in sage.rings.polynomial.polynomial_element.Polynomial._pari_with_name (build/cythonized/sage/rings/polynomial/polynomial_element.c:49540)()
-   6132     def _pari_with_name(self, name='x'):
-   6133         r"""
-   6134         Return polynomial as a PARI object with topmost variable
-   6135         ``name``.  By default, use 'x' for the variable name.
-   6136 
-   6137         For internal use only.
-   6138 
-   6139         EXAMPLES::
-   6140 
-   6141             sage: R.<a> = PolynomialRing(ZZ)
-   6142             sage: (2*a^2 + a)._pari_with_name()
-   6143             2*x^2 + x
-   6144             sage: (2*a^2 + a)._pari_with_name('y')
-   6145             2*y^2 + y
-   6146         """
--> 6147         vals = [x.__pari__() for x in self.list()]
-        global vals = undefined
-        global x.__pari__ = undefined
-        global x = undefined
-        global self.list = undefined
-   6148         return pari(vals).Polrev(name)
-   6149 
-   6150     def _pari_init_(self):
-   6151         return repr(self.__pari__())
-   6152 
-   6153     def _magma_init_(self, magma):
-   6154         """
-   6155         Return a string that evaluates in Magma to this polynomial.
-   6156 
-   6157         EXAMPLES::
-   6158 
-   6159             sage: magma = Magma()  # new session
-   6160             sage: R.<y> = ZZ[]
-   6161             sage: f = y^3 - 17*y + 5
-   6162             sage: f._magma_init_(magma)        # optional - magma
-
-/usr/lib64/python3.8/site-packages/sage/rings/complex_number.pyx in sage.rings.complex_number.ComplexNumber.__pari__ (build/cythonized/sage/rings/complex_number.c:7099)()
-    575             <type 'cypari2.gen.Gen'>
-    576             sage: a.__pari__()
-    577             2.00000000000000 + 1.00000000000000*I
-    578             sage: type(a.__pari__())
-    579             <type 'cypari2.gen.Gen'>
-    580             sage: a = CC(pi)
-    581             sage: pari(a)
-    582             3.14159265358979
-    583             sage: pari(a).type()
-    584             't_REAL'
-    585             sage: a = CC(-2).sqrt()
-    586             sage: pari(a)
-    587             1.41421356237310*I
-    588         """
-    589         if self.is_real():
---> 590             return self.real().__pari__()
-        global self.real.__pari__ = undefined
-    591         return sage.libs.pari.all.pari.complex(self.real() or 0, self.imag())
-    592 
-    593     def __mpc__(self):
-    594         """
-    595         Convert Sage ``ComplexNumber`` to gmpy2 ``mpc``.
-    596 
-    597         EXAMPLES::
-    598 
-    599             sage: c = ComplexNumber(2,1)
-    600             sage: c.__mpc__()
-    601             mpc('2.0+1.0j')
-    602             sage: from gmpy2 import mpc
-    603             sage: mpc(c)
-    604             mpc('2.0+1.0j')
-    605             sage: CF = ComplexField(134)
-
-/usr/lib64/python3.8/site-packages/sage/rings/real_mpfr.pyx in sage.rings.real_mpfr.RealNumber.__pari__ (build/cythonized/sage/rings/real_mpfr.c:22497)()
-   3246         sig_on()
-   3247         if mpfr_zero_p(self.value):
-   3248             pari_float = real_0_bit(-rounded_prec)
-   3249         else:
-   3250             # Now we can extract the mantissa, and it will be normalized
-   3251             # (the most significant bit of the most significant word will be 1).
-   3252             mpz_init(mantissa)
-   3253             exponent = mpfr_get_z_exp(mantissa, self.value)
-   3254 
-   3255             # Create a PARI REAL
-   3256             pari_float = cgetr(2 + rounded_prec / wordsize)
-   3257             pari_float[1] = evalexpo(exponent + rounded_prec - 1) + evalsigne(mpfr_sgn(self.value))
-   3258             mpz_export(&pari_float[2], NULL, 1, wordsize // 8, 0, 0, mantissa)
-   3259             mpz_clear(mantissa)
-   3260 
--> 3261         return new_gen(pari_float)
-        global new_gen = undefined
-        global pari_float = undefined
-   3262 
-   3263     def _mpmath_(self, prec=None, rounding=None):
-   3264         """
-   3265         Return an mpmath version of this :class:`RealNumber`.
-   3266 
-   3267         .. NOTE::
-   3268 
-   3269            Currently the rounding mode is ignored.
-   3270 
-   3271         EXAMPLES::
-   3272 
-   3273             sage: RR(-1.5)._mpmath_()
-   3274             mpf('-1.5')
-   3275         """
-   3276         if prec is not None:
-
-cypari2/stack.pyx in cypari2.stack.new_gen()
-
-cypari2/stack.pyx in cypari2.stack.new_gen_noclear()
-
-SystemError: new_gen() argument not on PARI stack, not on PARI heap and not a universal constant
-
-***************************************************************************
-
-History of session input:
-*** Last line of input (may not be in above history):
-
+The crash report is attached. The installation is from the latest Fedora 32 package (sage 9.0).
``````




---

archive/issue_comments_494234.json:
```json
{
    "body": "<div id=\"comment:1\" align=\"right\">comment:1</div>\n\nAttachment: **[Sage_crash_report.txt](https://github.com/sagemath/sage/files/ticket30868/Sage_crash_report.txt)**",
    "created_at": "2020-11-07T04:17:53Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30868#issuecomment-494234",
    "user": "https://github.com/AndrewLyasoff"
}
```

<div id="comment:1" align="right">comment:1</div>

Attachment: **[Sage_crash_report.txt](https://github.com/sagemath/sage/files/ticket30868/Sage_crash_report.txt)**



---

archive/issue_events_422618.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-11-07T19:13:04Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "milestone_number": null,
    "milestone_title": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422618"
}
```



---

archive/issue_comments_494235.json:
```json
{
    "body": "<div id=\"comment:2\" align=\"right\">comment:2</div>\n\nReport Fedora packaging bugs to Fedora.",
    "created_at": "2020-11-07T19:13:04Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30868#issuecomment-494235",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:2" align="right">comment:2</div>

Report Fedora packaging bugs to Fedora.



---

archive/issue_events_422619.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-11-07T19:13:04Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422619"
}
```



---

archive/issue_comments_494236.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nFor the record, this started happening when giac was updated from version 1.6.0-7 to version 1.6.0-25.  The way giac initializes pari was changed.  Sagemath starts up and initializes cypari2, which stores the value of `avma`.  Later, giac is loaded.  It initializes pari a second time, creating an entirely new stack and a new value of `avma`.  When cypari2 is next used, it tries to use values on the old stack, but they are not valid stack slots because giac made a new pari stack.\n\nI am going to try enabling TLS support in pari to see if that is sufficient.  That way, cypari2 and giac threads can use different pari stacks, at the cost of consuming more memory.",
    "created_at": "2020-11-09T17:24:27Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30868#issuecomment-494236",
    "user": "https://github.com/jamesjer"
}
```

<div id="comment:3" align="right">comment:3</div>

For the record, this started happening when giac was updated from version 1.6.0-7 to version 1.6.0-25.  The way giac initializes pari was changed.  Sagemath starts up and initializes cypari2, which stores the value of `avma`.  Later, giac is loaded.  It initializes pari a second time, creating an entirely new stack and a new value of `avma`.  When cypari2 is next used, it tries to use values on the old stack, but they are not valid stack slots because giac made a new pari stack.

I am going to try enabling TLS support in pari to see if that is sufficient.  That way, cypari2 and giac threads can use different pari stacks, at the cost of consuming more memory.



---

archive/issue_comments_494237.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nThis is probably best discussed in #30537, our giac 1.6 upgrade ticket",
    "created_at": "2020-11-09T18:07:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30868#issuecomment-494237",
    "user": "https://github.com/mkoeppe"
}
```

<div id="comment:4" align="right">comment:4</div>

This is probably best discussed in #30537, our giac 1.6 upgrade ticket



---

archive/issue_events_422620.json:
```json
{
    "actor": "https://github.com/slel",
    "created_at": "2021-01-02T21:36:10Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20build",
    "label_color": "0000b0",
    "label_name": "c: build",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422620"
}
```



---

archive/issue_events_422621.json:
```json
{
    "actor": "https://github.com/slel",
    "created_at": "2021-01-02T21:36:10Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422621"
}
```



---

archive/issue_events_422622.json:
```json
{
    "actor": "https://github.com/slel",
    "created_at": "2021-01-02T21:36:10Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422622"
}
```



---

archive/issue_comments_494238.json:
```json
{
    "body": "Reviewer: **Samuel Leli\u00e8vre**",
    "created_at": "2021-01-02T21:36:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30868#issuecomment-494238",
    "user": "https://github.com/slel"
}
```

Reviewer: **Samuel LeliÃ¨vre**



---

archive/issue_events_422623.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-06-24T20:15:37Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422623"
}
```



---

archive/issue_events_422624.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-06-24T20:15:37Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/30868",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30868#event-422624"
}
```
