# Issue 30302: Arithmetic on tensor module elements, manifold objects: Always Return a Copy

archive/issues_030065.json:
```json
{
    "body": "This question arose from ticket #30239, [ticket:30239#comment:36 [comment:36](#comment%3A36)].\n\nShould `FiniteRankFreeModule` and manifold objects always return a mutable copy, even for trivial operations? At least, this would be a consistent behavior.\n\nAs pointed out by Matthias, this already holds true for `FreeModule`:\n\n```\nsage: M = FreeModule(QQ, 3)\nsage: v = M([1,2,3])\nsage: w = v + 0\nsage: w == v\nTrue\nsage: w is v\nFalse\n```\n\nI feel quite torn about this, but slightly tend to the copy-version.\n\n**Addendum:**\n\nFor `FreeModule`, we also have the following behavior:\n\n```\nsage: M = FreeModule(QQ, 3)\nsage: M(0)\n(0, 0, 0)\nsage: M.zero()\n(0, 0, 0)\nsage: M.zero() is M(0)\nFalse\n```\n\nI don't think that a parent should do that, especially when it already has a `zero` method. Should that be changed?\n\n**CC:**  @egourgoulhon @tscrim @mkoeppe\n\n**Branch:** [u/gh-mjungmath/return_copy_always_scalarfields](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mjungmath/return_copy_always_scalarfields)\n\n**Commit:** [b7b0b3f338c4d64ef0229ec74c50c7e59a72454d](https://github.com/sagemath/sagetrac-mirror/commit/b7b0b3f338c4d64ef0229ec74c50c7e59a72454d)\n\nIssue created by migration from https://trac.sagemath.org/ticket/30302\n\n",
    "created_at": "2020-08-06T09:59:08Z",
    "labels": [
        "component: misc"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-9.8",
    "title": "Arithmetic on tensor module elements, manifold objects: Always Return a Copy",
    "type": "issue",
    "url": "https://github.com/sagemath/sage/issues/30302",
    "user": "https://github.com/mjungmath"
}
```
This question arose from ticket #30239, [ticket:30239#comment:36 [comment:36](#comment%3A36)].

Should `FiniteRankFreeModule` and manifold objects always return a mutable copy, even for trivial operations? At least, this would be a consistent behavior.

As pointed out by Matthias, this already holds true for `FreeModule`:

```
sage: M = FreeModule(QQ, 3)
sage: v = M([1,2,3])
sage: w = v + 0
sage: w == v
True
sage: w is v
False
```

I feel quite torn about this, but slightly tend to the copy-version.

**Addendum:**

For `FreeModule`, we also have the following behavior:

```
sage: M = FreeModule(QQ, 3)
sage: M(0)
(0, 0, 0)
sage: M.zero()
(0, 0, 0)
sage: M.zero() is M(0)
False
```

I don't think that a parent should do that, especially when it already has a `zero` method. Should that be changed?

**CC:**  @egourgoulhon @tscrim @mkoeppe

**Branch:** [u/gh-mjungmath/return_copy_always_scalarfields](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mjungmath/return_copy_always_scalarfields)

**Commit:** [b7b0b3f338c4d64ef0229ec74c50c7e59a72454d](https://github.com/sagemath/sagetrac-mirror/commit/b7b0b3f338c4d64ef0229ec74c50c7e59a72454d)

Issue created by migration from https://trac.sagemath.org/ticket/30302





---

archive/issue_comments_483472.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,6 +1,6 @@\n This question arose from ticket #30239, [ticket:30239#comment:36 [comment:36](#comment%3A36)].\n \n-Should `FiniteRankFreeModule` and manifold object always return a mutable copy, even for trivial operations? At least, this would be a consistent behavior.\n+Should `FiniteRankFreeModule` and manifold objects always return a mutable copy, even for trivial operations? At least, this would be a consistent behavior.\n \n As pointed out by Matthias, this already holds true for `FreeModule`:\n \n``````\n",
    "created_at": "2020-08-06T09:59:32Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483472",
    "user": "https://github.com/mjungmath"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,6 +1,6 @@
 This question arose from ticket #30239, [ticket:30239#comment:36 [comment:36](#comment%3A36)].
 
-Should `FiniteRankFreeModule` and manifold object always return a mutable copy, even for trivial operations? At least, this would be a consistent behavior.
+Should `FiniteRankFreeModule` and manifold objects always return a mutable copy, even for trivial operations? At least, this would be a consistent behavior.
 
 As pointed out by Matthias, this already holds true for `FreeModule`:
 
``````




---

archive/issue_comments_483473.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -14,7 +14,7 @@\n False\n ```\n \n-I feel quite torn about this, but tend to the copy-version.\n+I feel quite torn about this, but slightly tend to the copy-version.\n \n **Addendum:**\n \n``````\n",
    "created_at": "2020-08-06T10:01:00Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483473",
    "user": "https://github.com/mjungmath"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -14,7 +14,7 @@
 False
 ```
 
-I feel quite torn about this, but tend to the copy-version.
+I feel quite torn about this, but slightly tend to the copy-version.
 
 **Addendum:**
 
``````




---

archive/issue_comments_483474.json:
```json
{
    "body": "<a id='comment:3'></a>\nBoth `M()` and `M(0)` return a new mutable element. That's how one creates a new vector, whose components can then be modified. If you want the immutable 0 element, you can use `M.zero()`.\n\nThe arithmetic operations should either always create an immutable element or always create a new mutable element. It would be very inconvenient if the result of an operation was sometimes immutable, sometimes a new mutable element, depending on the input. (And it would be highly problematic if sometimes it would return an existing mutable element.)",
    "created_at": "2020-08-06T11:44:50Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483474",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:3'></a>
Both `M()` and `M(0)` return a new mutable element. That's how one creates a new vector, whose components can then be modified. If you want the immutable 0 element, you can use `M.zero()`.

The arithmetic operations should either always create an immutable element or always create a new mutable element. It would be very inconvenient if the result of an operation was sometimes immutable, sometimes a new mutable element, depending on the input. (And it would be highly problematic if sometimes it would return an existing mutable element.)



---

archive/issue_comments_483475.json:
```json
{
    "body": "<a id='comment:4'></a>\nMy concern here would be performance. For complicated symbolic expressions, creating a copy can have a significant CPU cost. The main concern is about scalar fields, because tensor fields arithmetics always end up to scalar fields arithmetics, the scalar fields being the tensor components in a given frame. For the time being, `ScalarField._add_()` starts with\n\n```\n        if self._is_zero:\n            return other\n        if other._is_zero:\n            return self\n```\nIf we change this to return a copy (I understand the arguments put forward by Matthias), then I would advocate for extensive benchmarks, with complicated tensor fields (those in the doctests are too simple), such as in those mentionned [ticket:30116#comment:52 here].",
    "created_at": "2020-08-06T14:38:56Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483475",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:4'></a>
My concern here would be performance. For complicated symbolic expressions, creating a copy can have a significant CPU cost. The main concern is about scalar fields, because tensor fields arithmetics always end up to scalar fields arithmetics, the scalar fields being the tensor components in a given frame. For the time being, `ScalarField._add_()` starts with

```
        if self._is_zero:
            return other
        if other._is_zero:
            return self
```
If we change this to return a copy (I understand the arguments put forward by Matthias), then I would advocate for extensive benchmarks, with complicated tensor fields (those in the doctests are too simple), such as in those mentionned [ticket:30116#comment:52 here].



---

archive/issue_comments_483476.json:
```json
{
    "body": "<a id='comment:5'></a>\nSymbolic expressions are immutable and therefore do not need to be copied.\n\nThe cost of making a copy should be dominated by copying the dictionaries in the Components objects.",
    "created_at": "2020-08-06T16:54:39Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483476",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:5'></a>
Symbolic expressions are immutable and therefore do not need to be copied.

The cost of making a copy should be dominated by copying the dictionaries in the Components objects.



---

archive/issue_comments_483477.json:
```json
{
    "body": "<a id='comment:6'></a>\nIf making a copy is so costly, we should try to optimize it.\n\nIf I remember correctly, until Sage 9 or so, all elements emerged from arithmetics were created from scratch, even the trivial ones. Even if copying would slow the current code down a bit, it should be still faster than versions before Sage 9.",
    "created_at": "2020-08-06T17:14:20Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483477",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:6'></a>
If making a copy is so costly, we should try to optimize it.

If I remember correctly, until Sage 9 or so, all elements emerged from arithmetics were created from scratch, even the trivial ones. Even if copying would slow the current code down a bit, it should be still faster than versions before Sage 9.



---

archive/issue_comments_483478.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [gh-mjungmath](#comment%3A6):\n> If making a copy is so costly, we should try to optimize it.\n\nCopying a symbolic expression with hundreds of terms will always remain slower than returning `self` or `other`. \n\n> If I remember correctly, until Sage 9 or so, all elements emerged from arithmetics were created from scratch, even the trivial ones. \n\n\nThat's not true: already in Sage 7.4, we have the code snippet shown in [comment:4](#comment%3A4).",
    "created_at": "2020-08-06T19:04:27Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483478",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:7'></a>
Replying to [gh-mjungmath](#comment%3A6):
> If making a copy is so costly, we should try to optimize it.

Copying a symbolic expression with hundreds of terms will always remain slower than returning `self` or `other`. 

> If I remember correctly, until Sage 9 or so, all elements emerged from arithmetics were created from scratch, even the trivial ones. 


That's not true: already in Sage 7.4, we have the code snippet shown in [comment:4](#comment%3A4).



---

archive/issue_comments_483479.json:
```json
{
    "body": "<a id='comment:8'></a>\nReplying to [gh-mjungmath](#comment%3A6):\n> If I remember correctly, until Sage 9 or so, all elements emerged from arithmetics were created from scratch, even the trivial ones. Even if copying would slow the current code down a bit, it should be still faster than versions before Sage 9.\n\n\nMy memory was partially wrong. For scalar fields, the `_is_zero` variable was already implemented, for tensor fields it was not.\n\nFurtermore, I've compared some computation times:\n\n**Current state:**\n\n```\nsage: M = Manifold(2, 'M', structure='topological') # the 2-dimensional sphere S^2\nsage: U = M.open_subset('U') # complement of the North pole\nsage: c_xy.<x,y> = U.chart() # stereographic coordinates from the North pole\nsage: V = M.open_subset('V') # complement of the South pole\nsage: c_uv.<u,v> = V.chart() # stereographic coordinates from the South pole\nsage: M.declare_union(U,V)   # S^2 is the union of U and V\nsage: xy_to_uv = c_xy.transition_map(c_uv, (x/(x^2+y^2), y/(x^2+y^2)),\n....:                                intersection_name='W',\n....:                                restrictions1= x^2+y^2!=0,\n....:                                restrictions2= u^2+v^2!=0)\nsage: uv_to_xy = xy_to_uv.inverse()\nsage: f = M.scalar_field({c_xy: 1/(1+x^2+y^2), c_uv: (u^2+v^2)/(1+u^2+v^2)},\n....:                    name='f')\nsage: %timeit f+0\nThe slowest run took 177.32 times longer than the fastest. This could mean that an intermediate result is being cached.\n100000 loops, best of 5: 4.22 \u00b5s per loop\nsage: %timeit f*1\nThe slowest run took 50.53 times longer than the fastest. This could mean that an intermediate result is being cached.\n100000 loops, best of 5: 11.8 \u00b5s per loop\n```\n\n\n**Returning a copy:**\n\n```\nsage: M = Manifold(2, 'M', structure='topological') # the 2-dimensional sphere S^2\nsage: U = M.open_subset('U') # complement of the North pole\nsage: c_xy.<x,y> = U.chart() # stereographic coordinates from the North pole\nsage: V = M.open_subset('V') # complement of the South pole\nsage: c_uv.<u,v> = V.chart() # stereographic coordinates from the South pole\nsage: M.declare_union(U,V)   # S^2 is the union of U and V\nsage: xy_to_uv = c_xy.transition_map(c_uv, (x/(x^2+y^2), y/(x^2+y^2)),\n....:                                intersection_name='W',\n....:                                restrictions1= x^2+y^2!=0,\n....:                                restrictions2= u^2+v^2!=0)\nsage: uv_to_xy = xy_to_uv.inverse()\nsage: f = M.scalar_field({c_xy: 1/(1+x^2+y^2), c_uv: (u^2+v^2)/(1+u^2+v^2)},\n....:                    name='f')\nsage: %timeit f+0\nThe slowest run took 23.78 times longer than the fastest. This could mean that an intermediate result is being cached.\n10000 loops, best of 5: 60.6 \u00b5s per loop\nsage: %timeit f*1\nThe slowest run took 24.43 times longer than the fastest. This could mean that an intermediate result is being cached.\n10000 loops, best of 5: 33.4 \u00b5s per loop\n```\n\nThat's a heavy loss of comutational time.",
    "created_at": "2020-08-06T19:04:59Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483479",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:8'></a>
Replying to [gh-mjungmath](#comment%3A6):
> If I remember correctly, until Sage 9 or so, all elements emerged from arithmetics were created from scratch, even the trivial ones. Even if copying would slow the current code down a bit, it should be still faster than versions before Sage 9.


My memory was partially wrong. For scalar fields, the `_is_zero` variable was already implemented, for tensor fields it was not.

Furtermore, I've compared some computation times:

**Current state:**

```
sage: M = Manifold(2, 'M', structure='topological') # the 2-dimensional sphere S^2
sage: U = M.open_subset('U') # complement of the North pole
sage: c_xy.<x,y> = U.chart() # stereographic coordinates from the North pole
sage: V = M.open_subset('V') # complement of the South pole
sage: c_uv.<u,v> = V.chart() # stereographic coordinates from the South pole
sage: M.declare_union(U,V)   # S^2 is the union of U and V
sage: xy_to_uv = c_xy.transition_map(c_uv, (x/(x^2+y^2), y/(x^2+y^2)),
....:                                intersection_name='W',
....:                                restrictions1= x^2+y^2!=0,
....:                                restrictions2= u^2+v^2!=0)
sage: uv_to_xy = xy_to_uv.inverse()
sage: f = M.scalar_field({c_xy: 1/(1+x^2+y^2), c_uv: (u^2+v^2)/(1+u^2+v^2)},
....:                    name='f')
sage: %timeit f+0
The slowest run took 177.32 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 5: 4.22 µs per loop
sage: %timeit f*1
The slowest run took 50.53 times longer than the fastest. This could mean that an intermediate result is being cached.
100000 loops, best of 5: 11.8 µs per loop
```


**Returning a copy:**

```
sage: M = Manifold(2, 'M', structure='topological') # the 2-dimensional sphere S^2
sage: U = M.open_subset('U') # complement of the North pole
sage: c_xy.<x,y> = U.chart() # stereographic coordinates from the North pole
sage: V = M.open_subset('V') # complement of the South pole
sage: c_uv.<u,v> = V.chart() # stereographic coordinates from the South pole
sage: M.declare_union(U,V)   # S^2 is the union of U and V
sage: xy_to_uv = c_xy.transition_map(c_uv, (x/(x^2+y^2), y/(x^2+y^2)),
....:                                intersection_name='W',
....:                                restrictions1= x^2+y^2!=0,
....:                                restrictions2= u^2+v^2!=0)
sage: uv_to_xy = xy_to_uv.inverse()
sage: f = M.scalar_field({c_xy: 1/(1+x^2+y^2), c_uv: (u^2+v^2)/(1+u^2+v^2)},
....:                    name='f')
sage: %timeit f+0
The slowest run took 23.78 times longer than the fastest. This could mean that an intermediate result is being cached.
10000 loops, best of 5: 60.6 µs per loop
sage: %timeit f*1
The slowest run took 24.43 times longer than the fastest. This could mean that an intermediate result is being cached.
10000 loops, best of 5: 33.4 µs per loop
```

That's a heavy loss of comutational time.



---

archive/issue_comments_483480.json:
```json
{
    "body": "<a id='comment:9'></a>\nReplying to [egourgoulhon](#comment%3A7):\n> Replying to [gh-mjungmath](#comment%3A6):\n> > If making a copy is so costly, we should try to optimize it.\n\n> Copying a symbolic expression with hundreds of terms will always remain slower than returning `self` or `other`. \n> \n> > If I remember correctly, until Sage 9 or so, all elements emerged from arithmetics were created from scratch, even the trivial ones. \n\n> \n> That's not true: already in Sage 7.4, we have the code snippet shown in [comment:4](#comment%3A4).\n\n\nYes sorry, I was mistaken. See above.",
    "created_at": "2020-08-06T19:05:58Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483480",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:9'></a>
Replying to [egourgoulhon](#comment%3A7):
> Replying to [gh-mjungmath](#comment%3A6):
> > If making a copy is so costly, we should try to optimize it.

> Copying a symbolic expression with hundreds of terms will always remain slower than returning `self` or `other`. 
> 
> > If I remember correctly, until Sage 9 or so, all elements emerged from arithmetics were created from scratch, even the trivial ones. 

> 
> That's not true: already in Sage 7.4, we have the code snippet shown in [comment:4](#comment%3A4).


Yes sorry, I was mistaken. See above.



---

archive/issue_comments_483481.json:
```json
{
    "body": "<a id='comment:10'></a>\nReplying to [gh-mjungmath](#comment%3A8):\n> **Returning a copy:**\n... could you share the changes that you made for benchmarking this?",
    "created_at": "2020-08-06T19:11:38Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483481",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:10'></a>
Replying to [gh-mjungmath](#comment%3A8):
> **Returning a copy:**
... could you share the changes that you made for benchmarking this?



---

archive/issue_comments_483482.json:
```json
{
    "body": "<a id='comment:11'></a>\nReplying to [mkoeppe](#comment%3A5):\n> Symbolic expressions are immutable and therefore do not need to be copied.\n> \n\n\nYou are right. Actually they are not copied when copying chart functions (and hence would not be copied when copying scalar fields): the code of `ChartFunction.copy()` is indeed:\n\n```\n        resu = type(self)(self.parent())\n        for kk, vv in self._express.items():\n            resu._express[kk] = vv\n        resu._expansion_symbol = self._expansion_symbol\n        resu._order = self._order\n        return resu\n```\nHere if `kk` is 'SR', `vv` is a symbolic expression.",
    "created_at": "2020-08-06T19:14:10Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483482",
    "user": "https://github.com/egourgoulhon"
}
```

<a id='comment:11'></a>
Replying to [mkoeppe](#comment%3A5):
> Symbolic expressions are immutable and therefore do not need to be copied.
> 


You are right. Actually they are not copied when copying chart functions (and hence would not be copied when copying scalar fields): the code of `ChartFunction.copy()` is indeed:

```
        resu = type(self)(self.parent())
        for kk, vv in self._express.items():
            resu._express[kk] = vv
        resu._expansion_symbol = self._expansion_symbol
        resu._order = self._order
        return resu
```
Here if `kk` is 'SR', `vv` is a symbolic expression.



---

archive/issue_comments_483483.json:
```json
{
    "body": "**Branch:** [u/gh-mjungmath/return_copy_always_scalarfields](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mjungmath/return_copy_always_scalarfields)",
    "created_at": "2020-08-06T19:16:07Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483483",
    "user": "https://github.com/mjungmath"
}
```

**Branch:** [u/gh-mjungmath/return_copy_always_scalarfields](https://github.com/sagemath/sagetrac-mirror/tree/u/gh-mjungmath/return_copy_always_scalarfields)



---

archive/issue_comments_483484.json:
```json
{
    "body": "**Commit:** [b7b0b3f338c4d64ef0229ec74c50c7e59a72454d](https://github.com/sagemath/sagetrac-mirror/commit/b7b0b3f338c4d64ef0229ec74c50c7e59a72454d)",
    "created_at": "2020-08-06T19:16:28Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483484",
    "user": "https://github.com/mkoeppe"
}
```

**Commit:** [b7b0b3f338c4d64ef0229ec74c50c7e59a72454d](https://github.com/sagemath/sagetrac-mirror/commit/b7b0b3f338c4d64ef0229ec74c50c7e59a72454d)



---

archive/issue_comments_483485.json:
```json
{
    "body": "<a id='comment:13'></a>\nAnother implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to \"copy-on-write\" semantics\n\n---\n**New commits:**\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/4f3b69f6159dbdc127070fce043a3428e09326c0\">4f3b69f</a></td><td><code>Trac 30291: simple checks for trivial cases in `_mul_`, `_add_` and _div_</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b7b0b3f338c4d64ef0229ec74c50c7e59a72454d\">b7b0b3f</a></td><td><code>return copies</code></td></tr></table>\n",
    "created_at": "2020-08-06T19:16:28Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483485",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:13'></a>
Another implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to "copy-on-write" semantics

---
**New commits:**
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/4f3b69f6159dbdc127070fce043a3428e09326c0">4f3b69f</a></td><td><code>Trac 30291: simple checks for trivial cases in `_mul_`, `_add_` and _div_</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b7b0b3f338c4d64ef0229ec74c50c7e59a72454d">b7b0b3f</a></td><td><code>return copies</code></td></tr></table>




---

archive/issue_comments_483486.json:
```json
{
    "body": "<a id='comment:14'></a>\nI've pushed my changes.",
    "created_at": "2020-08-06T19:17:44Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483486",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:14'></a>
I've pushed my changes.



---

archive/issue_comments_483487.json:
```json
{
    "body": "<a id='comment:15'></a>\nHere's the output of\n\n```\nsage: %prun %timeit f+0\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n   366666    1.064    0.000    1.584    0.000 chart_func.py:318(__init__)\n   366666    1.033    0.000    2.745    0.000 chart_func.py:879(copy)\n   122222    0.716    0.000    3.990    0.000 scalarfield.py:1480(copy)\n       10    0.505    0.051    5.468    0.547 <magic-timeit>:1(inner)\n   366666    0.395    0.000    0.463    0.000 chart.py:457(__getitem__)\n   122222    0.391    0.000    0.483    0.000 scalarfield.py:1060(__init__)\n   122222    0.176    0.000    0.543    0.000 scalarfield.py:1154(is_trivial_zero)\n    61111    0.150    0.000    2.201    0.000 scalarfield.py:2423(_add_)\n    61111    0.145    0.000    2.659    0.000 scalarfield.py:2632(_lmul_)\n    61111    0.111    0.000    0.230    0.000 chart_func.py:810(is_trivial_zero)\n    61111    0.103    0.000    2.762    0.000 unital_algebras.py:54(from_base_ring)\n   549999    0.099    0.000    0.099    0.000 {method 'parent' of 'sage.structure.element.Element' objects}\n   488888    0.087    0.000    0.087    0.000 {method 'items' of 'dict' objects}\n   122222    0.084    0.000    0.313    0.000 scalarfield.py:1212(<genexpr>)\n   366885    0.068    0.000    0.068    0.000 {built-in method builtins.isinstance}\n   366671    0.058    0.000    0.058    0.000 {built-in method builtins.len}\n    61111    0.052    0.000    0.073    0.000 calculus_method.py:278(is_trivial_zero)\n   122222    0.047    0.000    0.047    0.000 scalarfield.py:1327(_init_derived)\n    61111    0.046    0.000    0.046    0.000 chart_func.py:460(expr)\n   122222    0.045    0.000    0.045    0.000 subset.py:483(manifold)\n   122222    0.041    0.000    0.041    0.000 {method 'is_trivial_zero' of 'sage.symbolic.expression.Expression' objects}\n    61112    0.038    0.000    0.326    0.000 {built-in method builtins.all}\n    61111    0.015    0.000    0.015    0.000 {method 'values' of 'dict' objects}\n    ...\n```\n\nwith my pushed changes.",
    "created_at": "2020-08-06T19:22:37Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483487",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:15'></a>
Here's the output of

```
sage: %prun %timeit f+0

   Ordered by: internal time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
   366666    1.064    0.000    1.584    0.000 chart_func.py:318(__init__)
   366666    1.033    0.000    2.745    0.000 chart_func.py:879(copy)
   122222    0.716    0.000    3.990    0.000 scalarfield.py:1480(copy)
       10    0.505    0.051    5.468    0.547 <magic-timeit>:1(inner)
   366666    0.395    0.000    0.463    0.000 chart.py:457(__getitem__)
   122222    0.391    0.000    0.483    0.000 scalarfield.py:1060(__init__)
   122222    0.176    0.000    0.543    0.000 scalarfield.py:1154(is_trivial_zero)
    61111    0.150    0.000    2.201    0.000 scalarfield.py:2423(_add_)
    61111    0.145    0.000    2.659    0.000 scalarfield.py:2632(_lmul_)
    61111    0.111    0.000    0.230    0.000 chart_func.py:810(is_trivial_zero)
    61111    0.103    0.000    2.762    0.000 unital_algebras.py:54(from_base_ring)
   549999    0.099    0.000    0.099    0.000 {method 'parent' of 'sage.structure.element.Element' objects}
   488888    0.087    0.000    0.087    0.000 {method 'items' of 'dict' objects}
   122222    0.084    0.000    0.313    0.000 scalarfield.py:1212(<genexpr>)
   366885    0.068    0.000    0.068    0.000 {built-in method builtins.isinstance}
   366671    0.058    0.000    0.058    0.000 {built-in method builtins.len}
    61111    0.052    0.000    0.073    0.000 calculus_method.py:278(is_trivial_zero)
   122222    0.047    0.000    0.047    0.000 scalarfield.py:1327(_init_derived)
    61111    0.046    0.000    0.046    0.000 chart_func.py:460(expr)
   122222    0.045    0.000    0.045    0.000 subset.py:483(manifold)
   122222    0.041    0.000    0.041    0.000 {method 'is_trivial_zero' of 'sage.symbolic.expression.Expression' objects}
    61112    0.038    0.000    0.326    0.000 {built-in method builtins.all}
    61111    0.015    0.000    0.015    0.000 {method 'values' of 'dict' objects}
    ...
```

with my pushed changes.



---

archive/issue_comments_483488.json:
```json
{
    "body": "<a id='comment:16'></a>\n\n```diff\n        resu = type(self)(self.parent())\n-        for kk, vv in self._express.items():\n-            resu._express[kk] = vv\n+       resu._express = self._express.copy()\n        resu._expansion_symbol = self._expansion_symbol\n```\n\nis *slightly* faster btw:\n\n```\nsage: %timeit f+0\nThe slowest run took 5.64 times longer than the fastest. This could mean that an intermediate result is being cached.\n10000 loops, best of 5: 59.3 \u00b5s per loop\n```\n\nAnd changing back to `_is_zero` instead of `is_trivial_zero()` yields a further minimal improvement:\n\n```\nsage: %timeit f+0\nThe slowest run took 17.22 times longer than the fastest. This could mean that an intermediate result is being cached.\n10000 loops, best of 5: 55.5 \u00b5s per loop\n```",
    "created_at": "2020-08-06T19:38:29Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483488",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:16'></a>

```diff
        resu = type(self)(self.parent())
-        for kk, vv in self._express.items():
-            resu._express[kk] = vv
+       resu._express = self._express.copy()
        resu._expansion_symbol = self._expansion_symbol
```

is *slightly* faster btw:

```
sage: %timeit f+0
The slowest run took 5.64 times longer than the fastest. This could mean that an intermediate result is being cached.
10000 loops, best of 5: 59.3 µs per loop
```

And changing back to `_is_zero` instead of `is_trivial_zero()` yields a further minimal improvement:

```
sage: %timeit f+0
The slowest run took 17.22 times longer than the fastest. This could mean that an intermediate result is being cached.
10000 loops, best of 5: 55.5 µs per loop
```



---

archive/issue_comments_483489.json:
```json
{
    "body": "<a id='comment:17'></a>\nHowever, regarding my prun test, I think that\n\n```python\n        resu = type(self)(self.parent())\n```\n\nis the costly line. And that one shouldn't be an issue for more complicated expressions.",
    "created_at": "2020-08-06T19:45:21Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483489",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:17'></a>
However, regarding my prun test, I think that

```python
        resu = type(self)(self.parent())
```

is the costly line. And that one shouldn't be an issue for more complicated expressions.



---

archive/issue_comments_483490.json:
```json
{
    "body": "<a id='comment:18'></a>\nReplying to [mkoeppe](#comment%3A13):\n> Another implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to \"copy-on-write\" semantics\n\n\n\nSomething like this https://pypi.org/project/cowdict/ ?",
    "created_at": "2020-08-07T11:34:43Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483490",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:18'></a>
Replying to [mkoeppe](#comment%3A13):
> Another implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to "copy-on-write" semantics



Something like this https://pypi.org/project/cowdict/ ?



---

archive/issue_comments_483491.json:
```json
{
    "body": "<a id='comment:19'></a>\nI wonder, is copying the chart function even necessary? If new expressions are set/added, a new chart function is created anyway,isn't it? \n\nIf the user wants the chart function directly, one can create a copy there. Or we state all chart functions belonging to scalar fields automatically as immutable (available since #30310). If the user wants to modify it, he must copy it manually.",
    "created_at": "2020-08-07T11:55:39Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483491",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:19'></a>
I wonder, is copying the chart function even necessary? If new expressions are set/added, a new chart function is created anyway,isn't it? 

If the user wants the chart function directly, one can create a copy there. Or we state all chart functions belonging to scalar fields automatically as immutable (available since #30310). If the user wants to modify it, he must copy it manually.



---

archive/issue_comments_483492.json:
```json
{
    "body": "<a id='comment:20'></a>\nReplying to [gh-mjungmath](#comment%3A18):\n> Replying to [mkoeppe](#comment%3A13):\n> > Another implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to \"copy-on-write\" semantics\n\n> \n> Something like this https://pypi.org/project/cowdict/ ? \n\n\nYes, same idea but with a different granularity. Add a flag to `Component` instances that keeps track of whether it belongs to a unique `FiniteRankFreeModule` instance. In `FiniteRankFreeModule`, don't copy the component, just mark it non-unique; instead, each time that you want to mutate a component, check first whether it's unique and if not, first copy it, then mutate. But complex code like this should only be written if absolutely necessary.",
    "created_at": "2020-08-07T15:33:36Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483492",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:20'></a>
Replying to [gh-mjungmath](#comment%3A18):
> Replying to [mkoeppe](#comment%3A13):
> > Another implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to "copy-on-write" semantics

> 
> Something like this https://pypi.org/project/cowdict/ ? 


Yes, same idea but with a different granularity. Add a flag to `Component` instances that keeps track of whether it belongs to a unique `FiniteRankFreeModule` instance. In `FiniteRankFreeModule`, don't copy the component, just mark it non-unique; instead, each time that you want to mutate a component, check first whether it's unique and if not, first copy it, then mutate. But complex code like this should only be written if absolutely necessary.



---

archive/issue_comments_483493.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [mkoeppe](#comment%3A20):\n> Replying to [gh-mjungmath](#comment%3A18):\n> > Replying to [mkoeppe](#comment%3A13):\n> > > Another implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to \"copy-on-write\" semantics\n\n> > \n> > Something like this https://pypi.org/project/cowdict/ ? \n\n> \n> Yes, same idea but with a different granularity. Add a flag to `Component` instances that keeps track of whether it belongs to a unique `FiniteRankFreeModule` instance. In `FiniteRankFreeModule`, don't copy the component, just mark it non-unique; instead, each time that you want to mutate a component, check first whether it's unique and if not, first copy it, then mutate. But complex code like this should only be written if absolutely necessary.\n\n\nThat sounds like something we should attack.\n\nHowever, the ingredient of scalar fields is `ChartFunction`, not `Component`. What do you think about my proposal in [comment:19](#comment%3A19)?\n\nOr, alternatively, we apply the very same idea you proposed for `Component` to `ChartFunction`.\n\n**Edit:**\n> But complex code like this should only be written if absolutely necessary.\n\n\nI just overread this tiny but important part.\n\nWhat about simply making those `Components` immutable which are bound to tensors? Similar as my proposal in [comment:19](#comment%3A19). Each time the components of a tensor are changed via `set_comp` or `add_comp`, a whole new `Component` is created from scratch (`self._new_comp` is invoked). Making those components immutable which are used for tensors, wouldn't change much. Then we don't have to copy whole `Components` anymore, but only the dictionaries.",
    "created_at": "2020-08-07T15:44:31Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483493",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:21'></a>
Replying to [mkoeppe](#comment%3A20):
> Replying to [gh-mjungmath](#comment%3A18):
> > Replying to [mkoeppe](#comment%3A13):
> > > Another implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to "copy-on-write" semantics

> > 
> > Something like this https://pypi.org/project/cowdict/ ? 

> 
> Yes, same idea but with a different granularity. Add a flag to `Component` instances that keeps track of whether it belongs to a unique `FiniteRankFreeModule` instance. In `FiniteRankFreeModule`, don't copy the component, just mark it non-unique; instead, each time that you want to mutate a component, check first whether it's unique and if not, first copy it, then mutate. But complex code like this should only be written if absolutely necessary.


That sounds like something we should attack.

However, the ingredient of scalar fields is `ChartFunction`, not `Component`. What do you think about my proposal in [comment:19](#comment%3A19)?

Or, alternatively, we apply the very same idea you proposed for `Component` to `ChartFunction`.

**Edit:**
> But complex code like this should only be written if absolutely necessary.


I just overread this tiny but important part.

What about simply making those `Components` immutable which are bound to tensors? Similar as my proposal in [comment:19](#comment%3A19). Each time the components of a tensor are changed via `set_comp` or `add_comp`, a whole new `Component` is created from scratch (`self._new_comp` is invoked). Making those components immutable which are used for tensors, wouldn't change much. Then we don't have to copy whole `Components` anymore, but only the dictionaries.



---

archive/issue_comments_483494.json:
```json
{
    "body": "<a id='comment:22'></a>\nReplying to [gh-mjungmath](#comment%3A21):\n> Replying to [mkoeppe](#comment%3A20):\n> > Replying to [gh-mjungmath](#comment%3A18):\n> > > Replying to [mkoeppe](#comment%3A13):\n> > > > Another implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to \"copy-on-write\" semantics\n\n> > [...]\n> Add a flag to `Component` instances that keeps track of whether it belongs to a unique `FiniteRankFreeModule` instance. [...]\n> \n> That sounds like something we should attack.\n\n\nI think they're lower-hanging fruit for improving efficiency. For example, #30307 could make copying components faster.\n\n> However, the ingredient of scalar fields is `ChartFunction`, not `Component`. What do you think about my proposal in [comment:19](#comment%3A19)?\n\n\nSorry, I'm not up to speed on chart functions yet.",
    "created_at": "2020-08-07T16:04:48Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483494",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:22'></a>
Replying to [gh-mjungmath](#comment%3A21):
> Replying to [mkoeppe](#comment%3A20):
> > Replying to [gh-mjungmath](#comment%3A18):
> > > Replying to [mkoeppe](#comment%3A13):
> > > > Another implementation strategy if you consider `Components` objects an implementation detail that is not exposed to the user: Change them to "copy-on-write" semantics

> > [...]
> Add a flag to `Component` instances that keeps track of whether it belongs to a unique `FiniteRankFreeModule` instance. [...]
> 
> That sounds like something we should attack.


I think they're lower-hanging fruit for improving efficiency. For example, #30307 could make copying components faster.

> However, the ingredient of scalar fields is `ChartFunction`, not `Component`. What do you think about my proposal in [comment:19](#comment%3A19)?


Sorry, I'm not up to speed on chart functions yet.



---

archive/issue_events_270902.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-07T16:06:59Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "rename": {
        "from": "Always Return a Copy",
        "to": "Arithmetic on tensor module elements, manifold objects: Always Return a Copy"
    },
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270902"
}
```



---

archive/issue_comments_483495.json:
```json
{
    "body": "<a id='comment:24'></a>\nWatch my edit. Sorry for the chaos.",
    "created_at": "2020-08-07T16:10:02Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483495",
    "user": "https://github.com/mjungmath"
}
```

<a id='comment:24'></a>
Watch my edit. Sorry for the chaos.



---

archive/issue_comments_483496.json:
```json
{
    "body": "<a id='comment:25'></a>\nAnother useful thing for benchmarking is `%lprun`; see [this tutorial](https://doc.sagemath.org/html/en/thematic_tutorials/profiling.html#python-level-line-by-line-profiling-lprun).",
    "created_at": "2020-08-07T23:03:15Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483496",
    "user": "https://github.com/tscrim"
}
```

<a id='comment:25'></a>
Another useful thing for benchmarking is `%lprun`; see [this tutorial](https://doc.sagemath.org/html/en/thematic_tutorials/profiling.html#python-level-line-by-line-profiling-lprun).



---

archive/issue_events_270903.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-29T16:37:33Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270903"
}
```



---

archive/issue_events_270904.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-29T16:37:33Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270904"
}
```



---

archive/issue_events_270905.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270905"
}
```



---

archive/issue_events_270906.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270906"
}
```



---

archive/issue_comments_483497.json:
```json
{
    "body": "<a id='comment:27'></a>\nSetting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/30302#issuecomment-483497",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:27'></a>
Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_270907.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:43:17Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270907"
}
```



---

archive/issue_events_270908.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:43:17Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270908"
}
```



---

archive/issue_events_270909.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270909"
}
```



---

archive/issue_events_270910.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270910"
}
```



---

archive/issue_events_270911.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T00:06:20Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270911"
}
```



---

archive/issue_events_270912.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T00:06:20Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270912"
}
```



---

archive/issue_events_270913.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270913"
}
```



---

archive/issue_events_270914.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/30302",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/30302#event-270914"
}
```
