# Issue 30233: Axioms FinitelyGenerated, FinitelyGeneratedAs....

archive/issues_029996.json:
```json
{
    "body": "\n```\nsage: CR = CommutativeRings()\nsage: CR.FinitelyGenerated()\nValueError: FinitelyGenerated is ambiguous for Category of commutative rings.\nPlease use explicitly one of the FinitelyGeneratedAsXXX methods\n```\nHowever, there is only one such method: `FinitelyGeneratedAsMagma`.\n\nAlso:\n\n```\nsage: Modules(QQ).FinitelyGenerated()\nAttributeError: 'VectorSpaces_with_category' object has no attribute 'FinitelyGenerated'\n```\n\n\n\nCC:  @tscrim @nthiery @heluani\n\nBranch: public/finitely_generated_as_xxx_axioms\n\nStatus: new\n\nCommit: 2cf761420fbb107622a8febb4c6a88d1c4493fd9\n\nIssue created by migration from https://trac.sagemath.org/ticket/30233\n\n",
    "created_at": "2020-07-27T18:33:59Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-9.8",
    "title": "Axioms FinitelyGenerated, FinitelyGeneratedAs....",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/30233",
    "user": "https://github.com/mkoeppe"
}
```

```
sage: CR = CommutativeRings()
sage: CR.FinitelyGenerated()
ValueError: FinitelyGenerated is ambiguous for Category of commutative rings.
Please use explicitly one of the FinitelyGeneratedAsXXX methods
```
However, there is only one such method: `FinitelyGeneratedAsMagma`.

Also:

```
sage: Modules(QQ).FinitelyGenerated()
AttributeError: 'VectorSpaces_with_category' object has no attribute 'FinitelyGenerated'
```



CC:  @tscrim @nthiery @heluani

Branch: public/finitely_generated_as_xxx_axioms

Status: new

Commit: 2cf761420fbb107622a8febb4c6a88d1c4493fd9

Issue created by migration from https://trac.sagemath.org/ticket/30233





---

archive/issue_comments_587289.json:
```json
{
    "body": "<a id='comment:1'></a>\nI've implemented three more with `FinitelyGeneratedAsLieConformalAlgebra`, `FinitelyGeneratedAsVertexAlgebra` and `FinitelyGeneratedAsPoissonVertexAlgebra` I think it's only a matter of time until people (like me) are drawn to Sage and start implementing more. \n\nFor `Modules(QQ)` this was probably left intentionally like this. I can see a few reasons for this, since for modules over a `k` algebra `R`, `FiniteDimensional` means typically finite dimensional over `k`, it could be very confusing/tricky to have a `modules.SubcategoryMethods.FinitelyGenerated`.",
    "created_at": "2020-07-27T21:21:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587289",
    "user": "https://github.com/heluani"
}
```

<a id='comment:1'></a>
I've implemented three more with `FinitelyGeneratedAsLieConformalAlgebra`, `FinitelyGeneratedAsVertexAlgebra` and `FinitelyGeneratedAsPoissonVertexAlgebra` I think it's only a matter of time until people (like me) are drawn to Sage and start implementing more. 

For `Modules(QQ)` this was probably left intentionally like this. I can see a few reasons for this, since for modules over a `k` algebra `R`, `FiniteDimensional` means typically finite dimensional over `k`, it could be very confusing/tricky to have a `modules.SubcategoryMethods.FinitelyGenerated`.



---

archive/issue_comments_587290.json:
```json
{
    "body": "<a id='comment:2'></a>\nReplying to [heluani](#comment%3A1):\n> I've implemented three more with `FinitelyGeneratedAsLieConformalAlgebra`, `FinitelyGeneratedAsVertexAlgebra` and `FinitelyGeneratedAsPoissonVertexAlgebra` I think it's only a matter of time until people (like me) are drawn to Sage and start implementing more. \n\n\nYes, I saw them on your tickets, hence the cc.\n\n> For `Modules(QQ)` this was probably left intentionally like this. I can see a few reasons for this, since for modules over a `k` algebra `R`, `FiniteDimensional` means typically finite dimensional over `k`, it could be very confusing/tricky to have a `modules.SubcategoryMethods.FinitelyGenerated`. \n\n\nMaybe this example just provides an indication that `FinitelyGenerated` should not be a subcategory method.\n\nFor modules, I would like the category system to infer that `Modules(R).WithBasis().FinitelyGenerated() is Modules(R).FiniteDimensional()`, for example.",
    "created_at": "2020-07-27T21:46:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587290",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:2'></a>
Replying to [heluani](#comment%3A1):
> I've implemented three more with `FinitelyGeneratedAsLieConformalAlgebra`, `FinitelyGeneratedAsVertexAlgebra` and `FinitelyGeneratedAsPoissonVertexAlgebra` I think it's only a matter of time until people (like me) are drawn to Sage and start implementing more. 


Yes, I saw them on your tickets, hence the cc.

> For `Modules(QQ)` this was probably left intentionally like this. I can see a few reasons for this, since for modules over a `k` algebra `R`, `FiniteDimensional` means typically finite dimensional over `k`, it could be very confusing/tricky to have a `modules.SubcategoryMethods.FinitelyGenerated`. 


Maybe this example just provides an indication that `FinitelyGenerated` should not be a subcategory method.

For modules, I would like the category system to infer that `Modules(R).WithBasis().FinitelyGenerated() is Modules(R).FiniteDimensional()`, for example.



---

archive/issue_comments_587291.json:
```json
{
    "body": "<a id='comment:3'></a>\n> Maybe this example just provides an indication that `FinitelyGenerated` should not be a subcategory method.\n\n\nHaving it as a subcategory method is certainly an abuse. Back then, my decision to do this abuse was:\n- It really is meant as user-level syntactic sugar. Code or anyone wanting math reliability should use the long versions\n- It would be a pain to define FinitelyGenerated for all the variants of AdditiveMagmas and Magmas (e.g. (additive) semigroups, monoids, groups, finite or not, J/L/R-trivial or note, etc.\n\nMaybe it should just not exist.",
    "created_at": "2020-07-28T16:48:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587291",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:3'></a>
> Maybe this example just provides an indication that `FinitelyGenerated` should not be a subcategory method.


Having it as a subcategory method is certainly an abuse. Back then, my decision to do this abuse was:
- It really is meant as user-level syntactic sugar. Code or anyone wanting math reliability should use the long versions
- It would be a pain to define FinitelyGenerated for all the variants of AdditiveMagmas and Magmas (e.g. (additive) semigroups, monoids, groups, finite or not, J/L/R-trivial or note, etc.

Maybe it should just not exist.



---

archive/issue_comments_587292.json:
```json
{
    "body": "<a id='comment:4'></a>\n> For modules, I would like the category system to infer that `Modules(R).WithBasis().FinitelyGenerated() is Modules(R).FiniteDimensional()`, for example.\n\n\nThis should be doable with `Modules.WithBasis.FinitelyGenerated_extra_super_categories` returning `Modules(R).FiniteDimensional()`.\n\n(note: `Modules(R).WithBasis().FinitelyGenerated()` won't be `Modules(R).FiniteDimensional()` but `Modules(R).WithBasis().FiniteDimensional()`).\n\nAll of this said after not playing with categories for a long while. So take it with a grain of salt! In any case, I am super glad this is being extended and getting further attention.",
    "created_at": "2020-07-28T16:54:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587292",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:4'></a>
> For modules, I would like the category system to infer that `Modules(R).WithBasis().FinitelyGenerated() is Modules(R).FiniteDimensional()`, for example.


This should be doable with `Modules.WithBasis.FinitelyGenerated_extra_super_categories` returning `Modules(R).FiniteDimensional()`.

(note: `Modules(R).WithBasis().FinitelyGenerated()` won't be `Modules(R).FiniteDimensional()` but `Modules(R).WithBasis().FiniteDimensional()`).

All of this said after not playing with categories for a long while. So take it with a grain of salt! In any case, I am super glad this is being extended and getting further attention.



---

archive/issue_comments_587293.json:
```json
{
    "body": "<a id='comment:5'></a>\nReplying to [nthiery](#comment%3A4):\n> > For modules, I would like the category system to infer that `Modules(R).WithBasis().FinitelyGenerated() is Modules(R).FiniteDimensional()`, for example.\n\n> \n> This should be doable with `Modules.WithBasis.FinitelyGenerated_extra_super_categories` returning `Modules(R).FiniteDimensional()`.\n\n\nThanks! I'll try this.\n\n> (note: `Modules(R).WithBasis().FinitelyGenerated()` won't be `Modules(R).FiniteDimensional()` but `Modules(R).WithBasis().FiniteDimensional()`).\n\n\nRight, that's what I meant.",
    "created_at": "2020-07-28T17:03:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587293",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:5'></a>
Replying to [nthiery](#comment%3A4):
> > For modules, I would like the category system to infer that `Modules(R).WithBasis().FinitelyGenerated() is Modules(R).FiniteDimensional()`, for example.

> 
> This should be doable with `Modules.WithBasis.FinitelyGenerated_extra_super_categories` returning `Modules(R).FiniteDimensional()`.


Thanks! I'll try this.

> (note: `Modules(R).WithBasis().FinitelyGenerated()` won't be `Modules(R).FiniteDimensional()` but `Modules(R).WithBasis().FiniteDimensional()`).


Right, that's what I meant.



---

archive/issue_comments_587294.json:
```json
{
    "body": "<a id='comment:6'></a>\nBy the way, I am trying to figure out what exactly is meant by the category `Modules(R).FiniteDimensional()`. ~~Is this intended to be imply \"free\" already?~~",
    "created_at": "2020-07-28T17:11:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587294",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:6'></a>
By the way, I am trying to figure out what exactly is meant by the category `Modules(R).FiniteDimensional()`. ~~Is this intended to be imply "free" already?~~



---

archive/issue_comments_587295.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [heluani](#comment%3A1):\n> for modules over a `k` algebra `R`, `FiniteDimensional` means typically finite dimensional over `k`, it could be very confusing/tricky to have a `modules.SubcategoryMethods.FinitelyGenerated`. \n\n\nReimundo explained it above -- but then (1) should `Modules(R).FiniteDimensional()` be defined at all if `R` is not an algebra over a field?\n\nAlso, (2) the category system does not seem to know about it:\n\n```\nsage: QQ['x'] in Algebras(QQ)\nTrue\nsage: Modules(QQ['x']).FiniteDimensional() & Modules(QQ)\nJoin of Category of finite dimensional modules over Rational Field and Category of finite dimensional modules over Univariate Polynomial Ring in x over Rational Field and Category of vector spaces over Rational Field\n```",
    "created_at": "2020-07-28T18:23:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587295",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:7'></a>
Replying to [heluani](#comment%3A1):
> for modules over a `k` algebra `R`, `FiniteDimensional` means typically finite dimensional over `k`, it could be very confusing/tricky to have a `modules.SubcategoryMethods.FinitelyGenerated`. 


Reimundo explained it above -- but then (1) should `Modules(R).FiniteDimensional()` be defined at all if `R` is not an algebra over a field?

Also, (2) the category system does not seem to know about it:

```
sage: QQ['x'] in Algebras(QQ)
True
sage: Modules(QQ['x']).FiniteDimensional() & Modules(QQ)
Join of Category of finite dimensional modules over Rational Field and Category of finite dimensional modules over Univariate Polynomial Ring in x over Rational Field and Category of vector spaces over Rational Field
```



---

archive/issue_comments_587296.json:
```json
{
    "body": "<a id='comment:8'></a>\nI am not sure why I am not getting emails from most trac tickets that I am cc'd but from some I do (I missed this conversation for example). \n\nThere is a `WARNING` block in the code for modules.\n\n> Outside of the context of symmetric modules over a commutative\n> ring, the specifications of this category are fuzzy and not\n> yet set in stone (see below). The code in this category and\n> its subcategories is therefore prone to bugs or arbitrary\n> limitations in this case.\n\n\nWhich probably covers this. By browsing at the code in modules and modules with basis it looks to me that every method that is implemented works if `FiniteDimensional` just means \"Finitely generated and free\" as an `R`-module. \n\nI do not think that anything in the category files for modules refers to any of the list of probable definition of \"dimension\" for a module over an arbitrary ring (like \"Krull\" dimension for modules over a commutative ring, or globa dimension, projective dimension, etc. in other contexts) \n\nSince nothing is really implemented under the class `Modules.FiniteDimensional` besides the fact that a finite dimensional module over a finite ring is finite. It seems to me that all implemented methods are in `Modules.WithBasis.FiniteDimensional` which implies they are Free modules.",
    "created_at": "2020-07-29T01:04:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587296",
    "user": "https://github.com/heluani"
}
```

<a id='comment:8'></a>
I am not sure why I am not getting emails from most trac tickets that I am cc'd but from some I do (I missed this conversation for example). 

There is a `WARNING` block in the code for modules.

> Outside of the context of symmetric modules over a commutative
> ring, the specifications of this category are fuzzy and not
> yet set in stone (see below). The code in this category and
> its subcategories is therefore prone to bugs or arbitrary
> limitations in this case.


Which probably covers this. By browsing at the code in modules and modules with basis it looks to me that every method that is implemented works if `FiniteDimensional` just means "Finitely generated and free" as an `R`-module. 

I do not think that anything in the category files for modules refers to any of the list of probable definition of "dimension" for a module over an arbitrary ring (like "Krull" dimension for modules over a commutative ring, or globa dimension, projective dimension, etc. in other contexts) 

Since nothing is really implemented under the class `Modules.FiniteDimensional` besides the fact that a finite dimensional module over a finite ring is finite. It seems to me that all implemented methods are in `Modules.WithBasis.FiniteDimensional` which implies they are Free modules.



---

archive/issue_comments_587297.json:
```json
{
    "body": "<a id='comment:9'></a>\nI wanted to ask you your opinion on something. Since this has come up in the Lie Conformal Algebras ticket #30032 comment 30 and I suppose eventually this should scale correctly. \n\nI think that whatever category of parents `Cs()` where there is a natural notion of finitely generated object, this should be implemented as `Cs().FinitelyGenerated()`. Here by natural I mean that no mathematician would be confused. A prototypical example is `Rings()`. Of course one can think of a ring which is finitely generated as an additive magma, but in this case this would be explicit, when we simply say `R` is finitely generated we mean that every element of `R` can be written as a sum of elements of the form `a_1 a_2...a_n` for `a_i` in a finite set of generators. \n\nNow on the other hand it seems ridiculous to implement axioms `FinitelyGeneratedAs*` for `*` meaning an algebra over closely related operads. This does not scale correctly and eventually we will end up with a lot of axioms in `category_with_axiom.py`. So I suggest we implement at least these two generic axioms:\n\n1. For objects that are both a (multiplicative) magma and an additive magma and is distributive, implement something like `FinitelyGeneratedAsDistributiveMagmas` which means every element is written as sums of elements of the form `a_1...a_n` but now parenthesis are put anywhere. \n\n2. For objects as in 1. but in an `R`-linear category, that is they are `R`-modules and they have an `R`-bilinear operation `*` such that the sum is distributive. Then implement `FinitelyGeneratedAsDistributiveAlgebras` (perhaps a more generic name is in order and this is unfortunate that algebra means associative in Sage) to mean exactly as above but instead of sums, linear combinations with coefficients in `R`. \n\nThen for example `Rings().FinitelyGenerated()` should call `FinitelyGeneratedAsDistributiveMagmas` while `LieAlgebras().FinitelyGenerated()` and `Algebras(QQ).FinitelyGenerated()` for example should call `FinitelyGeneratedAsDistributiveAlgebras`. \n\nI can see also a lot of uses for a third option \n3. Objects as in 2. but with a derivation `D` of the operation `*` over the ring `R`. In this case we can implement `FinitelyGeneratedAsDifferentialAlgebra` (again different name because differential nowadays means with a differential not like Ritt's original definition) Then for example all my three objects `LieConformalAlgebras`, `VertexAlgebras` and `PoissonVertexAlgebras` would call the same axiom `FinitelyGeneratedAsDifferentialAlgebra` instead of having to implement three of them. \n\nThis post came to mind because Travis is suggesting in #30032 to implement something like `FinitelyGeneratedAsBracketAlgebra` but I think there is no need to have `Bracket` here mean something specific besides being a bilinear operation that is distributive as in 2.",
    "created_at": "2020-08-03T14:07:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587297",
    "user": "https://github.com/heluani"
}
```

<a id='comment:9'></a>
I wanted to ask you your opinion on something. Since this has come up in the Lie Conformal Algebras ticket #30032 comment 30 and I suppose eventually this should scale correctly. 

I think that whatever category of parents `Cs()` where there is a natural notion of finitely generated object, this should be implemented as `Cs().FinitelyGenerated()`. Here by natural I mean that no mathematician would be confused. A prototypical example is `Rings()`. Of course one can think of a ring which is finitely generated as an additive magma, but in this case this would be explicit, when we simply say `R` is finitely generated we mean that every element of `R` can be written as a sum of elements of the form `a_1 a_2...a_n` for `a_i` in a finite set of generators. 

Now on the other hand it seems ridiculous to implement axioms `FinitelyGeneratedAs*` for `*` meaning an algebra over closely related operads. This does not scale correctly and eventually we will end up with a lot of axioms in `category_with_axiom.py`. So I suggest we implement at least these two generic axioms:

1. For objects that are both a (multiplicative) magma and an additive magma and is distributive, implement something like `FinitelyGeneratedAsDistributiveMagmas` which means every element is written as sums of elements of the form `a_1...a_n` but now parenthesis are put anywhere. 

2. For objects as in 1. but in an `R`-linear category, that is they are `R`-modules and they have an `R`-bilinear operation `*` such that the sum is distributive. Then implement `FinitelyGeneratedAsDistributiveAlgebras` (perhaps a more generic name is in order and this is unfortunate that algebra means associative in Sage) to mean exactly as above but instead of sums, linear combinations with coefficients in `R`. 

Then for example `Rings().FinitelyGenerated()` should call `FinitelyGeneratedAsDistributiveMagmas` while `LieAlgebras().FinitelyGenerated()` and `Algebras(QQ).FinitelyGenerated()` for example should call `FinitelyGeneratedAsDistributiveAlgebras`. 

I can see also a lot of uses for a third option 
3. Objects as in 2. but with a derivation `D` of the operation `*` over the ring `R`. In this case we can implement `FinitelyGeneratedAsDifferentialAlgebra` (again different name because differential nowadays means with a differential not like Ritt's original definition) Then for example all my three objects `LieConformalAlgebras`, `VertexAlgebras` and `PoissonVertexAlgebras` would call the same axiom `FinitelyGeneratedAsDifferentialAlgebra` instead of having to implement three of them. 

This post came to mind because Travis is suggesting in #30032 to implement something like `FinitelyGeneratedAsBracketAlgebra` but I think there is no need to have `Bracket` here mean something specific besides being a bilinear operation that is distributive as in 2.



---

archive/issue_comments_587298.json:
```json
{
    "body": "<a id='comment:10'></a>\nReplying to [heluani](#comment%3A9):\n> I think that whatever category of parents `Cs()` where there is a natural notion of finitely generated object, this should be implemented as `Cs().FinitelyGenerated()`. Here by natural I mean that no mathematician would be confused. A prototypical example is `Rings()`. Of course one can think of a ring which is finitely generated as an additive magma, but in this case this would be explicit, when we simply say `R` is finitely generated we mean that every element of `R` can be written as a sum of elements of the form `a_1 a_2...a_n` for `a_i` in a finite set of generators. \n\n\nYes, I agree.\n\n> Now on the other hand it seems ridiculous to implement axioms `FinitelyGeneratedAs*` for `*` meaning an algebra over closely related operads. This does not scale correctly and eventually we will end up with a lot of axioms in `category_with_axiom.py`.\n\n\nYes, this (scaling) has also been a concern of mine -- and I was secretly hoping that the discussion with Travis on your ticket #30032 would clarify it for me...\n\n> So I suggest we implement at least these two generic axioms:\n> \n> 1. For objects that are both a (multiplicative) magma and an additive magma and is distributive, implement something like `FinitelyGeneratedAsDistributiveMagmas` which means every element is written as sums of elements of the form `a_1...a_n` but now parenthesis are put anywhere. \n> \n> 2. For objects as in 1. but in an `R`-linear category, that is they are `R`-modules and they have an `R`-bilinear operation `*` such that the sum is distributive. Then implement `FinitelyGeneratedAsDistributiveAlgebras` (perhaps a more generic name is in order and this is unfortunate that algebra means associative in Sage)\n\n\n... perhaps it's time to introduce the word `Lgebra` for not-necessarily associative algebras ...\n\n> to mean exactly as above but instead of sums, linear combinations with coefficients in `R`. \n> \n> Then for example `Rings().FinitelyGenerated()` should call `FinitelyGeneratedAsDistributiveMagmas` while `LieAlgebras().FinitelyGenerated()` and `Algebras(QQ).FinitelyGenerated()` for example should call `FinitelyGeneratedAsDistributiveAlgebras`. \n\n\nThis all sounds great to me.\n\n> I can see also a lot of uses for a third option \n> 3. Objects as in 2. but with a derivation `D` of the operation `*` over the ring `R`. In this case we can implement `FinitelyGeneratedAsDifferentialAlgebra` (again different name because differential nowadays means with a differential not like Ritt's original definition) Then for example all my three objects `LieConformalAlgebras`, `VertexAlgebras` and `PoissonVertexAlgebras` would call the same axiom `FinitelyGeneratedAsDifferentialAlgebra` instead of having to implement three of them. \n\n\nWhen you have a chance, could you elaborate on 3 in simpler terms? This one is going over the top of my head...",
    "created_at": "2020-08-03T18:08:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587298",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:10'></a>
Replying to [heluani](#comment%3A9):
> I think that whatever category of parents `Cs()` where there is a natural notion of finitely generated object, this should be implemented as `Cs().FinitelyGenerated()`. Here by natural I mean that no mathematician would be confused. A prototypical example is `Rings()`. Of course one can think of a ring which is finitely generated as an additive magma, but in this case this would be explicit, when we simply say `R` is finitely generated we mean that every element of `R` can be written as a sum of elements of the form `a_1 a_2...a_n` for `a_i` in a finite set of generators. 


Yes, I agree.

> Now on the other hand it seems ridiculous to implement axioms `FinitelyGeneratedAs*` for `*` meaning an algebra over closely related operads. This does not scale correctly and eventually we will end up with a lot of axioms in `category_with_axiom.py`.


Yes, this (scaling) has also been a concern of mine -- and I was secretly hoping that the discussion with Travis on your ticket #30032 would clarify it for me...

> So I suggest we implement at least these two generic axioms:
> 
> 1. For objects that are both a (multiplicative) magma and an additive magma and is distributive, implement something like `FinitelyGeneratedAsDistributiveMagmas` which means every element is written as sums of elements of the form `a_1...a_n` but now parenthesis are put anywhere. 
> 
> 2. For objects as in 1. but in an `R`-linear category, that is they are `R`-modules and they have an `R`-bilinear operation `*` such that the sum is distributive. Then implement `FinitelyGeneratedAsDistributiveAlgebras` (perhaps a more generic name is in order and this is unfortunate that algebra means associative in Sage)


... perhaps it's time to introduce the word `Lgebra` for not-necessarily associative algebras ...

> to mean exactly as above but instead of sums, linear combinations with coefficients in `R`. 
> 
> Then for example `Rings().FinitelyGenerated()` should call `FinitelyGeneratedAsDistributiveMagmas` while `LieAlgebras().FinitelyGenerated()` and `Algebras(QQ).FinitelyGenerated()` for example should call `FinitelyGeneratedAsDistributiveAlgebras`. 


This all sounds great to me.

> I can see also a lot of uses for a third option 
> 3. Objects as in 2. but with a derivation `D` of the operation `*` over the ring `R`. In this case we can implement `FinitelyGeneratedAsDifferentialAlgebra` (again different name because differential nowadays means with a differential not like Ritt's original definition) Then for example all my three objects `LieConformalAlgebras`, `VertexAlgebras` and `PoissonVertexAlgebras` would call the same axiom `FinitelyGeneratedAsDifferentialAlgebra` instead of having to implement three of them. 


When you have a chance, could you elaborate on 3 in simpler terms? This one is going over the top of my head...



---

archive/issue_comments_587299.json:
```json
{
    "body": "<a id='comment:11'></a>\nReplying to [mkoeppe](#comment%3A10): \n> ... perhaps it's time to introduce the word `Lgebra` for not-necessarily associative algebras ...\n\n\nThe thing is that in every example that I can think of for 2. it is irrelevant if the algebra is associative or not, on every non-associative example that I know of (Jordan, Lie, Vertex, Left/Right Symmetric, Leibniz, etc) the notion of finite generation is independent of the order of parentheses in `a_1...a_n`.  So for the purposes of this axiom it is the same being a finitely generated associative algebra, or Lie algebra, or Jordan algebra or Left/Right Symmetric algebra, etc. only matters to have a bilinear operation which distributes over sums. \n\n> When you have a chance, could you elaborate on 3 in simpler terms? This one is going over the top of my head...\n> \n\nSure, here is a different example but shows already a closely related phenomenom: the point is that often time you have an algebra `A` which has a bilinear operation (say `[,]` for this example) over a ring (say `k`). But `A` happens to be a module over a `k` algebra `R`, which is finitely generated over `R` but not finitely generated over `k`. The prototypical example of this would be `A` smooth vector fields on a manifold `X`. Then `k` is the Real numbers, and `R` is the ring of smooth functions over `X`. The operation `[,]` is `k`-linear but it is not `R` linear. As a Lie algebra over `k`, `A` is not finitely generated, but as a Lie algebroid over `R` it is. \n\nNow the exact example that I meant in 3. Consider a differential polynomial algebra, that is a polynomial algebra `k[x, x', x'', ...]` this is a polynomial algebra in infinitely many variables, `x` and all of its formal derivatives. So this algebra has a derivation `T x^n = x^{n+1}`. This algebra is infinitely generated as an algebra over `k`, but it is not a finitely generated algebra over `k[T]` since the multiplication is not `k[T]` linear. However, every element can be written as linear combination of `1, x` or products of these two and their derivatives. This situation is very closely related to the above one and it happens everywhere from the study of arc spaces, motivic integration etc, to algebraic geometry/representation theory of infinite dimensional algebras.\n\nI apologize if this is getting to \"chatty\" for a trac ticket.",
    "created_at": "2020-08-03T19:27:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587299",
    "user": "https://github.com/heluani"
}
```

<a id='comment:11'></a>
Replying to [mkoeppe](#comment%3A10): 
> ... perhaps it's time to introduce the word `Lgebra` for not-necessarily associative algebras ...


The thing is that in every example that I can think of for 2. it is irrelevant if the algebra is associative or not, on every non-associative example that I know of (Jordan, Lie, Vertex, Left/Right Symmetric, Leibniz, etc) the notion of finite generation is independent of the order of parentheses in `a_1...a_n`.  So for the purposes of this axiom it is the same being a finitely generated associative algebra, or Lie algebra, or Jordan algebra or Left/Right Symmetric algebra, etc. only matters to have a bilinear operation which distributes over sums. 

> When you have a chance, could you elaborate on 3 in simpler terms? This one is going over the top of my head...
> 

Sure, here is a different example but shows already a closely related phenomenom: the point is that often time you have an algebra `A` which has a bilinear operation (say `[,]` for this example) over a ring (say `k`). But `A` happens to be a module over a `k` algebra `R`, which is finitely generated over `R` but not finitely generated over `k`. The prototypical example of this would be `A` smooth vector fields on a manifold `X`. Then `k` is the Real numbers, and `R` is the ring of smooth functions over `X`. The operation `[,]` is `k`-linear but it is not `R` linear. As a Lie algebra over `k`, `A` is not finitely generated, but as a Lie algebroid over `R` it is. 

Now the exact example that I meant in 3. Consider a differential polynomial algebra, that is a polynomial algebra `k[x, x', x'', ...]` this is a polynomial algebra in infinitely many variables, `x` and all of its formal derivatives. So this algebra has a derivation `T x^n = x^{n+1}`. This algebra is infinitely generated as an algebra over `k`, but it is not a finitely generated algebra over `k[T]` since the multiplication is not `k[T]` linear. However, every element can be written as linear combination of `1, x` or products of these two and their derivatives. This situation is very closely related to the above one and it happens everywhere from the study of arc spaces, motivic integration etc, to algebraic geometry/representation theory of infinite dimensional algebras.

I apologize if this is getting to "chatty" for a trac ticket.



---

archive/issue_comments_587300.json:
```json
{
    "body": "<a id='comment:12'></a>\nReplying to [heluani](#comment%3A11):\n> I apologize if this is getting to \"chatty\" for a trac ticket. \n\n\nTo the contrary -- this was very helpful. Thanks for taking the time to explain!",
    "created_at": "2020-08-03T19:38:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587300",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:12'></a>
Replying to [heluani](#comment%3A11):
> I apologize if this is getting to "chatty" for a trac ticket. 


To the contrary -- this was very helpful. Thanks for taking the time to explain!



---

archive/issue_comments_587301.json:
```json
{
    "body": "<a id='comment:13'></a>\nIn fact the more I think about this, I convince myself that we only need one axiom instead of 1.--3. above: `FinitelyGeneratedAsDistributiveMagma` that is called as `Cs().FinitelyGenerated()` for every Category `Cs()` whose objects are as follows\n\na. There is a ring and its algebra `k -> R`. \nb. An object of the category is an `R` module. \nc. The object has a `k`-bilinear operation `*` that distributes over sums. \n\nThen the category of finitely generated objects is the category of objects such that there exists a finite number of elements `a_i` and every element can be written as linear combination with coefficients in `k` of elements of the form `(r_1.a_1)*(r_2.a_2)*....*(r_n.a_n)` where `r_i` is in `R` and arbitrary association of the `*` operation. \n\nFor non-linear categories like Rings, we would have `k = R = ZZ`. For linear categories like Lie/Associative/Jordan/LeftSymmetric-algebras we would have `k=R`. For the differential categories as I mentioned above we would have `k` and `R` arbitrary. The point is that this really encodes every example even from the point of view of implementing this in Sage. \n\nHowever I think that there may be a difficulty in the current implementation of `Rings` cause the category of Rings is not a category over the base ring `ZZ`. Anyway I think this example convinces me that 2. and 3. should be one axiom for algebras with a distributive operation that is called on the `SubcategoryMethods.FinitelyGenerated()` since this methods can be overriden in subcategories this is not a problem. \n\nFor example. `LieAlgebras(k).FinitelyGenerated()` would use the `k=R` version of the axiom. while `LieAlgebroids(R).FinitelyGenerated()` for a `k` algebra `R`, even though it is a subcategory of `LieAlgebras(k)` would override it to call the `k, R` version of the axiom. This is purely semantics of course since the Sage implementation of the axiom doesn't care about `k` nor `R`.",
    "created_at": "2020-08-03T20:28:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587301",
    "user": "https://github.com/heluani"
}
```

<a id='comment:13'></a>
In fact the more I think about this, I convince myself that we only need one axiom instead of 1.--3. above: `FinitelyGeneratedAsDistributiveMagma` that is called as `Cs().FinitelyGenerated()` for every Category `Cs()` whose objects are as follows

a. There is a ring and its algebra `k -> R`. 
b. An object of the category is an `R` module. 
c. The object has a `k`-bilinear operation `*` that distributes over sums. 

Then the category of finitely generated objects is the category of objects such that there exists a finite number of elements `a_i` and every element can be written as linear combination with coefficients in `k` of elements of the form `(r_1.a_1)*(r_2.a_2)*....*(r_n.a_n)` where `r_i` is in `R` and arbitrary association of the `*` operation. 

For non-linear categories like Rings, we would have `k = R = ZZ`. For linear categories like Lie/Associative/Jordan/LeftSymmetric-algebras we would have `k=R`. For the differential categories as I mentioned above we would have `k` and `R` arbitrary. The point is that this really encodes every example even from the point of view of implementing this in Sage. 

However I think that there may be a difficulty in the current implementation of `Rings` cause the category of Rings is not a category over the base ring `ZZ`. Anyway I think this example convinces me that 2. and 3. should be one axiom for algebras with a distributive operation that is called on the `SubcategoryMethods.FinitelyGenerated()` since this methods can be overriden in subcategories this is not a problem. 

For example. `LieAlgebras(k).FinitelyGenerated()` would use the `k=R` version of the axiom. while `LieAlgebroids(R).FinitelyGenerated()` for a `k` algebra `R`, even though it is a subcategory of `LieAlgebras(k)` would override it to call the `k, R` version of the axiom. This is purely semantics of course since the Sage implementation of the axiom doesn't care about `k` nor `R`.



---

archive/issue_comments_587302.json:
```json
{
    "body": "Changing commit from \"\" to \"2cf761420fbb107622a8febb4c6a88d1c4493fd9\"",
    "created_at": "2020-08-06T19:07:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587302",
    "user": "https://github.com/heluani"
}
```

Changing commit from "" to "2cf761420fbb107622a8febb4c6a88d1c4493fd9"



---

archive/issue_comments_587303.json:
```json
{
    "body": "<a id='comment:14'></a>\nNew commits:\n|                                                                                                                                          |                                            |\n|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|\n|[2cf7614](https://github.com/sagemath/sagetrac-mirror/commit/2cf761420fbb107622a8febb4c6a88d1c4493fd9)|`Implement generic FinitelyGenerated axioms`|",
    "created_at": "2020-08-06T19:07:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587303",
    "user": "https://github.com/heluani"
}
```

<a id='comment:14'></a>
New commits:
|                                                                                                                                          |                                            |
|------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------|
|[2cf7614](https://github.com/sagemath/sagetrac-mirror/commit/2cf761420fbb107622a8febb4c6a88d1c4493fd9)|`Implement generic FinitelyGenerated axioms`|



---

archive/issue_comments_587304.json:
```json
{
    "body": "Changing branch from \"\" to \"public/finitely_generated_as_xxx_axioms\"",
    "created_at": "2020-08-06T19:07:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587304",
    "user": "https://github.com/heluani"
}
```

Changing branch from "" to "public/finitely_generated_as_xxx_axioms"



---

archive/issue_comments_587305.json:
```json
{
    "body": "<a id='comment:15'></a>\nI thought I'll add a little test to show some of the difficulty that may arise if implementing generic `FinitelyGenerated` methods. Here's the commit message from that branch\n\nThis commit adds three axioms\n\n1. `FinitelyGeneratedAsDistributiveMagma`. An object `C` with two magmatic\n   operations `*` and `+`, such that `*` distributes over `+` is said to\n   be finitely generated if there exists a finite subset `A \\subset C`\n   such that every element can be written as sum of elements of the form\n   `a_1*...*a_n` with any parenthesis assignment and `a_i \\in A` for\n   every `i`\n2. `FinitelyGeneratedAsAlgebra`. An object as `C` above with the\n   which in addition is a `k`-module and the operation `*` is\n   `k`-bilinear is finitely generated if every element can be written as\n   a linear combination of elements as in 1.\n3. `FinitelyGeneratedAsLieAlgebroid`. An object as `C` above, with an\n   additional structure of being an `R`-module for a `k`-algebra `R`.\n   `C` is called finitely generated if every element can be written as a\n   `k`-linear combination of elements of the form\n   `(r_1 a_1)*....*(r_n a_n)` with `a_i \\in A` and `r_i \\in R` for every\n   `i` and any parenthesis assignment.\n\nIt adds a bare class `FinitelyGeneratedRings` and implements\n`Rings().FinitelyGenerated()` and `LieAlgebras().FinitelyGenerated()`\njust to show the difficulties that we would encounter with this generic\napproach: for a Lie algebra, `gens` is not what is meant by \"generators\"\nusually, but what is meant by a \"basis\". Of course finite `gens` implies\n`FinitelyGeneratedAsAlgebra` but not conversely.\n\nThe same abuse is currently used in `LieConformalAlgebras` where `gens`\nmeans a set of generators as an `R`-module (notation as in 3. above). So\nagain finite `gens` implies `FinitelyGeneratedAsAlgebroid` but not\nconversely.",
    "created_at": "2020-08-06T19:09:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587305",
    "user": "https://github.com/heluani"
}
```

<a id='comment:15'></a>
I thought I'll add a little test to show some of the difficulty that may arise if implementing generic `FinitelyGenerated` methods. Here's the commit message from that branch

This commit adds three axioms

1. `FinitelyGeneratedAsDistributiveMagma`. An object `C` with two magmatic
   operations `*` and `+`, such that `*` distributes over `+` is said to
   be finitely generated if there exists a finite subset `A \subset C`
   such that every element can be written as sum of elements of the form
   `a_1*...*a_n` with any parenthesis assignment and `a_i \in A` for
   every `i`
2. `FinitelyGeneratedAsAlgebra`. An object as `C` above with the
   which in addition is a `k`-module and the operation `*` is
   `k`-bilinear is finitely generated if every element can be written as
   a linear combination of elements as in 1.
3. `FinitelyGeneratedAsLieAlgebroid`. An object as `C` above, with an
   additional structure of being an `R`-module for a `k`-algebra `R`.
   `C` is called finitely generated if every element can be written as a
   `k`-linear combination of elements of the form
   `(r_1 a_1)*....*(r_n a_n)` with `a_i \in A` and `r_i \in R` for every
   `i` and any parenthesis assignment.

It adds a bare class `FinitelyGeneratedRings` and implements
`Rings().FinitelyGenerated()` and `LieAlgebras().FinitelyGenerated()`
just to show the difficulties that we would encounter with this generic
approach: for a Lie algebra, `gens` is not what is meant by "generators"
usually, but what is meant by a "basis". Of course finite `gens` implies
`FinitelyGeneratedAsAlgebra` but not conversely.

The same abuse is currently used in `LieConformalAlgebras` where `gens`
means a set of generators as an `R`-module (notation as in 3. above). So
again finite `gens` implies `FinitelyGeneratedAsAlgebroid` but not
conversely.



---

archive/issue_events_095981.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2020-08-13T17:11:30Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95981"
}
```



---

archive/issue_events_095982.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95982"
}
```



---

archive/issue_events_095983.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-02-13T20:51:01Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95983"
}
```



---

archive/issue_comments_587306.json:
```json
{
    "body": "<a id='comment:17'></a>\nSetting new milestone based on a cursory review of ticket status, priority, and last modification date.",
    "created_at": "2021-02-13T20:51:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/30233#issuecomment-587306",
    "user": "https://github.com/mkoeppe"
}
```

<a id='comment:17'></a>
Setting new milestone based on a cursory review of ticket status, priority, and last modification date.



---

archive/issue_events_095984.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:43:17Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95984"
}
```



---

archive/issue_events_095985.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-07-19T01:43:17Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95985"
}
```



---

archive/issue_events_095986.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.5",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95986"
}
```



---

archive/issue_events_095987.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2021-12-14T02:04:49Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95987"
}
```



---

archive/issue_events_095988.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T00:06:20Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.6",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95988"
}
```



---

archive/issue_events_095989.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-03-05T00:06:20Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95989"
}
```



---

archive/issue_events_095990.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.7",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95990"
}
```



---

archive/issue_events_095991.json:
```json
{
    "actor": "https://github.com/mkoeppe",
    "created_at": "2022-08-31T02:51:13Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/30233",
    "milestone": "sage-9.8",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/30233#event-95991"
}
```
