# Issue 21088: k-regular sequences: subsequences, forward/backward difference

Issue created by migration from Trac.

Original creator: dkrenn

Original creation time: 2016-08-24 08:56:30

CC:  galipnik

Implement subsequences and forward/backward differences


---

Comment by dkrenn created at 2016-08-24 08:57:18

Last 10 new commits:


---

Comment by git created at 2016-08-25 10:55:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-08-25 11:28:46

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2016-08-25 11:31:04

Changing status from new to needs_review.


---

Comment by git created at 2016-08-26 11:30:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-08-26 11:55:53

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2017-01-05 12:12:44

Changing status from needs_review to needs_work.


---

Comment by cheuberg created at 2017-01-05 12:12:44

patchbot python3 plugin fails


---

Comment by git created at 2017-01-24 13:13:51

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dkrenn created at 2017-01-24 13:14:21

Changing status from needs_work to needs_review.


---

Comment by dkrenn created at 2017-01-24 13:14:21

Replying to [comment:8 cheuberg]:
> patchbot python3 plugin fails

Fixed.


---

Comment by git created at 2018-04-06 07:41:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2019-03-29 08:50:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-05-11 14:04:51

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2021-06-25 11:19:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-25 12:09:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2021-06-25 12:10:54

Merged dependencies and adapted code due to changes in these dependencies.


---

Comment by cheuberg created at 2021-07-09 10:22:22

Changing status from needs_review to needs_work.


---

Comment by cheuberg created at 2021-07-09 10:22:22

1. `pad_right`: One-sentence description: the syntax ```zero``s` does not yield the desired formatting: The output is `zero``s to have at least the given ``length.`

2. `pad_right`: PEP8: Missing spaces after commas in input of examples and tests.

3. `subsequence`: Description of the input parameter `b`: The meaning of `c_j(a_n+b_j)` is unclear to me.

4. `subsequence`: First example: I think that it might be more intuitive to have a simpler linear representation for the sequence `(n)_{n\ge 0}`. The current representation corresponds to the vector `(n, 2n+1)`; a representation corresponding to the vector `(n, 1)` would be simpler. It might also be helpful to state the vector explicitly.

5. `subsequence`: the new method `linear_representation` implemented in the review phase of a precursor ticket could be used instead of manually extracting the information.

6. `subsequence`: For the example `C.subsequence(3, 1)`, it might be helpful to document that this does what it should do by adding some tests of the shape
   {{{
   #!python
   sage: var('n')
   sage: def v(n):
   ....:     return vector([3*n + 1, 6*n + 1])
   sage: S.mu[0] * v(n) == v(2*n)
   True
   sage: S.mu[1] * v(n) == v(2*n + 1)
   True
   }}}
   Similar tests would be welcome in other examples, too, e.g. for `C.subsequence(1, -1)`, the vector is something like `[n -1 + delta_0(n), 2*n - 1 + delta_0(n), 4*n + 1]` where `delta_0(n)` corresponds to `int(n == 0)`:
   {{{
   #!python
   sage: function('delta_0')
   sage: def v(n):
   ....:     return vector([n -1 + delta_0(n), 2*n - 1 + delta_0(n), 4*n + 1])
   sage: def simplify_delta(expr):
   ....:     return expr.subs({delta_0(2*n): delta_0(n), delta_0(2*n + 1): 0})
   sage: simplify_delta(v(2*n) - S.mu[0]*v(n)).is_zero()
   True
   sage: simplify_delta(v(2*n + 1) - S.mu[1]*v(n)).is_zero()
   True
   }}}
   or, for `S = C.subsequence(1, {0: 1, -1: -1})`:
   {{{
   #!python
   sage: def v(n):
   ....:     return vector([1 - delta_0(n), 1])
   }}}

7. `subsequence`: is there are a particular reason to write `lines = dict((r, []) for r in A)` instead of `lines = {r: [] for r in A}`

8. `subsequence`: I think that the code could be simplified by constructing the matrices of the new linear representation as block matrices in terms of the original matrices. For instance, the loop over `i in srange(dim)` and then extracting the `i`-th row of `self.mu[f]` could be omitted (with the additional benefit of not computing `d` and `f` in `mu_line` for all values of `i`); the index computation `(di*dim)*(0,)` in `pad` could be replaced by taking the zero matrix of the parent of `self.mu[f]` (or create that zero matrix once, instead of the current `zero`), `ndim` would be unnecessary.

9. `subsequence`: I think that in the block calling `mu_line`, a comment stating that we now compute the contributions of `v(an+c)[an\ge 0]` to the linear representation by using `v(a(kn+r)+c)[a(kn+r)+c\ge 0] = v(kan+ar+c)[kan+ar+c\ge 0] = v(k(an+d)+f)[an+d\ge 0]=mu[f]v(an+d)[an+d\ge 0]` where `v(n) = self.__getitem__(n, multiply_left=False)` would be helpful.

10. `subsequence`: I am not so sure about the comment on the various ranges (and consequently, the tests testing that the range of `c` is large enough): It seems that no predefined range is used (anymore?), everything is generated dynamically. The only thing which actually matters is termination of the procedure, and if I am not mistaken, then `-|b| \le f \le max(a, |b|)` always holds which implies termination.

11. `subsequence`: I think that the construction of the new left vector could be simplified by constructing it as a "block vector" instead of an actual sum of padded tuples:
    {{{
    #!python
    vector(sum((tuple(b.get(c, 0)*self.left) for c in kernel), tuple()))
    }}}

12. `partial_sums`: The description of the parameter `include_n` is rendered incompletely because ``n`th` is not formatted appropriately.

13. `partial_sums`: the new method `linear_representation` implemented in the review phase of a precursor ticket could be used instead of manually extracting the information.

14. `partial_sums`: is there are a particular reason to write `B = dict((r, sum(self.mu[a] for a in A[r:])) for r in A)` instead of `B = {r: sum(self.mu[a] for a in A[r:]) for r in A)`?

15. `partial_sums`: `dict((r, W.augment((-B[r+1]).stack(self.mu[r]))) for r in A)` vs. `{r: ... for r in A}`

16. `partial_sums` I think that using `block_matrix([[B[0], -B[r-1]], [Z, self.mu[r]]])` would be more readable than constructing the block matrix via `stack` and `augment`; I do not think that reusing the same first block column in all matrices is worth the effort.

17. The patchbot notes two issues raised by pyflakes; one of them can probably be fixed by merging the latest version of #21318

18. It seems that there is no function `block_vector` in [SageMath](SageMath). I think that always constructing them via conversion to tuples, adding tuples, converting back to a vector is not very readable. I posted about `block_vector` on [sage-devel](https://groups.google.com/g/sage-devel/c/X0a-ENF6LNk/m/0iRDn28eAAAJ). If no such function is introduced in appropriate places, I suggest to have a local function in `recognizable_series.py`.

19. I am curios why there are no methods `shift_left` and `shift_right`; they could easily be implemented via `subsequence`.

20. The methods `partial_sums` and the difference methods are mostly inverse to each other. It would be nice to check the obvious relations between these methods (as well as the shift methods from 19) using a random k-regular sequence. See also the discussion on [sage-devel](https://groups.google.com/g/sage-devel/c/3rOts1PjynU/m/vR5VMqmgAQAJ) concerning testing of random elements. This is probably something for a follow-up because equality checking would be useful.


---

Comment by mathzeta2 created at 2021-07-12 00:01:40

Following the discussion on [sage-devel](https://groups.google.com/g/sage-devel/c/X0a-ENF6LNk), here are two minor remarks:

Replying to [comment:18 cheuberg]:
> 18. It seems that there is no function `block_vector` in [SageMath](SageMath). I think that always constructing them via conversion to tuples, adding tuples, converting back to a vector is not very readable. I posted about `block_vector` on [sage-devel](https://groups.google.com/g/sage-devel/c/X0a-ENF6LNk/m/0iRDn28eAAAJ). If no such function is introduced in appropriate places, I suggest to have a local function in `recognizable_series.py`.
One can use Python's [itertools.chain](https://docs.python.org/3/library/itertools.html#itertools.chain) or [chain.from_iterable](https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable) where appropriate. For example:


```python
sage: from itertools import chain
sage: vector(chain([1,2,3], [4,5,6]))
(1, 2, 3, 4, 5, 6) 
```


> 14. `partial_sums`: is there are a particular reason to write `B = dict((r, sum(self.mu[a] for a in A[r:])) for r in A)` instead of `B = {r: sum(self.mu[a] for a in A[r:]) for r in A)`?
>
I think the number of additions is quadratic, where it can be linear. Creating such partial sums with linear number of additions has many implementations: [itertools.accumulate](https://docs.python.org/3/library/itertools.html#itertools.accumulate), [numpy.cumsum](https://numpy.org/doc/1.21/reference/generated/numpy.cumsum.html#numpy.cumsum), and not long ago I discovered that Sage have the function [running_total](https://doc.sagemath.org/html/en/reference/misc/sage/misc/misc_c.html#sage.misc.misc_c.running_total). If this is premature optimization (e.g. the size of `A` is always small), then please ignore.

I do not know much about k-regular sequences, but from a quick read it seems great to have them implementated in Sage.


---

Comment by git created at 2022-01-05 14:50:36

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by dkrenn created at 2022-01-05 14:52:07

Replying to [comment:18 cheuberg]:
> 1. `pad_right`: One-sentence description: the syntax ```zero``s` does not yield the desired formatting: The output is `zero``s to have at least the given ``length.`

Done.

> 2. `pad_right`: PEP8: Missing spaces after commas in input of examples and tests.

Done.

> 3. `subsequence`: Description of the input parameter `b`: The meaning of `c_j(a_n+b_j)` is unclear to me.

Indeed, this was incorrect. Changed now.

> 4. `subsequence`: First example: I think that it might be more intuitive to have a simpler linear representation for the sequence `(n)_{n\ge 0}`. The current representation corresponds to the vector `(n, 2n+1)`; a representation corresponding to the vector `(n, 1)` would be simpler. It might also be helpful to state the vector explicitly.

Yes, indeed we should use the simpler linear representation; changed.
Vector explicitly added (in separate commit).

> 5. `subsequence`: the new method `linear_representation` implemented in the review phase of a precursor ticket could be used instead of manually extracting the information.

Done.

> 6. `subsequence`: For the example `C.subsequence(3, 1)`, it might be helpful to document that this does what it should do by adding some tests of the shape [...]

Tests added in the `TESTS` section to not pollute the examples section in terms of readability.

> 7. `subsequence`: is there are a particular reason to write `lines = dict((r, []) for r in A)` instead of `lines = {r: [] for r in A}`

I vaguely remember that an older Python version didn't support this and parts of the code are quite old in terms of Python versions. Nevertheless, changed, as this is clearly an improvement.

> 8. `subsequence`: I think that the code could be simplified by constructing the matrices of the new linear representation as block matrices in terms of the original matrices. For instance, the loop over `i in srange(dim)` and then extracting the `i`-th row of `self.mu[f]` could be omitted (with the additional benefit of not computing `d` and `f` in `mu_line` for all values of `i`); the index computation `(di*dim)*(0,)` in `pad` could be replaced by taking the zero matrix of the parent of `self.mu[f]` (or create that zero matrix once, instead of the current `zero`), `ndim` would be unnecessary.

Changed. However, I am not fully convinced that this rewriting made it that much better/easier to read as hoped; nevertheless, it think it made it somehow easier to understand what is going on. The loop over i, for sure, needed to be pulled out, even without the change to block matrices.

> 9. `subsequence`: I think that in the block calling `mu_line`, a comment stating that we now compute the contributions of `v(an+c)[an\ge 0]` to the linear representation by using `v(a(kn+r)+c)[a(kn+r)+c\ge 0] = v(kan+ar+c)[kan+ar+c\ge 0] = v(k(an+d)+f)[an+d\ge 0]=mu[f]v(an+d)[an+d\ge 0]` where `v(n) = self.__getitem__(n, multiply_left=False)` would be helpful.

Comment (as stated) added.

> 10. `subsequence`: I am not so sure about the comment on the various ranges (and consequently, the tests testing that the range of `c` is large enough): It seems that no predefined range is used (anymore?), everything is generated dynamically. The only thing which actually matters is termination of the procedure, and if I am not mistaken, then `-|b| \le f \le max(a, |b|)` always holds which implies termination.

Ok.

> 11. `subsequence`: I think that the construction of the new left vector could be simplified by constructing it as a "block vector" instead of an actual sum of padded tuples:
>     {{{
>     #!python
>     vector(sum((tuple(b.get(c, 0)*self.left) for c in kernel), tuple()))
>     }}}

This is indeed much simpler; changed.

> 12. `partial_sums`: The description of the parameter `include_n` is rendered incompletely because ``n`th` is not formatted appropriately.

Done.

> 13. `partial_sums`: the new method `linear_representation` implemented in the review phase of a precursor ticket could be used instead of manually extracting the information.

Used now.

> 14. `partial_sums`: is there are a particular reason to write `B = dict((r, sum(self.mu[a] for a in A[r:])) for r in A)` instead of `B = {r: sum(self.mu[a] for a in A[r:]) for r in A)`?

Done.

> 15. `partial_sums`: `dict((r, W.augment((-B[r+1]).stack(self.mu[r]))) for r in A)` vs. `{r: ... for r in A}`

Done.

> 16. `partial_sums` I think that using `block_matrix([[B[0], -B[r-1]], [Z, self.mu[r]]])` would be more readable than constructing the block matrix via `stack` and `augment`; I do not think that reusing the same first block column in all matrices is worth the effort.

Agreed; changed.

Do we mind, that now the output of the linear representation sometimes is a displayed as block matrix? I guess not...

> 17. The patchbot notes two issues raised by pyflakes; one of them can probably be fixed by merging the latest version of #21318

I think this should be fixed already. Let's see what the patchbot reports.

> 18. It seems that there is no function `block_vector` in [SageMath](SageMath). I think that always constructing them via conversion to tuples, adding tuples, converting back to a vector is not very readable. I posted about `block_vector` on [sage-devel](https://groups.google.com/g/sage-devel/c/X0a-ENF6LNk/m/0iRDn28eAAAJ). If no such function is introduced in appropriate places, I suggest to have a local function in `recognizable_series.py`.

Changed to `vector(chain(...))` as discussed on the mailing list and ticket.

> 19. I am curios why there are no methods `shift_left` and `shift_right`; they could easily be implemented via `subsequence`.

Simply because not implemented. Done now.

> 20. The methods `partial_sums` and the difference methods are mostly inverse to each other. It would be nice to check the obvious relations between these methods (as well as the shift methods from 19) using a random k-regular sequence. See also the discussion on [sage-devel](https://groups.google.com/g/sage-devel/c/3rOts1PjynU/m/vR5VMqmgAQAJ) concerning testing of random elements. This is probably something for a follow-up because equality checking would be useful.

I agree that this should be done on a follow-up ticket.


---

Comment by dkrenn created at 2022-01-05 14:55:46

Replying to [comment:19 mathzeta2]:
> Following the discussion on [sage-devel](https://groups.google.com/g/sage-devel/c/X0a-ENF6LNk), here are two minor remarks:
> One can use Python's [itertools.chain](https://docs.python.org/3/library/itertools.html#itertools.chain) or [chain.from_iterable](https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable) where appropriate. For example:


Done.

> > 14. `partial_sums`: is there are a particular reason to write `B = dict((r, sum(self.mu[a] for a in A[r:])) for r in A)` instead of `B = {r: sum(self.mu[a] for a in A[r:]) for r in A)`?
> >
> I think the number of additions is quadratic, where it can be linear. Creating such partial sums with linear number of additions has many implementations: [itertools.accumulate](https://docs.python.org/3/library/itertools.html#itertools.accumulate), [numpy.cumsum](https://numpy.org/doc/1.21/reference/generated/numpy.cumsum.html#numpy.cumsum), and not long ago I discovered that Sage have the function [running_total](https://doc.sagemath.org/html/en/reference/misc/sage/misc/misc_c.html#sage.misc.misc_c.running_total). If this is premature optimization (e.g. the size of `A` is always small), then please ignore.

Yes, indeed the size of `A` is small compared to everything else. Nevertheless I gave it a try. One would need something like

```diff
-        B = {r: sum(self.mu[a] for a in A[r:]) for r in A}
+        B = dict(zip(reversed(A), accumulate(self.mu[r] for r in reversed(A))))
```

which makes it much less readable, so rejected this change.


---

Comment by dkrenn created at 2022-01-05 14:55:56

Changing status from needs_work to needs_review.


---

Comment by git created at 2022-01-06 15:48:12

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by git created at 2022-01-06 16:08:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by cheuberg created at 2022-01-06 16:20:35

Thank you, I reviewed the changes and added a few reviewer commits (sorry for messing up the history on trac here by mistyping my branch name; the last five commits are new).

Replying to [comment:23 dkrenn]:
> Replying to [comment:18 cheuberg]:
> > 8. `subsequence`: I think that the code could be simplified by constructing the matrices of the new linear representation as block matrices in terms of the original matrices. For instance, the loop over `i in srange(dim)` and then extracting the `i`-th row of `self.mu[f]` could be omitted (with the additional benefit of not computing `d` and `f` in `mu_line` for all values of `i`); the index computation `(di*dim)*(0,)` in `pad` could be replaced by taking the zero matrix of the parent of `self.mu[f]` (or create that zero matrix once, instead of the current `zero`), `ndim` would be unnecessary.
> 
> Changed. However, I am not fully convinced that this rewriting made it that much better/easier to read as hoped; nevertheless, it think it made it somehow easier to understand what is going on. The loop over i, for sure, needed to be pulled out, even without the change to block matrices.

I propose another variant in branch `u/cheuberg/21325-variant` (not linked to this ticket) where I try to avoid padding and indices.

The essential lines are

```python
        kernel = list(b)

        zero_M = self.mu[0].parent().zero()
        zero_R = self.right.parent().zero()
        # Let v(n) = self.__getitem__(n, multiply_left=False)
        rule = {}
        # We will construct `kernel` and `rule` in such a way that for all
        # c in `kernel`,
        #     rule[r, c] = (f, d)
        # holds for some 0 <= f < r and some d in `kernel` such that
        #     v(a(kn+r)+c) [a(kn+r) +c >= 0] = mu[f] v(an+d) [an+d >= 0].

        ci = 0
        while ci < len(kernel):
            c = kernel[ci]
            for r in A:
                # We now compute the contributions of v(an+c)[an >= 0] to
                # the linear representation by using
                #   v(a(kn+r)+c) [a(kn+r)+c >= 0]
                #   = v(kan+ar+c) [kan+ar+c >= 0]
                #   = v(k(an+d)+f) [an+d >= 0]
                #   = mu[f] v(an+d) [an+d >= 0].
                d, f = (a*r + c).quo_rem(k)
                if d not in kernel:
                    kernel.append(d)
                rule[r, c] = (d, f)
            ci += 1

        def matrix_row(r, c):
            d, f = rule[r, c]
            return [self.mu[f] if d == j else zero_M for j in kernel]

        result = P.element_class(
            P,
            {r: Matrix.block([matrix_row(r, c) for c in kernel])
             for r in A},
            vector(chain.from_iterable(
                b.get(c, 0)*self.left
                for c in kernel)),
            vector(chain.from_iterable(
                (self.__getitem__(c, multiply_left=False) if c >= 0 else zero_R)
                for c in kernel)))
```


> > 10. `subsequence`: I am not so sure about the comment on the various ranges (and consequently, the tests testing that the range of `c` is large enough): It seems that no predefined range is used (anymore?), everything is generated dynamically. The only thing which actually matters is termination of the procedure, and if I am not mistaken, then `-|b| \le f \le max(a, |b|)` always holds which implies termination.
> 
> Ok.

I propose to remove or amend the comment.

> > 16. `partial_sums` I think that using `block_matrix([[B[0], -B[r-1]], [Z, self.mu[r]]])` would be more readable than constructing the block matrix via `stack` and `augment`; I do not think that reusing the same first block column in all matrices is worth the effort.
> 
> Agreed; changed.
> 
> Do we mind, that now the output of the linear representation sometimes is a displayed as block matrix? I guess not...

I do not mind.

> > 20. The methods `partial_sums` and the difference methods are mostly inverse to each other. It would be nice to check the obvious relations between these methods (as well as the shift methods from 19) using a random k-regular sequence. See also the discussion on [sage-devel](https://groups.google.com/g/sage-devel/c/3rOts1PjynU/m/vR5VMqmgAQAJ) concerning testing of random elements. This is probably something for a follow-up because equality checking would be useful.
> 
> I agree that this should be done on a follow-up ticket.

Ok. Let us just keep it on this list for the moment.


---

Comment by cheuberg created at 2022-01-06 16:20:35

Changing status from needs_review to needs_work.


---

Comment by dkrenn created at 2022-01-07 09:54:36

Replying to [comment:29 cheuberg]:
> Thank you, I reviewed the changes and added a few reviewer commits

LGTM, thank you.

> I propose another variant in branch `u/cheuberg/21325-variant` (not linked to this ticket) where I try to avoid padding and indices.
> 
> The essential lines are [...]

LGTM, so merged in for this ticket.

> > > 10. `subsequence`: I am not so sure about the comment on the various ranges (and consequently, the tests testing that the range of `c` is large enough): It seems that no predefined range is used (anymore?), everything is generated dynamically. The only thing which actually matters is termination of the procedure, and if I am not mistaken, then `-|b| \le f \le max(a, |b|)` always holds which implies termination.
> > 
> > Ok.
> 
> I propose to remove or amend the comment.

Should the `f` in `-|b| \le f \le max(a, |b|)` be a `d`?
----
New commits:


---

Comment by cheuberg created at 2022-01-08 09:55:17

Replying to [comment:31 dkrenn]:
> Replying to [comment:29 cheuberg]:
> > > > 10. `subsequence`: I am not so sure about the comment on the various ranges (and consequently, the tests testing that the range of `c` is large enough): It seems that no predefined range is used (anymore?), everything is generated dynamically. The only thing which actually matters is termination of the procedure, and if I am not mistaken, then `-|b| \le f \le max(a, |b|)` always holds which implies termination.
> > > 
> > > Ok.
> > 
> > I propose to remove or amend the comment.
> 
> Should the `f` in `-|b| \le f \le max(a, |b|)` be a `d`?

Yes. Sorry.


---

Comment by dkrenn created at 2022-01-09 15:01:05

Replying to [comment:32 cheuberg]:
> Replying to [comment:31 dkrenn]:
> > Should the `f` in `-|b| \le f \le max(a, |b|)` be a `d`?
> Yes. Sorry.

Can you explain how you come to this estimate? (I am asking, because from the line `d, f = (a*r + c).quo_rem(k)`, I only get a weaker upper bound)


---

Comment by dkrenn created at 2022-01-09 15:05:37

Replying to [comment:33 dkrenn]:
> Replying to [comment:32 cheuberg]:
> > Replying to [comment:31 dkrenn]:
> > > Should the `f` in `-|b| \le f \le max(a, |b|)` be a `d`?
> > Yes. Sorry.
> 
> Can you explain how you come to this estimate? (I am asking, because from the line `d, f = (a*r + c).quo_rem(k)`, I only get a weaker upper bound)

Sorry for the noise, fine for me now; I understand.


---

Comment by dkrenn created at 2022-01-09 15:08:22

Replying to [comment:29 cheuberg]:
> > > 10. `subsequence`: I am not so sure about the comment on the various ranges (and consequently, the tests testing that the range of `c` is large enough): It seems that no predefined range is used (anymore?), everything is generated dynamically. The only thing which actually matters is termination of the procedure, and if I am not mistaken, then `-|b| \le f \le max(a, |b|)` always holds which implies termination.
> > 
> > Ok.
> 
> I propose to remove or amend the comment.

Comment removed now.


---

Comment by dkrenn created at 2022-01-09 15:08:22

Changing status from needs_work to needs_review.


---

Comment by git created at 2022-01-09 15:10:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2022-01-12 16:35:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2022-01-12 16:37:10

Replying to [comment:29 cheuberg]:
> > > 10. `subsequence`: I am not so sure about the comment on the various ranges (and consequently, the tests testing that the range of `c` is large enough): It seems that no predefined range is used (anymore?), everything is generated dynamically. The only thing which actually matters is termination of the procedure, and if I am not mistaken, then `-|b| \le f \le max(a, |b|)` always holds which implies termination.
> > 
> > Ok.
> 
> I propose to remove or amend the comment.

I have now amended a comment. Please have a look.


---

Comment by cheuberg created at 2022-01-15 06:55:00

Replying to [comment:38 dkrenn]:
> Replying to [comment:29 cheuberg]:
> > > > 10. `subsequence`: I am not so sure about the comment on the various ranges (and consequently, the tests testing that the range of `c` is large enough): It seems that no predefined range is used (anymore?), everything is generated dynamically. The only thing which actually matters is termination of the procedure, and if I am not mistaken, then `-|b| \le f \le max(a, |b|)` always holds which implies termination.
> > > 
> > > Ok.
> > 
> > I propose to remove or amend the comment.
> 
> I have now amended a comment. Please have a look.

Thank you, LGTM.

The docbuild failure of the patchbot seems to be unrelated.


---

Comment by cheuberg created at 2022-01-15 06:55:00

Changing status from needs_review to positive_review.


---

Comment by cheuberg created at 2022-01-17 07:05:54

Changing status from positive_review to needs_info.


---

Comment by cheuberg created at 2022-01-17 07:05:54

While reviewing #32921, I had one more look at this ticket, and found one more item to discuss.

21. I think that the last commits here removed all usage of the new function `pad_right` introduced in this ticket, so we might as well delete that function.


---

Comment by git created at 2022-01-23 16:35:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by dkrenn created at 2022-01-23 16:36:10

Replying to [comment:40 cheuberg]:
> 21. I think that the last commits here removed all usage of the new function `pad_right` introduced in this ticket, so we might as well delete that function.

Removed.


---

Comment by dkrenn created at 2022-01-23 16:36:10

Changing status from needs_info to needs_review.


---

Comment by dkrenn created at 2022-01-24 10:15:50

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2022-01-31 23:31:53

Resolution: fixed
