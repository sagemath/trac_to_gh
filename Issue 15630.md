# Issue 15630: Implement modular exponentiation for all polynomial rings

archive/issues_015630.json:
```json
{
    "body": "CC:  @roed314 @jdemeyer @pjbruin jakobkroeker\n\nSome `__pow__` functions just ignore the modulus, see #15777 comment 7.\n\nIssue created by migration from https://trac.sagemath.org/ticket/15867\n\n",
    "created_at": "2014-02-26T22:40:41Z",
    "labels": [
        "component: algebra",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Implement modular exponentiation for all polynomial rings",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15630",
    "user": "https://trac.sagemath.org/admin/accounts/users/jpflori"
}
```
CC:  @roed314 @jdemeyer @pjbruin jakobkroeker

Some `__pow__` functions just ignore the modulus, see #15777 comment 7.

Issue created by migration from https://trac.sagemath.org/ticket/15867





---

archive/issue_events_046682.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15630#event-46682"
}
```



---

archive/issue_events_046683.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15630#event-46683"
}
```



---

archive/issue_events_046684.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/15630#event-46684"
}
```



---

archive/issue_comments_202045.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. New commits:",
    "created_at": "2022-01-10T17:21:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202045",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. New commits:



---

archive/issue_comments_202046.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2022-01-10T17:22:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202046",
    "user": "https://github.com/shashwat1002"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_202047.json:
```json
{
    "body": "Thanks! Please add your full name in the \"Authors\" field.",
    "created_at": "2022-01-11T00:51:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202047",
    "user": "https://github.com/slel"
}
```

Thanks! Please add your full name in the "Authors" field.



---

archive/issue_comments_202048.json:
```json
{
    "body": "Now that the modulus argument is no longer ignored, you should rename it from `ignored` to something else (`modulus`? `mod`?).",
    "created_at": "2022-01-11T02:15:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202048",
    "user": "https://github.com/yyyyx4"
}
```

Now that the modulus argument is no longer ignored, you should rename it from `ignored` to something else (`modulus`? `mod`?).



---

archive/issue_comments_202049.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2022-01-11T06:11:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202049",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_202050.json:
```json
{
    "body": "Replying to [comment:8 slelievre]:\n> Thanks! Please add your full name in the \"Authors\" field.\n\nYeah, done! :)",
    "created_at": "2022-01-11T06:16:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202050",
    "user": "https://github.com/shashwat1002"
}
```

Replying to [comment:8 slelievre]:
> Thanks! Please add your full name in the "Authors" field.

Yeah, done! :)



---

archive/issue_comments_202051.json:
```json
{
    "body": "Replying to [comment:9 lorenz]:\n> Now that the modulus argument is no longer ignored, you should rename it from `ignored` to something else (`modulus`? `mod`?).\n\nrenamed to `modulus` and rewrote history :)",
    "created_at": "2022-01-11T06:17:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202051",
    "user": "https://github.com/shashwat1002"
}
```

Replying to [comment:9 lorenz]:
> Now that the modulus argument is no longer ignored, you should rename it from `ignored` to something else (`modulus`? `mod`?).

renamed to `modulus` and rewrote history :)



---

archive/issue_comments_202052.json:
```json
{
    "body": "To compare to `None`, we use `is` and `is not`\nrather than `==` and `!=`:\n\n\n```diff\n-                if modulus != None:\n+                if modulus is not None:\n```\n",
    "created_at": "2022-01-12T07:50:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202052",
    "user": "https://github.com/slel"
}
```

To compare to `None`, we use `is` and `is not`
rather than `==` and `!=`:


```diff
-                if modulus != None:
+                if modulus is not None:
```




---

archive/issue_comments_202053.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2022-01-12T12:53:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202053",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_202054.json:
```json
{
    "body": "Replying to [comment:14 slelievre]:\n> To compare to `None`, we use `is` and `is not`\n> rather than `==` and `!=`:\n> \n> {{{#!diff\n> -                if modulus != None:\n> +                if modulus is not None:\n> }}}\n\nDone (and rewrote history) :)",
    "created_at": "2022-01-12T12:54:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202054",
    "user": "https://github.com/shashwat1002"
}
```

Replying to [comment:14 slelievre]:
> To compare to `None`, we use `is` and `is not`
> rather than `==` and `!=`:
> 
> {{{#!diff
> -                if modulus != None:
> +                if modulus is not None:
> }}}

Done (and rewrote history) :)



---

archive/issue_comments_202055.json:
```json
{
    "body": "This patch makes things better in that it renders the implementation of `__pow__` *correct*, but it is still kind of misses the point: The entire reason why `pow()` has a \"modulus\" argument in the first place is that `pow(x, e, m)` can be *exponentially faster* than `pow(x, e) % m`! So, having an implementation of \"modular exponentiation\" that is simply exponentiation followed by modulo is rather pointless. It should use square-and-multiply with reductions at each step to keep things small.\n\nThe other issue is that the patch only affects modular exponentation for one particular univariate polynomial class in Sage, but there are tons of other polynomial implementations that still don't implement this correctly. Presumably, the best way to go would be to implement a generic modular-exponentiation function (do we have that already?) and simply call it in each of the polynomial classes when the `modulus` argument is given.",
    "created_at": "2022-01-25T02:51:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202055",
    "user": "https://github.com/yyyyx4"
}
```

This patch makes things better in that it renders the implementation of `__pow__` *correct*, but it is still kind of misses the point: The entire reason why `pow()` has a "modulus" argument in the first place is that `pow(x, e, m)` can be *exponentially faster* than `pow(x, e) % m`! So, having an implementation of "modular exponentiation" that is simply exponentiation followed by modulo is rather pointless. It should use square-and-multiply with reductions at each step to keep things small.

The other issue is that the patch only affects modular exponentation for one particular univariate polynomial class in Sage, but there are tons of other polynomial implementations that still don't implement this correctly. Presumably, the best way to go would be to implement a generic modular-exponentiation function (do we have that already?) and simply call it in each of the polynomial classes when the `modulus` argument is given.



---

archive/issue_comments_202056.json:
```json
{
    "body": "Replying to [comment:17 lorenz]:\n> This patch makes things better in that it renders the implementation of `__pow__` *correct*, but it is still kind of misses the point: The entire reason why `pow()` has a \"modulus\" argument in the first place is that `pow(x, e, m)` can be *exponentially faster* than `pow(x, e) % m`! So, having an implementation of \"modular exponentiation\" that is simply exponentiation followed by modulo is rather pointless. It should use square-and-multiply with reductions at each step to keep things small.\n> \n> The other issue is that the patch only affects modular exponentation for one particular univariate polynomial class in Sage, but there are tons of other polynomial implementations that still don't implement this correctly. Presumably, the best way to go would be to implement a generic modular-exponentiation function (do we have that already?) and simply call it in each of the polynomial classes when the `modulus` argument is given.\n\n\n\n\nI am going to begin work on a modular exponentiation function that is more efficient.\n\nBut before I begin, I had a few doubts:\n- the polynomials are dealt by one of two C libraries: FLINT and NTL, so a general modular exponentiation function on polynomials must be written in python?\n- Also, I am having trouble figuring where would I place the code for  that, and understanding the organization of the polynomials code in general. If I could be pointed to a developer documentation on the same it will be very helpful \n\nI started a mailing list thread here if that's more appropriate to respond to https://groups.google.com/g/sage-devel/c/5A8CDkj9jKo",
    "created_at": "2022-01-26T08:11:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202056",
    "user": "https://github.com/shashwat1002"
}
```

Replying to [comment:17 lorenz]:
> This patch makes things better in that it renders the implementation of `__pow__` *correct*, but it is still kind of misses the point: The entire reason why `pow()` has a "modulus" argument in the first place is that `pow(x, e, m)` can be *exponentially faster* than `pow(x, e) % m`! So, having an implementation of "modular exponentiation" that is simply exponentiation followed by modulo is rather pointless. It should use square-and-multiply with reductions at each step to keep things small.
> 
> The other issue is that the patch only affects modular exponentation for one particular univariate polynomial class in Sage, but there are tons of other polynomial implementations that still don't implement this correctly. Presumably, the best way to go would be to implement a generic modular-exponentiation function (do we have that already?) and simply call it in each of the polynomial classes when the `modulus` argument is given.




I am going to begin work on a modular exponentiation function that is more efficient.

But before I begin, I had a few doubts:
- the polynomials are dealt by one of two C libraries: FLINT and NTL, so a general modular exponentiation function on polynomials must be written in python?
- Also, I am having trouble figuring where would I place the code for  that, and understanding the organization of the polynomials code in general. If I could be pointed to a developer documentation on the same it will be very helpful 

I started a mailing list thread here if that's more appropriate to respond to https://groups.google.com/g/sage-devel/c/5A8CDkj9jKo



---

archive/issue_comments_202057.json:
```json
{
    "body": "If you're going to implement this on the level of `__pow__` (which, according to python's interface specification is actually a reasonable thing to do), you will need to implement it for FLINT and NTL wrappers separately, since each implements `__pow__`, so any inheritance would be overridden.\n\nAlso note that \"efficient\" powering of polynomials modulo other polynomials over QQ is less useful than you might initially think: it helps a LOT to not carry the higher order terms around, but the coefficient swell will still be significant, bounding the feasible powers to a relatively small range. For polynomials over finite fields, where coefficient swell is not an issue, this is an entirely different story.\n\nYou probably also want to document what exactly the modulo operation that you're doing, since `ZZ[x]` by itself is not a Euclidean ring, so the concept of \"remainder\" may need further explanation. Are you using some kind of pseudo division?\n\nAs an example:\n\n```\nsage: R.<x>=ZZ['x']\nsage: f=x^5-1\nsage: m=3*x^2+1\nsage: f % m\nx^5 - 1\nsage: (3*f) % m\n-x^3 - 3\nsage: (9*f) % m\nx - 9\n```\n",
    "created_at": "2022-01-26T21:00:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202057",
    "user": "https://github.com/nbruin"
}
```

If you're going to implement this on the level of `__pow__` (which, according to python's interface specification is actually a reasonable thing to do), you will need to implement it for FLINT and NTL wrappers separately, since each implements `__pow__`, so any inheritance would be overridden.

Also note that "efficient" powering of polynomials modulo other polynomials over QQ is less useful than you might initially think: it helps a LOT to not carry the higher order terms around, but the coefficient swell will still be significant, bounding the feasible powers to a relatively small range. For polynomials over finite fields, where coefficient swell is not an issue, this is an entirely different story.

You probably also want to document what exactly the modulo operation that you're doing, since `ZZ[x]` by itself is not a Euclidean ring, so the concept of "remainder" may need further explanation. Are you using some kind of pseudo division?

As an example:

```
sage: R.<x>=ZZ['x']
sage: f=x^5-1
sage: m=3*x^2+1
sage: f % m
x^5 - 1
sage: (3*f) % m
-x^3 - 3
sage: (9*f) % m
x - 9
```




---

archive/issue_comments_202058.json:
```json
{
    "body": "Replying to [comment:19 nbruin]:\n> You probably also want to document what exactly the modulo operation that you're doing, since `ZZ[x]` by itself is not a Euclidean ring, so the concept of \"remainder\" may need further explanation. Are you using some kind of pseudo division?\n\nI think this is outside the scope here: The notion of reduction is simply whatever `%` does for the parent ring, which should not surprise anyone. Improving the documentation for `%`, if deemed insufficient, should be another ticket.",
    "created_at": "2022-01-27T03:19:04Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202058",
    "user": "https://github.com/yyyyx4"
}
```

Replying to [comment:19 nbruin]:
> You probably also want to document what exactly the modulo operation that you're doing, since `ZZ[x]` by itself is not a Euclidean ring, so the concept of "remainder" may need further explanation. Are you using some kind of pseudo division?

I think this is outside the scope here: The notion of reduction is simply whatever `%` does for the parent ring, which should not surprise anyone. Improving the documentation for `%`, if deemed insufficient, should be another ticket.



---

archive/issue_comments_202059.json:
```json
{
    "body": "Replying to [comment:18 gh-shashwat1002]:\n> - the polynomials are dealt by one of two C libraries: FLINT and NTL, so a general modular exponentiation function on polynomials must be written in python?\n\nYes. In fact, I discovered that we already have such a function in Sage: `sage.arith.misc.power_mod()`. The documentation (misleadingly) only talks about integers, but the implementation actually works for any ring where `%` is defined. I've created #33244 to change this.\n\nThis means all we really need to do for *this* ticket is adding code along the lines of\n\n```\nif modulus is not None:\n    return power_mod(self, exponent, modulus)\n```\n\nto all the `.__pow__()` methods in polynomial-ring classes that do not yet handle the `modulus` argument.",
    "created_at": "2022-01-29T09:56:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202059",
    "user": "https://github.com/yyyyx4"
}
```

Replying to [comment:18 gh-shashwat1002]:
> - the polynomials are dealt by one of two C libraries: FLINT and NTL, so a general modular exponentiation function on polynomials must be written in python?

Yes. In fact, I discovered that we already have such a function in Sage: `sage.arith.misc.power_mod()`. The documentation (misleadingly) only talks about integers, but the implementation actually works for any ring where `%` is defined. I've created #33244 to change this.

This means all we really need to do for *this* ticket is adding code along the lines of

```
if modulus is not None:
    return power_mod(self, exponent, modulus)
```

to all the `.__pow__()` methods in polynomial-ring classes that do not yet handle the `modulus` argument.



---

archive/issue_comments_202060.json:
```json
{
    "body": "Replying to [comment:21 lorenz]:\n> Replying to [comment:18 gh-shashwat1002]:\n> > - the polynomials are dealt by one of two C libraries: FLINT and NTL, so a general modular exponentiation function on polynomials must be written in python?\n> \n> Yes. In fact, I discovered that we already have such a function in Sage: `sage.arith.misc.power_mod()`. The documentation (misleadingly) only talks about integers, but the implementation actually works for any ring where `%` is defined. I've created #33244 to change this.\n> \n> This means all we really need to do for *this* ticket is adding code along the lines of\n> {{{\n> if modulus is not None:\n>     return power_mod(self, exponent, modulus)\n> }}}\n> to all the `.__pow__()` methods in polynomial-ring classes that do not yet handle the `modulus` argument.\n\n\nHi, I had already written binary exponentiation (modular) using FLINT C functions directly. I'll replace my work with this. \n\nHowever, I am wondering, would there be a significant efficiency advantage writing it in cython (and making calls to FLINT functions as opposed to python as in power_mod)",
    "created_at": "2022-01-29T11:12:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202060",
    "user": "https://github.com/shashwat1002"
}
```

Replying to [comment:21 lorenz]:
> Replying to [comment:18 gh-shashwat1002]:
> > - the polynomials are dealt by one of two C libraries: FLINT and NTL, so a general modular exponentiation function on polynomials must be written in python?
> 
> Yes. In fact, I discovered that we already have such a function in Sage: `sage.arith.misc.power_mod()`. The documentation (misleadingly) only talks about integers, but the implementation actually works for any ring where `%` is defined. I've created #33244 to change this.
> 
> This means all we really need to do for *this* ticket is adding code along the lines of
> {{{
> if modulus is not None:
>     return power_mod(self, exponent, modulus)
> }}}
> to all the `.__pow__()` methods in polynomial-ring classes that do not yet handle the `modulus` argument.


Hi, I had already written binary exponentiation (modular) using FLINT C functions directly. I'll replace my work with this. 

However, I am wondering, would there be a significant efficiency advantage writing it in cython (and making calls to FLINT functions as opposed to python as in power_mod)



---

archive/issue_comments_202061.json:
```json
{
    "body": "There certainly are circumstances where saving on Python overhead is worth it, but my guess is that it won't give a noticeable speedup here. In this algorithm (except for toy-sized inputs), virtually all of the time will be spent on polynomial arithmetic, which is already implemented in low-level code even if you call it from Python.\nBut if your code is already functional, I figure there's no reason not to use it.\n\nOut of curiousity: Do you have an application in mind where you need this operation to be really fast?",
    "created_at": "2022-01-29T11:24:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202061",
    "user": "https://github.com/yyyyx4"
}
```

There certainly are circumstances where saving on Python overhead is worth it, but my guess is that it won't give a noticeable speedup here. In this algorithm (except for toy-sized inputs), virtually all of the time will be spent on polynomial arithmetic, which is already implemented in low-level code even if you call it from Python.
But if your code is already functional, I figure there's no reason not to use it.

Out of curiousity: Do you have an application in mind where you need this operation to be really fast?



---

archive/issue_comments_202062.json:
```json
{
    "body": "Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:",
    "created_at": "2022-01-29T11:37:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202062",
    "user": "https://trac.sagemath.org/admin/accounts/users/git"
}
```

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:



---

archive/issue_comments_202063.json:
```json
{
    "body": "Replying to [comment:23 lorenz]:\n> There certainly are circumstances where saving on Python overhead is worth it, but my guess is that it won't give a noticeable speedup here. In this algorithm (except for toy-sized inputs), virtually all of the time will be spent on polynomial arithmetic, which is already implemented in low-level code even if you call it from Python.\n> But if your code is already functional, I figure there's no reason not to use it.\n> \n> Out of curiousity: Do you have an application in mind where you need this operation to be really fast?\n\nNot at the moment, no. \nI just did it with power_mod therefore now. Probably best to reuse functions. \nIf someone deems it necessary to make `power_mod` itself in cython then maybe I could use the code.\n\nI couldn't find a `__pow__` in the NTL implementation.\n\nI am honestly struggling trying to find where to put appropriate code. Is there a detailed dev documentation somewhere?",
    "created_at": "2022-01-29T11:45:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15630",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15630#issuecomment-202063",
    "user": "https://github.com/shashwat1002"
}
```

Replying to [comment:23 lorenz]:
> There certainly are circumstances where saving on Python overhead is worth it, but my guess is that it won't give a noticeable speedup here. In this algorithm (except for toy-sized inputs), virtually all of the time will be spent on polynomial arithmetic, which is already implemented in low-level code even if you call it from Python.
> But if your code is already functional, I figure there's no reason not to use it.
> 
> Out of curiousity: Do you have an application in mind where you need this operation to be really fast?

Not at the moment, no. 
I just did it with power_mod therefore now. Probably best to reuse functions. 
If someone deems it necessary to make `power_mod` itself in cython then maybe I could use the code.

I couldn't find a `__pow__` in the NTL implementation.

I am honestly struggling trying to find where to put appropriate code. Is there a detailed dev documentation somewhere?
