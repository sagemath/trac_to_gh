# Issue 12931: Makes BooleanPolynomial more compatible with MPolynomial

archive/issues_012931.json:
```json
{
    "body": "Assignee: @malb\n\nCC:  @malb alexanderdreyer polybori\n\nKeywords: polybori\n\nBooleanPolynomial misses some basic function (e.g., p.is_univariate())\n\nThe class BooleanPolynomial, which is in fact a polybori interface, has a somewhat different interface compared to the \"normal\" MPolynomial. This is probably not normal. Because of this, the variety() function fails on ideals of BooleanPolynomial, which primarily exist to make this particular function faster...\n\nIssue created by migration from https://trac.sagemath.org/ticket/13103\n\n",
    "created_at": "2012-06-11T14:54:57Z",
    "labels": [
        "component: commutative algebra",
        "minor"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-5.2",
    "title": "Makes BooleanPolynomial more compatible with MPolynomial",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/12931",
    "user": "https://trac.sagemath.org/admin/accounts/users/Bouillaguet"
}
```
Assignee: @malb

CC:  @malb alexanderdreyer polybori

Keywords: polybori

BooleanPolynomial misses some basic function (e.g., p.is_univariate())

The class BooleanPolynomial, which is in fact a polybori interface, has a somewhat different interface compared to the "normal" MPolynomial. This is probably not normal. Because of this, the variety() function fails on ideals of BooleanPolynomial, which primarily exist to make this particular function faster...

Issue created by migration from https://trac.sagemath.org/ticket/13103





---

archive/issue_comments_155493.json:
```json
{
    "body": "Attachment [pbory_add_missing_functions.patch](tarball://root/attachments/some-uuid/ticket13103/pbory_add_missing_functions.patch) by Bouillaguet created at 2012-06-11 15:36:35\n\nPatch adding the functions",
    "created_at": "2012-06-11T15:36:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155493",
    "user": "https://trac.sagemath.org/admin/accounts/users/Bouillaguet"
}
```

Attachment [pbory_add_missing_functions.patch](tarball://root/attachments/some-uuid/ticket13103/pbory_add_missing_functions.patch) by Bouillaguet created at 2012-06-11 15:36:35

Patch adding the functions



---

archive/issue_comments_155494.json:
```json
{
    "body": "With the patch, the variety() function \"works\":\n\n```\nsage: R.<x,y,z> = BooleanPolynomialRing()\nsage: I = ideal( [ x*y*z + x*z + y + 1, x*y+x*z+y*z, x+y+z+1 ] )\nsage: I.variety()\nverbose 0 (3293: multi_polynomial_ideal.py, groebner_basis) Warning: falling back to very slow toy implementation.\nverbose 0 (2364: multi_polynomial_ideal.py, variety) Warning: falling back to very slow toy implementation.\n[{y: 1, z: 0, x: 0}]\n```\n\nHowever, it returns a **mathematically wrong result** when the polynomials do not generate a zero-dimensional ideal without the field equations. In this case, the variety() function normally fails (because on non-finite fields, the variety would be infinite).\n\nExample:\n\n```\nsage: R.<x,y,z> = GF(2)[]\nsage: I = ideal( [ x*y*z + x*z + y + 1, x+y+z+1 ] )\nsage: I.variety()\n...\nValueError: The dimension of the ideal is 1, but it should be 0\n```\n\nIf we add the field equations, then the ideal becomes zero-dimensional, and the variety() function works normally:\n\n```\nsage: J = I + sage.rings.ideal.FieldIdeal(R)\nsage: J.variety()\n[{y: 1, z: 0, x: 0}, {y: 1, z: 1, x: 1}]\n```\n\nBut over BooleanPolynomial things go wrong:\n\n```\nsage: R.<x,y,z> = BooleanPolynomialRing()\nsage: I = ideal( [ x*y*z + x*z + y + 1, x+y+z+1 ] )\nsage: I.variety()\nverbose 0 (3293: multi_polynomial_ideal.py, groebner_basis) Warning: falling back to very slow toy implementation.\nverbose 0 (2364: multi_polynomial_ideal.py, variety) Warning: falling back to very slow toy implementation.\n[{y: 1}]\n```\nThis result does not make sense. Of course ideals of BooleanPolynomials should have dimension zero, so that the variety() function should always work. But it should always return the right result!",
    "created_at": "2012-06-11T15:51:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155494",
    "user": "https://trac.sagemath.org/admin/accounts/users/Bouillaguet"
}
```

With the patch, the variety() function "works":

```
sage: R.<x,y,z> = BooleanPolynomialRing()
sage: I = ideal( [ x*y*z + x*z + y + 1, x*y+x*z+y*z, x+y+z+1 ] )
sage: I.variety()
verbose 0 (3293: multi_polynomial_ideal.py, groebner_basis) Warning: falling back to very slow toy implementation.
verbose 0 (2364: multi_polynomial_ideal.py, variety) Warning: falling back to very slow toy implementation.
[{y: 1, z: 0, x: 0}]
```

However, it returns a **mathematically wrong result** when the polynomials do not generate a zero-dimensional ideal without the field equations. In this case, the variety() function normally fails (because on non-finite fields, the variety would be infinite).

Example:

```
sage: R.<x,y,z> = GF(2)[]
sage: I = ideal( [ x*y*z + x*z + y + 1, x+y+z+1 ] )
sage: I.variety()
...
ValueError: The dimension of the ideal is 1, but it should be 0
```

If we add the field equations, then the ideal becomes zero-dimensional, and the variety() function works normally:

```
sage: J = I + sage.rings.ideal.FieldIdeal(R)
sage: J.variety()
[{y: 1, z: 0, x: 0}, {y: 1, z: 1, x: 1}]
```

But over BooleanPolynomial things go wrong:

```
sage: R.<x,y,z> = BooleanPolynomialRing()
sage: I = ideal( [ x*y*z + x*z + y + 1, x+y+z+1 ] )
sage: I.variety()
verbose 0 (3293: multi_polynomial_ideal.py, groebner_basis) Warning: falling back to very slow toy implementation.
verbose 0 (2364: multi_polynomial_ideal.py, variety) Warning: falling back to very slow toy implementation.
[{y: 1}]
```
This result does not make sense. Of course ideals of BooleanPolynomials should have dimension zero, so that the variety() function should always work. But it should always return the right result!



---

archive/issue_comments_155495.json:
```json
{
    "body": "The cause of the bug in \"positive\" dimension (without the field equations) is that BooleanPolynomialIdeal.groebner_basis() computes a groebner basis **modulo the field equations**, but this is not a Groebner basis in general.\n\nObvious fix :\na) Compute GB modulo field equations with BooleanPolynomialIdeal.groebner_basis()\nb) cast to MPolynomial\nc) Add field equations\nd) use MPolynomial.variety()\n\nThis is guaranteed to be correct, but is probably a bit sub-optimal. Adding the field equations may destroy the Groebner basis, but my guess is that running the buchberger algorithm again should do little work.\n\nThis is implemented by the second patch.\n\nPerformance-wise, the gain is decent (as expected from the use of PolyBoRi):\n\n```\nsage: n = 14\nsage: R = BooleanPolynomialRing(n, ['x%d'%(i+1) for i in range(n)], order='lex')\nsage: polys = [ sum([ GF(2).random_element() * R.gen(i) * R.gen(j) for i in range(n) for j in range(n)]) for k in range(n)]\nsage: I = R.ideal( polys )\nsage: time V1 = I.variety()\nTime: CPU 0.51 s, Wall: 0.54 s\n\nsage: R = PolynomialRing(GF(2), n, ['x%d'%(i+1) for i in range(n)], order='lex')\nsage: I = R.ideal( polys )\nsage: time V2 = (I + sage.rings.ideal.FieldIdeal(R)).variety()\nTime: CPU 9.12 s, Wall: 9.16 s\n\nsage: V1 == V2\nTrue\n```",
    "created_at": "2012-06-12T16:16:35Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155495",
    "user": "https://trac.sagemath.org/admin/accounts/users/Bouillaguet"
}
```

The cause of the bug in "positive" dimension (without the field equations) is that BooleanPolynomialIdeal.groebner_basis() computes a groebner basis **modulo the field equations**, but this is not a Groebner basis in general.

Obvious fix :
a) Compute GB modulo field equations with BooleanPolynomialIdeal.groebner_basis()
b) cast to MPolynomial
c) Add field equations
d) use MPolynomial.variety()

This is guaranteed to be correct, but is probably a bit sub-optimal. Adding the field equations may destroy the Groebner basis, but my guess is that running the buchberger algorithm again should do little work.

This is implemented by the second patch.

Performance-wise, the gain is decent (as expected from the use of PolyBoRi):

```
sage: n = 14
sage: R = BooleanPolynomialRing(n, ['x%d'%(i+1) for i in range(n)], order='lex')
sage: polys = [ sum([ GF(2).random_element() * R.gen(i) * R.gen(j) for i in range(n) for j in range(n)]) for k in range(n)]
sage: I = R.ideal( polys )
sage: time V1 = I.variety()
Time: CPU 0.51 s, Wall: 0.54 s

sage: R = PolynomialRing(GF(2), n, ['x%d'%(i+1) for i in range(n)], order='lex')
sage: I = R.ideal( polys )
sage: time V2 = (I + sage.rings.ideal.FieldIdeal(R)).variety()
Time: CPU 9.12 s, Wall: 9.16 s

sage: V1 == V2
True
```



---

archive/issue_comments_155496.json:
```json
{
    "body": "Attachment [boolean_ideal_variety.patch](tarball://root/attachments/some-uuid/ticket13103/boolean_ideal_variety.patch) by Bouillaguet created at 2012-06-12 16:17:11\n\noverloaded variety function for BooleanPolynomialIdeal",
    "created_at": "2012-06-12T16:17:11Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155496",
    "user": "https://trac.sagemath.org/admin/accounts/users/Bouillaguet"
}
```

Attachment [boolean_ideal_variety.patch](tarball://root/attachments/some-uuid/ticket13103/boolean_ideal_variety.patch) by Bouillaguet created at 2012-06-12 16:17:11

overloaded variety function for BooleanPolynomialIdeal



---

archive/issue_comments_155497.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2012-06-12T16:19:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155497",
    "user": "https://trac.sagemath.org/admin/accounts/users/Bouillaguet"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_155498.json:
```json
{
    "body": "Replying to [comment:2 Bouillaguet]:\n> The cause of the bug in \"positive\" dimension (without the field equations) is that BooleanPolynomialIdeal.groebner_basis() computes a groebner basis **modulo the field equations**, but this is not a Groebner basis in general.\n\n \n> Obvious fix :\n> a) Compute GB modulo field equations with BooleanPolynomialIdeal.groebner_basis()\n> b) cast to MPolynomial\n> c) Add field equations\n> d) use MPolynomial.variety()\n> \n> This is guaranteed to be correct, but is probably a bit sub-optimal. Adding the field equations may destroy the Groebner basis, but my guess is that running the buchberger algorithm again should do little work.\n\n\nActually, adding the field equations would not destroy the GB, as PolyBoRi actually computes the GB with the field equations implicitly added. The result + field equations is a GB wrt to GF(2)[x1,...xn].\n \n> This is implemented by the second patch.\n\n\nThis strategy looks fine to me. IIRC there is some special code in PolyBoRi to do this faster, but for now this simple approach fixes an embarrassing bug.",
    "created_at": "2012-06-13T10:24:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155498",
    "user": "https://github.com/malb"
}
```

Replying to [comment:2 Bouillaguet]:
> The cause of the bug in "positive" dimension (without the field equations) is that BooleanPolynomialIdeal.groebner_basis() computes a groebner basis **modulo the field equations**, but this is not a Groebner basis in general.

 
> Obvious fix :
> a) Compute GB modulo field equations with BooleanPolynomialIdeal.groebner_basis()
> b) cast to MPolynomial
> c) Add field equations
> d) use MPolynomial.variety()
> 
> This is guaranteed to be correct, but is probably a bit sub-optimal. Adding the field equations may destroy the Groebner basis, but my guess is that running the buchberger algorithm again should do little work.


Actually, adding the field equations would not destroy the GB, as PolyBoRi actually computes the GB with the field equations implicitly added. The result + field equations is a GB wrt to GF(2)[x1,...xn].
 
> This is implemented by the second patch.


This strategy looks fine to me. IIRC there is some special code in PolyBoRi to do this faster, but for now this simple approach fixes an embarrassing bug.



---

archive/issue_comments_155499.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2012-06-13T10:26:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155499",
    "user": "https://github.com/malb"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_155500.json:
```json
{
    "body": "Patch looks good to me.",
    "created_at": "2012-06-13T10:26:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155500",
    "user": "https://github.com/malb"
}
```

Patch looks good to me.



---

archive/issue_events_036049.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2012-06-18T13:33:51Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "milestone": "sage-5.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12931#event-36049"
}
```



---

archive/issue_comments_155501.json:
```json
{
    "body": "Since it could be done more efficient low-level, I'll add `p.is_univariate()`-support upstream later.",
    "created_at": "2012-06-25T09:19:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155501",
    "user": "https://github.com/alexanderdreyer"
}
```

Since it could be done more efficient low-level, I'll add `p.is_univariate()`-support upstream later.



---

archive/issue_comments_155502.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2012-07-02T15:25:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/12931#issuecomment-155502",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_036050.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2012-07-02T15:25:16Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/12931",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/12931#event-36050"
}
```
