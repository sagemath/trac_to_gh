# Issue 15883: Add a _float_ method to the class Universal Cyclotomic Field

archive/issues_015883.json:
```json
{
    "body": "CC:  jipilab stumpc5 sage-combinat tmonteil\n\nKeywords: Cyclotomic field, float, days57\n\nThere is currently no _float_ method for the class Universal Cyclotomic Field. For example:\n\n\n```\n    sage: UCF.<E> = UniversalCyclotomicField()\n    sage: float(E(5)+E(5)^(-1))\n    ---------------------------------------------------------------------------\n    TypeError                                 Traceback (most recent call last)\n    <ipython-input-2-0d63f957cb28> in <module>()\n    ----> 1 float(E(Integer(5))+E(Integer(5))**(-Integer(1)))\n\n    TypeError: float() argument must be a string or a number\n    \n    sage: float(CDF(E(5)+E(5)^(-1)).real_part())\n    0.6180339887498949\n\n```\n\n\nWe would like something such as:\n\n```\n\n    sage: float(E(5)+E(5)^(-1))\n    0.6180339887498949\n\n```\n  \nThis ticket is a prerequisite to #15703.\n\nIssue created by migration from https://trac.sagemath.org/ticket/16120\n\n",
    "created_at": "2014-04-10T09:38:12Z",
    "labels": [
        "number fields",
        "minor",
        "enhancement"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.2",
    "title": "Add a _float_ method to the class Universal Cyclotomic Field",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/15883",
    "user": "vripoll"
}
```
CC:  jipilab stumpc5 sage-combinat tmonteil

Keywords: Cyclotomic field, float, days57

There is currently no _float_ method for the class Universal Cyclotomic Field. For example:


```
    sage: UCF.<E> = UniversalCyclotomicField()
    sage: float(E(5)+E(5)^(-1))
    ---------------------------------------------------------------------------
    TypeError                                 Traceback (most recent call last)
    <ipython-input-2-0d63f957cb28> in <module>()
    ----> 1 float(E(Integer(5))+E(Integer(5))**(-Integer(1)))

    TypeError: float() argument must be a string or a number
    
    sage: float(CDF(E(5)+E(5)^(-1)).real_part())
    0.6180339887498949

```


We would like something such as:

```

    sage: float(E(5)+E(5)^(-1))
    0.6180339887498949

```
  
This ticket is a prerequisite to #15703.

Issue created by migration from https://trac.sagemath.org/ticket/16120





---

archive/issue_comments_206296.json:
```json
{
    "body": "What is wrong with using CLF rather than CDF? If the former is possible, I would prefer to use it.\n----\nNew commits:",
    "created_at": "2014-04-10T12:12:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206296",
    "user": "stumpc5"
}
```

What is wrong with using CLF rather than CDF? If the former is possible, I would prefer to use it.
----
New commits:



---

archive/issue_comments_206297.json:
```json
{
    "body": "New commits:",
    "created_at": "2014-04-10T12:17:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206297",
    "user": "vripoll"
}
```

New commits:



---

archive/issue_comments_206298.json:
```json
{
    "body": "I don't know, but what is better with CLF? A timing test is favorable towards CDF:\n\n```\n    sage: UCF.<E> = UniversalCyclotomicField()\n    sage: b=E(5)+E(5)^(-1)\n    sage: %timeit float(CDF(b).real_part())\n    1000 loops, best of 3: 1.06 ms per loop\n    sage: %timeit float(CLF(b))\n    100 loops, best of 3: 3.41 ms per loop\n\n```\n",
    "created_at": "2014-04-10T12:39:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206298",
    "user": "vripoll"
}
```

I don't know, but what is better with CLF? A timing test is favorable towards CDF:

```
    sage: UCF.<E> = UniversalCyclotomicField()
    sage: b=E(5)+E(5)^(-1)
    sage: %timeit float(CDF(b).real_part())
    1000 loops, best of 3: 1.06 ms per loop
    sage: %timeit float(CLF(b))
    100 loops, best of 3: 3.41 ms per loop

```




---

archive/issue_comments_206299.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2014-04-10T12:47:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206299",
    "user": "vripoll"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_206300.json:
```json
{
    "body": "Replying to [comment:4 vripoll]:\n> I don't know, but what is better with CLF?\n\nThe ComplexLazyField gives you as much precision as you want, while the ComplexDoubleField is restricted\n\n```\nsage: a = CLF(e)\nsage: b = CDF(e)\nsage: a\n2.718281828459046?\nsage: b\n2.71828182846\n```\n",
    "created_at": "2014-04-10T22:10:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206300",
    "user": "stumpc5"
}
```

Replying to [comment:4 vripoll]:
> I don't know, but what is better with CLF?

The ComplexLazyField gives you as much precision as you want, while the ComplexDoubleField is restricted

```
sage: a = CLF(e)
sage: b = CDF(e)
sage: a
2.718281828459046?
sage: b
2.71828182846
```




---

archive/issue_comments_206301.json:
```json
{
    "body": "Replying to [comment:6 stumpc5]:\n> The ComplexLazyField gives you as much precision as you want, while the ComplexDoubleField is restricted\n\nBut `__float__` is supposed to return a Python float, so you don't need the extra precision...\n\nVivien: wouldn't a `ValueError` be more appropriate in the case where the element you want to convert is not real?",
    "created_at": "2014-04-11T09:18:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206301",
    "user": "mmezzarobba"
}
```

Replying to [comment:6 stumpc5]:
> The ComplexLazyField gives you as much precision as you want, while the ComplexDoubleField is restricted

But `__float__` is supposed to return a Python float, so you don't need the extra precision...

Vivien: wouldn't a `ValueError` be more appropriate in the case where the element you want to convert is not real?



---

archive/issue_comments_206302.json:
```json
{
    "body": "I have corrected the doctest, that was failing. And also changed to ValueError\n\nAnd also used python3 syntax\n\nThis looks good to me. If nobody else disagrees, and my changes are ok, you can set to positive review.\n----\nNew commits:",
    "created_at": "2014-04-11T09:26:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206302",
    "user": "chapoton"
}
```

I have corrected the doctest, that was failing. And also changed to ValueError

And also used python3 syntax

This looks good to me. If nobody else disagrees, and my changes are ok, you can set to positive review.
----
New commits:



---

archive/issue_comments_206303.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2014-04-11T09:40:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206303",
    "user": "mmezzarobba"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_206304.json:
```json
{
    "body": "I was working on this review but you are all too fast for me :)\n\nI have some issues with testing this method.\n\n\n```\nsage: UCF.<E> = UniversalCyclotomicField()\nsage: e = 3/2*E(7) + E(7)^3 + E(7)^4 + 3/2*E(7)^6\nsage: e.is_real()\nTrue\nsage: CDF(e)\n0.0685316697714 + 1.62630325873e-19*I\n```\n\n\nMeaning that somewhere the rounding is not correct (at least for the imaginary\npart) with the computation of `CDF(e)`. Hence `float(CDF(self).real_part())`\nlooks like a post-processing of an error somewhere. But i do not see any\nreason why the rounding of the real part will be better.\n\nAs your number is already real, i would prefer to do `float(AA(e))`: here the\n\"real part projection\" is done on the exact side (and the method `real_exact`\nof `AA` will be called only once). It is however between two and three times\nslower.\n\nWhat do you think about this ?\n\nBy the way, it could be nice to be able to have `RR(e)`, `RIF(e)` and `CIF(e)`\nwork as well.\n\n\nThat said:\n\n```\nsage: UCF.<E> = UniversalCyclotomicField()\nsage: e = 3/2*E(7) + E(7)^3 + E(7)^4 + 3/2*E(7)^6\nsage: float(e) == float(AA(e))\nFalse\nsage: float(e) < float(AA(e))\nTrue\nsage: RIF = RealIntervalField(100)\nsage: RIF(float(e)).endpoints()[0] < RIF(AA(e)).endpoints()[0] < RIF(AA(e)).endpoints()[1] < RIF(float(AA(e))).endpoints()[0]\nTrue\nsage: RIF(AA(e)).endpoints()[1] - RIF(float(e)).endpoints()[0]\n5.9704982077798935821915405952e-19\nsage: RIF(float(AA(e))).endpoints()[0] - RIF(AA(e)).endpoints()[1]\n1.3280737987036467397076241791e-17\n```\n\n\nMeaning that `e` is closer to `float(e)` than `float(AA(e))` which are both\nfloating point numbers of the same precision, and the default rounding mode is\ndone \"to the nearest\". The conversion from `AA` to `RR` (hence to `float`) is\nassuming to respect the rounding mode, since the doc explicitely claims to\nrespect the rounding mode. This has to be explored, though it is not part of\nthis ticket.",
    "created_at": "2014-04-11T12:25:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206304",
    "user": "tmonteil"
}
```

I was working on this review but you are all too fast for me :)

I have some issues with testing this method.


```
sage: UCF.<E> = UniversalCyclotomicField()
sage: e = 3/2*E(7) + E(7)^3 + E(7)^4 + 3/2*E(7)^6
sage: e.is_real()
True
sage: CDF(e)
0.0685316697714 + 1.62630325873e-19*I
```


Meaning that somewhere the rounding is not correct (at least for the imaginary
part) with the computation of `CDF(e)`. Hence `float(CDF(self).real_part())`
looks like a post-processing of an error somewhere. But i do not see any
reason why the rounding of the real part will be better.

As your number is already real, i would prefer to do `float(AA(e))`: here the
"real part projection" is done on the exact side (and the method `real_exact`
of `AA` will be called only once). It is however between two and three times
slower.

What do you think about this ?

By the way, it could be nice to be able to have `RR(e)`, `RIF(e)` and `CIF(e)`
work as well.


That said:

```
sage: UCF.<E> = UniversalCyclotomicField()
sage: e = 3/2*E(7) + E(7)^3 + E(7)^4 + 3/2*E(7)^6
sage: float(e) == float(AA(e))
False
sage: float(e) < float(AA(e))
True
sage: RIF = RealIntervalField(100)
sage: RIF(float(e)).endpoints()[0] < RIF(AA(e)).endpoints()[0] < RIF(AA(e)).endpoints()[1] < RIF(float(AA(e))).endpoints()[0]
True
sage: RIF(AA(e)).endpoints()[1] - RIF(float(e)).endpoints()[0]
5.9704982077798935821915405952e-19
sage: RIF(float(AA(e))).endpoints()[0] - RIF(AA(e)).endpoints()[1]
1.3280737987036467397076241791e-17
```


Meaning that `e` is closer to `float(e)` than `float(AA(e))` which are both
floating point numbers of the same precision, and the default rounding mode is
done "to the nearest". The conversion from `AA` to `RR` (hence to `float`) is
assuming to respect the rounding mode, since the doc explicitely claims to
respect the rounding mode. This has to be explored, though it is not part of
this ticket.



---

archive/issue_comments_206305.json:
```json
{
    "body": "Changing status from positive_review to needs_info.",
    "created_at": "2014-04-11T12:25:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206305",
    "user": "tmonteil"
}
```

Changing status from positive_review to needs_info.



---

archive/issue_comments_206306.json:
```json
{
    "body": "Replying to [comment:10 tmonteil]:\n> As your number is already real, i would prefer to do `float(AA(e))`: here the\n> \"real part projection\" is done on the exact side (and the method `real_exact`\n> of `AA` will be called only once). It is however between two and three times\n> slower.\n> \n> What do you think about this ?\n\nI prefer the current version, because, as far as I understand, the test that `e` is real implied by `AA(e)` (`AA._element_constructor_` testing that the imaginary part of `QQbar(e)` is zero)  can be much more expensive than `e.is_real()`. And I don't really see the point of computing an exact representation of the real part if what we want in the end is an approximation.eans that \n\n> By the way, it could be nice to be able to have `RR(e)`, `RIF(e)` and `CIF(e)`\n> work as well.\n\nSure. But not necessarily as part of this ticket.\n\n> The conversion from `AA` to `RR` (hence to `float`) is\n> assuming to respect the rounding mode, since the doc explicitely claims to\n> respect the rounding mode. \n\nFrom `AA` to `RR`, yes, but why \"hence to `float`\"?\n\nThat being said, I agree that the conversion from `AA` to `RR` does not seem to round to nearest:\n\n```\nsage: a = AA(e); r = RR(a)\nsage: r.exact_rational() - a\n1.328?e-17\nsage: r.nextbelow().exact_rational() - a\n-6.0?e-19\n```\n",
    "created_at": "2014-04-11T13:21:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206306",
    "user": "mmezzarobba"
}
```

Replying to [comment:10 tmonteil]:
> As your number is already real, i would prefer to do `float(AA(e))`: here the
> "real part projection" is done on the exact side (and the method `real_exact`
> of `AA` will be called only once). It is however between two and three times
> slower.
> 
> What do you think about this ?

I prefer the current version, because, as far as I understand, the test that `e` is real implied by `AA(e)` (`AA._element_constructor_` testing that the imaginary part of `QQbar(e)` is zero)  can be much more expensive than `e.is_real()`. And I don't really see the point of computing an exact representation of the real part if what we want in the end is an approximation.eans that 

> By the way, it could be nice to be able to have `RR(e)`, `RIF(e)` and `CIF(e)`
> work as well.

Sure. But not necessarily as part of this ticket.

> The conversion from `AA` to `RR` (hence to `float`) is
> assuming to respect the rounding mode, since the doc explicitely claims to
> respect the rounding mode. 

From `AA` to `RR`, yes, but why "hence to `float`"?

That being said, I agree that the conversion from `AA` to `RR` does not seem to round to nearest:

```
sage: a = AA(e); r = RR(a)
sage: r.exact_rational() - a
1.328?e-17
sage: r.nextbelow().exact_rational() - a
-6.0?e-19
```




---

archive/issue_comments_206307.json:
```json
{
    "body": "Replying to [comment:10 tmonteil]:\n> The conversion from `AA` to `RR` (hence to `float`) is\n> assuming to respect the rounding mode, since the doc explicitely claims to\n> respect the rounding mode.\n\nHmm, are you referring to the docstring of `AlgebraicReal.real_number()`? It states that \"The approximation will be off by at most two ulp's\" and \"the rounding mode of the field is respected\"... but what can it possibly mean to respect RNDN without guaranteeing an error < 1/2 ulp???",
    "created_at": "2014-04-11T13:28:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206307",
    "user": "mmezzarobba"
}
```

Replying to [comment:10 tmonteil]:
> The conversion from `AA` to `RR` (hence to `float`) is
> assuming to respect the rounding mode, since the doc explicitely claims to
> respect the rounding mode.

Hmm, are you referring to the docstring of `AlgebraicReal.real_number()`? It states that "The approximation will be off by at most two ulp's" and "the rounding mode of the field is respected"... but what can it possibly mean to respect RNDN without guaranteeing an error < 1/2 ulp???



---

archive/issue_comments_206308.json:
```json
{
    "body": "Thank you Fred for your review and correction of syntax. Thanks Marc and Thierry for the technical discussion, I'm learning a lot! I'll wait for some consensus before doing any change.",
    "created_at": "2014-04-11T14:56:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206308",
    "user": "vripoll"
}
```

Thank you Fred for your review and correction of syntax. Thanks Marc and Thierry for the technical discussion, I'm learning a lot! I'll wait for some consensus before doing any change.



---

archive/issue_comments_206309.json:
```json
{
    "body": "So, what remains to be done here ?",
    "created_at": "2014-04-14T19:06:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206309",
    "user": "chapoton"
}
```

So, what remains to be done here ?



---

archive/issue_comments_206310.json:
```json
{
    "body": "Replying to [comment:14 chapoton]:\n> So, what remains to be done here ?\n\nI don't know: I am happy with the patch as it is, but Thierry seemed to disagree, and I'd like to hear his opinion on my last few comments...",
    "created_at": "2014-04-14T20:06:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206310",
    "user": "mmezzarobba"
}
```

Replying to [comment:14 chapoton]:
> So, what remains to be done here ?

I don't know: I am happy with the patch as it is, but Thierry seemed to disagree, and I'd like to hear his opinion on my last few comments...



---

archive/issue_comments_206311.json:
```json
{
    "body": "Replying to [comment:11]:\n> \n> I prefer the current version, because, as far as I understand, the test that `e` is real implied by `AA(e)` (`AA._element_constructor_` testing that the imaginary part of `QQbar(e)` is zero)  can be much more expensive than `e.is_real()`. And I don't really see the point of computing an exact representation of the real part if what we want in the end is an approximation.\n\nYou are right about the timings (the `AA` method is between 2 and 3 times slower). But the advantage with `float(AA(e))` is that you have a direct conversion from `AA` to `RR`, not a conversion inherited from the coercion mechanism, which is less easy to control (unless all parts of Sage are floating-point accurate, which is unfortunately not true).\n\n> > By the way, it could be nice to be able to have `RR(e)`, `RIF(e)` and `CIF(e)`\n> > work as well.\n> \n> Sure. But not necessarily as part of this ticket.\n\nOf course, this was only a suggestion for a further work on universal cyclotomic field.\n\n> > The conversion from `AA` to `RR` (hence to `float`) is\n> > assuming to respect the rounding mode, since the doc explicitely claims to\n> > respect the rounding mode. \n> \n> From `AA` to `RR`, yes, but why \"hence to `float`\"?\n\nBecause the method `__float__` of `AA` is just `return float(RR(self))`.\n\nReplying to [comment:12]:\n> Hmm, are you referring to the docstring of `AlgebraicReal.real_number()`? It states that \"The approximation will be off by at most two ulp's\" and \"the rounding mode of the field is respected\"... but what can it possibly mean to respect RNDN without guaranteeing an error < 1/2 ulp???\n\nYes, this is meaningless and i plan to fix it soon, see #16163. It should not cost much more time than now to have the right rounding since the current method already uses MPFI, it is only a matter of used digits (the current choice could have made sense if it was using CPU 53 bits precision arithmetics).\n\nReplying to [comment:15]:\n> I don't know: I am happy with the patch as it is, but Thierry seemed to disagree, and I'd like to hear his opinion on my last few comments...\n\nIf you are all ok with the current implementation, i am fine with it, especially i understood that this method is created for plotting. I will make stronger tests, if necessary i will open a new ticket, but i do not want to block this.",
    "created_at": "2014-04-14T21:19:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206311",
    "user": "tmonteil"
}
```

Replying to [comment:11]:
> 
> I prefer the current version, because, as far as I understand, the test that `e` is real implied by `AA(e)` (`AA._element_constructor_` testing that the imaginary part of `QQbar(e)` is zero)  can be much more expensive than `e.is_real()`. And I don't really see the point of computing an exact representation of the real part if what we want in the end is an approximation.

You are right about the timings (the `AA` method is between 2 and 3 times slower). But the advantage with `float(AA(e))` is that you have a direct conversion from `AA` to `RR`, not a conversion inherited from the coercion mechanism, which is less easy to control (unless all parts of Sage are floating-point accurate, which is unfortunately not true).

> > By the way, it could be nice to be able to have `RR(e)`, `RIF(e)` and `CIF(e)`
> > work as well.
> 
> Sure. But not necessarily as part of this ticket.

Of course, this was only a suggestion for a further work on universal cyclotomic field.

> > The conversion from `AA` to `RR` (hence to `float`) is
> > assuming to respect the rounding mode, since the doc explicitely claims to
> > respect the rounding mode. 
> 
> From `AA` to `RR`, yes, but why "hence to `float`"?

Because the method `__float__` of `AA` is just `return float(RR(self))`.

Replying to [comment:12]:
> Hmm, are you referring to the docstring of `AlgebraicReal.real_number()`? It states that "The approximation will be off by at most two ulp's" and "the rounding mode of the field is respected"... but what can it possibly mean to respect RNDN without guaranteeing an error < 1/2 ulp???

Yes, this is meaningless and i plan to fix it soon, see #16163. It should not cost much more time than now to have the right rounding since the current method already uses MPFI, it is only a matter of used digits (the current choice could have made sense if it was using CPU 53 bits precision arithmetics).

Replying to [comment:15]:
> I don't know: I am happy with the patch as it is, but Thierry seemed to disagree, and I'd like to hear his opinion on my last few comments...

If you are all ok with the current implementation, i am fine with it, especially i understood that this method is created for plotting. I will make stronger tests, if necessary i will open a new ticket, but i do not want to block this.



---

archive/issue_comments_206312.json:
```json
{
    "body": "Changing status from needs_info to positive_review.",
    "created_at": "2014-04-14T21:27:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206312",
    "user": "tmonteil"
}
```

Changing status from needs_info to positive_review.



---

archive/issue_comments_206313.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2014-04-15T23:19:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/15883",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/15883#issuecomment-206313",
    "user": "vbraun"
}
```

Resolution: fixed
