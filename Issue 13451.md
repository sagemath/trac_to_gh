# Issue 13451: anonymous symbols lose their identity when passed through maxima

archive/issues_013451.json:
```json
{
    "body": "Assignee: burcin\n\nWhen a symbol returned by `SR.symbol()` is passed through Maxima, it is turned into another symbol. They compare equal (because comparison invokes Maxima, probably) but they are not the same object.\n\nThis sounds as if it should not make a big difference, but it does in the case of Taylor series. In this example, I try to obtain taylor series coefficients. The call to `coefficient` returns zero, however, because the variable has changed identity because the Taylor series was generated by Maxima.\n\n\n\n```\nsage: s = SR.symbol()\nsage: converted_s = s._maxima_().sage()\nsage: converted_s is s\nFalse\nsage: bool(converted_s == s)\nTrue\nsage: x1 = var('x1')\nsage: converted_x1 = x1._maxima_().sage()\nsage: converted_x1 is x1\nTrue\nsage: bool(converted_x1 == x1)\nTrue\nsage: (3*x1).coefficient(converted_x1)\n3\nsage: (3*s).coefficient(converted_s)\n0\nsage: (x1^2 + 3*x1 + 1).taylor(x1,0,2).coefficient(x1)\n3\nsage: (s^2 + 3*s + 1).taylor(s,0,2).coefficient(s)\n0\n\n```\n\n\nIssue created by migration from https://trac.sagemath.org/ticket/13655\n\n",
    "created_at": "2012-10-26T13:40:40Z",
    "labels": [
        "symbolics",
        "major",
        "bug"
    ],
    "title": "anonymous symbols lose their identity when passed through maxima",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/13451",
    "user": "tkluck"
}
```
Assignee: burcin

When a symbol returned by `SR.symbol()` is passed through Maxima, it is turned into another symbol. They compare equal (because comparison invokes Maxima, probably) but they are not the same object.

This sounds as if it should not make a big difference, but it does in the case of Taylor series. In this example, I try to obtain taylor series coefficients. The call to `coefficient` returns zero, however, because the variable has changed identity because the Taylor series was generated by Maxima.



```
sage: s = SR.symbol()
sage: converted_s = s._maxima_().sage()
sage: converted_s is s
False
sage: bool(converted_s == s)
True
sage: x1 = var('x1')
sage: converted_x1 = x1._maxima_().sage()
sage: converted_x1 is x1
True
sage: bool(converted_x1 == x1)
True
sage: (3*x1).coefficient(converted_x1)
3
sage: (3*s).coefficient(converted_s)
0
sage: (x1^2 + 3*x1 + 1).taylor(x1,0,2).coefficient(x1)
3
sage: (s^2 + 3*s + 1).taylor(s,0,2).coefficient(s)
0

```


Issue created by migration from https://trac.sagemath.org/ticket/13655





---

archive/issue_comments_165871.json:
```json
{
    "body": "The problem is a little more widespread:\n\n```\nsage: s = SR.symbol()\nsage: s1 = s._maxima_().sage()\nsage: s2 = sage.calculus.calculus.maxima(s).sage()\nsage: s3 = integrate(s,s).variables()[0]\nsage: [id(s),id(s1),id(s2),id(s3)]\n[140326504362424, 96060840, 96060840, 96060696]\nsage: (s^2 + 3*s + 1).taylor(s,0,2).coefficient(s3)\n0\nsage: (s1^2 + 3*s1 + 1).taylor(s1,0,2).coefficient(s3)\n0\nsage: (s3^2 + 3*s3 + 1).taylor(s3,0,2).coefficient(s1)\n3\n```\n\n\n```\nsage: s = SR('t')\nsage: s1 = s._maxima_().sage()\nsage: s2 = sage.calculus.calculus.maxima(s).sage()\nsage: s3 = integrate(s,s).variables()[0]\nsage: [id(s),id(s1),id(s2),id(s3)]\n[95996024, 95996024, 95996024, 96062064]\nsage: (s^2 + 3*s + 1).taylor(s,0,2).coefficient(s3)\n3\nsage: L=[integrate(s,s).variables()[0] for i in range(10)]\nsage: [id(l) for  l in L]\n[96062928, 96061704, 96062568, 96061200, 97231576, 97231504, 97231936, 97232008, 97232080, 97232152]\n```\n\nAs you see, the variables produced by integrate, which go through the symbol-based interface with libmaxima (i.e., no direct string translations) don't maintain symbol identity at all. However, that doesn't always seem to affect how they behave (perhaps the python wrapper id doesn't reflect the identity of the wrapped pynac entity).\n\nPerhaps `SR.symbol` produces an \"uninterned\" symbol? In that case, the most straightforward solution would be to let `SR.symbol()` produce interned symbols. That would leak memory, but converting symbols to maxima already does (because we have to interface with a non-refcounting system)",
    "created_at": "2012-10-26T15:21:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165871",
    "user": "nbruin"
}
```

The problem is a little more widespread:

```
sage: s = SR.symbol()
sage: s1 = s._maxima_().sage()
sage: s2 = sage.calculus.calculus.maxima(s).sage()
sage: s3 = integrate(s,s).variables()[0]
sage: [id(s),id(s1),id(s2),id(s3)]
[140326504362424, 96060840, 96060840, 96060696]
sage: (s^2 + 3*s + 1).taylor(s,0,2).coefficient(s3)
0
sage: (s1^2 + 3*s1 + 1).taylor(s1,0,2).coefficient(s3)
0
sage: (s3^2 + 3*s3 + 1).taylor(s3,0,2).coefficient(s1)
3
```


```
sage: s = SR('t')
sage: s1 = s._maxima_().sage()
sage: s2 = sage.calculus.calculus.maxima(s).sage()
sage: s3 = integrate(s,s).variables()[0]
sage: [id(s),id(s1),id(s2),id(s3)]
[95996024, 95996024, 95996024, 96062064]
sage: (s^2 + 3*s + 1).taylor(s,0,2).coefficient(s3)
3
sage: L=[integrate(s,s).variables()[0] for i in range(10)]
sage: [id(l) for  l in L]
[96062928, 96061704, 96062568, 96061200, 97231576, 97231504, 97231936, 97232008, 97232080, 97232152]
```

As you see, the variables produced by integrate, which go through the symbol-based interface with libmaxima (i.e., no direct string translations) don't maintain symbol identity at all. However, that doesn't always seem to affect how they behave (perhaps the python wrapper id doesn't reflect the identity of the wrapped pynac entity).

Perhaps `SR.symbol` produces an "uninterned" symbol? In that case, the most straightforward solution would be to let `SR.symbol()` produce interned symbols. That would leak memory, but converting symbols to maxima already does (because we have to interface with a non-refcounting system)



---

archive/issue_comments_165872.json:
```json
{
    "body": "What do you mean by an \"uninterned\" symbol? Is that a Sage, a Pynac, or a Maxima concept?",
    "created_at": "2012-10-26T16:04:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165872",
    "user": "tkluck"
}
```

What do you mean by an "uninterned" symbol? Is that a Sage, a Pynac, or a Maxima concept?



---

archive/issue_comments_165873.json:
```json
{
    "body": "You can google \"string interning\". It's a standard technique that is usually employed for symbol-type objects. For \"interned\" objects, equality implies identity. I suspect Pynac does something like that internally.\n\nSome systems have both interned and uninterned strings/symbols. Using the latter in a context where the former is expected results exactly in the behaviour you observed. That's why I mentioned it, but a pynac expert (which I'm not) can probably quickly tell if this is the problem here.",
    "created_at": "2012-10-26T16:54:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165873",
    "user": "nbruin"
}
```

You can google "string interning". It's a standard technique that is usually employed for symbol-type objects. For "interned" objects, equality implies identity. I suspect Pynac does something like that internally.

Some systems have both interned and uninterned strings/symbols. Using the latter in a context where the former is expected results exactly in the behaviour you observed. That's why I mentioned it, but a pynac expert (which I'm not) can probably quickly tell if this is the problem here.



---

archive/issue_comments_165874.json:
```json
{
    "body": "Replying to [comment:3 nbruin]:\n> Some systems have both interned and uninterned strings/symbols. Using the latter in a context where the former is expected results exactly in the behaviour you observed. That's why I mentioned it, but a pynac expert (which I'm not) can probably quickly tell if this is the problem here.\n\n`SR.symbol()` is intended to return uninterned symbols when called without an argument. In the source, you will see that there is a branch `if name is None:` where `pynac_symbol_registry[name] = e` is not called. My intention was to let the user create symbolic variables without the risk of picking the name of a variable used in the input. \n\nThe conversion back from Maxima always creates an interned symbol if it cannot find one already existing in the registry. I admit that this use case never occured to me before. So we have a bug.\n\nI don't want to lose the current `SR.symbol()` behavior (uninterned symbols). One possible solution here is to keep two symbol registries. Keeping the current one and introducing a new one which contains all symbols including the \"uninterned\" ones, to be used for Maxima conversions.",
    "created_at": "2012-11-07T13:40:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165874",
    "user": "burcin"
}
```

Replying to [comment:3 nbruin]:
> Some systems have both interned and uninterned strings/symbols. Using the latter in a context where the former is expected results exactly in the behaviour you observed. That's why I mentioned it, but a pynac expert (which I'm not) can probably quickly tell if this is the problem here.

`SR.symbol()` is intended to return uninterned symbols when called without an argument. In the source, you will see that there is a branch `if name is None:` where `pynac_symbol_registry[name] = e` is not called. My intention was to let the user create symbolic variables without the risk of picking the name of a variable used in the input. 

The conversion back from Maxima always creates an interned symbol if it cannot find one already existing in the registry. I admit that this use case never occured to me before. So we have a bug.

I don't want to lose the current `SR.symbol()` behavior (uninterned symbols). One possible solution here is to keep two symbol registries. Keeping the current one and introducing a new one which contains all symbols including the "uninterned" ones, to be used for Maxima conversions.



---

archive/issue_comments_165875.json:
```json
{
    "body": "Replying to [comment:4 burcin]:\n> `SR.symbol()` is intended to return uninterned symbols when called without an argument. In the source, you will see that there is a branch `if name is None:` where `pynac_symbol_registry[name] = e` is not called. My intention was to let the user create symbolic variables without the risk of picking the name of a variable used in the input. \n\nMaxima (or lisp for that matter) does have uninterned symbols as well. You won't recognize them from their string representation, though (unless you introduce a naming convention). However, if upon creation you store an attribute on them, you can still identify them as \"uninterned\" and create the corresponding uninterned symbol in Pynac as well. For the binary libmaxima interface this is pretty straightforward. For string-based (and there is really not much reason anymore to keep using that for calculus other than laziness for moving the remaining routines over) it's a little trickier.\n\n**EDIT:** However, this is not going to help with translation between the two systems: If you want to log the mapping between uninterned symbols by identity then they're not really uninterned anymore (or at least, they'll leak memory just as normal symbols do).",
    "created_at": "2012-11-07T16:02:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165875",
    "user": "nbruin"
}
```

Replying to [comment:4 burcin]:
> `SR.symbol()` is intended to return uninterned symbols when called without an argument. In the source, you will see that there is a branch `if name is None:` where `pynac_symbol_registry[name] = e` is not called. My intention was to let the user create symbolic variables without the risk of picking the name of a variable used in the input. 

Maxima (or lisp for that matter) does have uninterned symbols as well. You won't recognize them from their string representation, though (unless you introduce a naming convention). However, if upon creation you store an attribute on them, you can still identify them as "uninterned" and create the corresponding uninterned symbol in Pynac as well. For the binary libmaxima interface this is pretty straightforward. For string-based (and there is really not much reason anymore to keep using that for calculus other than laziness for moving the remaining routines over) it's a little trickier.

**EDIT:** However, this is not going to help with translation between the two systems: If you want to log the mapping between uninterned symbols by identity then they're not really uninterned anymore (or at least, they'll leak memory just as normal symbols do).



---

archive/issue_comments_165876.json:
```json
{
    "body": "Changing component from symbolics to interfaces.",
    "created_at": "2015-01-13T16:16:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165876",
    "user": "rws"
}
```

Changing component from symbolics to interfaces.



---

archive/issue_comments_165877.json:
```json
{
    "body": "Changing assignee from burcin to was.",
    "created_at": "2015-01-13T16:16:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165877",
    "user": "rws"
}
```

Changing assignee from burcin to was.



---

archive/issue_comments_165878.json:
```json
{
    "body": "Changing assignee from was to burcin.",
    "created_at": "2015-01-13T16:55:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165878",
    "user": "rws"
}
```

Changing assignee from was to burcin.



---

archive/issue_comments_165879.json:
```json
{
    "body": "Oops, how did I do that?",
    "created_at": "2015-01-13T16:55:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165879",
    "user": "rws"
}
```

Oops, how did I do that?



---

archive/issue_comments_165880.json:
```json
{
    "body": "See also [this sage-devel discussion](https://groups.google.com/forum/#!topic/sage-devel/ktAt5_9xhOk) which apparently is about the same issue.",
    "created_at": "2016-01-22T16:00:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/13451",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/13451#issuecomment-165880",
    "user": "kcrisman"
}
```

See also [this sage-devel discussion](https://groups.google.com/forum/#!topic/sage-devel/ktAt5_9xhOk) which apparently is about the same issue.
