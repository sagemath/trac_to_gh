# Issue 13451: anonymous symbols lose their identity when passed through maxima

Issue created by migration from Trac.

Original creator: tkluck

Original creation time: 2012-10-26 13:40:40

Assignee: burcin

When a symbol returned by `SR.symbol()` is passed through Maxima, it is turned into another symbol. They compare equal (because comparison invokes Maxima, probably) but they are not the same object.

This sounds as if it should not make a big difference, but it does in the case of Taylor series. In this example, I try to obtain taylor series coefficients. The call to `coefficient` returns zero, however, because the variable has changed identity because the Taylor series was generated by Maxima.



```
sage: s = SR.symbol()
sage: converted_s = s._maxima_().sage()
sage: converted_s is s
False
sage: bool(converted_s == s)
True
sage: x1 = var('x1')
sage: converted_x1 = x1._maxima_().sage()
sage: converted_x1 is x1
True
sage: bool(converted_x1 == x1)
True
sage: (3*x1).coefficient(converted_x1)
3
sage: (3*s).coefficient(converted_s)
0
sage: (x1^2 + 3*x1 + 1).taylor(x1,0,2).coefficient(x1)
3
sage: (s^2 + 3*s + 1).taylor(s,0,2).coefficient(s)
0

```



---

Comment by nbruin created at 2012-10-26 15:21:14

The problem is a little more widespread:

```
sage: s = SR.symbol()
sage: s1 = s._maxima_().sage()
sage: s2 = sage.calculus.calculus.maxima(s).sage()
sage: s3 = integrate(s,s).variables()[0]
sage: [id(s),id(s1),id(s2),id(s3)]
[140326504362424, 96060840, 96060840, 96060696]
sage: (s^2 + 3*s + 1).taylor(s,0,2).coefficient(s3)
0
sage: (s1^2 + 3*s1 + 1).taylor(s1,0,2).coefficient(s3)
0
sage: (s3^2 + 3*s3 + 1).taylor(s3,0,2).coefficient(s1)
3
```


```
sage: s = SR('t')
sage: s1 = s._maxima_().sage()
sage: s2 = sage.calculus.calculus.maxima(s).sage()
sage: s3 = integrate(s,s).variables()[0]
sage: [id(s),id(s1),id(s2),id(s3)]
[95996024, 95996024, 95996024, 96062064]
sage: (s^2 + 3*s + 1).taylor(s,0,2).coefficient(s3)
3
sage: L=[integrate(s,s).variables()[0] for i in range(10)]
sage: [id(l) for  l in L]
[96062928, 96061704, 96062568, 96061200, 97231576, 97231504, 97231936, 97232008, 97232080, 97232152]
```

As you see, the variables produced by integrate, which go through the symbol-based interface with libmaxima (i.e., no direct string translations) don't maintain symbol identity at all. However, that doesn't always seem to affect how they behave (perhaps the python wrapper id doesn't reflect the identity of the wrapped pynac entity).

Perhaps `SR.symbol` produces an "uninterned" symbol? In that case, the most straightforward solution would be to let `SR.symbol()` produce interned symbols. That would leak memory, but converting symbols to maxima already does (because we have to interface with a non-refcounting system)


---

Comment by tkluck created at 2012-10-26 16:04:48

What do you mean by an "uninterned" symbol? Is that a Sage, a Pynac, or a Maxima concept?


---

Comment by nbruin created at 2012-10-26 16:54:39

You can google "string interning". It's a standard technique that is usually employed for symbol-type objects. For "interned" objects, equality implies identity. I suspect Pynac does something like that internally.

Some systems have both interned and uninterned strings/symbols. Using the latter in a context where the former is expected results exactly in the behaviour you observed. That's why I mentioned it, but a pynac expert (which I'm not) can probably quickly tell if this is the problem here.


---

Comment by burcin created at 2012-11-07 13:40:07

Replying to [comment:3 nbruin]:
> Some systems have both interned and uninterned strings/symbols. Using the latter in a context where the former is expected results exactly in the behaviour you observed. That's why I mentioned it, but a pynac expert (which I'm not) can probably quickly tell if this is the problem here.

`SR.symbol()` is intended to return uninterned symbols when called without an argument. In the source, you will see that there is a branch `if name is None:` where `pynac_symbol_registry[name] = e` is not called. My intention was to let the user create symbolic variables without the risk of picking the name of a variable used in the input. 

The conversion back from Maxima always creates an interned symbol if it cannot find one already existing in the registry. I admit that this use case never occured to me before. So we have a bug.

I don't want to lose the current `SR.symbol()` behavior (uninterned symbols). One possible solution here is to keep two symbol registries. Keeping the current one and introducing a new one which contains all symbols including the "uninterned" ones, to be used for Maxima conversions.


---

Comment by nbruin created at 2012-11-07 16:02:21

Replying to [comment:4 burcin]:
> `SR.symbol()` is intended to return uninterned symbols when called without an argument. In the source, you will see that there is a branch `if name is None:` where `pynac_symbol_registry[name] = e` is not called. My intention was to let the user create symbolic variables without the risk of picking the name of a variable used in the input. 

Maxima (or lisp for that matter) does have uninterned symbols as well. You won't recognize them from their string representation, though (unless you introduce a naming convention). However, if upon creation you store an attribute on them, you can still identify them as "uninterned" and create the corresponding uninterned symbol in Pynac as well. For the binary libmaxima interface this is pretty straightforward. For string-based (and there is really not much reason anymore to keep using that for calculus other than laziness for moving the remaining routines over) it's a little trickier.

*EDIT:* However, this is not going to help with translation between the two systems: If you want to log the mapping between uninterned symbols by identity then they're not really uninterned anymore (or at least, they'll leak memory just as normal symbols do).


---

Comment by rws created at 2015-01-13 16:16:41

Changing component from symbolics to interfaces.


---

Comment by rws created at 2015-01-13 16:16:41

Changing assignee from burcin to was.


---

Comment by rws created at 2015-01-13 16:55:48

Changing assignee from was to burcin.


---

Comment by rws created at 2015-01-13 16:55:48

Oops, how did I do that?


---

Comment by kcrisman created at 2016-01-22 16:00:38

See also [this sage-devel discussion](https://groups.google.com/forum/#!topic/sage-devel/ktAt5_9xhOk) which apparently is about the same issue.
