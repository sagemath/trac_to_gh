# Issue 23446: Speed up function field doctests

Issue created by migration from https://trac.sagemath.org/ticket/23683

Original creator: saraedum

Original creation time: 2017-08-23 13:18:22

CC:  chapoton roed xcaruso

Followup to #23193.

Function field doctests take 10 minutes on reasonable machines. That's way too much.


---

Comment by saraedum created at 2017-08-23 13:51:02

Changing status from new to needs_review.


---

Comment by saraedum created at 2017-08-23 13:51:02

New commits:


---

Comment by chapoton created at 2017-08-23 13:55:07

I think you should rather reduce the length of "some_elements" to at most 5 or 6. I have not chekced the current length, but it is probably much too long. IT was 3 before the ticket that caused the "long-time doctest" problem.


---

Comment by saraedum created at 2017-08-23 14:00:36

Why should some_elements be so short? This is precisely why we introduced max_runs in the first place. If I would write some_elements() manually, I would centainly come up with a list much longer than that. We actually find lots of bugs with having long some_elements lists in say p-adics code.


---

Comment by chapoton created at 2017-08-23 14:01:58

ok, I did not know about max_runs.


---

Comment by saraedum created at 2017-08-23 14:02:46

The length is typically about 50. The problem is that some doctests consider squares or triples of these. I think that max_runs is the way to go to make these doctests fast enough.


---

Comment by tscrim created at 2017-08-23 14:29:50

Replying to [comment:8 saraedum]:
> The length is typically about 50. The problem is that some doctests consider squares or triples of these. I think that max_runs is the way to go to make these doctests fast enough.

-1 because it doesn't get the same sort of coverage as to using 5-10 elements. E.g., it only does `x0 * (y * z) == (x0 * y) * z` for a fixed `x0`, which maybe too simple. So IMO, it is better to do a subset of `some_elements` (passed via `elements` to the `TestSuite`) to make sure you get more complicated elements tested, which is part of the reason you have these more complicated `some_elements()`, right?

Really, `some_elements()` is designed primarily for testing rather than to tell the user something. So having smaller number of `some_elements()`, but having those elements be "interesting" (in an appropriate definition), is what I think it should be.


---

Comment by saraedum created at 2017-08-23 14:43:10

I think this is a problem of `some_elements` or the doctests that use pairs and triples. Either `some_elements` should not just select the first few, or the doctests should generate the product in a more "interesting" fashion.


---

Comment by saraedum created at 2017-08-23 14:44:29

I am strongly opposed to shorten some_elements. As I said, having some_elements be long has proved very useful in the past. Of course, if the pairs tested are not "interesting" that is very bad.


---

Comment by saraedum created at 2017-08-23 14:47:20

This is now #23686.


---

Comment by tscrim created at 2017-08-23 15:05:43

Replying to [comment:10 saraedum]:
> I think this is a problem of `some_elements` or the doctests that use pairs and triples. Either `some_elements` should not just select the first few, or the doctests should generate the product in a more "interesting" fashion.

That would be an overengineered solution: you create a long list just to make a shorter list by sampling, which in turn, does not guarantee you get good elements. We could randomize this, but then you could have things that look like heisenbugs. So I do not think it makes any sense to have something like `_test_associative` to not go through all triples of the testing elements.


---

Comment by saraedum created at 2017-08-23 15:28:37

I can write down manually a lot of interesting elements in a p-adic ring that I would want tests to be run for. There are so many weird corner cases with precision in particular in extensions that you do not want to shorten these lists. Of course you can not test everything in all triples but that's ok. I still want almost everything be tested for the individual elements and pairs. (Actually p-adic some_elements is not so large yet because (as far as I recall) when we wrote it max_runs was not ready yet.)
What is wrong about not just taking the plain cartesian product but do some deterministic sampling? How we implement that is a different question. I believe there are a few viable options by either adapting the tests or have some_elements detect that it is being queried for a prouduct.


---

Comment by tscrim created at 2017-08-23 19:23:21

Replying to [comment:14 saraedum]:
> What is wrong about not just taking the plain cartesian product but do some deterministic sampling?

Because then you have fundamentally no control over the elements that are chosen and it can defeat the entire purpose of having a few interesting elements. Say you want 4 relatively trivial elements and 1 very complicated element in order to test interesting examples but it is too slow otherwise (perhaps in reality it would be 2x or 3x these particular numbers). It is very likely that you would sample only the trivial elements, but you would have no idea that those were the ones sampled, much less have any clear (or even feasible) way to change that. If you want to sample elements, then _you_ sample the elements and pass them to the `TestSuite`. However, you have to do that for every such test, so the best solution is to make `some_elements` smaller and instead pass `elements` with more complicated elements for those other more fundamental tests.


---

Comment by chapoton created at 2017-08-24 16:52:23

Whatever solution is chosen at the end, you should not remove the real time indications in the comments, but update them.


---

Comment by chapoton created at 2017-08-25 15:04:42

I would prefer to see this solved, even if in a bad way, than to stay unsolved any second longer.


---

Comment by saraedum created at 2017-08-25 16:52:20

Replying to [comment:15 tscrim]:
> Replying to [comment:14 saraedum]:
> > What is wrong about not just taking the plain cartesian product but do some deterministic sampling?
> 
> Because then you have fundamentally no control over the elements that are chosen and it can defeat the entire purpose of having a few interesting elements. Say you want 4 relatively trivial elements and 1 very complicated element in order to test interesting examples but it is too slow otherwise (perhaps in reality it would be 2x or 3x these particular numbers). It is very likely that you would sample only the trivial elements, but you would have no idea that those were the ones sampled, much less have any clear (or even feasible) way to change that. If you want to sample elements, then _you_ sample the elements and pass them to the `TestSuite`. However, you have to do that for every such test, so the best solution is to make `some_elements` smaller and instead pass `elements` with more complicated elements for those other more fundamental tests.

I don't understand. How can I pass in pairs and triples of elements to the TestSuite? I also don't understand the proposal apart from that technicality. If I follow what you propose, then I pass in a long list of elements to most test (the ones that are linear in the number of elements) and just use the default `some_elements` for the tests that use pairs and triples?


---

Comment by tscrim created at 2017-08-25 16:54:05

I've been talking with David at Days 88 about this, and I realized that I wasn't clear that I am not opposed to the current branch as a short-term solution. Julian, if you could update the timings, I will set a positive review.

Also, David and I discussed implementing a sampling feature to the `TestSuite` that would not be run by default, but by passing another argument to `TestSuite` that would only be used when the number of elements was bigger than `max_runs`.


---

Comment by git created at 2017-08-25 16:58:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by saraedum created at 2017-08-25 16:59:49

Replying to [comment:16 chapoton]:
> Whatever solution is chosen at the end, you should not remove the real time indications in the comments, but update them.
Ok. I put indications back in.


---

Comment by saraedum created at 2017-08-25 17:03:04

Replying to [comment:19 tscrim]:
> I've been talking with David at Days 88 about this, and I realized that I wasn't clear that I am not opposed to the current branch as a short-term solution. Julian, if you could update the timings, I will set a positive review.
Ok. Cool.

> Also, David and I discussed implementing a sampling feature to the `TestSuite` that would not be run by default, but by passing another argument to `TestSuite` that would only be used when the number of elements was bigger than `max_runs`.
Could you elaborate or maybe rather comment on the followup ticket?


---

Comment by tscrim created at 2017-08-25 18:29:02

Replying to [comment:22 saraedum]:
> Replying to [comment:19 tscrim]:
> > I've been talking with David at Days 88 about this, and I realized that I wasn't clear that I am not opposed to the current branch as a short-term solution. Julian, if you could update the timings, I will set a positive review.
> Ok. Cool.

Minor typo: `# long timeA (10s)`; you can set a positive review once fixed.

> > Also, David and I discussed implementing a sampling feature to the `TestSuite` that would not be run by default, but by passing another argument to `TestSuite` that would only be used when the number of elements was bigger than `max_runs`.
> Could you elaborate or maybe rather comment on the followup ticket?

I believe David (Roe) will post the followup ticket with perhaps more details and/or a first implementation. What we agreed upon was basically the following:

- if `some_elements()^N > max_runs` and something like `max_samples` or `sampling=True` was passed:
  * do sampling
- else:
  * use the direct iterator

As far as sampling goes, in order to do "good" sampling, we would need to decide upon a convention for where in `some_elements` the more "interesting" objects are at the end and we sample more heavily from there.

Something that I have used the `TestSuite` for is to increase the `max_runs` and fix failures as more interesting elements come up. So I needed that to behave in a more deterministic way as with sampling, it could be nice for `N` but fail for `N-1` because of the elements used. I also like it to work for infinite (enumerated) sets as well.


---

Comment by roed created at 2017-08-26 04:12:55

The followup is #23724.  I'm happy for feedback on the approach taken there.


---

Comment by chapoton created at 2017-08-26 11:49:59

Changing status from needs_review to positive_review.


---

Comment by chapoton created at 2017-08-26 11:49:59

after correcting the typo, I am setting to positive
----
New commits:


---

Comment by vbraun created at 2017-09-04 06:10:14

Resolution: fixed
