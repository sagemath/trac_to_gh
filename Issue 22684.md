# Issue 22684: Implementation of shifted tableaux

Issue created by migration from https://trac.sagemath.org/ticket/22921

Original creator: aschilling

Original creation time: 2017-05-01 19:38:43

CC:  tscrim kbparamonov hawkes aschilling mantepse andrew.mathas

Keywords: shifted tableaux, insertion algorithms

This ticket implements a new class for shifted tableaux and algorithm related to these.


---

Comment by tscrim created at 2017-05-01 20:26:57

See #20041.


---

Comment by kbparamonov created at 2017-05-04 18:55:50

Set assignee to kbparamonov.


---

Comment by git created at 2017-05-20 18:12:45

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-05-28 00:51:07

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-05-28 02:39:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-06-05 03:12:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by aschilling created at 2017-06-10 00:55:19

Looking at the code, I do not think it is necessary to implement a new class for StrictPartitions. You can access those using the already existing Partitions code:

```
sage: Partitions(7, max_slope=-1).list()
[[7], [6, 1], [5, 2], [4, 3], [4, 2, 1]]
```

Please also make sure that you stick to the Sage coding conventions described here
​http://doc.sagemath.org/html/en/developer/coding_basics.html


---

Comment by aschilling created at 2017-06-13 03:44:10

I still get many doctest failures (here are two, but there are many more):

```
sage -t tableau_shifted_primed.py
**********************************************************************
File "tableau_shifted_primed.py", line 43, in sage.combinat.tableau_shifted_primed.ShiftedPrimedTableau
Failed example:
    T([[1,"2'","3'",3],[2,"3'"]])[1]
Exception raised:
    Traceback (most recent call last):
      File "/Applications/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 509, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Applications/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 872, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.combinat.tableau_shifted_primed.ShiftedPrimedTableau[1]>", line 1, in <module>
        T([[Integer(1),"2'","3'",Integer(3)],[Integer(2),"3'"]])[Integer(1)]
      File "sage/structure/parent.pyx", line 941, in sage.structure.parent.Parent.__call__ (/Applications/sage/src/build/cythonized/sage/structure/parent.c:9839)
        return mor._call_(x)
      File "sage/structure/coerce_maps.pyx", line 110, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (/Applications/sage/src/build/cythonized/sage/structure/coerce_maps.c:4895)
        raise
      File "sage/structure/coerce_maps.pyx", line 105, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (/Applications/sage/src/build/cythonized/sage/structure/coerce_maps.c:4762)
        return C._element_constructor(x)
      File "/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/tableau_shifted_primed.py", line 904, in _element_constructor_
        raise ValueError("{} is not an element of {}".format(t, self))
    ValueError: [[1, "2'", "3'", 3], [2, "3'"]] is not an element of Shifted Primed tableaux of shape [4, 2]
**********************************************************************
File "tableau_shifted_primed.py", line 45, in sage.combinat.tableau_shifted_primed.ShiftedPrimedTableau
Failed example:
    t = ShiftedPrimedTableau([[1,"2p",2.5,3],[0,2,2.5]])
Exception raised:
    Traceback (most recent call last):
      File "/Applications/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 509, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Applications/sage/local/lib/python2.7/site-packages/sage/doctest/forker.py", line 872, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.combinat.tableau_shifted_primed.ShiftedPrimedTableau[2]>", line 1, in <module>
        t = ShiftedPrimedTableau([[Integer(1),"2p",RealNumber('2.5'),Integer(3)],[Integer(0),Integer(2),RealNumber('2.5')]])
      File "sage/misc/lazy_import.pyx", line 389, in sage.misc.lazy_import.LazyImport.__call__ (/Applications/sage/src/build/cythonized/sage/misc/lazy_import.c:4016)
        return self._get_object()(*args, **kwds)
      File "sage/misc/classcall_metaclass.pyx", line 330, in sage.misc.classcall_metaclass.ClasscallMetaclass.__call__ (/Applications/sage/src/build/cythonized/sage/misc/classcall_metaclass.c:1415)
        return cls.classcall(cls, *args, **kwds)
      File "/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/tableau_shifted_primed.py", line 86, in __classcall_private__
        return ShiftedPrimedTableaux(shape = shape, weight = weight)(T)
      File "sage/structure/parent.pyx", line 941, in sage.structure.parent.Parent.__call__ (/Applications/sage/src/build/cythonized/sage/structure/parent.c:9839)
        return mor._call_(x)
      File "sage/structure/coerce_maps.pyx", line 110, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (/Applications/sage/src/build/cythonized/sage/structure/coerce_maps.c:4895)
        raise
      File "sage/structure/coerce_maps.pyx", line 105, in sage.structure.coerce_maps.DefaultConvertMap_unique._call_ (/Applications/sage/src/build/cythonized/sage/structure/coerce_maps.c:4762)
        return C._element_constructor(x)
      File "/Applications/sage/local/lib/python2.7/site-packages/sage/combinat/tableau_shifted_primed.py", line 1004, in _element_constructor_
        raise ValueError("{} is not an element of {}".format(t, self))
    ValueError: [[1, '2p', 2.50000000000000, 3], [0, 2, 2.50000000000000]] is not an element of Shifted Primed Tableaux of weight (1, 4, 1) and shape [4, 2]
```



---

Comment by aschilling created at 2017-06-13 03:46:48

Here are some more trivial comments:

- you need a blank line before and after EXAMPLES::

- Returnes -> Return (several times)

- you need a blank line after the one-line description of a given method

- you need a 4-space indent of the code for each EXAMPLES::
  This indent is sometimes missing.

- EXAMPE: -> EXAMPLES::

- There is still some documentation missing for some of the methods


---

Comment by git created at 2017-06-20 00:11:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-06-24 06:21:08

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-06-24 07:05:38

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-06-25 13:39:54

In #23319 I have just implemented a growth diagram version of the insertion algorithm...


---

Comment by kbparamonov created at 2017-08-09 21:19:32

Changing status from new to needs_review.


---

Comment by git created at 2017-09-19 21:41:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-09-19 21:52:42

It would be nice to get this in, so we can have the following from #23896

```
sage: G = GrowthDiagramShiftedShapes([5, 10, 8, 7, 4, 1, 2, 9, 3, 6])
sage: G.P_symbol().pp()
 1   2   3   6   9
     4   5   7
         8   10

sage: G.Q_symbol().pp()
1   2   4'  5'  6'
    3   7'  8
        9   10
```



---

Comment by git created at 2017-09-19 22:17:16

Branch pushed to git repo; I updated commit sha1. Last 10 new commits:


---

Comment by mantepse created at 2017-09-19 22:31:08

Oh dear, help needed.  All the commits after 
> ​84093c4	fix minor formatting issues

should go away!


---

Comment by git created at 2017-09-20 05:36:22

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by git created at 2017-09-20 05:40:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-09-24 23:26:32

I just realised that we should have a skew version, too.


---

Comment by git created at 2017-10-02 19:45:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2017-10-02 19:57:59

Thanks for the minor fixes! Let me know if you have further feedback.
I'd rather do a semistandard version of Haiman insertion here, after the base class is implemented. 

Replying to [comment:20 mantepse]:
> It would be nice to get this in, so we can have the following from #23896
> {{{
> sage: G = GrowthDiagramShiftedShapes([5, 10, 8, 7, 4, 1, 2, 9, 3, 6])
> sage: G.P_symbol().pp()
>  1   2   3   6   9
>      4   5   7
>          8   10
> 
> sage: G.Q_symbol().pp()
> 1   2   4'  5'  6'
>     3   7'  8
>         9   10
> }}}


---

Comment by mantepse created at 2017-10-02 20:53:55

Replying to [comment:27 kbparamonov]:
> Thanks for the minor fixes! Let me know if you have further feedback.

Well, the most important thing for me would be support for the skew version, and support for `_ascii_art_`.  (In principle I think that there should be generic support for all sorts of fillings of shapes, but that's certainly not in the scope of this ticket.)

Important question: why do you use `ClonableArray` instead of `ClonableList`, as `Tableau` does?

> I'd rather do a semistandard version of Haiman insertion here, after the base class is implemented. 

As you like - maybe you could also do the skew version?  You can use the growth diagram version for cross-checking the standard case - the ticket is already closed, so it will be in 8.1.beta7.  The syntax has changed slightly, it is now

```
GrowthDiagram.rules.ShiftedShapes()([5,10,8,7,4,1,2,9,3,6])
```


I am too lazy to implement the semistandard version of the local rules, and I think they should be done generically anyway, via standardization and destandardization of the growth diagram.


---

Comment by kbparamonov created at 2017-10-02 21:05:54

Replying to [comment:29 mantepse]:

> Well, the most important thing for me would be support for the skew version, and support for `_ascii_art_`.  (In principle I think that there should be generic support for all sorts of fillings of shapes, but that's certainly not in the scope of this ticket.)
Got it

> Important question: why do you use `ClonableArray` instead of `ClonableList`, as `Tableau` does?
Good point, `ClonableList` is more consistent.


---

Comment by git created at 2017-10-03 01:33:27

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2017-10-03 15:55:06

`Tableau` probably should be using `ClonableArray` instead of `ClonableList` because it (should have) a fixed size. From the doc of `structure/list_clone.pyx`:

```
- :class:`ClonableArray` for arrays (lists of fixed length) of objects;
- :class:`ClonableList` for (resizable) lists of objects;
```



---

Comment by mantepse created at 2017-10-03 17:12:16

Replying to [comment:32 tscrim]:
> `Tableau` probably should be using `ClonableArray` instead of `ClonableList` because it (should have) a fixed size.

OK, I misunderstood: apparently, _size_ is the number of rows.  So, a tableau really should be a `ClonableArray` of lists, right?  Or should it be a `ClonableArray` of `ClonableArray`s?


---

Comment by tscrim created at 2017-10-03 17:51:49

`ClonableArray` of tuples is best so the rows cannot be modified via `T[0]` (a la #15862).


---

Comment by git created at 2017-10-04 01:16:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-10-04 05:29:12

Great!  One further comment (apart from the skew thing): it might be nice to have, similar to what's provided by `SkewTableau`, an argument `chain` that takes a sequence of shapes and creates a shifted (skew) tableau.  This is already implemented in #23896 (methods `P_symbol` and `Q_symbol`) for the standard case, but should be straightforward also for the (skew) semistandard case.  You can simply take the code from there, I would then replace those with a call to `ShiftedPrimedTableau(chain=Q_chain)`.

I admit that I'm not completely sure about how to do it right: in the shifted case, a chain is a sequence of strict partitions, alternating with a colour:

* colour 1 (black) - add a box on the diagonal
* colour 2 (blue) - add an ordinary box
* colour 3 (red) - add a primed box

Of course, black is redundant, so maybe you just want to have two colours...


---

Comment by aschilling created at 2017-10-06 16:55:02

Hi Kirill,

Not all methods seems to have documentation, see

```
sage -coverage tableau_shifted_primed.py 
------------------------------------------------------------------------
SCORE tableau_shifted_primed.py: 86.8% (46 of 53)

Missing documentation:
     * line 1630: def __classcall_private__(cls, *args, **kwargs)
     * line 1660: def __init__(self, shape=[4, 2], n=2)
     * line 1669: def _repr_(self)
     * line 1678: def add_strip(sub_tab, full_tab, length)
     * line 1736: def preprocessing(T)

Missing doctests:
     * line 1243: def __init__(self, shape, max_elt)
     * line 1510: def __init__(self, weight, shape)
------------------------------------------------------------------------
```



---

Comment by aschilling created at 2017-10-06 17:02:55

How do you actually make the crystal of shifted primed tableaux? There is no documentation given for this. Also, you want to include the crystal in the catalogue of crystals, so that it will be accessible as `crystals.shifted_primed_tableaux(shape)`. Currently, this does not seem to be implemented.


---

Comment by mantepse created at 2017-10-06 18:25:09

Changing status from needs_review to needs_work.


---

Comment by git created at 2017-10-06 21:50:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-10-06 21:57:52

Is there a good reason to have `shape=(4,2)` and `n=2` as defaults?


---

Comment by aschilling created at 2017-10-06 22:04:41

Replying to [comment:41 mantepse]:
> Is there a good reason to have `shape=(4,2)` and `n=2` as defaults? 

No, those should be removed! Examples should be given with these values, but there should not be defaults!


---

Comment by git created at 2017-10-06 22:18:13

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2017-10-07 07:18:18

* There are leftover default values in line 1740.

* I think `list_highest_weight` is redundant.  What I'm not sure about: shouldn't some of the methods, in particular `list_decreasing_weight`, be methods of the crystal class?

```
sage: %timeit crystals.ShiftedPrimedTableaux(shape=[4,3,2,1]).highest_weight_vectors()
1 loop, best of 3: 24.9 s per loop
sage: %timeit ShiftedPrimedTableaux(shape=[4,3,2,1]).list_highest_weight()
1 loop, best of 3: 24.3 s per loop
```


* The documentation in line 1648 is not clear to me, isn't it just constructed applying the lowering operators (you could link to those using `:meth:...`) to the highest weights?

* I think that `to_matrix` should be a private method - suppose that the internal representation changes, then it possibly doesn't make much sense anymore.

* I'm a bit unsure about `reading_word_with_positions`, possibly that should be private, too.

* any chance for the skew version?


---

Comment by kbparamonov created at 2017-10-07 18:27:27

Replying to [comment:44 mantepse]:
> * There are leftover default values in line 1740.
Those are for factory class `ShiftedPrimedTableauxCrystal`, which is not supposed to be called directly, so default values are only for internal use. I'll change it to raise error if arguments are not passed.

> * I think `list_highest_weight` is redundant.  What I'm not sure about: shouldn't some of the methods, in particular `list_decreasing_weight`, be methods of the crystal class?
> {{{
> sage: %timeit crystals.ShiftedPrimedTableaux(shape=[4,3,2,1]).highest_weight_vectors()
> 1 loop, best of 3: 24.9 s per loop
> sage: %timeit ShiftedPrimedTableaux(shape=[4,3,2,1]).list_highest_weight()
> 1 loop, best of 3: 24.3 s per loop
> }}}
`list_highest_weight` is interesting in terms of the paper we've been working on, the length of that list would be related to a certain Schur decomposition.

> * The documentation in line 1648 is not clear to me, isn't it just constructed applying the lowering operators (you could link to those using `:meth:...`) to the highest weights?
I'll include better explanation.

> * I think that `to_matrix` should be a private method - suppose that the internal representation changes, then it possibly doesn't make much sense anymore.
Agree.

> * I'm a bit unsure about `reading_word_with_positions`, possibly that should be private, too.
Agree.

> * any chance for the skew version?
I'll be modifying the functions for the skew version. Expect it next week.


---

Comment by mantepse created at 2017-10-07 18:51:51

Please clarify: isn't `list_highest_weight` the same as `crystals.ShiftedPrimedTableaux(shape=[4,3,2,1]).highest_weight_vectors()`?


---

Comment by aschilling created at 2017-10-07 19:02:20

Replying to [comment:44 mantepse]:

> * any chance for the skew version?

The skew version should be in a new ticket. Let us first get the crystal into Sage. Then you can add code to deal with the skew cases.


---

Comment by mantepse created at 2017-10-07 19:11:14

OK, sounds reasonable!


---

Comment by git created at 2017-10-07 21:03:28

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by aschilling created at 2017-10-07 22:05:12

Hi Kirill,

You changed the name of the crystal class as we discussed, but you did not change the tests. Now there are a lot of failing tests!


---

Comment by aschilling created at 2017-10-07 22:06:33

There are still missing doctests:

```
Missing doctests:
     * line 1172: def __init__(self, shape, max_elt)
     * line 1439: def __init__(self, weight, shape)
     * line 1710: def add_strip(sub_tab, full_tab, length)
```



---

Comment by git created at 2017-10-09 17:36:37

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-10-09 18:00:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by aschilling created at 2017-10-16 03:05:43

Hi Kirill,

I still get a lot of doctest failures when running the tests on 'tableau_shifted_primed.py'

```
sage -t tableau_shifted_primed.py  # 171 doctests failed
```

Can you please fix them?

Thanks,

Anne


---

Comment by kbparamonov created at 2017-10-16 03:21:07

Hi Anne,

I don't know why that happened, it passed all the tests for me.

Replying to [comment:54 aschilling]:
> Hi Kirill,
> 
> I still get a lot of doctest failures when running the tests on 'tableau_shifted_primed.py'
> {{{
> sage -t tableau_shifted_primed.py  # 171 doctests failed
> }}}
> Can you please fix them?
> 
> Thanks,
> 
> Anne


---

Comment by aschilling created at 2017-10-16 04:54:39

I get the following 

```
sage: B = crystals.ShiftedPrimedTableaux([3,2],2)
sage: TestSuite(B).run(verbose=True)
running ._test_an_element() . . . pass
running ._test_cardinality() . . . pass
running ._test_category() . . . pass
running ._test_elements() . . .
  Running the test suite of self.an_element()
  running ._test_category() . . . pass
  running ._test_eq() . . . pass
  running ._test_new() . . . pass
  running ._test_not_implemented_methods() . . . pass
  running ._test_pickling() . . . pass
  pass
running ._test_elements_eq_reflexive() . . . pass
running ._test_elements_eq_symmetric() . . . pass
running ._test_elements_eq_transitive() . . . pass
running ._test_elements_neq() . . . pass
running ._test_enumerated_set_contains() . . . pass
running ._test_enumerated_set_iter_cardinality() . . . pass
running ._test_enumerated_set_iter_list() . . . pass
running ._test_eq() . . . pass
running ._test_fast_iter() . . . pass
running ._test_new() . . . pass
running ._test_not_implemented_methods() . . . pass
running ._test_pickling() . . . pass
running ._test_some_elements() . . . pass
running ._test_stembridge_local_axioms() . . . fail
Traceback (most recent call last):
  File "/Applications/sage/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py", line 294, in run
    test_method(tester = tester)
  File "/Applications/sage/local/lib/python2.7/site-packages/sage/categories/regular_crystals.py", line 313, in _test_stembridge_local_axioms
    goodness = x._test_stembridge_local_axioms(index_set, verbose)
  File "sage/structure/element.pyx", line 484, in sage.structure.element.Element.__getattr__ (build/cythonized/sage/structure/element.c:4368)
    return self.getattr_from_category(name)
  File "sage/structure/element.pyx", line 497, in sage.structure.element.Element.getattr_from_category (build/cythonized/sage/structure/element.c:4477)
    return getattr_from_other_class(self, cls, name)
  File "sage/cpython/getattr.pyx", line 249, in sage.cpython.getattr.getattr_from_other_class (build/cythonized/sage/cpython/getattr.c:1830)
    raise dummy_attribute_error
AttributeError: 'ShiftedPrimedTableaux_all_with_category.element_class' object has no attribute '_test_stembridge_local_axioms'
------------------------------------------------------------
The following tests failed: _test_stembridge_local_axioms
```



---

Comment by kbparamonov created at 2017-10-16 16:53:04

It looks like the tableau class doesn't inherit method `_test_stembridge_local_axioms`.
Do you know why this happens?

Replying to [comment:56 aschilling]:
> I get the following 
> {{{
> sage: B = crystals.ShiftedPrimedTableaux([3,2],2)
> sage: TestSuite(B).run(verbose=True)
> running ._test_an_element() . . . pass
> running ._test_cardinality() . . . pass
> running ._test_category() . . . pass
> running ._test_elements() . . .
>   Running the test suite of self.an_element()
>   running ._test_category() . . . pass
>   running ._test_eq() . . . pass
>   running ._test_new() . . . pass
>   running ._test_not_implemented_methods() . . . pass
>   running ._test_pickling() . . . pass
>   pass
> running ._test_elements_eq_reflexive() . . . pass
> running ._test_elements_eq_symmetric() . . . pass
> running ._test_elements_eq_transitive() . . . pass
> running ._test_elements_neq() . . . pass
> running ._test_enumerated_set_contains() . . . pass
> running ._test_enumerated_set_iter_cardinality() . . . pass
> running ._test_enumerated_set_iter_list() . . . pass
> running ._test_eq() . . . pass
> running ._test_fast_iter() . . . pass
> running ._test_new() . . . pass
> running ._test_not_implemented_methods() . . . pass
> running ._test_pickling() . . . pass
> running ._test_some_elements() . . . pass
> running ._test_stembridge_local_axioms() . . . fail
> Traceback (most recent call last):
>   File "/Applications/sage/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py", line 294, in run
>     test_method(tester = tester)
>   File "/Applications/sage/local/lib/python2.7/site-packages/sage/categories/regular_crystals.py", line 313, in _test_stembridge_local_axioms
>     goodness = x._test_stembridge_local_axioms(index_set, verbose)
>   File "sage/structure/element.pyx", line 484, in sage.structure.element.Element.__getattr__ (build/cythonized/sage/structure/element.c:4368)
>     return self.getattr_from_category(name)
>   File "sage/structure/element.pyx", line 497, in sage.structure.element.Element.getattr_from_category (build/cythonized/sage/structure/element.c:4477)
>     return getattr_from_other_class(self, cls, name)
>   File "sage/cpython/getattr.pyx", line 249, in sage.cpython.getattr.getattr_from_other_class (build/cythonized/sage/cpython/getattr.c:1830)
>     raise dummy_attribute_error
> AttributeError: 'ShiftedPrimedTableaux_all_with_category.element_class' object has no attribute '_test_stembridge_local_axioms'
> ------------------------------------------------------------
> The following tests failed: _test_stembridge_local_axioms
> }}}


---

Comment by tscrim created at 2017-10-18 04:53:50

Replying to [comment:57 kbparamonov]:
> It looks like the tableau class doesn't inherit method `_test_stembridge_local_axioms`.
> Do you know why this happens?

Here is the problem:

```
sage: SPTC = crystals.ShiftedPrimedTableaux([4,2], 2)
sage: SPTC.an_element()
[(1.0, 1.0, 1.0, 1.0), (2.0, 2.0)]
sage: type(_)
<class 'sage.combinat.tableau_shifted_primed.ShiftedPrimedTableaux_all_with_category.element_class'>
sage: type(SPTC)
<class 'sage.combinat.tableau_shifted_primed.SPTCrystal_with_category'>
sage: SPTC.element_class
<class 'sage.combinat.tableau_shifted_primed.SPTCrystal_with_category.element_class'>
```

The elements of `SPTC` are not subclasses of `SPTC.element_class`. Hence, they belong to the wrong category.

```
sage: SPTC.an_element().category()
Category of elements of Shifted Primed Tableaux
```


I also do not see why you have `ShiftedPrimedTableauxCrystal` and the subclass `SPTCrystal`. It seems like the SPT crystals really should be the same as the SPT with a fixed shape and max element, but I've only quickly looked at it.

I am pushing a few simple tweaks. We can work on this more tomorrow.


---

Comment by git created at 2017-10-18 04:54:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-10-18 18:40:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2017-10-18 21:27:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by andrew.mathas created at 2017-10-22 19:05:01

Can you please add a reference to the literature to the documentation for shifted primed tableaux? I'm actually really curious to see a reference, independent of the code, because in my work "shifted shaded tableaux" come up and I wonder if they are the same objects. From a cursory look at the documentation they seem quite close.


---

Comment by tscrim created at 2017-10-23 03:52:07

Graham, Kirill, or Anne can probably answer better than I can, but a good starting point would be their paper:

```
.. [HPS2017] Graham Hawkes, Kirill Paramonov, and Anne Schilling.
             *Crystal analysis of type* `C` *Stanley symmetric functions*.
             Preprint, :arxiv:`1704.00889`.
```



---

Comment by kbparamonov created at 2017-10-23 06:32:24

I believe those tableaux were first introduced by Haiman here: http://www.sciencedirect.com/science/article/pii/0097316589900150
and recently were developed by Serrano here: https://arxiv.org/abs/0811.2057

Replying to [comment:62 andrew.mathas]:
> Can you please add a reference to the literature to the documentation for shifted primed tableaux? I'm actually really curious to see a reference, independent of the code, because in my work "shifted shaded tableaux" come up and I wonder if they are the same objects. From a cursory look at the documentation they seem quite close.


---

Comment by aschilling created at 2017-10-23 16:32:36

Replying to [comment:66 kbparamonov]:
> I believe those tableaux were first introduced by Haiman here: http://www.sciencedirect.com/science/article/pii/0097316589900150
> and recently were developed by Serrano here: https://arxiv.org/abs/0811.2057

Kirill, could you please add those references to the code? Also, did you fix the Stembridge axiom issues?


---

Comment by kbparamonov created at 2017-10-23 16:40:56

Sounds good. Travis fixed the Stembridge axioms issues last week.

Replying to [comment:67 aschilling]:
> Replying to [comment:66 kbparamonov]:
> > I believe those tableaux were first introduced by Haiman here: http://www.sciencedirect.com/science/article/pii/0097316589900150
> > and recently were developed by Serrano here: https://arxiv.org/abs/0811.2057
> 
> Kirill, could you please add those references to the code? Also, did you fix the Stembridge axiom issues?


---

Comment by git created at 2017-12-28 01:43:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by aschilling created at 2017-12-28 01:48:38

Hi Kirill,

Ok, let us try to get this ticket into Sage! I have tested the code extensively and the crystals seem to be correct. I rebased the code on the latest development version and also fixed some small typos. 

There are still some small issues with the coverage:

```
sage -coverage tableau_shifted_primed.py 
------------------------------------------------------------------------
SCORE tableau_shifted_primed.py: 95.9% (47 of 49)

Missing documentation:
     * line 1305: def __classcall_private__(cls, shape, max_elt=None, skew=None)

Missing doctests:
     * line 1416: def module_generators(self)

Possibly wrong (function name doesn't occur in doctests):
     * line 1755: def add_strip(sub_tab, full_tab, length)
------------------------------------------------------------------------
```

Could you please fix those?

Also, the ticket description mentions that this code is based on #20041. Can this be removed now? It also mentions various insertion algorithms, but I think they are not implemented in this ticket. Could you please update the description?

Thank you!

Anne


---

Comment by mantepse created at 2017-12-28 08:27:08

That would be great!

THe insertion algorithms are available via #23896, which could be reviewed as soon as this is done! (Hint :-)


---

Comment by git created at 2017-12-29 18:16:59

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2017-12-29 18:20:18

Changing keywords from "shifted tableaux, insertion algorithms" to "shifted primed tableaux, crystals".


---

Comment by kbparamonov created at 2017-12-29 18:20:18

Changing status from needs_work to needs_review.


---

Comment by kbparamonov created at 2017-12-29 18:25:38

Hi Anne,

I've removed the use of numpy in the code, could you check if everything still works?
Other issues have been fixed.

Replying to [comment:70 aschilling]:
> Hi Kirill,
> 
> Ok, let us try to get this ticket into Sage! I have tested the code extensively and the crystals seem to be correct. I rebased the code on the latest development version and also fixed some small typos. 
> 
> There are still some small issues with the coverage:
> {{{
> sage -coverage tableau_shifted_primed.py 
> ------------------------------------------------------------------------
> SCORE tableau_shifted_primed.py: 95.9% (47 of 49)
> 
> Missing documentation:
>      * line 1305: def __classcall_private__(cls, shape, max_elt=None, skew=None)
> 
> Missing doctests:
>      * line 1416: def module_generators(self)
> 
> Possibly wrong (function name doesn't occur in doctests):
>      * line 1755: def add_strip(sub_tab, full_tab, length)
> ------------------------------------------------------------------------
> }}}
> Could you please fix those?
> 
> Also, the ticket description mentions that this code is based on #20041. Can this be removed now? It also mentions various insertion algorithms, but I think they are not implemented in this ticket. Could you please update the description?
> 
> Thank you!
> 
> Anne


---

Comment by aschilling created at 2017-12-30 06:09:54

Hi Kirill,

Thanks for the fixes. There seems to be some problem with the documentation:

```
[dochtml] [combinat ] /Applications/sage/local/lib/python2.7/site-packages/sage/combinat/tableau_shifted_primed.py:docstring of sage.combinat.tableau_shifted_primed.ShiftedPrimedTableaux_shape:9: WARNING: citation not found: HPS17
```


Anne


---

Comment by git created at 2018-01-01 09:37:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-01 09:37:56

Alright, should be fixed.

Replying to [comment:76 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[b1d7d2e](https://git.sagemath.org/sage.git/commit/?id=b1d7d2e55e04a298a3a611c041dfa6bfa74adf2c)||`Fixed reference to the paper`||


---

Comment by mantepse created at 2018-01-01 16:27:17

I think that `shape` should return a skew partition, when necessary, and a partition otherwise.  Currently it returns lists.  For example:

```
        if self._skew is None:
            return Partition([len(_) for _ in self])
        return SkewPartition(([len(self[i])+self._skew[i]
                               for i in range(len(self._skew))] +
                              [len(self[i])
                               for i in range(len(self._skew), len(self))],
                              self._skew))

```

(doctests would have to be adapted)


---

Comment by mantepse created at 2018-01-01 18:24:19

I am not sure whether implementing `__call__` for shifted tableaux is a good idea.  In any case, it is not quite clear to me what it does:


```
sage: s = ShiftedPrimedTableau([["2p",3,4],[2]],skew=[2,1])
sage: s.pp()
 .  .  2' 3  4 
    .  2 
sage: s(0,0)
3.0
sage: s(0,1)
4.0
sage: s(0,2)
1.5
sage: s(0,3)
3.0
sage: s(0,4)
4.0
sage: s(0,5)
IndexError: invalid cell
sage: s(1,0)
2.0
sage: s(1,1)
2.0
sage: s(1,2)
IndexError: invalid cell
sage: s(2,0)
IndexError: invalid cell
```



---

Comment by aschilling created at 2018-01-01 23:10:07

Replying to [comment:78 mantepse]:
> I think that `shape` should return a skew partition, when necessary, and a partition otherwise.  Currently it returns lists.  For example:
> {{{
>         if self._skew is None:
>             return Partition([len(_) for _ in self])
>         return SkewPartition(([len(self[i])+self._skew[i]
>                                for i in range(len(self._skew))] +
>                               [len(self[i])
>                                for i in range(len(self._skew), len(self))],
>                               self._skew))
> 
> }}}
> (doctests would have to be adapted)

Hi Kirill,

Thank you for your changes. I agree with Martin that the shape should be in `Partitions` or `SkewPartitions`. In fact, the same is true for the weight of a crystal element (cf. with the weight of a tableaux crystal element):

```
sage: B = crystals.ShiftedPrimedTableaux([4,3,1], 5)
sage: b = B.an_element()
sage: type(b.weight())
<type 'tuple'>
sage: B = crystals.Tableaux(['A',2],shape=[2,1])
sage: b = B.an_element()
sage: type(b.weight())
<class 'sage.combinat.root_system.type_A.AmbientSpace_with_category.element_class'>
```


Anne


---

Comment by git created at 2018-01-02 01:29:06

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by aschilling created at 2018-01-02 01:30:09

Hi Kirill,

I merged in the latest development branch and also fixed some documentation. Please use this version when you fix the shape and weight to be of the correct type.

Thank you,

Anne


---

Comment by git created at 2018-01-02 07:41:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-02 07:44:12

Good point, thank you!

Replying to [comment:78 mantepse]:
> I think that `shape` should return a skew partition, when necessary, and a partition otherwise.  Currently it returns lists.  For example:
> {{{
>         if self._skew is None:
>             return Partition([len(_) for _ in self])
>         return SkewPartition(([len(self[i])+self._skew[i]
>                                for i in range(len(self._skew))] +
>                               [len(self[i])
>                                for i in range(len(self._skew), len(self))],
>                               self._skew))
> 
> }}}
> (doctests would have to be adapted)


---

Comment by kbparamonov created at 2018-01-02 07:55:42

That makes sense.
How do I change type of the weight of crystal elements?

Replying to [comment:80 aschilling]:
> Replying to [comment:78 mantepse]:
> > I think that `shape` should return a skew partition, when necessary, and a partition otherwise.  Currently it returns lists.  For example:
> > {{{
> >         if self._skew is None:
> >             return Partition([len(_) for _ in self])
> >         return SkewPartition(([len(self[i])+self._skew[i]
> >                                for i in range(len(self._skew))] +
> >                               [len(self[i])
> >                                for i in range(len(self._skew), len(self))],
> >                               self._skew))
> > 
> > }}}
> > (doctests would have to be adapted)
> 
> Hi Kirill,
> 
> Thank you for your changes. I agree with Martin that the shape should be in `Partitions` or `SkewPartitions`. In fact, the same is true for the weight of a crystal element (cf. with the weight of a tableaux crystal element):
> {{{
> sage: B = crystals.ShiftedPrimedTableaux([4,3,1], 5)
> sage: b = B.an_element()
> sage: type(b.weight())
> <type 'tuple'>
> sage: B = crystals.Tableaux(['A',2],shape=[2,1])
> sage: b = B.an_element()
> sage: type(b.weight())
> <class 'sage.combinat.root_system.type_A.AmbientSpace_with_category.element_class'>
> }}}
> 
> Anne


---

Comment by aschilling created at 2018-01-02 22:24:38

Replying to [comment:85 kbparamonov]:
> That makes sense.
> How do I change type of the weight of crystal elements?

You can do

```
sage: B = crystals.ShiftedPrimedTableaux([4,3,1], 5)
sage: b = B.an_element()
sage: b
[(1.0, 1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0,)]
sage: B.weight_lattice_realization()(b.weight())
(4, 3, 1, 0, 0)
```



---

Comment by kbparamonov created at 2018-01-04 22:15:41

I'm still not sure how to implement this.

Replying to [comment:86 aschilling]:
> Replying to [comment:85 kbparamonov]:
> > That makes sense.
> > How do I change type of the weight of crystal elements?
> 
> You can do
> {{{
> sage: B = crystals.ShiftedPrimedTableaux([4,3,1], 5)
> sage: b = B.an_element()
> sage: b
> [(1.0, 1.0, 1.0, 1.0), (2.0, 2.0, 2.0), (3.0,)]
> sage: B.weight_lattice_realization()(b.weight())
> (4, 3, 1, 0, 0)
> }}}


---

Comment by mantepse created at 2018-01-05 05:09:57


```
        weight = tuple([flat.count(i+1) for i in range(max_ind)])
        if self._skew is None:
            P = ShiftedPrimedTableaux(self.shape(), max_element=max_ind)
            return P.weight_lattice_realization()(weight)
        return weight
```


(needs more doctesting)


---

Comment by git created at 2018-01-05 22:48:41

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-05 22:49:11

Thanks for help!

Replying to [comment:88 mantepse]:
> {{{
>         weight = tuple([flat.count(i+1) for i in range(max_ind)])
>         if self._skew is None:
>             P = ShiftedPrimedTableaux(self.shape(), max_element=max_ind)
>             return P.weight_lattice_realization()(weight)
>         return weight
> }}}
> 
> (needs more doctesting)


---

Comment by mantepse created at 2018-01-05 23:26:34

Are you sure that you want to test only the following?

```
if isinstance(self.parent(), ShiftedPrimedTableaux_shape):
```

I don't know - should `weight` only return an element of the `AmbientSpace` when the tableau is initialised with a specific shape?


---

Comment by mantepse created at 2018-01-05 23:31:42

Finally, I am not yet convinced that `list_highest_weight` and possibly also `list_decreasing_weight` should be there, see comment:44 above.


---

Comment by kbparamonov created at 2018-01-05 23:38:15

I need

```
    return self.parent().weight_lattice_realization()(weight)
```

for the fixed-shape tableaux to get the crystal right, which doesn't work for other parents.
I didn't add that for other parents because we need to change the weight type only for crystal elements.
It's not hard to fix this though.

Replying to [comment:91 mantepse]:
> Are you sure that you want to test only the following?
> {{{
> if isinstance(self.parent(), ShiftedPrimedTableaux_shape):
> }}}
> I don't know - should `weight` only return an element of the `AmbientSpace` when the tableau is initialised with a specific shape?
>


---

Comment by git created at 2018-01-05 23:49:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-05 23:50:59

I think `list_decreasing_weight` is useful to get module generators for the crystal.

Replying to [comment:92 mantepse]:
> Finally, I am not yet convinced that `list_highest_weight` and possibly also `list_decreasing_weight` should be there, see comment:44 above.  
>


---

Comment by tscrim created at 2018-01-06 00:10:40

Replying to [comment:95 kbparamonov]:
> I think `list_decreasing_weight` is useful to get module generators for the crystal.
> 
> Replying to [comment:92 mantepse]:
> > Finally, I am not yet convinced that `list_highest_weight` and possibly also `list_decreasing_weight` should be there, see comment:44 above.  
> > 

You could just move that code into `module_generators` as `list_decreasing_weight` is not used elsewhere.


---

Comment by git created at 2018-01-06 01:10:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2018-01-06 08:55:37

I'm afraid I have some more requests, please excuse me.

* for all other varieties of tableaux (eg. `CompositionTableaux`, `SemiStandardTableaux`) the maximal entry is 

```
    - ``size`` -- the size of the composition tableaux
    - ``shape`` -- the shape of the composition tableaux
    - ``max_entry`` -- the maximum entry for the composition tableaux
```

    so I propose to rename both the parameter and the method from `max_element` to `max_entry`. Also, the alias `max_elt` should be removed.

* the alias `_is_a` should be removed

* this is more a question: should the method `is_highest_weight` really be included?  It would be the only instance of a separately defined `is_highest_weight`, all other crystals use the definition in `categories/crystals.py`.

* currently, modules concerning tableaux follow the naming scheme `adjective_tableau.py`:

```
composition_tableau.py
k_tableau.py
lr_tableau.py
ribbon_shaped_tableau.py
ribbon_tableau.py
skew_tableau.py
```

    so I propose to rename the module to `shifted_primed_tableau.py`.

* The docstring of `weight` should be

```
        Return the weight of ``self``.
```


* The docstring of `pp` should be

```
        Pretty print ``self``.
```


* the doctest of `add_strip` (should this have a leading underscore?) should have an `# indirect doctest` flag:

```

    TESTS::

        sage: list(ShiftedPrimedTableaux([3,1],(2,2)))                # indirect doctest
        [[(1.0, 1.0, 2.0), (2.0,)], [(1.0, 1.0, 1.5), (2.0,)]]

```


After this, and if Anne and Travis agree, I'd say the ticked is done!  Many many thanks!  I will then update #23896 so we have the insertion algorithms, too.


---

Comment by aschilling created at 2018-01-06 16:55:53

I agree with Martin's comments! `is_highest_weight` should only be implemented if the explicit implementation is faster than the default one.


---

Comment by git created at 2018-01-06 18:01:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-06 18:10:19

Thank you for your suggestions! 
I agree with everything, except for `is_highest_weight` comment: my implementation checks whether the reading word is Yamanouchi, which is a bit fast than checking each operator `e(i)` directly.

Replying to [comment:98 mantepse]:
> I'm afraid I have some more requests, please excuse me.
> 
> * for all other varieties of tableaux (eg. `CompositionTableaux`, `SemiStandardTableaux`) the maximal entry is 
> {{{
>     - ``size`` -- the size of the composition tableaux
>     - ``shape`` -- the shape of the composition tableaux
>     - ``max_entry`` -- the maximum entry for the composition tableaux
> }}}
>     so I propose to rename both the parameter and the method from `max_element` to `max_entry`. Also, the alias `max_elt` should be removed.
> 
> * the alias `_is_a` should be removed
> 
> * this is more a question: should the method `is_highest_weight` really be included?  It would be the only instance of a separately defined `is_highest_weight`, all other crystals use the definition in `categories/crystals.py`.
> 
> * currently, modules concerning tableaux follow the naming scheme `adjective_tableau.py`:
> {{{
> composition_tableau.py
> k_tableau.py
> lr_tableau.py
> ribbon_shaped_tableau.py
> ribbon_tableau.py
> skew_tableau.py
> }}}
>     so I propose to rename the module to `shifted_primed_tableau.py`.
> 
> * The docstring of `weight` should be
> {{{
>         Return the weight of ``self``.
> }}}
> 
> * The docstring of `pp` should be
> {{{
>         Pretty print ``self``.
> }}}
> 
> * the doctest of `add_strip` (should this have a leading underscore?) should have an `# indirect doctest` flag:
> {{{
> 
>     TESTS::
> 
>         sage: list(ShiftedPrimedTableaux([3,1],(2,2)))                # indirect doctest
>         [[(1.0, 1.0, 2.0), (2.0,)], [(1.0, 1.0, 1.5), (2.0,)]]
> 
> }}}
> 
> After this, and if Anne and Travis agree, I'd say the ticked is done!  Many many thanks!  I will then update #23896 so we have the insertion algorithms, too.


---

Comment by tscrim created at 2018-01-06 18:27:42

Replying to [comment:102 kbparamonov]:
> Thank you for your suggestions! 
> I agree with everything, except for `is_highest_weight` comment: my implementation checks whether the reading word is Yamanouchi, which is a bit fast than checking each operator `e(i)` directly.

Please post your timings. Also, to be consistent with the crystal implementation of `is_highest_weight`, it must support an optional `index_set` argument.


---

Comment by mantepse created at 2018-01-06 19:01:41

I actually do get better performance.  Kirill's version:

```
sage: %timeit [a for a in ShiftedPrimedTableaux(shape=[5,3,2], max_entry=4) if a.is_highest_weight()]
1 loop, best of 3: 5.12 s per loop
sage: L = [a for a in ShiftedPrimedTableaux(shape=[5,3,2], max_entry=4)]
sage: len(L)
960
sage: %timeit [a for a in L if a.is_highest_weight()]
10 loops, best of 3: 187 ms per loop
```

Generic version:

```
sage: %timeit [a for a in ShiftedPrimedTableaux(shape=[5,3,2], max_entry=4) if a.is_highest_weight()]
1 loop, best of 3: 5.66 s per loop
sage: L = [a for a in ShiftedPrimedTableaux(shape=[5,3,2], max_entry=4)]
sage: len(L)
960
sage: %timeit [a for a in L if a.is_highest_weight()]
1 loop, best of 3: 825 ms per loop
```



---

Comment by aschilling created at 2018-01-06 22:21:42

Kirill, I think you forgot to rename the file in the documentation links:

```
[dochtml] OSError: [combinat ] WARNING: /Applications/sage/src/doc/en/reference/combinat/sage/combinat/tableau_shifted_primed.rst:11: (WARNING/2) autodoc: failed to import module u'sage.combinat.tableau_shifted_primed'; the following exception was raised:
```



---

Comment by kbparamonov created at 2018-01-06 22:33:52

What file is responsible for generating the documentation? 

Replying to [comment:105 aschilling]:
> Kirill, I think you forgot to rename the file in the documentation links:
> {{{
> [dochtml] OSError: [combinat ] WARNING: /Applications/sage/src/doc/en/reference/combinat/sage/combinat/tableau_shifted_primed.rst:11: (WARNING/2) autodoc: failed to import module u'sage.combinat.tableau_shifted_primed'; the following exception was raised:
> }}}


---

Comment by tscrim created at 2018-01-06 23:06:40

Replying to [comment:106 kbparamonov]:
> What file is responsible for generating the documentation? 

`src/doc/en/reference/combinat/module_list.rst`

Addendum: you also need to change `src/sage/combinat/catalog_partitions.py`.


---

Comment by tscrim created at 2018-01-07 00:30:20

I know its somewhat far into this, but I don't like using floating points for the half integers. They are inexact and have a bad representation (e.g., when you raise an error on an invalid object). I think you should have a class that represents the letters in your alphabet. You will have the logic more localized and can better handle input and gives you better control over your letter's behavior. It's more work, but I think it will result in cleaner and easier to maintain code. Internally, you can do half integers (which I would also represent with elements in `QQ`).

Here are some additional comments:

- Revert the changes in `combinat/partition.py` as they are not substantive and could create unnecessary merge conflicts.
- Your `ShiftedPrimedTableau.__init__` should have a `check` argument that passes it off to `ClonableArray.__init__`.
- It is good practice to not use `_` as an iterating variable, e.g., `t = [tuple(_) for _ in t]` (normally it is done this way when it is a dummy variable).
- You need to also implement a `__ne__`:
  {{{
sage: t = ShiftedPrimedTableau([This is the Trac macro *1,"2p"* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,"2p"-macro))
sage: t != ShiftedPrimedTableaux([2])([1,1.5])
True
  }}}
- I think the checking that the shape is a partition should not be done within `check` but in `_element_constructor_`.
- For the `_repr_`, you should link to the global options of `Tableaux` and mimic that.
- The fact that you use `max_entry`, which is rounded up, leads to an extra space in the repr for a max entry of `9'`.
- Is the `_to_matrix()` suppose to only handle non-skew shapes? In particular, I am worried about the `m = self.shape()[0]`.
- You should put latex format docstring, such as ``i`` in `weight`.
- Your indentation of numbered lists is 1 too many (it should be at the same level as the rest of the documentation).
- In `f` and `e`, `self` should never be `None`.
- Instead of `self.parent()(T)`, you should use `type(self)(self.parent(), T)`.
- (As previously mentioned) `is_highest_weight` needs to take an `index_set` argument.
- Classes do not have an `OUTPUT`. Also, I prefer to have `INPUT` after the descriptive text of a class (and methods) doc.
- Anytime you have latex in a doc, you should make the string a raw string by doing `r"""`.
- `None of the Shifted Primed Tableaux classes can be iterated over.` is not true.
- Capitalization of `Shifted Primed Tableaux` should follow usual English capitalization (it is not a proper noun) in the documentation (not for the `_repr_`).
- `ShiftedPrimedTableaux` is not a factory class, so the `__classcall_private__` is wrong. For that doc, I would just say "Normalize and process input to return the correct parent and ensure a unique representation."
- Be explicit about your arguments in `__classcall_private__` instead of having to do extra processing.
- Do not be afraid to break the 80 char/line in code. For example, I would not do a line break here:
  {{{
                        raise ValueError(
                            'invalid argument for weight or shape')
  }}}
- The `ShiftedPrimedTableaux.__contains__` looks effectively like the default one from `Parent`, so I think it could be removed.
- Similarly for `ShiftedPrimedTableaux_all._element_constructor_`, which looses a more specific error message by the extra handling.
- I do not understand what you mean by `nonincreasing weight`.
- Actually, now that I've gotten through more of the code, I think you should implement your check by checking `T in self.parent()` and implementing all the actual checks in the `__contains__`.
- For the crystals, you can use the iterator from the category.
- Infinite sets are not a reason you cannot iterate.
- For the `__contains__` and `_element_constructor_`, use `super` calls.
- For the `__iter__`, it is not standard practice to return a generator object.
- You do not need to repeatedly do `Element = ShiftedPrimedTableau`.
- You should have a subclass of `ShiftedPrimedTableau` specifically for the case when it is a crystal.
- You have a blank `yield` in `ShiftedPrimedTableaux_weight_shape.__iter__`, and `yield` is not a function.
- In here `Partition(sorted(list(self._weight), key=int, reverse=True))):`, I don't understand why you need the `key=int` or why you need or should sort `self._weight`.


---

Comment by kbparamonov created at 2018-01-08 20:48:19

Alright, I'll be working on your comments.

Replying to [comment:108 tscrim]:
> I know its somewhat far into this, but I don't like using floating points for the half integers. They are inexact and have a bad representation (e.g., when you raise an error on an invalid object). I think you should have a class that represents the letters in your alphabet. You will have the logic more localized and can better handle input and gives you better control over your letter's behavior. It's more work, but I think it will result in cleaner and easier to maintain code. Internally, you can do half integers (which I would also represent with elements in `QQ`).
> 
> Here are some additional comments:
> 
> - Revert the changes in `combinat/partition.py` as they are not substantive and could create unnecessary merge conflicts.
> - Your `ShiftedPrimedTableau.__init__` should have a `check` argument that passes it off to `ClonableArray.__init__`.
> - It is good practice to not use `_` as an iterating variable, e.g., `t = [tuple(_) for _ in t]` (normally it is done this way when it is a dummy variable).
> - You need to also implement a `__ne__`:
>   {{{
> sage: t = ShiftedPrimedTableau([This is the Trac macro *1,"2p"* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,"2p"-macro))
> sage: t != ShiftedPrimedTableaux([2])([1,1.5])
> True
>   }}}
> - I think the checking that the shape is a partition should not be done within `check` but in `_element_constructor_`.
> - For the `_repr_`, you should link to the global options of `Tableaux` and mimic that.
> - The fact that you use `max_entry`, which is rounded up, leads to an extra space in the repr for a max entry of `9'`.
> - Is the `_to_matrix()` suppose to only handle non-skew shapes? In particular, I am worried about the `m = self.shape()[0]`.
> - You should put latex format docstring, such as ``i`` in `weight`.
> - Your indentation of numbered lists is 1 too many (it should be at the same level as the rest of the documentation).
> - In `f` and `e`, `self` should never be `None`.
> - Instead of `self.parent()(T)`, you should use `type(self)(self.parent(), T)`.
> - (As previously mentioned) `is_highest_weight` needs to take an `index_set` argument.
> - Classes do not have an `OUTPUT`. Also, I prefer to have `INPUT` after the descriptive text of a class (and methods) doc.
> - Anytime you have latex in a doc, you should make the string a raw string by doing `r"""`.
> - `None of the Shifted Primed Tableaux classes can be iterated over.` is not true.
> - Capitalization of `Shifted Primed Tableaux` should follow usual English capitalization (it is not a proper noun) in the documentation (not for the `_repr_`).
> - `ShiftedPrimedTableaux` is not a factory class, so the `__classcall_private__` is wrong. For that doc, I would just say "Normalize and process input to return the correct parent and ensure a unique representation."
> - Be explicit about your arguments in `__classcall_private__` instead of having to do extra processing.
> - Do not be afraid to break the 80 char/line in code. For example, I would not do a line break here:
>   {{{
>                         raise ValueError(
>                             'invalid argument for weight or shape')
>   }}}
> - The `ShiftedPrimedTableaux.__contains__` looks effectively like the default one from `Parent`, so I think it could be removed.
> - Similarly for `ShiftedPrimedTableaux_all._element_constructor_`, which looses a more specific error message by the extra handling.
> - I do not understand what you mean by `nonincreasing weight`.
> - Actually, now that I've gotten through more of the code, I think you should implement your check by checking `T in self.parent()` and implementing all the actual checks in the `__contains__`.
> - For the crystals, you can use the iterator from the category.
> - Infinite sets are not a reason you cannot iterate.
> - For the `__contains__` and `_element_constructor_`, use `super` calls.
> - For the `__iter__`, it is not standard practice to return a generator object.
> - You do not need to repeatedly do `Element = ShiftedPrimedTableau`.
> - You should have a subclass of `ShiftedPrimedTableau` specifically for the case when it is a crystal.
> - You have a blank `yield` in `ShiftedPrimedTableaux_weight_shape.__iter__`, and `yield` is not a function.
> - In here `Partition(sorted(list(self._weight), key=int, reverse=True))):`, I don't understand why you need the `key=int` or why you need or should sort `self._weight`.


---

Comment by git created at 2018-01-16 23:26:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-18 01:06:58

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-18 01:08:57

Alright, I've addressed Travis' comments. The code is ready for another review.

Replying to [comment:111 git]:
> Branch pushed to git repo; I updated commit sha1. New commits:
> ||[ea347f7](https://git.sagemath.org/sage.git/commit/?id=ea347f74dd96d9955622a930f9658560e0ead65d)||`Added class of entries`||


---

Comment by aschilling created at 2018-01-20 16:56:17

The documentation does not compile:

```
[dochtml] OSError: [combinat ] /Applications/sage/local/lib/python2.7/site-packages/sage/combinat/shifted_primed_tableau.py:docstring of sage.combinat.shifted_primed_tableau.CrystalElementShiftedPrimedTableau.reading_word:10: WARNING: Unexpected indentation.
[dochtml] 
make[2]: *** [doc-html] Error 1
```



---

Comment by git created at 2018-01-20 18:00:17

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2018-01-21 13:44:01

The weight of a skew shifted tableau currently fails:

```
sage: s = ShiftedPrimedTableau([(1, 3.5), (2.5,), (6,)], skew=[2,1])
sage: s.weight()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-194-c0897c3f66a5> in <module>()
----> 1 s.weight()

/home/martin/sage-develop/src/sage/combinat/shifted_primed_tableau.py in weight(self)
    697            (1, 4, 1)
    698 
--> 699            sage: s = ShiftedPrimedTableau([(1, 3.5), (2.5,), (6,)], skew=[2,1])
    700            sage: s.weight()
    701         """

AttributeError: 'NoneType' object has no attribute 'unprime'
```

A fix would be

```
    def weight(self):
        r"""
        Return the weight of ``self``.

        The weight of a shifted primed tableau is defined to be the vector
        with `i`-th component equal to the number of entries i and i' in the
        tableau.

        EXAMPLES::

           sage: t = ShiftedPrimedTableau([[1,'2p',2,2],[2,'3p']])
           sage: t.weight()
           (1, 4, 1)

           sage: s = ShiftedPrimedTableau([(1, 3.5), (2.5,), (6,)], skew=[2,1])
           sage: s.weight()
           (1, 0, 1, 1, 0, 1)
        """
        flat = [entry.unprime() for row in self for entry in row if entry is not None]
        if flat == []:
            max_ind = 0
        else:
            max_ind = max(flat)
        weight = tuple([flat.count(i+1) for i in range(max_ind)])
        return weight
```


It might be good to test a skew tableau in all methods.


---

Comment by mantepse created at 2018-01-21 13:51:12

I am not completely sure, but it might be that there is also a speed regression:

```
martin@Martin-Laptop:~/sage-develop$ sage -t src/sage/combinat/shifted_primed_tableau.py 
too many failed tests, not using stored timings
Running doctests with ID 2018-01-21-14-48-10-0647444a.
Git branch: HEAD
Using --optional=atlas,database_gap,dot2tex,fricas,gap_packages,mpir,ore_algebra,python2,sage
Doctesting 1 file.
sage -t src/sage/combinat/shifted_primed_tableau.py
    [218 tests, 48.25 s]
```


I think it was much faster before, but I did not take notes :-(


---

Comment by git created at 2018-01-21 17:26:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-21 17:31:09

Thanks for comments, Martin! I had a speedup on my computer actually.

```
sage -t shifted_primed_tableau.py
    [199 tests, 11.27 s]
----------------------------------------------------------------------
All tests passed!
----------------------------------------------------------------------
Total time for all tests: 11.4 seconds
    cpu time: 11.0 seconds
    cumulative wall time: 11.3 seconds
```



Replying to [comment:116 mantepse]:
> I am not completely sure, but it might be that there is also a speed regression:
> {{{
> martin`@`Martin-Laptop:~/sage-develop$ sage -t src/sage/combinat/shifted_primed_tableau.py 
> too many failed tests, not using stored timings
> Running doctests with ID 2018-01-21-14-48-10-0647444a.
> Git branch: HEAD
> Using --optional=atlas,database_gap,dot2tex,fricas,gap_packages,mpir,ore_algebra,python2,sage
> Doctesting 1 file.
> sage -t src/sage/combinat/shifted_primed_tableau.py
>     [218 tests, 48.25 s]
> }}}
> 
> I think it was much faster before, but I did not take notes :-(


---

Comment by git created at 2018-01-21 17:46:11

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by aschilling created at 2018-01-21 18:00:32

For me the tests on `shifted_primed_tableau` also only take about 9 seconds. There are still a couple of methods without proper tests:

```
sage -coverage shifted_primed_tableau.py 
------------------------------------------------------------------------
SCORE shifted_primed_tableau.py: 93.2% (55 of 59)

Missing doctests:
     * line 140: def _preprocess_(T, skew=None)
     * line 1128: def __init__(self, skew=None)
     * line 1134: def _element_constructor_(self, T)
     * line 1153: def _contains_tableau_(self, T)

Possibly wrong (function name doesn't occur in doctests):
     * line 241: def _repr_list(self)
------------------------------------------------------------------------
```

After that I am happy to set a positive review unless other issues arise!


---

Comment by mantepse created at 2018-01-21 18:20:21

I checked, on my office computer tests also take only about 8 seconds.  On my laptop, there is precisely one test which takes more than one second:

```
Trying (line 1502):    TestSuite(ShiftedPrimedTableaux([4,2,1], max_entry=4)).run()
Expecting nothing
ok [44.84 s]
```



---

Comment by mantepse created at 2018-01-21 19:01:11

The following change makes quite a difference.  After the change, most of the time is spent in `QQ(entry)`.

```
diff --git a/src/sage/combinat/shifted_primed_tableau.py b/src/sage/combinat/shifted_primed_tableau.py
index 266e556..8057497 100644
--- a/src/sage/combinat/shifted_primed_tableau.py
+++ b/src/sage/combinat/shifted_primed_tableau.py
@@ -884,15 +884,14 @@ class ShiftedPrimedTableauEntry(Rational):
             sage: ShiftedPrimedTableau([[1,1.5]])[0][1]
             2'
         """
+        half = Integer(1)/Integer(2)
         if isinstance(entry, str):
             if (entry[-1] == "'" or entry[-1] == "p") and entry[:-1].isdigit() is True:
                 # Check if an element has "'" or "p" at the end
-                entry = QQ(entry[:-1]) - .5
+                entry = QQ(entry[:-1]) - half
         try:
-            if (QQ(entry)+.5 in ZZ) or (QQ(entry) in ZZ):
-                # Check if an element is a half-integer
-                entry = QQ(entry)
-            else:
+            entry = QQ(entry)
+            if (entry not in ZZ) and ((entry + half) not in ZZ):
                 raise ValueError("all numbers must be half-integers")
         except (TypeError, ValueError):
             raise ValueError("primed elements have wrong format")
```



---

Comment by git created at 2018-01-21 19:42:35

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-21 19:59:43

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-21 20:01:27

Try it now, it should work faster.

Replying to [comment:122 mantepse]:
> The following change makes quite a difference.  After the change, most of the time is spent in `QQ(entry)`.
> {{{
> diff --git a/src/sage/combinat/shifted_primed_tableau.py b/src/sage/combinat/shifted_primed_tableau.py
> index 266e556..8057497 100644
> --- a/src/sage/combinat/shifted_primed_tableau.py
> +++ b/src/sage/combinat/shifted_primed_tableau.py
> `@``@` -884,15 +884,14 `@``@` class ShiftedPrimedTableauEntry(Rational):
>              sage: ShiftedPrimedTableau([This is the Trac macro *1,1.5* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1.5-macro))[0][1]
>              2'
>          """
> +        half = Integer(1)/Integer(2)
>          if isinstance(entry, str):
>              if (entry[-1] == "'" or entry[-1] == "p") and entry[:-1].isdigit() is True:
>                  # Check if an element has "'" or "p" at the end
> -                entry = QQ(entry[:-1]) - .5
> +                entry = QQ(entry[:-1]) - half
>          try:
> -            if (QQ(entry)+.5 in ZZ) or (QQ(entry) in ZZ):
> -                # Check if an element is a half-integer
> -                entry = QQ(entry)
> -            else:
> +            entry = QQ(entry)
> +            if (entry not in ZZ) and ((entry + half) not in ZZ):
>                  raise ValueError("all numbers must be half-integers")
>          except (TypeError, ValueError):
>              raise ValueError("primed elements have wrong format")
> }}}


---

Comment by git created at 2018-01-21 20:05:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2018-01-21 21:43:52

Indeed, it is faster now.  However, I now realise that I do not understand the logic of `ShiftedPrimedTableauEntry.__init__`:

* removing the call to `float` in `ShiftedPrimedTableauEntry.__add__` makes `__init__` break - why?

* the check for half-integer could also be done using `entry.denominator() in (1, 2)`.


---

Comment by git created at 2018-01-21 23:04:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-21 23:08:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-21 23:12:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-21 23:13:24

Alright, I've reworked the add function, it was too janky.

Replying to [comment:127 mantepse]:
> Indeed, it is faster now.  However, I now realise that I do not understand the logic of `ShiftedPrimedTableauEntry.__init__`:
> 
> * removing the call to `float` in `ShiftedPrimedTableauEntry.__add__` makes `__init__` break - why?
> 
> * the check for half-integer could also be done using `entry.denominator() in (1, 2)`.


---

Comment by mantepse created at 2018-01-22 07:26:31

It is **much** faster now, and easier to understand!

Very tiny thing: I would suggest to rename

```
    def unprime(self):
```

to

```
    def unprimed(self):
```

because it doesn't modify self (of course).

Travis, could you please do the final check?


---

Comment by tscrim created at 2018-01-24 05:48:10

Sorry, I haven't had time the past few days and most likely will not for the next few (but I will try). However, on a quick look, I do not like the tableau entries inheriting from `Rational` because they do not behave like rationals: they do not have a parent object, they do not have "actual" arithmetic, and they are not rational numbers in the usual sense. In a way, you override the methods precisely why you are inheriting from `Rational`. I think you would be better wrapping a `Rational`, but I would like to Cythonize it (which I can do once I have a few minutes).


---

Comment by mantepse created at 2018-01-24 06:44:47

Travis, isn't that an implementation detail, mostly private?  A lot of time already went into this ticket, I would think it might be better to go in for now...

Anyway I also thought a wrapper would be more logical.  To be precise, it should be a poset, but that's probably overkill.

EDIT: corrected version.

```
class PrimedEntry(SageObject):
    """
    The class of entries in shifted primed tableaux.
    """
    def __init__(self, entry=None, double=None):
        """
        Normalize the entry.

        TEST::

            sage: ShiftedPrimedTableau([[1,"2p"]])[0][1]
            2'
            sage: ShiftedPrimedTableau([[1,"2'"]])[0][1]
            2'
            sage: ShiftedPrimedTableau([[1,1.5]])[0][1]
            2'
        """
        # store primed numbers as odd, unprimed numbers as even integers
        if isinstance(entry, self.__class__):
            self._entry = entry._entry
            return

        if double is not None:
            self._entry = Integer(double)
            return

        if isinstance(entry, str):
            if (entry[-1] == "'" or entry[-1] == "p") and entry[:-1].isdigit() is True:
                # Check if an element has "'" or "p" at the end
                self._entry = 2*Integer(entry[:-1]) - 1
                return

        try:
            entry = Rational(entry)
        except (TypeError, ValueError):
            raise ValueError("primed elements have wrong format")
        if entry.denominator() not in (1, 2):
            # Check if an element is a half-integer
            raise ValueError("all numbers must be half-integers")
        self._entry = Integer(2*entry)

    def __hash__(self):
        return self._entry

    def __repr__(self):
        """
        Represent ``self`` as primed or unprimed integer.

        TEST::

            sage: ShiftedPrimedTableau([[1,"2p"]])[0][1]
            2'
        """
        if is_even(self._entry):
            return str(self._entry//2)
        else:
            return str((self._entry+1)//2) + "'"

    def integer(self):
        return self._entry//2

    def __eq__(self, other):
        return self._entry == PrimedEntry(other)._entry

    def __ne__(self, other):
        return self._entry != PrimedEntry(other)._entry

    def __lt__(self, other):
        return self._entry < PrimedEntry(other)._entry

    def __le__(self, other):
        return self._entry <= PrimedEntry(other)._entry

    def __gt__(self, other):
        return self._entry > PrimedEntry(other)._entry

    def __ge__(self, other):
        return self._entry >= PrimedEntry(other)._entry

    def is_unprimed(self):
        """
        Checks if ``self`` is an unprimed element.

        TEST::

            sage: a = ShiftedPrimedTableau([[1,"2p"]])[0][1]
            sage: a.is_unprimed()
            False
        """
        return is_even(self._entry)

    def is_primed(self):
        """
        Checks if ``self`` is a primed element.

        TEST::

            sage: a = ShiftedPrimedTableau([[1,"2p"]])[0][1]
            sage: a.is_primed()
            True
        """
        return is_odd(self._entry)

    def unprimed(self):
        """
        Unprime ``self`` if it is a primed element.

        TEST::

            sage: a = ShiftedPrimedTableau([[1,"2p"]])[0][1]
            sage: a.unprimed()
            2
        """
        if is_even(self._entry):
            return self
        else:
            return PrimedEntry(double=self._entry + 1)

    def primed(self):
        """
        Prime ``self`` if it is an unprimed element.

        TEST::

            sage: a = ShiftedPrimedTableau([[1,"2p"]])[0][0]
            sage: a.primed()
            1'
        """

        if is_even(self._entry):
            return PrimedEntry(double=self._entry - 1)
        else:
            return self

    def increase_half(self):
        return PrimedEntry(double=self._entry + 1)

    def decrease_half(self):
        return PrimedEntry(double=self._entry - 1)

    def increase_one(self):
        return PrimedEntry(double=self._entry + 2)

    def decrease_one(self):
        return PrimedEntry(double=self._entry - 2)
```



---

Attachment

I spent some time abstracting `PrimedEntry`, but the performance is not really good.  Moreover, this raises the question whether the elements of the reading word should be integers or `PrimedEntry`s.

I attached the file in case it is of any interest.


---

Comment by git created at 2018-01-24 23:48:49

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-24 23:49:46

Thank you for helping me with this.

Replying to [comment:134 mantepse]:
> Travis, isn't that an implementation detail, mostly private?  A lot of time already went into this ticket, I would think it might be better to go in for now...
> 
> Anyway I also thought a wrapper would be more logical.  To be precise, it should be a poset, but that's probably overkill.
> 
> EDIT: corrected version.
> {{{
> class PrimedEntry(SageObject):
>     """
>     The class of entries in shifted primed tableaux.
>     """
>     def __init__(self, entry=None, double=None):
>         """
>         Normalize the entry.
> 
>         TEST::
> 
>             sage: ShiftedPrimedTableau([This is the Trac macro *1,"2p"* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,"2p"-macro))[0][1]
>             2'
>             sage: ShiftedPrimedTableau([This is the Trac macro *1,"2'"* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,"2'"-macro))[0][1]
>             2'
>             sage: ShiftedPrimedTableau([This is the Trac macro *1,1.5* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,1.5-macro))[0][1]
>             2'
>         """
>         # store primed numbers as odd, unprimed numbers as even integers
>         if isinstance(entry, self.__class__):
>             self._entry = entry._entry
>             return
> 
>         if double is not None:
>             self._entry = Integer(double)
>             return
> 
>         if isinstance(entry, str):
>             if (entry[-1] == "'" or entry[-1] == "p") and entry[:-1].isdigit() is True:
>                 # Check if an element has "'" or "p" at the end
>                 self._entry = 2*Integer(entry[:-1]) - 1
>                 return
> 
>         try:
>             entry = Rational(entry)
>         except (TypeError, ValueError):
>             raise ValueError("primed elements have wrong format")
>         if entry.denominator() not in (1, 2):
>             # Check if an element is a half-integer
>             raise ValueError("all numbers must be half-integers")
>         self._entry = Integer(2*entry)
> 
>     def __hash__(self):
>         return self._entry
> 
>     def __repr__(self):
>         """
>         Represent ``self`` as primed or unprimed integer.
> 
>         TEST::
> 
>             sage: ShiftedPrimedTableau([This is the Trac macro *1,"2p"* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,"2p"-macro))[0][1]
>             2'
>         """
>         if is_even(self._entry):
>             return str(self._entry//2)
>         else:
>             return str((self._entry+1)//2) + "'"
> 
>     def integer(self):
>         return self._entry//2
> 
>     def __eq__(self, other):
>         return self._entry == PrimedEntry(other)._entry
> 
>     def __ne__(self, other):
>         return self._entry != PrimedEntry(other)._entry
> 
>     def __lt__(self, other):
>         return self._entry < PrimedEntry(other)._entry
> 
>     def __le__(self, other):
>         return self._entry <= PrimedEntry(other)._entry
> 
>     def __gt__(self, other):
>         return self._entry > PrimedEntry(other)._entry
> 
>     def __ge__(self, other):
>         return self._entry >= PrimedEntry(other)._entry
> 
>     def is_unprimed(self):
>         """
>         Checks if ``self`` is an unprimed element.
> 
>         TEST::
> 
>             sage: a = ShiftedPrimedTableau([This is the Trac macro *1,"2p"* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,"2p"-macro))[0][1]
>             sage: a.is_unprimed()
>             False
>         """
>         return is_even(self._entry)
> 
>     def is_primed(self):
>         """
>         Checks if ``self`` is a primed element.
> 
>         TEST::
> 
>             sage: a = ShiftedPrimedTableau([This is the Trac macro *1,"2p"* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,"2p"-macro))[0][1]
>             sage: a.is_primed()
>             True
>         """
>         return is_odd(self._entry)
> 
>     def unprimed(self):
>         """
>         Unprime ``self`` if it is a primed element.
> 
>         TEST::
> 
>             sage: a = ShiftedPrimedTableau([This is the Trac macro *1,"2p"* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,"2p"-macro))[0][1]
>             sage: a.unprimed()
>             2
>         """
>         if is_even(self._entry):
>             return self
>         else:
>             return PrimedEntry(double=self._entry + 1)
> 
>     def primed(self):
>         """
>         Prime ``self`` if it is an unprimed element.
> 
>         TEST::
> 
>             sage: a = ShiftedPrimedTableau([This is the Trac macro *1,"2p"* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#1,"2p"-macro))[0][0]
>             sage: a.primed()
>             1'
>         """
> 
>         if is_even(self._entry):
>             return PrimedEntry(double=self._entry - 1)
>         else:
>             return self
> 
>     def increase_half(self):
>         return PrimedEntry(double=self._entry + 1)
> 
>     def decrease_half(self):
>         return PrimedEntry(double=self._entry - 1)
> 
>     def increase_one(self):
>         return PrimedEntry(double=self._entry + 2)
> 
>     def decrease_one(self):
>         return PrimedEntry(double=self._entry - 2)
> }}}


---

Comment by mantepse created at 2018-01-25 07:25:39

Kirill, here are some more trivialities.  The first one cuts away a few seconds on my laptop.

Travis, is it good enough now?

```
diff --git a/src/sage/combinat/shifted_primed_tableau.py b/src/sage/combinat/shifted_primed_tableau.py
index a80a6acaae..be701a06bb 100644
--- a/src/sage/combinat/shifted_primed_tableau.py
+++ b/src/sage/combinat/shifted_primed_tableau.py
@@ -599,7 +599,7 @@ class CrystalElementShiftedPrimedTableau(ShiftedPrimedTableau):
             sage: mat
             [[1, 2', 2, 2], [None, 2, 3', None], [None, None, 3, None]]
         """
-        m = self.shape()[0]
+        m = len(self[0])
         return [[None]*i + list(row) + [None]*(m-i-len(row))
                 for i, row in enumerate(self)]
 
@@ -809,7 +809,7 @@ class CrystalElementShiftedPrimedTableau(ShiftedPrimedTableau):
         element_to_change = None
         count = 0
 
-        for element in read_word[::-1]:
+        for element in reversed(read_word):
             if element[1] == ind:
                 count += 1
             elif count == 0:
@@ -882,7 +882,7 @@ class CrystalElementShiftedPrimedTableau(ShiftedPrimedTableau):
         count = {i: 0 for i in range(max_entry+1)}
         if index_set is None:
             index_set = self.parent().index_set()
-        for l in read_w[::-1]:
+        for l in reversed(read_w):
             count[l] += 1
             if (l-1 in index_set) and (l > 1) and (count[l] > count[l-1]):
                 return False
@@ -2041,7 +2041,7 @@ def _add_strip(sub_tab, full_tab, length):
             if len(sub_tab) < len(full_tab) and len(sub_tab) != 0:
                 plat_list.append(min(sub_tab[-1] + primed_strip[-2] - 1,
                                      full_tab[len(sub_tab)]))
-            for row in range(1, len(sub_tab))[::-1]:
+            for row in reversed(range(1, len(sub_tab))):
                 plat_list.append(
                     min(sub_tab[row-1]+primed_strip[row-1]-1, full_tab[row])
                     - sub_tab[row] - primed_strip[row])
```



---

Comment by git created at 2018-01-25 18:15:20

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-01-29 18:50:47

I've been making my way through the current code. I think it has significantly improved by having the letter class in readability. Martin and Kirill, thank you for making the changes to the `PrimeEntry` class.

As part of my review, I have made some changes on my forthcoming push. A good majority of them are trivial changes in formatting and some tricks and micro-optimizations I've learned. Here are some of my more significant changes.

- I scrubbed all (unnecessary) calls to `float` and `int`.
- I used the fast partition iterator in one place.
- I removed some (now incorrect) documentation. (I generally do not like implementation details of top-level classes exposed to the user when they do not really "see" those details.)
- I fixed a bug with weight 0 tableaux.
- I removed the redundant `_element_constructor_`s that just made a super call and raised the same error as what the super does. I moved the doctests.
- Made `_reading_word_with_positions` an iterator as the list output was never used.
- I removed the iterator for the crystals because the one from the crystals category is >10x faster:
  {{{
sage: SPT = ShiftedPrimedTableaux([3,2], max_entry=3)
sage: %timeit for x in SPT._old_iter(): pass
The slowest run took 9.45 times longer than the fastest. This could mean that an intermediate result is being cached.
100 loops, best of 3: 19.2 ms per loop
sage: %timeit for x in SPT: pass
The slowest run took 5.46 times longer than the fastest. This could mean that an intermediate result is being cached.
1000 loops, best of 3: 1.48 ms per loop
  }}}

However, there are some other things that do need some additional work, but then I think that is the last of it.

- `_contains_tableau_` and `_preprocess_` are not special Sage methods, and should not end with a trailing underscore. You also should directly test them as it helps isolate bugs when one gets introduced.
- For the `PrimedEntry` class, you should import the class and directly construct the elements instead of indirectly via the tableau. Also, you might want to consider expanding the doc a little more (but not necessary).
- I noticed that `PrimedEntry` can sometimes be passed a `None`, which I do not think should happen. IMO, this is a bug that is hacked around (before, it was handled by `Rational(None)` being `1` through what is essentially a shortcoming of how `Parent.__call__` works). However, it is a technical debt we can take on for now.
- This is essentially a bug:
  {{{
sage: SPT = ShiftedPrimedTableaux(skew=[1])
sage: SPT.category()
Category of infinite enumerated sets
  }}}
  because you cannot iterate over this object (currently). In a related issue, I added a test `TestSuite(SPT).run()` and marked as a known bug. I think you should have the correct categories in this case.


---

Comment by git created at 2018-01-29 18:51:24

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2018-01-30 20:58:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-30 21:01:04

Alright, I've addressed your comments.

Replying to [comment:140 tscrim]:
> I've been making my way through the current code. I think it has significantly improved by having the letter class in readability. Martin and Kirill, thank you for making the changes to the `PrimeEntry` class.
> 
> As part of my review, I have made some changes on my forthcoming push. A good majority of them are trivial changes in formatting and some tricks and micro-optimizations I've learned. Here are some of my more significant changes.
> 
> - I scrubbed all (unnecessary) calls to `float` and `int`.
> - I used the fast partition iterator in one place.
> - I removed some (now incorrect) documentation. (I generally do not like implementation details of top-level classes exposed to the user when they do not really "see" those details.)
> - I fixed a bug with weight 0 tableaux.
> - I removed the redundant `_element_constructor_`s that just made a super call and raised the same error as what the super does. I moved the doctests.
> - Made `_reading_word_with_positions` an iterator as the list output was never used.
> - I removed the iterator for the crystals because the one from the crystals category is >10x faster:
>   {{{
> sage: SPT = ShiftedPrimedTableaux([3,2], max_entry=3)
> sage: %timeit for x in SPT._old_iter(): pass
> The slowest run took 9.45 times longer than the fastest. This could mean that an intermediate result is being cached.
> 100 loops, best of 3: 19.2 ms per loop
> sage: %timeit for x in SPT: pass
> The slowest run took 5.46 times longer than the fastest. This could mean that an intermediate result is being cached.
> 1000 loops, best of 3: 1.48 ms per loop
>   }}}
> 
> However, there are some other things that do need some additional work, but then I think that is the last of it.
> 
> - `_contains_tableau_` and `_preprocess_` are not special Sage methods, and should not end with a trailing underscore. You also should directly test them as it helps isolate bugs when one gets introduced.
> - For the `PrimedEntry` class, you should import the class and directly construct the elements instead of indirectly via the tableau. Also, you might want to consider expanding the doc a little more (but not necessary).
> - I noticed that `PrimedEntry` can sometimes be passed a `None`, which I do not think should happen. IMO, this is a bug that is hacked around (before, it was handled by `Rational(None)` being `1` through what is essentially a shortcoming of how `Parent.__call__` works). However, it is a technical debt we can take on for now.
> - This is essentially a bug:
>   {{{
> sage: SPT = ShiftedPrimedTableaux(skew=[1])
> sage: SPT.category()
> Category of infinite enumerated sets
>   }}}
>   because you cannot iterate over this object (currently). In a related issue, I added a test `TestSuite(SPT).run()` and marked as a known bug. I think you should have the correct categories in this case.


---

Comment by tscrim created at 2018-01-30 22:35:18

Replying to [comment:143 kbparamonov]:
> Alright, I've addressed your comments.

> Replying to [comment:140 tscrim]:
> > - `_contains_tableau_` and `_preprocess_` are not special Sage methods, and should not end with a trailing underscore. You also should directly test them as it helps isolate bugs when one gets introduced.

The latter part has not been adequately addressed. In particular, you should have the _direct_ tests for each method testing the key points (ideally every code path).

> > - I noticed that `PrimedEntry` can sometimes be passed a `None`, which I do not think should happen. IMO, this is a bug that is hacked around (before, it was handled by `Rational(None)` being `1` through what is essentially a shortcoming of how `Parent.__call__` works). However, it is a technical debt we can take on for now.

You should add a test showing that `PrimedEntry(None)` now raises an error.

I'm also not convinced of having the `try-except` blocks in the comparisons of `PrimedEntry`. I think because of how low-level `PrimedEntry` is, you don't need the extra minor speed hit except for  `__eq__` and `__ne__` (I agree with them raising an error, but the new error message is not really useful IMO).

----

Sorry, one additional little thing: `PrimedEntry.integer`, `PrimedEntry.decrease_*`, and `PrimedEntry.increase_*` should have at least a one line docstring explaining what they do.


---

Comment by git created at 2018-01-30 23:33:25

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-01-30 23:35:06

Is this what you had in mind?

Replying to [comment:144 tscrim]:
> Replying to [comment:143 kbparamonov]:
> > Alright, I've addressed your comments.
> 
> > Replying to [comment:140 tscrim]:
> > > - `_contains_tableau_` and `_preprocess_` are not special Sage methods, and should not end with a trailing underscore. You also should directly test them as it helps isolate bugs when one gets introduced.
> 
> The latter part has not been adequately addressed. In particular, you should have the _direct_ tests for each method testing the key points (ideally every code path).
> 
> > > - I noticed that `PrimedEntry` can sometimes be passed a `None`, which I do not think should happen. IMO, this is a bug that is hacked around (before, it was handled by `Rational(None)` being `1` through what is essentially a shortcoming of how `Parent.__call__` works). However, it is a technical debt we can take on for now.
> 
> You should add a test showing that `PrimedEntry(None)` now raises an error.
> 
> I'm also not convinced of having the `try-except` blocks in the comparisons of `PrimedEntry`. I think because of how low-level `PrimedEntry` is, you don't need the extra minor speed hit except for  `__eq__` and `__ne__` (I agree with them raising an error, but the new error message is not really useful IMO).
> 
> ----
> 
> Sorry, one additional little thing: `PrimedEntry.integer`, `PrimedEntry.decrease_*`, and `PrimedEntry.increase_*` should have at least a one line docstring explaining what they do.


---

Comment by tscrim created at 2018-01-31 01:36:49

Yes, although there are two `_contains_tableau` that are still not directly doctested. Also, the `__ge__` test is actually testing `__le__`.


---

Comment by git created at 2018-01-31 01:52:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by tscrim created at 2018-01-31 02:11:32

Thank you. I am happy and given Martin's comments, I am setting this to a positive review.


---

Comment by tscrim created at 2018-01-31 02:11:32

Changing status from needs_review to positive_review.


---

Comment by kbparamonov created at 2018-01-31 06:36:35

Thank you for reviewing it!

Replying to [comment:149 tscrim]:
> Thank you. I am happy and given Martin's comments, I am setting this to a positive review.


---

Comment by mantepse created at 2018-01-31 08:56:17

Wonderful! #23896 is then also ready for review!  (For some reason, the automerging failed, but I could checkout the ticket without trouble.)


---

Comment by mantepse created at 2018-02-01 04:13:18

The patchbot is reporting a failure I overlooked because the doctest is marked "long time":

```
sage: SPT = ShiftedPrimedTableaux()
sage: TestSuite(SPT).run()
  Failure in _test_eq:
  Traceback (most recent call last):
    File "/home/martin/sage-develop/local/lib/python2.7/site-packages/sage/misc/sage_unittest.py", line 294, in run                                   
      test_method(tester = tester)
    File "sage/structure/element.pyx", line 745, in sage.structure.element.Element._test_eq (build/cythonized/sage/structure/element.c:6812)          
      tester.assertFalse(self == None,
    File "/home/martin/sage-develop/local/lib/python2.7/unittest/case.py", line 416, in assertFalse                                                   
      raise self.failureException(msg)
  AssertionError: broken equality: [] == None                                                                                                         
  ------------------------------------------------------------
  The following tests failed: _test_eq
Failure in _test_elements
The following tests failed: _test_elements
```

Apparently, it fails because of the following, but I'm not sure:

```
sage: SPT = ShiftedPrimedTableaux()
sage: SPT.an_element()
[]
sage: SPT.an_element() == None
True
# which is, because
sage: ShiftedPrimedTableau(None)
[]
```



---

Comment by mantepse created at 2018-02-01 04:13:18

Changing status from positive_review to needs_work.


---

Comment by tscrim created at 2018-02-01 04:18:08

That might be my fault and something I introduced trying to keep the code clean. I am about ready to board a flight to Australia, so I cannot look at it for ~19 hours.


---

Comment by mantepse created at 2018-02-01 04:28:23

Quick reply:


```
    def __classcall_private__(cls, T, skew=None):
...
      if isinstance(T, ShiftedPrimedTableau) and T._skew == skew:
            return T
      if not T or T == [[]]:
            return ShiftedPrimedTableaux(skew=skew)([])
```

should be 

```
      if T == [] or T == [[]]:
            return ShiftedPrimedTableaux(skew=skew)([])

```


But the bigger question is: why is `not T` preferred over `T == []` by some people.

The former is impossible to grep for, but still widely used.


---

Comment by mantepse created at 2018-02-01 05:06:58

Please remind me: should the input checking be done in `__classcall_private__` and via `contains`?

For example, I think we should not allow

```
sage: ShiftedPrimedTableau([[None, None, "1p",None, 2]])
[(None, None, None, 1', 2)]                                                                                                                           
```

On the other hand:

```
sage: ShiftedPrimedTableau([tuple([])])
```

should work, shouldn't it?


---

Comment by mantepse created at 2018-02-01 07:45:15

Another corner case:

```
sage: ShiftedPrimedTableau([[None]]).pp()
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-2-d20e95e0a9ff> in <module>()
----> 1 ShiftedPrimedTableau([[None]]).pp()

/home/martin/sage-develop/local/lib/python2.7/site-packages/sage/combinat/shifted_primed_tableau.pyc in pp(self)
    494                 .  2'                                                                                                                         
    495         """                                                                                                                                   
--> 496         print(self._repr_diagram())
    497
    498     def _latex_(self):

/home/martin/sage-develop/local/lib/python2.7/site-packages/sage/combinat/shifted_primed_tableau.pyc in _repr_diagram(self)
    324                 .  2'                                                                                                                         
    325         """                                                                                                                                   
--> 326         max_len = len(str(self.max_entry()))+2
    327         return "\n".join([" "*max_len*i + "".join(val)                                                                                        
    328                           for i, val in enumerate(self._repr_tab())])

/home/martin/sage-develop/local/lib/python2.7/site-packages/sage/combinat/shifted_primed_tableau.pyc in max_entry(self)
    528             return 0
    529
--> 530         return max(entry.unprimed() for row in self
    531                    for entry in row if entry is not None)
    532

ValueError: max() arg is an empty sequence
sage: ShiftedPrimedTableau([[None]])
[(None,)]
```



---

Comment by mantepse created at 2018-02-01 08:16:33

Here is a proposal:


```
diff --git a/src/sage/combinat/shifted_primed_tableau.py b/src/sage/combinat/shifted_primed_tableau.py
index 5fd0c09..be6f46d 100644
--- a/src/sage/combinat/shifted_primed_tableau.py
+++ b/src/sage/combinat/shifted_primed_tableau.py
@@ -108,21 +108,11 @@ class ShiftedPrimedTableau(ClonableArray):
         """
         if isinstance(T, ShiftedPrimedTableau) and T._skew == skew:
             return T
-        if not T or T == [[]]:
-            return ShiftedPrimedTableaux(skew=skew)([])
-        try:
-            entry = T[0][0]
-        except TypeError:
-            raise ValueError("input tableau must be a list of lists")
-
-        if entry is None:
-            skew_ = [row.count(None) for row in T if row[0] is None]
-            if skew is not None:
-                if skew != skew_:
-                    raise ValueError("skew shape does not agree with None entries")
-            else:
-                skew = skew_
-
+        skew_ = Partition([row.count(None) for row in T])
+        if skew_:
+            if skew and Partition(skew) != skew_:
+                raise ValueError("skew shape does not agree with None entries")
+            skew = skew_
         return ShiftedPrimedTableaux(skew=skew)(T)
 
     def __init__(self, parent, T, skew=None, check=True, preprocessed=False):
@@ -163,26 +153,56 @@ class ShiftedPrimedTableau(ClonableArray):
         """
         Preprocessing list ``T`` to initialize the tableau.
 
+        The output is a list of rows as tuples, with explicit
+        ``None``'s to indicate the skew shape, and entries being
+        ``PrimedEntry``s.
+
+        Trailing empty rows are removed.
+
         TESTS::
 
-            sage: ShiftedPrimedTableau._preprocess([["2'", "3p", 3.5]],
-            ....: skew=[1])
+            sage: ShiftedPrimedTableau._preprocess([["2'", "3p", 3.5]], skew=[1])
             [(None, 2', 3', 4')]
+
+            sage: ShiftedPrimedTableau._preprocess([[None, "2'", "3p", 3.5]])
+            [(None, 2', 3', 4')]
+
+            sage: ShiftedPrimedTableau._preprocess([[None]])
+            [(None,)]
+
+            sage: ShiftedPrimedTableau._preprocess([], skew=[2,1])
+            [(None, None), (None,)]
+
+            sage: ShiftedPrimedTableau._preprocess([], skew=[])
+            []
         """
         if isinstance(T, ShiftedPrimedTableau):
             return T
 
-        # Preprocessing list t for primes and other symbols
-        T = [[PrimedEntry(entry) for entry in row if entry is not None]
-             for row in T]
-
-        if skew is not None:
-            T = ([(None,)*skew[i] + tuple(T[i])
-                  for i in range(len(skew))]
-                 + [tuple(T[i]) for i in range(len(skew), len(T))])
-        else:
-            T = [tuple(row) for row in T]
-        return T
+        skew_ = Partition([row.count(None) for row in T])
+        if skew_: # None's are explicit
+            if skew:
+                if Partition(skew) != skew_:
+                    raise ValueError("skew shape does not agree with None entries")
+            T.extend([[]]*(len(skew_)-len(T))) # Warning: these are identical lists
+            for i, s in enumerate(skew_):
+                T[i] = (None,)*s + tuple(PrimedEntry(e) for e in T[i][s:])
+            i += 1
+            T[i:] = [tuple(PrimedEntry(e) for e in row) for row in T[i:]]
+        else: # there are no None's
+            if skew:
+                T.extend([[]]*(len(skew)-len(T))) # Warning: these are identical lists
+                for i, s in enumerate(skew):
+                    T[i] = (None,)*s + tuple(PrimedEntry(e) for e in T[i])
+                i += 1
+                T[i:] = [tuple(PrimedEntry(e) for e in row) for row in T[i:]]
+            else:
+                T = [tuple(PrimedEntry(e) for e in row) for row in T]
+        # remove empty trailing rows
+        for i, row in enumerate(reversed(T)):
+            if row:
+                return T[:-i or None]
+        return []
 
     def check(self):
         """
@@ -354,6 +374,12 @@ class ShiftedPrimedTableau(ClonableArray):
             sage: ascii_art(ShiftedPrimedTableau([]))
             ++
             ++
+
+            sage: ascii_art(ShiftedPrimedTableau([], skew=[1]))
+            +---+
+            | . |
+            +---+
+
         """
         from sage.typeset.ascii_art import AsciiArt
         return AsciiArt(self._ascii_art_table(unicode=False).splitlines())
@@ -383,6 +409,10 @@ class ShiftedPrimedTableau(ClonableArray):
             sage: unicode_art(ShiftedPrimedTableau([]))
             ┌┐
             └┘
+            sage: unicode_art(ShiftedPrimedTableau([], skew=[1]))
+            ┌───┐
+            │ . │
+            └───┘
         """
         from sage.typeset.unicode_art import UnicodeArt
         return UnicodeArt(self._ascii_art_table(unicode=True).splitlines())
@@ -492,6 +522,14 @@ class ShiftedPrimedTableau(ClonableArray):
             sage: s.pp()
              .  .  2' 2  3
                 .  2'
+
+        TESTS::
+
+            sage: ShiftedPrimedTableau([],skew=[1]).pp()
+            .
+
+            sage: ShiftedPrimedTableau([]).pp()
+            <BLANKLINE>
         """
         print(self._repr_diagram())
 
@@ -523,12 +561,19 @@ class ShiftedPrimedTableau(ClonableArray):
             sage: Tab = ShiftedPrimedTableau([(1,1,'2p','3p'),(2,2)])
             sage: Tab.max_entry()
             3
-        """
-        if not self:
-            return 0
 
-        return max(entry.unprimed() for row in self
-                   for entry in row if entry is not None)
+        TESTS::
+
+            sage: Tab = ShiftedPrimedTableau([], skew=[2,1])
+            sage: Tab.max_entry()
+            0
+
+            sage: Tab = ShiftedPrimedTableau([["1p"]], skew=[2,1])
+            sage: Tab.max_entry()
+            1
+        """
+        return max([entry.unprimed() for row in self
+                    for entry in row if entry is not None] + [0])
 
     def shape(self):
         r"""
@@ -2019,4 +2064,3 @@ def _add_strip(sub_tab, full_tab, length):
                                                    k=len(plat_list),
                                                    outer=plat_list):
                 yield list(primed_strip) + list(non_primed_strip)
-
```



---

Comment by git created at 2018-02-01 19:16:19

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-02-01 19:25:52

I agree with the arguments here, though `ShiftedPrimedTableau(None)` should not work in my opinion.
I fixed the `_preprocess` to deal with empty input tableaux.

Replying to [comment:157 mantepse]:
> Here is a proposal:
> {{{
> +            sage: ShiftedPrimedTableau._preprocess([This is the Trac macro *None, "2'", "3p", 3.5* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#None, "2'", "3p", 3.5-macro))
> +            [(None, 2', 3', 4')]
> +
> +            sage: ShiftedPrimedTableau._preprocess([This is the Trac macro *None* that was inherited from the migration](https://trac.sagemath.org/wiki/WikiMacros#None-macro))
> +            [(None,)]
>}}}

I don't agree with this test. Since `_preprocess` is a private function, we can assume all `None`'s in the tableau that get to this point are garbage, and the skew information is passed by `skew` argument.


---

Comment by mantepse created at 2018-02-01 19:46:52

I don't mind - I was only guessing what the responsibilities of `_preprocess` are.  It would be good if you'd clarify by saying what the expected input is.

However, I think that treating `[]` and `[[]]` specially, as follows:

```
        if T == [] or T == [[]]:
             return ShiftedPrimedTableaux(skew=skew)([])
```

is a **very** bad idea.  For example, it is now unclear whether passing tuples or other iterables would also work - I think they should.


---

Comment by git created at 2018-02-01 20:04:15

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by kbparamonov created at 2018-02-01 20:04:53

Fair enough. Let me know if this works.

Replying to [comment:160 mantepse]:
> I don't mind - I was only guessing what the responsibilities of `_preprocess` are.  It would be good if you'd clarify by saying what the expected input is.
> 
> However, I think that treating `[]` and `[[]]` specially, as follows:
> {{{
>         if T == [] or T == [[]]:
>              return ShiftedPrimedTableaux(skew=skew)([])
> }}}
> is a **very** bad idea.  For example, it is now unclear whether passing tuples or other iterables would also work - I think they should.


---

Comment by mantepse created at 2018-02-01 20:09:46

Sorry, I don't understand.  In my proposal, I simply omitted this special case and it worked.  Why do you want to treat it specially?


---

Comment by tscrim created at 2018-02-01 21:15:35

Replying to [comment:154 mantepse]:
> But the bigger question is: why is `not T` preferred over `T == []` by some people.

Because it is both faster and covers a much broader range of inputs uniformly, such as tuples. Although in this case it is a bit too permissive. It probably is better to restrict to lists and tuples. Either that or have an explicit cast to a list/tuple.

> The former is impossible to grep for, but still widely used.

If you are greping for it, then you are looking at something far too localized or disregarding the traceback information.


---

Comment by git created at 2018-02-01 21:43:47

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mantepse created at 2018-02-01 21:54:40

Works for me!  Thanks!


---

Comment by mantepse created at 2018-02-01 22:46:51

Changing status from needs_work to needs_review.


---

Comment by tscrim created at 2018-02-02 10:53:19

Since there is a test for these corner cases via the `_element_constructor_` and the patchbot are green, back to positive review.


---

Comment by tscrim created at 2018-02-02 10:53:19

Changing status from needs_review to positive_review.


---

Comment by vbraun created at 2018-02-03 17:50:13

Resolution: fixed
