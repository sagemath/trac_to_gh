# Issue 20258: Add a function to generate random lattice (poset)

Issue created by migration from Trac.

Original creator: jmantysalo

Original creation time: 2016-04-24 07:37:53

CC:  tscrim chapoton

Keywords: latticeposet

Add a function to generate a random lattice with given number of elements.


---

Comment by jmantysalo created at 2016-08-29 10:30:17

New commits:


---

Comment by jmantysalo created at 2016-08-29 10:30:17

Changing status from new to needs_review.


---

Comment by tscrim created at 2016-08-29 14:14:50

If you pass in a tuple for the `properties`, e.g., `('dismantlable')`, it will result in an error. If you're going to compare it to a list, you should cast `properties` into a list. You should also future-proof your code by checking `properties[0] == 'dismantlable'`.

Also, I feel that `p = 0` should be acceptable and return a chain, as it is the unique lattice with the minimal number of cover relations.

Is this model of random lattices known (i.e., is there a literature reference for it)?


---

Comment by jmantysalo created at 2016-08-29 15:00:41

Replying to [comment:3 tscrim]:
> If you pass in a tuple for the `properties`, e.g., `('dismantlable')`, it will result in an error. If you're going to compare it to a list, you should cast `properties` into a list. You should also future-proof your code by checking `properties[0] == 'dismantlable'`.

The code must be something like


```
props = ['dismantlable', 'modular', 'planar' . . .]
for p in properties:
    if p not in props:
        Raise ValueError(...)
```


But the most important question is the "interface", that is hard to change later. What kind of parameters would be possible to have for different kind of lattices? What if type `x` lattices can have five different numerical parameters to choise from, and type `y` has two?

Or maybe I am planning too much for a code not yet written.

> Also, I feel that `p = 0` should be acceptable and return a chain, as it is the unique lattice with the minimal number of cover relations.

Actually it kind of works now, but generates a random semilattice with minimal number of covers, i.e. a tree, and then adds the top element. Would be strange if `p=0` would always give the chain and `p=0.001` would give a tree (+top).

> Is this model of random lattices known (i.e., is there a literature reference for it)?

I found only https://www.emis.de/journals/MB/125.2/mb125_2_1.pdf and the code in that paper is... Well, take a look at yourself.

I don't know if there is even a theoretical results about "random lattice", like "What is the average width of all non-isomorphic lattices on 100 elements?" So is there anything to compare to be able to say how good or bad an algorithm is?


---

Comment by tscrim created at 2016-08-29 15:23:03

Replying to [comment:4 jmantysalo]:
> Replying to [comment:3 tscrim]:
> > If you pass in a tuple for the `properties`, e.g., `('dismantlable')`, it will result in an error. If you're going to compare it to a list, you should cast `properties` into a list. You should also future-proof your code by checking `properties[0] == 'dismantlable'`.
> 
> The code must be something like
> 
> {{{
> props = ['dismantlable', 'modular', 'planar' . . .]
> for p in properties:
>     if p not in props:
>         Raise ValueError(...)
> }}}

You can also do something like this:

```python
if not set('dismantlable', 'modular', 'planar', ...).is_superset(properties):
    raise ValueError("invalid property")
```


> But the most important question is the "interface", that is hard to change later. What kind of parameters would be possible to have for different kind of lattices? What if type `x` lattices can have five different numerical parameters to choise from, and type `y` has two?

We can easily add parameters and moderately easily change to an `*args` attribute if necessary.

> Or maybe I am planning too much for a code not yet written.
> 
> > Also, I feel that `p = 0` should be acceptable and return a chain, as it is the unique lattice with the minimal number of cover relations.
> 
> Actually it kind of works now, but generates a random semilattice with minimal number of covers, i.e. a tree, and then adds the top element. Would be strange if `p=0` would always give the chain and `p=0.001` would give a tree (+top).

The minimal number of covers has to be a chain, because a tree + top will have E+k covers, where k is the number leaves that is not the root and `E` is the number of edges of the tree. 2 leaves with one being the root minimizes `k`, which implies the tree must be a path/chain. So it is not strange to me because boundary points (at least for Gnp random graphs) can behave different.

> > Is this model of random lattices known (i.e., is there a literature reference for it)?
> 
> I found only https://www.emis.de/journals/MB/125.2/mb125_2_1.pdf and the code in that paper is... Well, take a look at yourself.

Hmmm...I see your point. At least we could drop that C code in and link it easily in Sage to compare. Although it looks like it will generate a different distribution from a cursory look.

> I don't know if there is even a theoretical results about "random lattice", like "What is the average width of all non-isomorphic lattices on 100 elements?" So is there anything to compare to be able to say how good or bad an algorithm is?

Well, if its not known, it might result in a paper if you can determine some theoretical results. I was asking more if there was a reference that could be added.


---

Comment by jmantysalo created at 2016-08-29 16:35:48

Replying to [comment:5 tscrim]:

> You can also do something like this:
> {{{#!python
> if not set('dismantlable', 'modular', 'planar', ...).is_superset(properties):
>     raise ValueError("invalid property")
> }}}

But then we can not raise exception saying _what_ property was invalid.

> We can easily add parameters and moderately easily change to an `*args` attribute if necessary.

True. We could add something like `extra` parameter if needed for some special type of lattices.

> > > Also, I feel that `p = 0` should be acceptable and return a chain, as it is the unique lattice with the minimal number of cover relations.
> > 
> > Actually it kind of works now, but generates a random semilattice with minimal number of covers, i.e. a tree, and then adds the top element. Would be strange if `p=0` would always give the chain and `p=0.001` would give a tree (+top).
> 
> The minimal number of covers has to be a chain

Yes for lattices. Not for semilattices.

But after all, I don't know if we really have to think about semilattices. I did the code such way that internal function generates a semilattice, which can be used directly as a meet-semilattice, inversed as a join-semilattice or after adding one element as a lattice.

> > > Is this model of random lattices known (i.e., is there a literature reference for it)?
> > 
> > I found only https://www.emis.de/journals/MB/125.2/mb125_2_1.pdf and the code in that paper is... Well, take a look at yourself.
> 
> Hmmm...I see your point. At least we could drop that C code in and link it easily in Sage to compare. Although it looks like it will generate a different distribution from a cursory look.

Can you copypaste and compile it from PDF? I think I tried and failed.

> > I don't know if there is even a theoretical results about "random lattice", like "What is the average width of all non-isomorphic lattices on 100 elements?" So is there anything to compare to be able to say how good or bad an algorithm is?
> 
> Well, if its not known, it might result in a paper if you can determine some theoretical results. I was asking more if there was a reference that could be added.

True. The paper http://users.cecs.anu.edu.au/~bdm/papers/posets.pdf actually refers to a result about posets: "Our results do not show this behaviour, emphasizing again that the convergence of posets to their asymptotic behaviour is quite slow."

But at least the average number of atoms equals to number of coatoms. My ad hoc code does not achieve this. I used `sqrt(random())` as a slight help to this direction.

I tested that my code generates all lattices of given (small) size eventually, and it should be theoretically clear too.


---

Comment by git created at 2016-08-30 12:50:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-08-30 12:53:42

Changing status from needs_review to needs_work.


---

Comment by jmantysalo created at 2016-08-30 12:53:42

How this looks? I think that this should still simplified, so that `RandomLattice` will contain only the parameters check and the logic to choise right function to do the job.


---

Comment by tscrim created at 2016-08-30 14:27:33

I think you should make `known_properties` into a `set` for faster checking. (Actually, to still have your desired error message, you could do `if properties.difference(known_properties):`, then pop an element off from that different for the error message.) There is a discrepancy between the doc and the code in that the doc says `p=0` is valid input, but the code will error out. Otherwise it seems okay.


---

Comment by git created at 2016-08-31 09:16:56

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2016-08-31 09:18:44

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by jmantysalo created at 2016-08-31 09:24:33

Changing status from needs_work to needs_review.


---

Comment by jmantysalo created at 2016-08-31 09:24:33

Replying to [comment:9 tscrim]:
> I think you should make `known_properties` into a `set` for faster checking. (Actually, to still have your desired error message, you could do `if properties.difference(known_properties):`, then pop an element off from that different for the error message.) There is a discrepancy between the doc and the code in that the doc says `p=0` is valid input, but the code will error out. Otherwise it seems okay.

OK, done that, even if this should not be an issue: I suppose we wont have _that_ many properties ever available.

Now if someone says `Posets.RandomLattice(30, 0, properties='dismantlable')` it will also work, and not raise an error about parameter value 'd'. (See `set('hello')`.)

I also rethinked something, but the algorithms themself have not changed. I added tests and docstrings.

Maybe a time to close this and do other additions later. Will be a nice challenge, I guess, to make for example a random lattice that is both atomic and co-atomic.


---

Comment by jmantysalo created at 2016-09-02 16:52:20

I have already thinked about adding random atomic, distributive, modular and semimodular lattices. However I think it is easier to first integrate this patch to Sage and continue after that. Then patches are of manageable size.


---

Comment by jmantysalo created at 2016-09-10 06:29:15

Just pinging. I think I did nothing very special after your comment "Otherwise it seems okay."

This would be nice to have, as this can used for testing other functions.


---

Comment by tscrim created at 2016-09-10 12:18:43

Sorry, forgot about this. Yes, LGTM now. Thanks.


---

Comment by tscrim created at 2016-09-10 12:18:43

Changing status from needs_review to positive_review.


---

Comment by jmantysalo created at 2016-09-10 12:20:36

Thanks! Hopefully this will be used to test and optimize other parts of `lattices.py`.


---

Comment by vbraun created at 2016-09-12 19:02:23

Resolution: fixed
