# Issue 11898: Unavoidable DeprecationWarnings when calling piecewise functions

Issue created by migration from Trac.

Original creator: mjo

Original creation time: 2011-11-22 03:19:23

Assignee: burcin

CC:  kcrisman

When using piecewise functions across modules, you can find yourself unable to avoid the DeprecationWarning resulting from positional arguments, e.g. f(0).

A small example:

some_library.py

```
from sage.all import *

def make_f():
    x = SR.symbol('x', domain='real')
    f = piecewise([This is the Trac macro ** that was inherited from the migration called with arguments (-1,1), x**2)](https://trac.sagemath.org/wiki/WikiMacros#-macro))
    return f
```


some_script.py

```
from some_library import *

my_f = make_f()
my_f(0)
```


There is no obvious (or un-obvious, as far as I know) way to avoid the warning here.

The output, for reference:


```
$ sage some_script.py 
some_script.py:4: DeprecationWarning: Substitution using function-call syntax and unnamed arguments is deprecated and will be removed from a future release of Sage; you can use named arguments instead, like EXPR(x=..., y=...)
  my_f(0)
```




---

Comment by kini created at 2011-11-22 04:08:15

This produces the same output in the Sage console (directly after starting it) so I doubt it has anything to do with modules or `.py` / `.sage` files in particular.

Indeed something is screwed up here, though.


---

Comment by mjo created at 2011-11-22 04:57:12

Well, in a sage prompt there's an easy workaround: write f(x) = piecewise(...) instead of just f = ...

That doesn't work outside of a prompt, though, and the preprocessor breaks some imports if you try to rename the *.py files to *.sage.


---

Comment by kini created at 2011-11-22 05:19:52

Actually that doesn't work - I get a `TypeError` with no message, which is pretty strange. I also saw this same `TypeError` when trying to coerce a `PiecewisePolynomial` into `SR` (the Symbolic Ring) so that I could write `.function(x)` inside your definition of `make_f`, which I originally thought should be the correct way to do this.


---

Comment by mjo created at 2011-11-22 05:32:13

Oh, sorry. This is how to make it work in the prompt:


```
sage: f1(x) = 2*x
sage: f = piecewise([This is the Trac macro ** that was inherited from the migration called with arguments (-1,1), f1)](https://trac.sagemath.org/wiki/WikiMacros#-macro))
```


I was planning an "easy" patch for this too, but it turns out to be harder than it looks. You can supply a variable to piecewise() to fix my simple example, but that causes other problems by turning everything into a callable expression.


---

Comment by nbruin created at 2016-03-01 16:41:19

The example in this ticket is just misuse. `piecewise` takes functions, not expressions. Oneliner solution is

```
f = piecewise([This is the Trac macro ** that was inherited from the migration called with arguments (-1,1), )](https://trac.sagemath.org/wiki/WikiMacros#-macro))
```

It's essential to be explicit about the variable name. See:

```
var('foo,bar')
f = piecewise([This is the Trac macro ** that was inherited from the migration called with arguments (-1,1), )](https://trac.sagemath.org/wiki/WikiMacros#-macro))
```

Close as invalid or resolve by updating documentation?


---

Comment by slelievre created at 2016-03-01 17:18:01

I vote to update the documentation. Maybe we also need a thematic tutorial
about piecewise-defined functions. Questions about them are quite frequent
in the various help channels.


---

Comment by kcrisman created at 2016-03-01 17:21:21

Or to use Volker's new piecewise functions, #14801.  But there are some things that no longer work with those, I guess (the oooold stuff about fourier or whatever) and there are some other roadblocks.  But probably in the long run that might be better unless we can somehow integrate piecewise.mac in Maxima, but I'm not even sure those are well-debugged.


---

Comment by mjo created at 2016-03-01 20:26:16

Replying to [comment:10 nbruin]:
> The example in this ticket is just misuse. `piecewise` takes functions, not expressions.

Ok, but the existing doctests and examples (mis)use that same format (I never knew I could/should change an expression into a function). The ones that don't, rely on the preparsing of `f(x) = ...` that isn't helpful to people using `piecewise()` in python code. What do we do with `f(x) = 1`, change it to `f = SR(1).function(x)`?

I think `f = SR(1).function(x)` is stupid, but having examples that only work when preparsed isn't great either. How about we just fix this for symbolic expressions of one variable?


```
if is_Expression(f):
    if len(f.variables()) == 1:
        f = f.function(f.variables()[0]) # We know what you meant bro.
    else:
        raise Whatever()
```


If there's a good reason not to do that, then the examples illustrating e.g. `(x**2).function(x)` should at least be prominent.


---

Comment by slelievre created at 2016-03-02 07:23:07

About `f(x) = 1` vs `f = SR(1).function(x)`, maybe we could
introduce `constant_function` and use `f = constant_function(1)`.


---

Comment by mjo created at 2022-01-08 15:02:52

This got fixed somewhere along the way:


```
sage: f = piecewise([This is the Trac macro ** that was inherited from the migration called with arguments (-1,1), SR)](https://trac.sagemath.org/wiki/WikiMacros#-macro))
sage: f(0)
1
```



---

Comment by mjo created at 2022-01-08 15:03:08

Changing status from new to needs_review.


---

Comment by slelievre created at 2022-01-08 20:32:51

Tried it in Sage 9.5.beta9, seems indeed fixed.


---

Comment by slelievre created at 2022-01-08 20:32:51

Changing status from needs_review to positive_review.


---

Comment by mkoeppe created at 2022-01-08 21:27:14

Resolution: invalid
