# Issue 12336: Optimize zero test in dict_addition.pyx

Issue created by migration from https://trac.sagemath.org/ticket/12508

Original creator: hivert

Original creation time: 2012-02-14 13:36:41

Assignee: sage-combinat

CC:  stumpc5 sage-combinat

The code currently says:

```
        a = D[iter(D).next()]
        if hasattr(a,'parent') and hasattr(a.parent(),'zero'):
            zero = a.parent().zero()
        else:
            zero = 0
    for_removal = [key for key in D if D[key] == zero]
    for key in for_removal:
        del D[key]    
```

If it's robust, using `bool(x)` that is `__nonzero__` could be faster.


---

Comment by stumpc5 created at 2012-02-14 16:42:36

did you do some tests?

Within Sage, I get

sage: D = dict( (i,i) for i in range(100000) ) 
sage: zero = 0
sage: %timeit for_removal = [key for key in D if D[key] == zero]
25 loops, best of 3: 23.2 ms per loop
sage: %timeit for_removal = [key for key in D if D[key].__nonzero__() ]
25 loops, best of 3: 36.8 ms per loop

But calling __nonzero__ in python is much slower than is cython, isn't it?


---

Comment by hivert created at 2012-02-14 19:44:48

Replying to [comment:1 stumpc5]:
> did you do some tests?

Actually not Yet... However:

```
sage: D = dict( (i,i) for i in srange(100000) )
sage: zero = 0
sage: %timeit for_removal = [key for key in D if D[key] == zero]
25 loops, best of 3: 15 ms per loop
sage: %timeit for_removal = [key for key in D if D[key].__nonzero__() ]
25 loops, best of 3: 27.5 ms per loop
sage: %timeit for_removal = [key for key in D if not D[key] ]
25 loops, best of 3: 8.78 ms per loop
```

Two remarks:

  - Using sage integer (ie `srange`) is more realistic than python
    `int`.

  - I actually meant `bool(D[key])` which calls implicitely
    `__nonzero__` in an optimized way, rather than calling explicitely it.

Of course, we still have to check how it behave in Cython.

Cheers,

Florent


---

Comment by hivert created at 2012-02-14 20:03:52

>   - I actually meant `bool(D[key])` which calls implicitely
>     `__nonzero__` in an optimized way, rather than calling explicitely it.

If you don't know it, here is what I call by optimized way:

```
sage: class bla(object):
....:      def __nonzero__(self): 
....:           print "bla.__nonzero__ called"
....:           return True
....: 
sage: b = bla()
sage: if b: print "ok"
....: 
bla.__nonzero__ called
ok
```

But:

```
sage: b.__nonzero__ = lambda self: False
sage: if b: print "ok"
....: 
bla.__nonzero__ called
ok
```

So the lookup in `b.__dict__` is bypassed (see
[special method lookup](http://docs.python.org/reference/datamodel.html#special-method-lookup-for-new-style-classes)),
which allows for much faster non zero test than calling `__nonzero__`
explicitely. I'm pretty sure Cython optimize that too.


---

Comment by hivert created at 2012-02-14 20:15:59

Changing assignee from sage-combinat to hivert.


---

Comment by hivert created at 2012-02-14 20:15:59

By the way, I didn't put you in cc because I wanted you to fix that. I thought you might be interested in those kind of optimizations. If you want to fix it, please tell me, otherwise I'll do it myself.


---

Comment by stumpc5 created at 2012-02-14 21:49:16

Replying to [comment:4 hivert]:
> By the way, I didn't put you in cc because I wanted you to fix that. I thought you might be interested in those kind of optimizations. If you want to fix it, please tell me, otherwise I'll do it myself.

I will look at the special method lookup these days, but go ahead providing a patch if you want (can we always be certain that bool( D[key] ) will indeed return what we want it to return? ).


---

Comment by hivert created at 2012-02-15 08:06:56

Replying to [comment:5 stumpc5]:
> can we always be certain that bool( D[key] ) will indeed return what we want it to return?

It's Python's specification, so it definitely should return what we want. Now the best way to be sure that it does is to add it in the generic tests for object in the category `FreeModules()`. Since now, thanks to Simon all rings conform with categories, adding a test here should catch all problems.


---

Comment by stumpc5 created at 2012-02-15 08:16:27

Replying to [comment:6 hivert]:
> Replying to [comment:5 stumpc5]:
> It's Python's specification, so it definitely should return what we want. Now the best way to be sure that it does is to add it in the generic tests for object in the category `FreeModules()`. Since now, thanks to Simon all rings conform with categories, adding a test here should catch all problems.

Things are getting forward, that's great to hear!


---

Comment by stumpc5 created at 2013-01-02 11:30:50

Replying to [comment:7 stumpc5]:
> Replying to [comment:6 hivert]:
> > Replying to [comment:5 stumpc5]:
> > It's Python's specification, so it definitely should return what we want. Now the best way to be sure that it does is to add it in the generic tests for object in the category `FreeModules()`. Since now, thanks to Simon all rings conform with categories, adding a test here should catch all problems.
> 
> Things are getting forward, that's great to hear!

I just saw this patch in my list, so I give it a ping to see if this was solved somewhere else, or if it is still to be done (most likely by you, Florent ?)...


---

Comment by chapoton created at 2018-02-23 19:56:38

Changing status from new to needs_review.


---

Comment by chapoton created at 2018-02-23 19:56:38

* `dict_addition.pyx` was deprecated in #20680 in favor of blas.sum

* there one finds `src/sage/data_structures/blas_dict.pyx:    for_removal = [key for key in result if not result[key]]`

So let us close this ticket now.


---

Comment by jdemeyer created at 2018-02-23 20:29:44

Resolution: invalid
