# Issue 30070: Refactor Components into parent & element

Issue created by migration from https://trac.sagemath.org/ticket/30307

Original creator: mkoeppe

Original creation time: 2020-08-07 01:26:06

CC:  @mjungmath egourgoulhon tscrim @honglizhaobob

Currently every `Components` object has lots of metadata attributes in addition to the actual data dictionary in `._comp`.  

If one has many different `Components` objects with the same metadata, we can reduce storage space as follows.

We create new classes `CompParent`, `CompParentWithSym`, ..., which 
store the attributes and become `UniqueRepresentation`. We make `Components` objects elements of these parents.  

Data associated with symmetries, computed currently each time for each `CompWithSym` object in methods such as `__init__`, `__add__`, `trace`, ... can then be precomputed and cached in the parent (for example using `@`cached_method in the parent class).


The parents will also have index iterator methods.

This will make the code in #30229 (subspaces of tensor with symmetries) more elegant because it no longer needs a dummy `Components` object to represent the symmetry but rather a `CompParent` object.


---

Comment by mkoeppe created at 2021-01-22 20:38:26

Help with implementing this would be very welcome!


---

Comment by @mjungmath created at 2021-01-22 23:41:18

That's a nice idea, +1!

> Data associated with symmetries, computed currently each time for each `CompWithSym` object in methods such as `__init__`, `__add__`, `trace`, ... can then be precomputed and cached in the parent (for example using `@`cached_method in the parent class).

I think it would be a good idea to cache results from `trace`, `contract`, ... as well.

The most annoying thing with this ticket will most likely be the docstring that has to be adapted...is there a good way to use search&replace?


---

Comment by @mjungmath created at 2021-01-23 13:09:10

Currently, the index generators and manipulators take (mostly) lists and can therefore not be cached. To use the caching most efficiently, I suggest we switch entirely to tuples.


---

Comment by git created at 2021-01-23 14:05:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by @mjungmath created at 2021-01-23 14:07:03

Before I go on with this ticket, could you please take a look whether this meets your rough idea?

Is anyone willing to work on the docstrings...? Perhaps there's an efficient way to do this?


---

Comment by git created at 2021-01-23 14:11:12

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-01-23 18:43:54

Replying to [comment:7 gh-mjungmath]:
> Before I go on with this ticket, could you please take a look whether this meets your rough idea?

Yes, this is going in the direction that I had in mind.

Some more of the normalization happening in `CompParentWithSym.__init__` should probably be moved to `__classcall_private__`


---

Comment by @mjungmath created at 2021-01-24 11:16:05

What would be a proper category for the parent?


---

Comment by @mjungmath created at 2021-01-24 11:49:29

Replying to [comment:9 mkoeppe]:
> Some more of the normalization happening in `CompParentWithSym.__init__` should probably be moved to `__classcall_private__`

For example?


---

Comment by mkoeppe created at 2021-01-24 18:17:45

For example the order of the component indices does not matter


---

Comment by egourgoulhon created at 2021-01-24 18:50:40

Replying to [comment:10 gh-mjungmath]:
> What would be a proper category for the parent?

Take the following with a grain of salt (this is just a rough/naive thought): It seems to me that the current proposal is a kind of abuse of Sage's parent/element scheme, for `CompParent` does not correspond to a "genuine" mathematical object (hence maybe your question...). In particular, it does not know about the ring on which the components are based. I do not deny that a reorganization of `Components` would be a good thing, but maybe at the class level, not at the parent/element level, the issue here being mostly the storage of metadata.


---

Comment by mkoeppe created at 2021-01-24 19:15:06

Just use the category of sets. I don't think this is an abuse.

Think of an instance of `CompParent` as the set of all possible `Components` instances that have the specified symmetry.

By using the parent/element framework, you will get coercion for free - so elements with a coarser symmetry will be `in` a finer parent.


---

Comment by @mjungmath created at 2021-01-24 19:23:43

Replying to [comment:12 mkoeppe]:
> For example the order of the component indices does not matter
Right!

Replying to [comment:14 mkoeppe]:
> Just use the category of sets. I don't think this is an abuse.
> 
> Think of an instance of `CompParent` as the set of all possible `Components` instances that have the specified symmetry.
> 
> By using the parent/element framework, you will get coercion for free - so elements with a coarser symmetry will be `in` a finer parent.

For me, it doesn't feel like an abuse either. Besides, I am sure you can make that notion of compontents mathematically rigorous. But I am not sure whether this becomes a well-defined set then... What about the category of objects?


---

Comment by @mjungmath created at 2021-01-24 20:37:12

Alright, I make progress here. I changed only the backend such that most doctests should still pass, and the module can be used exactly as before. The elementary examples already passed.

I'll push my branch tomorrow.

I am looking forward to some benchmarks as soon as this branch is ready. :)


---

Comment by tscrim created at 2021-01-24 23:22:32

I can understand why this might seem like an abuse because it is a set of objects, but by extension, all of the combinatorial objects would be an abuse as well. So even though we will not be putting an extra mathematical structure on the components, this is still a valid use of the framework because there is a set of objects (the parent) and the individual objects (the elements).

Something to consider, however, is a potential speed penalty for the extra levels of initialization. This can be somewhat mitigated by using Cython, but performance regression testing is warranted here.


---

Comment by @mjungmath created at 2021-01-25 02:25:08

Replying to [comment:17 tscrim]:
> This can be somewhat mitigated by using Cython, but performance regression testing is warranted here.

How so?


---

Comment by tscrim created at 2021-01-25 02:58:30

Replying to [comment:18 gh-mjungmath]:
> Replying to [comment:17 tscrim]:
> > This can be somewhat mitigated by using Cython, but performance regression testing is warranted here.
> 
> How so?

Because Cython is faster than Python, including potential benefits from direct C-level function calls.


---

Comment by @mjungmath created at 2021-01-25 07:45:03

Yes, that's clear. I meant, how to implement? Make `CompParent` and `Components` both simply extension types?

Would `cdpef`ing the symmetry related functions cause a speedup btw?

Since this involves only integers, i.e. struct types, one could even try to Cythonize these completely.


---

Comment by git created at 2021-01-25 13:50:10

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by egourgoulhon created at 2021-01-25 13:52:12

Replying to [comment:17 tscrim]:
> I can understand why this might seem like an abuse because it is a set of objects, but by extension, all of the combinatorial objects would be an abuse as well. So even though we will not be putting an extra mathematical structure on the components, this is still a valid use of the framework because there is a set of objects (the parent) and the individual objects (the elements).
> 

Thank you Matthias, Michael and Travis for your replies. I'm convinced now that parent/element is a good approach here (I was bothered by the lack of algebraic structure of the parent), especially for symmetry-based coercions. 


> Something to consider, however, is a potential speed penalty for the extra levels of initialization. This can be somewhat mitigated by using Cython, but performance regression testing is warranted here.

Certainly!
----
New commits:


---

Comment by git created at 2021-01-25 13:52:31

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by egourgoulhon created at 2021-01-25 13:54:04

A possibly relevant ticket, about enhancing symmetries of components beyond the currently implemented ones: #28813
----
New commits:


---

Comment by @mjungmath created at 2021-01-25 13:57:13

I am sorry for the mess. However, this is my rough approach. I separated elements and parents, and established factory methods to recover the old behavior (backwards compatibility and less work on the docstrings).

I am open to suggestions how to separate the symmetry code apart. Some symmetry treatments are coupled to the element for optimization (e.g. `antisymmetrize` to determine zero more quickly).

This code is too big for me to do it alone. I'd appreciate some help here. I hope my first approach is of some use for you.


---

Comment by egourgoulhon created at 2021-01-25 14:03:30

A concern about cythonizing the whole thing: the Python debugger cannot be used in Cython parts of codes, which is a pity, IMHO. So if Cython does not bring any significant performance improvement, we are loosing more than we gain.


---

Comment by egourgoulhon created at 2021-01-25 14:08:56

Also shouldn't one perform a single task in this ticket, namely refactor `Components` into parent/element, and leave cythonization to another ticket?


---

Comment by @mjungmath created at 2021-01-25 15:14:10

Replying to [comment:27 egourgoulhon]:
> Also shouldn't one perform a single task in this ticket, namely refactor `Components` into parent/element, and leave cythonization to another ticket?

That makes sense. In the next step one could try to implement #28813, and perhaps even use Cython to do so.

Besides, I just learned that one could increase the init speed with Python 3 using `__slots__`. Maybe that's what we should do for now.

Still, I don't know how we should separate the symmetry code properly. My idea so far was to let the parent do the symmetrizing work and return the parent with the corresponding symmetries, and construct an element from it, then assign the components. But this doesn't work so well when the element itself such as in `antisymmetrize` is taken into account.

Alternatively, it would be nice do define maps (morphisms) between parents doing that work and cache those morphisms. But that is something I don't know how to do in a nice and proper way. For example, if one antisymmetrizes in the variables where the components are already symmetric, it's simply the "zero morphism".


---

Comment by @mjungmath created at 2021-01-25 15:21:16

Nevertheless, I think that the rough refactoring into `comp_element` and `comp_parent` (and `comp` to recover the old behavior) is already a good way to go.


---

Comment by mkoeppe created at 2021-01-25 18:01:33

Replying to [comment:24 egourgoulhon]:
> A possibly relevant ticket, about enhancing symmetries of components beyond the currently implemented ones: #28813

I agree that it would be a good idea to keep possible generalizations in mind while doing this refactoring. (Also #30276)


---

Comment by @mjungmath created at 2021-01-25 18:15:54

Definitely! So, do we have a roadmap?


---

Comment by mkoeppe created at 2021-01-25 19:39:00

This is looking nice already, and I agree that this ticket should do a Python implementation only. I would hope that there are already performance gains by caching.


---

Comment by @mjungmath created at 2021-01-25 20:26:53

`@`Mattihas: What do you say about the morphism idea in comment:27?

`@`Travis: What about using `__slots__` in this ticket instead of Cythonizing?


---

Comment by mkoeppe created at 2021-01-25 20:36:06

Regrading the morphisms: These are exactly the `reduce`, `retract`, `lift` maps that we discussed in #30229 - just on the level of components rather than modules.


---

Comment by @mjungmath created at 2021-01-25 21:03:10

Replying to [comment:34 mkoeppe]:
> Regrading the morphisms: These are exactly the `reduce`, `retract`, `lift` maps that we discussed in #30229 - just on the level of components rather than modules.

Mh...but I suggest more than 3 morphisms. I don't know what you mean, sorry.

Can I take it as a "yes, what a wonderful idea!"? :P


---

Comment by mkoeppe created at 2021-01-25 23:10:26

Yes, there are many maps:
- For a `CompParent` with a coarser symmetry, there is an injection (`lift` map) to any `CompParent` with a finer symmetry.
etc.
(And yes, it's a wonderful idea.)


---

Comment by tscrim created at 2021-01-26 02:24:52

I don't expect `__slots__` to provide much benefit to speed as from what I am reading, it is more useful for memory usage. The main thing is to turn the file into a `.pyx` file with a `.pxd` header for declarations. The element class should be a `cpdef` with the main parameters declared and given explicit typing. These are relatively easy things to do provided you don't have multiple inheritance in the element classes (the parent can remain normal Python classes in a pyx file).

IMO, you also don't loose too much with converting to Cython with debugging because you still get a lot with error tracebacks. The biggest thing I have found lost is the ease of profiling to find bottlenecks. However, testing with practical examples can get around that a bit, and there is a tool to profile Cython code IIRC. So I generally see this as a smaller trade-off.


---

Comment by @mjungmath created at 2021-01-26 06:01:19

Well, `__slots__` makes initializations faster because attribute access is significantly faster (up to 30%). Memory is just an additional benefit.

Even if we turn `Components` into a `cpdef`, I think we still gain a good performance boost with `__slots__` which can sum up quickly with recurrent use of `_comp`.


---

Comment by @mjungmath created at 2021-01-26 06:03:36

To use morphisms, we need a new category (say `Category of collections of abstract components`) and a homset, right?


---

Comment by @mjungmath created at 2021-01-26 06:11:07

Btw, I am not convinced that `cpdef`ing the class makes initializations faster, I'd bet on the contrary. When I understand it correctly, `cpdef` creates two classes in the background, an extension type and a usual Python class. Since we don't expect a benefit during the lifetime of an instance, it should even slowdown things. But maybe I just got things wrong here.


---

Comment by tscrim created at 2021-01-28 08:21:19

What are you talking about `cpdef`ing a class? You only do that to functions AFAIK. I am still not 100% convinced by the `__slots__` approach, more so because it makes it (slightly) harder to switch from a Python class to an extension class IIRC.

I don't see why we need a new category. We don't need to be so heavy-handed with the approach. Having the homset be in the category of (enumerated?) sets is sufficient IMO.


---

Comment by tscrim created at 2021-01-28 08:22:15

The main benefit with Cython and extension classes is being able to strongly type things to have as many C level function calls and code as possible.


---

Comment by @mjungmath created at 2021-01-28 09:53:55

Replying to [comment:42 tscrim]:
> I don't see why we need a new category. We don't need to be so heavy-handed with the approach. Having the homset be in the category of (enumerated?) sets is sufficient IMO.

Mathematically, I am still not convinced that our parents constitute sets. Their elements run over all possible rings (and "frames"), which is not a set either.


---

Comment by @mjungmath created at 2021-01-28 10:00:23

Replying to [comment:43 tscrim]:
> The main benefit with Cython and extension classes is being able to strongly type things to have as many C level function calls and code as possible.

Indeed. That needs a thorough modification of the current code. The indices checks use mostly lists and Python sets. The components are stored as dictionaries which cannot be strongly typed. I agree, that should eventually be done, however I propose that's something for another ticket.


---

Comment by @mjungmath created at 2021-01-28 11:32:16

For now, we can use `__slots__` for a slight speedup and remove it again when we Cythonize. That's what I meant.


---

Comment by tscrim created at 2021-01-28 23:30:49

I don't really like this partial measure. I wouldn't do it and just keep it pure Python until you actually decide to make it Cython.

Why is the ring associated with the element and not the parent? In general, why is all of these attributes copied from the parent? Is the extra level of indirection that slow? You can just call `self._parent` in the Cython code.

Because of how your current implementation is done, you are not going to benefit from coercions. Nor do you seem to be using anything in a category. Thus, I would actually weaken things and not use Sage's Parent/Element classes. Instead, I would just mimic them. Perhaps I am misunderstanding how you plan to apply these.

There is still a lot of you things you can do to tell Cython to make things be strongly typed even if they are extracted from lists/sets/dicts, such as type-casting.


---

Comment by @mjungmath created at 2021-01-29 08:02:11

Please don't look at the details yet. The code is far away from being finished. Coercions come, attributes will be removed (it's just to make parts of the code already debuggable).

Why has the parent no ring? Because the symmetries and indices simply do not depend on it. On the level of indices and symmetries we have: different ring -> same data -> same instance -> more effective storage.


---

Comment by tscrim created at 2021-01-29 08:20:04

Replying to [comment:48 gh-mjungmath]:
> Why has the parent no ring? Because the symmetries and indices simply do not depend on it. On the level of indices and symmetries we have: different ring -> same data -> same instance -> more effective storage. 

You're passing around a pointer to the ring in a lot of the elements, which is storage. Since I doubt the ring will change much, I don't think you gain much. Plus you have to pass more around, which makes maintenance harder and can come with performance impacts.


---

Comment by egourgoulhon created at 2021-01-29 09:54:02

Replying to [comment:44 gh-mjungmath]:
> 
> Mathematically, I am still not convinced that our parents constitute sets. Their elements run over all possible rings (and "frames"), which is not a set either.

I've also the feeling that this kind of parents cannot be sets in the meaning of standard set theory.


---

Comment by @mjungmath created at 2021-01-30 09:57:15

Alright, probably you're right, Travis (as always). :P

But I'm still convinced that `__slots__` is a good thing for now. It will take a while until we have Cythonized everything.

Even if we delegate the ring to the parent, they are still no sets. The "frame" is still an object in the category of finite sets (with length `n`).


---

Comment by tscrim created at 2021-02-01 02:52:00

Replying to [comment:52 gh-mjungmath]:
> But I'm still convinced that `__slots__` is a good thing for now. It will take a while until we have Cythonized everything.

I am not, but I don't have the same stake in the code as you. A little experimentation is not a bad thing either.


---

Comment by @mjungmath created at 2021-02-01 05:36:27

Mh. Matthias, Eric, what are your opinions on that `__slot__` matter?


---

Comment by mkoeppe created at 2021-02-01 05:41:38

It's a further optimization and I think it should be tried in a follow-up, not this ticket


---

Comment by egourgoulhon created at 2021-02-01 08:21:19

Replying to [comment:55 mkoeppe]:
> It's a further optimization and I think it should be tried in a follow-up, not this ticket

+1


---

Comment by mkoeppe created at 2021-02-13 20:51:01

Setting new milestone based on a cursory review of ticket status, priority, and last modification date.


---

Comment by @mjungmath created at 2021-02-14 17:30:26

Alright, let's do that optimization in a follow-up.

However, I am still concerned about `CompParent` being a proper class, which means that the collection of all those parents is no class at all and hence no category in terms of strict category theory.

Any ideas how to circumvent this matter?


---

Comment by tscrim created at 2021-02-15 00:01:56

Replying to [comment:58 gh-mjungmath]:
> However, I am still concerned about `CompParent` being a proper class, which means that the collection of all those parents is no class at all and hence no category in terms of strict category theory.
> 
> Any ideas how to circumvent this matter?

Stop worrying about it. We can have slight abuses in Sage (see `RR` being a field), and this is also something that is a very technical point that is occurring below what most users will see.


---

Comment by @mjungmath created at 2021-03-25 15:53:07

This task seems nothing that can be done in just one day. I would appreciate a little help and direction here. Especially w.r.t. #30276 and #28813. It would be a shame to put a lot of work in here if we had to refactor it again to achieve #30276 and #28813.


---

Comment by mkoeppe created at 2021-03-25 16:05:18

I'll return to it after the 9.3 release


---

Comment by git created at 2021-06-15 17:44:13

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:


---

Comment by mkoeppe created at 2021-06-15 18:14:42

I have rebased the branch on top of the current develop.

To keep the ticket more focused, I have undone the Cythonization.


---

Comment by mkoeppe created at 2021-06-15 18:16:42

I am going to move `start_index` from the parents to the elements because the symmetries have nothing to do with it.


---

Comment by mkoeppe created at 2021-06-15 18:52:32

Same also for `_dim`. 

Method `index_generator` will take a list of range objects - this will provide a generalization for the case of tensors between modules of differing ranks


---

Comment by git created at 2021-06-15 19:57:42

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-15 20:36:23

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-15 23:32:57

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-16 01:39:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-16 02:35:05

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-06-16 02:35:35

Started to prepare the classes for multiple backend implementations.


---

Comment by git created at 2021-06-16 03:16:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-16 03:55:39

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-17 19:03:30

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-17 19:59:54

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-17 21:15:36

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-06-17 22:57:53

I will need to revise the design a bit to accommodate different backends.

A `CompParent` will become a free module over a fixed ring.  

Fixing the ring is necessary because numerical backends (for example for NumPy's `ndarray`) can only work with base ring `RDF`; whereas the symbolic backends (such as the existing dictionary-based implementation) is for `SR` and exact rings.


---

Comment by git created at 2021-06-17 23:20:34

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-06-17 23:23:40

I've arrived at a point where it just remains to teach the coercion system about coercions/pushouts to combine operands with differing symmetries

```
File "src/sage/tensor/modules/comp_element_dict.py", line 914, in sage.tensor.modules.comp_element_dict.ComponentsWithSym_dict
Failed example:
    s = a + b ; s
Exception raised:
    Traceback (most recent call last):
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-gcc11/src/sage/doctest/forker.py", line 714, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-gcc11/src/sage/doctest/forker.py", line 1133, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.tensor.modules.comp_element_dict.ComponentsWithSym_dict[27]>", line 1, in <module>
        s = a + b ; s
      File "sage/structure/element.pyx", line 1232, in sage.structure.element.Element.__add__
        return coercion_model.bin_op(left, right, add)
      File "sage/structure/coerce.pyx", line 1248, in sage.structure.coerce.CoercionModel.bin_op
        raise bin_op_exception(op, x, y)
    TypeError: unsupported operand parent(s) for +: 'Parent of 2-index components over Rational Field' and 'Parent of Fully symmetric 2-index components over Rational Field'
```



---

Comment by git created at 2021-06-18 00:18:02

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-18 01:24:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-18 04:12:04

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-18 04:42:48

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by git created at 2021-06-18 05:55:00

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-06-18 05:59:05

`sage.tensor.modules` passes all tests except for `_test_not_implemented_methods` (to be fixed by #29619)

There are still various errors in `sage.manifolds`. 
For example, in `src/sage/manifolds/differentiable/multivectorfield.py`:

```
sage -t --random-seed=0 src/sage/manifolds/differentiable/multivectorfield.py
**********************************************************************
File "src/sage/manifolds/differentiable/multivectorfield.py", line 117, in sage.manifolds.differentiable.multivectorfield.MultivectorField
Failed example:
    a.display(eU)
Expected:
    a = (x*y^2 + 2*x) d/dx/\d/dy
Got:
    a = (x*y^2 + 2*x) d/dx*d/dy + (-x*y^2 - 2*x) d/dy*d/dx
```


Help in spotting where these errors are coming from would be welcome


---

Comment by @mjungmath created at 2021-06-19 13:55:22

For some reason, the `restrict` method doesn't work properly:



```
sage: M = Manifold(2, 'M')
sage: U = M.open_subset('U') ; V = M.open_subset('V')
sage: M.declare_union(U,V)   # M is the union of U and V
sage: c_xy.<x,y> = U.chart() ; c_uv.<u,v> = V.chart()
sage: xy_to_uv = c_xy.transition_map(c_uv, (x+y, x-y),
....:                         intersection_name='W',
....:                         restrictions1= x>0, restrictions2= u+v>0)
sage: uv_to_xy = xy_to_uv.inverse()
sage: W = U.intersection(V)
sage: eU = c_xy.frame() ; eV = c_uv.frame()
sage: a = M.multivector_field(2, name='a')
sage: a[eU,0,1] = x*y^2 + 2*x
sage: a.add_comp_by_continuation(eV, W, c_uv)
sage: a.retrict(U)
Tensor field a of type (2,0) on the Open subset U of the 2-dimensional differentiable manifold M
```


But it should return


```
2-vector field a on the Open subset U of the 2-dimensional differentiable manifold M
```



---

Comment by @mjungmath created at 2021-06-20 21:18:02

Okay, I spotted the error. It's caused by these lines:


```diff
+        self._sym = tuple(self._sym)
+        self._antisym = tuple(self._antisym)
```


When a tensor field is displayed, it must be restricted to a parallelizable subset first. If that restriction does not exists, it's constructed from scratch. This is done by the `tensor` method of the corresponding vector field module of this subset. In particular, the parameters `sym` and `antisym` are passed to this method. In our particular case the code will be executed until


```python
        elif tensor_type[0] > 1 and tensor_type[1] == 0 and antisym:
            if isinstance(antisym[0], (int, Integer)):
                # a single antisymmetry is provided as a tuple or a
                # range object; it is converted to a 1-item list:
                antisym = [tuple(antisym)]
            if isinstance(antisym, list):
                antisym0 = antisym[0]
            else:
                antisym0 = antisym
            if len(antisym0) == tensor_type[0]:
                return self.alternating_contravariant_tensor(
                                              tensor_type[0], name=name,
                                              latex_name=latex_name)
```


With the above change, however, `len(antisym0)` returns `1`, but it should be `2` because the code turns `[(0, 1)]` into `((0,1),)`. So, this case will be ignored and a tensor without symmetries will be created instead.


---

Comment by @mjungmath created at 2021-06-20 21:21:08

One way to solve this could be to adapt the preprocessing of `antisym0` and `sym0` in the `tensor` method, assuming `antisym` and `sym` is a tuple.


---

Comment by mkoeppe created at 2021-06-20 22:44:44

Thanks for spotting this!


---

Comment by git created at 2021-06-20 23:10:22

Branch pushed to git repo; I updated commit sha1. New commits:


---

Comment by mkoeppe created at 2021-06-20 23:12:24

With these changes, only failures that look like this remain:

```
sage -t --random-seed=0 src/sage/manifolds/differentiable/examples/sphere.py
**********************************************************************
File "src/sage/manifolds/differentiable/examples/sphere.py", line 56, in sage.manifolds.differentiable.examples.sphere
Failed example:
    h.display()
Exception raised:
    Traceback (most recent call last):
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-gcc11/src/sage/doctest/forker.py", line 714, in _run
        self.compile_and_execute(example, compiler, test.globs)
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-gcc11/src/sage/doctest/forker.py", line 1133, in compile_and_execute
        exec(compiled, globs)
      File "<doctest sage.manifolds.differentiable.examples.sphere[5]>", line 1, in <module>
        h.display()
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-gcc11/src/sage/manifolds/differentiable/tensorfield.py", line 1852, in display
        return rst.display(frame, chart)
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-gcc11/src/sage/tensor/modules/free_module_tensor.py", line 723, in display
        coef = comp[ind_arg]
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-gcc11/src/sage/tensor/modules/comp_element_dict.py", line 2533, in __getitem__
        return self._output_formatter(self._comp[ind])
      File "/Users/mkoeppe/s/sage/sage-rebasing/worktree-gcc11/src/sage/manifolds/scalarfield.py", line 1786, in coord_function
        raise ValueError("no starting chart could be found to " +
    ValueError: no starting chart could be found to compute the expression in the Chart (E^3, (x, y, z))
```



---

Comment by mkoeppe created at 2021-06-20 23:39:42

This is likely not the final form of this ticket.

The goals of this ticket -- one-time precomputation of data related to the symmetries -- have not been fully achieved yet because the parent class is now a module over a base ring. This is fine for numerical tensors that are all over the same ring (`QQ` or `RDF`) but for the symbolic tensors that are used in `sage.manifolds`, there are many base rings, so the symmetries will be recomputed for each of them.

But for now it was more important to me to have separate parents for separate base rings, as this will allow us to dispatch to different implementation backends (= element classes) - as part of `@`gh-honglizhaobob's project (#31991).

My solution for allowing more shared precomputation would be to introduce another class, similar to https://docs.sympy.org/latest/modules/tensor/tensor.html#sympy.tensor.tensor.TensorSymmetry, which only captures the symmetry group (with action).

Apart from this, there is still some code that should be pushed from element to parent, for example the symmetries from tensor contraction. 

And there are branches in the code that can no longer be reached because the coercion system, via `CompParent._element_constructor_`, now guarantees that the inputs of single-underscore methods such as `_add_` have the same symmetry already.

Also, I have not done any time measurements.


---

Comment by mkoeppe created at 2021-06-22 07:01:17

Further refactoring will go through #32029 (Action of a sympy `TensorSymmetry`)


---

Comment by @mjungmath created at 2021-06-27 11:17:05

Looks good so far!

What about the idea with the morphisms in comment:28?


---

Comment by mkoeppe created at 2021-06-27 17:45:48

Replying to [comment:101 gh-mjungmath]:
> What about the idea with the morphisms in comment:28?

The next step into this direction should be to fix/complete the existing code for coercions.

```
sage: cp = CompParentWithSym(QQ, 4, sym=((1, 2), (3, 4)))
sage: cp2 = CompParentWithSym(QQ, 4, sym=((1, 2, 3, 4)))
sage: cp.coerce_map_from(cp2)   # returns None, should return injection to cp
```

Help with this is welcome!


---

Comment by mkoeppe created at 2022-09-06 00:15:57

Restarting this effort with a smaller step in #34497.
