# Issue 10950: The hash function for matrices suffers from many collisions

archive/issues_010871.json:
```json
{
    "assignees": [
        "https://github.com/nthiery"
    ],
    "body": "<div id=\"comment:0\"></div>\n\nThe current hash function for generic dense matrices suffers from hard collisions with permutation matrices. For example: all permutation matrices of size 4 have hash 0!\n\n```\n    sage: def mat(p): m = p.to_matrix(); m.set_immutable(); return m\n    sage: [ hash(mat(p)) for p in Permutations(4) ]\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n```\n\nI stumbled on this when profiling some code using Weyl groups that\nheavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices.\n\nCheers,\n\t\t\t\tNicolas\n\n\nAfter applying this branch:\n\n```\nsage: def hashmat(p): m = p.to_matrix(); m.set_immutable(); return hash(m)\nsage: len(set(hashmat(p) for p in Permutations(1)))\n1\nsage: len(set(hashmat(p) for p in Permutations(2)))\n2\nsage: len(set(hashmat(p) for p in Permutations(3)))\n6\nsage: len(set(hashmat(p) for p in Permutations(4)))\n24\nsage: len(set(hashmat(p) for p in Permutations(5)))\n120\nsage: len(set(hashmat(p) for p in Permutations(6)))\n720\nsage: len(set(hashmat(p) for p in Permutations(7)))\n5040\nsage: len(set(hashmat(p) for p in Permutations(8)))\n40320\n```\n\nAs extra bonus, this branch ensures that scalar matrices have the same hash as the scalar. This means one extra case where `A == B` implies `hash(A) == hash(B)`.\n\n\n\nDepends on #24090\n\nCC:  @sagetrac-sage-combinat\n\nComponent: **linear algebra**\n\nKeywords: **Weyl groups, permutation matrices, hash**\n\nAuthor: **Jeroen Demeyer**\n\nBranch: **[`da5c1ff`](https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8)**\n\nReviewer: **Travis Scrimshaw, Vincent Delecroix**\n\n_Issue created by migration from https://trac.sagemath.org/ticket/10950_\n\n",
    "closed_at": "2017-10-30T07:41:31Z",
    "created_at": "2011-03-16T18:02:58Z",
    "labels": [
        "https://github.com/sagemath/sage/labels/c%3A%20linear%20algebra",
        "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
        "https://github.com/sagemath/sage/labels/bug"
    ],
    "milestone": "https://github.com/sagemath/sage/milestones/sage-8.1",
    "reactions": [],
    "repository": "https://github.com/sagemath/sage",
    "title": "The hash function for matrices suffers from many collisions",
    "type": "issue",
    "updated_at": "2017-10-30T16:35:56Z",
    "url": "https://github.com/sagemath/sage/issues/10950",
    "user": "https://github.com/nthiery"
}
```
<div id="comment:0"></div>

The current hash function for generic dense matrices suffers from hard collisions with permutation matrices. For example: all permutation matrices of size 4 have hash 0!

```
    sage: def mat(p): m = p.to_matrix(); m.set_immutable(); return m
    sage: [ hash(mat(p)) for p in Permutations(4) ]
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

I stumbled on this when profiling some code using Weyl groups that
heavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices.

Cheers,
				Nicolas


After applying this branch:

```
sage: def hashmat(p): m = p.to_matrix(); m.set_immutable(); return hash(m)
sage: len(set(hashmat(p) for p in Permutations(1)))
1
sage: len(set(hashmat(p) for p in Permutations(2)))
2
sage: len(set(hashmat(p) for p in Permutations(3)))
6
sage: len(set(hashmat(p) for p in Permutations(4)))
24
sage: len(set(hashmat(p) for p in Permutations(5)))
120
sage: len(set(hashmat(p) for p in Permutations(6)))
720
sage: len(set(hashmat(p) for p in Permutations(7)))
5040
sage: len(set(hashmat(p) for p in Permutations(8)))
40320
```

As extra bonus, this branch ensures that scalar matrices have the same hash as the scalar. This means one extra case where `A == B` implies `hash(A) == hash(B)`.



Depends on #24090

CC:  @sagetrac-sage-combinat

Component: **linear algebra**

Keywords: **Weyl groups, permutation matrices, hash**

Author: **Jeroen Demeyer**

Branch: **[`da5c1ff`](https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8)**

Reviewer: **Travis Scrimshaw, Vincent Delecroix**

_Issue created by migration from https://trac.sagemath.org/ticket/10950_





---

archive/issue_events_143730.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2011-03-16T18:02:58Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20linear%20algebra",
    "label_color": "0000ff",
    "label_name": "c: linear algebra",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143730"
}
```



---

archive/issue_events_143731.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2011-03-16T18:02:58Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "label": "https://github.com/sagemath/sage/labels/p%3A%20major%20/%203",
    "label_color": "ffbb00",
    "label_name": "p: major / 3",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143731"
}
```



---

archive/issue_events_143732.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2011-03-16T18:02:58Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "label": "https://github.com/sagemath/sage/labels/bug",
    "label_color": "d73a4a",
    "label_name": "bug",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143732"
}
```



---

archive/issue_events_143733.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2011-03-16T18:02:58Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20group%20theory",
    "label_color": "0000ff",
    "label_name": "c: group theory",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143733"
}
```



---

archive/issue_events_143734.json:
```json
{
    "actor": "https://github.com/jasongrout",
    "created_at": "2011-03-16T18:02:58Z",
    "event": "assigned",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "subject": "https://github.com/nthiery",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143734"
}
```



---

archive/issue_events_143735.json:
```json
{
    "actor": "https://github.com/williamstein",
    "created_at": "2011-03-16T18:02:58Z",
    "event": "assigned",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "subject": "https://github.com/nthiery",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143735"
}
```



---

archive/issue_comments_106402.json:
```json
{
    "body": "Attachment: **[trac_10950-hash_matrices-nt.patch.gz](https://github.com/sagemath/sage/files/ticket10950/trac_10950-hash_matrices-nt.patch.gz)**",
    "created_at": "2011-03-16T18:07:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106402",
    "user": "https://github.com/nthiery"
}
```

Attachment: **[trac_10950-hash_matrices-nt.patch.gz](https://github.com/sagemath/sage/files/ticket10950/trac_10950-hash_matrices-nt.patch.gz)**



---

archive/issue_comments_106403.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -1,6 +1,4 @@\n-The current hash function for generic dense matrices suffers from hard\n-collisions with permutation matrices. For example: all permutation\n-matrices of size 4 have hash 0!\n+The current hash function for generic dense matrices suffers from hard collisions with permutation matrices. For example: all permutation matrices of size 4 have hash 0!\n \n ```\n     sage: def mat(p): m = p.to_matrix(); m.set_immutable(); return m\n@@ -30,11 +28,7 @@\n ```\n \n I stumbled on this when profiling some code using Weyl groups that\n-heavily used caching (the hash of a weyl group element is the hash of\n-the underlying matrix). I gained a speed factor of 10x by just\n-tweaking the hash of matrices as in the attached patch. Now, I have no\n-idea if in general that would be a good hash for matrices, so please\n-some expert write an appropriate patch.\n+heavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices as in the attached patch. Now, I have no idea if in general that would be a good hash for matrices, so please some expert write an appropriate patch.\n \n Cheers,\n \t\t\t\tNicolas\n``````\n",
    "created_at": "2011-03-16T18:08:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106403",
    "user": "https://github.com/nthiery"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -1,6 +1,4 @@
-The current hash function for generic dense matrices suffers from hard
-collisions with permutation matrices. For example: all permutation
-matrices of size 4 have hash 0!
+The current hash function for generic dense matrices suffers from hard collisions with permutation matrices. For example: all permutation matrices of size 4 have hash 0!
 
 ```
     sage: def mat(p): m = p.to_matrix(); m.set_immutable(); return m
@@ -30,11 +28,7 @@
 ```
 
 I stumbled on this when profiling some code using Weyl groups that
-heavily used caching (the hash of a weyl group element is the hash of
-the underlying matrix). I gained a speed factor of 10x by just
-tweaking the hash of matrices as in the attached patch. Now, I have no
-idea if in general that would be a good hash for matrices, so please
-some expert write an appropriate patch.
+heavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices as in the attached patch. Now, I have no idea if in general that would be a good hash for matrices, so please some expert write an appropriate patch.
 
 Cheers,
 				Nicolas
``````




---

archive/issue_events_143736.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2011-03-16T18:08:08Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "title_is": "The Hash function for matrices suffers from many collisions with permutation matrices",
    "title_was": "The Hash function for matrices has many collisions with permutation matrices:",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143736"
}
```



---

archive/issue_events_143737.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2011-03-16T18:08:22Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "title_is": "The hash function for matrices suffers from many collisions with permutation matrices",
    "title_was": "The Hash function for matrices suffers from many collisions with permutation matrices",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143737"
}
```



---

archive/issue_comments_106404.json:
```json
{
    "body": "<div id=\"comment:3\" align=\"right\">comment:3</div>\n\nNote that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.",
    "created_at": "2011-03-16T20:20:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106404",
    "user": "https://github.com/jhpalmieri"
}
```

<div id="comment:3" align="right">comment:3</div>

Note that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.



---

archive/issue_comments_106405.json:
```json
{
    "body": "<div id=\"comment:4\" align=\"right\">comment:4</div>\n\nReplying to [@jhpalmieri](#comment%3A3):\n> Note that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.\n\nOops. I changed my examples at the last minute, thinking that permutation matrices would feel less exotic than Weyl groups, but I forgot to actually check that my patch fixed the problem for those. Thanks for pointing this out!",
    "created_at": "2011-03-16T22:02:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106405",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:4" align="right">comment:4</div>

Replying to [@jhpalmieri](#comment%3A3):
> Note that in `m = p.to_matrix()`, the matrix m is sparse, not dense (as far as I can tell), so you'll need to patch both matrix_dense.pyx and matrix_sparse.pyx.

Oops. I changed my examples at the last minute, thinking that permutation matrices would feel less exotic than Weyl groups, but I forgot to actually check that my patch fixed the problem for those. Thanks for pointing this out!



---

archive/issue_comments_106406.json:
```json
{
    "body": "Changed keywords from **Weyl groups** to **Weyl groups, permutation matrices, hash**",
    "created_at": "2011-03-16T22:02:10Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106406",
    "user": "https://github.com/nthiery"
}
```

Changed keywords from **Weyl groups** to **Weyl groups, permutation matrices, hash**



---

archive/issue_events_143738.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2011-03-16T22:02:10Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "label": "https://github.com/sagemath/sage/labels/c%3A%20group%20theory",
    "label_color": "0000ff",
    "label_name": "c: group theory",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143738"
}
```



---

archive/issue_comments_106407.json:
```json
{
    "body": "<div id=\"comment:5\" align=\"right\">comment:5</div>\n\nOops again ... Please ignore the second attachment; it's a duplicate of the first. Anyone with power: feel free to delete",
    "created_at": "2011-03-17T08:12:47Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106407",
    "user": "https://github.com/nthiery"
}
```

<div id="comment:5" align="right">comment:5</div>

Oops again ... Please ignore the second attachment; it's a duplicate of the first. Anyone with power: feel free to delete



---

archive/issue_events_143739.json:
```json
{
    "actor": "https://github.com/jasongrout",
    "created_at": "2011-03-17T08:12:47Z",
    "event": "unassigned",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "subject": "https://github.com/nthiery",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143739"
}
```



---

archive/issue_events_143740.json:
```json
{
    "actor": "https://github.com/williamstein",
    "created_at": "2011-03-17T08:12:47Z",
    "event": "unassigned",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "subject": "https://github.com/nthiery",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143740"
}
```



---

archive/issue_events_143741.json:
```json
{
    "actor": "https://github.com/nthiery",
    "created_at": "2011-03-17T08:12:47Z",
    "event": "assigned",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "subject": "https://github.com/nthiery",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143741"
}
```



---

archive/issue_comments_106408.json:
```json
{
    "body": "<div id=\"comment:6\" align=\"right\">comment:6</div>\n\nThis is still true. I'd say it's just true of \"dense\" collections of matrices:\n\n```\ndef imm(A):\n    A.set_immutable()\n    return A\n```\n\n```\nsage: V={imm(matrix([a,b,c,d])) for a in [-1..1] for b in [-1..1] for c in [-1..1] for d in [-1..1]}\nsage: H={hash(v) for v in V}\nsage: Ht={hash(tuple(v.list())) for v in V}\nsage: len(V); len (H); len(Ht)\n81\n14\n69\n```\nso I think this problem might need a little bump in priority.",
    "created_at": "2016-07-04T16:02:57Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106408",
    "user": "https://github.com/nbruin"
}
```

<div id="comment:6" align="right">comment:6</div>

This is still true. I'd say it's just true of "dense" collections of matrices:

```
def imm(A):
    A.set_immutable()
    return A
```

```
sage: V={imm(matrix([a,b,c,d])) for a in [-1..1] for b in [-1..1] for c in [-1..1] for d in [-1..1]}
sage: H={hash(v) for v in V}
sage: Ht={hash(tuple(v.list())) for v in V}
sage: len(V); len (H); len(Ht)
81
14
69
```
so I think this problem might need a little bump in priority.



---

archive/issue_comments_106409.json:
```json
{
    "body": "<div id=\"comment:7\" align=\"right\">comment:7</div>\n\nI opened #19050 while not knowing about this one! Funny numbers.\n\nIt would be easy to design a robust hash for dense matrices. But we do want to have the same hash for sparse and dense matrices. As a consequence the hash should just be computed from the set {`(i,j,v)`} of nonzero values `v` at position `(i,j)`. We could do a reasonable hash by asking this list to be sorted lexicographically in `(i,j)` (that would cost a `log(num of entries)`).\n\nFor polynomials this is exactly the same setting with the list `(exponent, coefficient)`. See #21284.\n\nThe question: for sparse matrices (respectively sparse or multivariate polynomials), would it be reasonable to sort the indices in the hash function?",
    "created_at": "2017-10-22T09:21:37Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106409",
    "user": "https://github.com/videlec"
}
```

<div id="comment:7" align="right">comment:7</div>

I opened #19050 while not knowing about this one! Funny numbers.

It would be easy to design a robust hash for dense matrices. But we do want to have the same hash for sparse and dense matrices. As a consequence the hash should just be computed from the set {`(i,j,v)`} of nonzero values `v` at position `(i,j)`. We could do a reasonable hash by asking this list to be sorted lexicographically in `(i,j)` (that would cost a `log(num of entries)`).

For polynomials this is exactly the same setting with the list `(exponent, coefficient)`. See #21284.

The question: for sparse matrices (respectively sparse or multivariate polynomials), would it be reasonable to sort the indices in the hash function?



---

archive/issue_comments_106410.json:
```json
{
    "body": "<div id=\"comment:8\" align=\"right\">comment:8</div>\n\nThis may be a silly question, but why does this happen?\n\n```\nsage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))\nTrue\n```",
    "created_at": "2017-10-22T21:59:16Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106410",
    "user": "https://github.com/jhpalmieri"
}
```

<div id="comment:8" align="right">comment:8</div>

This may be a silly question, but why does this happen?

```
sage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))
True
```



---

archive/issue_comments_106411.json:
```json
{
    "body": "<div id=\"comment:9\" align=\"right\">comment:9</div>\n\nHow about just doing a `frozenset` instead of sorting the tuples?",
    "created_at": "2017-10-23T03:44:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106411",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:9" align="right">comment:9</div>

How about just doing a `frozenset` instead of sorting the tuples?



---

archive/issue_comments_106412.json:
```json
{
    "body": "<div id=\"comment:10\" align=\"right\">comment:10</div>\n\n@tscrim: using `frozenset`, the hash function would be less robust and, more importantly, would be very hard to optimize in specialized classes. You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).",
    "created_at": "2017-10-23T10:16:12Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106412",
    "user": "https://github.com/videlec"
}
```

<div id="comment:10" align="right">comment:10</div>

@tscrim: using `frozenset`, the hash function would be less robust and, more importantly, would be very hard to optimize in specialized classes. You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).



---

archive/issue_comments_106413.json:
```json
{
    "body": "<div id=\"comment:11\" align=\"right\">comment:11</div>\n\nReplying to [@videlec](#comment%3A10):\n> @tscrim: using `frozenset`, the hash function would be less robust\n\nI don't see how, but maybe I don't understand what you think it will be less robust with respect to.\n\n> and, more importantly, would be very hard to optimize in specialized classes.\n\nI don't see why you would need to optimize the hash function. The bottleneck would be iterating over the non-zero values, which is (would be?) a separate method.\n\n> You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).\n\nDo you really want to sort a list of triples every time for sparse matrices? Inserting n objects into a hash table is much faster than that: O(n) vs O(n log n) for sorting them. We might want to consider (continuing) to cache the `__hash__` as well.\n\nI also don't see why polynomials should come into an argument here.\n\nHowever, here is another thought for a hash function:\n\n```python\ntemp = [0,0,0]\nfor i,j in self.nonzero_positions():\n    temp[0] += i\n    temp[1] += j\n    temp[2] += self[i,j]\nreturn hash(tuple(temp))\n```",
    "created_at": "2017-10-23T13:20:07Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106413",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:11" align="right">comment:11</div>

Replying to [@videlec](#comment%3A10):
> @tscrim: using `frozenset`, the hash function would be less robust

I don't see how, but maybe I don't understand what you think it will be less robust with respect to.

> and, more importantly, would be very hard to optimize in specialized classes.

I don't see why you would need to optimize the hash function. The bottleneck would be iterating over the non-zero values, which is (would be?) a separate method.

> You don't want the construction of a frozenset each time `__hash__` is called (eg for dense matrices or univariate polynomial the list of exponents naturally come in order).

Do you really want to sort a list of triples every time for sparse matrices? Inserting n objects into a hash table is much faster than that: O(n) vs O(n log n) for sorting them. We might want to consider (continuing) to cache the `__hash__` as well.

I also don't see why polynomials should come into an argument here.

However, here is another thought for a hash function:

```python
temp = [0,0,0]
for i,j in self.nonzero_positions():
    temp[0] += i
    temp[1] += j
    temp[2] += self[i,j]
return hash(tuple(temp))
```



---

archive/issue_comments_106414.json:
```json
{
    "body": "<div id=\"comment:12\" align=\"right\">comment:12</div>\n\nFirst of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.\n\nLet me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.\n\nA situation for which caching might be useful is when you have a \"combinatorial\" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).\n\nDo you have more concrete situations where hashing is involved?\n\nFor sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.\n\nConcerning collisions, I don't believe your hash function was a serious proposal. Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.\n\nThe relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.",
    "created_at": "2017-10-23T14:12:52Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106414",
    "user": "https://github.com/videlec"
}
```

<div id="comment:12" align="right">comment:12</div>

First of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.

Let me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.

A situation for which caching might be useful is when you have a "combinatorial" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).

Do you have more concrete situations where hashing is involved?

For sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.

Concerning collisions, I don't believe your hash function was a serious proposal. Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.

The relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.



---

archive/issue_comments_106415.json:
```json
{
    "body": "<div id=\"comment:13\" align=\"right\">comment:13</div>\n\nReplying to [@jhpalmieri](#comment%3A8):\n> This may be a silly question, but why does this happen?\n> \n> ```\n> sage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))\n> True\n> ```\n\nInteresting. This is how Python implements hashing for tuples:\n\n```\nsage: def tuplehash(t):\n....:     n = len(t)\n....:     x = 3430008\n....:     for i in range(n):\n....:         h = hash(t[i])\n....:         x = (x ^^ h) * (1000003 + (82520 + 2*n)*i)\n....:     return x + 97531\n```\nThe resulting value should be reduced mod 2<sup>32</sup> or 2<sup>64</sup> depending on the system.\n\nThe reason for the collision is that `N ^^ -2 == -N` for any odd `N`. The choice of a XOR operation there is strange, since most simple hash functions would use addition instead. See https://en.wikipedia.org/wiki/Universal_hashing#Constructions for example.",
    "created_at": "2017-10-23T14:35:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106415",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:13" align="right">comment:13</div>

Replying to [@jhpalmieri](#comment%3A8):
> This may be a silly question, but why does this happen?
> 
> ```
> sage: hash((0, 1, -1, -1)) == hash((0, 1, 0, 0))
> True
> ```

Interesting. This is how Python implements hashing for tuples:

```
sage: def tuplehash(t):
....:     n = len(t)
....:     x = 3430008
....:     for i in range(n):
....:         h = hash(t[i])
....:         x = (x ^^ h) * (1000003 + (82520 + 2*n)*i)
....:     return x + 97531
```
The resulting value should be reduced mod 2<sup>32</sup> or 2<sup>64</sup> depending on the system.

The reason for the collision is that `N ^^ -2 == -N` for any odd `N`. The choice of a XOR operation there is strange, since most simple hash functions would use addition instead. See https://en.wikipedia.org/wiki/Universal_hashing#Constructions for example.



---

archive/issue_comments_106416.json:
```json
{
    "body": "<div id=\"comment:14\" align=\"right\">comment:14</div>\n\nReplying to [@tscrim](#comment%3A11):\n> However, here is another thought for a hash function:\n> \n> ```python\n> temp = [0,0,0]\n> for i,j in self.nonzero_positions():\n>     temp[0] += i\n>     temp[1] += j\n>     temp[2] += self[i,j]\n> return hash(tuple(temp))\n> ```\n\nI like the idea but not the concrete implementation. It does avoid sorting but there needs to be more mixing. Something like\n\n```python\nh = 0\nfor i,j in self.nonzero_positions():\n    h += H(i, j, self[i,j])\nreturn h\n```\nwhere `H` is a simple hash function.",
    "created_at": "2017-10-23T14:41:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106416",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:14" align="right">comment:14</div>

Replying to [@tscrim](#comment%3A11):
> However, here is another thought for a hash function:
> 
> ```python
> temp = [0,0,0]
> for i,j in self.nonzero_positions():
>     temp[0] += i
>     temp[1] += j
>     temp[2] += self[i,j]
> return hash(tuple(temp))
> ```

I like the idea but not the concrete implementation. It does avoid sorting but there needs to be more mixing. Something like

```python
h = 0
for i,j in self.nonzero_positions():
    h += H(i, j, self[i,j])
return h
```
where `H` is a simple hash function.



---

archive/issue_comments_106417.json:
```json
{
    "body": "Author: **Jeroen Demeyer**",
    "created_at": "2017-10-23T14:45:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106417",
    "user": "https://github.com/jdemeyer"
}
```

Author: **Jeroen Demeyer**



---

archive/issue_events_143742.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2017-10-23T14:45:02Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "milestone_number": null,
    "milestone_title": "sage-8.1",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143742"
}
```



---

archive/issue_comments_106418.json:
```json
{
    "body": "<div id=\"comment:15\" align=\"right\">comment:15</div>\n\nLet me give this a shot...",
    "created_at": "2017-10-23T14:45:02Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106418",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:15" align="right">comment:15</div>

Let me give this a shot...



---

archive/issue_comments_106419.json:
```json
{
    "body": "Dependencies: **#24090**",
    "created_at": "2017-10-23T15:27:59Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106419",
    "user": "https://github.com/jdemeyer"
}
```

Dependencies: **#24090**



---

archive/issue_comments_106420.json:
```json
{
    "body": "<div id=\"comment:17\" align=\"right\">comment:17</div>\n\nReplying to [@videlec](#comment%3A12):\n> First of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.\n> \n> Let me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.\n\nIt depends on what you mean by \"considerable waste.\" In terms of computational complexity, it just adds to the constant (or probably would not even be contributing asymptotically for dense matrices). However, I do agree that it effectively doubles the memory footprint for dense matrices.\n\n> A situation for which caching might be useful is when you have a \"combinatorial\" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).\n> \n> Do you have more concrete situations where hashing is involved?\n\nAs you mentioned, when they are used for keys of a module implemented as a `dict`, such for `CombinatorialFreeModule` elements, or for defining objects such as `FiniteDimensionalAlgebra`. Granted, in these situations the matrices are relatively small.\n\n> For sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.\n\nI have been doing a bunch of stuff with sparse matrices recently (computing representations of Lie algebras) and have encountered things that are optimized for dense matrices that are used by sparse matrices as well. So I'd appreciate it if we didn't make the hash worse for sparse matrices just because it is better of dense matrices.\n\n> Concerning collisions, I don't believe your hash function was a serious proposal.\n\nIt was just a thought on how to remove the dependence on the order and not fully fleshed out. I know I'm less experienced in this area, but I am legitimately trying to help.\n\n> Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.\n\nI agree that it would not perform well in this case. What do you think about Jeoren's modification. I think it works well for both dense and sparse matrices and should work better than my proposal.\n\n> The relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.\n\nFor the multivariate polynomials, it looks like what is used is Jeroen's proposal. Although we could have a completely different solution for polynomials because the data structure for dense univariate is 1D and sparse k-variate are kD, whereas matrices are strictly 2D.",
    "created_at": "2017-10-23T23:57:45Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106420",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:17" align="right">comment:17</div>

Replying to [@videlec](#comment%3A12):
> First of all, the hash function is time critical and caching a hash is useless. You are almost never trying to test `A = A` (are you?). At least, upstream Python decided not to cache it for tuples and frozensets based on concrete benchmarking.
> 
> Let me consider a first concrete situation. I have 2 invertible matrices 3x3 matrices and I want to check whether there is a multiplicative relation among them. It is likely that I need to consider products of size 20, that is put in a set around 3<sup>20</sup> matrices. Building a frozenset for each of them would be a considerable waste and caching would not help.

It depends on what you mean by "considerable waste." In terms of computational complexity, it just adds to the constant (or probably would not even be contributing asymptotically for dense matrices). However, I do agree that it effectively doubles the memory footprint for dense matrices.

> A situation for which caching might be useful is when you have a "combinatorial" free module with a basis made of matrices and you encode your vectors using your matrices as keys. Though, that might be a problem of datastructure here (the keys are completely static).
> 
> Do you have more concrete situations where hashing is involved?

As you mentioned, when they are used for keys of a module implemented as a `dict`, such for `CombinatorialFreeModule` elements, or for defining objects such as `FiniteDimensionalAlgebra`. Granted, in these situations the matrices are relatively small.

> For sorting the indices, I believe that in most situations hashing will be used on dense matrices. For them, you can go through the `(i,j)` indices in any order you like.

I have been doing a bunch of stuff with sparse matrices recently (computing representations of Lie algebras) and have encountered things that are optimized for dense matrices that are used by sparse matrices as well. So I'd appreciate it if we didn't make the hash worse for sparse matrices just because it is better of dense matrices.

> Concerning collisions, I don't believe your hash function was a serious proposal.

It was just a thought on how to remove the dependence on the order and not fully fleshed out. I know I'm less experienced in this area, but I am legitimately trying to help.

> Let us consider `n x n` matrices with entries `{0,1}`. Let N = n<sup>2</sup>. You know that you have 2<sup>N</sup> such matrices and it is easy to see that you have a polynomial number of values produced by your hash function (around N<sup>2</sup> N<sup>2</sup> N = N<sup>5</sup> if I am optimistic). Even on permutation matrices, your hash function would perform terribly.

I agree that it would not perform well in this case. What do you think about Jeoren's modification. I think it works well for both dense and sparse matrices and should work better than my proposal.

> The relevance of polynomials is that you have the same kind of troubles passing from univariate (coefficients in a list like structure) to multivariate (coefficients in a dictionary like structure). See #21284.

For the multivariate polynomials, it looks like what is used is Jeroen's proposal. Although we could have a completely different solution for polynomials because the data structure for dense univariate is 1D and sparse k-variate are kD, whereas matrices are strictly 2D.



---

archive/issue_comments_106421.json:
```json
{
    "body": "Branch: **[u/jdemeyer/the_hash_function_for_matrices_suffers_from_many_collisions_with_permutation_matrices](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/the_hash_function_for_matrices_suffers_from_many_collisions_with_permutation_matrices)**",
    "created_at": "2017-10-24T13:41:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106421",
    "user": "https://github.com/jdemeyer"
}
```

Branch: **[u/jdemeyer/the_hash_function_for_matrices_suffers_from_many_collisions_with_permutation_matrices](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/the_hash_function_for_matrices_suffers_from_many_collisions_with_permutation_matrices)**



---

archive/issue_comments_106422.json:
```json
{
    "body": "Commit: **[`f67a883`](https://github.com/sagemath/sagetrac-mirror/commit/f67a8839d7dfb843a8ed8652a2734b644be579f1)**",
    "created_at": "2017-10-24T15:30:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106422",
    "user": "https://github.com/sagetrac-git"
}
```

Commit: **[`f67a883`](https://github.com/sagemath/sagetrac-mirror/commit/f67a8839d7dfb843a8ed8652a2734b644be579f1)**



---

archive/issue_comments_106423.json:
```json
{
    "body": "<div id=\"comment:19\"></div>\n\nBranch pushed to git repo; I updated commit sha1. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/f67a8839d7dfb843a8ed8652a2734b644be579f1\"><code>f67a883</code></a></td><td><code>Fix doctests</code></td></tr></table>\n",
    "created_at": "2017-10-24T15:30:21Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106423",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:19"></div>

Branch pushed to git repo; I updated commit sha1. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/f67a8839d7dfb843a8ed8652a2734b644be579f1"><code>f67a883</code></a></td><td><code>Fix doctests</code></td></tr></table>




---

archive/issue_comments_106424.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -6,25 +6,26 @@\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n ```\n \n-In general, we would hope to get n! below:\n+After applying this branch:\n \n ```\n-    sage: len(set([ hash(mat(p)) for p in Permutations(1) ]))\n-    1\n-    sage: len(set([ hash(mat(p)) for p in Permutations(2) ]))\n-    1\n-    sage: len(set([ hash(mat(p)) for p in Permutations(3) ]))\n-    5\n-    sage: len(set([ hash(mat(p)) for p in Permutations(4) ]))\n-    1\n-    sage: len(set([ hash(mat(p)) for p in Permutations(5) ]))\n-    16\n-    sage: len(set([ hash(mat(p)) for p in Permutations(6) ]))\n-    16\n-    sage: len(set([ hash(mat(p)) for p in Permutations(7) ]))\n-    32\n-    sage: len(set([ hash(mat(p)) for p in Permutations(8) ]))\n-    1\n+sage: def hashmat(p): m = p.to_matrix(); m.set_immutable(); return hash(m)\n+sage: len(set(hashmat(p) for p in Permutations(1)))\n+1\n+sage: len(set(hashmat(p) for p in Permutations(2)))\n+2\n+sage: len(set(hashmat(p) for p in Permutations(3)))\n+6\n+sage: len(set(hashmat(p) for p in Permutations(4)))\n+24\n+sage: len(set(hashmat(p) for p in Permutations(5)))\n+120\n+sage: len(set(hashmat(p) for p in Permutations(6)))\n+720\n+sage: len(set(hashmat(p) for p in Permutations(7)))\n+5040\n+sage: len(set(hashmat(p) for p in Permutations(8)))\n+40320\n ```\n \n I stumbled on this when profiling some code using Weyl groups that\n``````\n",
    "created_at": "2017-10-24T15:34:40Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106424",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -6,25 +6,26 @@
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
 ```
 
-In general, we would hope to get n! below:
+After applying this branch:
 
 ```
-    sage: len(set([ hash(mat(p)) for p in Permutations(1) ]))
-    1
-    sage: len(set([ hash(mat(p)) for p in Permutations(2) ]))
-    1
-    sage: len(set([ hash(mat(p)) for p in Permutations(3) ]))
-    5
-    sage: len(set([ hash(mat(p)) for p in Permutations(4) ]))
-    1
-    sage: len(set([ hash(mat(p)) for p in Permutations(5) ]))
-    16
-    sage: len(set([ hash(mat(p)) for p in Permutations(6) ]))
-    16
-    sage: len(set([ hash(mat(p)) for p in Permutations(7) ]))
-    32
-    sage: len(set([ hash(mat(p)) for p in Permutations(8) ]))
-    1
+sage: def hashmat(p): m = p.to_matrix(); m.set_immutable(); return hash(m)
+sage: len(set(hashmat(p) for p in Permutations(1)))
+1
+sage: len(set(hashmat(p) for p in Permutations(2)))
+2
+sage: len(set(hashmat(p) for p in Permutations(3)))
+6
+sage: len(set(hashmat(p) for p in Permutations(4)))
+24
+sage: len(set(hashmat(p) for p in Permutations(5)))
+120
+sage: len(set(hashmat(p) for p in Permutations(6)))
+720
+sage: len(set(hashmat(p) for p in Permutations(7)))
+5040
+sage: len(set(hashmat(p) for p in Permutations(8)))
+40320
 ```
 
 I stumbled on this when profiling some code using Weyl groups that
``````




---

archive/issue_comments_106425.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -5,6 +5,13 @@\n     sage: [ hash(mat(p)) for p in Permutations(4) ]\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n ```\n+\n+I stumbled on this when profiling some code using Weyl groups that\n+heavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices.\n+\n+Cheers,\n+\t\t\t\tNicolas\n+\n \n After applying this branch:\n \n@@ -28,9 +35,6 @@\n 40320\n ```\n \n-I stumbled on this when profiling some code using Weyl groups that\n-heavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices as in the attached patch. Now, I have no idea if in general that would be a good hash for matrices, so please some expert write an appropriate patch.\n+As extra bonus, this branch ensures that scalar matrices have the same hash as the scalar. This means one extra case where `A == B` implies `hash(A) == hash(B)`.\n \n-Cheers,\n-\t\t\t\tNicolas\n \n``````\n",
    "created_at": "2017-10-24T15:36:54Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106425",
    "user": "https://github.com/jdemeyer"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -5,6 +5,13 @@
     sage: [ hash(mat(p)) for p in Permutations(4) ]
     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
 ```
+
+I stumbled on this when profiling some code using Weyl groups that
+heavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices.
+
+Cheers,
+				Nicolas
+
 
 After applying this branch:
 
@@ -28,9 +35,6 @@
 40320
 ```
 
-I stumbled on this when profiling some code using Weyl groups that
-heavily used caching (the hash of a weyl group element is the hash of the underlying matrix). I gained a speed factor of 10x by just tweaking the hash of matrices as in the attached patch. Now, I have no idea if in general that would be a good hash for matrices, so please some expert write an appropriate patch.
+As extra bonus, this branch ensures that scalar matrices have the same hash as the scalar. This means one extra case where `A == B` implies `hash(A) == hash(B)`.
 
-Cheers,
-				Nicolas
 
``````




---

archive/issue_comments_106426.json:
```json
{
    "body": "<div id=\"comment:22\" align=\"right\">comment:22</div>\n\nFeel free to comment. This is essentially \"needs review\" except that I haven't run all doctests yet.",
    "created_at": "2017-10-24T15:38:00Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106426",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:22" align="right">comment:22</div>

Feel free to comment. This is essentially "needs review" except that I haven't run all doctests yet.



---

archive/issue_events_143743.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2017-10-24T15:39:30Z",
    "event": "renamed",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "title_is": "The hash function for matrices suffers from many collisions",
    "title_was": "The hash function for matrices suffers from many collisions with permutation matrices",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143743"
}
```



---

archive/issue_comments_106427.json:
```json
{
    "body": "<div id=\"comment:24\" align=\"right\">comment:24</div>\n\nNice! Would be interesting to test in conjunction with #23706.",
    "created_at": "2017-10-24T15:55:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106427",
    "user": "https://github.com/videlec"
}
```

<div id="comment:24" align="right">comment:24</div>

Nice! Would be interesting to test in conjunction with #23706.



---

archive/issue_comments_106428.json:
```json
{
    "body": "<div id=\"comment:25\" align=\"right\">comment:25</div>\n\nInstead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?",
    "created_at": "2017-10-24T15:56:41Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106428",
    "user": "https://github.com/videlec"
}
```

<div id="comment:25" align="right">comment:25</div>

Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?



---

archive/issue_comments_106429.json:
```json
{
    "body": "<div id=\"comment:26\" align=\"right\">comment:26</div>\n\nReplying to [@videlec](#comment%3A25):\n> Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?\n\nPlease elaborate. Why should I do that?",
    "created_at": "2017-10-24T19:11:17Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106429",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:26" align="right">comment:26</div>

Replying to [@videlec](#comment%3A25):
> Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?

Please elaborate. Why should I do that?



---

archive/issue_comments_106430.json:
```json
{
    "body": "Changed commit from **[`f67a883`](https://github.com/sagemath/sagetrac-mirror/commit/f67a8839d7dfb843a8ed8652a2734b644be579f1)** to **[`d159670`](https://github.com/sagemath/sagetrac-mirror/commit/d159670f8f4f3196abd340a5ed3df2d16a291f8c)**",
    "created_at": "2017-10-24T19:14:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106430",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`f67a883`](https://github.com/sagemath/sagetrac-mirror/commit/f67a8839d7dfb843a8ed8652a2734b644be579f1)** to **[`d159670`](https://github.com/sagemath/sagetrac-mirror/commit/d159670f8f4f3196abd340a5ed3df2d16a291f8c)**



---

archive/issue_comments_106431.json:
```json
{
    "body": "<div id=\"comment:27\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/d159670f8f4f3196abd340a5ed3df2d16a291f8c\"><code>d159670</code></a></td><td><code>Fix doctests</code></td></tr></table>\n",
    "created_at": "2017-10-24T19:14:11Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106431",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:27"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/d159670f8f4f3196abd340a5ed3df2d16a291f8c"><code>d159670</code></a></td><td><code>Fix doctests</code></td></tr></table>




---

archive/issue_events_143744.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2017-10-24T19:14:32Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143744"
}
```



---

archive/issue_comments_106432.json:
```json
{
    "body": "<div id=\"comment:29\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b98ce2845f2fae050502dfa8ee855127395d8810\"><code>b98ce28</code></a></td><td><code>Better hash for matrices</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/b3abe34f8b1c8b9592ed661de2d40d2ece85a5d4\"><code>b3abe34</code></a></td><td><code>Fix doctests</code></td></tr></table>\n",
    "created_at": "2017-10-25T08:10:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106432",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:29"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b98ce2845f2fae050502dfa8ee855127395d8810"><code>b98ce28</code></a></td><td><code>Better hash for matrices</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/b3abe34f8b1c8b9592ed661de2d40d2ece85a5d4"><code>b3abe34</code></a></td><td><code>Fix doctests</code></td></tr></table>




---

archive/issue_comments_106433.json:
```json
{
    "body": "Changed commit from **[`d159670`](https://github.com/sagemath/sagetrac-mirror/commit/d159670f8f4f3196abd340a5ed3df2d16a291f8c)** to **[`b3abe34`](https://github.com/sagemath/sagetrac-mirror/commit/b3abe34f8b1c8b9592ed661de2d40d2ece85a5d4)**",
    "created_at": "2017-10-25T08:10:03Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106433",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`d159670`](https://github.com/sagemath/sagetrac-mirror/commit/d159670f8f4f3196abd340a5ed3df2d16a291f8c)** to **[`b3abe34`](https://github.com/sagemath/sagetrac-mirror/commit/b3abe34f8b1c8b9592ed661de2d40d2ece85a5d4)**



---

archive/issue_comments_106434.json:
```json
{
    "body": "<div id=\"comment:30\" align=\"right\">comment:30</div>\n\nReorganized the code a bit, added documentation in `matrix0.pyx` to explain why I did things the way I did.",
    "created_at": "2017-10-25T08:17:08Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106434",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:30" align="right">comment:30</div>

Reorganized the code a bit, added documentation in `matrix0.pyx` to explain why I did things the way I did.



---

archive/issue_comments_106435.json:
```json
{
    "body": "<div id=\"comment:31\"></div>\n\nBranch pushed to git repo; I updated commit sha1. This was a forced push. New commits:\n<table><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/210febfdf2555cd5ffc8ad20303131edb4931b54\"><code>210febf</code></a></td><td><code>Better hash for matrices</code></td></tr><tr><td><a href=\"https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8\"><code>da5c1ff</code></a></td><td><code>Fix doctests</code></td></tr></table>\n",
    "created_at": "2017-10-25T08:20:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106435",
    "user": "https://github.com/sagetrac-git"
}
```

<div id="comment:31"></div>

Branch pushed to git repo; I updated commit sha1. This was a forced push. New commits:
<table><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/210febfdf2555cd5ffc8ad20303131edb4931b54"><code>210febf</code></a></td><td><code>Better hash for matrices</code></td></tr><tr><td><a href="https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8"><code>da5c1ff</code></a></td><td><code>Fix doctests</code></td></tr></table>




---

archive/issue_comments_106436.json:
```json
{
    "body": "Changed commit from **[`b3abe34`](https://github.com/sagemath/sagetrac-mirror/commit/b3abe34f8b1c8b9592ed661de2d40d2ece85a5d4)** to **[`da5c1ff`](https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8)**",
    "created_at": "2017-10-25T08:20:42Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106436",
    "user": "https://github.com/sagetrac-git"
}
```

Changed commit from **[`b3abe34`](https://github.com/sagemath/sagetrac-mirror/commit/b3abe34f8b1c8b9592ed661de2d40d2ece85a5d4)** to **[`da5c1ff`](https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8)**



---

archive/issue_comments_106437.json:
```json
{
    "body": "<div id=\"comment:32\" align=\"right\">comment:32</div>\n\nReplying to [@jdemeyer](#comment%3A26):\n> Replying to [@videlec](#comment%3A25):\n> > Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?\n> \n> \n> Please elaborate. Why should I do that?\n\nTo make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.",
    "created_at": "2017-10-25T09:35:44Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106437",
    "user": "https://github.com/videlec"
}
```

<div id="comment:32" align="right">comment:32</div>

Replying to [@jdemeyer](#comment%3A26):
> Replying to [@videlec](#comment%3A25):
> > Instead of `hash(self.get_unsafe(i, j))` what about introducing `self._entry_hash(i, j)`?
> 
> 
> Please elaborate. Why should I do that?

To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.



---

archive/issue_comments_106438.json:
```json
{
    "body": "<div id=\"comment:33\" align=\"right\">comment:33</div>\n\nReplying to [@videlec](#comment%3A32):\n> To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.\n\nOn the other hand, you force every `Matrix` class to implement yet another method...\n\nI'm not really convinced... in any case, that can wait for a follow-up ticket.",
    "created_at": "2017-10-25T09:41:38Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106438",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:33" align="right">comment:33</div>

Replying to [@videlec](#comment%3A32):
> To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.

On the other hand, you force every `Matrix` class to implement yet another method...

I'm not really convinced... in any case, that can wait for a follow-up ticket.



---

archive/issue_comments_106439.json:
```json
{
    "body": "<div id=\"comment:34\" align=\"right\">comment:34</div>\n\nReplying to [@jdemeyer](#comment%3A33):\n> Replying to [@videlec](#comment%3A32):\n> > To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.\n> \n> \n> On the other hand, you force every `Matrix` class to implement yet another method...\n\nIt would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.\n\n> I'm not really convinced... in any case, that can wait for a follow-up ticket.\n\nAgreed, it can wait.",
    "created_at": "2017-10-25T09:43:30Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106439",
    "user": "https://github.com/videlec"
}
```

<div id="comment:34" align="right">comment:34</div>

Replying to [@jdemeyer](#comment%3A33):
> Replying to [@videlec](#comment%3A32):
> > To make hashing faster! That would be a method easy to implement for extension classes that store the data as a C attribute. In such situation you don't want to build a Python object each time you compute the hash of an entry. And you don't want to copy/paste of the `_hash_` function either.
> 
> 
> On the other hand, you force every `Matrix` class to implement yet another method...

It would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.

> I'm not really convinced... in any case, that can wait for a follow-up ticket.

Agreed, it can wait.



---

archive/issue_comments_106440.json:
```json
{
    "body": "<div id=\"comment:35\" align=\"right\">comment:35</div>\n\nReplying to [@videlec](#comment%3A34):\n> It would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.\n\nBut that would add an extra level of indirection in the general case, slowing that down.",
    "created_at": "2017-10-25T10:19:35Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106440",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:35" align="right">comment:35</div>

Replying to [@videlec](#comment%3A34):
> It would not be forced: `return hash(self._get_unsafe(i,j))` is a reasonable default.

But that would add an extra level of indirection in the general case, slowing that down.



---

archive/issue_comments_106441.json:
```json
{
    "body": "Reviewer: **Travis Scrimshaw, Vincent Delecroix**",
    "created_at": "2017-10-25T22:57:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106441",
    "user": "https://github.com/tscrim"
}
```

Reviewer: **Travis Scrimshaw, Vincent Delecroix**



---

archive/issue_comments_106442.json:
```json
{
    "body": "<div id=\"comment:36\" align=\"right\">comment:36</div>\n\nI don't think there should be any Python object getting created by `_get_unsafe`, just a pointer to a Python object. What would be a use-case for implementing a custom `_entry_hash`?\n\nAnyways, since you say it can wait for a followup and this is a good improvement, I am setting it to a positive review. If you still want to discuss things first, feel free to revert.",
    "created_at": "2017-10-25T22:57:13Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106442",
    "user": "https://github.com/tscrim"
}
```

<div id="comment:36" align="right">comment:36</div>

I don't think there should be any Python object getting created by `_get_unsafe`, just a pointer to a Python object. What would be a use-case for implementing a custom `_entry_hash`?

Anyways, since you say it can wait for a followup and this is a good improvement, I am setting it to a positive review. If you still want to discuss things first, feel free to revert.



---

archive/issue_events_143745.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2017-10-25T22:57:13Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "label": "https://github.com/sagemath/sage/labels/needs%20review",
    "label_color": "7fff00",
    "label_name": "needs review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143745"
}
```



---

archive/issue_events_143746.json:
```json
{
    "actor": "https://github.com/tscrim",
    "created_at": "2017-10-25T22:57:13Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143746"
}
```



---

archive/issue_comments_106443.json:
```json
{
    "body": "<div id=\"comment:37\" align=\"right\">comment:37</div>\n\nReplying to [@tscrim](#comment%3A36):\n> I don't think there should be any Python object getting created by `_get_unsafe`\n\n...only if the entries of the matrix are stored as Python objects. For many specialized classes (matrices over ZZ or over finite fields), the entries are stored in some C array, so `_get_unsafe()` does need to create a Python object.",
    "created_at": "2017-10-26T06:43:25Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106443",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:37" align="right">comment:37</div>

Replying to [@tscrim](#comment%3A36):
> I don't think there should be any Python object getting created by `_get_unsafe`

...only if the entries of the matrix are stored as Python objects. For many specialized classes (matrices over ZZ or over finite fields), the entries are stored in some C array, so `_get_unsafe()` does need to create a Python object.



---

archive/issue_events_143747.json:
```json
{
    "actor": "https://github.com/vbraun",
    "created_at": "2017-10-30T07:41:31Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "label": "https://github.com/sagemath/sage/labels/positive%20review",
    "label_color": "dfffc0",
    "label_name": "positive review",
    "label_text_color": "ffffff",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143747"
}
```



---

archive/issue_events_143748.json:
```json
{
    "actor": "https://github.com/vbraun",
    "commit_id": "1df89a43aaa66bff03abcf12e4c7bf1d2b7b689c",
    "commit_repository": "https://github.com/sagemath/sage",
    "created_at": "2017-10-30T07:41:31Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sage/issues/10950#event-143748"
}
```



---

archive/issue_comments_106444.json:
```json
{
    "body": "Changed branch from **[u/jdemeyer/the_hash_function_for_matrices_suffers_from_many_collisions_with_permutation_matrices](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/the_hash_function_for_matrices_suffers_from_many_collisions_with_permutation_matrices)** to **[`da5c1ff`](https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8)**",
    "created_at": "2017-10-30T07:41:31Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106444",
    "user": "https://github.com/vbraun"
}
```

Changed branch from **[u/jdemeyer/the_hash_function_for_matrices_suffers_from_many_collisions_with_permutation_matrices](https://github.com/sagemath/sagetrac-mirror/tree/u/jdemeyer/the_hash_function_for_matrices_suffers_from_many_collisions_with_permutation_matrices)** to **[`da5c1ff`](https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8)**



---

archive/issue_comments_106445.json:
```json
{
    "body": "Changed commit from **[`da5c1ff`](https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8)** to none",
    "created_at": "2017-10-30T16:35:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106445",
    "user": "https://github.com/jdemeyer"
}
```

Changed commit from **[`da5c1ff`](https://github.com/sagemath/sagetrac-mirror/commit/da5c1ff296edce8e6037d134e774ffdf328984f8)** to none



---

archive/issue_comments_106446.json:
```json
{
    "body": "<div id=\"comment:39\" align=\"right\">comment:39</div>\n\nSome more comments:\n\nThis hash function is a lot better than the old one. However, it is far from perfect:\n\n```\nsage: M = diagonal_matrix([0, 1, -2, 1]); M.set_immutable(); hash(M)\n0\n```\nStill, it is the best hash that I could come up with which is very efficient for sparse matrices: it takes time `O(s)` with `s` the number of non-zero entries of a matrix (independent of the size of the matrix). If you are willing to sort the indices (as suggested in [comment:7]), you get a better hash but with a runtime of `O(s log(s))`.",
    "created_at": "2017-10-30T16:35:56Z",
    "formatter": "markdown",
    "issue": "https://github.com/sagemath/sage/issues/10950",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sage/issues/10950#issuecomment-106446",
    "user": "https://github.com/jdemeyer"
}
```

<div id="comment:39" align="right">comment:39</div>

Some more comments:

This hash function is a lot better than the old one. However, it is far from perfect:

```
sage: M = diagonal_matrix([0, 1, -2, 1]); M.set_immutable(); hash(M)
0
```
Still, it is the best hash that I could come up with which is very efficient for sparse matrices: it takes time `O(s)` with `s` the number of non-zero entries of a matrix (independent of the size of the matrix). If you are willing to sort the indices (as suggested in [comment:7]), you get a better hash but with a runtime of `O(s log(s))`.
