# Issue 10667: Morphisms and Objects of Categories

archive/issues_010614.json:
```json
{
    "body": "**__Purpose__**\n\nIntroduce a framework for testing whether or not something is a morphism in a category. See the discussion on [sage-algebra](http://groups.google.com/group/sage-algebra/browse_thread/thread/3e2ca2a8be1a3a23). Here is a summary of the discussion.\n\n__Methods for categories__\n\nCategories `C` should have a method `C.has_morphism(f)` answering whether `f` is a morphism in `C`. By symmetry, we want a method `C.has_object(X)`, answering whether `X` is an object in `C`.\n\nNote that we want `X in C` to be true if and only if `X` is an object of `C` (so, it is synonymous to `C.has_object(X)`). This currently is not always the case:\n\n```\nsage: P.<x,y> = QQ[]\nsage: f = P.hom(reversed(P.gens()))\nsage: f in Rings().hom_category()\nTrue\n```\nbut of course `f` is not an *object* of the hom-category (it is only *contained* in an object of the hom-category).\n\n__Class/Set of objects and morphisms__\n\nIt would be nice to have container classes for the objects and for the morphisms of a category. Then, `f in C.morphisms()` would be a very natural notation for `C.has_morphism(f)`, and `X in C.objects()` would be another way of saying `X in C`.\n\nOf course, since `f in C.morphisms()` and `f in C.objects()` are nice notations, they should be as fast as possible -- otherwise, people wouldn't use them.\n\nFurther discussion should be put in comments to this ticket.\n\n**Assignee:** @nthiery\n\n**CC:**  @nilesjohnson jpflori\n\n**Keywords:** objects morphisms containment sd34\n\n**Work Issues:** Cope with non-unique number fields\n\n**Author:** Simon King\n\n**Status:** needs_work\n\n**Dependencies:** #9138, #11115, #11780\n\nIssue created by migration from https://trac.sagemath.org/ticket/10667\n\n",
    "created_at": "2011-01-21T08:18:44Z",
    "labels": [
        "component: categories"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-6.4",
    "title": "Morphisms and Objects of Categories",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/10667",
    "user": "https://github.com/simon-king-jena"
}
```
**__Purpose__**

Introduce a framework for testing whether or not something is a morphism in a category. See the discussion on [sage-algebra](http://groups.google.com/group/sage-algebra/browse_thread/thread/3e2ca2a8be1a3a23). Here is a summary of the discussion.

__Methods for categories__

Categories `C` should have a method `C.has_morphism(f)` answering whether `f` is a morphism in `C`. By symmetry, we want a method `C.has_object(X)`, answering whether `X` is an object in `C`.

Note that we want `X in C` to be true if and only if `X` is an object of `C` (so, it is synonymous to `C.has_object(X)`). This currently is not always the case:

```
sage: P.<x,y> = QQ[]
sage: f = P.hom(reversed(P.gens()))
sage: f in Rings().hom_category()
True
```
but of course `f` is not an *object* of the hom-category (it is only *contained* in an object of the hom-category).

__Class/Set of objects and morphisms__

It would be nice to have container classes for the objects and for the morphisms of a category. Then, `f in C.morphisms()` would be a very natural notation for `C.has_morphism(f)`, and `X in C.objects()` would be another way of saying `X in C`.

Of course, since `f in C.morphisms()` and `f in C.objects()` are nice notations, they should be as fast as possible -- otherwise, people wouldn't use them.

Further discussion should be put in comments to this ticket.

**Assignee:** @nthiery

**CC:**  @nilesjohnson jpflori

**Keywords:** objects morphisms containment sd34

**Work Issues:** Cope with non-unique number fields

**Author:** Simon King

**Status:** needs_work

**Dependencies:** #9138, #11115, #11780

Issue created by migration from https://trac.sagemath.org/ticket/10667





---

archive/issue_comments_140281.json:
```json
{
    "body": "<a id='comment:1'></a>\nIf a category has not its own implementation of a hom-category, currently the join of the hom-categories of its super-categories is chosen. Hence, we have\n\n```\nsage: CommutativeRings().hom_category()\nCategory of hom sets in Category of rings\nsage: WeylGroups().hom_category()\nCategory of hom sets in Category of sets\n```\n\nI don't like that. One problem is that, for test suites, one would like to have a sample object -- but there is no way to create a sample object for a join of arbitrary categories.\n\nMoreover, the \"hom sets in the Category of rings\" are simply wrong for the category of *commutative* rings.\n\nInstead, I suggest to walk through the list of all super categories of `self`, take the first that has the attribute `HomCategory` (i.e., has a custom implementation of a hom category), and insert `self` as argument for that `HomCategory`:\n\n```\nsage: HopfAlgebrasWithBasis(QQ).hom_category()\nCategory of hom sets in Category of hopf algebras with basis over Rational Field\nsage: WeylGroups().hom_category()\nCategory of hom sets in Category of weyl groups\nsage: type(HopfAlgebrasWithBasis(QQ).hom_category())\n<class 'sage.categories.modules_with_basis.ModulesWithBasis.HomCategory'>\nsage: type(WeylGroups().hom_category())\n<class 'sage.categories.sets_cat.Sets.HomCategory'>\n```\n\nOf course, it may happen that several super categories have different custom implementation of hom categories, and we pick just one. But I think this should be taken care of manually, as join categories have a serious drawback, IMHO.",
    "created_at": "2011-01-21T08:44:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140281",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:1'></a>
If a category has not its own implementation of a hom-category, currently the join of the hom-categories of its super-categories is chosen. Hence, we have

```
sage: CommutativeRings().hom_category()
Category of hom sets in Category of rings
sage: WeylGroups().hom_category()
Category of hom sets in Category of sets
```

I don't like that. One problem is that, for test suites, one would like to have a sample object -- but there is no way to create a sample object for a join of arbitrary categories.

Moreover, the "hom sets in the Category of rings" are simply wrong for the category of *commutative* rings.

Instead, I suggest to walk through the list of all super categories of `self`, take the first that has the attribute `HomCategory` (i.e., has a custom implementation of a hom category), and insert `self` as argument for that `HomCategory`:

```
sage: HopfAlgebrasWithBasis(QQ).hom_category()
Category of hom sets in Category of hopf algebras with basis over Rational Field
sage: WeylGroups().hom_category()
Category of hom sets in Category of weyl groups
sage: type(HopfAlgebrasWithBasis(QQ).hom_category())
<class 'sage.categories.modules_with_basis.ModulesWithBasis.HomCategory'>
sage: type(WeylGroups().hom_category())
<class 'sage.categories.sets_cat.Sets.HomCategory'>
```

Of course, it may happen that several super categories have different custom implementation of hom categories, and we pick just one. But I think this should be taken care of manually, as join categories have a serious drawback, IMHO.



---

archive/issue_comments_140282.json:
```json
{
    "body": "<a id='comment:2'></a>\nHi Simon!\n\nReplying to [SimonKing](#comment%3A1):\n> If a category has not its own implementation of a hom-category, currently the join of the hom-categories of its super-categories is chosen. Hence, we have\n> \n> ```\n> sage: CommutativeRings().hom_category()\n> Category of hom sets in Category of rings\n> sage: WeylGroups().hom_category()\n> Category of hom sets in Category of sets\n> ```\n> \n> I don't like that.\n> ...\n\n\nYeah. As mentioned in the code and in the road map [1], HomCategory is\njust plain broken and needs a full refactoring. I just used the\noccasion to create a ticket with design suggestions: #10668.\n\nIf you want to improve things in this direction, please jump right\naway on #10668; it might actually not be that much work, and every\nintermediate step would be just a work around and a waste of time.\n\nThanks again for your continuous motion toward improving Sage in this\narea!\n\nCheers,\n\t\t\t\tNicolas\n\n[1] http://trac.sagemath.org/sage_trac/wiki/CategoriesRoadMap",
    "created_at": "2011-01-21T09:41:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140282",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:2'></a>
Hi Simon!

Replying to [SimonKing](#comment%3A1):
> If a category has not its own implementation of a hom-category, currently the join of the hom-categories of its super-categories is chosen. Hence, we have
> 
> ```
> sage: CommutativeRings().hom_category()
> Category of hom sets in Category of rings
> sage: WeylGroups().hom_category()
> Category of hom sets in Category of sets
> ```
> 
> I don't like that.
> ...


Yeah. As mentioned in the code and in the road map [1], HomCategory is
just plain broken and needs a full refactoring. I just used the
occasion to create a ticket with design suggestions: #10668.

If you want to improve things in this direction, please jump right
away on #10668; it might actually not be that much work, and every
intermediate step would be just a work around and a waste of time.

Thanks again for your continuous motion toward improving Sage in this
area!

Cheers,
				Nicolas

[1] http://trac.sagemath.org/sage_trac/wiki/CategoriesRoadMap



---

archive/issue_comments_140283.json:
```json
{
    "body": "<a id='comment:3'></a>\ncc me!  Thanks :)",
    "created_at": "2011-01-21T15:16:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140283",
    "user": "https://github.com/nilesjohnson"
}
```

<a id='comment:3'></a>
cc me!  Thanks :)



---

archive/issue_comments_140284.json:
```json
{
    "body": "<a id='comment:4'></a>\nDepends on #10496, #10659, #8611, #10467\n\nI wont to get the patch finally off my plate. So, here it is, although it isn't finished yet. \n\nMy patch provides the following:\n\n```\nsage: C = Rings()\nsage: P.<x,y> = QQ[]\nsage: f = P.hom(reversed(P.gens()))\nsage: C.has_morphism(f)\nTrue\nsage: C.morphisms()\nClass of morphisms in category of rings\nsage: f in C.morphisms()\nTrue\n# Currently, a category is acknowledged as \"small\"\n# iff it is a sub-category of FiniteEnumeratedSets()\nsage: FiniteFields().morphisms()\nSet of morphisms in category of finite fields\nsage: f in FiniteFields().morphisms()\nFalse\nsage: P in C\nTrue\nsage: C.objects()\nClass of objects in category of rings\nsage: P in C.objects()\nTrue\nsage: FiniteFields().objects()\nSet of objects in category of finite fields\n```\n\nNote that I interprete `Objects()` (the top-category in Sage) as the \"category of all classes\", although this definition probably is not water-proof:\n\n```\nsage: C.objects().category()\nCategory of objects\nsage: FiniteFields().objects().category()\nCategory of sets\n```\n\nSome categories have a custom containment test, e.g., the category of fields. The containment test of `C.objects()` automatically tests whether `C` has a custom containment, and uses it if it is the case:\n\n```\nsage: PolynomialRing(QQ,[]).category()\nCategory of commutative rings\nsage: PolynomialRing(QQ,[]) in Fields()\nTrue\nsage: PolynomialRing(QQ,[]) in Fields().objects()\nTrue\n```\n\nThe documentation for the new containers for objects and morphisms are added to the Sage reference manual -- please have a look.\n\n**__`SageObject` versus `CategoryObject`__**\n\n`SageObject` and `CategoryObject` were almost identical. In particular, `SageObject` provided a method `category()`, that by default returned the \"category of objects\". In addition, the specifition says that `X` is an object of `X.category()`, i.e., `X in X.category()`.\n\nBut that approach yields to quite unnatural constructions. For example, `1.category()` used to be the \"category of elements of Integer Ring\", whatever that means. Worse, one used to have\n\n```\n# Unpatched behaviour: Bug\nsage: ZZ.hom([1]) in Rings().hom_category()\nTrue\n```\nIn other words, a *ring homomorphism* is considered a *homset* of the category of rings - of course, it should just be an *element* of a homset:\n\n```\n# With the patch:\nsage: ZZ.hom([1]) in Rings().hom_category()\nFalse\nsage: ZZ.hom([1]) in ZZ.Hom(ZZ)\nTrue\nsage: ZZ.hom([1]) in Rings().morphisms()\nTrue\n```\n\nFixing that bug required to re-structure `SageObject` and `CategoryObject`:\n\n* I removed `category()` and `_test_category()` from `SageObject` and moved it to `CategoryObject` (which directly inherits from `SageObject` anyway).\n* I made `Element` and `Map` inherit from `SageObject`, not from `CategoryObject`, and removed the custom `category()` for `Element`. Of course, `Parent` still inherits from `CategoryObject`.\n\nNote that by this change, it is now impossible to define nonsense such as `Hom(2,3)` (2 and 3 used to be objects in a category, so, there was a hom-set!).\n\n**__Hom-categories__**\n\n**Compare #10668**: This part of my patch is not finished, yet. I suppose that eventually this ticket here will depend on #10668.\n\nJust for now, I implemented what I described in my previous post. Otherwise, many tests from the new test suites described below would fail.\n\n**__Test Suites__**\n\nThe test suites of categories have been extended to test against the specification of the new features. In particular, the containers for morphisms and objects provide a test suite. The test suites for `C.morphisms()` and `C.objects()` and `C.hom_category()` are added to the test suite of `C`.\n\nThe patch adds a method `an_object()` to categories, that is used for additional tests. The default is to return `example()`, but this is not provided in all cases. The purpose of `an_object()` is narrower than that of `example()`, which is supposed to provide a concise instructive (but not necessarily very efficient) implementation. In contrast, `an_object()` may return an object of a subcategory, if nothing else is available. The test suite of `C.an_object()` becomes part of the test suite of `C`.\n\nSimilarly, I introduce a method `a_morphism`. By default, it takes the output of `an_object()`, tries to create an automorphism by reverting the list of generators, and if that fails then it returns the identity automorphism. The latter sounds trivial, but actually I found several cases where the identity automorphism was provided with the wrong category. This led to the following bug fixes:\n\n* In `sage.categories.homset.Hom`, there was an assymmetry between the categories of the domain and the codomain. I suggest to choose the *meet* of both categories. However, note that there was a comment like this:\n\n ```\n    To avoid creating superfluous categories, homsets are in the\n    homset category of the lowest category which currently says\n    something specific about its homsets.\n ```\n which meant that the endomorphisms of the rational field used to belong to the \"Category of hom sets in Category of rings\". I didn't observe any problems changing it into the \"Category of hom sets in Category of quotient fields\".\n\n* Without the patch:\n\n   ```\n   sage: F = GF(5); MS = MatrixSpace(F,2,2)\n   sage: G = MatrixGroup([MS([1,1,0,1])])\n   sage: H = MatrixGroup([MS([1,0,1,1])])\n   sage: phi = G.hom(H.gens())\n   sage: phi.category_for()\n   Category of groups\n   sage: H.category()\n   Category of finite groups\n   sage: G.category()\n   Category of finite groups\n  ```\n  Hence, the morphism belongs to a category that is too broad. With the patch:\n\n  ```\n  sage: F = GF(5); MS = MatrixSpace(F,2,2)\n  sage: G = MatrixGroup([MS([1,1,0,1])])\n  sage: H = MatrixGroup([MS([1,0,1,1])])\n  sage: phi = G.hom(H.gens())\n  sage: phi.category_for()\n  Category of finite groups\n  ```\n  In several cases I have not been able to find any proper use case in Sage for a given category. In these cases, I have not been able to provide `an_object()`, so that in these cases I have to skip some tests from the test suites:\n\n* `JoinCategory` (I guess it is impossible to construct a generic object of the join of two arbitrary categories)\n\n* `AbstractCategory` (Do I understand correctly that the abstract category for the category of `ZZ`-modules would be the catogory of modules? I.e., one abstracts the base ring away?)\n\n* `Schemes`:\n\n  ```\n  # Bug, not fixed in the patch\n  sage: Spec(QQ).category()\n  Category of sets\n  ```\n\n* `UniqueFactorizationDomains`\n\n  ```\n  # Bug, not fixed in the patch\n  sage: ZZ in UniqueFactorizationDomains()\n  False\n  ```\n\n* `AlgebraModules`:\n\n  ```\n  sage: QQ['x'] in Algebras(QQ)\n  True\n  # Bug?\n  sage: QQ['x']^3 in AlgebraModules(QQ['x'])\n  False\n  ```\n\n* `GSets` (Is there any G-set in Sage that knows that it is a G-set?)\n\n* `DualObjectsCategory`\n\n* `Sets().Subquotients()`\n\n* `FiniteDimensional...`: Most categories whose name starts with `FiniteDimensional` are not in use.\n\n* `PartiallyOrderedMonoids`\n\n* `MonoidAlgebras`\n\n* `TensorProductsCategory`\n\n\n* I added a minimal implementation of pointed sets:\n\n  ```\n  sage: from sage.categories.examples.pointed_sets import PointedSet\n  sage: S = PointedSet([1,2,3],2)\n  sage: S\n  {1, 2, 3} -> 2\n  sage: S is loads(dumps(S))\n  True\n  sage: S == PointedSet([1,2,3],3)\n  False\n  ```\n\n* I fixed the category of partially ordered sets.\n\n  Without patch:\n\n  ```\n  sage: from sage.combinat.posets.posets import Poset\n  sage: elms = [1,2,3,4,5,6,7]\n  sage: rels = [[1,2],[3,4],[4,5],[2,5]]\n  sage: Poset((elms, rels), cover_relations = True).category()\n  Category of sets\n  ```\n  With the patch, we obtain `Category of partially ordered sets`.\n\n* The category of matrix algebras has not been used. I added the obvious example:\n\n  ```\n  sage: MatrixSpace(QQ,2).category()\n  Category of matrix algebras over Rational Field\n  ```\n  which used to be the category of algebras (not: matrix algebras).\n\n**__Groupoids__**\n\nGroupoids are considered as a category with a single object. However, this object did not exist. The patch provides it, modeled as an empty set:\n\n```\nsage: G = SymmetricGroup(5)\nsage: C = Groupoid(G)\nsage: O = C.an_object(); O\nUnique object of Groupoid with underlying set SymmetricGroup(5)\nsage: len(O)\n0\nsage: O.an_element()\nTraceback (most recent call last):\n...\nEmptySetError: \n```\n\nThe elements of `G` correspond to morphisms of its groupoid. I suggest to actually consider them as morphisms (which is stronger than saying they *correspond to* morphisms):\n\n```\nsage: G.an_element() in C.morphisms()\nTrue\n```\n\nNote that this point of view is needed in order to have a functorial approach towards actions, namely: If we want to view a group action of `G` on a set `S` as a functor from the groupoid of `G` to the category containing `S` as an object, then \n\n1. we need that functors can map morphisms (see #8807), and\n\n2. we need that group elements are considered as morphisms.\n\nActually, that was the starting point for my work on this ticket.\n\nOn the other hand, I do think that considering `G` as a homset of `Groupoid(G)` is not a very clean solution. But I believe this could be addressed on a different ticket, as this one is already too long.\n\n**__Need for Speed__**\n\nOf course, testing containment in a category `C` or in `C.objects()` or in `C.morphisms()` should be as fast as possible. I did the following:\n\n* I added a shortpath to `C.__contains__` and `C.objects().__contains__` for the common case that the category of the argument is `C`.\n\n* `C.objects()` and `C.morphisms()` are cached methods. By #8611, the overhead is now pretty small anyway.\n\n* Containment of an object `O` in a category `C` relies on testing whether `O.category()` is a sub-category of `C`. This is cached, by #8611. In addition, I remove the overhead entirely, by directly accessing the cache.\n\n* The containers for objects and morphisms are implemented in Cython. The default containment test is copied from the category, in order to reduce the overhead of calling a Python function. Therefore, `F in O` (where `O = C.objects()`) is sometimes even a little quicker than `F in C`:\n\n ```\n sage: F = GF(5)\n sage: C = Rings()\n sage: O = C.objects()\n sage: F in O\n True\n sage: timeit('F in O',number=100000)\n 100000 loops, best of 3: 5.2 \u00b5s per loop\n sage: timeit('F in C',number=100000)\n 100000 loops, best of 3: 5.38 \u00b5s per loop\n ```\n\nHere are some timings. Their purpose is to show that `X in C` did not slow down (in fact, there is a speed-up in one special case), and that `X in C.objects()` has almost no overhead compared to `X in C`.\n\nSetting:\n\n```\nsage: G = SymmetricGroup(5)\nsage: P.<x,y> = QQ[]\nsage: F = PolynomialRing(QQ,[])\nsage: C1 = Rings()\nsage: C2 = G.category()\nsage: C3 = Fields()\n```\n\nSanity tests:\n\n```\n# test that X in C.objects() is the same as X in C\n# For C1:\nsage: P in C1\nTrue\nsage: P in C1.objects()\nTrue\nsage: G in C1\nFalse\nsage: G in C1.objects()\nFalse\nsage: F in C1\nTrue\nsage: F in C1.objects()\nTrue\n\n# For C2, which is a join (that's a special case):\nsage: P in C2\nFalse\nsage: P in C2.objects()\nFalse\nsage: G in C2\nTrue\nsage: G in C2.objects()\nTrue\nsage: F in C2\nFalse\nsage: F in C2.objects()\nFalse\n\n# For C3 (having a custom containment test):\nsage: P in C3\nFalse\nsage: P in C3.objects()\nFalse\nsage: G in C3\nFalse\nsage: G in C3.objects()\nFalse\nsage: F in C3\nTrue\nsage: F in C3.objects()\nTrue\n```\n\nTimings without the new patch (but with #10496, #10659, #8611 and #10467):\n\n```\n# containment in C1\nsage: timeit('P in C1',number=100000)\n100000 loops, best of 3: 11.1 \u00b5s per loop\nsage: timeit('G in C1',number=100000)\n100000 loops, best of 3: 4.32 \u00b5s per loop\nsage: timeit('F in C1',number=100000)\n100000 loops, best of 3: 11.9 \u00b5s per loop\n# containment in C2\nsage: timeit('P in C2',number=100000)\n100000 loops, best of 3: 11.1 \u00b5s per loop\nsage: timeit('G in C2',number=100000)\n100000 loops, best of 3: 4.2 \u00b5s per loop\nsage: timeit('F in C2',number=100000)\n100000 loops, best of 3: 11.5 \u00b5s per loop\n# containment in C3 (custom test for fields!)\nsage: timeit('P in C3',number=100000)\n100000 loops, best of 3: 16.1 \u00b5s per loop\nsage: timeit('G in C3',number=100000)\n100000 loops, best of 3: 20.5 \u00b5s per loop\nsage: timeit('F in C3',number=100000)\n100000 loops, best of 3: 17.9 \u00b5s per loop\n```\n\nTimings with the patch, including the new syntax `X in C.objects()`:\n\n```\n# containment in C1\nsage: timeit('P in C1',number=100000)\n100000 loops, best of 3: 9.29 \u00b5s per loop\nsage: timeit('P in C1.objects()',number=100000)\n100000 loops, best of 3: 9.85 \u00b5s per loop\nsage: timeit('G in C1',number=100000)\n100000 loops, best of 3: 1.91 \u00b5s per loop\nsage: timeit('G in C1.objects()',number=100000)\n100000 loops, best of 3: 2.45 \u00b5s per loop\nsage: timeit('F in C1',number=100000)\n100000 loops, best of 3: 9.51 \u00b5s per loop\nsage: timeit('F in C1.objects()',number=100000)\n100000 loops, best of 3: 10.2 \u00b5s per loop\n# containment in C2\nsage: timeit('P in C2',number=100000)\n100000 loops, best of 3: 9.2 \u00b5s per loop\nsage: timeit('P in C2.objects()',number=100000)\n100000 loops, best of 3: 9.85 \u00b5s per loop\n# using the shortpath, as G.category() is C2\nsage: timeit('G in C2',number=100000)\n100000 loops, best of 3: 836 ns per loop\nsage: timeit('G in C2.objects()',number=100000)\n100000 loops, best of 3: 1.52 \u00b5s per loop\nsage: timeit('F in C2',number=100000)\n100000 loops, best of 3: 9.52 \u00b5s per loop\nsage: timeit('F in C2.objects()',number=100000)\n100000 loops, best of 3: 10.3 \u00b5s per loop\n# containment in C3 (custom test for fields!)\nsage: timeit('P in C3',number=100000)\n100000 loops, best of 3: 14 \u00b5s per loop\nsage: timeit('P in C3.objects()',number=100000)\n100000 loops, best of 3: 15.9 \u00b5s per loop\nsage: timeit('G in C3',number=100000)\n100000 loops, best of 3: 15.7 \u00b5s per loop\nsage: timeit('G in C3.objects()',number=100000)\n100000 loops, best of 3: 18.3 \u00b5s per loop\nsage: timeit('F in C3',number=100000)\n100000 loops, best of 3: 15.6 \u00b5s per loop\nsage: timeit('F in C3.objects()',number=100000)\n100000 loops, best of 3: 17.3 \u00b5s per loop\n```\n\nOr, directly testing containment in the class of objects:\n\n```\nsage: O1 = C1.objects()\nsage: O2 = C2.objects()\nsage: O3 = C3.objects()\nsage: timeit('P in O1',number=100000)\n100000 loops, best of 3: 8.88 \u00b5s per loop\nsage: timeit('G in O1',number=100000)\n100000 loops, best of 3: 1.56 \u00b5s per loop\nsage: timeit('F in O1',number=100000)\n100000 loops, best of 3: 9.31 \u00b5s per loop\nsage: timeit('P in O2',number=100000)\n100000 loops, best of 3: 8.94 \u00b5s per loop\nsage: timeit('G in O2',number=100000)\n100000 loops, best of 3: 704 ns per loop\nsage: timeit('F in O2',number=100000)\n100000 loops, best of 3: 9.29 \u00b5s per loop\nsage: timeit('P in O3',number=100000)\n100000 loops, best of 3: 14.9 \u00b5s per loop\nsage: timeit('G in O3',number=100000)\n100000 loops, best of 3: 17.1 \u00b5s per loop\nsage: timeit('F in O3',number=100000)\n100000 loops, best of 3: 16.5 \u00b5s per loop\n```",
    "created_at": "2011-01-22T17:25:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140284",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:4'></a>
Depends on #10496, #10659, #8611, #10467

I wont to get the patch finally off my plate. So, here it is, although it isn't finished yet. 

My patch provides the following:

```
sage: C = Rings()
sage: P.<x,y> = QQ[]
sage: f = P.hom(reversed(P.gens()))
sage: C.has_morphism(f)
True
sage: C.morphisms()
Class of morphisms in category of rings
sage: f in C.morphisms()
True
# Currently, a category is acknowledged as "small"
# iff it is a sub-category of FiniteEnumeratedSets()
sage: FiniteFields().morphisms()
Set of morphisms in category of finite fields
sage: f in FiniteFields().morphisms()
False
sage: P in C
True
sage: C.objects()
Class of objects in category of rings
sage: P in C.objects()
True
sage: FiniteFields().objects()
Set of objects in category of finite fields
```

Note that I interprete `Objects()` (the top-category in Sage) as the "category of all classes", although this definition probably is not water-proof:

```
sage: C.objects().category()
Category of objects
sage: FiniteFields().objects().category()
Category of sets
```

Some categories have a custom containment test, e.g., the category of fields. The containment test of `C.objects()` automatically tests whether `C` has a custom containment, and uses it if it is the case:

```
sage: PolynomialRing(QQ,[]).category()
Category of commutative rings
sage: PolynomialRing(QQ,[]) in Fields()
True
sage: PolynomialRing(QQ,[]) in Fields().objects()
True
```

The documentation for the new containers for objects and morphisms are added to the Sage reference manual -- please have a look.

**__`SageObject` versus `CategoryObject`__**

`SageObject` and `CategoryObject` were almost identical. In particular, `SageObject` provided a method `category()`, that by default returned the "category of objects". In addition, the specifition says that `X` is an object of `X.category()`, i.e., `X in X.category()`.

But that approach yields to quite unnatural constructions. For example, `1.category()` used to be the "category of elements of Integer Ring", whatever that means. Worse, one used to have

```
# Unpatched behaviour: Bug
sage: ZZ.hom([1]) in Rings().hom_category()
True
```
In other words, a *ring homomorphism* is considered a *homset* of the category of rings - of course, it should just be an *element* of a homset:

```
# With the patch:
sage: ZZ.hom([1]) in Rings().hom_category()
False
sage: ZZ.hom([1]) in ZZ.Hom(ZZ)
True
sage: ZZ.hom([1]) in Rings().morphisms()
True
```

Fixing that bug required to re-structure `SageObject` and `CategoryObject`:

* I removed `category()` and `_test_category()` from `SageObject` and moved it to `CategoryObject` (which directly inherits from `SageObject` anyway).
* I made `Element` and `Map` inherit from `SageObject`, not from `CategoryObject`, and removed the custom `category()` for `Element`. Of course, `Parent` still inherits from `CategoryObject`.

Note that by this change, it is now impossible to define nonsense such as `Hom(2,3)` (2 and 3 used to be objects in a category, so, there was a hom-set!).

**__Hom-categories__**

**Compare #10668**: This part of my patch is not finished, yet. I suppose that eventually this ticket here will depend on #10668.

Just for now, I implemented what I described in my previous post. Otherwise, many tests from the new test suites described below would fail.

**__Test Suites__**

The test suites of categories have been extended to test against the specification of the new features. In particular, the containers for morphisms and objects provide a test suite. The test suites for `C.morphisms()` and `C.objects()` and `C.hom_category()` are added to the test suite of `C`.

The patch adds a method `an_object()` to categories, that is used for additional tests. The default is to return `example()`, but this is not provided in all cases. The purpose of `an_object()` is narrower than that of `example()`, which is supposed to provide a concise instructive (but not necessarily very efficient) implementation. In contrast, `an_object()` may return an object of a subcategory, if nothing else is available. The test suite of `C.an_object()` becomes part of the test suite of `C`.

Similarly, I introduce a method `a_morphism`. By default, it takes the output of `an_object()`, tries to create an automorphism by reverting the list of generators, and if that fails then it returns the identity automorphism. The latter sounds trivial, but actually I found several cases where the identity automorphism was provided with the wrong category. This led to the following bug fixes:

* In `sage.categories.homset.Hom`, there was an assymmetry between the categories of the domain and the codomain. I suggest to choose the *meet* of both categories. However, note that there was a comment like this:

 ```
    To avoid creating superfluous categories, homsets are in the
    homset category of the lowest category which currently says
    something specific about its homsets.
 ```
 which meant that the endomorphisms of the rational field used to belong to the "Category of hom sets in Category of rings". I didn't observe any problems changing it into the "Category of hom sets in Category of quotient fields".

* Without the patch:

   ```
   sage: F = GF(5); MS = MatrixSpace(F,2,2)
   sage: G = MatrixGroup([MS([1,1,0,1])])
   sage: H = MatrixGroup([MS([1,0,1,1])])
   sage: phi = G.hom(H.gens())
   sage: phi.category_for()
   Category of groups
   sage: H.category()
   Category of finite groups
   sage: G.category()
   Category of finite groups
  ```
  Hence, the morphism belongs to a category that is too broad. With the patch:

  ```
  sage: F = GF(5); MS = MatrixSpace(F,2,2)
  sage: G = MatrixGroup([MS([1,1,0,1])])
  sage: H = MatrixGroup([MS([1,0,1,1])])
  sage: phi = G.hom(H.gens())
  sage: phi.category_for()
  Category of finite groups
  ```
  In several cases I have not been able to find any proper use case in Sage for a given category. In these cases, I have not been able to provide `an_object()`, so that in these cases I have to skip some tests from the test suites:

* `JoinCategory` (I guess it is impossible to construct a generic object of the join of two arbitrary categories)

* `AbstractCategory` (Do I understand correctly that the abstract category for the category of `ZZ`-modules would be the catogory of modules? I.e., one abstracts the base ring away?)

* `Schemes`:

  ```
  # Bug, not fixed in the patch
  sage: Spec(QQ).category()
  Category of sets
  ```

* `UniqueFactorizationDomains`

  ```
  # Bug, not fixed in the patch
  sage: ZZ in UniqueFactorizationDomains()
  False
  ```

* `AlgebraModules`:

  ```
  sage: QQ['x'] in Algebras(QQ)
  True
  # Bug?
  sage: QQ['x']^3 in AlgebraModules(QQ['x'])
  False
  ```

* `GSets` (Is there any G-set in Sage that knows that it is a G-set?)

* `DualObjectsCategory`

* `Sets().Subquotients()`

* `FiniteDimensional...`: Most categories whose name starts with `FiniteDimensional` are not in use.

* `PartiallyOrderedMonoids`

* `MonoidAlgebras`

* `TensorProductsCategory`


* I added a minimal implementation of pointed sets:

  ```
  sage: from sage.categories.examples.pointed_sets import PointedSet
  sage: S = PointedSet([1,2,3],2)
  sage: S
  {1, 2, 3} -> 2
  sage: S is loads(dumps(S))
  True
  sage: S == PointedSet([1,2,3],3)
  False
  ```

* I fixed the category of partially ordered sets.

  Without patch:

  ```
  sage: from sage.combinat.posets.posets import Poset
  sage: elms = [1,2,3,4,5,6,7]
  sage: rels = [[1,2],[3,4],[4,5],[2,5]]
  sage: Poset((elms, rels), cover_relations = True).category()
  Category of sets
  ```
  With the patch, we obtain `Category of partially ordered sets`.

* The category of matrix algebras has not been used. I added the obvious example:

  ```
  sage: MatrixSpace(QQ,2).category()
  Category of matrix algebras over Rational Field
  ```
  which used to be the category of algebras (not: matrix algebras).

**__Groupoids__**

Groupoids are considered as a category with a single object. However, this object did not exist. The patch provides it, modeled as an empty set:

```
sage: G = SymmetricGroup(5)
sage: C = Groupoid(G)
sage: O = C.an_object(); O
Unique object of Groupoid with underlying set SymmetricGroup(5)
sage: len(O)
0
sage: O.an_element()
Traceback (most recent call last):
...
EmptySetError: 
```

The elements of `G` correspond to morphisms of its groupoid. I suggest to actually consider them as morphisms (which is stronger than saying they *correspond to* morphisms):

```
sage: G.an_element() in C.morphisms()
True
```

Note that this point of view is needed in order to have a functorial approach towards actions, namely: If we want to view a group action of `G` on a set `S` as a functor from the groupoid of `G` to the category containing `S` as an object, then 

1. we need that functors can map morphisms (see #8807), and

2. we need that group elements are considered as morphisms.

Actually, that was the starting point for my work on this ticket.

On the other hand, I do think that considering `G` as a homset of `Groupoid(G)` is not a very clean solution. But I believe this could be addressed on a different ticket, as this one is already too long.

**__Need for Speed__**

Of course, testing containment in a category `C` or in `C.objects()` or in `C.morphisms()` should be as fast as possible. I did the following:

* I added a shortpath to `C.__contains__` and `C.objects().__contains__` for the common case that the category of the argument is `C`.

* `C.objects()` and `C.morphisms()` are cached methods. By #8611, the overhead is now pretty small anyway.

* Containment of an object `O` in a category `C` relies on testing whether `O.category()` is a sub-category of `C`. This is cached, by #8611. In addition, I remove the overhead entirely, by directly accessing the cache.

* The containers for objects and morphisms are implemented in Cython. The default containment test is copied from the category, in order to reduce the overhead of calling a Python function. Therefore, `F in O` (where `O = C.objects()`) is sometimes even a little quicker than `F in C`:

 ```
 sage: F = GF(5)
 sage: C = Rings()
 sage: O = C.objects()
 sage: F in O
 True
 sage: timeit('F in O',number=100000)
 100000 loops, best of 3: 5.2 µs per loop
 sage: timeit('F in C',number=100000)
 100000 loops, best of 3: 5.38 µs per loop
 ```

Here are some timings. Their purpose is to show that `X in C` did not slow down (in fact, there is a speed-up in one special case), and that `X in C.objects()` has almost no overhead compared to `X in C`.

Setting:

```
sage: G = SymmetricGroup(5)
sage: P.<x,y> = QQ[]
sage: F = PolynomialRing(QQ,[])
sage: C1 = Rings()
sage: C2 = G.category()
sage: C3 = Fields()
```

Sanity tests:

```
# test that X in C.objects() is the same as X in C
# For C1:
sage: P in C1
True
sage: P in C1.objects()
True
sage: G in C1
False
sage: G in C1.objects()
False
sage: F in C1
True
sage: F in C1.objects()
True

# For C2, which is a join (that's a special case):
sage: P in C2
False
sage: P in C2.objects()
False
sage: G in C2
True
sage: G in C2.objects()
True
sage: F in C2
False
sage: F in C2.objects()
False

# For C3 (having a custom containment test):
sage: P in C3
False
sage: P in C3.objects()
False
sage: G in C3
False
sage: G in C3.objects()
False
sage: F in C3
True
sage: F in C3.objects()
True
```

Timings without the new patch (but with #10496, #10659, #8611 and #10467):

```
# containment in C1
sage: timeit('P in C1',number=100000)
100000 loops, best of 3: 11.1 µs per loop
sage: timeit('G in C1',number=100000)
100000 loops, best of 3: 4.32 µs per loop
sage: timeit('F in C1',number=100000)
100000 loops, best of 3: 11.9 µs per loop
# containment in C2
sage: timeit('P in C2',number=100000)
100000 loops, best of 3: 11.1 µs per loop
sage: timeit('G in C2',number=100000)
100000 loops, best of 3: 4.2 µs per loop
sage: timeit('F in C2',number=100000)
100000 loops, best of 3: 11.5 µs per loop
# containment in C3 (custom test for fields!)
sage: timeit('P in C3',number=100000)
100000 loops, best of 3: 16.1 µs per loop
sage: timeit('G in C3',number=100000)
100000 loops, best of 3: 20.5 µs per loop
sage: timeit('F in C3',number=100000)
100000 loops, best of 3: 17.9 µs per loop
```

Timings with the patch, including the new syntax `X in C.objects()`:

```
# containment in C1
sage: timeit('P in C1',number=100000)
100000 loops, best of 3: 9.29 µs per loop
sage: timeit('P in C1.objects()',number=100000)
100000 loops, best of 3: 9.85 µs per loop
sage: timeit('G in C1',number=100000)
100000 loops, best of 3: 1.91 µs per loop
sage: timeit('G in C1.objects()',number=100000)
100000 loops, best of 3: 2.45 µs per loop
sage: timeit('F in C1',number=100000)
100000 loops, best of 3: 9.51 µs per loop
sage: timeit('F in C1.objects()',number=100000)
100000 loops, best of 3: 10.2 µs per loop
# containment in C2
sage: timeit('P in C2',number=100000)
100000 loops, best of 3: 9.2 µs per loop
sage: timeit('P in C2.objects()',number=100000)
100000 loops, best of 3: 9.85 µs per loop
# using the shortpath, as G.category() is C2
sage: timeit('G in C2',number=100000)
100000 loops, best of 3: 836 ns per loop
sage: timeit('G in C2.objects()',number=100000)
100000 loops, best of 3: 1.52 µs per loop
sage: timeit('F in C2',number=100000)
100000 loops, best of 3: 9.52 µs per loop
sage: timeit('F in C2.objects()',number=100000)
100000 loops, best of 3: 10.3 µs per loop
# containment in C3 (custom test for fields!)
sage: timeit('P in C3',number=100000)
100000 loops, best of 3: 14 µs per loop
sage: timeit('P in C3.objects()',number=100000)
100000 loops, best of 3: 15.9 µs per loop
sage: timeit('G in C3',number=100000)
100000 loops, best of 3: 15.7 µs per loop
sage: timeit('G in C3.objects()',number=100000)
100000 loops, best of 3: 18.3 µs per loop
sage: timeit('F in C3',number=100000)
100000 loops, best of 3: 15.6 µs per loop
sage: timeit('F in C3.objects()',number=100000)
100000 loops, best of 3: 17.3 µs per loop
```

Or, directly testing containment in the class of objects:

```
sage: O1 = C1.objects()
sage: O2 = C2.objects()
sage: O3 = C3.objects()
sage: timeit('P in O1',number=100000)
100000 loops, best of 3: 8.88 µs per loop
sage: timeit('G in O1',number=100000)
100000 loops, best of 3: 1.56 µs per loop
sage: timeit('F in O1',number=100000)
100000 loops, best of 3: 9.31 µs per loop
sage: timeit('P in O2',number=100000)
100000 loops, best of 3: 8.94 µs per loop
sage: timeit('G in O2',number=100000)
100000 loops, best of 3: 704 ns per loop
sage: timeit('F in O2',number=100000)
100000 loops, best of 3: 9.29 µs per loop
sage: timeit('P in O3',number=100000)
100000 loops, best of 3: 14.9 µs per loop
sage: timeit('G in O3',number=100000)
100000 loops, best of 3: 17.1 µs per loop
sage: timeit('F in O3',number=100000)
100000 loops, best of 3: 16.5 µs per loop
```



---

archive/issue_comments_140285.json:
```json
{
    "body": "**Author:** Simon King",
    "created_at": "2011-01-22T17:25:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140285",
    "user": "https://github.com/simon-king-jena"
}
```

**Author:** Simon King



---

archive/issue_comments_140286.json:
```json
{
    "body": "<a id='comment:5'></a>\nSo, what's the status of the ticket?\n\nI need more info!\n\nFirst thing: I am still not happy with the groupoids. But can this perhaps be solved in a different ticket?\n\nSecond and more urgent thing? Why does my example of pointed sets not inherit from `PointedSets().parent_class`? What did I do wrong? I asked on sage-support, but didn't receive a reply.\n\nThe problem is:\n\n```\nsage: from sage.categories.examples.pointed_sets import PointedSet\nsage: S = PointedSet([1,2,3],2)\nsage: S.category()\nCategory of pointed sets\nsage: S.__class__\n<class 'sage.categories.examples.pointed_sets.PointedSet_with_category'>\n```\nSo, the category is initialised. But:\n\n```\nsage: isinstance(S,PointedSets().parent_class)\nFalse\n```\n\nWhat goes wrong in my implementation?",
    "created_at": "2011-01-22T17:29:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140286",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:5'></a>
So, what's the status of the ticket?

I need more info!

First thing: I am still not happy with the groupoids. But can this perhaps be solved in a different ticket?

Second and more urgent thing? Why does my example of pointed sets not inherit from `PointedSets().parent_class`? What did I do wrong? I asked on sage-support, but didn't receive a reply.

The problem is:

```
sage: from sage.categories.examples.pointed_sets import PointedSet
sage: S = PointedSet([1,2,3],2)
sage: S.category()
Category of pointed sets
sage: S.__class__
<class 'sage.categories.examples.pointed_sets.PointedSet_with_category'>
```
So, the category is initialised. But:

```
sage: isinstance(S,PointedSets().parent_class)
False
```

What goes wrong in my implementation?



---

archive/issue_comments_140287.json:
```json
{
    "body": "**Changing status** from new to needs_info.",
    "created_at": "2011-01-22T17:29:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140287",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from new to needs_info.



---

archive/issue_comments_140288.json:
```json
{
    "body": "<a id='comment:6'></a>\nHi Simon!\n\nI have only browsed quickly through this yet. I'll try to have a look\nsoon at the broken parent you mention in the other comment. Just some\nsmall comments before heading for my bed.\n\n>  * In `sage.categories.homset.Hom`, there was an assymmetry between the categories of the domain and the codomain. I suggest to choose the *meet* of both categories. However, note that there was a comment like this:\n>  \n>  ```\n>     To avoid creating superfluous categories, homsets are in the\n>     homset category of the lowest category which currently says\n>     something specific about its homsets.\n>  ```\n>  which meant that the endomorphisms of the rational field used to belong to the \"Category of hom sets in Category of rings\". I didn't observe any problems changing it into the \"Category of hom sets in Category of quotient fields\".\n\n\nI wrote this comment. This won't break indeed, but there might\neventually be a penalty in creating that many categories. I need to\nthink back about it, but this comment might become irrelevant since we\nare going to break the inheritance in-between hom categories.\n\n>  * `AbstractCategory` (Do I understand correctly that the abstract category for the category of `ZZ`-modules would be the catogory of modules? I.e., one abstracts the base ring away?)\n\n\nAs I said, don't bother understanding: that's going to be removed. If\nit gets in your way, just kill the beast, and remove right now\neverything about AbstractCategory (typically by taking over the\nappropriate bits of the patch I mentioned).",
    "created_at": "2011-01-22T23:10:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140288",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:6'></a>
Hi Simon!

I have only browsed quickly through this yet. I'll try to have a look
soon at the broken parent you mention in the other comment. Just some
small comments before heading for my bed.

>  * In `sage.categories.homset.Hom`, there was an assymmetry between the categories of the domain and the codomain. I suggest to choose the *meet* of both categories. However, note that there was a comment like this:
>  
>  ```
>     To avoid creating superfluous categories, homsets are in the
>     homset category of the lowest category which currently says
>     something specific about its homsets.
>  ```
>  which meant that the endomorphisms of the rational field used to belong to the "Category of hom sets in Category of rings". I didn't observe any problems changing it into the "Category of hom sets in Category of quotient fields".


I wrote this comment. This won't break indeed, but there might
eventually be a penalty in creating that many categories. I need to
think back about it, but this comment might become irrelevant since we
are going to break the inheritance in-between hom categories.

>  * `AbstractCategory` (Do I understand correctly that the abstract category for the category of `ZZ`-modules would be the catogory of modules? I.e., one abstracts the base ring away?)


As I said, don't bother understanding: that's going to be removed. If
it gets in your way, just kill the beast, and remove right now
everything about AbstractCategory (typically by taking over the
appropriate bits of the patch I mentioned).



---

archive/issue_comments_140289.json:
```json
{
    "body": "<a id='comment:7'></a>\nThanks to Nicolas for his comments on sage-algebra explaining why my example of pointed sets didn't work well. It is now fixed. Hence, ready for review!",
    "created_at": "2011-01-24T12:12:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140289",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>
Thanks to Nicolas for his comments on sage-algebra explaining why my example of pointed sets didn't work well. It is now fixed. Hence, ready for review!



---

archive/issue_comments_140290.json:
```json
{
    "body": "**Changing status** from needs_info to needs_review.",
    "created_at": "2011-01-24T12:12:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140290",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from needs_info to needs_review.



---

archive/issue_comments_140291.json:
```json
{
    "body": "<a id='comment:8'></a>\nI updated the patch, so that it now applies to `sage-4.6.2.alpha4`. There are no dependencies.",
    "created_at": "2011-02-11T07:55:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140291",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>
I updated the patch, so that it now applies to `sage-4.6.2.alpha4`. There are no dependencies.



---

archive/issue_comments_140292.json:
```json
{
    "body": "<a id='comment:9'></a>\nSince the patchbot keeps complaining that the patch did not apply to good old sage-4.6.1 and since I just verified once again that the patch cleanly applies to sage-4.6.2.alpha4, I replaced the patch by an identical copy and hope that it pushes the patchbot to try it another time with the new sage version.",
    "created_at": "2011-02-18T07:56:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140292",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>
Since the patchbot keeps complaining that the patch did not apply to good old sage-4.6.1 and since I just verified once again that the patch cleanly applies to sage-4.6.2.alpha4, I replaced the patch by an identical copy and hope that it pushes the patchbot to try it another time with the new sage version.



---

archive/issue_comments_140293.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2011-08-29T06:45:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140293",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_140294.json:
```json
{
    "body": "<a id='comment:10'></a>\nOn #9054, William expressed his anger about category containment tests being too slow. That reminded me of the ticket here. Since the patches do not apply, it needs work. But I guess it is worth while to resume work on that ticket.",
    "created_at": "2011-08-29T06:45:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140294",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:10'></a>
On #9054, William expressed his anger about category containment tests being too slow. That reminded me of the ticket here. Since the patches do not apply, it needs work. But I guess it is worth while to resume work on that ticket.



---

archive/issue_comments_140295.json:
```json
{
    "body": "<a id='comment:11'></a>\nI have updated the patch, so that it should apply against sage-4.7.2.alpha2. I did not run tests, yet. Here are some timings:\n\n```\nsage: from sage.rings.commutative_ring import is_CommutativeRing\nsage: %timeit is_CommutativeRing(QQ)\n625 loops, best of 3: 1.09 \u00b5s per loop\nsage: C = CommutativeRings().objects()\nsage: %timeit QQ in C\n625 loops, best of 3: 3.82 \u00b5s per loop\n```\n\n`is_CommutativeRing` simply tests whether `QQ` is an instance of `sage.rings.ring.CommutativeRing`, which is of course very fast (but not very reliable from a mathematical point of view.\n\nAnyway, I try to squeeze `QQ in C` a bit more.",
    "created_at": "2011-08-29T10:02:55Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140295",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:11'></a>
I have updated the patch, so that it should apply against sage-4.7.2.alpha2. I did not run tests, yet. Here are some timings:

```
sage: from sage.rings.commutative_ring import is_CommutativeRing
sage: %timeit is_CommutativeRing(QQ)
625 loops, best of 3: 1.09 µs per loop
sage: C = CommutativeRings().objects()
sage: %timeit QQ in C
625 loops, best of 3: 3.82 µs per loop
```

`is_CommutativeRing` simply tests whether `QQ` is an instance of `sage.rings.ring.CommutativeRing`, which is of course very fast (but not very reliable from a mathematical point of view.

Anyway, I try to squeeze `QQ in C` a bit more.



---

archive/issue_comments_140296.json:
```json
{
    "body": "<a id='comment:12'></a>\nI created a new version of my patch. The aim is to make the performance of containment tests even better. I did the following, compared with the old patch:\n\n* I make the patch dependent on #9138 and #11115 (both help to come to speed).\n\n* I've put power series rings into the category and coercion framework.\n\n* I introduced base() for join categories: If at least one of the underlying categories has a base and if there is no conflict with different bases, then the join shall have that base as well. That is needed because some algebras have a join category by #9138.\n\n* SimplicialComplex has not been derived from CategoryObject, even though its instances are objects of a category! I corrected it.\n\n* GroupAlgebras should not only be Hopf algebras with basis but also group algebras. Hence, I made it a join of the two.\n\n* I implemented is_supercategory (there has only been is_subcategory), and use it to make containment tests even faster. It depends on #11115, because I use the Cython class of cached methods.\n\nI guess the best news is that the containment test via category framework can now compete with a pure class check, if that class check is done in Python. I take, for example, commutative rings:\n\n```\nsage: from sage.rings.commutative_ring import is_CommutativeRing\nsage: is_CommutativeRing??\nType:           function\nBase Class:     <type 'function'>\nString Form:    <function is_CommutativeRing at 0x118c488>\nNamespace:      Interactive\nFile:           /mnt/local/king/SAGE/sandbox/sage-4.7.2.alpha2/local/lib/python2.6/site-packages/sage/rings/commutative_ring.py\nDefinition:     is_CommutativeRing(R)\nSource:\ndef is_CommutativeRing(R):\n    return isinstance(R, CommutativeRing)\nsage: is_CommutativeRing(QQ)\nTrue\nsage: s = SymmetricGroup(4)\nsage: is_CommutativeRing(s)\nFalse\nsage: %timeit is_CommutativeRing(QQ)\n625 loops, best of 3: 1.09 \u00b5s per loop\nsage: %timeit is_CommutativeRing(s)\n625 loops, best of 3: 3.51 \u00b5s per loop\n```\n\nSince `is_CommutativeRing` just tests the class, it is supposed to be very fast. But let us compare with the generic containment test in the category of commutative rings and in the class of objects of that category:\n\n```\nsage: C = CommutativeRings()\nsage: O = C.objects()\nsage: QQ in C\nTrue\nsage: QQ in O\nTrue\nsage: s in C\nFalse\nsage: s in O\nFalse\nsage: %timeit QQ in C\n625 loops, best of 3: 4.62 \u00b5s per loop\n# Timing in sage-4.6.2: 12.9 \u00b5s per loop\nsage: %timeit QQ in O\n625 loops, best of 3: 1.5 \u00b5s per loop\nsage: %timeit s in C\n625 loops, best of 3: 4.69 \u00b5s per loop\n# Timing in sage-4.6.2: 10.2 \u00b5s per loop\nsage: %timeit s in O\n625 loops, best of 3: 1.46 \u00b5s per loop\n```\n\nHence, `is_CommutativeRing(s)` is slower than `s in O`, where `O = CommutativeRings().objects()`.\n\nThe reason for that speedup is Cython. While `is_CommutativeRing` is a Python function, the objects of a category are implemented in Cython. Moreover, category containment is tested by the cached method `is_supercategory`, which also is in Cython by #9138.\n\nCaveat: I did not run the full tests, yet, and I would like to try and remove some custom containment tests in the category framework, that tend to be slower than the generic test and might not be needed with #9138.",
    "created_at": "2011-08-30T09:49:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140296",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:12'></a>
I created a new version of my patch. The aim is to make the performance of containment tests even better. I did the following, compared with the old patch:

* I make the patch dependent on #9138 and #11115 (both help to come to speed).

* I've put power series rings into the category and coercion framework.

* I introduced base() for join categories: If at least one of the underlying categories has a base and if there is no conflict with different bases, then the join shall have that base as well. That is needed because some algebras have a join category by #9138.

* SimplicialComplex has not been derived from CategoryObject, even though its instances are objects of a category! I corrected it.

* GroupAlgebras should not only be Hopf algebras with basis but also group algebras. Hence, I made it a join of the two.

* I implemented is_supercategory (there has only been is_subcategory), and use it to make containment tests even faster. It depends on #11115, because I use the Cython class of cached methods.

I guess the best news is that the containment test via category framework can now compete with a pure class check, if that class check is done in Python. I take, for example, commutative rings:

```
sage: from sage.rings.commutative_ring import is_CommutativeRing
sage: is_CommutativeRing??
Type:           function
Base Class:     <type 'function'>
String Form:    <function is_CommutativeRing at 0x118c488>
Namespace:      Interactive
File:           /mnt/local/king/SAGE/sandbox/sage-4.7.2.alpha2/local/lib/python2.6/site-packages/sage/rings/commutative_ring.py
Definition:     is_CommutativeRing(R)
Source:
def is_CommutativeRing(R):
    return isinstance(R, CommutativeRing)
sage: is_CommutativeRing(QQ)
True
sage: s = SymmetricGroup(4)
sage: is_CommutativeRing(s)
False
sage: %timeit is_CommutativeRing(QQ)
625 loops, best of 3: 1.09 µs per loop
sage: %timeit is_CommutativeRing(s)
625 loops, best of 3: 3.51 µs per loop
```

Since `is_CommutativeRing` just tests the class, it is supposed to be very fast. But let us compare with the generic containment test in the category of commutative rings and in the class of objects of that category:

```
sage: C = CommutativeRings()
sage: O = C.objects()
sage: QQ in C
True
sage: QQ in O
True
sage: s in C
False
sage: s in O
False
sage: %timeit QQ in C
625 loops, best of 3: 4.62 µs per loop
# Timing in sage-4.6.2: 12.9 µs per loop
sage: %timeit QQ in O
625 loops, best of 3: 1.5 µs per loop
sage: %timeit s in C
625 loops, best of 3: 4.69 µs per loop
# Timing in sage-4.6.2: 10.2 µs per loop
sage: %timeit s in O
625 loops, best of 3: 1.46 µs per loop
```

Hence, `is_CommutativeRing(s)` is slower than `s in O`, where `O = CommutativeRings().objects()`.

The reason for that speedup is Cython. While `is_CommutativeRing` is a Python function, the objects of a category are implemented in Cython. Moreover, category containment is tested by the cached method `is_supercategory`, which also is in Cython by #9138.

Caveat: I did not run the full tests, yet, and I would like to try and remove some custom containment tests in the category framework, that tend to be slower than the generic test and might not be needed with #9138.



---

archive/issue_comments_140297.json:
```json
{
    "body": "**Changing status** from needs_work to needs_review.",
    "created_at": "2011-08-30T09:49:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140297",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from needs_work to needs_review.



---

archive/issue_comments_140298.json:
```json
{
    "body": "**Dependencies:** #9138, #11115",
    "created_at": "2011-08-30T09:49:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140298",
    "user": "https://github.com/simon-king-jena"
}
```

**Dependencies:** #9138, #11115



---

archive/issue_comments_140299.json:
```json
{
    "body": "<a id='comment:13'></a>\nI forgot to mention that I also improved `is_Ring`.\n\nWith sage-4.7.2.alpha1 plus #9138 and #11115:\n\n```\nsage: from sage.rings.ring import is_Ring\nsage: MS = MatrixSpace(QQ,2)\nsage: %timeit is_Ring(QQ)\n625 loops, best of 3: 5.1 \u00b5s per loop\nsage: %timeit is_Ring(MS)\n625 loops, best of 3: 17.3 \u00b5s per loop\nsage: C = Rings()\nsage: %timeit QQ in C\n625 loops, best of 3: 4.18 \u00b5s per loop\nsage: %timeit MS in C\n625 loops, best of 3: 4.31 \u00b5s per loop\n```\n\nWith sage-4.7.2.alpha2 plus #9138 and #11115 and the patch from here:\n\n```\nsage: from sage.rings.ring import is_Ring\nsage: MS = MatrixSpace(QQ,2)\nsage: %timeit is_Ring(QQ)\n625 loops, best of 3: 259 ns per loop\nsage: %timeit is_Ring(MS)\n625 loops, best of 3: 17.5 \u00b5s per loop\nsage: C = Rings().objects()\nsage: %timeit QQ in C\n625 loops, best of 3: 1.49 \u00b5s per loop\nsage: %timeit MS in C\n625 loops, best of 3: 1.57 \u00b5s per loop\n```",
    "created_at": "2011-08-30T09:54:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140299",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:13'></a>
I forgot to mention that I also improved `is_Ring`.

With sage-4.7.2.alpha1 plus #9138 and #11115:

```
sage: from sage.rings.ring import is_Ring
sage: MS = MatrixSpace(QQ,2)
sage: %timeit is_Ring(QQ)
625 loops, best of 3: 5.1 µs per loop
sage: %timeit is_Ring(MS)
625 loops, best of 3: 17.3 µs per loop
sage: C = Rings()
sage: %timeit QQ in C
625 loops, best of 3: 4.18 µs per loop
sage: %timeit MS in C
625 loops, best of 3: 4.31 µs per loop
```

With sage-4.7.2.alpha2 plus #9138 and #11115 and the patch from here:

```
sage: from sage.rings.ring import is_Ring
sage: MS = MatrixSpace(QQ,2)
sage: %timeit is_Ring(QQ)
625 loops, best of 3: 259 ns per loop
sage: %timeit is_Ring(MS)
625 loops, best of 3: 17.5 µs per loop
sage: C = Rings().objects()
sage: %timeit QQ in C
625 loops, best of 3: 1.49 µs per loop
sage: %timeit MS in C
625 loops, best of 3: 1.57 µs per loop
```



---

archive/issue_comments_140300.json:
```json
{
    "body": "<a id='comment:14'></a>\nI leave it as \"needs review\", but I think I have to adopt the Cython improvements on morphism containment tests as well.",
    "created_at": "2011-08-30T10:10:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140300",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>
I leave it as "needs review", but I think I have to adopt the Cython improvements on morphism containment tests as well.



---

archive/issue_events_032890.json:
```json
{
    "actor": "https://github.com/simon-king-jena",
    "created_at": "2011-08-30T10:10:48Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "milestone": "sage-5.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10667#event-32890"
}
```



---

archive/issue_comments_140301.json:
```json
{
    "body": "**Changing status** from needs_review to needs_work.",
    "created_at": "2011-08-30T11:53:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140301",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing status** from needs_review to needs_work.



---

archive/issue_comments_140302.json:
```json
{
    "body": "**Work_Issues:** doctests",
    "created_at": "2011-08-30T11:53:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140302",
    "user": "https://github.com/simon-king-jena"
}
```

**Work_Issues:** doctests



---

archive/issue_comments_140303.json:
```json
{
    "body": "<a id='comment:15'></a>\nReplying to [SimonKing](#comment%3A14):\n> I leave it as \"needs review\", but I think I have to adopt the Cython improvements on morphism containment tests as well.\n\n\nNope, it wouldn't easily work for the morphisms.\n\nIt turns out that I have to fix many doctests.",
    "created_at": "2011-08-30T11:53:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140303",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:15'></a>
Replying to [SimonKing](#comment%3A14):
> I leave it as "needs review", but I think I have to adopt the Cython improvements on morphism containment tests as well.


Nope, it wouldn't easily work for the morphisms.

It turns out that I have to fix many doctests.



---

archive/issue_comments_140304.json:
```json
{
    "body": "<a id='comment:16'></a>\nIt is a very bad error, and I don't know at which point I introduced it. It is about incompatible method resolution orders:\n\n```\nsage: class Foo(Homset, Objects().HomCategory(Objects()).parent_class): pass\n....: \n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n\n/mnt/local/king/SAGE/sandbox/sage-4.7.2.alpha2/devel/sage-main/<ipython console> in <module>()\n\nTypeError: Error when calling the metaclass bases\n    Cannot create a consistent method resolution\norder (MRO) for bases Homset, Objects.HomCategory.parent_class\n```\n\nIt seems that the problem is in the order in which the two classes are presented:\n\n```\nsage: class Foo(Objects().HomCategory(Objects()).parent_class, Homset): pass\n....: \nsage:\n```",
    "created_at": "2011-08-30T12:28:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140304",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:16'></a>
It is a very bad error, and I don't know at which point I introduced it. It is about incompatible method resolution orders:

```
sage: class Foo(Homset, Objects().HomCategory(Objects()).parent_class): pass
....: 
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/mnt/local/king/SAGE/sandbox/sage-4.7.2.alpha2/devel/sage-main/<ipython console> in <module>()

TypeError: Error when calling the metaclass bases
    Cannot create a consistent method resolution
order (MRO) for bases Homset, Objects.HomCategory.parent_class
```

It seems that the problem is in the order in which the two classes are presented:

```
sage: class Foo(Objects().HomCategory(Objects()).parent_class, Homset): pass
....: 
sage:
```



---

archive/issue_comments_140305.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [SimonKing](#comment%3A16):\n> It is a very bad error, and I don't know at which point I introduced it. It is about incompatible method resolution orders:\n> \n> ```\n> sage: class Foo(Homset, Objects().HomCategory(Objects()).parent_class): pass\n> order (MRO) for bases Homset, Objects.HomCategory.parent_class\n> ```\n\n\nYeah, this kind of error can be quite tricky indeed. This is the very\ntechnical bit where I am bit uneasy about the future scaling of\ncategories using dynamic classes. The only way to avoid such errors\nsanely is to specify general rules about the order of the base classes\nof a class. There are very minimal comments about that at the end of\nthe primer. Reducing the risk of this kind of issue is also one of the\ngoal of #10963 (the more is done automatically, the higher are the\nchances of consistency).\n\n> It seems that the problem is in the order in which the two classes are presented:\n> \n> ```\n> sage: class Foo(Objects().HomCategory(Objects()).parent_class, Homset): pass\n> ....: \n> sage:\n> ```\n\n\nHere, I would say that the rule is that category code (in particular\nwhat comes from a_category.parent_class) should always come after\nconcrete classes.\n\nGood luck!\n\nBy the way: congrats on all your category optimization work. I love it!",
    "created_at": "2011-08-30T13:10:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140305",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:17'></a>
Replying to [SimonKing](#comment%3A16):
> It is a very bad error, and I don't know at which point I introduced it. It is about incompatible method resolution orders:
> 
> ```
> sage: class Foo(Homset, Objects().HomCategory(Objects()).parent_class): pass
> order (MRO) for bases Homset, Objects.HomCategory.parent_class
> ```


Yeah, this kind of error can be quite tricky indeed. This is the very
technical bit where I am bit uneasy about the future scaling of
categories using dynamic classes. The only way to avoid such errors
sanely is to specify general rules about the order of the base classes
of a class. There are very minimal comments about that at the end of
the primer. Reducing the risk of this kind of issue is also one of the
goal of #10963 (the more is done automatically, the higher are the
chances of consistency).

> It seems that the problem is in the order in which the two classes are presented:
> 
> ```
> sage: class Foo(Objects().HomCategory(Objects()).parent_class, Homset): pass
> ....: 
> sage:
> ```


Here, I would say that the rule is that category code (in particular
what comes from a_category.parent_class) should always come after
concrete classes.

Good luck!

By the way: congrats on all your category optimization work. I love it!



---

archive/issue_comments_140306.json:
```json
{
    "body": "<a id='comment:18'></a>\nReplying to [nthiery](#comment%3A17):\n> The only way to avoid such errors\n> sanely is to specify general rules about the order of the base classes\n> of a class.\n\n\nI thought of that. But it could slow things down.\n\n> Here, I would say that the rule is that category code (in particular\n> what comes from a_category.parent_class) should always come after\n> concrete classes.\n\n\nIt is not very much concrete. The real error reduces to what I have shown. But in fact, the class Homset comes from `sage.categories.objects.HomCategory.ParentMethods`. To be precise:\n\n```\nsage: from sage.structure.dynamic_class import dynamic_class\nsage: C = Objects().hom_category()\nsage: dynamic_class('bla', (C.parent_class,), C.ParentMethods)\n```\n\nAnd going further down, the above is caused by some lines in the parent_class lazy attribute:\n\n```\n        return dynamic_class(\"%s.parent_class\"%self.__class__.__name__,\n                             tuple(cat.parent_class for cat in self.super_categories()),\n                             self.ParentMethods,\n                             reduction = (getattr, (self, \"parent_class\")))\n```\n\nIn my case, `cat.parent_class` is a sub-class of `self.ParentMethods` (self being C above). Here is the relation with my patch:\n\n```\nsage: C = ChainComplexes(ZZ)\nsage: HC = C.hom_category()\nsage: HC.super_categories()\n[Category of hom sets in Category of objects]\n# it was [Category of sets] without my patch!\n```\n\nAnd finally, that comes from\n\n```\nsage: HC.base_category\nCategory of chain complexes over Integer Ring\n# it used to be Category of objects without my patch\n```\n\nSince `[category.hom_category() for category in self.base_category.super_categories()]` is part of the super categories, the change of the base category was the ultimate cause of the error.\n\nHowever, I wouldn't like to change the base_category. After all, the base_category is the category to which the homsets belong. Here, the homsets belong to the category of chain complexes over Integer Ring. Thus, \"category of objects\" is plainly wrong.\n\nSo, for now, I see two ways to fix it:\n\n1. Change `HomCategory.super_categories`. It should only return `self.extra_super_categories() + Sets()` (after all, homsets are sets), but not `[category.hom_category() for category in self.base_category.super_categories()]`.\n\n2. Change `parent_class`, so that not all of `tuple(cat.parent_class for cat in self.super_categories())` is included, but only the bits that are no sub-classes of `self.ParentMethods`.\n\nIs it really mathematically correct that the hom-category of a category C is a subcategory of the hom-category of any super-category of C?\n\nFor example, if C is the category of unital K-algebras (K some field) then C is a subcategory of the category of K-vectorspaces. The homsets of K-vectorspaces are K-vectorspaces. But the homsets of unital K-algebras do not form K-vectorspaces, isn't it?\n\nAt least, computationally, option 1 is faster than option 2. And when you confirm that option 2 (which is the status quo!) is actually mathematically wrong then it is clear what I will do.\n\n> By the way: congrats on all your category optimization work. I love it!\n\n\nThank you!",
    "created_at": "2011-08-30T14:24:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140306",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'></a>
Replying to [nthiery](#comment%3A17):
> The only way to avoid such errors
> sanely is to specify general rules about the order of the base classes
> of a class.


I thought of that. But it could slow things down.

> Here, I would say that the rule is that category code (in particular
> what comes from a_category.parent_class) should always come after
> concrete classes.


It is not very much concrete. The real error reduces to what I have shown. But in fact, the class Homset comes from `sage.categories.objects.HomCategory.ParentMethods`. To be precise:

```
sage: from sage.structure.dynamic_class import dynamic_class
sage: C = Objects().hom_category()
sage: dynamic_class('bla', (C.parent_class,), C.ParentMethods)
```

And going further down, the above is caused by some lines in the parent_class lazy attribute:

```
        return dynamic_class("%s.parent_class"%self.__class__.__name__,
                             tuple(cat.parent_class for cat in self.super_categories()),
                             self.ParentMethods,
                             reduction = (getattr, (self, "parent_class")))
```

In my case, `cat.parent_class` is a sub-class of `self.ParentMethods` (self being C above). Here is the relation with my patch:

```
sage: C = ChainComplexes(ZZ)
sage: HC = C.hom_category()
sage: HC.super_categories()
[Category of hom sets in Category of objects]
# it was [Category of sets] without my patch!
```

And finally, that comes from

```
sage: HC.base_category
Category of chain complexes over Integer Ring
# it used to be Category of objects without my patch
```

Since `[category.hom_category() for category in self.base_category.super_categories()]` is part of the super categories, the change of the base category was the ultimate cause of the error.

However, I wouldn't like to change the base_category. After all, the base_category is the category to which the homsets belong. Here, the homsets belong to the category of chain complexes over Integer Ring. Thus, "category of objects" is plainly wrong.

So, for now, I see two ways to fix it:

1. Change `HomCategory.super_categories`. It should only return `self.extra_super_categories() + Sets()` (after all, homsets are sets), but not `[category.hom_category() for category in self.base_category.super_categories()]`.

2. Change `parent_class`, so that not all of `tuple(cat.parent_class for cat in self.super_categories())` is included, but only the bits that are no sub-classes of `self.ParentMethods`.

Is it really mathematically correct that the hom-category of a category C is a subcategory of the hom-category of any super-category of C?

For example, if C is the category of unital K-algebras (K some field) then C is a subcategory of the category of K-vectorspaces. The homsets of K-vectorspaces are K-vectorspaces. But the homsets of unital K-algebras do not form K-vectorspaces, isn't it?

At least, computationally, option 1 is faster than option 2. And when you confirm that option 2 (which is the status quo!) is actually mathematically wrong then it is clear what I will do.

> By the way: congrats on all your category optimization work. I love it!


Thank you!



---

archive/issue_comments_140307.json:
```json
{
    "body": "<a id='comment:19'></a>\nIndeed the hom category of algebras is attributed as a subcategory of the category of vectorspaces:\n\n```\nsage: Algebras(QQ).hom_category().is_subcategory(VectorSpaces(QQ))\nTrue\n```\n\nIsn't that plainly wrong?",
    "created_at": "2011-08-30T14:31:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140307",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'></a>
Indeed the hom category of algebras is attributed as a subcategory of the category of vectorspaces:

```
sage: Algebras(QQ).hom_category().is_subcategory(VectorSpaces(QQ))
True
```

Isn't that plainly wrong?



---

archive/issue_comments_140308.json:
```json
{
    "body": "<a id='comment:20'></a>\nIt seems to me that the implementation can not so easily be cleaned. \n\nIn some cases, we do want that the hom category of a category inherits stuff from the hom category of a super category - simply in order to avoid code duplication. For example, `VectorSpaces(...).hom_category()` does (and should) inherit from `Modules(...).hom_category()`.\n\nIn other cases, we do not want that inheritance. For example, we do not want that `Algebras(...).hom_category()` inherits from `VectorSpaces(...).hom_category()`.\n\nIndeed, we currently have\n\n```\nsage: Algebras(QQ).hom_category().extra_super_categories()\n[Category of sets]\n```\n\nI tried to understand why we have the above answer. We have\n\n```\nsage: Algebras(QQ).hom_category().extra_super_categories.__module__\n'sage.categories.rings'\n```\nSo, the method is inherited from the hom category of the category of rings.\n\nWhy is it (correctly) not inherited from the hom category of the category of Q-modules? \n\n```\nsage: Modules(QQ).hom_category().extra_super_categories()\n[Category of vector spaces over Rational Field]\n```\n\nIt seems to me that the correct inheritence is just due to the fact that `Algebras(...).super_categories()` returns first `Rings()` and then `Modules(...)`\n\n```\nsage: Algebras(QQ).super_categories()\n[Category of rings, Category of vector spaces over Rational Field]\n```\nIf that list would be returned in the opposite order, then `Algebras(QQ).hom_category()` would pick up the `extra_super_categories` method from `Modules(QQ).hom_category()`, which would not be correct.\n\nI think that inheritance being dependent on the order of a list of super categories is very much error prone and difficult to debug.",
    "created_at": "2011-08-30T15:19:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140308",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:20'></a>
It seems to me that the implementation can not so easily be cleaned. 

In some cases, we do want that the hom category of a category inherits stuff from the hom category of a super category - simply in order to avoid code duplication. For example, `VectorSpaces(...).hom_category()` does (and should) inherit from `Modules(...).hom_category()`.

In other cases, we do not want that inheritance. For example, we do not want that `Algebras(...).hom_category()` inherits from `VectorSpaces(...).hom_category()`.

Indeed, we currently have

```
sage: Algebras(QQ).hom_category().extra_super_categories()
[Category of sets]
```

I tried to understand why we have the above answer. We have

```
sage: Algebras(QQ).hom_category().extra_super_categories.__module__
'sage.categories.rings'
```
So, the method is inherited from the hom category of the category of rings.

Why is it (correctly) not inherited from the hom category of the category of Q-modules? 

```
sage: Modules(QQ).hom_category().extra_super_categories()
[Category of vector spaces over Rational Field]
```

It seems to me that the correct inheritence is just due to the fact that `Algebras(...).super_categories()` returns first `Rings()` and then `Modules(...)`

```
sage: Algebras(QQ).super_categories()
[Category of rings, Category of vector spaces over Rational Field]
```
If that list would be returned in the opposite order, then `Algebras(QQ).hom_category()` would pick up the `extra_super_categories` method from `Modules(QQ).hom_category()`, which would not be correct.

I think that inheritance being dependent on the order of a list of super categories is very much error prone and difficult to debug.



---

archive/issue_comments_140309.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [SimonKing](#comment%3A19):\n> Indeed the hom category of algebras is attributed as a subcategory of the category of vectorspaces:\n> \n> ```\n> sage: Algebras(QQ).hom_category().is_subcategory(VectorSpaces(QQ))\n> True\n> ```\n> \n> Isn't that plainly wrong?\n\n\nYes it is plain wrong. We had discussed this early this Spring, and we even both have patches fixing this (using a different syntax) :-) See #10668.\n\nThis property only holds for full subcategories, and last time we discussed that we were looking for a syntax specifying when a category is a full subcategory of another one.\n\nCheers,\n                 Nicolas",
    "created_at": "2011-08-30T15:25:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140309",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:21'></a>
Replying to [SimonKing](#comment%3A19):
> Indeed the hom category of algebras is attributed as a subcategory of the category of vectorspaces:
> 
> ```
> sage: Algebras(QQ).hom_category().is_subcategory(VectorSpaces(QQ))
> True
> ```
> 
> Isn't that plainly wrong?


Yes it is plain wrong. We had discussed this early this Spring, and we even both have patches fixing this (using a different syntax) :-) See #10668.

This property only holds for full subcategories, and last time we discussed that we were looking for a syntax specifying when a category is a full subcategory of another one.

Cheers,
                 Nicolas



---

archive/issue_comments_140310.json:
```json
{
    "body": "<a id='comment:22'></a>\nReplying to [nthiery](#comment%3A21):\n> Yes it is plain wrong. We had discussed this early this Spring, and we even both have patches fixing this (using a different syntax) :-) See #10668.\n\n\nOuch! I completely forgot about that other ticket!\n \n> This property only holds for full subcategories, and last time we discussed that we were looking for a syntax specifying when a category is a full subcategory of another one.\n\n\nOK. Then I wonder what I should do here.\n\nThe purpose of this ticket is to provide containers for the morphisms and objects of a category, and to provide an acceptable speed. It is *not* the purpose to refactor hom categories - because that is to be done in #10668.\n\nHence, for now, I suggest that I will restrict myself on getting the tests pass. I guess it will be possible in a couple of days, and may require to change `HomCategory.super_categories` in the way I suggested above. But apart from that, I will not aim at refactoring everything.",
    "created_at": "2011-08-30T15:42:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140310",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:22'></a>
Replying to [nthiery](#comment%3A21):
> Yes it is plain wrong. We had discussed this early this Spring, and we even both have patches fixing this (using a different syntax) :-) See #10668.


Ouch! I completely forgot about that other ticket!
 
> This property only holds for full subcategories, and last time we discussed that we were looking for a syntax specifying when a category is a full subcategory of another one.


OK. Then I wonder what I should do here.

The purpose of this ticket is to provide containers for the morphisms and objects of a category, and to provide an acceptable speed. It is *not* the purpose to refactor hom categories - because that is to be done in #10668.

Hence, for now, I suggest that I will restrict myself on getting the tests pass. I guess it will be possible in a couple of days, and may require to change `HomCategory.super_categories` in the way I suggested above. But apart from that, I will not aim at refactoring everything.



---

archive/issue_comments_140311.json:
```json
{
    "body": "<a id='comment:23'></a>\nAnother mathematical question: \n\nI thought that any hom category is a sub-category of the category of sets.\n\nCurrently, `HomCategory(Objects()).super_categories()` returns `Objects()`, which is a bug anyway, because it does *not* return a list! But should it return `[Sets()]`? The same answer for `HomCategory(SetsWithPartialMaps()).super_categories()`?",
    "created_at": "2011-08-30T15:51:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140311",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:23'></a>
Another mathematical question: 

I thought that any hom category is a sub-category of the category of sets.

Currently, `HomCategory(Objects()).super_categories()` returns `Objects()`, which is a bug anyway, because it does *not* return a list! But should it return `[Sets()]`? The same answer for `HomCategory(SetsWithPartialMaps()).super_categories()`?



---

archive/issue_comments_140312.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [SimonKing](#comment%3A22):\n> OK. Then I wonder what I should do here.\n> \n> The purpose of this ticket is to provide containers for the morphisms and objects of a category, and to provide an acceptable speed. It is *not* the purpose to refactor hom categories - because that is to be done in #10668.\n> \n> Hence, for now, I suggest that I will restrict myself on getting the tests pass. I guess it will be possible in a couple of days, and may require to change `HomCategory.super_categories` in the way I suggested above. But apart from that, I will not aim at refactoring everything.\n\n\nThis sounds good. I just hope that there are not too many things that currently depends\non that (buggy most of the time, but from time to time correct) inheritance.",
    "created_at": "2011-08-30T16:39:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140312",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:24'></a>
Replying to [SimonKing](#comment%3A22):
> OK. Then I wonder what I should do here.
> 
> The purpose of this ticket is to provide containers for the morphisms and objects of a category, and to provide an acceptable speed. It is *not* the purpose to refactor hom categories - because that is to be done in #10668.
> 
> Hence, for now, I suggest that I will restrict myself on getting the tests pass. I guess it will be possible in a couple of days, and may require to change `HomCategory.super_categories` in the way I suggested above. But apart from that, I will not aim at refactoring everything.


This sounds good. I just hope that there are not too many things that currently depends
on that (buggy most of the time, but from time to time correct) inheritance.



---

archive/issue_comments_140313.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [SimonKing](#comment%3A23):\n> Another mathematical question: \n> \n> I thought that any hom category is a sub-category of the category of sets.\n> \n> Currently, `HomCategory(Objects()).super_categories()` returns `Objects()`, which is a bug anyway, because it does *not* return a list! But should it return `[Sets()]`? The same answer for `HomCategory(SetsWithPartialMaps()).super_categories()`?\n\n\nYes it should definitely be fixed to be a list. Now, I would tend to be safe and stick to [Objects()], unless some abstract category expert is absolutely convinced that [Sets()] is always correct (I doubt it).",
    "created_at": "2011-08-30T16:45:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140313",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:25'></a>
Replying to [SimonKing](#comment%3A23):
> Another mathematical question: 
> 
> I thought that any hom category is a sub-category of the category of sets.
> 
> Currently, `HomCategory(Objects()).super_categories()` returns `Objects()`, which is a bug anyway, because it does *not* return a list! But should it return `[Sets()]`? The same answer for `HomCategory(SetsWithPartialMaps()).super_categories()`?


Yes it should definitely be fixed to be a list. Now, I would tend to be safe and stick to [Objects()], unless some abstract category expert is absolutely convinced that [Sets()] is always correct (I doubt it).



---

archive/issue_comments_140314.json:
```json
{
    "body": "<a id='comment:26'></a>\nPersonally, I believe that `Objects()` is not a category in the proper meaning of the word. I think for any category C and any objects A,B of C, then `Hom(A,B)` must by definition be a set.\n\nBut you are right, in case of doubt one should use `Objects()`, not `Sets()`.",
    "created_at": "2011-08-30T16:52:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140314",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:26'></a>
Personally, I believe that `Objects()` is not a category in the proper meaning of the word. I think for any category C and any objects A,B of C, then `Hom(A,B)` must by definition be a set.

But you are right, in case of doubt one should use `Objects()`, not `Sets()`.



---

archive/issue_comments_140315.json:
```json
{
    "body": "<a id='comment:27'></a>\nNo, after all, I think that Sets() is correct.\n\nWe already have\n\n```\nsage: O = Objects()\nsage: H = O.HomCategory(O)\nsage: H.super_categories()\n[Category of sets]\n```\nand a comment in the doc string of `H.super_categegories`:\n\n```\n            \"\"\"\n            This declares that any homset `Hom(A, B)` for `A` and `B`\n            in the category of objects is a set.\n            This more or less assumes that the category is locally small.\n            See http://en.wikipedia.org/wiki/Category_(mathematics)\n\n            EXAMPLES::\n\n                sage: Objects().hom_category().super_categories()\n                [Category of sets]\n            \"\"\"\n```\n\nSo, that should be fine.",
    "created_at": "2011-08-31T11:09:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140315",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:27'></a>
No, after all, I think that Sets() is correct.

We already have

```
sage: O = Objects()
sage: H = O.HomCategory(O)
sage: H.super_categories()
[Category of sets]
```
and a comment in the doc string of `H.super_categegories`:

```
            """
            This declares that any homset `Hom(A, B)` for `A` and `B`
            in the category of objects is a set.
            This more or less assumes that the category is locally small.
            See http://en.wikipedia.org/wiki/Category_(mathematics)

            EXAMPLES::

                sage: Objects().hom_category().super_categories()
                [Category of sets]
            """
```

So, that should be fine.



---

archive/issue_comments_140316.json:
```json
{
    "body": "<a id='comment:28'></a>\nCurrently, I'm having trouble with getting an appropriate class for the homsets.\n\nYou know that rings have a specially designed class for their homsets:\n\n```\nsage: Rings().HomCategory\n<class 'sage.categories.rings.Rings.HomCategory'>\nsage: Rings().HomCategory(Rings()).parent_class.__module__\n'sage.categories.rings'\n```\n\nBy #9944 and #9138, polynomial rings are (commutative) algebras and not just rings. The category of algebras does not define their own `HomCategory` class.\n\nHowever, two of its super categories have special `HomCategory`, namely\n\n```\nsage: Modules(ZZ).HomCategory\n<class 'sage.categories.modules.Modules.HomCategory'>\nsage: Rings().HomCategory\n<class 'sage.categories.rings.Rings.HomCategory'>\n```\n\nWouldn't it be a good idea to create a lazy attribute `HomCategory` for `sage.categories.category.Category`, that returns a dynamic class formed by all the hom category classes of the super categories?\n\nHence, what I suggest means that `Algebras(ZZ).HomCategory` would be a sub-class of both `Rings().HomCategory` and `Modules(ZZ).HomCategory`. At least in this example, it would work, regardless of the order:\n\n```\nsage: class Foo(Rings().HomCategory, Modules(ZZ).HomCategory): pass\n....: \nsage: class Foo(Modules(ZZ).HomCategory, Rings().HomCategory): pass\n....: \n```\n\nAs a dynamic class, we would probably have\n\n```\nsage: from sage.structure.dynamic_class import dynamic_class\nsage: from sage.categories.category import HomCategory\nsage: dynamic_class('FooHomCategory', (Rings().HomCategory, Modules(ZZ).HomCategory, HomCategory))\n<class 'sage.categories.rings.FooHomCategory'>\n```\nBut note that putting `HomCategory` in front of the tuple or providing it as second argument after the tuple will *not* work.\n\nI think that this would be a very clean solution. The method resolution order of the dynamic class would, if I understand correctly, first pick up the stuff defined for rings, then the stuff defined for modules, and finally the generic stuff of `HomCategory`.",
    "created_at": "2011-08-31T11:32:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140316",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:28'></a>
Currently, I'm having trouble with getting an appropriate class for the homsets.

You know that rings have a specially designed class for their homsets:

```
sage: Rings().HomCategory
<class 'sage.categories.rings.Rings.HomCategory'>
sage: Rings().HomCategory(Rings()).parent_class.__module__
'sage.categories.rings'
```

By #9944 and #9138, polynomial rings are (commutative) algebras and not just rings. The category of algebras does not define their own `HomCategory` class.

However, two of its super categories have special `HomCategory`, namely

```
sage: Modules(ZZ).HomCategory
<class 'sage.categories.modules.Modules.HomCategory'>
sage: Rings().HomCategory
<class 'sage.categories.rings.Rings.HomCategory'>
```

Wouldn't it be a good idea to create a lazy attribute `HomCategory` for `sage.categories.category.Category`, that returns a dynamic class formed by all the hom category classes of the super categories?

Hence, what I suggest means that `Algebras(ZZ).HomCategory` would be a sub-class of both `Rings().HomCategory` and `Modules(ZZ).HomCategory`. At least in this example, it would work, regardless of the order:

```
sage: class Foo(Rings().HomCategory, Modules(ZZ).HomCategory): pass
....: 
sage: class Foo(Modules(ZZ).HomCategory, Rings().HomCategory): pass
....: 
```

As a dynamic class, we would probably have

```
sage: from sage.structure.dynamic_class import dynamic_class
sage: from sage.categories.category import HomCategory
sage: dynamic_class('FooHomCategory', (Rings().HomCategory, Modules(ZZ).HomCategory, HomCategory))
<class 'sage.categories.rings.FooHomCategory'>
```
But note that putting `HomCategory` in front of the tuple or providing it as second argument after the tuple will *not* work.

I think that this would be a very clean solution. The method resolution order of the dynamic class would, if I understand correctly, first pick up the stuff defined for rings, then the stuff defined for modules, and finally the generic stuff of `HomCategory`.



---

archive/issue_comments_140317.json:
```json
{
    "body": "<a id='comment:29'></a>\nPerhaps a related question: In sage/categories/rings.py, we have\n\n```python\n    class HomCategory(HomCategory):\n        class ParentMethods:\n            def __new__(cls, X, Y, category):\n                from sage.rings.homset import RingHomset\n                return RingHomset(X, Y, category = category)\n            def __getnewargs__(self):\n                return (self.domain(), self.codomain(), self.category())\n```\n\nWouldn't it be possible to simply have\n\n```python\n    class HomCategory(HomCategory):\n        class ParentMethods(RingHomset):\n            pass\n```\n?",
    "created_at": "2011-08-31T11:35:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140317",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:29'></a>
Perhaps a related question: In sage/categories/rings.py, we have

```python
    class HomCategory(HomCategory):
        class ParentMethods:
            def __new__(cls, X, Y, category):
                from sage.rings.homset import RingHomset
                return RingHomset(X, Y, category = category)
            def __getnewargs__(self):
                return (self.domain(), self.codomain(), self.category())
```

Wouldn't it be possible to simply have

```python
    class HomCategory(HomCategory):
        class ParentMethods(RingHomset):
            pass
```
?



---

archive/issue_comments_140318.json:
```json
{
    "body": "<a id='comment:30'></a>\nHi Simon!\n\nReplying to [SimonKing](#comment%3A28):\n> Wouldn't it be a good idea to create a lazy attribute `HomCategory` for `sage.categories.category.Category`, that returns a dynamic class formed by all the hom category classes of the super categories?\n\n\nIf I remember correctly, that's more or less what you had implemented\nfor #10668 :-) Of course (and you had taken care of this), unless one\nis having a full subcategory, one should have this inheritance only\nfor elements of the hom category (i.e. morphisms), not for the homsets\nor the category.\n\nSo ... Do you see a temporary quick fix to have #10667 work for the\nmoment, before we go on to #10668?\n\nCheers,",
    "created_at": "2011-08-31T11:45:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140318",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:30'></a>
Hi Simon!

Replying to [SimonKing](#comment%3A28):
> Wouldn't it be a good idea to create a lazy attribute `HomCategory` for `sage.categories.category.Category`, that returns a dynamic class formed by all the hom category classes of the super categories?


If I remember correctly, that's more or less what you had implemented
for #10668 :-) Of course (and you had taken care of this), unless one
is having a full subcategory, one should have this inheritance only
for elements of the hom category (i.e. morphisms), not for the homsets
or the category.

So ... Do you see a temporary quick fix to have #10667 work for the
moment, before we go on to #10668?

Cheers,



---

archive/issue_comments_140319.json:
```json
{
    "body": "<a id='comment:31'></a>\nReplying to [SimonKing](#comment%3A29):\n> Perhaps a related question: In sage/categories/rings.py, we have\n> \n> ```python\n>     class HomCategory(HomCategory):\n>         class ParentMethods:\n>             def __new__(cls, X, Y, category):\n>                 from sage.rings.homset import RingHomset\n>                 return RingHomset(X, Y, category = category)\n>             def __getnewargs__(self):\n>                 return (self.domain(), self.codomain(), self.category())\n> ```\n> \n> Wouldn't it be possible to simply have\n> \n> ```python\n>     class HomCategory(HomCategory):\n>         class ParentMethods(RingHomset):\n>             pass\n> ```\n> ?\n\n\nSomehow both are wrong; I had just put that here to make the damn thing work for the moment: the category really should not be dealing with the concrete classes used to implement the Homsets. That's Hom's job at best, but we need to design a proper protocol for this.",
    "created_at": "2011-08-31T11:49:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140319",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:31'></a>
Replying to [SimonKing](#comment%3A29):
> Perhaps a related question: In sage/categories/rings.py, we have
> 
> ```python
>     class HomCategory(HomCategory):
>         class ParentMethods:
>             def __new__(cls, X, Y, category):
>                 from sage.rings.homset import RingHomset
>                 return RingHomset(X, Y, category = category)
>             def __getnewargs__(self):
>                 return (self.domain(), self.codomain(), self.category())
> ```
> 
> Wouldn't it be possible to simply have
> 
> ```python
>     class HomCategory(HomCategory):
>         class ParentMethods(RingHomset):
>             pass
> ```
> ?


Somehow both are wrong; I had just put that here to make the damn thing work for the moment: the category really should not be dealing with the concrete classes used to implement the Homsets. That's Hom's job at best, but we need to design a proper protocol for this.



---

archive/issue_comments_140320.json:
```json
{
    "body": "<a id='comment:32'></a>\nReplying to [SimonKing](#comment%3A27):\n> No, after all, I think that Sets() is correct.\n> and a comment in the doc string of `H.super_categegories`:\n> \n> ```\n>             \"\"\"\n>             This declares that any homset `Hom(A, B)` for `A` and `B`\n>             in the category of objects is a set.\n>             This more or less assumes that the category is locally small.\n>             See http://en.wikipedia.org/wiki/Category_(mathematics)\n> \n>             EXAMPLES::\n> \n>                 sage: Objects().hom_category().super_categories()\n>                 [Category of sets]\n>             \"\"\"\n> ```\n\n\nROTFL. I wrote that comment. So I guess I should agree with it :-)",
    "created_at": "2011-08-31T11:50:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140320",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:32'></a>
Replying to [SimonKing](#comment%3A27):
> No, after all, I think that Sets() is correct.
> and a comment in the doc string of `H.super_categegories`:
> 
> ```
>             """
>             This declares that any homset `Hom(A, B)` for `A` and `B`
>             in the category of objects is a set.
>             This more or less assumes that the category is locally small.
>             See http://en.wikipedia.org/wiki/Category_(mathematics)
> 
>             EXAMPLES::
> 
>                 sage: Objects().hom_category().super_categories()
>                 [Category of sets]
>             """
> ```


ROTFL. I wrote that comment. So I guess I should agree with it :-)



---

archive/issue_comments_140321.json:
```json
{
    "body": "<a id='comment:33'></a>\nYes, it seems to work nicely with lazy attribute plus dynamic class!!\n\nI have (to be a doctest):\n\n```\n            sage: A = Algebras(ZZ)\n            sage: H = A.hom_category()   #indirect doctest\n            sage: H\n            Category of hom sets in Category of algebras over Integer Ring\n            sage: isinstance(H, Rings().HomCategory)\n            True\n            sage: isinstance(H, Modules(ZZ).HomCategory)\n            True\n```",
    "created_at": "2011-08-31T11:57:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140321",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:33'></a>
Yes, it seems to work nicely with lazy attribute plus dynamic class!!

I have (to be a doctest):

```
            sage: A = Algebras(ZZ)
            sage: H = A.hom_category()   #indirect doctest
            sage: H
            Category of hom sets in Category of algebras over Integer Ring
            sage: isinstance(H, Rings().HomCategory)
            True
            sage: isinstance(H, Modules(ZZ).HomCategory)
            True
```



---

archive/issue_comments_140322.json:
```json
{
    "body": "<a id='comment:34'></a>\nPS:\n\nI forgot to add that the super categories of the hom category are fine as well. We have:\n\n```\nsage: A = Algebras(ZZ)\nsage: H = A.hom_category()   #indirect doctest\nsage: H.super_categories()\n[Category of hom sets in Category of objects]\nsage: H.an_object()\nSet of Homomorphisms from Univariate Polynomial Ring in x over Integer Ring to Univariate Polynomial Ring in x over Integer Ring\nsage: H.an_object().category()\nCategory of hom sets in Category of algebras over Integer Ring\nsage: H.an_object().category().super_categories()\n[Category of hom sets in Category of objects]\n```",
    "created_at": "2011-08-31T12:01:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140322",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:34'></a>
PS:

I forgot to add that the super categories of the hom category are fine as well. We have:

```
sage: A = Algebras(ZZ)
sage: H = A.hom_category()   #indirect doctest
sage: H.super_categories()
[Category of hom sets in Category of objects]
sage: H.an_object()
Set of Homomorphisms from Univariate Polynomial Ring in x over Integer Ring to Univariate Polynomial Ring in x over Integer Ring
sage: H.an_object().category()
Category of hom sets in Category of algebras over Integer Ring
sage: H.an_object().category().super_categories()
[Category of hom sets in Category of objects]
```



---

archive/issue_comments_140323.json:
```json
{
    "body": "<a id='comment:35'></a>\nReplying to [nthiery](#comment%3A30):\n> So ... Do you see a temporary quick fix to have #10667 work for the\n> moment, before we go on to #10668?\n\n\nI don't know yet. I am still walking my way accross the mine field of doctest errors. For example, the idea to provide a lazy attribute dynamic class for `HomCategory` is simply a means to enable\n\n```\nsage: R = QQ['z0','z1','z2','z3']\nsage: R.hom(R.gens())\nRing endomorphism of Multivariate Polynomial Ring in z0, z1, z2, z3 over Rational Field\n  Defn: z0 |--> z0\n        z1 |--> z1\n        z2 |--> z2\n        z3 |--> z3\n```\nThat easy example would have failed in the previous version of my patch.",
    "created_at": "2011-08-31T12:10:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140323",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:35'></a>
Replying to [nthiery](#comment%3A30):
> So ... Do you see a temporary quick fix to have #10667 work for the
> moment, before we go on to #10668?


I don't know yet. I am still walking my way accross the mine field of doctest errors. For example, the idea to provide a lazy attribute dynamic class for `HomCategory` is simply a means to enable

```
sage: R = QQ['z0','z1','z2','z3']
sage: R.hom(R.gens())
Ring endomorphism of Multivariate Polynomial Ring in z0, z1, z2, z3 over Rational Field
  Defn: z0 |--> z0
        z1 |--> z1
        z2 |--> z2
        z3 |--> z3
```
That easy example would have failed in the previous version of my patch.



---

archive/issue_comments_140324.json:
```json
{
    "body": "<a id='comment:36'></a>\nThe tests in devel/sage/doc pass. That encourages me to post my current patch version, so that you can already have a look at it (when you have the time; I know, probably you don't...).\n\nHowever, I keep it as \"needs work\", since I did not run the devel/sage/sage/, and since I need to check whether I really tested and documented all new functionality.",
    "created_at": "2011-08-31T12:20:14Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140324",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:36'></a>
The tests in devel/sage/doc pass. That encourages me to post my current patch version, so that you can already have a look at it (when you have the time; I know, probably you don't...).

However, I keep it as "needs work", since I did not run the devel/sage/sage/, and since I need to check whether I really tested and documented all new functionality.



---

archive/issue_comments_140325.json:
```json
{
    "body": "<a id='comment:37'></a>\nReplying to [nthiery](#comment%3A30):\n> So ... Do you see a temporary quick fix to have #10667 work for the\n> moment, before we go on to #10668?\n\n\nMeanwhile I think that a quick fix based on a modification of the current patch will be doable. I get 242 doctest errors related with Steenrod algebras. They seem to be caused by a wrong method resolution order, and I suppose that it can be fixed by changing the order on the list of super categories for some category. The remaining test failures seem to be harmless.",
    "created_at": "2011-08-31T14:06:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140325",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:37'></a>
Replying to [nthiery](#comment%3A30):
> So ... Do you see a temporary quick fix to have #10667 work for the
> moment, before we go on to #10668?


Meanwhile I think that a quick fix based on a modification of the current patch will be doable. I get 242 doctest errors related with Steenrod algebras. They seem to be caused by a wrong method resolution order, and I suppose that it can be fixed by changing the order on the list of super categories for some category. The remaining test failures seem to be harmless.



---

archive/issue_comments_140326.json:
```json
{
    "body": "<a id='comment:38'></a>\nWell, mostly harmless. Some involve to implement the category framework for uni- and multivariate power series rings. Multivariate power series rings was a recent addition - so, why has it not been done in the first place?\n\nIt seems that the 242 Steenrod errors are mostly gone. At least, `TestSuite(SteenrodAlgebra(2)).run()` works.\n\nTime to call it a day...",
    "created_at": "2011-08-31T16:43:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140326",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:38'></a>
Well, mostly harmless. Some involve to implement the category framework for uni- and multivariate power series rings. Multivariate power series rings was a recent addition - so, why has it not been done in the first place?

It seems that the 242 Steenrod errors are mostly gone. At least, `TestSuite(SteenrodAlgebra(2)).run()` works.

Time to call it a day...



---

archive/issue_comments_140327.json:
```json
{
    "body": "<a id='comment:39'></a>\nReplying to [SimonKing](#comment%3A38):\n> Well, mostly harmless. Some involve to implement the category framework for uni- and multivariate power series rings. Multivariate power series rings was a recent addition - so, why has it not been done in the first place?\n\n\nStill way too much code using prehistoric stuff; so devs and reviewers don't take the right examples to start from.\n\n> It seems that the 242 Steenrod errors are mostly gone. At least, `TestSuite(SteenrodAlgebra(2)).run()` works.\n\n\nYippee!\n\n> Time to call it a day...\n\n\n:-)",
    "created_at": "2011-08-31T17:24:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140327",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:39'></a>
Replying to [SimonKing](#comment%3A38):
> Well, mostly harmless. Some involve to implement the category framework for uni- and multivariate power series rings. Multivariate power series rings was a recent addition - so, why has it not been done in the first place?


Still way too much code using prehistoric stuff; so devs and reviewers don't take the right examples to start from.

> It seems that the 242 Steenrod errors are mostly gone. At least, `TestSuite(SteenrodAlgebra(2)).run()` works.


Yippee!

> Time to call it a day...


:-)



---

archive/issue_comments_140328.json:
```json
{
    "body": "<a id='comment:40'></a>\nReplying to [SimonKing](#comment%3A36):\n> The tests in devel/sage/doc pass. That encourages me to post my current patch version, so that you can already have a look at it (when you have the time; I know, probably you don't...).\n\n\nI really should take the time. At this point, I am so much behind with your patches that I am thinking we should have a face to face review sprint. Alas, I don't have yet the schedule for my classes this fall to see whether I could come to the Sage days at KL. Are you planning to come to France anytime soon?",
    "created_at": "2011-08-31T17:27:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140328",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:40'></a>
Replying to [SimonKing](#comment%3A36):
> The tests in devel/sage/doc pass. That encourages me to post my current patch version, so that you can already have a look at it (when you have the time; I know, probably you don't...).


I really should take the time. At this point, I am so much behind with your patches that I am thinking we should have a face to face review sprint. Alas, I don't have yet the schedule for my classes this fall to see whether I could come to the Sage days at KL. Are you planning to come to France anytime soon?



---

archive/issue_comments_140329.json:
```json
{
    "body": "<a id='comment:41'></a>\nReplying to [nthiery](#comment%3A40):\n> Alas, I don't have yet the schedule for my classes this fall to see whether I could come to the Sage days at KL. Are you planning to come to France anytime soon?\n\n\nI will be in Kaiserslautern, but apart from that I have no plans at all. But there should be some travel money available from my project...\n\nFor the record: Steenrod algebra tests pass fully. I am still having trouble to find the right order of base classes for dynamic classes. Probably it would not be possible at all. Thus, with my current patch (not posted), I catch the resulting type error, and return a generic class (such as `Objects().HomCategory`) for implementing the hom category of a category.",
    "created_at": "2011-08-31T18:13:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140329",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:41'></a>
Replying to [nthiery](#comment%3A40):
> Alas, I don't have yet the schedule for my classes this fall to see whether I could come to the Sage days at KL. Are you planning to come to France anytime soon?


I will be in Kaiserslautern, but apart from that I have no plans at all. But there should be some travel money available from my project...

For the record: Steenrod algebra tests pass fully. I am still having trouble to find the right order of base classes for dynamic classes. Probably it would not be possible at all. Thus, with my current patch (not posted), I catch the resulting type error, and return a generic class (such as `Objects().HomCategory`) for implementing the hom category of a category.



---

archive/issue_comments_140330.json:
```json
{
    "body": "<a id='comment:42'></a>\nI am making some progress. \n\nTestsuites are really a good thing! By adding tests for morphisms, I found a couple of bugs. And that's why my patch can not just be a short work-around (unless I make the Testsuites skip some tests). It will contain fixes in different parts of sage.\n\nJust one example:\n\n```\nsage: E = CombinatorialFreeModule(ZZ, [1,2,3])\nsage: F = CombinatorialFreeModule(ZZ, [2,3,4])\nsage: H = Hom(E, F)\nsage: TestSuite(H).run()\nFailure in _test_additive_associativity:\nTraceback (most recent call last):\n  File \"/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/misc/sage_unittest.py\", line 275, in run\n    test_method(tester = tester)\n  File \"/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/categories/commutative_additive_semigroups.py\", line 80, in _test_additive_associativity\n    tester.assert_((x + y) + z == x + (y + z))\nTypeError: unsupported operand type(s) for +: 'ModuleMorphismByLinearity' and 'ModuleMorphismByLinearity'\n------------------------------------------------------------\nFailure in _test_an_element:\nTraceback (most recent call last):\n  File \"/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/misc/sage_unittest.py\", line 275, in run\n    test_method(tester = tester)\n  File \"/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/categories/sets_cat.py\", line 388, in _test_an_element\n    tester.assertEqual(self(an_element), an_element, \"element construction is not idempotent\")\n...\n```\n\nThe reason is that `dumps(H.zero())` fails:\n\n```\nsage: dumps(H.zero())\n---------------------------------------------------------------------------\nPicklingError                             Traceback (most recent call last)\n\n/home/king/SAGE/work/categories/objects/<ipython console> in <module>()\n\n/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/structure/sage_object.so in sage.structure.sage_object.dumps (sage/structure/sage_object.c:8274)()\n\n/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/structure/sage_object.so in sage.structure.sage_object.SageObject.dumps (sage/structure/sage_object.c:2183)()\n\nPicklingError: Can't pickle <type 'function'>: attribute lookup __builtin__.function failed\n```\n\nThere are more of those bugs.\n\nThe good news: I think I found a stable way to get the method resolution order of hom category parent classes right.\n\nI even tried to get rid of the odd explicit `__new__` method in `sage.categories.rings.Rings.HomCategory.ParentMethods`. But I am not sure if I will succeed.",
    "created_at": "2011-09-03T11:22:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140330",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:42'></a>
I am making some progress. 

Testsuites are really a good thing! By adding tests for morphisms, I found a couple of bugs. And that's why my patch can not just be a short work-around (unless I make the Testsuites skip some tests). It will contain fixes in different parts of sage.

Just one example:

```
sage: E = CombinatorialFreeModule(ZZ, [1,2,3])
sage: F = CombinatorialFreeModule(ZZ, [2,3,4])
sage: H = Hom(E, F)
sage: TestSuite(H).run()
Failure in _test_additive_associativity:
Traceback (most recent call last):
  File "/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/misc/sage_unittest.py", line 275, in run
    test_method(tester = tester)
  File "/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/categories/commutative_additive_semigroups.py", line 80, in _test_additive_associativity
    tester.assert_((x + y) + z == x + (y + z))
TypeError: unsupported operand type(s) for +: 'ModuleMorphismByLinearity' and 'ModuleMorphismByLinearity'
------------------------------------------------------------
Failure in _test_an_element:
Traceback (most recent call last):
  File "/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/misc/sage_unittest.py", line 275, in run
    test_method(tester = tester)
  File "/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/categories/sets_cat.py", line 388, in _test_an_element
    tester.assertEqual(self(an_element), an_element, "element construction is not idempotent")
...
```

The reason is that `dumps(H.zero())` fails:

```
sage: dumps(H.zero())
---------------------------------------------------------------------------
PicklingError                             Traceback (most recent call last)

/home/king/SAGE/work/categories/objects/<ipython console> in <module>()

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/structure/sage_object.so in sage.structure.sage_object.dumps (sage/structure/sage_object.c:8274)()

/mnt/local/king/SAGE/broken/local/lib/python2.6/site-packages/sage/structure/sage_object.so in sage.structure.sage_object.SageObject.dumps (sage/structure/sage_object.c:2183)()

PicklingError: Can't pickle <type 'function'>: attribute lookup __builtin__.function failed
```

There are more of those bugs.

The good news: I think I found a stable way to get the method resolution order of hom category parent classes right.

I even tried to get rid of the odd explicit `__new__` method in `sage.categories.rings.Rings.HomCategory.ParentMethods`. But I am not sure if I will succeed.



---

archive/issue_comments_140331.json:
```json
{
    "body": "<a id='comment:43'></a>\nJust a status report: I got rid of the `__new__` method. Instead, I produce a `__classcall__` method, similar to what is done in `UniqueRepresentation` (and in fact I make `sage.categories.rings.Rings.HomCategory.ParentClass` inherit from `UniqueRepresentation`).\n\nI have already mentioned that I added some methods to the Cartesian product categories, so that some test suites actually passed. Next, I fixed another problem with Cartesian products: It has not been possible to create Cartesian products of algebras. It neither worked in sage-4.6.2 nor in sage-4.7.2.alpha1+#9138, but failed with different errors.\n\n```\nsage: C = cartesian_product([ZZ['x'], ZZ['y']])\n<BOOM>\n```\n\nAfter my patches and the addition of the base_ring method to Cartesian product categories, the problem arose with `__init_extra__` method in `sage.categories.algebras.Algebras.ParentMethods`: The Cartesian product of algebras over a ring R is an algebra over R (apparently acting diagonally). The `__init_extra__` tries to create a coercion from the R to the cartesian product. However, that ended in an infinite recursion. I solved it by adding a `from_base_ring` method, that is understood by `__init_extra__`.\n\nThe remaining problem concerns summation of elements of Cartesian products. Multiplication is defined, via `sage.categories.magmas.Magmas.CartesianProduct.ParentMethods.product`. But summation is missing. I guess it should be implemented in `sage.categories.AdditiveMagmas.CartesianProduct.ParentMethods.summation`.",
    "created_at": "2011-09-05T10:17:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140331",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:43'></a>
Just a status report: I got rid of the `__new__` method. Instead, I produce a `__classcall__` method, similar to what is done in `UniqueRepresentation` (and in fact I make `sage.categories.rings.Rings.HomCategory.ParentClass` inherit from `UniqueRepresentation`).

I have already mentioned that I added some methods to the Cartesian product categories, so that some test suites actually passed. Next, I fixed another problem with Cartesian products: It has not been possible to create Cartesian products of algebras. It neither worked in sage-4.6.2 nor in sage-4.7.2.alpha1+#9138, but failed with different errors.

```
sage: C = cartesian_product([ZZ['x'], ZZ['y']])
<BOOM>
```

After my patches and the addition of the base_ring method to Cartesian product categories, the problem arose with `__init_extra__` method in `sage.categories.algebras.Algebras.ParentMethods`: The Cartesian product of algebras over a ring R is an algebra over R (apparently acting diagonally). The `__init_extra__` tries to create a coercion from the R to the cartesian product. However, that ended in an infinite recursion. I solved it by adding a `from_base_ring` method, that is understood by `__init_extra__`.

The remaining problem concerns summation of elements of Cartesian products. Multiplication is defined, via `sage.categories.magmas.Magmas.CartesianProduct.ParentMethods.product`. But summation is missing. I guess it should be implemented in `sage.categories.AdditiveMagmas.CartesianProduct.ParentMethods.summation`.



---

archive/issue_comments_140332.json:
```json
{
    "body": "**Changing work_issues** from \"doctests\" to \"Cartesian products\".",
    "created_at": "2011-09-05T10:17:20Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140332",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "doctests" to "Cartesian products".



---

archive/issue_comments_140333.json:
```json
{
    "body": "<a id='comment:44'></a>\nHelas.\n\nI fixed the Cartesian products, but now I have a couple of hundred errors in elliptic curves. The problem is that non-unique parents occur in `sage.libs.singular.ring.singular_ring_new` when constructing a multivariate polynomial ring over a number field.\n\nI have no idea why that problem is invisible without my patch.\n\nIt seems that this ticket is a can of worms. I will keep the current bug fixes in my patch (sorry that I didn't submit it yet), but from now on new bug fixes will give rise to new tickets.",
    "created_at": "2011-09-05T13:17:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140333",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:44'></a>
Helas.

I fixed the Cartesian products, but now I have a couple of hundred errors in elliptic curves. The problem is that non-unique parents occur in `sage.libs.singular.ring.singular_ring_new` when constructing a multivariate polynomial ring over a number field.

I have no idea why that problem is invisible without my patch.

It seems that this ticket is a can of worms. I will keep the current bug fixes in my patch (sorry that I didn't submit it yet), but from now on new bug fixes will give rise to new tickets.



---

archive/issue_comments_140334.json:
```json
{
    "body": "**Changing dependencies** from \"#9138, #11115\" to \"#9138, #11115, #11780\".",
    "created_at": "2011-09-05T13:26:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140334",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing dependencies** from "#9138, #11115" to "#9138, #11115, #11780".



---

archive/issue_comments_140335.json:
```json
{
    "body": "<a id='comment:45'></a>\nThe ticket for the non-unique polynomial rings is #11780.",
    "created_at": "2011-09-05T13:26:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140335",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:45'></a>
The ticket for the non-unique polynomial rings is #11780.



---

archive/issue_comments_140336.json:
```json
{
    "body": "Implement the classes of morphisms and objects of a category; improve performance; some fixes relating with morphisms; `TestSuite` for all categories; add a `HomCategory` class to any category",
    "created_at": "2011-09-05T13:54:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140336",
    "user": "https://github.com/simon-king-jena"
}
```

Implement the classes of morphisms and objects of a category; improve performance; some fixes relating with morphisms; `TestSuite` for all categories; add a `HomCategory` class to any category



---

archive/attachments_013981.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "trac10667-morphisms_and_objects.patch",
    "asset_url": "tarball://root/attachments/some-uuid/ticket10667/trac10667-morphisms_and_objects.patch",
    "created_at": "2011-09-05T13:58:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "attachment",
    "url": "https://github.com/assets/some-id/some-uuid.patch",
    "user": "https://github.com/simon-king-jena"
}
```



---

archive/issue_comments_140337.json:
```json
{
    "body": "<a id='comment:46'></a>\nI have a patch at #11780 that solves the problem. I am thus also submitting my current patch on morphisms and objects. It contains many new features that I will describe later. It is still \"needs work\", since the patch contains some uncommented code that should eventually be deleted, and since there will certainly be a couple of \"trivial\" doctest errors, namely for tests that concern the super categories of a category (I had to re-order the super categories in order to get the method resolution orders right).\n\nBut if you want to play with it: Go ahead (and don't forget to apply #11780 first...).",
    "created_at": "2011-09-05T13:58:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140337",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:46'></a>
I have a patch at #11780 that solves the problem. I am thus also submitting my current patch on morphisms and objects. It contains many new features that I will describe later. It is still "needs work", since the patch contains some uncommented code that should eventually be deleted, and since there will certainly be a couple of "trivial" doctest errors, namely for tests that concern the super categories of a category (I had to re-order the super categories in order to get the method resolution orders right).

But if you want to play with it: Go ahead (and don't forget to apply #11780 first...).



---

archive/issue_comments_140338.json:
```json
{
    "body": "<a id='comment:47'></a>\nNicolas, I have a question on the category of schemes. In `sage.categories.schemes.Schemes.HomCategory`, there is a comment saying\n\n```\n            FIXME: what category structure is there on Homsets of schemes?\n            The result above is wrong, and should be fixed during the next\n            homsets overhaul.\n```\n\nIs there any answer? What is the category structure?",
    "created_at": "2011-09-05T14:17:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140338",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:47'></a>
Nicolas, I have a question on the category of schemes. In `sage.categories.schemes.Schemes.HomCategory`, there is a comment saying

```
            FIXME: what category structure is there on Homsets of schemes?
            The result above is wrong, and should be fixed during the next
            homsets overhaul.
```

Is there any answer? What is the category structure?



---

archive/issue_comments_140339.json:
```json
{
    "body": "<a id='comment:48'></a>\nHelas. The number of errors has decreased with the new patch. However, there remain numerous errors of the same kind (\"there is some non-unique parent and thus the coercion system complains\"). #11780 fixed many of these errors, but not all.",
    "created_at": "2011-09-05T14:53:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140339",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:48'></a>
Helas. The number of errors has decreased with the new patch. However, there remain numerous errors of the same kind ("there is some non-unique parent and thus the coercion system complains"). #11780 fixed many of these errors, but not all.



---

archive/issue_comments_140340.json:
```json
{
    "body": "<a id='comment:49'></a>\nReplying to [SimonKing](#comment%3A42):\n> I am making some progress. \n> \n> Testsuites are really a good thing!\n\n\n:-)\n\n> The good news: I think I found a stable way to get the method resolution order of hom category parent classes right.\n\n\nNice!",
    "created_at": "2011-09-05T20:56:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140340",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:49'></a>
Replying to [SimonKing](#comment%3A42):
> I am making some progress. 
> 
> Testsuites are really a good thing!


:-)

> The good news: I think I found a stable way to get the method resolution order of hom category parent classes right.


Nice!



---

archive/issue_comments_140341.json:
```json
{
    "body": "<a id='comment:50'></a>\nReplying to [SimonKing](#comment%3A43):\n> Just a status report: I got rid of the `__new__` method. Instead, I produce a `__classcall__` method, \n\n\nSounds good. I guess I had not yet implemented __classcall__ when I\nwrote the __new__ workarounds.\n\n> similar to what is done in `UniqueRepresentation` (and in fact I make `sage.categories.rings.Rings.HomCategory.ParentClass` inherit from `UniqueRepresentation`).\n\n\nI am not absolutely sure about this: as for parents, it is recommended\nfor Homsets to have unique representation, but I am not sure this is\ncurrently *required* and *enforced*. So this may open a larger can of\nworm than this ticket can handle. This might be the issue you\nencountered with polynomials.\n\n> After my patches and the addition of the base_ring method to Cartesian product categories, the problem arose with `__init_extra__` method in `sage.categories.algebras.Algebras.ParentMethods`: The Cartesian product of algebras over a ring R is an algebra over R (apparently acting diagonally). The `__init_extra__` tries to create a coercion from the R to the cartesian product. However, that ended in an infinite recursion. I solved it by adding a `from_base_ring` method, that is understood by `__init_extra__`.\n\n\nCool!\n\n> The remaining problem concerns summation of elements of Cartesian products. Multiplication is defined, via `sage.categories.magmas.Magmas.CartesianProduct.ParentMethods.product`. But summation is missing. I guess it should be implemented in `sage.categories.AdditiveMagmas.CartesianProduct.ParentMethods.summation`.\n\n\nThanks for implementing this missing piece!\n\nCheers,\n                     Nicolas",
    "created_at": "2011-09-05T21:01:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140341",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:50'></a>
Replying to [SimonKing](#comment%3A43):
> Just a status report: I got rid of the `__new__` method. Instead, I produce a `__classcall__` method, 


Sounds good. I guess I had not yet implemented __classcall__ when I
wrote the __new__ workarounds.

> similar to what is done in `UniqueRepresentation` (and in fact I make `sage.categories.rings.Rings.HomCategory.ParentClass` inherit from `UniqueRepresentation`).


I am not absolutely sure about this: as for parents, it is recommended
for Homsets to have unique representation, but I am not sure this is
currently *required* and *enforced*. So this may open a larger can of
worm than this ticket can handle. This might be the issue you
encountered with polynomials.

> After my patches and the addition of the base_ring method to Cartesian product categories, the problem arose with `__init_extra__` method in `sage.categories.algebras.Algebras.ParentMethods`: The Cartesian product of algebras over a ring R is an algebra over R (apparently acting diagonally). The `__init_extra__` tries to create a coercion from the R to the cartesian product. However, that ended in an infinite recursion. I solved it by adding a `from_base_ring` method, that is understood by `__init_extra__`.


Cool!

> The remaining problem concerns summation of elements of Cartesian products. Multiplication is defined, via `sage.categories.magmas.Magmas.CartesianProduct.ParentMethods.product`. But summation is missing. I guess it should be implemented in `sage.categories.AdditiveMagmas.CartesianProduct.ParentMethods.summation`.


Thanks for implementing this missing piece!

Cheers,
                     Nicolas



---

archive/issue_comments_140342.json:
```json
{
    "body": "<a id='comment:51'></a>\nReplying to [nthiery](#comment%3A50):\n> Replying to [SimonKing](#comment%3A43):\n> I am not absolutely sure about this: as for parents, it is recommended\n> for Homsets to have unique representation, but I am not sure this is\n> currently *required* and *enforced*.\n\n\nFirst of all, Homsets *are* cached. But using unique representation, it is less easy to break the cache.\n\nAnd I think that we should use any opportunity to reduce the number of violations of the unique parent assumption. After all, it is a matter of efficiency.\n\n> This might be the issue you\n> encountered with polynomials.\n\n\nActually it was. The problem was that (for the sake of explicit documentation) some tests create a polynomial ring directly, not using the `PolynomialRing` constructor. My solution: I introduced a parent method for rings, that removes the ring from the homset cache, and use it after any test that creates a non-unique parent. Of course, it is for internal use only.",
    "created_at": "2011-09-06T06:21:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140342",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:51'></a>
Replying to [nthiery](#comment%3A50):
> Replying to [SimonKing](#comment%3A43):
> I am not absolutely sure about this: as for parents, it is recommended
> for Homsets to have unique representation, but I am not sure this is
> currently *required* and *enforced*.


First of all, Homsets *are* cached. But using unique representation, it is less easy to break the cache.

And I think that we should use any opportunity to reduce the number of violations of the unique parent assumption. After all, it is a matter of efficiency.

> This might be the issue you
> encountered with polynomials.


Actually it was. The problem was that (for the sake of explicit documentation) some tests create a polynomial ring directly, not using the `PolynomialRing` constructor. My solution: I introduced a parent method for rings, that removes the ring from the homset cache, and use it after any test that creates a non-unique parent. Of course, it is for internal use only.



---

archive/issue_comments_140343.json:
```json
{
    "body": "<a id='comment:52'></a>\nReplying to [SimonKing](#comment%3A51):\n> First of all, Homsets *are* cached. But using unique representation, it is less easy to break the cache.\n\n\nI am glad that UniqueRepresentation works well :-)\n\n> And I think that we should use any opportunity to reduce the number of violations of the unique parent assumption. After all, it is a matter of efficiency.\n\n\nAgreed, the more unique parents, the better. But you don't have to fix\nall of Sage misfeatures in just this patch :-)\n\nBesides, I am still not yet sure that we want to strictly enforce 100%\nunique parents. There might be occasional exceptions -- I don't know,\nthings like temporarily created parents or what not -- where we might\nwant to not have uniqueness.\n\n> Actually it was. The problem was that (for the sake of explicit\n> documentation) some tests create a polynomial ring directly, not\n> using the `PolynomialRing` constructor. My solution: I introduced a\n> parent method for rings, that removes the ring from the homset\n> cache, and use it after any test that creates a non-unique\n> parent. Of course, it is for internal use only.\n\n\nOk. I could see other use cases. Should this be a method of\nUniqueRepresentation -- of course still for internal use ?\n\nCheers,\n                   Nicolas",
    "created_at": "2011-09-06T06:35:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140343",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:52'></a>
Replying to [SimonKing](#comment%3A51):
> First of all, Homsets *are* cached. But using unique representation, it is less easy to break the cache.


I am glad that UniqueRepresentation works well :-)

> And I think that we should use any opportunity to reduce the number of violations of the unique parent assumption. After all, it is a matter of efficiency.


Agreed, the more unique parents, the better. But you don't have to fix
all of Sage misfeatures in just this patch :-)

Besides, I am still not yet sure that we want to strictly enforce 100%
unique parents. There might be occasional exceptions -- I don't know,
things like temporarily created parents or what not -- where we might
want to not have uniqueness.

> Actually it was. The problem was that (for the sake of explicit
> documentation) some tests create a polynomial ring directly, not
> using the `PolynomialRing` constructor. My solution: I introduced a
> parent method for rings, that removes the ring from the homset
> cache, and use it after any test that creates a non-unique
> parent. Of course, it is for internal use only.


Ok. I could see other use cases. Should this be a method of
UniqueRepresentation -- of course still for internal use ?

Cheers,
                   Nicolas



---

archive/issue_comments_140344.json:
```json
{
    "body": "<a id='comment:53'></a>\nReplying to [nthiery](#comment%3A52):\n> I am glad that UniqueRepresentation works well :-)\n\n\nI am not 100% certain that they work well. At least for getting the tests of elliptic curves pass, we probably need #11670 (uniqueness of number fields). And note that (currently) I only introduce `UniqueRepresentation` to homsets of rings. I did not try to have it for all parents.\n\n> Agreed, the more unique parents, the better. But you don't have to fix\n> all of Sage misfeatures in just this patch :-)\n\n\nBut all that were uncovered by new tests introduced with this patch.\n \n> Besides, I am still not yet sure that we want to strictly enforce 100%\n> unique parents. There might be occasional exceptions -- I don't know,\n> things like temporarily created parents or what not -- where we might\n> want to not have uniqueness.\n\n\nWhy would one not want uniqueness for temporarily created parents? When the same parent is frequently created, then it is more efficient to just use a cache. Or are you concerned that one creates too many different parents that will stay in cache forever?\n\n> Ok. I could see other use cases. Should this be a method of\n> UniqueRepresentation -- of course still for internal use ?\n\n\nNo, what I just wrote can't be a method of `UniqueRepresentation`. Here is the purpose of what I wrote: Let X be a ring; `X._remove_from_homset_cache()` removes `Hom(X,Y)` and `Hom(Y,X)` from cache, for any ring `Y`.\n\nHence, it is not `X.__class__.__classcall__.cache` that is cleared, but `X.category().hom_category().parent_class.__classcall__.cache`. And an item is removed from the cache not if X is the value of that item, but if X appears in the key of the item.\n\nBut I think it would be a good idea to add a `X._reduce_from_cache()` method to `UniqueRepresentation`: It would remove any item of `X.__class__.__classcall__.cache` whose value is (equal to) X, and then it would try `X._reduce_from_homset_cache()` as well (which would of course only be available for rings).",
    "created_at": "2011-09-06T06:55:06Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140344",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:53'></a>
Replying to [nthiery](#comment%3A52):
> I am glad that UniqueRepresentation works well :-)


I am not 100% certain that they work well. At least for getting the tests of elliptic curves pass, we probably need #11670 (uniqueness of number fields). And note that (currently) I only introduce `UniqueRepresentation` to homsets of rings. I did not try to have it for all parents.

> Agreed, the more unique parents, the better. But you don't have to fix
> all of Sage misfeatures in just this patch :-)


But all that were uncovered by new tests introduced with this patch.
 
> Besides, I am still not yet sure that we want to strictly enforce 100%
> unique parents. There might be occasional exceptions -- I don't know,
> things like temporarily created parents or what not -- where we might
> want to not have uniqueness.


Why would one not want uniqueness for temporarily created parents? When the same parent is frequently created, then it is more efficient to just use a cache. Or are you concerned that one creates too many different parents that will stay in cache forever?

> Ok. I could see other use cases. Should this be a method of
> UniqueRepresentation -- of course still for internal use ?


No, what I just wrote can't be a method of `UniqueRepresentation`. Here is the purpose of what I wrote: Let X be a ring; `X._remove_from_homset_cache()` removes `Hom(X,Y)` and `Hom(Y,X)` from cache, for any ring `Y`.

Hence, it is not `X.__class__.__classcall__.cache` that is cleared, but `X.category().hom_category().parent_class.__classcall__.cache`. And an item is removed from the cache not if X is the value of that item, but if X appears in the key of the item.

But I think it would be a good idea to add a `X._reduce_from_cache()` method to `UniqueRepresentation`: It would remove any item of `X.__class__.__classcall__.cache` whose value is (equal to) X, and then it would try `X._reduce_from_homset_cache()` as well (which would of course only be available for rings).



---

archive/issue_comments_140345.json:
```json
{
    "body": "<a id='comment:54'></a>\nIt turns out that #11670 will not solve the problem. But it seems to me that I come closer to a solution: In contrast to many other cases, hom sets of number fields are *not* unique parents. With my patch, they are even less unique. Here is a show case:\n\nsage-4.6.2\n\n```\nsage: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a') \nsage: Hom(N,N) is Hom(N,N)\nFalse\nsage: Hom(N,N) == Hom(N,N)\nTrue\n```\n\nWith my patch, we still have\n\n```\nsage: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a') \nsage: Hom(N,N) is Hom(N,N)\nFalse\n```\nbut then\n\n```\nsage: Hom(N,N) == Hom(N,N)\nFalse\n```\n\nI don't know yet why this is the case, because the `__cmp__` function of number field homsets did not change.",
    "created_at": "2011-09-06T08:06:02Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140345",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:54'></a>
It turns out that #11670 will not solve the problem. But it seems to me that I come closer to a solution: In contrast to many other cases, hom sets of number fields are *not* unique parents. With my patch, they are even less unique. Here is a show case:

sage-4.6.2

```
sage: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a') 
sage: Hom(N,N) is Hom(N,N)
False
sage: Hom(N,N) == Hom(N,N)
True
```

With my patch, we still have

```
sage: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a') 
sage: Hom(N,N) is Hom(N,N)
False
```
but then

```
sage: Hom(N,N) == Hom(N,N)
False
```

I don't know yet why this is the case, because the `__cmp__` function of number field homsets did not change.



---

archive/issue_comments_140346.json:
```json
{
    "body": "<a id='comment:55'></a>\nAha! I understand!\n\n`Hom(N,N)` reduces to `N._Hom_(N)`, which *directly* constructs a number field hom set.\n\nBy consequence, `Hom(N,N)` does not become a unique parent, even though it inherits from `UniqueRepresentation` via inheritance from the category. But that inheritance takes place *after* creation of the hom set, so that it is too late for `Rings().HomCategory.ParentMethods.__classcall__`.\n\nIn other words: Via category inheritance, `Hom(N,N)` inherits `__eq__` from `UniqueRepresentation`, which is used for comparison and precedes the use of the custom `__cmp__` method of number field homsets. However, `__eq__` expects unique parents.\n\nWe thus have:\n\n```\nage: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a')\nsage: H = Hom(N,N)\nsage: H == Hom(N,N)\nFalse\nsage: H > Hom(N,N)\nFalse\nsage: H < Hom(N,N)\nFalse\n```\n\nI guess, until number fields are truly unique parents, I should add an `__eq__` to number field hom sets, in order to not have it inherited from `UniqueRepresentation`.",
    "created_at": "2011-09-06T08:22:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140346",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:55'></a>
Aha! I understand!

`Hom(N,N)` reduces to `N._Hom_(N)`, which *directly* constructs a number field hom set.

By consequence, `Hom(N,N)` does not become a unique parent, even though it inherits from `UniqueRepresentation` via inheritance from the category. But that inheritance takes place *after* creation of the hom set, so that it is too late for `Rings().HomCategory.ParentMethods.__classcall__`.

In other words: Via category inheritance, `Hom(N,N)` inherits `__eq__` from `UniqueRepresentation`, which is used for comparison and precedes the use of the custom `__cmp__` method of number field homsets. However, `__eq__` expects unique parents.

We thus have:

```
age: N = NumberField(x^12 - 4*x^11 + 6*x^10 - 5*x^9 + 5*x^8 - 9*x^7 + 21*x^6 - 9*x^5 + 5*x^4 - 5*x^3 + 6*x^2 - 4*x + 1, 'a')
sage: H = Hom(N,N)
sage: H == Hom(N,N)
False
sage: H > Hom(N,N)
False
sage: H < Hom(N,N)
False
```

I guess, until number fields are truly unique parents, I should add an `__eq__` to number field hom sets, in order to not have it inherited from `UniqueRepresentation`.



---

archive/issue_comments_140347.json:
```json
{
    "body": "<a id='comment:56'></a>\nI think I found a valid work-around: Sometimes, a number field is created with passing the option `cache=False` to the number field constructor. If that option is used, I suggest to call the new `_remove_from_homset_cache`. It seems to work!\n\nWith that change (not yet posted), we have\n\n```\nsage: E = EllipticCurve('389a'); P = E.heegner_point(-7, 5); P\nHeegner point of discriminant -7 and conductor 5 on elliptic curve of conductor 389\nsage:  z = P.point_exact(100, optimize=True)\n```\nWith the old patch, one would have the following error:\n\n```\nAssertionError: BUG in coercion model\n    Apparently there are two versions of\n        Number Field in a with defining polynomial x^12 + 4*x^11 + 56*x^10 + 170*x^9 + 1130*x^8 + 2564*x^7 + 10791*x^6 + 18054*x^5 + 51340*x^4 + 57530*x^3 + 102986*x^2 + 53724*x + 35001\n    in the cache.\n```\n\nRunning doctests, and then I hope the most serious problems have finally disappeared...",
    "created_at": "2011-09-06T08:42:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140347",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:56'></a>
I think I found a valid work-around: Sometimes, a number field is created with passing the option `cache=False` to the number field constructor. If that option is used, I suggest to call the new `_remove_from_homset_cache`. It seems to work!

With that change (not yet posted), we have

```
sage: E = EllipticCurve('389a'); P = E.heegner_point(-7, 5); P
Heegner point of discriminant -7 and conductor 5 on elliptic curve of conductor 389
sage:  z = P.point_exact(100, optimize=True)
```
With the old patch, one would have the following error:

```
AssertionError: BUG in coercion model
    Apparently there are two versions of
        Number Field in a with defining polynomial x^12 + 4*x^11 + 56*x^10 + 170*x^9 + 1130*x^8 + 2564*x^7 + 10791*x^6 + 18054*x^5 + 51340*x^4 + 57530*x^3 + 102986*x^2 + 53724*x + 35001
    in the cache.
```

Running doctests, and then I hope the most serious problems have finally disappeared...



---

archive/issue_comments_140348.json:
```json
{
    "body": "**Changing work_issues** from \"Cartesian products\" to \"Cope with non-unique number fields\".",
    "created_at": "2011-09-06T08:42:37Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140348",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing work_issues** from "Cartesian products" to "Cope with non-unique number fields".



---

archive/issue_comments_140349.json:
```json
{
    "body": "<a id='comment:57'></a>\nReplying to [SimonKing](#comment%3A53):\n> Why would one not want uniqueness for temporarily created parents? When the same parent is frequently created, then it is more efficient to just use a cache. Or are you concerned that one creates too many different parents that will stay in cache forever?\n\n\nPossibly so. Or about creating many different parents that each need a\nlot of input data, or maybe some non hashable data; and maybe you need\neach such parent only once. So the overhead in time or code complexity\nof guaranteeing unique representation would not be worth it.\n\nHonestly, I don't have a specific use case, just a bad feeling about\nit.\n\n> But I think it would be a good idea to add a `X._reduce_from_cache()` method to `UniqueRepresentation`: It would remove any item of `X.__class__.__classcall__.cache` whose value is (equal to) X,\n\n\n+1. I am not sure about the name though. What about something like\n_delete_from_cache instead?\n\n> and then it would try `X._reduce_from_homset_cache()` as well (which\n> would of course only be available for rings).\n\n\nUniqueRepresentation is meant to also be used by non Parents. So I'd\nrather have nothing Parent-related in it. On the other hand, Parent\ncould overload UniqueRepresentation's method to also call that for\nhomsets.\n\nCheers,\n\t\t\t\tNicolas",
    "created_at": "2011-09-06T15:27:58Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140349",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:57'></a>
Replying to [SimonKing](#comment%3A53):
> Why would one not want uniqueness for temporarily created parents? When the same parent is frequently created, then it is more efficient to just use a cache. Or are you concerned that one creates too many different parents that will stay in cache forever?


Possibly so. Or about creating many different parents that each need a
lot of input data, or maybe some non hashable data; and maybe you need
each such parent only once. So the overhead in time or code complexity
of guaranteeing unique representation would not be worth it.

Honestly, I don't have a specific use case, just a bad feeling about
it.

> But I think it would be a good idea to add a `X._reduce_from_cache()` method to `UniqueRepresentation`: It would remove any item of `X.__class__.__classcall__.cache` whose value is (equal to) X,


+1. I am not sure about the name though. What about something like
_delete_from_cache instead?

> and then it would try `X._reduce_from_homset_cache()` as well (which
> would of course only be available for rings).


UniqueRepresentation is meant to also be used by non Parents. So I'd
rather have nothing Parent-related in it. On the other hand, Parent
could overload UniqueRepresentation's method to also call that for
homsets.

Cheers,
				Nicolas



---

archive/issue_comments_140350.json:
```json
{
    "body": "<a id='comment:58'></a>\nHi Simon,\n\nReplying to [SimonKing](#comment%3A55):\n> Aha! I understand!\n\n\n:-)\n\n> I guess, until number fields are truly unique parents, I should add an `__eq__` to number field hom sets, in order to not have it inherited from `UniqueRepresentation`.\n\n\nI am not very keen on having a class inherit (indirectly) from\nUniqueRepresentation, and then hacking it's way around to actually not\nhave to implement the unique representation protocole. I'd rather only\ninherit explicitly from UniqueRepresentation when I mean it.\n\nCheers,",
    "created_at": "2011-09-06T15:32:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140350",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:58'></a>
Hi Simon,

Replying to [SimonKing](#comment%3A55):
> Aha! I understand!


:-)

> I guess, until number fields are truly unique parents, I should add an `__eq__` to number field hom sets, in order to not have it inherited from `UniqueRepresentation`.


I am not very keen on having a class inherit (indirectly) from
UniqueRepresentation, and then hacking it's way around to actually not
have to implement the unique representation protocole. I'd rather only
inherit explicitly from UniqueRepresentation when I mean it.

Cheers,



---

archive/issue_comments_140351.json:
```json
{
    "body": "<a id='comment:59'></a>\nReplying to [nthiery](#comment%3A57):\n> > But I think it would be a good idea to add a `X._reduce_from_cache()` method to `UniqueRepresentation`: It would remove any item of `X.__class__.__classcall__.cache` whose value is (equal to) X,\n\n> \n> +1. I am not sure about the name though. What about something like\n> _delete_from_cache instead?\n\n\nSorry, I meant to write `_remove_from_cache`, not `_reduce_from_cache`.\n\n> > and then it would try `X._reduce_from_homset_cache()` as well (which\n> > would of course only be available for rings).\n\n> \n> UniqueRepresentation is meant to also be used by non Parents.\n\n\nAnd `_reduce_from_homset_cache` is only for those parents that happen to belong to the category of rings. That's why I write \"try ... (which would ... only be available for rings)\". It would not be available for non-rings, and in particular not for non-parents. So, no problem, the attribute error would be caught anyway.\n\n> Parent\n> could overload UniqueRepresentation's method to also call that for\n> homsets.\n\n\nNo, it could not, because most parents are no `UniqueRepresentation`s.",
    "created_at": "2011-09-06T15:49:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140351",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:59'></a>
Replying to [nthiery](#comment%3A57):
> > But I think it would be a good idea to add a `X._reduce_from_cache()` method to `UniqueRepresentation`: It would remove any item of `X.__class__.__classcall__.cache` whose value is (equal to) X,

> 
> +1. I am not sure about the name though. What about something like
> _delete_from_cache instead?


Sorry, I meant to write `_remove_from_cache`, not `_reduce_from_cache`.

> > and then it would try `X._reduce_from_homset_cache()` as well (which
> > would of course only be available for rings).

> 
> UniqueRepresentation is meant to also be used by non Parents.


And `_reduce_from_homset_cache` is only for those parents that happen to belong to the category of rings. That's why I write "try ... (which would ... only be available for rings)". It would not be available for non-rings, and in particular not for non-parents. So, no problem, the attribute error would be caught anyway.

> Parent
> could overload UniqueRepresentation's method to also call that for
> homsets.


No, it could not, because most parents are no `UniqueRepresentation`s.



---

archive/issue_comments_140352.json:
```json
{
    "body": "<a id='comment:60'></a>\nReplying to [nthiery](#comment%3A58):\n> I am not very keen on having a class inherit (indirectly) from\n> UniqueRepresentation, and then hacking it's way around to actually not\n> have to implement the unique representation protocole. I'd rather only\n> inherit explicitly from UniqueRepresentation when I mean it.\n\n\nYes, what I did doesn't fully convince me. \n\nWith my patch, the `Rings().HomCategory.ParentMethods` inherits from `UniqueRepresentation`, and since `NumberFields()` is a sub-category of `Rings()`, the default `NumberFields().hom_category().parent_class inherits from `UniqueRepresentation` as well.\n\nBut it would be possible to have a custom `NumberFields().HomCategory.ParentMethods`, similar to the custom `Rings().HomCategory.ParentMethods`.\n\nWhile `Rings().hom_category().parent_class` with my patch inherits from `UniqueRepresentation` and (via classcall) from either `sage.rings.homset.RingHomset_generic` or `sage.rings.homset.RingHomset_quo_ring`, one could have `NumberFields().hom_category().parent_class` inherit from `sage.rings.number_field.morphism.NumberFieldHomset`, but not from `UniqueRepresentation`.",
    "created_at": "2011-09-06T15:57:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140352",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:60'></a>
Replying to [nthiery](#comment%3A58):
> I am not very keen on having a class inherit (indirectly) from
> UniqueRepresentation, and then hacking it's way around to actually not
> have to implement the unique representation protocole. I'd rather only
> inherit explicitly from UniqueRepresentation when I mean it.


Yes, what I did doesn't fully convince me. 

With my patch, the `Rings().HomCategory.ParentMethods` inherits from `UniqueRepresentation`, and since `NumberFields()` is a sub-category of `Rings()`, the default `NumberFields().hom_category().parent_class inherits from `UniqueRepresentation` as well.

But it would be possible to have a custom `NumberFields().HomCategory.ParentMethods`, similar to the custom `Rings().HomCategory.ParentMethods`.

While `Rings().hom_category().parent_class` with my patch inherits from `UniqueRepresentation` and (via classcall) from either `sage.rings.homset.RingHomset_generic` or `sage.rings.homset.RingHomset_quo_ring`, one could have `NumberFields().hom_category().parent_class` inherit from `sage.rings.number_field.morphism.NumberFieldHomset`, but not from `UniqueRepresentation`.



---

archive/issue_comments_140353.json:
```json
{
    "body": "<a id='comment:61'></a>\nNext: I accidentally found that quotient rings are no unique parents either.\n\nI guess they should be, right?",
    "created_at": "2011-09-06T16:26:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140353",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:61'></a>
Next: I accidentally found that quotient rings are no unique parents either.

I guess they should be, right?



---

archive/issue_comments_140354.json:
```json
{
    "body": "<a id='comment:62'></a>\nReplying to [SimonKing](#comment%3A61):\n> Next: I accidentally found that quotient rings are no unique parents either.\n> \n> I guess they should be, right?\n\n\nDealt with on a different ticket, I mean...",
    "created_at": "2011-09-06T16:30:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140354",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:62'></a>
Replying to [SimonKing](#comment%3A61):
> Next: I accidentally found that quotient rings are no unique parents either.
> 
> I guess they should be, right?


Dealt with on a different ticket, I mean...



---

archive/issue_comments_140355.json:
```json
{
    "body": "<a id='comment:63'></a>\nReplying to [SimonKing](#comment%3A60):\n> But it would be possible to have a custom `NumberFields().HomCategory.ParentMethods`, similar to the custom `Rings().HomCategory.ParentMethods`.\n> \n> While `Rings().hom_category().parent_class` with my patch inherits from `UniqueRepresentation` and (via classcall) from either `sage.rings.homset.RingHomset_generic` or `sage.rings.homset.RingHomset_quo_ring`, one could have `NumberFields().hom_category().parent_class` inherit from `sage.rings.number_field.morphism.NumberFieldHomset`, but not from `UniqueRepresentation`.\n\n\nSound good.",
    "created_at": "2011-09-06T20:15:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140355",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:63'></a>
Replying to [SimonKing](#comment%3A60):
> But it would be possible to have a custom `NumberFields().HomCategory.ParentMethods`, similar to the custom `Rings().HomCategory.ParentMethods`.
> 
> While `Rings().hom_category().parent_class` with my patch inherits from `UniqueRepresentation` and (via classcall) from either `sage.rings.homset.RingHomset_generic` or `sage.rings.homset.RingHomset_quo_ring`, one could have `NumberFields().hom_category().parent_class` inherit from `sage.rings.number_field.morphism.NumberFieldHomset`, but not from `UniqueRepresentation`.


Sound good.



---

archive/issue_comments_140356.json:
```json
{
    "body": "<a id='comment:64'></a>\nReplying to [SimonKing](#comment%3A59):\n> And `_reduce_from_homset_cache` is only for those parents that\n>  happen to belong to the category of rings. That's why I write \"try\n> ... (which would ... only be available for rings)\". It would not be\n>  available for non-rings, and in particular not for non-parents. So,\n>  no problem, the attribute error would be caught anyway.\n\n\nYes, it would work. Yet, in a perfect world, UniqueRepresentation\nought to be generalized outside of Sage, as a general purpose Python\ntool (even though I am not sure anyone will take the time for\nthat). So having some logic in there specifically targetted toward\nhomsets smells. But maybe it's just a question of finding a more\ngeneral name for this hook.\n\n> No, it could not, because most parents are no `UniqueRepresentation`s.\n\n\nGood point :-)",
    "created_at": "2011-09-06T20:20:59Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140356",
    "user": "https://github.com/nthiery"
}
```

<a id='comment:64'></a>
Replying to [SimonKing](#comment%3A59):
> And `_reduce_from_homset_cache` is only for those parents that
>  happen to belong to the category of rings. That's why I write "try
> ... (which would ... only be available for rings)". It would not be
>  available for non-rings, and in particular not for non-parents. So,
>  no problem, the attribute error would be caught anyway.


Yes, it would work. Yet, in a perfect world, UniqueRepresentation
ought to be generalized outside of Sage, as a general purpose Python
tool (even though I am not sure anyone will take the time for
that). So having some logic in there specifically targetted toward
homsets smells. But maybe it's just a question of finding a more
general name for this hook.

> No, it could not, because most parents are no `UniqueRepresentation`s.


Good point :-)



---

archive/issue_comments_140357.json:
```json
{
    "body": "<a id='comment:65'></a>\nI am not sure if the attached patch is up to date. Unfortunately, applying it to sage-4.7.2.alpha3 gives 5 hunks that fail to apply. I hope that I'll be able to get finally a working version during the upcoming sage days 34.",
    "created_at": "2011-09-24T13:57:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140357",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:65'></a>
I am not sure if the attached patch is up to date. Unfortunately, applying it to sage-4.7.2.alpha3 gives 5 hunks that fail to apply. I hope that I'll be able to get finally a working version during the upcoming sage days 34.



---

archive/issue_comments_140358.json:
```json
{
    "body": "**Changing keywords** from \"objects morphisms containment\" to \"objects morphisms containment sd34\".",
    "created_at": "2011-09-24T13:57:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140358",
    "user": "https://github.com/simon-king-jena"
}
```

**Changing keywords** from "objects morphisms containment" to "objects morphisms containment sd34".



---

archive/issue_events_032891.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "milestone": "sage-5.0",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10667#event-32891"
}
```



---

archive/issue_events_032892.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2013-08-13T15:35:53Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10667#event-32892"
}
```



---

archive/issue_events_032893.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "milestone": "sage-5.12",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10667#event-32893"
}
```



---

archive/issue_events_032894.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-01-30T21:20:52Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10667#event-32894"
}
```



---

archive/issue_events_032895.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "milestone": "sage-6.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10667#event-32895"
}
```



---

archive/issue_events_032896.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-05-06T15:20:58Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10667#event-32896"
}
```



---

archive/issue_events_032897.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "demilestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "milestone": "sage-6.3",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10667#event-32897"
}
```



---

archive/issue_events_032898.json:
```json
{
    "actor": "https://trac.sagemath.org/admin/accounts/users/vbraun_spam",
    "created_at": "2014-08-10T16:51:03Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "milestone": "sage-6.4",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10667#event-32898"
}
```



---

archive/issue_comments_140359.json:
```json
{
    "body": "<a id='comment:70'></a>\nLet us see if anything from this patch could be useful in the current state of the art. See #10668 and #16340.",
    "created_at": "2014-10-13T14:56:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10667",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10667#issuecomment-140359",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:70'></a>
Let us see if anything from this patch could be useful in the current state of the art. See #10668 and #16340.
