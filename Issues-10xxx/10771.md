# Issue 10771: gcd and lcm for fraction fields

archive/issues_010706.json:
```json
{
    "body": "At [sage-devel](http://groups.google.com/group/sage-devel/browse_thread/thread/cd05585cf395b3a0/a34f04f32d68e525), the question was raised whether it really is a good idea that the gcd in the rational field should return either `0` or `1`.\n\nSince *any* non-zero element of `QQ` qualifies as gcd of two non-zero rationals, it should be possible to define gcd and lcm, so that `gcd(x,y)*lcm(x,y)==x*y` holds for any rational numbers x,y, and so that `gcd(QQ(m),QQ(n))==gcd(m,n)` and `lcm(QQ(m),QQ(n))==lcm(m,n)` for any two integers m,n.\n\nMoreover, it should be possible to provide gcd/lcm for any fraction field of a `PID`: Note that currently gcd raises a type error for elements of `Frac(QQ['x'])`.\n\nThe aim is to implement gcd and lcm as `ElementMethods` of the category `QuotientFields()`.\n\n**__Approach__**\n\nLet R be an integral domain, assume that it provides gcd and lcm, and let F be its fraction field. Since R has gcd, we can assume that `x.numerator()` and `x.denominator()` are relatively prime for any element x of F.\n\nThen, define\n\n```\ngcd(x,y) = gcd(x.numerator(),y.numerator())/lcm(x.denominator(),y.denominator())\nlcm(x,y) = lcm(x.numerator(),y.numerator())/gcd(x.denominator(),y.denominator())\n```\n\n**__Benefits__**\n\nIf that approach is mathematically sober, we obtain the following equalities up to units in R:\n\n* `gcd(x,y)*lcm(x,y)==x*y`, for any x,y in F, provided that the equality holds for any x,y in R.\n* `gcd(F(x),F(y))==gcd(x,y)` and `lcm(F(x),F(y))==lcm(x,y)` for any x,y in R.\n\n\n\nAssignee: @aghitza\n\nCC:  @burcin\n\nKeywords: gcd lcm fraction fields\n\nResolution: fixed\n\nAuthor: Simon King\n\nReviewer: Marco Streng, Mariah Lenox\n\nMerged: sage-4.7.2.alpha0\n\nIssue created by migration from https://trac.sagemath.org/ticket/10771\n\n",
    "closed_at": "2011-07-22T12:50:17Z",
    "created_at": "2011-02-11T09:57:26Z",
    "labels": [
        "component: basic arithmetic"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-4.7.2",
    "title": "gcd and lcm for fraction fields",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/10771",
    "user": "https://github.com/simon-king-jena"
}
```
At [sage-devel](http://groups.google.com/group/sage-devel/browse_thread/thread/cd05585cf395b3a0/a34f04f32d68e525), the question was raised whether it really is a good idea that the gcd in the rational field should return either `0` or `1`.

Since *any* non-zero element of `QQ` qualifies as gcd of two non-zero rationals, it should be possible to define gcd and lcm, so that `gcd(x,y)*lcm(x,y)==x*y` holds for any rational numbers x,y, and so that `gcd(QQ(m),QQ(n))==gcd(m,n)` and `lcm(QQ(m),QQ(n))==lcm(m,n)` for any two integers m,n.

Moreover, it should be possible to provide gcd/lcm for any fraction field of a `PID`: Note that currently gcd raises a type error for elements of `Frac(QQ['x'])`.

The aim is to implement gcd and lcm as `ElementMethods` of the category `QuotientFields()`.

**__Approach__**

Let R be an integral domain, assume that it provides gcd and lcm, and let F be its fraction field. Since R has gcd, we can assume that `x.numerator()` and `x.denominator()` are relatively prime for any element x of F.

Then, define

```
gcd(x,y) = gcd(x.numerator(),y.numerator())/lcm(x.denominator(),y.denominator())
lcm(x,y) = lcm(x.numerator(),y.numerator())/gcd(x.denominator(),y.denominator())
```

**__Benefits__**

If that approach is mathematically sober, we obtain the following equalities up to units in R:

* `gcd(x,y)*lcm(x,y)==x*y`, for any x,y in F, provided that the equality holds for any x,y in R.
* `gcd(F(x),F(y))==gcd(x,y)` and `lcm(F(x),F(y))==lcm(x,y)` for any x,y in R.



Assignee: @aghitza

CC:  @burcin

Keywords: gcd lcm fraction fields

Resolution: fixed

Author: Simon King

Reviewer: Marco Streng, Mariah Lenox

Merged: sage-4.7.2.alpha0

Issue created by migration from https://trac.sagemath.org/ticket/10771





---

archive/issue_comments_136181.json:
```json
{
    "body": "Description changed:\n``````diff\n--- \n+++ \n@@ -6,7 +6,22 @@\n \n The aim is to implement gcd and lcm as `ElementMethods` of the category `QuotientFields()`.\n \n-It seems that defining `gcd(a/b,c/d) = gcd(a,c)/lcm(b,d)` and `lcm(a/b,c/d) = lcm(a,c)/gcd(b,d)` works, *under the assumption that `a/b` and `c/d` are reduced fractions*. Note: Since we need `gcd` for `a,b,c,d` anyway, it is no problem to reduce the fractions.\n+**__Approach__**\n \n-But I am not 100% sure whether that approach is mathematically sober.\n+Let R be an integral domain, assume that it provides gcd and lcm, and let F be its fraction field. Since R has gcd, we can assume that `x.numerator()` and `x.denominator()` are relatively prime for any element x of F.\n \n+Then, define\n+\n+```\n+gcd(x,y) = gcd(x.numerator(),y.numerator())/lcm(x.denominator(),y.denominator())\n+lcm(x,y) = lcm(x.numerator(),y.numerator())/gcd(x.denominator(),y.denominator())\n+```\n+\n+**__Benefits__**\n+\n+If that approach is mathematically sober, we obtain the following equalities up to units in R:\n+\n+* `gcd(x,y)*lcm(x,y)==x*y`, for any x,y in F, provided that the equality holds for any x,y in R.\n+* `gcd(F(x),F(y))==gcd(x,y)` and `lcm(F(x),F(y))==lcm(x,y)` for any x,y in R.\n+\n+\n``````\n",
    "created_at": "2011-02-11T10:22:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136181",
    "user": "https://github.com/simon-king-jena"
}
```

Description changed:
``````diff
--- 
+++ 
@@ -6,7 +6,22 @@
 
 The aim is to implement gcd and lcm as `ElementMethods` of the category `QuotientFields()`.
 
-It seems that defining `gcd(a/b,c/d) = gcd(a,c)/lcm(b,d)` and `lcm(a/b,c/d) = lcm(a,c)/gcd(b,d)` works, *under the assumption that `a/b` and `c/d` are reduced fractions*. Note: Since we need `gcd` for `a,b,c,d` anyway, it is no problem to reduce the fractions.
+**__Approach__**
 
-But I am not 100% sure whether that approach is mathematically sober.
+Let R be an integral domain, assume that it provides gcd and lcm, and let F be its fraction field. Since R has gcd, we can assume that `x.numerator()` and `x.denominator()` are relatively prime for any element x of F.
 
+Then, define
+
+```
+gcd(x,y) = gcd(x.numerator(),y.numerator())/lcm(x.denominator(),y.denominator())
+lcm(x,y) = lcm(x.numerator(),y.numerator())/gcd(x.denominator(),y.denominator())
+```
+
+**__Benefits__**
+
+If that approach is mathematically sober, we obtain the following equalities up to units in R:
+
+* `gcd(x,y)*lcm(x,y)==x*y`, for any x,y in F, provided that the equality holds for any x,y in R.
+* `gcd(F(x),F(y))==gcd(x,y)` and `lcm(F(x),F(y))==lcm(x,y)` for any x,y in R.
+
+
``````




---

archive/issue_comments_136182.json:
```json
{
    "body": "<a id='comment:2'></a>Without the patch, we had:\n\n```\nsage: gcd(2/1,4)  # does not restrict to ZZ\n1\nsage: lcm(2/1,4)  # Bug\nTraceback (most recent call last):\n...\nTypeError: Argument 'other' has incorrect type (expected sage.rings.rational.Rational, got sage.rings.integer.Integer)\nsage: R.<x> = QQ[]\nsage: lcm(1/(x+1),1/(x+1)^2) # note that the error message names gcd, not lcm!\nTraceback (most recent call last):\n...\nTypeError: unable to find gcd of 1/(x + 1) and 1/(x^2 + 2*x + 1)\nsage: gcd(1/(x+1),1/(x+1)^2)\nTraceback (most recent call last):\n...\nTypeError: unable to find gcd of 1/(x + 1) and 1/(x^2 + 2*x + 1)\nsage: gcd(int(2),2/1)\n2\nsage: gcd(2,2/1) # gcd of ints and integers are different\n1\n```\n\nWith the patch, one has\n\n```\nsage: gcd(2/1,4)\n2\nsage: lcm(2/1,4)\n4\nsage: R.<x> = QQ[]\nsage: lcm(1/(x+1),1/(x+1)^2)\n1/(x + 1)\nsage: gcd(1/(x+1),1/(x+1)^2)\n1/(x^2 + 2*x + 1)\nsage: gcd(int(2),2/1)\n2\nsage: gcd(2,2/1)\n2\n```",
    "created_at": "2011-02-14T13:12:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136182",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:2'></a>Without the patch, we had:

```
sage: gcd(2/1,4)  # does not restrict to ZZ
1
sage: lcm(2/1,4)  # Bug
Traceback (most recent call last):
...
TypeError: Argument 'other' has incorrect type (expected sage.rings.rational.Rational, got sage.rings.integer.Integer)
sage: R.<x> = QQ[]
sage: lcm(1/(x+1),1/(x+1)^2) # note that the error message names gcd, not lcm!
Traceback (most recent call last):
...
TypeError: unable to find gcd of 1/(x + 1) and 1/(x^2 + 2*x + 1)
sage: gcd(1/(x+1),1/(x+1)^2)
Traceback (most recent call last):
...
TypeError: unable to find gcd of 1/(x + 1) and 1/(x^2 + 2*x + 1)
sage: gcd(int(2),2/1)
2
sage: gcd(2,2/1) # gcd of ints and integers are different
1
```

With the patch, one has

```
sage: gcd(2/1,4)
2
sage: lcm(2/1,4)
4
sage: R.<x> = QQ[]
sage: lcm(1/(x+1),1/(x+1)^2)
1/(x + 1)
sage: gcd(1/(x+1),1/(x+1)^2)
1/(x^2 + 2*x + 1)
sage: gcd(int(2),2/1)
2
sage: gcd(2,2/1)
2
```



---

archive/issue_comments_136183.json:
```json
{
    "body": "Changing type from PLEASE CHANGE to defect.",
    "created_at": "2011-02-14T13:12:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136183",
    "user": "https://github.com/simon-king-jena"
}
```

Changing type from PLEASE CHANGE to defect.



---

archive/issue_comments_136184.json:
```json
{
    "body": "Changing author from \"\" to \"Simon King\"",
    "created_at": "2011-02-14T13:12:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136184",
    "user": "https://github.com/simon-king-jena"
}
```

Changing author from "" to "Simon King"



---

archive/issue_comments_136185.json:
```json
{
    "body": "Changing status from new to needs_review.",
    "created_at": "2011-02-14T13:12:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136185",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from new to needs_review.



---

archive/issue_comments_136186.json:
```json
{
    "body": "Changing reviewer from \"\" to \"Marco Streng\"",
    "created_at": "2011-02-14T14:48:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136186",
    "user": "https://github.com/mstreng"
}
```

Changing reviewer from "" to "Marco Streng"



---

archive/issue_comments_136187.json:
```json
{
    "body": "<a id='comment:3'></a>A couple of comments:\n\n* I don't see the point of keeping a special function `gcd_rational(self, other, **kwds):` that returns a GCD in the set {0,1}. Why only for QQ? Why at all? Also, the difference between `gcd` and `gcd_rational` is not explained by the word \"rational\". Perhaps `gcd_zero_one` would be a more informative name.\n\n* Everything generalizes from principal ideal domains to unique factorization domains (UFD's) (such as multivariate polynomial rings over unique factorization domains) as long as they have `gcd` and `lcm` methods implemented. Why not write \"unique factorization domain\" in the documentation instead of \"principal ideal domain\"?\n\n* Suppose I have a fraction field F of a ring of type R that does not have lcm and gcd methods, or these methods exist, but raise other kinds of errors, e.g. because the ring is not a UFD or the methods have not been implemented. Let a and b be elements of F. Then a and b have a gcd in F because F is a field, so I would expect a.gcd(b) to return something (anything basically). After applying your patch, if I do `a.gcd(b)`, it is very confusing to get an `AttributeError: 'RElement' object has no attribute 'gcd'`: I'm not interested in gcd's of RElements, only of `(Fraction)FieldElements`. You could put your entire `gcd` and `lcm` code between `try:` and `except (AttributeError, NotImplementedError, TypeError, ValueError):` to return the same 0 or 1 that `gcd_rational` would (which is a mathematically correct gcd in F after all).\n\n* trac has a `t` too much in line 1610 of ring.pyx: `the case of the rational field. However, since tract ticket #10771,`\n\n* you write \"quotient field\" in the documentation. You could write \"fraction field\" to avoid confusion with quotient rings, which may be fields. This makes it more clear that you refer to the mathematical counterpart of Sage's \"`FractionField`\"?\n\n* `All tests passed!` with -long, well documented, looks good.",
    "created_at": "2011-02-14T14:48:31Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136187",
    "user": "https://github.com/mstreng"
}
```

<a id='comment:3'></a>A couple of comments:

* I don't see the point of keeping a special function `gcd_rational(self, other, **kwds):` that returns a GCD in the set {0,1}. Why only for QQ? Why at all? Also, the difference between `gcd` and `gcd_rational` is not explained by the word "rational". Perhaps `gcd_zero_one` would be a more informative name.

* Everything generalizes from principal ideal domains to unique factorization domains (UFD's) (such as multivariate polynomial rings over unique factorization domains) as long as they have `gcd` and `lcm` methods implemented. Why not write "unique factorization domain" in the documentation instead of "principal ideal domain"?

* Suppose I have a fraction field F of a ring of type R that does not have lcm and gcd methods, or these methods exist, but raise other kinds of errors, e.g. because the ring is not a UFD or the methods have not been implemented. Let a and b be elements of F. Then a and b have a gcd in F because F is a field, so I would expect a.gcd(b) to return something (anything basically). After applying your patch, if I do `a.gcd(b)`, it is very confusing to get an `AttributeError: 'RElement' object has no attribute 'gcd'`: I'm not interested in gcd's of RElements, only of `(Fraction)FieldElements`. You could put your entire `gcd` and `lcm` code between `try:` and `except (AttributeError, NotImplementedError, TypeError, ValueError):` to return the same 0 or 1 that `gcd_rational` would (which is a mathematically correct gcd in F after all).

* trac has a `t` too much in line 1610 of ring.pyx: `the case of the rational field. However, since tract ticket #10771,`

* you write "quotient field" in the documentation. You could write "fraction field" to avoid confusion with quotient rings, which may be fields. This makes it more clear that you refer to the mathematical counterpart of Sage's "`FractionField`"?

* `All tests passed!` with -long, well documented, looks good.



---

archive/issue_comments_136188.json:
```json
{
    "body": "<a id='comment:4'></a>Related tickets: #9819, #10459",
    "created_at": "2011-02-14T14:55:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136188",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:4'></a>Related tickets: #9819, #10459



---

archive/issue_comments_136189.json:
```json
{
    "body": "<a id='comment:5'></a>Trivial: typo \"tract\" for \"trac\" in patch.",
    "created_at": "2011-02-14T15:43:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136189",
    "user": "https://trac.sagemath.org/admin/accounts/users/dsm"
}
```

<a id='comment:5'></a>Trivial: typo "tract" for "trac" in patch.



---

archive/issue_comments_136190.json:
```json
{
    "body": "<a id='comment:6'></a>Hi Marco,\n\nReplying to [comment:3 mstreng]:\n> A couple of comments:\n> \n> * I don't see the point of keeping a special function `gcd_rational(self, other, **kwds):` that returns a GCD in the set {0,1}. Why only for QQ? Why at all? Also, the difference between `gcd` and `gcd_rational` is not explained by the word \"rational\". Perhaps `gcd_zero_one` would be a more informative name.\n\n\nPerhaps I am too 'conservative': I would rather rename something than to delete it.\n\nBut I suppose it would be better to implement a gcd and an lcm as element methods of `Fields()` -- see #9819. In that way, one could easily provide a correct gcd/lcm behaviour for all fields, and for fraction fields of PID one would still obtain a gcd/lcm behaviour that is not only correct but nice.\n\n> * Everything generalizes from principal ideal domains to unique factorization domains (UFD's) (such as multivariate polynomial rings over unique factorization domains) as long as they have `gcd` and `lcm` methods implemented. Why not write \"unique factorization domain\" in the documentation instead of \"principal ideal domain\"?\n\n\nGood question. I did it by accident. However, it matches the sad fact that the categories are a little askew here:\n\n```\nsage: PrincipalIdealDomains().is_subcategory(UniqueFactorizationDomains())\nFalse  # shouldn't that be \"True\"?\nsage: PrincipalIdealDomains().is_subcategory(GcdDomains())\nTrue\nsage: UniqueFactorizationDomains().is_subcategory(GcdDomains())\nTrue\n```\n\nPerhaps one should write \"fraction field of an integral domain with gcd and lcm\"? Because that's what is duck typed.\n\n> * Suppose I have a fraction field F of a ring of type R that does not have lcm and gcd methods, or these methods exist, but raise other kinds of errors, e.g. because the ring is not a UFD or the methods have not been implemented. Let a and b be elements of F. Then a and b have a gcd in F because F is a field, so I would expect a.gcd(b) to return something (anything basically). After applying your patch, if I do `a.gcd(b)`, it is very confusing to get an `AttributeError: 'RElement' object has no attribute 'gcd'`: I'm not interested in gcd's of RElements, only of `(Fraction)FieldElements`. You could put your entire `gcd` and `lcm` code between `try:` and `except (AttributeError, NotImplementedError, TypeError, ValueError):` to return the same 0 or 1 that `gcd_rational` would (which is a mathematically correct gcd in F after all).\n\n\nIf one adds a gcd and lcm for field elements (#9819) returning 0 or 1, then your suggestion certainly makes sense. \n\n> * trac has a `t` too much in line 1610 of ring.pyx: `the case of the rational field. However, since tract ticket #10771,`\n> \n> * you write \"quotient field\" in the documentation. You could write \"fraction field\" to avoid confusion with quotient rings, which may be fields. This makes it more clear that you refer to the mathematical counterpart of Sage's \"`FractionField`\"?\n\n\nThanks! I am about to post a new patch, and I hope that Luis as author of #9819 does not mind if I add the case of arbitrary fields to my patch.",
    "created_at": "2011-02-14T15:49:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136190",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:6'></a>Hi Marco,

Replying to [comment:3 mstreng]:
> A couple of comments:
> 
> * I don't see the point of keeping a special function `gcd_rational(self, other, **kwds):` that returns a GCD in the set {0,1}. Why only for QQ? Why at all? Also, the difference between `gcd` and `gcd_rational` is not explained by the word "rational". Perhaps `gcd_zero_one` would be a more informative name.


Perhaps I am too 'conservative': I would rather rename something than to delete it.

But I suppose it would be better to implement a gcd and an lcm as element methods of `Fields()` -- see #9819. In that way, one could easily provide a correct gcd/lcm behaviour for all fields, and for fraction fields of PID one would still obtain a gcd/lcm behaviour that is not only correct but nice.

> * Everything generalizes from principal ideal domains to unique factorization domains (UFD's) (such as multivariate polynomial rings over unique factorization domains) as long as they have `gcd` and `lcm` methods implemented. Why not write "unique factorization domain" in the documentation instead of "principal ideal domain"?


Good question. I did it by accident. However, it matches the sad fact that the categories are a little askew here:

```
sage: PrincipalIdealDomains().is_subcategory(UniqueFactorizationDomains())
False  # shouldn't that be "True"?
sage: PrincipalIdealDomains().is_subcategory(GcdDomains())
True
sage: UniqueFactorizationDomains().is_subcategory(GcdDomains())
True
```

Perhaps one should write "fraction field of an integral domain with gcd and lcm"? Because that's what is duck typed.

> * Suppose I have a fraction field F of a ring of type R that does not have lcm and gcd methods, or these methods exist, but raise other kinds of errors, e.g. because the ring is not a UFD or the methods have not been implemented. Let a and b be elements of F. Then a and b have a gcd in F because F is a field, so I would expect a.gcd(b) to return something (anything basically). After applying your patch, if I do `a.gcd(b)`, it is very confusing to get an `AttributeError: 'RElement' object has no attribute 'gcd'`: I'm not interested in gcd's of RElements, only of `(Fraction)FieldElements`. You could put your entire `gcd` and `lcm` code between `try:` and `except (AttributeError, NotImplementedError, TypeError, ValueError):` to return the same 0 or 1 that `gcd_rational` would (which is a mathematically correct gcd in F after all).


If one adds a gcd and lcm for field elements (#9819) returning 0 or 1, then your suggestion certainly makes sense. 

> * trac has a `t` too much in line 1610 of ring.pyx: `the case of the rational field. However, since tract ticket #10771,`
> 
> * you write "quotient field" in the documentation. You could write "fraction field" to avoid confusion with quotient rings, which may be fields. This makes it more clear that you refer to the mathematical counterpart of Sage's "`FractionField`"?


Thanks! I am about to post a new patch, and I hope that Luis as author of #9819 does not mind if I add the case of arbitrary fields to my patch.



---

archive/issue_comments_136191.json:
```json
{
    "body": "<a id='comment:7'></a>I just updated my patch, and I hope it addresses all your remarks. The typos are fixed, the old gcd of the rational field is now removed, and: I also added gcd/lcm for general fields. I am sorry that this makes #9819 a duplicate.\n\nAnd I hope that I did not confuse gcd and lcm in the following setting:\n\n```\nsage: GF(2)(1).gcd(GF(2)(1))\n1\nsage: GF(2)(1).gcd(GF(2)(0))\n1\nsage: GF(2)(0).gcd(GF(2)(0))\n0\nsage: GF(2)(1).lcm(GF(2)(0))\n0\nsage: GF(2)(1).lcm(GF(2)(1))\n1\n```\nThat's implemented as element methods for the category of `Fields()`. Somehow, the category framework is cool, isn't it?",
    "created_at": "2011-02-14T16:19:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136191",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:7'></a>I just updated my patch, and I hope it addresses all your remarks. The typos are fixed, the old gcd of the rational field is now removed, and: I also added gcd/lcm for general fields. I am sorry that this makes #9819 a duplicate.

And I hope that I did not confuse gcd and lcm in the following setting:

```
sage: GF(2)(1).gcd(GF(2)(1))
1
sage: GF(2)(1).gcd(GF(2)(0))
1
sage: GF(2)(0).gcd(GF(2)(0))
0
sage: GF(2)(1).lcm(GF(2)(0))
0
sage: GF(2)(1).lcm(GF(2)(1))
1
```
That's implemented as element methods for the category of `Fields()`. Somehow, the category framework is cool, isn't it?



---

archive/issue_comments_136192.json:
```json
{
    "body": "<a id='comment:8'></a>Oops, I forgot one aspect: If the gcd/lcm of the base ring raises an error, it should be caught. Implementing it now...",
    "created_at": "2011-02-14T16:23:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136192",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:8'></a>Oops, I forgot one aspect: If the gcd/lcm of the base ring raises an error, it should be caught. Implementing it now...



---

archive/issue_comments_136193.json:
```json
{
    "body": "<a id='comment:9'></a>Replying to [comment:8 SimonKing]:\n> Oops, I forgot one aspect: If the gcd/lcm of the base ring raises an error, it should be caught. Implementing it now...\n\n\nHere it is:\n\n```\nsage: R.<q> = ZZ.extension(x^2+5)\nsage: gcd(q,q)\n1\nsage: gcd(q,0)\n1\nsage: gcd(R.zero(),0)\n0\nsage: lcm(q,q)\n1\nsage: lcm(q,0)\n0\n```\n\nCorrect me if I am wrong, but I think that now every complaint is addressed.\n\nBest regards,\n\nSimon",
    "created_at": "2011-02-14T16:34:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136193",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:9'></a>Replying to [comment:8 SimonKing]:
> Oops, I forgot one aspect: If the gcd/lcm of the base ring raises an error, it should be caught. Implementing it now...


Here it is:

```
sage: R.<q> = ZZ.extension(x^2+5)
sage: gcd(q,q)
1
sage: gcd(q,0)
1
sage: gcd(R.zero(),0)
0
sage: lcm(q,q)
1
sage: lcm(q,0)
0
```

Correct me if I am wrong, but I think that now every complaint is addressed.

Best regards,

Simon



---

archive/issue_comments_136194.json:
```json
{
    "body": "Changing status from needs_review to needs_work.",
    "created_at": "2011-02-14T17:07:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136194",
    "user": "https://github.com/mstreng"
}
```

Changing status from needs_review to needs_work.



---

archive/issue_comments_136195.json:
```json
{
    "body": "<a id='comment:10'></a>New complaints, sorry.\n\n* I don't really like this:\n  {{{\n  sage: M = Matrix(GF(3),2,2,[1,2,0,1]); M\n  [1 2]\n  [0 1]\n  sage: GF(2)(1).lcm(M)\n  1\n  }}}\n  I think you should first try to coerce other to self.parent() in gcd and lcm for Field elements.\n\n* Line 64 of quotient_fields.py \"`both GCD and LCM, it is possible to be a bit more specific`\"\n  uses capital letters GCD and LCM, while the methods that it (quasi-)refers to are lower case:\n  `AttributeError: 'sage.rings.rational.Rational' object has no attribute 'GCD'`\n\n* Next line: \"define the GCD uniquely up to a unit in the base ring\". Write \"of\" instead of \"in\"\n  so that it is clear that you are not saying that the GCD is in the base ring.\n\n* Your tests with `R.<q> = ZZ.extension(x^2+5)` is unrelated to fraction field: q is 1\n  {{{\n  sage: R.<q> = ZZ.extension(x^2+5)\n  sage: g = R.gens(); g\n  [1, q]\n  sage: q\n  1\n  sage: g[1]\n  q\n  sage: g[1] == q\n  False\n  }}}\n  All your examples involving q get coerced to ZZ by the global GCD and LCM, so you should\n  find other examples. This seems to work:\n  {{{\n  sage: gcd(g[1],1)\n  TypeError: unable to find gcd of q and 1\n  sage: gcd(g[1]/1,1)\n  1\n  }}}\n  (Correct behaviour both times)\n\nTime to catch a bus, may have more comments later.",
    "created_at": "2011-02-14T17:07:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136195",
    "user": "https://github.com/mstreng"
}
```

<a id='comment:10'></a>New complaints, sorry.

* I don't really like this:
  {{{
  sage: M = Matrix(GF(3),2,2,[1,2,0,1]); M
  [1 2]
  [0 1]
  sage: GF(2)(1).lcm(M)
  1
  }}}
  I think you should first try to coerce other to self.parent() in gcd and lcm for Field elements.

* Line 64 of quotient_fields.py "`both GCD and LCM, it is possible to be a bit more specific`"
  uses capital letters GCD and LCM, while the methods that it (quasi-)refers to are lower case:
  `AttributeError: 'sage.rings.rational.Rational' object has no attribute 'GCD'`

* Next line: "define the GCD uniquely up to a unit in the base ring". Write "of" instead of "in"
  so that it is clear that you are not saying that the GCD is in the base ring.

* Your tests with `R.<q> = ZZ.extension(x^2+5)` is unrelated to fraction field: q is 1
  {{{
  sage: R.<q> = ZZ.extension(x^2+5)
  sage: g = R.gens(); g
  [1, q]
  sage: q
  1
  sage: g[1]
  q
  sage: g[1] == q
  False
  }}}
  All your examples involving q get coerced to ZZ by the global GCD and LCM, so you should
  find other examples. This seems to work:
  {{{
  sage: gcd(g[1],1)
  TypeError: unable to find gcd of q and 1
  sage: gcd(g[1]/1,1)
  1
  }}}
  (Correct behaviour both times)

Time to catch a bus, may have more comments later.



---

archive/issue_comments_136196.json:
```json
{
    "body": "<a id='comment:11'></a>Replying to [comment:7 SimonKing]:\n> I just updated my patch, and I hope it addresses all your remarks. The typos are fixed, the old gcd of the rational field is now removed, and: I also added gcd/lcm for general fields. I am sorry that this makes #9819 a duplicate.\n\n\nPlease.\n\n> And I hope that I did not confuse gcd and lcm in the following setting:\n> \n> ```\n> sage: GF(2)(1).gcd(GF(2)(1))\n> 1\n> sage: GF(2)(1).gcd(GF(2)(0))\n> 1\n> sage: GF(2)(0).gcd(GF(2)(0))\n> 0\n> sage: GF(2)(1).lcm(GF(2)(0))\n> 0\n> sage: GF(2)(1).lcm(GF(2)(1))\n> 1\n> ```\n> That's implemented as element methods for the category of `Fields()`. Somehow, the category framework is cool, isn't it?\n\n\nI do not full understand this, but I am happy that works.\n\nSome thoughts:\n\nFor QQ and the like, could it be that gcd and lcm should only take care of coercing to a good setting and then the real algorithm should be in _lcm, _gcd? Note that QQ already has ._gcd and ._lcm so these methods has to be taken into account.\n\nFor generic Fields, It should appear in the documentation that the methods return 0 if both arguments are zero and a non-zero element otherwise. The user should not suppose that the non-zero element is actually one, since this is changed by subclasses.",
    "created_at": "2011-02-14T17:22:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136196",
    "user": "https://github.com/lftabera"
}
```

<a id='comment:11'></a>Replying to [comment:7 SimonKing]:
> I just updated my patch, and I hope it addresses all your remarks. The typos are fixed, the old gcd of the rational field is now removed, and: I also added gcd/lcm for general fields. I am sorry that this makes #9819 a duplicate.


Please.

> And I hope that I did not confuse gcd and lcm in the following setting:
> 
> ```
> sage: GF(2)(1).gcd(GF(2)(1))
> 1
> sage: GF(2)(1).gcd(GF(2)(0))
> 1
> sage: GF(2)(0).gcd(GF(2)(0))
> 0
> sage: GF(2)(1).lcm(GF(2)(0))
> 0
> sage: GF(2)(1).lcm(GF(2)(1))
> 1
> ```
> That's implemented as element methods for the category of `Fields()`. Somehow, the category framework is cool, isn't it?


I do not full understand this, but I am happy that works.

Some thoughts:

For QQ and the like, could it be that gcd and lcm should only take care of coercing to a good setting and then the real algorithm should be in _lcm, _gcd? Note that QQ already has ._gcd and ._lcm so these methods has to be taken into account.

For generic Fields, It should appear in the documentation that the methods return 0 if both arguments are zero and a non-zero element otherwise. The user should not suppose that the non-zero element is actually one, since this is changed by subclasses.



---

archive/issue_comments_136197.json:
```json
{
    "body": "<a id='comment:12'></a>Hi Luis!\n\nReplying to [comment:11 lftabera]:\n> > That's implemented as element methods for the category of `Fields()`. Somehow, the category framework is cool, isn't it?\n\n> \n> I do not full understand this, but I am happy that works.\n\n\nThen let me explain:\n\nAny category (in Sage) comes with a parent class and an \"element class\". That very often is an abstract thing, but you can inherit from it, and in particular you can implement methods for it.\n\nIf things are properly done, then a parent P is declared as an object in some category, and its class *automatically(!)* inherits from the parent class of its category:\n\n```\nsage: QQ.__class__\n<class 'sage.rings.rational_field.RationalField_with_category'>\nsage: issubclass(QQ.__class__,QuotientFields().parent_class)\nTrue\n```\n\nIf things are very properly done, then the parent has an attribute `Element`, which is supposed to be a class. That class will (again automatically) be translated into a subclass of the element class of the parent's category, and is available as the attribute `element_class`:\n\n```\nsage: m = matrix(GF(2),[[1]])\nsage: G = MatrixGroup([m])\nsage: G.Element\n<class 'sage.groups.matrix_gps.matrix_group_element.MatrixGroupElement'>\nsage: G.__class__\n<class 'sage.groups.matrix_gps.matrix_group.MatrixGroup_gens_finite_field_with_category'>\nsage: G.element_class\n<class 'sage.groups.matrix_gps.matrix_group_element.MatrixGroup_gens_finite_field_with_category.element_class'>\nsage: issubclass(G.element_class,G.Element)\nTrue\nsage: issubclass(G.element_class,G.category().element_class)\nTrue\nsage: isinstance(G.random_element(),G.category().element_class)\nTrue\n```\n\nSo, if things are very properly done, then a method defined as an \"element method\" of a category, will be available by looking up the method resolution order, since the elements of the parent are actual instances of the category's element class.\n\nSometimes things are done properly, but not *very* properly:\n\n```\nsage: QQ.category()\nCategory of quotient fields\nsage: isinstance(QQ, QQ.category().parent_class)\nTrue\nsage: hasattr(QQ,'Element')\nFalse\nsage: isinstance(QQ.one(), QQ.category().element_class)\nFalse\n```\n\nHence, the methods that I defined for the element class of the \"category of quotient fields\" is not available to elements of `QQ` by simply looking up the method resolution order. But: There also is a `__getattr__` method implemented for `sage.structure.element.Element`, and this can access the element methods of the category of the parent of an element (uff!) even if the element is no instance of the \"proper\" element class.\n\nThis is why the new gcd works for the rationals, but it's slower than with the method resolution order, and this is why I also did not remove the existing lcm for rationals.\n\n> Some thoughts:\n> \n> For QQ and the like, could it be that gcd and lcm should only take care of coercing to a good setting and then the real algorithm should be in _lcm, _gcd? Note that QQ already has ._gcd and ._lcm so these methods has to be taken into account.\n\n\nThat's a nice observation. By searching a little, I found that `_gcd` is used in the method `sage.structure.element.PrincipalIdealDomainElement.gcd`. \n\nHowever, there are only very few classes that define a `_gcd` method: `sage.structure.element.EuclideanDomainElement`, `sage.structure.element.FieldElement`, `sage.rings.rational.Rational`, and then there are hits in `...polynomial_element_generic` and `...polynomial_modn_dense_ntl`.\n\nIn other words, I guess that the `_gcd` method is an artefact of earlier attempts to reflect mathematics in the class hierarchy -- this should now be done in the category framework. `_gcd` will *only* play a role if \n\n1. the class of an element derives from `PrincipalIdealDomainElement`, and\n\n2. the class of an element additionally defines `_gcd`.\n\nIt seems to me that there is precisely one class that directly inherits from `PrincipalIdealDomainElement`, and there is precisely one class that directly inherits from that class:\n\n```\nsage: search_src(\"\\(PrincipalIdealDomainElement\")\nstructure/element.pxd:83:cdef class EuclideanDomainElement(PrincipalIdealDomainElement):\nstructure/element.pyx:2370:cdef class EuclideanDomainElement(PrincipalIdealDomainElement):\n\nsage: search_src(\"\\(EuclideanDomainElement\")\nstructure/element.pyx:2362:PY_SET_TP_NEW(EuclideanDomainElement, Element)\nrings/integer.pxd:9:cdef class Integer(EuclideanDomainElement):\n```\n\nSo, `_gcd` is only used for the `Integer` class. I guess it could easily be removed.\n\n> For generic Fields, It should appear in the documentation that the methods return 0 if both arguments are zero and a non-zero element otherwise. The user should not suppose that the non-zero element is actually one, since this is changed by subclasses.\n\n\nRight. I'll take care of that, but now I have a bus to catch...",
    "created_at": "2011-02-15T10:22:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136197",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:12'></a>Hi Luis!

Replying to [comment:11 lftabera]:
> > That's implemented as element methods for the category of `Fields()`. Somehow, the category framework is cool, isn't it?

> 
> I do not full understand this, but I am happy that works.


Then let me explain:

Any category (in Sage) comes with a parent class and an "element class". That very often is an abstract thing, but you can inherit from it, and in particular you can implement methods for it.

If things are properly done, then a parent P is declared as an object in some category, and its class *automatically(!)* inherits from the parent class of its category:

```
sage: QQ.__class__
<class 'sage.rings.rational_field.RationalField_with_category'>
sage: issubclass(QQ.__class__,QuotientFields().parent_class)
True
```

If things are very properly done, then the parent has an attribute `Element`, which is supposed to be a class. That class will (again automatically) be translated into a subclass of the element class of the parent's category, and is available as the attribute `element_class`:

```
sage: m = matrix(GF(2),[[1]])
sage: G = MatrixGroup([m])
sage: G.Element
<class 'sage.groups.matrix_gps.matrix_group_element.MatrixGroupElement'>
sage: G.__class__
<class 'sage.groups.matrix_gps.matrix_group.MatrixGroup_gens_finite_field_with_category'>
sage: G.element_class
<class 'sage.groups.matrix_gps.matrix_group_element.MatrixGroup_gens_finite_field_with_category.element_class'>
sage: issubclass(G.element_class,G.Element)
True
sage: issubclass(G.element_class,G.category().element_class)
True
sage: isinstance(G.random_element(),G.category().element_class)
True
```

So, if things are very properly done, then a method defined as an "element method" of a category, will be available by looking up the method resolution order, since the elements of the parent are actual instances of the category's element class.

Sometimes things are done properly, but not *very* properly:

```
sage: QQ.category()
Category of quotient fields
sage: isinstance(QQ, QQ.category().parent_class)
True
sage: hasattr(QQ,'Element')
False
sage: isinstance(QQ.one(), QQ.category().element_class)
False
```

Hence, the methods that I defined for the element class of the "category of quotient fields" is not available to elements of `QQ` by simply looking up the method resolution order. But: There also is a `__getattr__` method implemented for `sage.structure.element.Element`, and this can access the element methods of the category of the parent of an element (uff!) even if the element is no instance of the "proper" element class.

This is why the new gcd works for the rationals, but it's slower than with the method resolution order, and this is why I also did not remove the existing lcm for rationals.

> Some thoughts:
> 
> For QQ and the like, could it be that gcd and lcm should only take care of coercing to a good setting and then the real algorithm should be in _lcm, _gcd? Note that QQ already has ._gcd and ._lcm so these methods has to be taken into account.


That's a nice observation. By searching a little, I found that `_gcd` is used in the method `sage.structure.element.PrincipalIdealDomainElement.gcd`. 

However, there are only very few classes that define a `_gcd` method: `sage.structure.element.EuclideanDomainElement`, `sage.structure.element.FieldElement`, `sage.rings.rational.Rational`, and then there are hits in `...polynomial_element_generic` and `...polynomial_modn_dense_ntl`.

In other words, I guess that the `_gcd` method is an artefact of earlier attempts to reflect mathematics in the class hierarchy -- this should now be done in the category framework. `_gcd` will *only* play a role if 

1. the class of an element derives from `PrincipalIdealDomainElement`, and

2. the class of an element additionally defines `_gcd`.

It seems to me that there is precisely one class that directly inherits from `PrincipalIdealDomainElement`, and there is precisely one class that directly inherits from that class:

```
sage: search_src("\(PrincipalIdealDomainElement")
structure/element.pxd:83:cdef class EuclideanDomainElement(PrincipalIdealDomainElement):
structure/element.pyx:2370:cdef class EuclideanDomainElement(PrincipalIdealDomainElement):

sage: search_src("\(EuclideanDomainElement")
structure/element.pyx:2362:PY_SET_TP_NEW(EuclideanDomainElement, Element)
rings/integer.pxd:9:cdef class Integer(EuclideanDomainElement):
```

So, `_gcd` is only used for the `Integer` class. I guess it could easily be removed.

> For generic Fields, It should appear in the documentation that the methods return 0 if both arguments are zero and a non-zero element otherwise. The user should not suppose that the non-zero element is actually one, since this is changed by subclasses.


Right. I'll take care of that, but now I have a bus to catch...



---

archive/issue_comments_136198.json:
```json
{
    "body": "<a id='comment:13'></a>* Did you run a full doctest? I'm getting doctest failures that may have something to do with your patch, as they probably simplify fractions somewhere deep inside in some way. Or my installation is messed up again.\n  {{{\n  sage -t -long devel/sage/sage/symbolic/expression.pyx # 1 doctests failed\n  sage -t -long devel/sage/sage/symbolic/integration/integral.py # 1 doctests failed\n  sage -t -long devel/sage/sage/stats/basic_stats.py # 2 doctests failed\n  }}}\n\n  * The documentation of content for multivariate polynomials says \"Returns the content of this polynomial.\n  Here, we define content as the gcd of the coefficients in the base ring.\"\n  Your changed doctest (1 becomes 2) is correct, but perhaps it would be more informative to\n  add `f.content().parent()`, and to give an example over another field. (Just a suggestion\n  if you are editing the code anyway. Otherwise, don't bother.)\n  More important:\n  {{{\n  # Since trac ticket #10771, the gcd in QQ restricts to the \n  # gcd in ZZ. \n  }}}\n  I don't think this comment is needed in this part of the code. If you want to include it, it would better fit in the doctest a few lines above it.\n  And I think junk like the following should not be in the code at all: `  #,integer=self.parent() is ZZ) `",
    "created_at": "2011-02-15T12:09:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136198",
    "user": "https://github.com/mstreng"
}
```

<a id='comment:13'></a>* Did you run a full doctest? I'm getting doctest failures that may have something to do with your patch, as they probably simplify fractions somewhere deep inside in some way. Or my installation is messed up again.
  {{{
  sage -t -long devel/sage/sage/symbolic/expression.pyx # 1 doctests failed
  sage -t -long devel/sage/sage/symbolic/integration/integral.py # 1 doctests failed
  sage -t -long devel/sage/sage/stats/basic_stats.py # 2 doctests failed
  }}}

  * The documentation of content for multivariate polynomials says "Returns the content of this polynomial.
  Here, we define content as the gcd of the coefficients in the base ring."
  Your changed doctest (1 becomes 2) is correct, but perhaps it would be more informative to
  add `f.content().parent()`, and to give an example over another field. (Just a suggestion
  if you are editing the code anyway. Otherwise, don't bother.)
  More important:
  {{{
  # Since trac ticket #10771, the gcd in QQ restricts to the 
  # gcd in ZZ. 
  }}}
  I don't think this comment is needed in this part of the code. If you want to include it, it would better fit in the doctest a few lines above it.
  And I think junk like the following should not be in the code at all: `  #,integer=self.parent() is ZZ) `



---

archive/issue_comments_136199.json:
```json
{
    "body": "<a id='comment:14'></a>Replying to [comment:13 mstreng]:\n>   * Did you run a full doctest? I'm getting doctest failures that may have something to do with your patch, as they probably simplify fractions somewhere deep inside in some way. Or my installation is messed up again.\n>   \n>   ```\n>   sage -t -long devel/sage/sage/symbolic/expression.pyx # 1 doctests failed\n>   sage -t -long devel/sage/sage/symbolic/integration/integral.py # 1 doctests failed\n>   sage -t -long devel/sage/sage/stats/basic_stats.py # 2 doctests failed\n>   ```\n\n\nHum. Apparently I did not run these tests. The problem is that I currently work on various patches, frequently switch between them, and it may happen that I test one of them but forget the other.\n\nAnyway, the failure in \"expression.pyx\" seems to be related with the patch. I'll try to understand what is happening.\n\n>   * The documentation of content for multivariate polynomials says \"Returns the content of this polynomial.\n>   Here, we define content as the gcd of the coefficients in the base ring.\"\n>   Your changed doctest (1 becomes 2) is correct, but perhaps it would be more informative to\n>   add `f.content().parent()`, and to give an example over another field. (Just a suggestion\n>   if you are editing the code anyway. Otherwise, don't bother.)\n\n\nOK.\n\n>   More important:\n>   \n>   ```\n>   # Since trac ticket #10771, the gcd in QQ restricts to the \n>   # gcd in ZZ. \n>   ```\n>   I don't think this comment is needed in this part of the code. If you want to include it, it would better fit in the doctest a few lines above it.\n\n\nI thought of it as a comment to people who know the original code. It could be that it is a method that uses gcd only internally, so that commenting in the code seems better than in the documentation.\n\n>   And I think junk like the following should not be in the code at all: `  #,integer=self.parent() is ZZ) `\n\n\nOK, that was an artefact of editing.\n\nBut I think most urgent are the doctest failures. It seems related to gcd for fields that are not fraction fields (such as `RR`). That would also explain why all text passed with the original version of my patch, whereas the new version fails.\n\nCheers,\nSimon",
    "created_at": "2011-02-15T13:31:45Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136199",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:14'></a>Replying to [comment:13 mstreng]:
>   * Did you run a full doctest? I'm getting doctest failures that may have something to do with your patch, as they probably simplify fractions somewhere deep inside in some way. Or my installation is messed up again.
>   
>   ```
>   sage -t -long devel/sage/sage/symbolic/expression.pyx # 1 doctests failed
>   sage -t -long devel/sage/sage/symbolic/integration/integral.py # 1 doctests failed
>   sage -t -long devel/sage/sage/stats/basic_stats.py # 2 doctests failed
>   ```


Hum. Apparently I did not run these tests. The problem is that I currently work on various patches, frequently switch between them, and it may happen that I test one of them but forget the other.

Anyway, the failure in "expression.pyx" seems to be related with the patch. I'll try to understand what is happening.

>   * The documentation of content for multivariate polynomials says "Returns the content of this polynomial.
>   Here, we define content as the gcd of the coefficients in the base ring."
>   Your changed doctest (1 becomes 2) is correct, but perhaps it would be more informative to
>   add `f.content().parent()`, and to give an example over another field. (Just a suggestion
>   if you are editing the code anyway. Otherwise, don't bother.)


OK.

>   More important:
>   
>   ```
>   # Since trac ticket #10771, the gcd in QQ restricts to the 
>   # gcd in ZZ. 
>   ```
>   I don't think this comment is needed in this part of the code. If you want to include it, it would better fit in the doctest a few lines above it.


I thought of it as a comment to people who know the original code. It could be that it is a method that uses gcd only internally, so that commenting in the code seems better than in the documentation.

>   And I think junk like the following should not be in the code at all: `  #,integer=self.parent() is ZZ) `


OK, that was an artefact of editing.

But I think most urgent are the doctest failures. It seems related to gcd for fields that are not fraction fields (such as `RR`). That would also explain why all text passed with the original version of my patch, whereas the new version fails.

Cheers,
Simon



---

archive/issue_comments_136200.json:
```json
{
    "body": "<a id='comment:15'></a>Yep, I understand where the first error comes from.\n\nThe original gcd codes says:\n\n```\n    if b is not None:\n        if hasattr(a, \"gcd\"):\n            return a.gcd(b, **kwargs)\n        else:\n            try:\n                return ZZ(a).gcd(ZZ(b))\n            except TypeError:\n                raise TypeError, \"unable to find gcd of %s and %s\"%(a,b)\n```\nMoreover, elements of `RR` did not have a gcd method. Hence, it was tried to coerce them into ZZ, and so we had\n\n```\nsage: gcd(3.0,6.0)\n3\n```\n\nBut with my patch, *all* field elements (including elements of `RR`) have a gcd method, so, a conversion to `ZZ` is not attempted.\n\nI am not sure yet how I would solve it: Change the code of `sage.symbolic.expression\"? Change the gcd implemented for fields that are no fraction fields, such that a special case is made for inexact fields?",
    "created_at": "2011-02-15T13:38:29Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136200",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:15'></a>Yep, I understand where the first error comes from.

The original gcd codes says:

```
    if b is not None:
        if hasattr(a, "gcd"):
            return a.gcd(b, **kwargs)
        else:
            try:
                return ZZ(a).gcd(ZZ(b))
            except TypeError:
                raise TypeError, "unable to find gcd of %s and %s"%(a,b)
```
Moreover, elements of `RR` did not have a gcd method. Hence, it was tried to coerce them into ZZ, and so we had

```
sage: gcd(3.0,6.0)
3
```

But with my patch, *all* field elements (including elements of `RR`) have a gcd method, so, a conversion to `ZZ` is not attempted.

I am not sure yet how I would solve it: Change the code of `sage.symbolic.expression"? Change the gcd implemented for fields that are no fraction fields, such that a special case is made for inexact fields?



---

archive/issue_comments_136201.json:
```json
{
    "body": "<a id='comment:16'></a>I suggest to do the following, which would generalize the current attempt to convert stuff into `ZZ`:\n\n```\n            For inexact fields, evaluation in the prime subfield is attempted::\n\n                sage: lcm(15.2,12.0); lcm(15.2,12.0).parent()\n                228\n                Rational Field\n                sage: RR(76/5)\n                15.2000000000000\n                sage: lcm(76/5,12)\n                228\n\n            If this fails, we resort to the default we see above::\n\n                sage: lcm(6.0*CC.0,8*CC.0); lcm(6.0*CC.0,8*CC.0).parent()\n                1.00000000000000\n                Complex Field with 53 bits of precision\n```\n\nSimilarly for gcd.\n\nIn that way, the first of the three doctest failures vanishes. But the other two remain problems.",
    "created_at": "2011-02-15T13:59:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136201",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:16'></a>I suggest to do the following, which would generalize the current attempt to convert stuff into `ZZ`:

```
            For inexact fields, evaluation in the prime subfield is attempted::

                sage: lcm(15.2,12.0); lcm(15.2,12.0).parent()
                228
                Rational Field
                sage: RR(76/5)
                15.2000000000000
                sage: lcm(76/5,12)
                228

            If this fails, we resort to the default we see above::

                sage: lcm(6.0*CC.0,8*CC.0); lcm(6.0*CC.0,8*CC.0).parent()
                1.00000000000000
                Complex Field with 53 bits of precision
```

Similarly for gcd.

In that way, the first of the three doctest failures vanishes. But the other two remain problems.



---

archive/issue_comments_136202.json:
```json
{
    "body": "<a id='comment:17'></a>The second failure can be triggered as follows:\n\n```\nsage: F(x) = 1/sqrt(2*pi*1^2)*exp(-1/(2*1^2)*(x-0)^2)\nsage: G(x) = 1/sqrt(2*pi*n(1)^2)*exp(-1/(2*n(1)^2)*(x-n(0))^2)\nsage: ((F(x)-G(x))^2).expand()\n/mnt/local/king/SAGE/sage-4.6.2.alpha4/local/bin/sage-sage: Zeile 300: 18366 Speicherzugriffsfehler  sage-ipython \"$@\" -i\n```\n\nSegmentation fault while expanding. I could imagine that `gcd==1` results in an infinite loop.",
    "created_at": "2011-02-15T14:04:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136202",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:17'></a>The second failure can be triggered as follows:

```
sage: F(x) = 1/sqrt(2*pi*1^2)*exp(-1/(2*1^2)*(x-0)^2)
sage: G(x) = 1/sqrt(2*pi*n(1)^2)*exp(-1/(2*n(1)^2)*(x-n(0))^2)
sage: ((F(x)-G(x))^2).expand()
/mnt/local/king/SAGE/sage-4.6.2.alpha4/local/bin/sage-sage: Zeile 300: 18366 Speicherzugriffsfehler  sage-ipython "$@" -i
```

Segmentation fault while expanding. I could imagine that `gcd==1` results in an infinite loop.



---

archive/issue_comments_136203.json:
```json
{
    "body": "<a id='comment:18'></a>Replying to [comment:17 SimonKing]:\n> Segmentation fault while expanding. I could imagine that `gcd==1` results in an infinite loop.\n\n\nOuch, it is worse: It already occurs *before* the expansion!",
    "created_at": "2011-02-15T14:05:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136203",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:18'></a>Replying to [comment:17 SimonKing]:
> Segmentation fault while expanding. I could imagine that `gcd==1` results in an infinite loop.


Ouch, it is worse: It already occurs *before* the expansion!



---

archive/issue_comments_136204.json:
```json
{
    "body": "<a id='comment:19'></a>The third error boils down to:\n\nWithout patch\n\n```\nsage: x = -sqrt(2)-1/5*I\nsage: x*x\n1/25*(5*sqrt(2) + I)^2\n```\nWith patch\n\n```\nsage: x = -sqrt(2)-1/5*I\nsage: x*x\n1/25*(-5*sqrt(2) - I)^2\n```\n\nThe segfault in the second doctest problem also comes from multiplication of symbolic expressions. And the example above indicates that it is related with pulling common factors out of a list of expressions.",
    "created_at": "2011-02-15T14:34:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136204",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:19'></a>The third error boils down to:

Without patch

```
sage: x = -sqrt(2)-1/5*I
sage: x*x
1/25*(5*sqrt(2) + I)^2
```
With patch

```
sage: x = -sqrt(2)-1/5*I
sage: x*x
1/25*(-5*sqrt(2) - I)^2
```

The segfault in the second doctest problem also comes from multiplication of symbolic expressions. And the example above indicates that it is related with pulling common factors out of a list of expressions.



---

archive/issue_comments_136205.json:
```json
{
    "body": "<a id='comment:20'></a>Just FYI, #8111 is possibly also related.",
    "created_at": "2011-02-16T21:21:22Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136205",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:20'></a>Just FYI, #8111 is possibly also related.



---

archive/issue_comments_136206.json:
```json
{
    "body": "Changing status from needs_work to needs_review.",
    "created_at": "2011-02-17T13:22:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136206",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to needs_review.



---

archive/issue_comments_136207.json:
```json
{
    "body": "<a id='comment:21'></a>With the new patch, all tests pass for me. The behaviour is now (mutatis mutandis for lcm):\n\n* If `ZZ` is a subring of a field F that is not a fraction field then `a.gcd(b)` first tests if a and b can be converted into `ZZ`. If it is the case, their gcd in `ZZ` *as element of `ZZ`* is returned. This is not nice, but it is compatible with the \"unpatched\" behaviour of Sage and is assumed in some other parts of Sage:\n {{{\n# unpatched!\nsage: gcd(RR(1),RR(1))\n1\nsage: _.parent()\nInteger Ring\n }}}\n\n* If `ZZ` is no subring of F or conversion fails then `a.gcd(b)` returns `F(0)` or `F(1)`. This is, e.g., the case for `gcd(CC(2),CC(2))`, since `CC(2)` can not be converted into `ZZ`.\n\n* a.gcd(b) only raises an error if `b` can not be converted into `a.parent()`.\n\n* gcd and lcm in fraction fields of a unique factorization domain R restrict to R, and moreover they satisfy `gcd(a,b)*lcm(a,b)==a*b` up to multiplication with a unit of R.\n\nThere is a price to pay, and that's why I put Burcin on Cc:\n\nThe distribution of minus signs in symbolic expression changes, apparently since now gcd raises no errors in examples like the following:\n\n```\nsage: (I - 1/3*sqrt(2))^2\n1/9*(-sqrt(2) + 3*I)^2\n# Without patch, we would get\n# 1/9*(sqrt(2) - 3*I)^2\n```\n\nThe question is whether a changed minus sign distribution is such a serious thing.",
    "created_at": "2011-02-17T13:22:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136207",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:21'></a>With the new patch, all tests pass for me. The behaviour is now (mutatis mutandis for lcm):

* If `ZZ` is a subring of a field F that is not a fraction field then `a.gcd(b)` first tests if a and b can be converted into `ZZ`. If it is the case, their gcd in `ZZ` *as element of `ZZ`* is returned. This is not nice, but it is compatible with the "unpatched" behaviour of Sage and is assumed in some other parts of Sage:
 {{{
# unpatched!
sage: gcd(RR(1),RR(1))
1
sage: _.parent()
Integer Ring
 }}}

* If `ZZ` is no subring of F or conversion fails then `a.gcd(b)` returns `F(0)` or `F(1)`. This is, e.g., the case for `gcd(CC(2),CC(2))`, since `CC(2)` can not be converted into `ZZ`.

* a.gcd(b) only raises an error if `b` can not be converted into `a.parent()`.

* gcd and lcm in fraction fields of a unique factorization domain R restrict to R, and moreover they satisfy `gcd(a,b)*lcm(a,b)==a*b` up to multiplication with a unit of R.

There is a price to pay, and that's why I put Burcin on Cc:

The distribution of minus signs in symbolic expression changes, apparently since now gcd raises no errors in examples like the following:

```
sage: (I - 1/3*sqrt(2))^2
1/9*(-sqrt(2) + 3*I)^2
# Without patch, we would get
# 1/9*(sqrt(2) - 3*I)^2
```

The question is whether a changed minus sign distribution is such a serious thing.



---

archive/issue_comments_136208.json:
```json
{
    "body": "<a id='comment:22'></a>Hi Marco,\n\nsorry, I forgot to explain how I addressed your complaints:\n\nReplying to [comment:10 mstreng]:\n> New complaints, sorry.\n> \n> * I don't really like this:\n>   {{{\n>   sage: M = Matrix(GF(3),2,2,[1,2,0,1]); M\n>   [1 2]\n>   [0 1]\n>   sage: GF(2)(1).lcm(M)\n>   1\n>   }}}\n>   I think you should first try to coerce other to self.parent() in gcd and lcm for Field elements.\n\n\nYep, that was a mistake. We now have:\n\n```\nsage: M = Matrix(GF(3),2,2,[1,2,0,1]); M\n[1 2]\n[0 1]\nsage: GF(2)(1).lcm(M)\n---------------------------------------------------------------------------\nArithmeticError                           Traceback (most recent call last)\n...\nArithmeticError: The second argument can not be interpreted in the parent of the first argument. Can't compute the lcm\nsage: GF(2)(1).gcd(M)\nERROR: An unexpected error occurred while tokenizing input\nThe following traceback may be corrupted or invalid\nThe error message is: ('EOF in multi-line statement', (4, 0))\n\n---------------------------------------------------------------------------\nArithmeticError                           Traceback (most recent call last)\n\n...\nArithmeticError: The second argument can not be interpreted in the parent of the first argument. Can't compute the gcd\n```\n \n>  * Line 64 of quotient_fields.py \"`both GCD and LCM, it is possible to be a bit more specific`\"\n>    uses capital letters GCD and LCM, while the methods that it (quasi-)refers to are lower case:\n\n\nI changed the doc string to lower case.\n\n>  * Next line: \"define the GCD uniquely up to a unit in the base ring\". Write \"of\" instead of \"in\" so that it is clear that you are not saying that the GCD is in the base ring.\n\n\nDone.\n\n \n>  * Your tests with `R.<q> = ZZ.extension(x^2+5)` is unrelated to fraction field:\n\n\nYou are right. My intention was to *start* with `R`, show that there is no gcd in R, and then expose what happens in `Frac(R)`. The test is changed accordingly.\n\nBest regards,\n\nSimon",
    "created_at": "2011-02-17T13:46:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136208",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:22'></a>Hi Marco,

sorry, I forgot to explain how I addressed your complaints:

Replying to [comment:10 mstreng]:
> New complaints, sorry.
> 
> * I don't really like this:
>   {{{
>   sage: M = Matrix(GF(3),2,2,[1,2,0,1]); M
>   [1 2]
>   [0 1]
>   sage: GF(2)(1).lcm(M)
>   1
>   }}}
>   I think you should first try to coerce other to self.parent() in gcd and lcm for Field elements.


Yep, that was a mistake. We now have:

```
sage: M = Matrix(GF(3),2,2,[1,2,0,1]); M
[1 2]
[0 1]
sage: GF(2)(1).lcm(M)
---------------------------------------------------------------------------
ArithmeticError                           Traceback (most recent call last)
...
ArithmeticError: The second argument can not be interpreted in the parent of the first argument. Can't compute the lcm
sage: GF(2)(1).gcd(M)
ERROR: An unexpected error occurred while tokenizing input
The following traceback may be corrupted or invalid
The error message is: ('EOF in multi-line statement', (4, 0))

---------------------------------------------------------------------------
ArithmeticError                           Traceback (most recent call last)

...
ArithmeticError: The second argument can not be interpreted in the parent of the first argument. Can't compute the gcd
```
 
>  * Line 64 of quotient_fields.py "`both GCD and LCM, it is possible to be a bit more specific`"
>    uses capital letters GCD and LCM, while the methods that it (quasi-)refers to are lower case:


I changed the doc string to lower case.

>  * Next line: "define the GCD uniquely up to a unit in the base ring". Write "of" instead of "in" so that it is clear that you are not saying that the GCD is in the base ring.


Done.

 
>  * Your tests with `R.<q> = ZZ.extension(x^2+5)` is unrelated to fraction field:


You are right. My intention was to *start* with `R`, show that there is no gcd in R, and then expose what happens in `Frac(R)`. The test is changed accordingly.

Best regards,

Simon



---

archive/issue_comments_136209.json:
```json
{
    "body": "<a id='comment:23'></a>> There is a price to pay, and that's why I put Burcin on Cc:\n> \n> The distribution of minus signs in symbolic expression changes, apparently since now gcd raises no errors in examples like the following:\n> \n> ```\n> sage: (I - 1/3*sqrt(2))^2\n> 1/9*(-sqrt(2) + 3*I)^2\n> # Without patch, we would get\n> # 1/9*(sqrt(2) - 3*I)^2\n> ```\n> \n> The question is whether a changed minus sign distribution is such a serious thing.\n\n\nWhat happens with the already existing doctests?  That would be what I would be most concerned about.  Also, is the infinite loop now gone?  IIRC you had fixed that somehow.\n\nReally, in some sense the new version is 'better' because it keeps the minus where the user put it.  Do `(-I - 1/3*sqrt(2))^2` and `(I + 1/3*sqrt(2))^2` do anything different from before?",
    "created_at": "2011-02-17T14:04:54Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136209",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:23'></a>> There is a price to pay, and that's why I put Burcin on Cc:
> 
> The distribution of minus signs in symbolic expression changes, apparently since now gcd raises no errors in examples like the following:
> 
> ```
> sage: (I - 1/3*sqrt(2))^2
> 1/9*(-sqrt(2) + 3*I)^2
> # Without patch, we would get
> # 1/9*(sqrt(2) - 3*I)^2
> ```
> 
> The question is whether a changed minus sign distribution is such a serious thing.


What happens with the already existing doctests?  That would be what I would be most concerned about.  Also, is the infinite loop now gone?  IIRC you had fixed that somehow.

Really, in some sense the new version is 'better' because it keeps the minus where the user put it.  Do `(-I - 1/3*sqrt(2))^2` and `(I + 1/3*sqrt(2))^2` do anything different from before?



---

archive/issue_comments_136210.json:
```json
{
    "body": "<a id='comment:24'></a>Replying to [comment:23 kcrisman]:\n> What happens with the already existing doctests?  That would be what I would be most concerned about. \n\n\nThere are two tests (really in fact only one) in `sage.stats` where I had to change the expected output. The old and new output are equivalent:\n\n```\nsage: std([I, sqrt(2), 3/5]) # result with patch\nsqrt(1/450*(-5*sqrt(2) + 10*I - 3)^2 + 1/450*(-5*sqrt(2) - 5*I + 6)^2 + 1/450*(10*sqrt(2) - 5*I - 3)^2)\n# Without patch, we had sqrt(1/450*(5*sqrt(2) + 5*I - 6)^2 + 1/450*(5*sqrt(2) - 10*I + 3)^2 + 1/450*(10*sqrt(2) - 5*I - 3)^2)\n# Testing equality:\nsage: bool(sqrt(1/450*(5*sqrt(2) + 5*I - 6)^2 + 1/450*(5*sqrt(2) - 10*I + 3)^2 + 1/450*(10*sqrt(2) - 5*I - 3)^2) == std([I, sqrt(2), 3/5]))\nTrue\n```\nThere is essentially the same happening with `variance([I, sqrt(2), 3/5])`.\n\n> Also, is the infinite loop now gone?  IIRC you had fixed that somehow.\n\n\nYep. The problem was that in an old version of my patch I would not try conversion to `ZZ` but conversion to the prime subfield. A real number with finitely many digits can of course *always* be converted into `RR.prime_subfield()`, which is `QQ`. So, I guess that the segfault came from rationals with very large numerator and denominator. Here is the proof that the segfault has gone:\n\n```\nsage: F(x) = 1/sqrt(2*pi*1^2)*exp(-1/(2*1^2)*(x-0)^2) \nsage: G(x) = 1/sqrt(2*pi*n(1)^2)*exp(-1/(2*n(1)^2)*(x-n(0))^2) \nsage: (F-G)**2 \nx |--> 1/4*(sqrt(2)*e^(-1/2*x^2)/sqrt(pi) - 1.41421356237309*e^(-0.500000000000000*x^2)/sqrt(pi))^2\n```\nwhich coincides with the answer of unpatched Sage.\n\n> Really, in some sense the new version is 'better' because it keeps the minus where the user put it.  Do `(-I - 1/3*sqrt(2))^2` and `(I + 1/3*sqrt(2))^2` do anything different from before?\n\n\nThey do.\n\n```\nsage: (-I - 1/3*sqrt(2))^2\n1/9*(-sqrt(2) - 3*I)^2\n# Was: 1/9*(sqrt(2) + 3*I)^2\nsage: (I + 1/3*sqrt(2))^2\n1/9*(sqrt(2) + 3*I)^2\n# Was: 1/9*(sqrt(2) + 3*I)^2\n```\n\nReally I don't understand where that comes from. Namely, as far as I know, the sign of gcd or lcm did not change. The only difference in gcd/lcm examples involving `I` and `sqrt(2)` is the fact that without my patch an error would be raised.",
    "created_at": "2011-02-17T14:21:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136210",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:24'></a>Replying to [comment:23 kcrisman]:
> What happens with the already existing doctests?  That would be what I would be most concerned about. 


There are two tests (really in fact only one) in `sage.stats` where I had to change the expected output. The old and new output are equivalent:

```
sage: std([I, sqrt(2), 3/5]) # result with patch
sqrt(1/450*(-5*sqrt(2) + 10*I - 3)^2 + 1/450*(-5*sqrt(2) - 5*I + 6)^2 + 1/450*(10*sqrt(2) - 5*I - 3)^2)
# Without patch, we had sqrt(1/450*(5*sqrt(2) + 5*I - 6)^2 + 1/450*(5*sqrt(2) - 10*I + 3)^2 + 1/450*(10*sqrt(2) - 5*I - 3)^2)
# Testing equality:
sage: bool(sqrt(1/450*(5*sqrt(2) + 5*I - 6)^2 + 1/450*(5*sqrt(2) - 10*I + 3)^2 + 1/450*(10*sqrt(2) - 5*I - 3)^2) == std([I, sqrt(2), 3/5]))
True
```
There is essentially the same happening with `variance([I, sqrt(2), 3/5])`.

> Also, is the infinite loop now gone?  IIRC you had fixed that somehow.


Yep. The problem was that in an old version of my patch I would not try conversion to `ZZ` but conversion to the prime subfield. A real number with finitely many digits can of course *always* be converted into `RR.prime_subfield()`, which is `QQ`. So, I guess that the segfault came from rationals with very large numerator and denominator. Here is the proof that the segfault has gone:

```
sage: F(x) = 1/sqrt(2*pi*1^2)*exp(-1/(2*1^2)*(x-0)^2) 
sage: G(x) = 1/sqrt(2*pi*n(1)^2)*exp(-1/(2*n(1)^2)*(x-n(0))^2) 
sage: (F-G)**2 
x |--> 1/4*(sqrt(2)*e^(-1/2*x^2)/sqrt(pi) - 1.41421356237309*e^(-0.500000000000000*x^2)/sqrt(pi))^2
```
which coincides with the answer of unpatched Sage.

> Really, in some sense the new version is 'better' because it keeps the minus where the user put it.  Do `(-I - 1/3*sqrt(2))^2` and `(I + 1/3*sqrt(2))^2` do anything different from before?


They do.

```
sage: (-I - 1/3*sqrt(2))^2
1/9*(-sqrt(2) - 3*I)^2
# Was: 1/9*(sqrt(2) + 3*I)^2
sage: (I + 1/3*sqrt(2))^2
1/9*(sqrt(2) + 3*I)^2
# Was: 1/9*(sqrt(2) + 3*I)^2
```

Really I don't understand where that comes from. Namely, as far as I know, the sign of gcd or lcm did not change. The only difference in gcd/lcm examples involving `I` and `sqrt(2)` is the fact that without my patch an error would be raised.



---

archive/issue_comments_136211.json:
```json
{
    "body": "<a id='comment:25'></a>> > Really, in some sense the new version is 'better' because it keeps the minus where the user put it.  Do `(-I - 1/3*sqrt(2))^2` and `(I + 1/3*sqrt(2))^2` do anything different from before?\n\n> \n> They do.\n> sage: (-I - 1/3*sqrt(2))^2\n> 1/9*(-sqrt(2) - 3*I)^2\n> # Was: 1/9*(sqrt(2) + 3*I)^2\n\nOkay, that's what I figured would happen.\n> sage: (I + 1/3*sqrt(2))^2\n> 1/9*(sqrt(2) + 3*I)^2\n> # Was: 1/9*(sqrt(2) + 3*I)^2\n\nOkay, that is the same as before in any case.\n> Really I don't understand where that comes from. Namely, as far as I know, the sign of gcd or lcm did not change. The only difference in gcd/lcm examples involving `I` and `sqrt(2)` is the fact that without my patch an error would be raised.\n\nYes,\n\n```\nsage: gcd(I + 1/3*sqrt(2),I + 1/3*sqrt(2))\n---------------------------------------------------------------------------\nRuntimeError                              Traceback (most recent call last)\n```\nInteresting.  Like I said earlier, Sage now sends such symbolic things to Pynac/Ginac, which however needs to use Sage again in order to do certain calculations like this (Mike Hansen explained it well in your thread on sage-devel).  So apparently in the past it decided to factor out a -1 in certain cases based on some gcd - maybe just a default of 1 or something - whereas now it does not, due to the new gcd.  What does \n\n```\nsage: gcd(I + 1/3*sqrt(2),I + 1/3*sqrt(2))\n```\ndo after the patch?  What happens with this?\n\n```\nsage: gcd(4,2+2*I*sqrt(3))\n```\nNotice that I am purposely taking two things NOT in a polynomial or extension thing, where it can be calculated whether it's a UFD.  In the symbolic ring, who knows what's \"right\"?",
    "created_at": "2011-02-17T14:47:09Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136211",
    "user": "https://github.com/kcrisman"
}
```

<a id='comment:25'></a>> > Really, in some sense the new version is 'better' because it keeps the minus where the user put it.  Do `(-I - 1/3*sqrt(2))^2` and `(I + 1/3*sqrt(2))^2` do anything different from before?

> 
> They do.
> sage: (-I - 1/3*sqrt(2))^2
> 1/9*(-sqrt(2) - 3*I)^2
> # Was: 1/9*(sqrt(2) + 3*I)^2

Okay, that's what I figured would happen.
> sage: (I + 1/3*sqrt(2))^2
> 1/9*(sqrt(2) + 3*I)^2
> # Was: 1/9*(sqrt(2) + 3*I)^2

Okay, that is the same as before in any case.
> Really I don't understand where that comes from. Namely, as far as I know, the sign of gcd or lcm did not change. The only difference in gcd/lcm examples involving `I` and `sqrt(2)` is the fact that without my patch an error would be raised.

Yes,

```
sage: gcd(I + 1/3*sqrt(2),I + 1/3*sqrt(2))
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
```
Interesting.  Like I said earlier, Sage now sends such symbolic things to Pynac/Ginac, which however needs to use Sage again in order to do certain calculations like this (Mike Hansen explained it well in your thread on sage-devel).  So apparently in the past it decided to factor out a -1 in certain cases based on some gcd - maybe just a default of 1 or something - whereas now it does not, due to the new gcd.  What does 

```
sage: gcd(I + 1/3*sqrt(2),I + 1/3*sqrt(2))
```
do after the patch?  What happens with this?

```
sage: gcd(4,2+2*I*sqrt(3))
```
Notice that I am purposely taking two things NOT in a polynomial or extension thing, where it can be calculated whether it's a UFD.  In the symbolic ring, who knows what's "right"?



---

archive/issue_comments_136212.json:
```json
{
    "body": "<a id='comment:26'></a>I think I've figured out hg queues now, so I can actually try out the patch!  [No guarantees, though.]  Was fuzz-testing it and noticed the following:\n\n```\nsage: var(\"x\")\nx\nsage: a = 1/3*x**0\nsage: b = 2/5*x**0\nsage: type(a)\n<type 'sage.symbolic.expression.Expression'>\nsage: gcd(a,b)\n1/15\nsage: lcm(a,b)\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\n\n/Applications/sage_devel/devel/sage-main/<ipython console> in <module>()\n\n/Applications/sage_devel/local/lib/python2.6/site-packages/sage/rings/arith.pyc in lcm(a, b)\n   1562                 return ZZ(a).lcm(ZZ(b))\n   1563             except TypeError:\n-> 1564                 raise TypeError, \"unable to find lcm of %s and %s\"%(a,b)\n   1565         return LCM(b)\n   1566 \n\nTypeError: unable to find lcm of 1/3 and 2/5\n```\n\nAll bets are off in SR, but there is an Expression.gcd (no .lcm, strangely).  Now that QQ reduces to ZZ, maybe switch the attempt to try ZZ to QQ, so that rationals Just Work(tm)?\n\nThis surprised me a little too:\n\n```\nsage: R.<x>=QQ[]\nsage: \nsage: a = 1/3*x**0\nsage: b = 2/5*x**0\nsage: type(a)\n<type 'sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint'>\nsage: gcd(a,b), lcm(a,b)\n(1, 1)\nsage: \nsage: a = (1*x**0)/(3*x**0)\nsage: b = (2*x**0)/(5*x**0)\nsage: type(a)\n<class 'sage.rings.fraction_field_element.FractionFieldElement_1poly_field'>\nsage: gcd(a,b), lcm(a,b)\n(1, 1)\n```\n\ngiven that the seemingly harder cases\n\n```\nsage: a = 1/3+x\nsage: b = 2/5+x\nsage: type(a)\n<type 'sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint'>\nsage: gcd(a,b), lcm(a,b), a*b-gcd(a,b)*lcm(a,b)\n(1, x^2 + 11/15*x + 2/15, 0)\nsage: \nsage: a = (1*x**0)/(3*x**0)+x\nsage: b = (2*x**0)/(5*x**0)+x\nsage: type(a)\n<class 'sage.rings.fraction_field_element.FractionFieldElement_1poly_field'>\nsage: gcd(a,b), lcm(a,b), a*b-gcd(a,b)*lcm(a,b)\n(1, x^2 + 11/15*x + 2/15, 0)\n```\n\nbehave a little nicer.  Is it possible to recover the rational results?",
    "created_at": "2011-02-17T15:19:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136212",
    "user": "https://trac.sagemath.org/admin/accounts/users/dsm"
}
```

<a id='comment:26'></a>I think I've figured out hg queues now, so I can actually try out the patch!  [No guarantees, though.]  Was fuzz-testing it and noticed the following:

```
sage: var("x")
x
sage: a = 1/3*x**0
sage: b = 2/5*x**0
sage: type(a)
<type 'sage.symbolic.expression.Expression'>
sage: gcd(a,b)
1/15
sage: lcm(a,b)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)

/Applications/sage_devel/devel/sage-main/<ipython console> in <module>()

/Applications/sage_devel/local/lib/python2.6/site-packages/sage/rings/arith.pyc in lcm(a, b)
   1562                 return ZZ(a).lcm(ZZ(b))
   1563             except TypeError:
-> 1564                 raise TypeError, "unable to find lcm of %s and %s"%(a,b)
   1565         return LCM(b)
   1566 

TypeError: unable to find lcm of 1/3 and 2/5
```

All bets are off in SR, but there is an Expression.gcd (no .lcm, strangely).  Now that QQ reduces to ZZ, maybe switch the attempt to try ZZ to QQ, so that rationals Just Work(tm)?

This surprised me a little too:

```
sage: R.<x>=QQ[]
sage: 
sage: a = 1/3*x**0
sage: b = 2/5*x**0
sage: type(a)
<type 'sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint'>
sage: gcd(a,b), lcm(a,b)
(1, 1)
sage: 
sage: a = (1*x**0)/(3*x**0)
sage: b = (2*x**0)/(5*x**0)
sage: type(a)
<class 'sage.rings.fraction_field_element.FractionFieldElement_1poly_field'>
sage: gcd(a,b), lcm(a,b)
(1, 1)
```

given that the seemingly harder cases

```
sage: a = 1/3+x
sage: b = 2/5+x
sage: type(a)
<type 'sage.rings.polynomial.polynomial_rational_flint.Polynomial_rational_flint'>
sage: gcd(a,b), lcm(a,b), a*b-gcd(a,b)*lcm(a,b)
(1, x^2 + 11/15*x + 2/15, 0)
sage: 
sage: a = (1*x**0)/(3*x**0)+x
sage: b = (2*x**0)/(5*x**0)+x
sage: type(a)
<class 'sage.rings.fraction_field_element.FractionFieldElement_1poly_field'>
sage: gcd(a,b), lcm(a,b), a*b-gcd(a,b)*lcm(a,b)
(1, x^2 + 11/15*x + 2/15, 0)
```

behave a little nicer.  Is it possible to recover the rational results?



---

archive/issue_comments_136213.json:
```json
{
    "body": "<a id='comment:27'></a>Ah, I just read the comments in #8111 (re: having to dive into flint).  Well, at least changing ZZ to QQ in rings.arith.lcm would be straightforward.",
    "created_at": "2011-02-17T15:53:32Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136213",
    "user": "https://trac.sagemath.org/admin/accounts/users/dsm"
}
```

<a id='comment:27'></a>Ah, I just read the comments in #8111 (re: having to dive into flint).  Well, at least changing ZZ to QQ in rings.arith.lcm would be straightforward.



---

archive/issue_comments_136214.json:
```json
{
    "body": "<a id='comment:28'></a>Replying to [comment:27 dsm]:\n> Ah, I just read the comments in #8111 (re: having to dive into flint).  Well, at least changing ZZ to QQ in rings.arith.lcm would be straightforward.\n\n\nIt could be that it is not straight forward. If my analysis of the segfault occuring with a previous version of my patch is correct, changing `ZZ` to `QQ` could very well trigger the segfault again.",
    "created_at": "2011-02-17T16:21:26Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136214",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:28'></a>Replying to [comment:27 dsm]:
> Ah, I just read the comments in #8111 (re: having to dive into flint).  Well, at least changing ZZ to QQ in rings.arith.lcm would be straightforward.


It could be that it is not straight forward. If my analysis of the segfault occuring with a previous version of my patch is correct, changing `ZZ` to `QQ` could very well trigger the segfault again.



---

archive/issue_comments_136215.json:
```json
{
    "body": "<a id='comment:29'></a>Well, even after changing ZZ to QQ there everything seems to work as expected for me (no segfaults, a quick subset of tests all passed; I'll try testall long later and look for more crashers), and if it did explode it sort of feels like it'd be due to a bug somewhere else that it revealed.. but that can wait for another ticket later.\n\nThe real meat is already in your patch, and I'm already using it, so I'm very grateful for the work, and hope someone gives the okay soon!  `:^)`",
    "created_at": "2011-02-25T12:04:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136215",
    "user": "https://trac.sagemath.org/admin/accounts/users/dsm"
}
```

<a id='comment:29'></a>Well, even after changing ZZ to QQ there everything seems to work as expected for me (no segfaults, a quick subset of tests all passed; I'll try testall long later and look for more crashers), and if it did explode it sort of feels like it'd be due to a bug somewhere else that it revealed.. but that can wait for another ticket later.

The real meat is already in your patch, and I'm already using it, so I'm very grateful for the work, and hope someone gives the okay soon!  `:^)`



---

archive/issue_comments_136216.json:
```json
{
    "body": "Changing assignee from @aghitza to dsm.",
    "created_at": "2011-02-25T12:04:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136216",
    "user": "https://trac.sagemath.org/admin/accounts/users/dsm"
}
```

Changing assignee from @aghitza to dsm.



---

archive/issue_comments_136217.json:
```json
{
    "body": "Changing assignee from dsm to @aghitza.",
    "created_at": "2011-03-02T05:23:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136217",
    "user": "https://trac.sagemath.org/admin/accounts/users/dsm"
}
```

Changing assignee from dsm to @aghitza.



---

archive/issue_comments_136218.json:
```json
{
    "body": "<a id='comment:31'></a>Replying to [comment:29 dsm]:\n> Well, even after changing ZZ to QQ there everything seems to work as expected for me (no segfaults, a quick subset of tests all passed; I'll try testall long later and look for more crashers), and if it did explode it sort of feels like it'd be due to a bug somewhere else that it revealed.. but that can wait for another ticket later.\n\n\nWhat came out of the tests?\n\n> The real meat is already in your patch, and I'm already using it, so I'm very grateful for the work, and hope someone gives the okay soon!  `:^)`\n\n\nYou (after finishing the tests, of course)?? Or you could post a patch for changing `ZZ` to `QQ` in `rings.arith.lcm`, and perhaps I can have a look on it? If I remember correctly, it is ok if you are reviewer for my patch and I am reviewer for your patch.",
    "created_at": "2011-03-02T06:40:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136218",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:31'></a>Replying to [comment:29 dsm]:
> Well, even after changing ZZ to QQ there everything seems to work as expected for me (no segfaults, a quick subset of tests all passed; I'll try testall long later and look for more crashers), and if it did explode it sort of feels like it'd be due to a bug somewhere else that it revealed.. but that can wait for another ticket later.


What came out of the tests?

> The real meat is already in your patch, and I'm already using it, so I'm very grateful for the work, and hope someone gives the okay soon!  `:^)`


You (after finishing the tests, of course)?? Or you could post a patch for changing `ZZ` to `QQ` in `rings.arith.lcm`, and perhaps I can have a look on it? If I remember correctly, it is ok if you are reviewer for my patch and I am reviewer for your patch.



---

archive/issue_comments_136219.json:
```json
{
    "body": "<a id='comment:32'></a>Replying to [comment:31 SimonKing]:\n> What came out of the tests?\n\n\nI seem to recall it passed just fine but I can't find the output now `:-(` so I'm rerunning them (takes me about ~3h).\n\n> You (after finishing the tests, of course)?? \n\n\nFollowing was's recommendations (http://ask.sagemath.org/question/31/should-i-_really_-review-trac-tickets) I don't think I've got enough experience with the Sage codebase yet to set something to positive review; I'm still finding my way around.",
    "created_at": "2011-03-02T12:29:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136219",
    "user": "https://trac.sagemath.org/admin/accounts/users/dsm"
}
```

<a id='comment:32'></a>Replying to [comment:31 SimonKing]:
> What came out of the tests?


I seem to recall it passed just fine but I can't find the output now `:-(` so I'm rerunning them (takes me about ~3h).

> You (after finishing the tests, of course)?? 


Following was's recommendations (http://ask.sagemath.org/question/31/should-i-_really_-review-trac-tickets) I don't think I've got enough experience with the Sage codebase yet to set something to positive review; I'm still finding my way around.



---

archive/issue_comments_136220.json:
```json
{
    "body": "Changing reviewer from \"Marco Streng\" to \"Marco Streng, Mariah Lenox\"",
    "created_at": "2011-06-22T13:04:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136220",
    "user": "https://trac.sagemath.org/admin/accounts/users/mariah"
}
```

Changing reviewer from "Marco Streng" to "Marco Streng, Mariah Lenox"



---

archive/issue_comments_136221.json:
```json
{
    "body": "Changing status from needs_review to positive_review.",
    "created_at": "2011-06-22T13:04:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136221",
    "user": "https://trac.sagemath.org/admin/accounts/users/mariah"
}
```

Changing status from needs_review to positive_review.



---

archive/issue_comments_136222.json:
```json
{
    "body": "<a id='comment:33'></a>Applied patch to sage-4.7.1.alpha2, did 'sage -b' followed by 'make testlong'.  All tests passed.  Positive review!",
    "created_at": "2011-06-22T13:04:34Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136222",
    "user": "https://trac.sagemath.org/admin/accounts/users/mariah"
}
```

<a id='comment:33'></a>Applied patch to sage-4.7.1.alpha2, did 'sage -b' followed by 'make testlong'.  All tests passed.  Positive review!



---

archive/issue_comments_136223.json:
```json
{
    "body": "<a id='comment:34'></a><Mr Burns>  Excellent.  </Burns>  Many thanks to Simon for the work!",
    "created_at": "2011-06-22T13:18:12Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136223",
    "user": "https://trac.sagemath.org/admin/accounts/users/dsm"
}
```

<a id='comment:34'></a><Mr Burns>  Excellent.  </Burns>  Many thanks to Simon for the work!



---

archive/issue_events_027763.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-06-22T17:38:00Z",
    "event": "milestoned",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "milestone": "sage-4.7.2",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10771#event-27763"
}
```



---

archive/issue_comments_136224.json:
```json
{
    "body": "Changing type from defect to enhancement.",
    "created_at": "2011-06-22T17:38:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136224",
    "user": "https://github.com/jdemeyer"
}
```

Changing type from defect to enhancement.



---

archive/issue_comments_136225.json:
```json
{
    "body": "<a id='comment:36'></a>Could you please change the commit message such that the lines are not so long?  You should wrap long lines but make sure the first still makes sense by itself, that will appear in `hg log`.",
    "created_at": "2011-06-26T18:27:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136225",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:36'></a>Could you please change the commit message such that the lines are not so long?  You should wrap long lines but make sure the first still makes sense by itself, that will appear in `hg log`.



---

archive/issue_comments_136226.json:
```json
{
    "body": "Changing status from positive_review to needs_work.",
    "created_at": "2011-06-26T18:27:10Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136226",
    "user": "https://github.com/jdemeyer"
}
```

Changing status from positive_review to needs_work.



---

archive/issue_comments_136227.json:
```json
{
    "body": "Attachment [trac10771-lcm_gcd_fraction_fields.patch](tarball://root/attachments/some-uuid/ticket10771/trac10771-lcm_gcd_fraction_fields.patch) by @simon-king-jena created at 2011-06-26 19:03:51\n\nImplement gcd and lcm for general fields, with the special case of the fraction field of a unique factorization domain",
    "created_at": "2011-06-26T19:03:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136227",
    "user": "https://github.com/simon-king-jena"
}
```

Attachment [trac10771-lcm_gcd_fraction_fields.patch](tarball://root/attachments/some-uuid/ticket10771/trac10771-lcm_gcd_fraction_fields.patch) by @simon-king-jena created at 2011-06-26 19:03:51

Implement gcd and lcm for general fields, with the special case of the fraction field of a unique factorization domain



---

archive/issue_comments_136228.json:
```json
{
    "body": "Changing status from needs_work to positive_review.",
    "created_at": "2011-06-26T19:06:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136228",
    "user": "https://github.com/simon-king-jena"
}
```

Changing status from needs_work to positive_review.



---

archive/issue_comments_136229.json:
```json
{
    "body": "<a id='comment:37'></a>Replying to [comment:36 jdemeyer]:\n> Could you please change the commit message such that the lines are not so long?  You should wrap long lines but make sure the first still makes sense by itself, that will appear in `hg log`.\n\n\nAdmittedly the log line was \"a bit\" two long. It is now spread over three lines. I hope it is fine now.",
    "created_at": "2011-06-26T19:06:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136229",
    "user": "https://github.com/simon-king-jena"
}
```

<a id='comment:37'></a>Replying to [comment:36 jdemeyer]:
> Could you please change the commit message such that the lines are not so long?  You should wrap long lines but make sure the first still makes sense by itself, that will appear in `hg log`.


Admittedly the log line was "a bit" two long. It is now spread over three lines. I hope it is fine now.



---

archive/issue_comments_136230.json:
```json
{
    "body": "Resolution: fixed",
    "created_at": "2011-07-22T12:50:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136230",
    "user": "https://github.com/jdemeyer"
}
```

Resolution: fixed



---

archive/issue_events_027764.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-07-22T12:50:17Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10771#event-27764"
}
```



---

archive/issue_comments_136231.json:
```json
{
    "body": "Changing merged from \"\" to \"sage-4.7.2.alpha0\"",
    "created_at": "2011-07-22T12:50:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10771",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10771#issuecomment-136231",
    "user": "https://github.com/jdemeyer"
}
```

Changing merged from "" to "sage-4.7.2.alpha0"
