# Issue 10339: Simplify spkg/pipestatus

archive/issues_010338.json:
```json
{
    "body": "`spkg/pipestatus` currently uses two different mechanisms, depending on the `bash` version (>=3.0 or not).  Unfortunately, the two alternatives currently differ in behaviour (the consequence in one case being an `install.log` file appearing in the wrong place).\n\nConsider a command\n\n```\npipestatus \"A && B\" \"C\"\n```\n\n**Alternative 1** (for new versions of bash) does\n\n```sh\nA && (B | C)\n```\n(which is - without regard of the subshell environment - equivalent to the command list without parentheses, i.e. `A && B | C`, since the pipe symbol has higher precedence),\n\n\nwhile **alternative 2** (for very old versions of bash) does\n\n```sh\n(A && B) | C\n```\n\n---\n\nThe attached / merged patch makes `pipestatus` behave like **alternative 1** for *all* versions of `bash`, and executes all commands in the *same* environment.\n\nIt also patches the top-level `Makefile` to no longer depend on (previously) varying behavior of `pipestatus` by changing a receipt to\n\n```sh\n        cd some_dir && pipestatus \"A\" \"B\"\n```\n(where `A` and `B` are simple commands).\n\n---\n\nMerged patches: [attachment:10339_pipestatus.v3.patch] and [attachment:10339_pipestatus.v3_spkg_install.patch]\n\n**Assignee:** GeorgSWeber\n\n**CC:**  @nexttime drkirkby @kiwifb\n\n**Keywords:** pipestatus Makefile shell environment tee exit code status\n\n**Author:** Jeroen Demeyer, Leif Leonhardy\n\n**Reviewer:** Leif Leonhardy\n\n**Merged:** sage-4.6.1.rc0\n\nIssue created by migration from https://trac.sagemath.org/ticket/10339\n\n",
    "closed_at": "2011-01-10T20:50:07Z",
    "created_at": "2010-11-26T14:36:08Z",
    "labels": [
        "component: scripts",
        "bug"
    ],
    "milestone": "https://github.com/sagemath/sagetest/milestones/sage-4.6.1",
    "title": "Simplify spkg/pipestatus",
    "type": "issue",
    "url": "https://github.com/sagemath/sagetest/issues/10339",
    "user": "https://github.com/jdemeyer"
}
```
`spkg/pipestatus` currently uses two different mechanisms, depending on the `bash` version (>=3.0 or not).  Unfortunately, the two alternatives currently differ in behaviour (the consequence in one case being an `install.log` file appearing in the wrong place).

Consider a command

```
pipestatus "A && B" "C"
```

**Alternative 1** (for new versions of bash) does

```sh
A && (B | C)
```
(which is - without regard of the subshell environment - equivalent to the command list without parentheses, i.e. `A && B | C`, since the pipe symbol has higher precedence),


while **alternative 2** (for very old versions of bash) does

```sh
(A && B) | C
```

---

The attached / merged patch makes `pipestatus` behave like **alternative 1** for *all* versions of `bash`, and executes all commands in the *same* environment.

It also patches the top-level `Makefile` to no longer depend on (previously) varying behavior of `pipestatus` by changing a receipt to

```sh
        cd some_dir && pipestatus "A" "B"
```
(where `A` and `B` are simple commands).

---

Merged patches: [attachment:10339_pipestatus.v3.patch] and [attachment:10339_pipestatus.v3_spkg_install.patch]

**Assignee:** GeorgSWeber

**CC:**  @nexttime drkirkby @kiwifb

**Keywords:** pipestatus Makefile shell environment tee exit code status

**Author:** Jeroen Demeyer, Leif Leonhardy

**Reviewer:** Leif Leonhardy

**Merged:** sage-4.6.1.rc0

Issue created by migration from https://trac.sagemath.org/ticket/10339





---

archive/issue_comments_098993.json:
```json
{
    "body": "Replying to [ticket:10339 jdemeyer]:\n> In my opinion, there should be only one alternative.  If we have something which works for old versions, why not use that for new versions also?\n\n\nBecause it is completely inefficient; I would even use `set -o pipefail` in `bash` >= 3.0 directly, and not call scripts.\n\nIMHO Bash 3.0 is old enough to make it a prerequisite anyway.\n\n> In any case, it would be good to think of a more robust implementation of pipestatus.  I can think of the following:\n\n\n>  1. Write a simple C program using pipe(), fork(), exec(), wait().\n\n\n>  2. Use the `mkfifo` command.\n\n\n>  3. Use a temporary file:\n\n\n```\n EXITSTATUS=/tmp/pipestatus$$     # Obviously, we should use TMPDIR if set\n ( A; echo $? >$EXITSTATUS ) | B\n```\n\nBack to MS-DOS? ;-)",
    "created_at": "2010-11-26T14:56:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-98993",
    "user": "https://github.com/nexttime"
}
```

Replying to [ticket:10339 jdemeyer]:
> In my opinion, there should be only one alternative.  If we have something which works for old versions, why not use that for new versions also?


Because it is completely inefficient; I would even use `set -o pipefail` in `bash` >= 3.0 directly, and not call scripts.

IMHO Bash 3.0 is old enough to make it a prerequisite anyway.

> In any case, it would be good to think of a more robust implementation of pipestatus.  I can think of the following:


>  1. Write a simple C program using pipe(), fork(), exec(), wait().


>  2. Use the `mkfifo` command.


>  3. Use a temporary file:


```
 EXITSTATUS=/tmp/pipestatus$$     # Obviously, we should use TMPDIR if set
 ( A; echo $? >$EXITSTATUS ) | B
```

Back to MS-DOS? ;-)



---

archive/issue_comments_098994.json:
```json
{
    "body": "Replying to [ticket:10339 jdemeyer]:\n> Consider a command\n\n\n```sh\n pipestatus \"A && B\" \"C\"\n```\n\nSomeone reading the \"documentation\":\n\n```\nif [ -z \"$1\" ]; then\n    echo \"Run two commands in a pipeline 'CMD1 | CMD2' and exit\"\n    echo \"with the exit status of CMD1, *not* that of CMD2.\"\n    echo \"$0 cmd1 cmd2\"\n    exit\nfi\n```\nwould perhaps do:\n\n```sh\npipestatus \"(A && B)\" \"C\"\n```\nbut we can add the parentheses in `pipestatus` to get the same behavior in both cases:\n\n```diff\n--- pipestatus.orig\t2010-07-22 10:54:43.000000000 +0200\n+++ pipestatus\t2010-11-26 16:14:37.000000000 +0100\n@@ -16,7 +16,8 @@\n \n if [ $VER -gt 2 ]; then\n     # Use bash 3.0's pipefail option.\n-    (set -o pipefail; eval \"$1 | $2\")\n+    set -o pipefail\n+    eval \"($1) | $2\"\n     exit $?\n else\n     # Use redirection.  Adapted from the comp.unix.shell FAQ.  See\n```\n\nBtw, if we change pipestatus, we should also `test $# -eq 2` and give an error otherwise. Such a change was previously rejected just because someone didn't want to touch `pipestatus` or `spkg/install` again.\n\n> Alternative 1 (for new versions of bash) does `A && (B | C)` while alternative 2 (for old versions of bash) does `(A && B) | C`.\n\n\nThe patch above fixes that, though it's IMHO a minor issue, because one can easily make the call to `pipestatus` unambiguous.",
    "created_at": "2010-11-26T15:28:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-98994",
    "user": "https://github.com/nexttime"
}
```

Replying to [ticket:10339 jdemeyer]:
> Consider a command


```sh
 pipestatus "A && B" "C"
```

Someone reading the "documentation":

```
if [ -z "$1" ]; then
    echo "Run two commands in a pipeline 'CMD1 | CMD2' and exit"
    echo "with the exit status of CMD1, *not* that of CMD2."
    echo "$0 cmd1 cmd2"
    exit
fi
```
would perhaps do:

```sh
pipestatus "(A && B)" "C"
```
but we can add the parentheses in `pipestatus` to get the same behavior in both cases:

```diff
--- pipestatus.orig	2010-07-22 10:54:43.000000000 +0200
+++ pipestatus	2010-11-26 16:14:37.000000000 +0100
@@ -16,7 +16,8 @@
 
 if [ $VER -gt 2 ]; then
     # Use bash 3.0's pipefail option.
-    (set -o pipefail; eval "$1 | $2")
+    set -o pipefail
+    eval "($1) | $2"
     exit $?
 else
     # Use redirection.  Adapted from the comp.unix.shell FAQ.  See
```

Btw, if we change pipestatus, we should also `test $# -eq 2` and give an error otherwise. Such a change was previously rejected just because someone didn't want to touch `pipestatus` or `spkg/install` again.

> Alternative 1 (for new versions of bash) does `A && (B | C)` while alternative 2 (for old versions of bash) does `(A && B) | C`.


The patch above fixes that, though it's IMHO a minor issue, because one can easily make the call to `pipestatus` unambiguous.



---

archive/issue_comments_098995.json:
```json
{
    "body": "<a id='comment:3'></a>\nPerhaps better\n\n```diff\n--- pipestatus.orig\t2010-07-22 10:54:43.000000000 +0200\n+++ pipestatus\t2010-11-26 16:35:44.000000000 +0100\n@@ -1,6 +1,6 @@\n #!/usr/bin/env bash\n \n-if [ -z \"$1\" ]; then\n+if [ $# -ne 2 ] || [ -z \"$1\" -o -z \"$2\" ]; then\n     echo \"Run two commands in a pipeline 'CMD1 | CMD2' and exit\"\n     echo \"with the exit status of CMD1, *not* that of CMD2.\"\n     echo \"$0 cmd1 cmd2\"\n@@ -16,7 +16,8 @@\n \n if [ $VER -gt 2 ]; then\n     # Use bash 3.0's pipefail option.\n-    (set -o pipefail; eval \"$1 | $2\")\n+    set -o pipefail\n+    eval \"( $1 ) | ( $2 )\"\n     exit $?\n else\n     # Use redirection.  Adapted from the comp.unix.shell FAQ.  See\n```",
    "created_at": "2010-11-26T15:39:38Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-98995",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:3'></a>
Perhaps better

```diff
--- pipestatus.orig	2010-07-22 10:54:43.000000000 +0200
+++ pipestatus	2010-11-26 16:35:44.000000000 +0100
@@ -1,6 +1,6 @@
 #!/usr/bin/env bash
 
-if [ -z "$1" ]; then
+if [ $# -ne 2 ] || [ -z "$1" -o -z "$2" ]; then
     echo "Run two commands in a pipeline 'CMD1 | CMD2' and exit"
     echo "with the exit status of CMD1, *not* that of CMD2."
     echo "$0 cmd1 cmd2"
@@ -16,7 +16,8 @@
 
 if [ $VER -gt 2 ]; then
     # Use bash 3.0's pipefail option.
-    (set -o pipefail; eval "$1 | $2")
+    set -o pipefail
+    eval "( $1 ) | ( $2 )"
     exit $?
 else
     # Use redirection.  Adapted from the comp.unix.shell FAQ.  See
```



---

archive/issue_comments_098996.json:
```json
{
    "body": "<a id='comment:4'></a>\nP.P.S.: We should then also update the documentation, i.e. the usage message, to reflect that one or both commands are run in (different) subshells.",
    "created_at": "2010-11-26T15:44:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-98996",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:4'></a>
P.P.S.: We should then also update the documentation, i.e. the usage message, to reflect that one or both commands are run in (different) subshells.



---

archive/issue_comments_098997.json:
```json
{
    "body": "<a id='comment:5'></a>\nP.P.P.S.:\n\nRather than testing for the Bash version, it would be better to use\n\n```sh\nif set -o | grep -w pipefail &>/dev/null; then\n    # shell (whatever it is) supports set -o pipefail\n    ...\nelse\n    # not supported - work around\n    ...\nfi\n```\nsince other shells might adopt that feature.",
    "created_at": "2010-11-26T15:58:42Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-98997",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:5'></a>
P.P.P.S.:

Rather than testing for the Bash version, it would be better to use

```sh
if set -o | grep -w pipefail &>/dev/null; then
    # shell (whatever it is) supports set -o pipefail
    ...
else
    # not supported - work around
    ...
fi
```
since other shells might adopt that feature.



---

archive/issue_comments_098998.json:
```json
{
    "body": "<a id='comment:6'></a>\nReplying to [leif](#comment%3A1):\n> IMHO Bash 3.0 is old enough to make it a prerequisite anyway.\n\n\n-1 to this idea, since OS X 10.4 has bash version 2.\n\nThe question I posed in the ticket remains: why should there be two cases (the second case should work always, no matter the bash version).\n\nBy the way: fixing `eval \"$1 | $2\"` is easy: `eval \"$1\" | eval \"$2\"`.",
    "created_at": "2010-11-26T16:12:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-98998",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:6'></a>
Replying to [leif](#comment%3A1):
> IMHO Bash 3.0 is old enough to make it a prerequisite anyway.


-1 to this idea, since OS X 10.4 has bash version 2.

The question I posed in the ticket remains: why should there be two cases (the second case should work always, no matter the bash version).

By the way: fixing `eval "$1 | $2"` is easy: `eval "$1" | eval "$2"`.



---

archive/issue_comments_098999.json:
```json
{
    "body": "<a id='comment:7'></a>\nReplying to [leif](#comment%3A1):\n> Replying to [ticket:10339 jdemeyer]:\n> > In my opinion, there should be only one alternative.  If we have something which works for old versions, why not use that for new versions also?\n\n> \n> Because it is completely inefficient\n\n\nPlease elaborate...",
    "created_at": "2010-11-26T16:17:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-98999",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:7'></a>
Replying to [leif](#comment%3A1):
> Replying to [ticket:10339 jdemeyer]:
> > In my opinion, there should be only one alternative.  If we have something which works for old versions, why not use that for new versions also?

> 
> Because it is completely inefficient


Please elaborate...



---

archive/issue_comments_099000.json:
```json
{
    "body": "<a id='comment:8'></a>\nReplying to [jdemeyer](#comment%3A6):\n> Replying to [leif](#comment%3A1):\n> > IMHO Bash 3.0 is old enough to make it a prerequisite anyway.\n\n> \n> -1 to this idea, since OS X 10.4 has bash version 2.\n\n\nI don't care about it since it is dead old and only causes problems. If someone is able to build Sage on MacOS X 10.4, Bash 3.x or 4.x should also build, be it an optional Sage package for boot-strapping.\n\n> The question I posed in the ticket remains: why should there be two cases (the second case should work always, no matter the bash version).\n\n\nHaving both in `pipestatus` doesn't make *much* sense. As said, if at all I would make a distinction in the scripts where `pipestatus` is needed / called, and / or use a variable for the command, which could simply be a shell function. (`spkg/standard/deps` e.g. should IMHO be *generated* anyway.)\n\n> By the way: fixing `eval \"$1 | $2\"` is easy: `eval \"$1\" | eval \"$2\"`.\n\n\nSure.",
    "created_at": "2010-11-26T18:40:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99000",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:8'></a>
Replying to [jdemeyer](#comment%3A6):
> Replying to [leif](#comment%3A1):
> > IMHO Bash 3.0 is old enough to make it a prerequisite anyway.

> 
> -1 to this idea, since OS X 10.4 has bash version 2.


I don't care about it since it is dead old and only causes problems. If someone is able to build Sage on MacOS X 10.4, Bash 3.x or 4.x should also build, be it an optional Sage package for boot-strapping.

> The question I posed in the ticket remains: why should there be two cases (the second case should work always, no matter the bash version).


Having both in `pipestatus` doesn't make *much* sense. As said, if at all I would make a distinction in the scripts where `pipestatus` is needed / called, and / or use a variable for the command, which could simply be a shell function. (`spkg/standard/deps` e.g. should IMHO be *generated* anyway.)

> By the way: fixing `eval "$1 | $2"` is easy: `eval "$1" | eval "$2"`.


Sure.



---

archive/issue_comments_099001.json:
```json
{
    "body": "<a id='comment:9'></a>\nReplying to [leif](#comment%3A8):\n> Replying to [jdemeyer](#comment%3A6):\n> > Replying to [leif](#comment%3A1):\n> > > IMHO Bash 3.0 is old enough to make it a prerequisite anyway.\n\n> > \n> > -1 to this idea, since OS X 10.4 has bash version 2.\n\n> \n> I don't care about it since it is dead old and only causes problems. If someone is able to build Sage on MacOS X 10.4, Bash 3.x or 4.x should also build, be it an optional Sage package for boot-strapping.\n> \n\nWell, there are people that do care about OS X 10.4. Since (at least) Sage-3.4 till the current Sage-4.6.alpha2, this is an officially supported platform with the regular binary distributions. If Harald (who is able to look at the statistics) tells me nobody downloads these anymore, I'll stop providing them. OTOH, the inclusion of bash as a Sage dependency has been discussed before. (Mainly due to the problems if the system bash is built to use readline as dynamic librariy, and blows up if the readline lib provided by Sage is older, but is found first in the library search path due to the Sage specific LD_LIBRARY_PATH settings, as e.g. in Arch Linux and younger SuSE distributions.)\nBut the conclusion was always that we don't want to have bash as a core dependency to be shipped with Sage (be it only for a few OSes).\n\nCheers,\nGeorg",
    "created_at": "2010-11-26T19:03:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99001",
    "user": "https://trac.sagemath.org/admin/accounts/users/GeorgSWeber"
}
```

<a id='comment:9'></a>
Replying to [leif](#comment%3A8):
> Replying to [jdemeyer](#comment%3A6):
> > Replying to [leif](#comment%3A1):
> > > IMHO Bash 3.0 is old enough to make it a prerequisite anyway.

> > 
> > -1 to this idea, since OS X 10.4 has bash version 2.

> 
> I don't care about it since it is dead old and only causes problems. If someone is able to build Sage on MacOS X 10.4, Bash 3.x or 4.x should also build, be it an optional Sage package for boot-strapping.
> 

Well, there are people that do care about OS X 10.4. Since (at least) Sage-3.4 till the current Sage-4.6.alpha2, this is an officially supported platform with the regular binary distributions. If Harald (who is able to look at the statistics) tells me nobody downloads these anymore, I'll stop providing them. OTOH, the inclusion of bash as a Sage dependency has been discussed before. (Mainly due to the problems if the system bash is built to use readline as dynamic librariy, and blows up if the readline lib provided by Sage is older, but is found first in the library search path due to the Sage specific LD_LIBRARY_PATH settings, as e.g. in Arch Linux and younger SuSE distributions.)
But the conclusion was always that we don't want to have bash as a core dependency to be shipped with Sage (be it only for a few OSes).

Cheers,
Georg



---

archive/issue_comments_099002.json:
```json
{
    "body": "<a id='comment:10'></a>\nReplying to [GeorgSWeber](#comment%3A9):\n> Replying to [leif](#comment%3A8):\n> > Replying to [jdemeyer](#comment%3A6):\n> > > Replying to [leif](#comment%3A1):\n> > > > IMHO Bash 3.0 is old enough to make it a prerequisite anyway.\n\n> > > \n> > > -1 to this idea, since OS X 10.4 has bash version 2.\n\n> > \n> > I don't care about it since it is dead old and only causes problems. If someone is able to build Sage on MacOS X 10.4, Bash 3.x or 4.x should also build, be it an optional Sage package for boot-strapping.\n> > \n\n> Well, there are people that do care about OS X 10.4.\n\nI've also wasted enough time with trying to find out what's going wrong on some MacOS... ;-)\n\n\n> Since (at least) Sage-3.4 till the current Sage-4.6.alpha2, this is an officially supported platform with the regular binary distributions.\n\n\nTime goes by...; I think five years of \"active\" support are more than one can expect today, and there's no such machine on the build farm, so it is no longer an \"officially supported\" platform according to what was written on sage-devel.\n\n> OTOH, the inclusion of bash as a Sage dependency has been discussed before. (Mainly due to the problems if the system bash is built to use readline as dynamic librariy, and blows up if the readline lib provided by Sage is older, but is found first in the library search path due to the Sage specific LD_LIBRARY_PATH settings, as e.g. in Arch Linux and younger SuSE distributions.)\n> But the conclusion was always that we don't want to have bash as a core dependency to be shipped with Sage (be it only for a few OSes).\n\n\nMaking a *specific (minimal) version* mandatory (rather than just requiring Bash, which is the case anyway, i.e. it *is* already a prerequisite) doesn't mean we should ship it with every release. There are other things that could (and IMHO should) be made available differently, like the odd Fortran binaries that are totally useless to everyone not using MacOS X.\n\nSo I would for convenience perhaps offer a Bash 3.x or 4.x for MacOS X [10.4], but separate from Sage distributions. I'm pretty sure such packages are already available elsewhere though.\n\nBtw, I don't think a newer `bash` is required in a binary Sage distribution for ordinary use. So just having a newer `bash` on the build system might be sufficient for many people.",
    "created_at": "2010-11-26T19:49:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99002",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:10'></a>
Replying to [GeorgSWeber](#comment%3A9):
> Replying to [leif](#comment%3A8):
> > Replying to [jdemeyer](#comment%3A6):
> > > Replying to [leif](#comment%3A1):
> > > > IMHO Bash 3.0 is old enough to make it a prerequisite anyway.

> > > 
> > > -1 to this idea, since OS X 10.4 has bash version 2.

> > 
> > I don't care about it since it is dead old and only causes problems. If someone is able to build Sage on MacOS X 10.4, Bash 3.x or 4.x should also build, be it an optional Sage package for boot-strapping.
> > 

> Well, there are people that do care about OS X 10.4.

I've also wasted enough time with trying to find out what's going wrong on some MacOS... ;-)


> Since (at least) Sage-3.4 till the current Sage-4.6.alpha2, this is an officially supported platform with the regular binary distributions.


Time goes by...; I think five years of "active" support are more than one can expect today, and there's no such machine on the build farm, so it is no longer an "officially supported" platform according to what was written on sage-devel.

> OTOH, the inclusion of bash as a Sage dependency has been discussed before. (Mainly due to the problems if the system bash is built to use readline as dynamic librariy, and blows up if the readline lib provided by Sage is older, but is found first in the library search path due to the Sage specific LD_LIBRARY_PATH settings, as e.g. in Arch Linux and younger SuSE distributions.)
> But the conclusion was always that we don't want to have bash as a core dependency to be shipped with Sage (be it only for a few OSes).


Making a *specific (minimal) version* mandatory (rather than just requiring Bash, which is the case anyway, i.e. it *is* already a prerequisite) doesn't mean we should ship it with every release. There are other things that could (and IMHO should) be made available differently, like the odd Fortran binaries that are totally useless to everyone not using MacOS X.

So I would for convenience perhaps offer a Bash 3.x or 4.x for MacOS X [10.4], but separate from Sage distributions. I'm pretty sure such packages are already available elsewhere though.

Btw, I don't think a newer `bash` is required in a binary Sage distribution for ordinary use. So just having a newer `bash` on the build system might be sufficient for many people.



---

archive/issue_comments_099003.json:
```json
{
    "body": "<a id='comment:11'></a>\nHow did a discussion of pipestatus turn in a discussion about a bash spkg?  The point is, it is easy to implement something like pipestatus on OS X 10.4 *without* a bash spkg, so what's the problem?\n\nIf one day there is truly a big problem on OS X 10.4, then we might consider dropping support.  But as long as we can make Sage run on OS X 10.4 without too much effort, I think we should try supporting it.",
    "created_at": "2010-11-26T19:57:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99003",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:11'></a>
How did a discussion of pipestatus turn in a discussion about a bash spkg?  The point is, it is easy to implement something like pipestatus on OS X 10.4 *without* a bash spkg, so what's the problem?

If one day there is truly a big problem on OS X 10.4, then we might consider dropping support.  But as long as we can make Sage run on OS X 10.4 without too much effort, I think we should try supporting it.



---

archive/issue_comments_099004.json:
```json
{
    "body": "<a id='comment:12'></a>\nReplying to [jdemeyer](#comment%3A11):\n> How did a discussion of pipestatus turn in a discussion about a bash spkg?\n\n\nThat's actually a continued discussion...\n\n> The point is, it is easy to implement something like pipestatus on OS X 10.4 *without* a bash spkg, so what's the problem?\n\n\nGo ahead. (If it doesn't make worse what we currently have, which is really suboptimal).\n\nBut it's obviously the most easiest thing to simply use a useful feature of a shell we already require anyway.\n\nI'd say define a variable name (e.g. `PIPE_STATUS`) for what makes up `pipestatus` and then let `$PIPE_STATUS cmd1 cmd2` either call a Bash-3.0 function (using the `pipefail` shell option) or call a `pipestatus` script, from which we can remove the first case. Of course the second implementation could also be made into a shell function, though more complex.\n\nAs mentioned elsewhere, I would also move the logging (`tee`s) from `deps` to `sage-spkg`, which simplifies things.",
    "created_at": "2010-11-26T20:26:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99004",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:12'></a>
Replying to [jdemeyer](#comment%3A11):
> How did a discussion of pipestatus turn in a discussion about a bash spkg?


That's actually a continued discussion...

> The point is, it is easy to implement something like pipestatus on OS X 10.4 *without* a bash spkg, so what's the problem?


Go ahead. (If it doesn't make worse what we currently have, which is really suboptimal).

But it's obviously the most easiest thing to simply use a useful feature of a shell we already require anyway.

I'd say define a variable name (e.g. `PIPE_STATUS`) for what makes up `pipestatus` and then let `$PIPE_STATUS cmd1 cmd2` either call a Bash-3.0 function (using the `pipefail` shell option) or call a `pipestatus` script, from which we can remove the first case. Of course the second implementation could also be made into a shell function, though more complex.

As mentioned elsewhere, I would also move the logging (`tee`s) from `deps` to `sage-spkg`, which simplifies things.



---

archive/issue_comments_099005.json:
```json
{
    "body": "<a id='comment:13'></a>\nReplying to [leif](#comment%3A12):\n> As mentioned elsewhere, I would also move the logging (`tee`s) from `deps` to `sage-spkg`, which simplifies things.\n\n\nWell, pipestatus is also used for `make doc-html`, so I would leave it as a shell script where it is.",
    "created_at": "2010-11-26T21:27:17Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99005",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:13'></a>
Replying to [leif](#comment%3A12):
> As mentioned elsewhere, I would also move the logging (`tee`s) from `deps` to `sage-spkg`, which simplifies things.


Well, pipestatus is also used for `make doc-html`, so I would leave it as a shell script where it is.



---

archive/issue_comments_099006.json:
```json
{
    "body": "<a id='comment:14'></a>\nReplying to [leif](#comment%3A8):\n> Replying to [jdemeyer](#comment%3A6):\n> > Replying to [leif](#comment%3A1):\n> > > IMHO Bash 3.0 is old enough to make it a prerequisite anyway.\n\n> > \n> > -1 to this idea, since OS X 10.4 has bash version 2.\n\n> \n> I don't care about it since it is dead old and only causes problems. If someone is able to build Sage on MacOS X 10.4, Bash 3.x or 4.x should also build, be it an optional Sage package for boot-strapping.\n\n\nThere are several people building on 10.4 (tiger). It is not as dead as you believe. OS X 10.5 (Leopard) was not released until October 2007. Making life hard for people with computers just over 3 years old is not in my opinion very good. Unlike Linux & Solaris, operating system upgrades are not free for OS X. \n\nThe first release of Solaris 10 (03/2005) slightly predates OS X 10.4 (April 2005), yet comes with bash 3.00.16(1). \n \n> > The question I posed in the ticket remains: why should there be two cases (the second case should work always, no matter the bash version).\n\n\nIMHO, if we relied less on bashims, and sought advice from places like the autoconf mailing list, or comp.unix.shell, we would do a lot better. Those places tend to have people know know how to write portable shell scripts. \n\nDave",
    "created_at": "2010-11-28T11:46:03Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99006",
    "user": "https://trac.sagemath.org/admin/accounts/users/drkirkby"
}
```

<a id='comment:14'></a>
Replying to [leif](#comment%3A8):
> Replying to [jdemeyer](#comment%3A6):
> > Replying to [leif](#comment%3A1):
> > > IMHO Bash 3.0 is old enough to make it a prerequisite anyway.

> > 
> > -1 to this idea, since OS X 10.4 has bash version 2.

> 
> I don't care about it since it is dead old and only causes problems. If someone is able to build Sage on MacOS X 10.4, Bash 3.x or 4.x should also build, be it an optional Sage package for boot-strapping.


There are several people building on 10.4 (tiger). It is not as dead as you believe. OS X 10.5 (Leopard) was not released until October 2007. Making life hard for people with computers just over 3 years old is not in my opinion very good. Unlike Linux & Solaris, operating system upgrades are not free for OS X. 

The first release of Solaris 10 (03/2005) slightly predates OS X 10.4 (April 2005), yet comes with bash 3.00.16(1). 
 
> > The question I posed in the ticket remains: why should there be two cases (the second case should work always, no matter the bash version).


IMHO, if we relied less on bashims, and sought advice from places like the autoconf mailing list, or comp.unix.shell, we would do a lot better. Those places tend to have people know know how to write portable shell scripts. 

Dave



---

archive/attachments_013536.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "10339_pipestatus.patch",
    "asset_url": "tarball://root/attachments/some-uuid/ticket10339/10339_pipestatus.patch",
    "created_at": "2010-11-28T14:15:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "attachment",
    "url": "https://github.com/assets/some-id/some-uuid.patch",
    "user": "https://github.com/jdemeyer"
}
```



---

archive/issue_comments_099007.json:
```json
{
    "body": "non-hg patch for SAGE_ROOT",
    "created_at": "2010-11-28T14:15:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99007",
    "user": "https://github.com/jdemeyer"
}
```

non-hg patch for SAGE_ROOT



---

archive/issue_events_079076.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-11-28T18:45:50Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79076"
}
```



---

archive/issue_comments_099008.json:
```json
{
    "body": "**Author:** Jeroen Demeyer",
    "created_at": "2010-11-28T18:45:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99008",
    "user": "https://github.com/jdemeyer"
}
```

**Author:** Jeroen Demeyer



---

archive/issue_comments_099009.json:
```json
{
    "body": "<a id='comment:16'></a>\nDo we really want to run \"cmd1\" in a different subshell?\n\n---\n\nIf we change (the meaning of) `spkg/pipestatus`, we should perhaps also change its (potential) generation in `spkg/install`.",
    "created_at": "2010-11-29T16:03:50Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99009",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:16'></a>
Do we really want to run "cmd1" in a different subshell?

---

If we change (the meaning of) `spkg/pipestatus`, we should perhaps also change its (potential) generation in `spkg/install`.



---

archive/issue_comments_099010.json:
```json
{
    "body": "<a id='comment:17'></a>\nReplying to [leif](#comment%3A16):\n> Do we really want to run \"cmd1\" in a different subshell?\n\nWhy not?  It seems to work fine on various systems that I tested.\n\n> If we change (the meaning of) `spkg/pipestatus`, we should perhaps also change its (potential) generation in `spkg/install`.\n\nI don't see the need for this, what would you propose?",
    "created_at": "2010-11-29T20:15:24Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99010",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:17'></a>
Replying to [leif](#comment%3A16):
> Do we really want to run "cmd1" in a different subshell?

Why not?  It seems to work fine on various systems that I tested.

> If we change (the meaning of) `spkg/pipestatus`, we should perhaps also change its (potential) generation in `spkg/install`.

I don't see the need for this, what would you propose?



---

archive/issue_comments_099011.json:
```json
{
    "body": "<a id='comment:18'></a>\nI admit I don't feel comfortable reviewing this. Let me have a go and see what I think. \n\nBut I am against making bash 3.0 a perquisite. If this can be done without working around different bash versions, then lets do so. \n\nI found this. \n\nhttp://cfajohnson.com/shell/cus-faq-2.html#Q11\n\nDave",
    "created_at": "2010-12-02T14:21:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99011",
    "user": "https://trac.sagemath.org/admin/accounts/users/drkirkby"
}
```

<a id='comment:18'></a>
I admit I don't feel comfortable reviewing this. Let me have a go and see what I think. 

But I am against making bash 3.0 a perquisite. If this can be done without working around different bash versions, then lets do so. 

I found this. 

http://cfajohnson.com/shell/cus-faq-2.html#Q11

Dave



---

archive/issue_comments_099012.json:
```json
{
    "body": "<a id='comment:19'></a>\nAs a compromise, I'd suggest using simply Bash's `PIPESTATUS` array, which is available in by far older versions as well, e.g.\n\n```sh\n    ...\n    # e.g. eval \"$1 | $2\"\n    # or   eval \"$1\" | eval \"$2\"\n\n    if [ ${PIPESTATUS[0]} -ne 0 ]; then\n        exit ${PIPESTATUS[0]}\n    else\n        exit ${PIPESTATUS[1]} # equivalent to exit $? (if 'pipefail' is not set)\n    fi\n\n    # NOTREACHED\n```\n\nAs you can see, the `else` part is completely redundant, since a script does `exit $?` by default.",
    "created_at": "2010-12-02T16:21:21Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99012",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:19'></a>
As a compromise, I'd suggest using simply Bash's `PIPESTATUS` array, which is available in by far older versions as well, e.g.

```sh
    ...
    # e.g. eval "$1 | $2"
    # or   eval "$1" | eval "$2"

    if [ ${PIPESTATUS[0]} -ne 0 ]; then
        exit ${PIPESTATUS[0]}
    else
        exit ${PIPESTATUS[1]} # equivalent to exit $? (if 'pipefail' is not set)
    fi

    # NOTREACHED
```

As you can see, the `else` part is completely redundant, since a script does `exit $?` by default.



---

archive/issue_comments_099013.json:
```json
{
    "body": "<a id='comment:20'></a>\nIf you want compatibility with `pipefail`, you should exchange 0 and 1 in your patch.\n\nI would do eval \"$1\" | eval \"$2\" which I think is more logical than eval \"$1 | $2\".",
    "created_at": "2010-12-02T17:05:01Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99013",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:20'></a>
If you want compatibility with `pipefail`, you should exchange 0 and 1 in your patch.

I would do eval "$1" | eval "$2" which I think is more logical than eval "$1 | $2".



---

archive/issue_events_079077.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-02T17:05:01Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79077"
}
```



---

archive/issue_events_079078.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-02T17:05:01Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79078"
}
```



---

archive/issue_comments_099014.json:
```json
{
    "body": "<a id='comment:21'></a>\nReplying to [jdemeyer](#comment%3A20):\n> If you want compatibility with `pipefail`, you should exchange 0 and 1 in your patch.\n\n\nNo, that would return 0 if cmd1 fails but not cmd2. So we could do:\n\n```sh\n#!/usr/bin/env bash\n\n    ...\n    if [ ${PIPESTATUS[0]} -ne 0 ]; then\n        if [ ${PIPESTATUS[1]} -ne 0 ]; then\n            exit ${PIPESTATUS[1]}\n        else\n            exit ${PIPESTATUS[0]}\n        fi\n    fi\n\n    # else returns $?, which is ${PIPESTATUS[1]}\n\n```\n\nOk, swapping all 0's and 1's in the previous example (but only **with** the `else` part) also works.\n\n\n> I would do eval \"$1\" | eval \"$2\" which I think is more logical than eval \"$1 | $2\".\n\n\nIs it?",
    "created_at": "2010-12-02T17:22:28Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99014",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:21'></a>
Replying to [jdemeyer](#comment%3A20):
> If you want compatibility with `pipefail`, you should exchange 0 and 1 in your patch.


No, that would return 0 if cmd1 fails but not cmd2. So we could do:

```sh
#!/usr/bin/env bash

    ...
    if [ ${PIPESTATUS[0]} -ne 0 ]; then
        if [ ${PIPESTATUS[1]} -ne 0 ]; then
            exit ${PIPESTATUS[1]}
        else
            exit ${PIPESTATUS[0]}
        fi
    fi

    # else returns $?, which is ${PIPESTATUS[1]}

```

Ok, swapping all 0's and 1's in the previous example (but only **with** the `else` part) also works.


> I would do eval "$1" | eval "$2" which I think is more logical than eval "$1 | $2".


Is it?



---

archive/issue_events_079079.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-04T14:43:53Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs info",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79079"
}
```



---

archive/issue_events_079080.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-04T14:43:53Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79080"
}
```



---

archive/issue_comments_099015.json:
```json
{
    "body": "<a id='comment:22'></a>\nLeif: what do you think of this alternative patch?  I've tested that it behaves the same as `set -o pipefail`.",
    "created_at": "2010-12-04T14:43:53Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99015",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:22'></a>
Leif: what do you think of this alternative patch?  I've tested that it behaves the same as `set -o pipefail`.



---

archive/issue_comments_099016.json:
```json
{
    "body": "<a id='comment:23'></a>\nReplying to [jdemeyer](#comment%3A22):\n> Leif: what do you think of this alternative patch?  I've tested that it behaves the same as `set -o pipefail`.\n\n\nBetter. :)\n\nUsing `eval` twice still behaves different to what you get directly on the command line; we could instead use:\n\n```sh\neval \"$1 | $2 ; ecs=(\\${PIPESTATUS[*]})\"\n\nif [ ${ecs[1]} -ne 0 ]; then\n    exit ${ecs[1]}\nelse\n    exit ${ecs[0]}\nfi\n```\n\nThe comment *\"Like this, ...\"* is a bit misleading, as we exactly fix that undesired behavior with `pipestatus`.",
    "created_at": "2010-12-04T20:08:25Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99016",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:23'></a>
Replying to [jdemeyer](#comment%3A22):
> Leif: what do you think of this alternative patch?  I've tested that it behaves the same as `set -o pipefail`.


Better. :)

Using `eval` twice still behaves different to what you get directly on the command line; we could instead use:

```sh
eval "$1 | $2 ; ecs=(\${PIPESTATUS[*]})"

if [ ${ecs[1]} -ne 0 ]; then
    exit ${ecs[1]}
else
    exit ${ecs[0]}
fi
```

The comment *"Like this, ..."* is a bit misleading, as we exactly fix that undesired behavior with `pipestatus`.



---

archive/issue_comments_099017.json:
```json
{
    "body": "<a id='comment:24'></a>\nReplying to [leif](#comment%3A23):\n> Using `eval` twice still behaves different to what you get directly on the command line; we could instead use:\n\n\nI disagree.  Personally, I wouldn't expect `pipestatus` to behave in a way that the first argument influences the second.  For me, the command line arguments to `pipestatus` are like \"blocks\" and should not be split.  In other words, I expect\n\n```\npipestatus \"A && B\" \"C\"\n```\nto behave like\n\n```\n(A && B) | (C)\n```",
    "created_at": "2010-12-04T20:55:15Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99017",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:24'></a>
Replying to [leif](#comment%3A23):
> Using `eval` twice still behaves different to what you get directly on the command line; we could instead use:


I disagree.  Personally, I wouldn't expect `pipestatus` to behave in a way that the first argument influences the second.  For me, the command line arguments to `pipestatus` are like "blocks" and should not be split.  In other words, I expect

```
pipestatus "A && B" "C"
```
to behave like

```
(A && B) | (C)
```



---

archive/issue_comments_099018.json:
```json
{
    "body": "Alternative patch, based on Leif's proposal",
    "created_at": "2010-12-04T20:57:27Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99018",
    "user": "https://github.com/jdemeyer"
}
```

Alternative patch, based on Leif's proposal



---

archive/issue_comments_099019.json:
```json
{
    "body": "**Reviewer:** Leif Leonhardy",
    "created_at": "2010-12-04T21:00:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99019",
    "user": "https://github.com/jdemeyer"
}
```

**Reviewer:** Leif Leonhardy



---

archive/attachments_013537.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "10339_pipestatus.v2.patch",
    "asset_url": "tarball://root/attachments/some-uuid/ticket10339/10339_pipestatus.v2.patch",
    "created_at": "2010-12-04T21:00:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "attachment",
    "url": "https://github.com/assets/some-id/some-uuid.patch",
    "user": "https://github.com/jdemeyer"
}
```



---

archive/issue_comments_099020.json:
```json
{
    "body": "<a id='comment:25'></a>\nReplying to [leif](#comment%3A23):\n> The comment *\"Like this, ...\"* is a bit misleading, as we exactly fix that undesired behavior with `pipestatus`.\n\n\nTrue.  I have updated the comment.",
    "created_at": "2010-12-04T21:00:52Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99020",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:25'></a>
Replying to [leif](#comment%3A23):
> The comment *"Like this, ..."* is a bit misleading, as we exactly fix that undesired behavior with `pipestatus`.


True.  I have updated the comment.



---

archive/issue_comments_099021.json:
```json
{
    "body": "<a id='comment:26'></a>\nReplying to [leif](#comment%3A23):\n> Using `eval` twice still behaves different to what you get directly on the command line\n\n\nConsider the following Python analogy:\n\n```\ndef multiply(a,b):\n    return a*b\n```\n\nYou would not expect `multiply(x+y,z)` to behave like `x+y*z` but you expect it to behave like `(x+y)*z`.",
    "created_at": "2010-12-04T21:04:39Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99021",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:26'></a>
Replying to [leif](#comment%3A23):
> Using `eval` twice still behaves different to what you get directly on the command line


Consider the following Python analogy:

```
def multiply(a,b):
    return a*b
```

You would not expect `multiply(x+y,z)` to behave like `x+y*z` but you expect it to behave like `(x+y)*z`.



---

archive/issue_comments_099022.json:
```json
{
    "body": "<a id='comment:27'></a>\nReplying to [jdemeyer](#comment%3A24):\n> Replying to [leif](#comment%3A23):\n> > Using `eval` twice still behaves different to what you get directly on the command line; we could instead use:\n\n> \n> I disagree.\n\n\nWell, certainly not on what one gets directly at the shell prompt.\n\n> Personally, I wouldn't expect `pipestatus` to behave in a way that the first argument influences the second.  For me, the command line arguments to `pipestatus` are like \"blocks\" and should not be split.  In other words, I expect\n\n\n```\n pipestatus \"A && B\" \"C\"\n```\n> to behave like\n\n\n```\n (A && B) | (C)\n```\n\nAnd I would expect `pipestatus cmd1 cmd2` to behave as what it is intended to replace (for the only reason that the direct syntax isn't supported by dead old bashs on user-friendly OSs):\n\n```\n$ set -o pipefail; cmd 1 | cmd2\n```\n\nWe here have simple textual substitution (or term rewriting like in macros):\n\n```\n    pipestatus = lambda cmd1. cmd2: cmd1 | cmd2\n```\n\nThat's not eager evaluation / call by value, like (analogously) <code>pipestatus \\`eval cmd1\\` \\`eval cmd2\\`</code>, or what one would expect from true functions. Of course I would\n\n```C\n#define mul(a,b)  ((a)*(b))  /* and not (a*b), which might give contra-intuitive results */\n```\nbut that's a different story (and you certainly know the pitfalls when passing things like `n++` to macros rather than [inline] functions).\n\nIn a shell, with a `|` operator, I would expect exactly what the shell (and especially `make`, in our application domain) usually does, namely simple text substitution (and concatenation without bracketing), for perhaps later evaluation. If I want or need parentheses here, I pass them.\n\nAnd as a side-effect, we get `bash` into the `make` receipt. Rather than writing\n\n```make\ntarget: prereq\n        bash -c \"cmd1\" ; pipestatus \"cmd2\" \"cmd3\" ; bash -c \"cmd4\"\n```\nwe can simply do\n\n```make\ntarget: prereq\n        pipestatus \"cmd1 ; cmd2\" \"cmd3 ; cmd4\"\n```\nwith the advantage of having the ability to e.g, set environment variables in the first command that take effect in the latter.\n\nOk, you could also write\n\n```make\ntarget: prereq\n        bash -c \"cmd1 ; pipestatus cmd2 cmd3 ; cmd4\"\n```\nbut then you again get into trouble with quoting.",
    "created_at": "2010-12-04T22:39:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99022",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:27'></a>
Replying to [jdemeyer](#comment%3A24):
> Replying to [leif](#comment%3A23):
> > Using `eval` twice still behaves different to what you get directly on the command line; we could instead use:

> 
> I disagree.


Well, certainly not on what one gets directly at the shell prompt.

> Personally, I wouldn't expect `pipestatus` to behave in a way that the first argument influences the second.  For me, the command line arguments to `pipestatus` are like "blocks" and should not be split.  In other words, I expect


```
 pipestatus "A && B" "C"
```
> to behave like


```
 (A && B) | (C)
```

And I would expect `pipestatus cmd1 cmd2` to behave as what it is intended to replace (for the only reason that the direct syntax isn't supported by dead old bashs on user-friendly OSs):

```
$ set -o pipefail; cmd 1 | cmd2
```

We here have simple textual substitution (or term rewriting like in macros):

```
    pipestatus = lambda cmd1. cmd2: cmd1 | cmd2
```

That's not eager evaluation / call by value, like (analogously) <code>pipestatus \`eval cmd1\` \`eval cmd2\`</code>, or what one would expect from true functions. Of course I would

```C
#define mul(a,b)  ((a)*(b))  /* and not (a*b), which might give contra-intuitive results */
```
but that's a different story (and you certainly know the pitfalls when passing things like `n++` to macros rather than [inline] functions).

In a shell, with a `|` operator, I would expect exactly what the shell (and especially `make`, in our application domain) usually does, namely simple text substitution (and concatenation without bracketing), for perhaps later evaluation. If I want or need parentheses here, I pass them.

And as a side-effect, we get `bash` into the `make` receipt. Rather than writing

```make
target: prereq
        bash -c "cmd1" ; pipestatus "cmd2" "cmd3" ; bash -c "cmd4"
```
we can simply do

```make
target: prereq
        pipestatus "cmd1 ; cmd2" "cmd3 ; cmd4"
```
with the advantage of having the ability to e.g, set environment variables in the first command that take effect in the latter.

Ok, you could also write

```make
target: prereq
        bash -c "cmd1 ; pipestatus cmd2 cmd3 ; cmd4"
```
but then you again get into trouble with quoting.



---

archive/issue_comments_099023.json:
```json
{
    "body": "<a id='comment:28'></a>\nI guess we have to agree to disagree then.\n\nJust to be clear: are you refusing a positive_review because of this or can you live with my patch?",
    "created_at": "2010-12-04T23:16:57Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99023",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:28'></a>
I guess we have to agree to disagree then.

Just to be clear: are you refusing a positive_review because of this or can you live with my patch?



---

archive/issue_comments_099024.json:
```json
{
    "body": "<a id='comment:29'></a>\nReplying to [jdemeyer](#comment%3A28):\n> I guess we have to agree to disagree then.\n\n\n\n```sh\n...\nif [ $# -eq 3 -a -n \"$2\" -a -n \"$3\" ]; then\n    case \"$1\" in\n        -j|--jeroen|--contra-intuitively)\n             eval \"$2\" | eval \"$3\" ; pipestatus=(${PIPESTATUS[*]})\n             ;;\n        -l|--leif|--as-expected|--as-previously-with-current-bashs)\n             eval \"$2 | $3 ; pipestatus=(\\${PIPESTATUS[*]})\"\n             ;;\n         *)\n             usage\n    esac\n    if [ ${pipestatus[1]} -ne 0 ]; then \n \texit ${pipestatus[1]}\n    else\n        exit ${pipestatus[0]}\n    fi\nelse\n    usage\nfi # semper\n\n# NOTREACHED\n```\n\n> Just to be clear: are you refusing a positive_review because of this or can you live with my patch?\n\n\nYou refuse to get convinced...\n\nHonestly, I reluctantly gave *a lot* of positive reviews to IMHO bad (to be fair, some of them worse) things recently, like keeping useless baggage in spkgs or leaving definitely *wrong* code like `unset MAKEFLAGS` in because others feared to make changes, in fact corrections, or like introducing new superfluous behavior regarding `SAGE64` (which should be called `SAGE_FORCE_64_BIT_BUILD`, to restate it once more) etc., at the same time having invested into tickets that then wouldn't get merged or again postponed, to next year.\n\nI'll leave the decision to someone else. It's certainly not such an important design decision, but why should I agree on something I still have a different opinion on?\n\nYou didn't give an answer to the other aspects I mentioned.",
    "created_at": "2010-12-05T00:42:00Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99024",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:29'></a>
Replying to [jdemeyer](#comment%3A28):
> I guess we have to agree to disagree then.



```sh
...
if [ $# -eq 3 -a -n "$2" -a -n "$3" ]; then
    case "$1" in
        -j|--jeroen|--contra-intuitively)
             eval "$2" | eval "$3" ; pipestatus=(${PIPESTATUS[*]})
             ;;
        -l|--leif|--as-expected|--as-previously-with-current-bashs)
             eval "$2 | $3 ; pipestatus=(\${PIPESTATUS[*]})"
             ;;
         *)
             usage
    esac
    if [ ${pipestatus[1]} -ne 0 ]; then 
 	exit ${pipestatus[1]}
    else
        exit ${pipestatus[0]}
    fi
else
    usage
fi # semper

# NOTREACHED
```

> Just to be clear: are you refusing a positive_review because of this or can you live with my patch?


You refuse to get convinced...

Honestly, I reluctantly gave *a lot* of positive reviews to IMHO bad (to be fair, some of them worse) things recently, like keeping useless baggage in spkgs or leaving definitely *wrong* code like `unset MAKEFLAGS` in because others feared to make changes, in fact corrections, or like introducing new superfluous behavior regarding `SAGE64` (which should be called `SAGE_FORCE_64_BIT_BUILD`, to restate it once more) etc., at the same time having invested into tickets that then wouldn't get merged or again postponed, to next year.

I'll leave the decision to someone else. It's certainly not such an important design decision, but why should I agree on something I still have a different opinion on?

You didn't give an answer to the other aspects I mentioned.



---

archive/issue_comments_099025.json:
```json
{
    "body": "<a id='comment:30'></a>\nReplying to [leif](#comment%3A29):\n> You didn't give an answer to the other aspects I mentioned.\n\n\nYou mean this?:\n\nReplying to [leif](#comment%3A27):\n> And as a side-effect, we get `bash` into the `make` receipt. Rather than writing\n> \n> ```make\n> target: prereq\n>         bash -c \"cmd1\" ; pipestatus \"cmd2\" \"cmd3\" ; bash -c \"cmd4\"\n> ```\n> we can simply do\n> \n> ```make\n> target: prereq\n>         pipestatus \"cmd1 ; cmd2\" \"cmd3 ; cmd4\"\n> ```\n> with the advantage of having the ability to e.g, set environment variables in the first command that take effect in the latter.\n\n\nI don't think that's relevant.  If you really need specific `bash` code in your `Makefile`, you better just write a separate shell script.",
    "created_at": "2010-12-05T09:22:46Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99025",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:30'></a>
Replying to [leif](#comment%3A29):
> You didn't give an answer to the other aspects I mentioned.


You mean this?:

Replying to [leif](#comment%3A27):
> And as a side-effect, we get `bash` into the `make` receipt. Rather than writing
> 
> ```make
> target: prereq
>         bash -c "cmd1" ; pipestatus "cmd2" "cmd3" ; bash -c "cmd4"
> ```
> we can simply do
> 
> ```make
> target: prereq
>         pipestatus "cmd1 ; cmd2" "cmd3 ; cmd4"
> ```
> with the advantage of having the ability to e.g, set environment variables in the first command that take effect in the latter.


I don't think that's relevant.  If you really need specific `bash` code in your `Makefile`, you better just write a separate shell script.



---

archive/issue_events_079081.json:
```json
{
    "actor": "https://github.com/jhpalmieri",
    "created_at": "2010-12-06T04:45:36Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79081"
}
```



---

archive/issue_events_079082.json:
```json
{
    "actor": "https://github.com/jhpalmieri",
    "created_at": "2010-12-06T04:45:36Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79082"
}
```



---

archive/issue_comments_099026.json:
```json
{
    "body": "<a id='comment:31'></a>\nI don't really care which version eventually gets used, but especially since this issue is being debated here, it's crucial that the behavior of pipestatus with regard to a command like `pipestatus \"A && B\" \"C\"` be documented, say in the message at the beginning of that file or in the comments following that, or both.\n\n```\nif [ $# -ne 2 ] || [ -z \"$1\" -o -z \"$2\" ]; then \n    echo >&2 \"Usage: $0 CMD1 CMD2\" \n    echo >&2 \"Run two commands in a pipeline 'CMD1 | CMD2' and exit\" \n    echo >&2 \"with the exit status of CMD1, *not* that of CMD2.\" \n    echo >&2 \"MAYBE ADD SOMETHING HELPFUL HERE\"\n    exit 2 \n```\nOr here:\n\n```\n# Run two commands in a pipeline and exit with the exit status of the \n# first command, not the second.\n# This is useful, for example, in a makefile, where we tee the output\n# ....\n# Note that if you run \n#     pipestatus \"A && B\" \"C\"\n# then ...\n```",
    "created_at": "2010-12-06T04:45:36Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99026",
    "user": "https://github.com/jhpalmieri"
}
```

<a id='comment:31'></a>
I don't really care which version eventually gets used, but especially since this issue is being debated here, it's crucial that the behavior of pipestatus with regard to a command like `pipestatus "A && B" "C"` be documented, say in the message at the beginning of that file or in the comments following that, or both.

```
if [ $# -ne 2 ] || [ -z "$1" -o -z "$2" ]; then 
    echo >&2 "Usage: $0 CMD1 CMD2" 
    echo >&2 "Run two commands in a pipeline 'CMD1 | CMD2' and exit" 
    echo >&2 "with the exit status of CMD1, *not* that of CMD2." 
    echo >&2 "MAYBE ADD SOMETHING HELPFUL HERE"
    exit 2 
```
Or here:

```
# Run two commands in a pipeline and exit with the exit status of the 
# first command, not the second.
# This is useful, for example, in a makefile, where we tee the output
# ....
# Note that if you run 
#     pipestatus "A && B" "C"
# then ...
```



---

archive/issue_comments_099027.json:
```json
{
    "body": "<a id='comment:32'></a>\nReplying to [jhpalmieri](#comment%3A31):\n> I don't really care which version eventually gets used, but especially since this issue is being debated here, it's crucial that the behavior of pipestatus with regard to a command like `pipestatus \"A && B\" \"C\"` be documented, say in the message at the beginning of that file or in the comments following that, or both.\n\n\nWell, my approach follows the principle of least astonishment in that it lets `pipestatus` behave as if you issued \"`cmd1 | cmd2`\" at the shell prompt (with `pipefail` set), where `cmd1` and `cmd2` are meta variables (non-terminals) for arbitrary valid shell commands, sequences of commands etc. included. ;-)\n\nThat's easy to document.\n\n(I think a comment in the file is sufficient, as `pipestatus` is not intended to be called directly by a user. A developer if in doubt would perhaps look at the file rather than trying to call it. The usage message should of course mention that `pipestatus` exits with the **last** non-zero exit code or zero if the resulting whole statement is a pipeline, i.e. resembles the behavior when Bash's `pipefail` option is set.)",
    "created_at": "2010-12-06T07:22:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99027",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:32'></a>
Replying to [jhpalmieri](#comment%3A31):
> I don't really care which version eventually gets used, but especially since this issue is being debated here, it's crucial that the behavior of pipestatus with regard to a command like `pipestatus "A && B" "C"` be documented, say in the message at the beginning of that file or in the comments following that, or both.


Well, my approach follows the principle of least astonishment in that it lets `pipestatus` behave as if you issued "`cmd1 | cmd2`" at the shell prompt (with `pipefail` set), where `cmd1` and `cmd2` are meta variables (non-terminals) for arbitrary valid shell commands, sequences of commands etc. included. ;-)

That's easy to document.

(I think a comment in the file is sufficient, as `pipestatus` is not intended to be called directly by a user. A developer if in doubt would perhaps look at the file rather than trying to call it. The usage message should of course mention that `pipestatus` exits with the **last** non-zero exit code or zero if the resulting whole statement is a pipeline, i.e. resembles the behavior when Bash's `pipefail` option is set.)



---

archive/issue_comments_099028.json:
```json
{
    "body": "<a id='comment:33'></a>\nP.S.:\n\nWhile with my approach one can force the behavoir Jeroen expects (by using parentheses), the opposite is impossible. On the other hand, one *could* of course also do something like\n\n```sh\n$ A && pipestatus \"B\" \"C\" \n```\nto get the behavior of\n\n```sh\n$ A && B | C  # same as  pipestatus \"A && B\" \"C\"  with my version\n```\nwith Jeroen's version, but that's IMHO odd, at least in Makefiles where we mainly use it (and `A` there would potentially be executed by a *different* shell than the parameters to `pipestatus`, `B` and `C`).\n\nThe name of the script (and the current \"syntax description\") suggests not to use other things than simple commands for each of the two parameters anyway I think.",
    "created_at": "2010-12-06T07:53:47Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99028",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:33'></a>
P.S.:

While with my approach one can force the behavoir Jeroen expects (by using parentheses), the opposite is impossible. On the other hand, one *could* of course also do something like

```sh
$ A && pipestatus "B" "C" 
```
to get the behavior of

```sh
$ A && B | C  # same as  pipestatus "A && B" "C"  with my version
```
with Jeroen's version, but that's IMHO odd, at least in Makefiles where we mainly use it (and `A` there would potentially be executed by a *different* shell than the parameters to `pipestatus`, `B` and `C`).

The name of the script (and the current "syntax description") suggests not to use other things than simple commands for each of the two parameters anyway I think.



---

archive/issue_comments_099029.json:
```json
{
    "body": "<a id='comment:34'></a>\nReplying to [leif](#comment%3A33):\n> [...] but that's IMHO odd, at least in Makefiles where we mainly use it (and `A` there would potentially be executed by a *different* shell than the parameters to `pipestatus`, `B` and `C`).\n\n\nNote that we would **not** log the output of command `A` in a `make` rule like\n\n```make\ntarget: prereq\n        A && pipestatus \"B\" \"tee -a logfile\"\n```",
    "created_at": "2010-12-06T08:01:30Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99029",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:34'></a>
Replying to [leif](#comment%3A33):
> [...] but that's IMHO odd, at least in Makefiles where we mainly use it (and `A` there would potentially be executed by a *different* shell than the parameters to `pipestatus`, `B` and `C`).


Note that we would **not** log the output of command `A` in a `make` rule like

```make
target: prereq
        A && pipestatus "B" "tee -a logfile"
```



---

archive/issue_comments_099030.json:
```json
{
    "body": "<a id='comment:35'></a>\nReplying to [leif](#comment%3A34):\n> Note that we would **not** log the output of command `A` in a `make` rule like\n\n\n```make\n target: prereq\n         A && pipestatus \"B\" \"tee -a logfile\"\n```\n\nIn fact also not with my version of `pipestatus`, where one would instead use\n\n```make\ntarget: prereq\n        pipestatus \"(A && B)\" \"tee -a logfile\"\n```\n\n(If `A` is e.g. `cd spkg` there, we would also - as we currently do - use `tee -a ../logfile` there, because `A && B` is **explicitly** executed in a subshell.)",
    "created_at": "2010-12-06T08:09:05Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99030",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:35'></a>
Replying to [leif](#comment%3A34):
> Note that we would **not** log the output of command `A` in a `make` rule like


```make
 target: prereq
         A && pipestatus "B" "tee -a logfile"
```

In fact also not with my version of `pipestatus`, where one would instead use

```make
target: prereq
        pipestatus "(A && B)" "tee -a logfile"
```

(If `A` is e.g. `cd spkg` there, we would also - as we currently do - use `tee -a ../logfile` there, because `A && B` is **explicitly** executed in a subshell.)



---

archive/issue_comments_099031.json:
```json
{
    "body": "<a id='comment:36'></a>\nReplying to [leif](#comment%3A35):\n> (If `A` is e.g. `cd spkg` there, we would also - as we currently do - use `tee -a ../logfile` there, because `A && B` is **explicitly** executed in a subshell.)\n\n\nI mean we would **not** have to use `../logfile` **because** `cd spkg && B` is *explicitly* executed in a subshell, by using parentheses, i.e.\n `pipestatus \"(cd spkg && B)\" \"tee -a logfile\"`.\n\nHaven't had much sleep...",
    "created_at": "2010-12-06T08:15:41Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99031",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:36'></a>
Replying to [leif](#comment%3A35):
> (If `A` is e.g. `cd spkg` there, we would also - as we currently do - use `tee -a ../logfile` there, because `A && B` is **explicitly** executed in a subshell.)


I mean we would **not** have to use `../logfile` **because** `cd spkg && B` is *explicitly* executed in a subshell, by using parentheses, i.e.
 `pipestatus "(cd spkg && B)" "tee -a logfile"`.

Haven't had much sleep...



---

archive/issue_comments_099032.json:
```json
{
    "body": "<a id='comment:37'></a>\nReplying to [leif](#comment%3A36):\n> I mean we would **not** have to use `../logfile` **because** `cd spkg && B` is *explicitly* executed in a subshell, by using parentheses, i.e.\n>  `pipestatus \"(cd spkg && B)\" \"tee -a logfile\"`.\n\n\nDon't you think that simply being able to write\n\n```\npipestatus \"cd spkg && B\" \"tee -a logfile\"\n```\nis the most natural solution?  No subshells, no `../`",
    "created_at": "2010-12-06T08:18:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99032",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:37'></a>
Replying to [leif](#comment%3A36):
> I mean we would **not** have to use `../logfile` **because** `cd spkg && B` is *explicitly* executed in a subshell, by using parentheses, i.e.
>  `pipestatus "(cd spkg && B)" "tee -a logfile"`.


Don't you think that simply being able to write

```
pipestatus "cd spkg && B" "tee -a logfile"
```
is the most natural solution?  No subshells, no `../`



---

archive/issue_comments_099033.json:
```json
{
    "body": "<a id='comment:38'></a>\nFinally, perhaps we should simply rename the script and just let it do what we mainly need:\n\n```\ntee_output_of_commands <string of commands> <logfile>\n```\n(where `<logfile>` might also be `\"-a some_file\"`)\n\nand let it just do the equivalent of\n\n```\nset -o pipefail; ( <commands> ) | tee <logfile>\n```\n(where in the script `<commands>` would be `eval \"$1\"` and `<logfile>` would be `$2`, **without** quotes).",
    "created_at": "2010-12-06T08:51:19Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99033",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:38'></a>
Finally, perhaps we should simply rename the script and just let it do what we mainly need:

```
tee_output_of_commands <string of commands> <logfile>
```
(where `<logfile>` might also be `"-a some_file"`)

and let it just do the equivalent of

```
set -o pipefail; ( <commands> ) | tee <logfile>
```
(where in the script `<commands>` would be `eval "$1"` and `<logfile>` would be `$2`, **without** quotes).



---

archive/issue_comments_099034.json:
```json
{
    "body": "<a id='comment:39'></a>\nJeroen, (at least) in case we use your solution, we have to also change `spkg/install` where `pipestatus` is created if it doesn't already exist, for upgrades from older versions prior to 4.5.1.",
    "created_at": "2010-12-06T09:03:48Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99034",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:39'></a>
Jeroen, (at least) in case we use your solution, we have to also change `spkg/install` where `pipestatus` is created if it doesn't already exist, for upgrades from older versions prior to 4.5.1.



---

archive/issue_events_079083.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-18T16:38:57Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "component: build",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79083"
}
```



---

archive/issue_events_079084.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-18T16:38:57Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "component: scripts",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79084"
}
```



---

archive/issue_comments_099035.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -19,3 +19,4 @@\n EXITSTATUS=/tmp/pipestatus$$     # Obviously, we should use TMPDIR if set\n ( A; echo $? >$EXITSTATUS ) | B\n ```\n+1. Use `bash`'s `PIPESTATUS` array.\n``````\n",
    "created_at": "2010-12-19T09:50:51Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99035",
    "user": "https://github.com/jdemeyer"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -19,3 +19,4 @@
 EXITSTATUS=/tmp/pipestatus$$     # Obviously, we should use TMPDIR if set
 ( A; echo $? >$EXITSTATUS ) | B
 ```
+1. Use `bash`'s `PIPESTATUS` array.
``````




---

archive/attachments_013538.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "10339_pipestatus.v3.patch",
    "asset_url": "tarball://root/attachments/some-uuid/ticket10339/10339_pipestatus.v3.patch",
    "created_at": "2010-12-19T10:19:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "attachment",
    "url": "https://github.com/assets/some-id/some-uuid.patch",
    "user": "https://github.com/jdemeyer"
}
```



---

archive/issue_comments_099036.json:
```json
{
    "body": "Leif's alternative, apply to SAGE_ROOT",
    "created_at": "2010-12-19T10:19:16Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99036",
    "user": "https://github.com/jdemeyer"
}
```

Leif's alternative, apply to SAGE_ROOT



---

archive/attachments_013539.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "10339_pipestatus.v3_spkg_install.patch",
    "asset_url": "tarball://root/attachments/some-uuid/ticket10339/10339_pipestatus.v3_spkg_install.patch",
    "created_at": "2010-12-19T10:19:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "attachment",
    "url": "https://github.com/assets/some-id/some-uuid.patch",
    "user": "https://github.com/jdemeyer"
}
```



---

archive/issue_comments_099037.json:
```json
{
    "body": "Leif's alternative, patch for spkg/install",
    "created_at": "2010-12-19T10:19:56Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99037",
    "user": "https://github.com/jdemeyer"
}
```

Leif's alternative, patch for spkg/install



---

archive/issue_events_079085.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-19T10:22:43Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs work",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79085"
}
```



---

archive/issue_events_079086.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-19T10:22:43Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79086"
}
```



---

archive/issue_comments_099038.json:
```json
{
    "body": "<a id='comment:42'></a>\nLeif, I implemented the patch your way.  Not because I think it is better, but because I think there is a bug to be fixed.  I also rewrote the `Makefile` rule not to assume any particular behaviour for `spkg/pipestatus`.\n\nPlease review, I would like to merge this in 4.6.1.",
    "created_at": "2010-12-19T10:22:43Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99038",
    "user": "https://github.com/jdemeyer"
}
```

<a id='comment:42'></a>
Leif, I implemented the patch your way.  Not because I think it is better, but because I think there is a bug to be fixed.  I also rewrote the `Makefile` rule not to assume any particular behaviour for `spkg/pipestatus`.

Please review, I would like to merge this in 4.6.1.



---

archive/issue_comments_099039.json:
```json
{
    "body": "**Merged:** sage-4.6.1.rc0",
    "created_at": "2010-12-24T20:01:49Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99039",
    "user": "https://github.com/jdemeyer"
}
```

**Merged:** sage-4.6.1.rc0



---

archive/issue_comments_099040.json:
```json
{
    "body": "<a id='comment:44'></a>\nTo bring this (at least the ticket) to an end, **positive review** from me (as I am a co-author / have suggested most of the current changes ;-) ).\n\nIt's also clearly better to use an \"unambiguous\" call of `pipestatus` in the (top-level) `Makefile`. We could still add a note to `pipestatus`' usage message that it behaves as if\n\n```sh\nset -o pipefail; CMD1 | CMD2\n```\nwas issued at the shell prompt, as John suggested IIRC.\n\nUntil we drop support for Bashs < 3.0 ...\n\n(and/or *generate* the Makefiles, creating \"customized\" versions depending on the version of the shell found.)\n\nIn any case, it's better to not mess around with file descriptors that might already be used (i.e. use Bash's `PIPESTATUS` array instead, since we rely on `bash` anyway).\n\n---\n\nBecause `bash` **is** in fact a prerequisite for Sage, I still see no reason for not making a *contemporary* version of it a requirement. If people lacking one are unable to build/install it themselves from the GNU tarball, they can still install pre-built binaries, which AFAIK need not even be provided by Sage as there are already such packages available elsewhere.\n\nI wouldn't consider a shell a battery either, and we *do* care less about older / out-dated releases of *other* operating systems.\n\n---\n\nThe ticket's description should perhaps be updated to reflect the outcome.",
    "created_at": "2010-12-28T21:58:13Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99040",
    "user": "https://github.com/nexttime"
}
```

<a id='comment:44'></a>
To bring this (at least the ticket) to an end, **positive review** from me (as I am a co-author / have suggested most of the current changes ;-) ).

It's also clearly better to use an "unambiguous" call of `pipestatus` in the (top-level) `Makefile`. We could still add a note to `pipestatus`' usage message that it behaves as if

```sh
set -o pipefail; CMD1 | CMD2
```
was issued at the shell prompt, as John suggested IIRC.

Until we drop support for Bashs < 3.0 ...

(and/or *generate* the Makefiles, creating "customized" versions depending on the version of the shell found.)

In any case, it's better to not mess around with file descriptors that might already be used (i.e. use Bash's `PIPESTATUS` array instead, since we rely on `bash` anyway).

---

Because `bash` **is** in fact a prerequisite for Sage, I still see no reason for not making a *contemporary* version of it a requirement. If people lacking one are unable to build/install it themselves from the GNU tarball, they can still install pre-built binaries, which AFAIK need not even be provided by Sage as there are already such packages available elsewhere.

I wouldn't consider a shell a battery either, and we *do* care less about older / out-dated releases of *other* operating systems.

---

The ticket's description should perhaps be updated to reflect the outcome.



---

archive/issue_events_079087.json:
```json
{
    "actor": "https://github.com/nexttime",
    "created_at": "2010-12-28T21:58:13Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79087"
}
```



---

archive/issue_events_079088.json:
```json
{
    "actor": "https://github.com/nexttime",
    "created_at": "2010-12-28T21:58:13Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79088"
}
```



---

archive/issue_comments_099041.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -8,15 +8,4 @@\n \n Alternative 1 (for new versions of bash) does `A && (B | C)` while alternative 2 (for old versions of bash) does `(A && B) | C`.\n \n-In my opinion, there should be only one alternative.  If we have something which works for old versions, why not use that for new versions also?\n-\n-In any case, it would be good to think of a more robust implementation of pipestatus.  I can think of the following:\n-1. Write a simple C program using pipe(), fork(), exec(), wait().\n-2. Use the `mkfifo` command.\n-3. Use a temporary file:\n-\n-```\n-EXITSTATUS=/tmp/pipestatus$$     # Obviously, we should use TMPDIR if set\n-( A; echo $? >$EXITSTATUS ) | B\n-```\n-1. Use `bash`'s `PIPESTATUS` array.\n+The attached patch makes `pipestatus` behave like alternative 1 for *all* versions of `bash`.\n``````\n",
    "created_at": "2010-12-31T14:49:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99041",
    "user": "https://github.com/jdemeyer"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -8,15 +8,4 @@
 
 Alternative 1 (for new versions of bash) does `A && (B | C)` while alternative 2 (for old versions of bash) does `(A && B) | C`.
 
-In my opinion, there should be only one alternative.  If we have something which works for old versions, why not use that for new versions also?
-
-In any case, it would be good to think of a more robust implementation of pipestatus.  I can think of the following:
-1. Write a simple C program using pipe(), fork(), exec(), wait().
-2. Use the `mkfifo` command.
-3. Use a temporary file:
-
-```
-EXITSTATUS=/tmp/pipestatus$$     # Obviously, we should use TMPDIR if set
-( A; echo $? >$EXITSTATUS ) | B
-```
-1. Use `bash`'s `PIPESTATUS` array.
+The attached patch makes `pipestatus` behave like alternative 1 for *all* versions of `bash`.
``````




---

archive/issue_events_079089.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-31T14:49:23Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "positive review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79089"
}
```



---

archive/issue_events_079090.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2010-12-31T14:49:23Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79090"
}
```



---

archive/issue_comments_099042.json:
```json
{
    "body": "**Changing author** from \"Jeroen Demeyer\" to \"Jeroen Demeyer, Leif Leonhardy\".",
    "created_at": "2010-12-31T14:49:23Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99042",
    "user": "https://github.com/jdemeyer"
}
```

**Changing author** from "Jeroen Demeyer" to "Jeroen Demeyer, Leif Leonhardy".



---

archive/issue_comments_099043.json:
```json
{
    "body": "**Changing keywords** from \"pipestatus Makefile\" to \"pipestatus Makefile shell environment tee exit code status\".",
    "created_at": "2010-12-31T18:06:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99043",
    "user": "https://github.com/nexttime"
}
```

**Changing keywords** from "pipestatus Makefile" to "pipestatus Makefile shell environment tee exit code status".



---

archive/issue_comments_099044.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -1,4 +1,4 @@\n-spkg/pipestatus currently uses two different mechanisms, depending on the bash version.  Unfortunately, the two alternatives differ in behaviour (the consequence is an `install.log` file appearing in the wrong place).\n+`spkg/pipestatus` currently uses two different mechanisms, depending on the `bash` version (>=3.0 or not).  Unfortunately, the two alternatives currently differ in behaviour (the consequence in one case being an `install.log` file appearing in the wrong place).\n \n Consider a command\n \n@@ -6,6 +6,28 @@\n pipestatus \"A && B\" \"C\"\n ```\n \n-Alternative 1 (for new versions of bash) does `A && (B | C)` while alternative 2 (for old versions of bash) does `(A && B) | C`.\n+**Alternative 1** (for new versions of bash) does\n \n-The attached patch makes `pipestatus` behave like alternative 1 for *all* versions of `bash`.\n+```sh\n+A && (B | C)\n+```\n+(which is - without regard of the subshell environment - equivalent to the command list without parentheses, i.e. `A && B | C`, since the pipe symbol has higher precedence),\n+\n+\n+while **alternative 2** (for very old versions of bash) does\n+\n+```sh\n+(A && B) | C\n+```\n+\n+---\n+\n+The attached / merged patch makes `pipestatus` behave like **alternative 1** for *all* versions of `bash`, and executes all commands in the *same* environment.\n+\n+It also patches the top-level `Makefile` to no longer depend on (previously) varying behavior of `pipestatus` by changing a receipt to\n+\n+```sh\n+        cd some_dir && pipestatus \"A\" \"B\"\n+```\n+(where `A` and `B` are simple commands).\n+\n``````\n",
    "created_at": "2010-12-31T18:06:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99044",
    "user": "https://github.com/nexttime"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -1,4 +1,4 @@
-spkg/pipestatus currently uses two different mechanisms, depending on the bash version.  Unfortunately, the two alternatives differ in behaviour (the consequence is an `install.log` file appearing in the wrong place).
+`spkg/pipestatus` currently uses two different mechanisms, depending on the `bash` version (>=3.0 or not).  Unfortunately, the two alternatives currently differ in behaviour (the consequence in one case being an `install.log` file appearing in the wrong place).
 
 Consider a command
 
@@ -6,6 +6,28 @@
 pipestatus "A && B" "C"
 ```
 
-Alternative 1 (for new versions of bash) does `A && (B | C)` while alternative 2 (for old versions of bash) does `(A && B) | C`.
+**Alternative 1** (for new versions of bash) does
 
-The attached patch makes `pipestatus` behave like alternative 1 for *all* versions of `bash`.
+```sh
+A && (B | C)
+```
+(which is - without regard of the subshell environment - equivalent to the command list without parentheses, i.e. `A && B | C`, since the pipe symbol has higher precedence),
+
+
+while **alternative 2** (for very old versions of bash) does
+
+```sh
+(A && B) | C
+```
+
+---
+
+The attached / merged patch makes `pipestatus` behave like **alternative 1** for *all* versions of `bash`, and executes all commands in the *same* environment.
+
+It also patches the top-level `Makefile` to no longer depend on (previously) varying behavior of `pipestatus` by changing a receipt to
+
+```sh
+        cd some_dir && pipestatus "A" "B"
+```
+(where `A` and `B` are simple commands).
+
``````




---

archive/issue_comments_099045.json:
```json
{
    "body": "Apply on top of previous",
    "created_at": "2011-01-03T10:51:18Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99045",
    "user": "https://github.com/jdemeyer"
}
```

Apply on top of previous



---

archive/attachments_013540.json:
```json
{
    "asset_content_type": "application/octet-stream",
    "asset_name": "10339_authors_install.patch",
    "asset_url": "tarball://root/attachments/some-uuid/ticket10339/10339_authors_install.patch",
    "created_at": "2011-01-03T11:03:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "attachment",
    "url": "https://github.com/assets/some-id/some-uuid.patch",
    "user": "https://github.com/jdemeyer"
}
```



---

archive/issue_comments_099046.json:
```json
{
    "body": "",
    "created_at": "2011-01-03T11:03:33Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99046",
    "user": "https://github.com/jdemeyer"
}
```





---

archive/issue_events_079091.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-01-03T11:23:44Z",
    "event": "labeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79091"
}
```



---

archive/issue_comments_099047.json:
```json
{
    "body": "**Changing merged** from \"sage-4.6.1.rc0\" to \"\".",
    "created_at": "2011-01-03T11:23:44Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99047",
    "user": "https://github.com/jdemeyer"
}
```

**Changing merged** from "sage-4.6.1.rc0" to "".



---

archive/issue_events_079092.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-01-10T20:50:07Z",
    "event": "unlabeled",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "label": "needs review",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79092"
}
```



---

archive/issue_events_079093.json:
```json
{
    "actor": "https://github.com/jdemeyer",
    "created_at": "2011-01-10T20:50:07Z",
    "event": "closed",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_event",
    "url": "https://github.com/sagemath/sagetest/issues/10339#event-79093"
}
```



---

archive/issue_comments_099048.json:
```json
{
    "body": "**Merged:** sage-4.6.1.rc0",
    "created_at": "2011-01-10T20:50:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99048",
    "user": "https://github.com/jdemeyer"
}
```

**Merged:** sage-4.6.1.rc0



---

archive/issue_comments_099049.json:
```json
{
    "body": "**Description changed:**\n``````diff\n--- \n+++ \n@@ -31,3 +31,6 @@\n ```\n (where `A` and `B` are simple commands).\n \n+---\n+\n+Merged patches: [attachment:10339_pipestatus.v3.patch] and [attachment:10339_pipestatus.v3_spkg_install.patch]\n``````\n",
    "created_at": "2011-01-10T20:50:07Z",
    "issue": "https://github.com/sagemath/sagetest/issues/10339",
    "type": "issue_comment",
    "url": "https://github.com/sagemath/sagetest/issues/10339#issuecomment-99049",
    "user": "https://github.com/jdemeyer"
}
```

**Description changed:**
``````diff
--- 
+++ 
@@ -31,3 +31,6 @@
 ```
 (where `A` and `B` are simple commands).
 
+---
+
+Merged patches: [attachment:10339_pipestatus.v3.patch] and [attachment:10339_pipestatus.v3_spkg_install.patch]
``````

